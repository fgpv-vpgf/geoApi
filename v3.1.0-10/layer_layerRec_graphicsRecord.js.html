<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>layer/layerRec/graphicsRecord.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AttribFC.html">AttribFC</a><ul class='methods'><li data-type='method'><a href="AttribFC.html#.aliasedFieldNameDirect">aliasedFieldNameDirect</a></li><li data-type='method'><a href="AttribFC.html#.unAliasAttribs">unAliasAttribs</a></li><li data-type='method'><a href="AttribFC.html#aliasedFieldName">aliasedFieldName</a></li><li data-type='method'><a href="AttribFC.html#checkDateType">checkDateType</a></li><li data-type='method'><a href="AttribFC.html#getFormattedAttributes">getFormattedAttributes</a></li></ul></li><li><a href="AttribRecord.html">AttribRecord</a><ul class='methods'><li data-type='method'><a href="AttribRecord.html#aliasedFieldName">aliasedFieldName</a></li><li data-type='method'><a href="AttribRecord.html#attributesToDetails">attributesToDetails</a></li><li data-type='method'><a href="AttribRecord.html#checkDateType">checkDateType</a></li><li data-type='method'><a href="AttribRecord.html#getFormattedAttributes">getFormattedAttributes</a></li></ul></li><li><a href="BasicFC.html">BasicFC</a><ul class='methods'><li data-type='method'><a href="BasicFC.html#zoomToBoundary">zoomToBoundary</a></li></ul></li><li><a href="DynamicFC.html">DynamicFC</a></li><li><a href="DynamicRecord.html">DynamicRecord</a><ul class='methods'><li data-type='method'><a href="DynamicRecord.html#getChildProxy">getChildProxy</a></li></ul></li><li><a href="FakeEvent.html">FakeEvent</a></li><li><a href="FeatureRecord.html">FeatureRecord</a></li><li><a href="Filter.html">Filter</a></li><li><a href="GraphicsRecord.html">GraphicsRecord</a></li><li><a href="IdentifyResult.html">IdentifyResult</a></li><li><a href="ImageRecord.html">ImageRecord</a></li><li><a href="LayerInterface.html">LayerInterface</a></li><li><a href="LayerRecord.html">LayerRecord</a><ul class='methods'><li data-type='method'><a href="LayerRecord.html#onMouseOut">onMouseOut</a></li><li data-type='method'><a href="LayerRecord.html#onMouseOver">onMouseOver</a></li><li data-type='method'><a href="LayerRecord.html#validateProjection">validateProjection</a></li></ul></li><li><a href="PlaceholderFC.html">PlaceholderFC</a></li><li><a href="Root.html">Root</a></li><li><a href="TileRecord.html">TileRecord</a></li><li><a href="WmsFC.html">WmsFC</a></li><li><a href="WmsRecord.html">WmsRecord</a><ul class='methods'><li data-type='method'><a href="WmsRecord.html#identify">identify</a></li></ul></li></ul><h3>Tutorials</h3><ul><li><a href="tutorial-developer-guide.html">developer-guide</a></li><li><a href="tutorial-getting_started.html">getting_started</a></li></ul><h3>Global</h3><ul><li><a href="global.html#_addLine">_addLine</a></li><li><a href="global.html#_addMultiLine">_addMultiLine</a></li><li><a href="global.html#_addMultiPoint">_addMultiPoint</a></li><li><a href="global.html#_addPoint">_addPoint</a></li><li><a href="global.html#_addPolygon">_addPolygon</a></li><li><a href="global.html#_attribsAdded">_attribsAdded</a></li><li><a href="global.html#_isUrl">_isUrl</a></li><li><a href="global.html#_listToSymbology">_listToSymbology</a></li><li><a href="global.html#_stateChange">_stateChange</a></li><li><a href="global.html#_zoomToScaleSet">_zoomToScaleSet</a></li><li><a href="global.html#abortAttribLoad">abortAttribLoad</a></li><li><a href="global.html#addAttribListener">addAttribListener</a></li><li><a href="global.html#addFilterListener">addFilterListener</a></li><li><a href="global.html#addGeometry">addGeometry</a></li><li><a href="global.html#addHilight">addHilight</a></li><li><a href="global.html#addHoverListener">addHoverListener</a></li><li><a href="global.html#addListener">addListener</a></li><li><a href="global.html#addPin">addPin</a></li><li><a href="global.html#addStateListener">addStateListener</a></li><li><a href="global.html#aliasedFieldName">aliasedFieldName</a></li><li><a href="global.html#allComb">allComb</a></li><li><a href="global.html#allocateLayersToSections">allocateLayersToSections</a></li><li><a href="global.html#applyFilterToLayer">applyFilterToLayer</a></li><li><a href="global.html#areExtentsSame">areExtentsSame</a></li><li><a href="global.html#arrayBufferToString">arrayBufferToString</a></li><li><a href="global.html#arrayIntersect">arrayIntersect</a></li><li><a href="global.html#arrayToIn">arrayToIn</a></li><li><a href="global.html#assignIds">assignIds</a></li><li><a href="global.html#assignLayerSplits">assignLayerSplits</a></li><li><a href="global.html#attribsLoaded">attribsLoaded</a></li><li><a href="global.html#bindEvents">bindEvents</a></li><li><a href="global.html#cacheActiveKeys">cacheActiveKeys</a></li><li><a href="global.html#checkDateType">checkDateType</a></li><li><a href="global.html#checkProj">checkProj</a></li><li><a href="global.html#cleanRenderer">cleanRenderer</a></li><li><a href="global.html#cleanUpAttribs">cleanUpAttribs</a></li><li><a href="global.html#cleanUpFields">cleanUpFields</a></li><li><a href="global.html#clearAll">clearAll</a></li><li><a href="global.html#clearAllCaches">clearAllCaches</a></li><li><a href="global.html#clearCacheSet">clearCacheSet</a></li><li><a href="global.html#clearHilight">clearHilight</a></li><li><a href="global.html#clipExtentCoords">clipExtentCoords</a></li><li><a href="global.html#constructLayer">constructLayer</a></li><li><a href="global.html#convertImageToCanvas">convertImageToCanvas</a></li><li><a href="global.html#convertImagetoDataURL">convertImagetoDataURL</a></li><li><a href="global.html#crawlLayerInfos">crawlLayerInfos</a></li><li><a href="global.html#createAttribSet">createAttribSet</a></li><li><a href="global.html#createBasemap">createBasemap</a></li><li><a href="global.html#csvPeek">csvPeek</a></li><li><a href="global.html#dataSource">dataSource</a></li><li><a href="global.html#enforceBoundary">enforceBoundary</a></li><li><a href="global.html#enhanceRenderer">enhanceRenderer</a></li><li><a href="global.html#eventRaiser">eventRaiser</a></li><li><a href="global.html#extractFields">extractFields</a></li><li><a href="global.html#featureTypeToRenderer">featureTypeToRenderer</a></li><li><a href="global.html#fetchGraphic">fetchGraphic</a></li><li><a href="global.html#filterifyRenderer">filterifyRenderer</a></li><li><a href="global.html#findCandidates">findCandidates</a></li><li><a href="global.html#findClosestLOD">findClosestLOD</a></li><li><a href="global.html#findOptimalSplit">findOptimalSplit</a></li><li><a href="global.html#findZoomScale">findZoomScale</a></li><li><a href="global.html#fireEvent">fireEvent</a></li><li><a href="global.html#fitInto">fitInto</a></li><li><a href="global.html#generateLocalCanvas">generateLocalCanvas</a></li><li><a href="global.html#generatePlaceholderSymbology">generatePlaceholderSymbology</a></li><li><a href="global.html#generateServerImage">generateServerImage</a></li><li><a href="global.html#generateUUID">generateUUID</a></li><li><a href="global.html#generateWMSSymbology">generateWMSSymbology</a></li><li><a href="global.html#geomToGraphic">geomToGraphic</a></li><li><a href="global.html#getAttribs">getAttribs</a></li><li><a href="global.html#getCache">getCache</a></li><li><a href="global.html#getCacheKey">getCacheKey</a></li><li><a href="global.html#getChildName">getChildName</a></li><li><a href="global.html#getChildTree">getChildTree</a></li><li><a href="global.html#getCombinedSql">getCombinedSql</a></li><li><a href="global.html#getExtentFromJson">getExtentFromJson</a></li><li><a href="global.html#getFeatureCount">getFeatureCount</a></li><li><a href="global.html#getFeatureName">getFeatureName</a></li><li><a href="global.html#getFilterOIDs">getFilterOIDs</a></li><li><a href="global.html#getFormattedAttributes">getFormattedAttributes</a></li><li><a href="global.html#getGeomType">getGeomType</a></li><li><a href="global.html#getGraphicIcon">getGraphicIcon</a></li><li><a href="global.html#getGraphicsBoundingBox">getGraphicsBoundingBox</a></li><li><a href="global.html#getGraphicSymbol">getGraphicSymbol</a></li><li><a href="global.html#getLayerData">getLayerData</a></li><li><a href="global.html#getLayerType">getLayerType</a></li><li><a href="global.html#getLegendUrls">getLegendUrls</a></li><li><a href="global.html#getMapServerLegend">getMapServerLegend</a></li><li><a href="global.html#getNorthArrowAngle">getNorthArrowAngle</a></li><li><a href="global.html#getOidField">getOidField</a></li><li><a href="global.html#getProxy">getProxy</a></li><li><a href="global.html#getScaleRatio">getScaleRatio</a></li><li><a href="global.html#getScaleSet">getScaleSet</a></li><li><a href="global.html#getSql">getSql</a></li><li><a href="global.html#getSymbology">getSymbology</a></li><li><a href="global.html#getTooltipName">getTooltipName</a></li><li><a href="global.html#getUnboundGraphics">getUnboundGraphics</a></li><li><a href="global.html#getVisibility">getVisibility</a></li><li><a href="global.html#getVisibleScales">getVisibleScales</a></li><li><a href="global.html#getWMSLayerTitle">getWMSLayerTitle</a></li><li><a href="global.html#guessCSVfields">guessCSVfields</a></li><li><a href="global.html#hideLayers">hideLayers</a></li><li><a href="global.html#identify">identify</a></li><li><a href="global.html#initBasemaps">initBasemaps</a></li><li><a href="global.html#isActive">isActive</a></li><li><a href="global.html#isOffScale">isOffScale</a></li><li><a href="global.html#isQueryable">isQueryable</a></li><li><a href="global.html">isSpatialRefEqual</a></li><li><a href="global.html#layerLoaded">layerLoaded</a></li><li><a href="global.html#loadDataBatch">loadDataBatch</a></li><li><a href="global.html#loadSymbology">loadSymbology</a></li><li><a href="global.html#localProjectExtent">localProjectExtent</a></li><li><a href="global.html#localProjectGeometry">localProjectGeometry</a></li><li><a href="global.html#localProjectPoint">localProjectPoint</a></li><li><a href="global.html#makeBoundingBox">makeBoundingBox</a></li><li><a href="global.html#makeClickBuffer">makeClickBuffer</a></li><li><a href="global.html#makeGeoJsonLayer">makeGeoJsonLayer</a></li><li><a href="global.html#makeHilightLayer">makeHilightLayer</a></li><li><a href="global.html#makeLayerConfig">makeLayerConfig</a></li><li><a href="global.html#makeLayerInfo">makeLayerInfo</a></li><li><a href="global.html#makeLegend">makeLegend</a></li><li><a href="global.html#makeSafeExtent">makeSafeExtent</a></li><li><a href="global.html#makeSymbologyArray">makeSymbologyArray</a></li><li><a href="global.html#mapDefault">mapDefault</a></li><li><a href="global.html#mapServerLegendToRenderer">mapServerLegendToRenderer</a></li><li><a href="global.html#mapServerLegendToRendererAll">mapServerLegendToRendererAll</a></li><li><a href="global.html#mapServerToLocalLegend">mapServerToLocalLegend</a></li><li><a href="global.html#moveToOffsetExtent">moveToOffsetExtent</a></li><li><a href="global.html#newLayerPackage">newLayerPackage</a></li><li><a href="global.html#newProp">newProp</a></li><li><a href="global.html#normalizeProj">normalizeProj</a></li><li><a href="global.html#onError">onError</a></li><li><a href="global.html#onLoad">onLoad</a></li><li><a href="global.html#onMouseOut">onMouseOut</a></li><li><a href="global.html#onMouseOver">onMouseOver</a></li><li><a href="global.html#onUpdateEnd">onUpdateEnd</a></li><li><a href="global.html#onUpdateStart">onUpdateStart</a></li><li><a href="global.html#packLayersIntoExactSections">packLayersIntoExactSections</a></li><li><a href="global.html#packLayersIntoOptimalSections">packLayersIntoOptimalSections</a></li><li><a href="global.html#parseUrlIndex">parseUrlIndex</a></li><li><a href="global.html#predictFileUrlBuilder">predictFileUrlBuilder</a></li><li><a href="global.html#predictLayerUrl">predictLayerUrl</a></li><li><a href="global.html#projectGeojson">projectGeojson</a></li><li><a href="global.html#queryGeometryHelper">queryGeometryHelper</a></li><li><a href="global.html#raiseFilterEvent">raiseFilterEvent</a></li><li><a href="global.html#removeAttribListener">removeAttribListener</a></li><li><a href="global.html#removeFilterListener">removeFilterListener</a></li><li><a href="global.html#removeGeometry">removeGeometry</a></li><li><a href="global.html#removeHoverListener">removeHoverListener</a></li><li><a href="global.html#removeListener">removeListener</a></li><li><a href="global.html#removeStateListener">removeStateListener</a></li><li><a href="global.html#renderSymbologyIcon">renderSymbologyIcon</a></li><li><a href="global.html#renderSymbologyImage">renderSymbologyImage</a></li><li><a href="global.html#repokeEsriService">repokeEsriService</a></li><li><a href="global.html#resizeSVGElement">resizeSVGElement</a></li><li><a href="global.html#scrapeListRenderer">scrapeListRenderer</a></li><li><a href="global.html#searchRenderer">searchRenderer</a></li><li><a href="global.html#serverLayerIdentify">serverLayerIdentify</a></li><li><a href="global.html#serviceType">serviceType</a></li><li><a href="global.html#setCache">setCache</a></li><li><a href="global.html#setCustomParameter">setCustomParameter</a></li><li><a href="global.html#setDefinitionQuery">setDefinitionQuery</a></li><li><a href="global.html#setExtent">setExtent</a></li><li><a href="global.html#setMapScale">setMapScale</a></li><li><a href="global.html#setQueryable">setQueryable</a></li><li><a href="global.html#setSql">setSql</a></li><li><a href="global.html#setVisibility">setVisibility</a></li><li><a href="global.html#shiftZoom">shiftZoom</a></li><li><a href="global.html#showLayers">showLayers</a></li><li><a href="global.html#splitLayer">splitLayer</a></li><li><a href="global.html#sqlActiveFilters">sqlActiveFilters</a></li><li><a href="global.html#sqlAttributeFilter">sqlAttributeFilter</a></li><li><a href="global.html#sqlGraphicsVisibility">sqlGraphicsVisibility</a></li><li><a href="global.html#stringToArrayBuffer">stringToArrayBuffer</a></li><li><a href="global.html#svgDrawImage">svgDrawImage</a></li><li><a href="global.html#symbolToLegend">symbolToLegend</a></li><li><a href="global.html#synchOpacity">synchOpacity</a></li><li><a href="global.html#validateCSV">validateCSV</a></li><li><a href="global.html#validateFile">validateFile</a></li><li><a href="global.html#validateGeoJson">validateGeoJson</a></li><li><a href="global.html#validateLatLong">validateLatLong</a></li><li><a href="global.html#wrapEvents">wrapEvents</a></li><li><a href="global.html#zoomToBoundary">zoomToBoundary</a></li><li><a href="global.html#zoomToExtent">zoomToExtent</a></li><li><a href="global.html#zoomToGraphic">zoomToGraphic</a></li><li><a href="global.html#zoomToLatLong">zoomToLatLong</a></li><li><a href="global.html#zoomToScale">zoomToScale</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">layer/layerRec/graphicsRecord.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';

const layerInterface = require('./layerInterface.js')();
const root = require('./root.js')();
const shared = require('./shared.js')();

const geometryTypes = {
    POINT: 'Point',
    MULTIPOINT: 'MultiPoint',
    LINESTRING: 'LineString',
    MULTILINESTRING: 'MultiLineString',
    POLYGON: 'Polygon',
    MULTIPOLYGON: 'MultiPolygon'
}

const pointStyles = {
    CIRCLE: 'esriSMSCircle',
    CROSS: 'esriSMSCross',
    DIAMOND: 'esriSMSDiamond',
    SQUARE: 'esriSMSSquare',
    X: 'esriSMSX',
    TRIANGLE: 'esriSMSTriangle'
}
const lineStyles = {
    DASH: 'esriSLSDash',
    DASHDOT: 'esriSLSDashDot',
    DASHDOTDOT: 'esriSLSDashDotDot',
    DOT: 'esriSLSDot',
    NULL: 'esriSLSNull',
    SOLID: 'esriSLSSolid'
}
const fillStyles = {
    BDIAG: 'backwarddiagonal',
    CROSS: 'cross',
    DIAG_CROSS: 'diagonalcross',
    FDIAG: 'forwarddiagonal',
    HORIZONTAL: 'horizontal',
    NULL: 'none',
    SOLID: 'solid',
    VERTICAL: 'vertical'
}

const llSR = {
    wkid: 4326
}

/**
 * @class GraphicsRecord
 */
class GraphicsRecord extends root.Root {
    /**
     * Create a graphics layer record with the appropriate geoApi layer type.
     * TODO: possibly have an intermediate class between root and layerRecord to have all the duplicated items, such as hovertips.
     * TODO: add identify functionality and fix any other features that might need to be modified
     * @param {Object} esriBundle       bundle of API classes
     * @param {Object} apiRef           object pointing to the geoApi. allows us to call other geoApi functions.
     * @param {String} name             name and id of the layer.
     */
    constructor (esriBundle, apiRef, name) {
        super();

        this._bundle = esriBundle;
        this._apiRef = apiRef;
        this._layerClass = esriBundle.GraphicsLayer;
        this._name = name;
        this._id = name;
        this._layer = this._layerClass({ id: this._name });
        this.bindEvents(this._layer);
        this._hoverEvent = new shared.FakeEvent();
    }

    get layerId () { return this._id; }

    get name () { return this._name; }
    set name (value) {
        this._name = value;
        this._id = value;
    }

    get layerType () { return shared.clientLayerType.ESRI_GRAPHICS; }

    get visibility () {
        if (this._layer) {
            return this._layer.visible;
        } else {
            return true; // TODO what should a proper default be? example of this situation??
        }
    }
    set visibility (value) {
        if (this._layer) {
            this._layer.setVisibility(value);
        }

        // TODO do we need an ELSE case here?
    }

    get opacity () {
        if (this._layer) {
            return this._layer.opacity;
        } else {
            return 1; // TODO what should a proper default be? example of this situation??
        }
    }
    set opacity (value) {
        if (this._layer) {
            this._layer.setOpacity(value);
        }

        // TODO do we need an ELSE case here?
    }

    // use of the following property is unsupported by ramp team.
    // it is provided for plugin developers who want to write advanced geo functions
    // and wish to directly consume the esri api objects AT THEIR OWN RISK !!!  :'O  !!!
    get esriLayer () { return this._layer; }

    /**
     * Attach record event handlers to common layer events
     *
     * @function bindEvents
     * @param {Object} layer the api layer object
     */
    bindEvents (layer) {
        // TODO optional refactor.  Rather than making the events object in the parameter,
        //      do it as a variable, and only add mouse-over, mouse-out events if we are
        //      in an app configuration that will use it. May save a bit of processing
        //      by not having unused events being handled and ignored.
        //      Second optional thing. Call a separate wrapEvents in FeatuerRecord class
        // TODO apply johann update here
        this._apiRef.events.wrapEvents(layer, {
            // wrapping the function calls to keep `this` bound correctly
            'mouse-over': e => this.onMouseOver(e),
            'mouse-out': e => this.onMouseOut(e)
        });
    }

    /**
     * Wire up mouse hover listener.
     *
     * @function addHoverListener
     * @param {Function} listenerCallback function to call when a hover event happens
     */
    addHoverListener (listenerCallback) {
        return this._hoverEvent.addListener(listenerCallback);
    }

    /**
     * Remove a mouse hover listener.
     *
     * @function removeHoverListener
     * @param {Function} listenerCallback function to not call when a hover event happens
     */
    removeHoverListener (listenerCallback) {
        this._hoverEvent.removeListener(listenerCallback);
    }

    /**
     * Provides the proxy interface object to the layer.
     *
     * @function getProxy
     * @returns {Object} the proxy interface for the layer
     */
    getProxy () {
        if (!this._rootProxy) {
            this._rootProxy = new layerInterface.LayerInterface(this);
            this._rootProxy.convertToGraphicsLayer(this);
        }
        return this._rootProxy;
    }

    /**
     * Triggers when the mouse enters a feature of the layer.
     *
     * @function onMouseOver
     * @param {Object} standard mouse event object
     */
    onMouseOver (e) {
        const showBundle = {
            type: 'mouseOver',
            point: e.screenPoint,
            target: e.target,
            graphic: e.graphic
        };

        // tell anyone listening we moused into something
        this._hoverEvent.fireEvent(showBundle);
    }

    /**
     * Triggers when the mouse leaves a feature of the layer.
     *
     * @function onMouseOut
     * @param {Object} standard mouse event object
     */
    onMouseOut (e) {
        // tell anyone listening we moused out
        const outBundle = {
            type: 'mouseOut',
            target: e.target
        };
        this._hoverEvent.fireEvent(outBundle);
    }

    /**
     * Identify the type of geometry being added and add it to the map.
     *
     * @function addGeometry
     * @param {Object|Array} geo                  api geometry class to be added
     * @param {Object} spatialReference          the projection the graphics should be in
     */
    addGeometry(geo, spatialReference) {
        // for each geometry, figure out what type it is, massage the data
        // to a format that our internal libraries can use, then call the
        // appropriate _add function to get it on the map.

        const geometries = Array.isArray(geo) ? geo : [ geo ];

        geometries.forEach(geometry => {
            const id = geometry.id;
            const geomArray = geometry.toArray();
            if (geometry.type === geometryTypes.POINT) {
                const icon = geometry.styleOptions.icon;
                this._addPoint(geomArray, spatialReference, icon, id, geometry.styleOptions);
            } else if (geometry.type === geometryTypes.MULTIPOINT) {
                const icon = geometry.styleOptions.icon;
                this._addMultiPoint(geomArray, spatialReference, icon, id, geometry.styleOptions);
            } else if (geometry.type === geometryTypes.LINESTRING) {
                this._addLine(geomArray, spatialReference, id, geometry.styleOptions);
            } else if (geometry.type === geometryTypes.MULTILINESTRING) {
                this._addMultiLine(geomArray, spatialReference, id, geometry.styleOptions);
            } else if (geometry.type === geometryTypes.POLYGON) {

                this._addPolygon(geomArray, spatialReference, id, geometry.styleOptions);
            } else if (geometry.type === geometryTypes.MULTIPOLYGON) {
                // the esri js api doesnt have a concept of multipolygon, so we combine all the polygons
                // in the geometry to be one polygon (all the separate parts are treated as rings)
                const rings = [].concat.apply([], geomArray);

                // addPolygon functions works for MultiPolygon as well, since we set up the rings in the proper format
                this._addPolygon(rings, spatialReference, id, geometry.styleOptions);
            }
        });
    }

    /**
     * Add a point where specified using longitute and latitute.
     *
     * @function _addPoint
     * @private
     * @param {Object} coords                    the long and lat to use as the graphic location
     * @param {Object} spatialReference          the desired projection the graphics should be in
     * @param {String} icon                      data / image url or svg path for layer icon. defaults to a red point
     * @param {String} id                        id of api geometry being added to map
     * @param {Object} opts                      options to apply to point
     */
    _addPoint(coords, spatialReference, icon, id, opts) {
        const projPt = this._apiRef.proj.localProjectPoint(llSR, spatialReference, coords);
        const point = new this._bundle.Point({
            x: projPt[0],
            y: projPt[1],
            spatialReference
        });

        let symbol, marker;
        if (opts.style === 'ICON') {
            if (this._isUrl(icon)) {
                // TODO: discuss how to handle the width / height issue when passing in an icon
                symbol = new this._bundle.PictureMarkerSymbol(icon, opts.width, opts.height);
                symbol.setOffset(opts.xOffset, opts.yOffset);
            } else {
                symbol = new this._bundle.SimpleMarkerSymbol();
                symbol.setPath(icon);
                symbol.setColor(opts.colour);
                symbol.setSize(opts.width);
                symbol.setOffset(opts.xOffset, opts.yOffset);
            }
            marker = new this._bundle.Graphic(point, symbol);
        } else {
            const options = {
                color: opts.colour,
                size: opts.width,
                xoffset: opts.xOffset,
                yoffset: opts.yOffset,
                type: 'esriSMS',
                style: pointStyles[opts.style],
                outline: {
                    color: [0, 0, 0],
                    width: 1,
                    type: 'esriSLS',
                    style: 'esriSLSSolid'
                }
            }
            symbol = new this._bundle.SimpleMarkerSymbol(options);
            marker = new this._bundle.Graphic(point, symbol);
        }

        marker.geometry.apiId = id;
        marker.geometry.geomType = "esriGeometryPoint"; // trickery for the zooming
        this._layer.add(marker);
    }

    /**
     * Add multiple points where specified using the longitutes and latitutes.
     *
     * @function _addMultiPoint
     * @private
     * @param {Array} coords                     a 3D array of long and lat to use as the graphic location for each point
     * @param {Object} spatialReference          the desired projection the graphics should be in
     * @param {String} icon                      data / image url or svg path for layer icon. defaults to a green point
     * @param {String} id                        id of api geometry being added to map
     * @param {Object} opts                      options to apply to points
     */
    _addMultiPoint(coords, spatialReference, icon, id, opts) {
        const llPoints =  new this._bundle.Multipoint({
            points: coords,
            spatialReference: llSR
        });

        const projPoints = this._apiRef.proj.localProjectGeometry(spatialReference, llPoints);
        const points = new this._bundle.Multipoint(projPoints);

        let symbol, marker;
        if (opts.style === 'ICON') {
            if (this._isUrl(icon)) {
                // TODO: discuss how to handle the width / height issue when passing in an icon
                symbol = new this._bundle.PictureMarkerSymbol(icon, 16.5, 16.5);
            } else {
                symbol = new this._bundle.SimpleMarkerSymbol();
                symbol.setPath(icon);
                symbol.setColor([255, 0, 0]);
                symbol.setSize('auto');
            }
            marker = new this._bundle.Graphic(points, symbol);
        } else {
            const options = {
                color: opts.colour,
                size: opts.width,
                xoffset: opts.xOffset,
                yoffset: opts.yOffset,
                type: 'esriSMS',
                style: pointStyles[opts.style],
                outline: {
                    color: [0, 0, 0],
                    width: 1,
                    type: 'esriSLS',
                    style: 'esriSLSSolid'
                }
            }
            symbol = new this._bundle.SimpleMarkerSymbol(options);
            marker = new this._bundle.Graphic(points, symbol);
        }

        marker.geometry.apiId = id;
        this._layer.add(marker);
    }

    /**
     * Add a line where specified using the path of longitutes and latitutes.
     *
     * @function _addLine
     * @private
     * @param {Array} path                       an array of long and lat to use as the path for the line
     * @param {Object} spatialReference          the desired projection the graphics should be in
     * @param {String} id                        id of api geometry being added to map
     * @param {Object} opts                      options to apply to line
     */
    _addLine(path, spatialReference, id, opts) {
        this._addMultiLine([path], spatialReference, id, opts);
    }

    /**
     * Add multiple lines where specified using the path of longitutes and latitutes.
     *
     * @function _addMultiLine
     * @private
     * @param {Array} paths                      a 3D array of long and lat to use as the paths for the lines
     * @param {Object} spatialReference          the desired projection the graphics should be in
     * @param {String} id                        id of api geometry being added to map
     * @param {Object} opts                      options to apply to lines
     */
    _addMultiLine(paths, spatialReference, id, opts) {
        const llLine = new this._bundle.Polyline({
            paths: paths,
            spatialReference: llSR
        });

        const projLine = this._apiRef.proj.localProjectGeometry(spatialReference, llLine);
        const lines = new this._bundle.Polyline(projLine);

        const symbol = {
            width: opts.width,
            type: 'esriSLS',
            color: opts.colour,
            style: opts.style,
            outline: {
                color: [0, 0, 0],
                width: 1,
                type: 'esriSLS',
                style: 'esriSLSSolid'
            }
        }
        const marker = new this._bundle.Graphic({ symbol: symbol });
        marker.setGeometry(lines);

        marker.geometry.apiId = id;
        this._layer.add(marker);
    }

    /**
     * Add a polygon where specified using the rings provided.
     *
     * @function _addPolygon
     * @private
     * @param {Array} rings                      an array of rings containing an array of long-lat coordinates
     * @param {Object} spatialReference          the desired projection the graphics should be in
     * @param {String} id                        id of api geometry being added to map
     * @param {Object} opts                      settings such as color and opacity for the polygon
     */
    _addPolygon(rings, spatialReference, id, opts) {
        const llPoly = new this._bundle.Polygon({
            rings,
            spatialReference: llSR
        });

        const projPoly = this._apiRef.proj.localProjectGeometry(spatialReference, llPoly);
        const polygon = new this._bundle.Polygon(projPoly);

        const lineSymbol = new this._bundle.SimpleLineSymbol();
        lineSymbol.setColor(opts.outlineColor);
        lineSymbol.setWidth(opts.outlineWidth);
        lineSymbol.setStyle(lineStyles[opts.outlineStyle]);

        const fillColor = new this._bundle.Color(opts.fillColor);
        fillColor.a = opts.fillOpacity;

        const fillSymbol = new this._bundle.SimpleFillSymbol();
        fillSymbol.setStyle(fillStyles[opts.fillStyle]);
        fillSymbol.setColor(fillColor);
        fillSymbol.setOutline(lineSymbol);

        const marker = new this._bundle.Graphic(polygon, fillSymbol);

        marker.geometry.apiId = id;
        this._layer.add(marker);
    }

    /**
     * Remove the specified graphic.
     *
     * @function removeGeometry
     * @param {Number} index      index of the graphic to remove from the layer
     */
    removeGeometry(index) {
        const graphic = this._layer.graphics[index];
        this._layer.remove(graphic);
    };

    /**
     * Check to see if text provided is a valid image / data URL based on extension type or format.
     *
     * @function _isUrl
     * @private
     * @param {String} text                      string to be matched against valid image types / data url format
     * @returns {Boolean}                        true if valid image extension
     */
    _isUrl(text) {
        return !!text.match(/\.(jpeg|jpg|gif|png|swf|svg)$/) ||
            !!text.match(/^\s*data:([a-z]+\/[a-z]+(;[a-z\-]+\=[a-z\-]+)?)?(;base64)?,[a-z0-9\!\$\&amp;\'\,\(\)\*\+\,\;\=\-\.\_\~\:\@\/\?\%\s]*\s*$/i);
    }

    /**
     * Return the extent of an array of graphics.
     *
     * @function getGraphicsBoundingBox
     * @param {Array&lt;Graphic>} graphics      the graphics whose bounding box we want to calculate
     * @returns {Object}                     the extent of an array of graphics
     */
    getGraphicsBoundingBox(graphics) {
        return this._apiRef.proj.graphicsUtils.graphicsExtent(graphics);
    };

    /**
     * Will attempt to zoom the map view so the a graphic is prominent.
     *
     * @function zoomToGraphic
     * @param  {String} apiId           API ID of grahpic being searched for. This is a string name from api, not an esri OID.
     * @param  {Object} map             wrapper object for the map we want to zoom
     * @param {Object} offsetFraction   an object with decimal properties `x` and `y` indicating percentage of offsetting on each axis
     * @return {Promise}                resolves after the map is done moving
     */
    zoomToGraphic (apiId, map, offsetFraction) {

        // TODO this is a hacky re-write of the standard attribFC.zoomToGraphic.
        // we need a function quickly, so doing it this way.
        // the proper way would be to build in a nice zoom to graphic as part of
        // the api, and clean up the logic here or somehow merge logic with attribFC (a larger task)

        // find graphic by api id
        const targGraphic = this._layer.graphics.find(g => g.geometry.apiId === apiId);

        if (targGraphic) {
            const gapi = this._apiRef;

            // we know graphic is real graphic, and in map projection.
            // we also assume there is no scale level dependency to worry about.

            const extent = gapi.proj.graphicsUtils.graphicsExtent([targGraphic]);

            let geomZoomPromise;
            if (targGraphic.geometry.geomType === 'esriGeometryPoint') {
                // zoom to point at a decent scale for hilighting a point
                const sweetLod = gapi.Map.findClosestLOD(map.lods, 50000);
                geomZoomPromise = map.centerAndZoom(extent.getCenter(), Math.max(sweetLod.level, 0));
            } else {
                // zoom to the extent of the geometery
                geomZoomPromise = map.setExtent(extent, true);
            }

            return geomZoomPromise.then(() => {
                // we have zoomed to our graphic. now position our map
                return map.moveToOffsetExtent(extent, offsetFraction);
            });

        } else {
            // TODO handle error correctly
            console.warn(`could not find graphic ${apiId}`);
            return Promise.resolve();
        }
    }
}

module.exports = () => ({
    GraphicsRecord
});
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Mon Aug 12 2019 18:59:42 GMT+0000 (UTC) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
