<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>legend.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AttribFC.html">AttribFC</a><ul class='methods'><li data-type='method'><a href="AttribFC.html#.aliasedFieldNameDirect">aliasedFieldNameDirect</a></li><li data-type='method'><a href="AttribFC.html#.unAliasAttribs">unAliasAttribs</a></li><li data-type='method'><a href="AttribFC.html#aliasedFieldName">aliasedFieldName</a></li><li data-type='method'><a href="AttribFC.html#checkDateType">checkDateType</a></li><li data-type='method'><a href="AttribFC.html#getFormattedAttributes">getFormattedAttributes</a></li></ul></li><li><a href="AttribRecord.html">AttribRecord</a><ul class='methods'><li data-type='method'><a href="AttribRecord.html#aliasedFieldName">aliasedFieldName</a></li><li data-type='method'><a href="AttribRecord.html#attributesToDetails">attributesToDetails</a></li><li data-type='method'><a href="AttribRecord.html#checkDateType">checkDateType</a></li><li data-type='method'><a href="AttribRecord.html#getFormattedAttributes">getFormattedAttributes</a></li></ul></li><li><a href="BasicFC.html">BasicFC</a><ul class='methods'><li data-type='method'><a href="BasicFC.html#zoomToBoundary">zoomToBoundary</a></li></ul></li><li><a href="DynamicFC.html">DynamicFC</a></li><li><a href="DynamicRecord.html">DynamicRecord</a><ul class='methods'><li data-type='method'><a href="DynamicRecord.html#getChildProxy">getChildProxy</a></li></ul></li><li><a href="FeatureRecord.html">FeatureRecord</a></li><li><a href="GraphicsRecord.html">GraphicsRecord</a></li><li><a href="IdentifyResult.html">IdentifyResult</a></li><li><a href="ImageRecord.html">ImageRecord</a></li><li><a href="LayerInterface.html">LayerInterface</a></li><li><a href="LayerRecord.html">LayerRecord</a><ul class='methods'><li data-type='method'><a href="LayerRecord.html#onMouseOut">onMouseOut</a></li><li data-type='method'><a href="LayerRecord.html#onMouseOver">onMouseOver</a></li><li data-type='method'><a href="LayerRecord.html#validateProjection">validateProjection</a></li></ul></li><li><a href="PlaceholderFC.html">PlaceholderFC</a></li><li><a href="Root.html">Root</a></li><li><a href="TileRecord.html">TileRecord</a></li><li><a href="WmsFC.html">WmsFC</a></li><li><a href="WmsRecord.html">WmsRecord</a><ul class='methods'><li data-type='method'><a href="WmsRecord.html#identify">identify</a></li></ul></li></ul><h3>Tutorials</h3><ul><li><a href="tutorial-developer-guide.html">developer-guide</a></li><li><a href="tutorial-getting_started.html">getting_started</a></li></ul><h3>Global</h3><ul><li><a href="global.html#_addPoint">_addPoint</a></li><li><a href="global.html#_attribsAdded">_attribsAdded</a></li><li><a href="global.html#_fireEvent">_fireEvent</a></li><li><a href="global.html#_listToSymbology">_listToSymbology</a></li><li><a href="global.html#_stateChange">_stateChange</a></li><li><a href="global.html#_zoomToScaleSet">_zoomToScaleSet</a></li><li><a href="global.html#abortAttribLoad">abortAttribLoad</a></li><li><a href="global.html#addAttribListener">addAttribListener</a></li><li><a href="global.html#addGeometry">addGeometry</a></li><li><a href="global.html#addHilight">addHilight</a></li><li><a href="global.html#addHoverListener">addHoverListener</a></li><li><a href="global.html#addPin">addPin</a></li><li><a href="global.html#addStateListener">addStateListener</a></li><li><a href="global.html#aliasedFieldName">aliasedFieldName</a></li><li><a href="global.html#allComb">allComb</a></li><li><a href="global.html#allocateLayersToSections">allocateLayersToSections</a></li><li><a href="global.html#arrayBufferToString">arrayBufferToString</a></li><li><a href="global.html#assignIds">assignIds</a></li><li><a href="global.html#assignLayerSplits">assignLayerSplits</a></li><li><a href="global.html#attribsLoaded">attribsLoaded</a></li><li><a href="global.html#bindEvents">bindEvents</a></li><li><a href="global.html#checkDateType">checkDateType</a></li><li><a href="global.html#checkProj">checkProj</a></li><li><a href="global.html#cleanRenderer">cleanRenderer</a></li><li><a href="global.html#cleanUpAttribs">cleanUpAttribs</a></li><li><a href="global.html#cleanUpFields">cleanUpFields</a></li><li><a href="global.html#clearHilight">clearHilight</a></li><li><a href="global.html#clipExtentCoords">clipExtentCoords</a></li><li><a href="global.html#constructLayer">constructLayer</a></li><li><a href="global.html#convertImageToCanvas">convertImageToCanvas</a></li><li><a href="global.html#convertImagetoDataURL">convertImagetoDataURL</a></li><li><a href="global.html#crawlLayerInfos">crawlLayerInfos</a></li><li><a href="global.html#createAttribSet">createAttribSet</a></li><li><a href="global.html#csvPeek">csvPeek</a></li><li><a href="global.html#enforceBoundary">enforceBoundary</a></li><li><a href="global.html#enhanceRenderer">enhanceRenderer</a></li><li><a href="global.html#extractFields">extractFields</a></li><li><a href="global.html#featureTypeToRenderer">featureTypeToRenderer</a></li><li><a href="global.html#fetchGraphic">fetchGraphic</a></li><li><a href="global.html#filterifyRenderer">filterifyRenderer</a></li><li><a href="global.html#findCandidates">findCandidates</a></li><li><a href="global.html#findClosestLOD">findClosestLOD</a></li><li><a href="global.html#findOptimalSplit">findOptimalSplit</a></li><li><a href="global.html#findZoomScale">findZoomScale</a></li><li><a href="global.html#fitInto">fitInto</a></li><li><a href="global.html#generateLocalCanvas">generateLocalCanvas</a></li><li><a href="global.html#generatePlaceholderSymbology">generatePlaceholderSymbology</a></li><li><a href="global.html#generateServerImage">generateServerImage</a></li><li><a href="global.html#generateUUID">generateUUID</a></li><li><a href="global.html#generateWMSSymbology">generateWMSSymbology</a></li><li><a href="global.html#geomToGraphic">geomToGraphic</a></li><li><a href="global.html#getAttribs">getAttribs</a></li><li><a href="global.html#getChildName">getChildName</a></li><li><a href="global.html#getChildTree">getChildTree</a></li><li><a href="global.html#getExtentFromJson">getExtentFromJson</a></li><li><a href="global.html#getFeatureCount">getFeatureCount</a></li><li><a href="global.html#getFeatureName">getFeatureName</a></li><li><a href="global.html#getFormattedAttributes">getFormattedAttributes</a></li><li><a href="global.html#getGeomType">getGeomType</a></li><li><a href="global.html#getGraphicIcon">getGraphicIcon</a></li><li><a href="global.html#getGraphicSymbol">getGraphicSymbol</a></li><li><a href="global.html#getLayerData">getLayerData</a></li><li><a href="global.html#getLayerType">getLayerType</a></li><li><a href="global.html#getLegendUrls">getLegendUrls</a></li><li><a href="global.html#getMapServerLegend">getMapServerLegend</a></li><li><a href="global.html#getNorthArrowAngle">getNorthArrowAngle</a></li><li><a href="global.html#getOidField">getOidField</a></li><li><a href="global.html#getProxy">getProxy</a></li><li><a href="global.html#getScaleRatio">getScaleRatio</a></li><li><a href="global.html#getScaleSet">getScaleSet</a></li><li><a href="global.html#getSymbology">getSymbology</a></li><li><a href="global.html#getUnboundGraphics">getUnboundGraphics</a></li><li><a href="global.html#getVisibility">getVisibility</a></li><li><a href="global.html#getVisibleScales">getVisibleScales</a></li><li><a href="global.html#getWMSLayerTitle">getWMSLayerTitle</a></li><li><a href="global.html#guessCSVfields">guessCSVfields</a></li><li><a href="global.html#hideLayers">hideLayers</a></li><li><a href="global.html#identify">identify</a></li><li><a href="global.html#initBasemaps">initBasemaps</a></li><li><a href="global.html#isFileLayer">isFileLayer</a></li><li><a href="global.html#isOffScale">isOffScale</a></li><li><a href="global.html#isQueryable">isQueryable</a></li><li><a href="global.html">isSpatialRefEqual</a></li><li><a href="global.html#layerLoaded">layerLoaded</a></li><li><a href="global.html#loadDataBatch">loadDataBatch</a></li><li><a href="global.html#loadSymbology">loadSymbology</a></li><li><a href="global.html#localProjectExtent">localProjectExtent</a></li><li><a href="global.html#localProjectGeometry">localProjectGeometry</a></li><li><a href="global.html#localProjectPoint">localProjectPoint</a></li><li><a href="global.html#makeBoundingBox">makeBoundingBox</a></li><li><a href="global.html#makeClickBuffer">makeClickBuffer</a></li><li><a href="global.html#makeGeoJsonLayer">makeGeoJsonLayer</a></li><li><a href="global.html#makeHilightLayer">makeHilightLayer</a></li><li><a href="global.html#makeLayerConfig">makeLayerConfig</a></li><li><a href="global.html#makeLayerInfo">makeLayerInfo</a></li><li><a href="global.html#makeLegend">makeLegend</a></li><li><a href="global.html#makeSafeExtent">makeSafeExtent</a></li><li><a href="global.html#makeSymbologyArray">makeSymbologyArray</a></li><li><a href="global.html#mapDefault">mapDefault</a></li><li><a href="global.html#mapServerLegendToRenderer">mapServerLegendToRenderer</a></li><li><a href="global.html#mapServerLegendToRendererAll">mapServerLegendToRendererAll</a></li><li><a href="global.html#mapServerToLocalLegend">mapServerToLocalLegend</a></li><li><a href="global.html#moveToOffsetExtent">moveToOffsetExtent</a></li><li><a href="global.html#newLayerPackage">newLayerPackage</a></li><li><a href="global.html#newProp">newProp</a></li><li><a href="global.html#normalizeProj">normalizeProj</a></li><li><a href="global.html#onError">onError</a></li><li><a href="global.html#onLoad">onLoad</a></li><li><a href="global.html#onMouseOut">onMouseOut</a></li><li><a href="global.html#onMouseOver">onMouseOver</a></li><li><a href="global.html#onUpdateEnd">onUpdateEnd</a></li><li><a href="global.html#onUpdateStart">onUpdateStart</a></li><li><a href="global.html#packLayersIntoExactSections">packLayersIntoExactSections</a></li><li><a href="global.html#packLayersIntoOptimalSections">packLayersIntoOptimalSections</a></li><li><a href="global.html#parseUrlIndex">parseUrlIndex</a></li><li><a href="global.html#predictFileUrlBuilder">predictFileUrlBuilder</a></li><li><a href="global.html#predictLayerUrl">predictLayerUrl</a></li><li><a href="global.html#projectGeojson">projectGeojson</a></li><li><a href="global.html#removeAttribListener">removeAttribListener</a></li><li><a href="global.html#removeGeometry">removeGeometry</a></li><li><a href="global.html#removeHoverListener">removeHoverListener</a></li><li><a href="global.html#removeStateListener">removeStateListener</a></li><li><a href="global.html#renderSymbologyIcon">renderSymbologyIcon</a></li><li><a href="global.html#renderSymbologyImage">renderSymbologyImage</a></li><li><a href="global.html#repokeEsriService">repokeEsriService</a></li><li><a href="global.html#resizeSVGElement">resizeSVGElement</a></li><li><a href="global.html#scrapeListRenderer">scrapeListRenderer</a></li><li><a href="global.html#searchRenderer">searchRenderer</a></li><li><a href="global.html#serverLayerIdentify">serverLayerIdentify</a></li><li><a href="global.html#serviceType">serviceType</a></li><li><a href="global.html#setDefinitionQuery">setDefinitionQuery</a></li><li><a href="global.html#setMapScale">setMapScale</a></li><li><a href="global.html#setQueryable">setQueryable</a></li><li><a href="global.html#setVisibility">setVisibility</a></li><li><a href="global.html#shiftZoom">shiftZoom</a></li><li><a href="global.html#showLayers">showLayers</a></li><li><a href="global.html#splitLayer">splitLayer</a></li><li><a href="global.html#svgDrawImage">svgDrawImage</a></li><li><a href="global.html#symbolToLegend">symbolToLegend</a></li><li><a href="global.html#synchOpacity">synchOpacity</a></li><li><a href="global.html#validateCSV">validateCSV</a></li><li><a href="global.html#validateFile">validateFile</a></li><li><a href="global.html#validateGeoJson">validateGeoJson</a></li><li><a href="global.html#validateLatLong">validateLatLong</a></li><li><a href="global.html#wrapEvents">wrapEvents</a></li><li><a href="global.html#zoomToBoundary">zoomToBoundary</a></li><li><a href="global.html#zoomToExtent">zoomToExtent</a></li><li><a href="global.html#zoomToGraphic">zoomToGraphic</a></li><li><a href="global.html#zoomToLatLong">zoomToLatLong</a></li><li><a href="global.html#zoomToScale">zoomToScale</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">legend.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';
const TOO_MANY_LAYERS = 15;

// This file relates to legends on an exported map, not legends in the layer selector

/**
 * Generate all permutations of length M, with exactly N `true` values.
 *
 * @function
 * @param {int} M the size of the array (must be greater than 0)
 * @param {int} N the number of entries which should be true (must not be greater than M)
 * @return an array containing all possible size M arrays of boolean values with N true entries
 */
function allComb(M, N) {
    const maxTrue = N;
    const maxFalse = M - N;
    const C = [[[[]]]]; // C[m][n] is the solution to all_comb(m,n), C[0][0] starts with an empty array
    for (let m = 1; m &lt;= M; ++m) {
        C[m] = [];
        for (let n = 0; n &lt;= m; ++n) {
            // if this would place more than the max number of true or false values we don't need this part of the array
            if (n > maxTrue || (m - n) > maxFalse) { continue; }

            const a = n > 0 ? C[m - 1][n - 1].map(x => x.concat(true)) : [];
            const b = m > n ? C[m - 1][n].map(x => x.concat(false)) : [];

            C[m][n] = a.concat(b);
        }
    }
    return C[M][N];
}

/**
 * Convenience function for assigning the `splitBefore` property on layers at specified points.
 * NOTE: this function modifies data in place
 * @function
 * @private
 * @param {Array} layers a list of layers to be updated (modified in place)
 * @param {Array} splitPoints an array of boolean values indicating if the layer list should be split at that point (must be layers.length-1 in size)
 * @return layers the same array as passed in
 */
function assignLayerSplits(layers, splitPoints) {
    layers[0].splitBefore = false;
    splitPoints.forEach((split, i) => layers[i + 1].splitBefore = split);
    return layers;
}

/**
 * Groups multiple layers into each section while attempting to minimize the legend height.
 * Allocates to the exact number specified in the `sections` argument.
 * NOTE: don't call this with too many layers as it tests all possible groupings and can be
 * computationally expensive (&lt; 15 layers should be fine)
 * @function
 * @private
 * @param {Array} layers a list of layers to be fitted
 * @param {int} sections the number of sections to use
 * @return {Object} an object in the form { layers, sectionsUsed, bestPerm, bestHeight }
 */
function packLayersIntoExactSections(layers, sections) {
    const potentialSplits = layers.length - 1;
    const requiredSplits = sections - 1;

    const permutations = allComb(potentialSplits, requiredSplits);
    let bestHeight = Number.MAX_VALUE;
    let bestPerm = null;
    const heights = Array(sections);

    permutations.forEach(perm => {
        heights.fill(0);
        let curSec = 0;
        layers.forEach((l, i) => {
            heights[curSec] += l.height;
            if (perm[i]) {
                ++curSec;
            }
        });
        const h = Math.max(...heights);
        if (h &lt;= bestHeight) {
            bestHeight = h;
            bestPerm = perm;
        }
    });
    return { layers, sectionsUsed: sections, bestPerm, bestHeight };
}

/**
 * Groups multiple layers into each section while attempting to minimize the legend height.
 * Repeats as necessary to use the least number of sections while still keeping the resulting
 * legend height within 20% of optimal.
 * NOTE: don't call this with too many layers as it tests all possible groupings and can be
 * computationally expensive (&lt; 15 layers should be fine)
 * @function
 * @private
 * @param {Array} layers a list of layers to be updated (modified in place)
 * @param {int} sections the number of sections to use
 * @return {Object} an object in the form { layers, sectionsUsed }
 */
function packLayersIntoOptimalSections(layers, sections) {
    let bestHeight = Number.MAX_VALUE;
    let bestPerm = null;
    let sectionsUsed = -1;
    for (let n = sections; n > 1; --n) {
        const { bestPerm: perm, bestHeight: height } = packLayersIntoExactSections(layers, n);
        if (height * 0.8 > bestHeight) {
            break;
        } else if (height &lt;= bestHeight) {
            [bestHeight, bestPerm, sectionsUsed] = [height, perm, n];
        }
    }
    assignLayerSplits(layers, bestPerm);
    return { layers, sectionsUsed };
}

/**
 * Split a layer into `splitCount` parts of roughly equal size.
 * @function
 * @private
 * @param {Object} layer a layer object to be split into `splitCount` parts
 * @param {int} chunkSize the maximum height in pixels of the legend sections
 * @param {int} splitCount the number of pieces which the layer should be broken into
 * @return an object with properties whiteSpace: &lt;int>, splits: [ &lt;layerItems> ]
 */
function splitLayer(layer, chunkSize, splitCount) {
    let itemYOffset = layer.y;
    let itemYMax = 0;
    const splits = [];
    const splitSizes = Array(splitCount).fill(0);

    function traverse(items) {
        items.forEach(item => {

            if (splitCount === 1) {
                return;
            }

            splitSizes[splitCount - 1] = itemYMax - itemYOffset; // bottom of current item - offset at current section start

            // this is the y coordinate of the item's bottom boundary
            itemYMax = item.y + (item.type === 'group' ? item.headerHeight : item.height);

            if (itemYMax - itemYOffset >= chunkSize) {
                splitCount--;

                // whitespace is created when an item sitting on the boundary pulled into the next chunk, the space
                // it would have occupied is wasted; the waste doubles as the entire item is moved to the next legend chunk
                itemYOffset = item.y;
                splits.push(item);
            }

            if (item.type === 'group') {
                traverse(item.items);
            }
        });
    }

    traverse(layer.items);
    splitSizes[splitCount - 1] = layer.height - (itemYOffset - layer.y); // bottom of layer - start of last section; start of last section = total offset of last section - offset at start of layer

    // with whiteSpace we want to find the difference between the chunkSize and used space
    // for each section used (whiteSpace may be negative indicating that a section is
    // spilling past the target size); the total amount of whiteSpace is a measure of how
    // bad the layer allocation was
    return { whiteSpace: splitSizes.reduce((a, b) => a + Math.abs(chunkSize - b), 0), splits };
}

/**
 * Find the optimal split points for the given layer.
 * @function
 * @private
 * @param {Object} layer a layer object to be split into `splitCount` parts
 * @param {int} splitCount the number of pieces which the layer should be broken into
 * @return a reference to the layer passed in
 */
function findOptimalSplit(layer, splitCount) {
    if (splitCount === 1) {
        return layer;
    }

    let chunkSize = layer.height / splitCount; // get initial chunk size for starters

    // get initial splits and whitespace with initial chunk size; this will serve to determine the steps at which the chunk size will be increased
    let { splits: minSplits, whiteSpace: minWhiteSpace } = splitLayer(layer, chunkSize, splitCount);

    const stepCount = 8; // number of attempts
    const step = minWhiteSpace / stepCount;

    // calculate splits while increasing the chunk size
    for (let i = 1; i &lt;= stepCount; i++) {
        chunkSize += step;

        let { splits, whiteSpace } = splitLayer(layer, chunkSize, splitCount);

        // store splits corresponding to the minimum whitespace
        if (whiteSpace &lt; minWhiteSpace) {
            minWhiteSpace = whiteSpace;
            minSplits = splits;
        }
    }

    // apply split to the splits that result in the minimum of whitespace
    minSplits.forEach(split => split.splitBefore = true);
    return layer;
}

/**
 * @function
 * @private
 * @param {Array} layers a list of layers to be updated (modified in place)
 * @param {int} sectionsAvailable the maximum number of sections to use
 * @param {int} mapHeight the rendered height of the map image
 * @return the same layers array as passed in
 */
function allocateLayersToSections(layers, sectionsAvailable, mapHeight) {
    assignLayerSplits(layers, Array(layers.length - 1).fill(true));
    const bestSectionUsage = {}; // maps number of sections used to best height achieved
    bestSectionUsage[layers.length] = {
        height: Math.max(...layers.map(l => l.height)),
        segments: Array(layers.length)
    };
    bestSectionUsage[layers.length].segments.fill(1);

    let curSectionsUsed = layers.length;
    while (curSectionsUsed &lt; sectionsAvailable &amp;&amp; bestSectionUsage[curSectionsUsed].height > mapHeight * 2) {
        const oldSegments = bestSectionUsage[curSectionsUsed].segments;
        const normalizedLayers = oldSegments.map((seg, i) => layers[i].height / seg);
        const worstLayerIndex = normalizedLayers.indexOf(Math.max(...normalizedLayers));
        const newSegments = oldSegments.map((seg, i) => i === worstLayerIndex ? seg + 1 : seg);
        ++curSectionsUsed;
        bestSectionUsage[curSectionsUsed] = {
            height: Math.max(...newSegments.map((seg, i) => layers[i].height / seg)),
            segments: newSegments
        };
    }
    while (curSectionsUsed > layers.length) {
        if (bestSectionUsage[curSectionsUsed].height &lt; 0.9 * bestSectionUsage[curSectionsUsed - 1].height) {
            break;
        }
        --curSectionsUsed;
    }
    layers.forEach((l, i) => findOptimalSplit(l, bestSectionUsage[curSectionsUsed].segments[i]));
    return { layers, sectionsUsed: curSectionsUsed };
}

/**
 * Generate the structure for a legend given a set of layers.
 * @function
 * @param {Array} layerList a list of layers to be updated (modified in place)
 * @param {int} sectionsAvailable the maximum number of sections to use
 * @param {int} mapHeight the rendered height of the map image
 * @return an object with properties layers, sectionsUsed. (layerList is modified in place)
 */
function makeLegend(layerList, sectionsAvailable, mapHeight) {
    if (layerList.length > TOO_MANY_LAYERS) {
        const layersPerSection = Math.ceil(layerList.length / sectionsAvailable);
        const splitPoints = Array(layerList.length - 1).fill(0).map((v, i) => (i + 1) % layersPerSection === 0); // I don't know why the useless fill is necessary
        assignLayerSplits(layerList, splitPoints);
        return { layers: layerList, sectionsUsed: sectionsAvailable };
    }
    if (layerList.length &lt;= sectionsAvailable) {
        return allocateLayersToSections(layerList, sectionsAvailable, mapHeight);
    } else {
        return packLayersIntoOptimalSections(layerList, sectionsAvailable);
    }
}

module.exports = () => ({ makeLegend, allComb, splitLayer, findOptimalSplit });
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Wed Mar 07 2018 16:02:16 GMT+0000 (UTC) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
