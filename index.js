!function(t){function I(n){if(g[n])return g[n].exports;var c=g[n]={i:n,l:!1,exports:{}};return t[n].call(c.exports,c,c.exports,I),c.l=!0,c.exports}var g={};I.m=t,I.c=g,I.i=function(t){return t},I.d=function(t,g,n){I.o(t,g)||Object.defineProperty(t,g,{configurable:!1,enumerable:!0,get:n})},I.n=function(t){var g=t&&t.__esModule?function(){return t.default}:function(){return t};return I.d(g,"a",g),g},I.o=function(t,I){return Object.prototype.hasOwnProperty.call(t,I)},I.p="",I(I.s=80)}([function(module,exports,__webpack_require__){eval("var TWO_PI = Math.PI * 2;\n// SPI is slightly greater than Math.PI, so values that exceed the -180..180\n// degree range by a tiny amount don't get wrapped. This prevents points that\n// have drifted from their original location along the 180th meridian (due to\n// floating point error) from changing their sign.\nvar SPI = 3.14159265359;\nvar sign = __webpack_require__(17);\n\nmodule.exports = function(x) {\n  return (Math.abs(x) <= SPI) ? x : (x - (sign(x) * TWO_PI));\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9jb21tb24vYWRqdXN0X2xvbi5qcz85YmRiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIFRXT19QSSA9IE1hdGguUEkgKiAyO1xuLy8gU1BJIGlzIHNsaWdodGx5IGdyZWF0ZXIgdGhhbiBNYXRoLlBJLCBzbyB2YWx1ZXMgdGhhdCBleGNlZWQgdGhlIC0xODAuLjE4MFxuLy8gZGVncmVlIHJhbmdlIGJ5IGEgdGlueSBhbW91bnQgZG9uJ3QgZ2V0IHdyYXBwZWQuIFRoaXMgcHJldmVudHMgcG9pbnRzIHRoYXRcbi8vIGhhdmUgZHJpZnRlZCBmcm9tIHRoZWlyIG9yaWdpbmFsIGxvY2F0aW9uIGFsb25nIHRoZSAxODB0aCBtZXJpZGlhbiAoZHVlIHRvXG4vLyBmbG9hdGluZyBwb2ludCBlcnJvcikgZnJvbSBjaGFuZ2luZyB0aGVpciBzaWduLlxudmFyIFNQSSA9IDMuMTQxNTkyNjUzNTk7XG52YXIgc2lnbiA9IHJlcXVpcmUoJy4vc2lnbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIChNYXRoLmFicyh4KSA8PSBTUEkpID8geCA6ICh4IC0gKHNpZ24oeCkgKiBUV09fUEkpKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Byb2o0L2xpYi9jb21tb24vYWRqdXN0X2xvbi5qc1xuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){"use strict";eval('\nvar support = __webpack_require__(6);\nvar compressions = __webpack_require__(26);\nvar nodeBuffer = __webpack_require__(27);\n/**\n * Convert a string to a "binary string" : a string containing only char codes between 0 and 255.\n * @param {string} str the string to transform.\n * @return {String} the binary string.\n */\nexports.string2binary = function(str) {\n    var result = "";\n    for (var i = 0; i < str.length; i++) {\n        result += String.fromCharCode(str.charCodeAt(i) & 0xff);\n    }\n    return result;\n};\nexports.arrayBuffer2Blob = function(buffer, mimeType) {\n    exports.checkSupport("blob");\n\tmimeType = mimeType || \'application/zip\';\n\n    try {\n        // Blob constructor\n        return new Blob([buffer], {\n            type: mimeType\n        });\n    }\n    catch (e) {\n\n        try {\n            // deprecated, browser only, old way\n            var Builder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;\n            var builder = new Builder();\n            builder.append(buffer);\n            return builder.getBlob(mimeType);\n        }\n        catch (e) {\n\n            // well, fuck ?!\n            throw new Error("Bug : can\'t construct the Blob.");\n        }\n    }\n\n\n};\n/**\n * The identity function.\n * @param {Object} input the input.\n * @return {Object} the same input.\n */\nfunction identity(input) {\n    return input;\n}\n\n/**\n * Fill in an array with a string.\n * @param {String} str the string to use.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to fill in (will be mutated).\n * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated array.\n */\nfunction stringToArrayLike(str, array) {\n    for (var i = 0; i < str.length; ++i) {\n        array[i] = str.charCodeAt(i) & 0xFF;\n    }\n    return array;\n}\n\n/**\n * Transform an array-like object to a string.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.\n * @return {String} the result.\n */\nfunction arrayLikeToString(array) {\n    // Performances notes :\n    // --------------------\n    // String.fromCharCode.apply(null, array) is the fastest, see\n    // see http://jsperf.com/converting-a-uint8array-to-a-string/2\n    // but the stack is limited (and we can get huge arrays !).\n    //\n    // result += String.fromCharCode(array[i]); generate too many strings !\n    //\n    // This code is inspired by http://jsperf.com/arraybuffer-to-string-apply-performance/2\n    var chunk = 65536;\n    var result = [],\n        len = array.length,\n        type = exports.getTypeOf(array),\n        k = 0,\n        canUseApply = true;\n      try {\n         switch(type) {\n            case "uint8array":\n               String.fromCharCode.apply(null, new Uint8Array(0));\n               break;\n            case "nodebuffer":\n               String.fromCharCode.apply(null, nodeBuffer(0));\n               break;\n         }\n      } catch(e) {\n         canUseApply = false;\n      }\n\n      // no apply : slow and painful algorithm\n      // default browser on android 4.*\n      if (!canUseApply) {\n         var resultStr = "";\n         for(var i = 0; i < array.length;i++) {\n            resultStr += String.fromCharCode(array[i]);\n         }\n    return resultStr;\n    }\n    while (k < len && chunk > 1) {\n        try {\n            if (type === "array" || type === "nodebuffer") {\n                result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));\n            }\n            else {\n                result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));\n            }\n            k += chunk;\n        }\n        catch (e) {\n            chunk = Math.floor(chunk / 2);\n        }\n    }\n    return result.join("");\n}\n\nexports.applyFromCharCode = arrayLikeToString;\n\n\n/**\n * Copy the data from an array-like to an other array-like.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayFrom the origin array.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayTo the destination array which will be mutated.\n * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated destination array.\n */\nfunction arrayLikeToArrayLike(arrayFrom, arrayTo) {\n    for (var i = 0; i < arrayFrom.length; i++) {\n        arrayTo[i] = arrayFrom[i];\n    }\n    return arrayTo;\n}\n\n// a matrix containing functions to transform everything into everything.\nvar transform = {};\n\n// string to ?\ntransform["string"] = {\n    "string": identity,\n    "array": function(input) {\n        return stringToArrayLike(input, new Array(input.length));\n    },\n    "arraybuffer": function(input) {\n        return transform["string"]["uint8array"](input).buffer;\n    },\n    "uint8array": function(input) {\n        return stringToArrayLike(input, new Uint8Array(input.length));\n    },\n    "nodebuffer": function(input) {\n        return stringToArrayLike(input, nodeBuffer(input.length));\n    }\n};\n\n// array to ?\ntransform["array"] = {\n    "string": arrayLikeToString,\n    "array": identity,\n    "arraybuffer": function(input) {\n        return (new Uint8Array(input)).buffer;\n    },\n    "uint8array": function(input) {\n        return new Uint8Array(input);\n    },\n    "nodebuffer": function(input) {\n        return nodeBuffer(input);\n    }\n};\n\n// arraybuffer to ?\ntransform["arraybuffer"] = {\n    "string": function(input) {\n        return arrayLikeToString(new Uint8Array(input));\n    },\n    "array": function(input) {\n        return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));\n    },\n    "arraybuffer": identity,\n    "uint8array": function(input) {\n        return new Uint8Array(input);\n    },\n    "nodebuffer": function(input) {\n        return nodeBuffer(new Uint8Array(input));\n    }\n};\n\n// uint8array to ?\ntransform["uint8array"] = {\n    "string": arrayLikeToString,\n    "array": function(input) {\n        return arrayLikeToArrayLike(input, new Array(input.length));\n    },\n    "arraybuffer": function(input) {\n        return input.buffer;\n    },\n    "uint8array": identity,\n    "nodebuffer": function(input) {\n        return nodeBuffer(input);\n    }\n};\n\n// nodebuffer to ?\ntransform["nodebuffer"] = {\n    "string": arrayLikeToString,\n    "array": function(input) {\n        return arrayLikeToArrayLike(input, new Array(input.length));\n    },\n    "arraybuffer": function(input) {\n        return transform["nodebuffer"]["uint8array"](input).buffer;\n    },\n    "uint8array": function(input) {\n        return arrayLikeToArrayLike(input, new Uint8Array(input.length));\n    },\n    "nodebuffer": identity\n};\n\n/**\n * Transform an input into any type.\n * The supported output type are : string, array, uint8array, arraybuffer, nodebuffer.\n * If no output type is specified, the unmodified input will be returned.\n * @param {String} outputType the output type.\n * @param {String|Array|ArrayBuffer|Uint8Array|Buffer} input the input to convert.\n * @throws {Error} an Error if the browser doesn\'t support the requested output type.\n */\nexports.transformTo = function(outputType, input) {\n    if (!input) {\n        // undefined, null, etc\n        // an empty string won\'t harm.\n        input = "";\n    }\n    if (!outputType) {\n        return input;\n    }\n    exports.checkSupport(outputType);\n    var inputType = exports.getTypeOf(input);\n    var result = transform[inputType][outputType](input);\n    return result;\n};\n\n/**\n * Return the type of the input.\n * The type will be in a format valid for JSZip.utils.transformTo : string, array, uint8array, arraybuffer.\n * @param {Object} input the input to identify.\n * @return {String} the (lowercase) type of the input.\n */\nexports.getTypeOf = function(input) {\n    if (typeof input === "string") {\n        return "string";\n    }\n    if (Object.prototype.toString.call(input) === "[object Array]") {\n        return "array";\n    }\n    if (support.nodebuffer && nodeBuffer.test(input)) {\n        return "nodebuffer";\n    }\n    if (support.uint8array && input instanceof Uint8Array) {\n        return "uint8array";\n    }\n    if (support.arraybuffer && input instanceof ArrayBuffer) {\n        return "arraybuffer";\n    }\n};\n\n/**\n * Throw an exception if the type is not supported.\n * @param {String} type the type to check.\n * @throws {Error} an Error if the browser doesn\'t support the requested type.\n */\nexports.checkSupport = function(type) {\n    var supported = support[type.toLowerCase()];\n    if (!supported) {\n        throw new Error(type + " is not supported by this browser");\n    }\n};\nexports.MAX_VALUE_16BITS = 65535;\nexports.MAX_VALUE_32BITS = -1; // well, "\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF" is parsed as -1\n\n/**\n * Prettify a string read as binary.\n * @param {string} str the string to prettify.\n * @return {string} a pretty string.\n */\nexports.pretty = function(str) {\n    var res = \'\',\n        code, i;\n    for (i = 0; i < (str || "").length; i++) {\n        code = str.charCodeAt(i);\n        res += \'\\\\x\' + (code < 16 ? "0" : "") + code.toString(16).toUpperCase();\n    }\n    return res;\n};\n\n/**\n * Find a compression registered in JSZip.\n * @param {string} compressionMethod the method magic to find.\n * @return {Object|null} the JSZip compression object, null if none found.\n */\nexports.findCompression = function(compressionMethod) {\n    for (var method in compressions) {\n        if (!compressions.hasOwnProperty(method)) {\n            continue;\n        }\n        if (compressions[method].magic === compressionMethod) {\n            return compressions[method];\n        }\n    }\n    return null;\n};\n/**\n* Cross-window, cross-Node-context regular expression detection\n* @param  {Object}  object Anything\n* @return {Boolean}        true if the object is a regular expression,\n* false otherwise\n*/\nexports.isRegExp = function (object) {\n    return Object.prototype.toString.call(object) === "[object RegExp]";\n};\n\n/**\n * Merge the objects passed as parameters into a new one.\n * @private\n * @param {...Object} var_args All objects to merge.\n * @return {Object} a new object with the data of the others.\n */\nexports.extend = function() {\n    var result = {}, i, attr;\n    for (i = 0; i < arguments.length; i++) { // arguments is not enumerable in some browsers\n        for (attr in arguments[i]) {\n            if (arguments[i].hasOwnProperty(attr) && typeof result[attr] === "undefined") {\n                result[attr] = arguments[i][attr];\n            }\n        }\n    }\n    return result;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2pzemlwL2xpYi91dGlscy5qcz9iZmNjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLG9DQUFvQztBQUMvQyxZQUFZLG9DQUFvQztBQUNoRDtBQUNBO0FBQ0EsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxvQ0FBb0M7QUFDL0MsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtCQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0EsV0FBVyxvQ0FBb0M7QUFDL0MsV0FBVyxvQ0FBb0M7QUFDL0MsWUFBWSxvQ0FBb0M7QUFDaEQ7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsMkNBQTJDO0FBQ3RELFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHdCQUF3QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLGVBQWUsc0JBQXNCLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xudmFyIHN1cHBvcnQgPSByZXF1aXJlKCcuL3N1cHBvcnQnKTtcbnZhciBjb21wcmVzc2lvbnMgPSByZXF1aXJlKCcuL2NvbXByZXNzaW9ucycpO1xudmFyIG5vZGVCdWZmZXIgPSByZXF1aXJlKCcuL25vZGVCdWZmZXInKTtcbi8qKlxuICogQ29udmVydCBhIHN0cmluZyB0byBhIFwiYmluYXJ5IHN0cmluZ1wiIDogYSBzdHJpbmcgY29udGFpbmluZyBvbmx5IGNoYXIgY29kZXMgYmV0d2VlbiAwIGFuZCAyNTUuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIHRoZSBzdHJpbmcgdG8gdHJhbnNmb3JtLlxuICogQHJldHVybiB7U3RyaW5nfSB0aGUgYmluYXJ5IHN0cmluZy5cbiAqL1xuZXhwb3J0cy5zdHJpbmcyYmluYXJ5ID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgdmFyIHJlc3VsdCA9IFwiXCI7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoc3RyLmNoYXJDb2RlQXQoaSkgJiAweGZmKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5leHBvcnRzLmFycmF5QnVmZmVyMkJsb2IgPSBmdW5jdGlvbihidWZmZXIsIG1pbWVUeXBlKSB7XG4gICAgZXhwb3J0cy5jaGVja1N1cHBvcnQoXCJibG9iXCIpO1xuXHRtaW1lVHlwZSA9IG1pbWVUeXBlIHx8ICdhcHBsaWNhdGlvbi96aXAnO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgLy8gQmxvYiBjb25zdHJ1Y3RvclxuICAgICAgICByZXR1cm4gbmV3IEJsb2IoW2J1ZmZlcl0sIHtcbiAgICAgICAgICAgIHR5cGU6IG1pbWVUeXBlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBkZXByZWNhdGVkLCBicm93c2VyIG9ubHksIG9sZCB3YXlcbiAgICAgICAgICAgIHZhciBCdWlsZGVyID0gd2luZG93LkJsb2JCdWlsZGVyIHx8IHdpbmRvdy5XZWJLaXRCbG9iQnVpbGRlciB8fCB3aW5kb3cuTW96QmxvYkJ1aWxkZXIgfHwgd2luZG93Lk1TQmxvYkJ1aWxkZXI7XG4gICAgICAgICAgICB2YXIgYnVpbGRlciA9IG5ldyBCdWlsZGVyKCk7XG4gICAgICAgICAgICBidWlsZGVyLmFwcGVuZChidWZmZXIpO1xuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkZXIuZ2V0QmxvYihtaW1lVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcblxuICAgICAgICAgICAgLy8gd2VsbCwgZnVjayA/IVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQnVnIDogY2FuJ3QgY29uc3RydWN0IHRoZSBCbG9iLlwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59O1xuLyoqXG4gKiBUaGUgaWRlbnRpdHkgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXQgdGhlIGlucHV0LlxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgc2FtZSBpbnB1dC5cbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQ7XG59XG5cbi8qKlxuICogRmlsbCBpbiBhbiBhcnJheSB3aXRoIGEgc3RyaW5nLlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciB0aGUgc3RyaW5nIHRvIHVzZS5cbiAqIEBwYXJhbSB7QXJyYXl8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGFycmF5IHRoZSBhcnJheSB0byBmaWxsIGluICh3aWxsIGJlIG11dGF0ZWQpLlxuICogQHJldHVybiB7QXJyYXl8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IHRoZSB1cGRhdGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBzdHJpbmdUb0FycmF5TGlrZShzdHIsIGFycmF5KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgYXJyYXlbaV0gPSBzdHIuY2hhckNvZGVBdChpKSAmIDB4RkY7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gYW4gYXJyYXktbGlrZSBvYmplY3QgdG8gYSBzdHJpbmcuXG4gKiBAcGFyYW0ge0FycmF5fEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBhcnJheSB0aGUgYXJyYXkgdG8gdHJhbnNmb3JtLlxuICogQHJldHVybiB7U3RyaW5nfSB0aGUgcmVzdWx0LlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VUb1N0cmluZyhhcnJheSkge1xuICAgIC8vIFBlcmZvcm1hbmNlcyBub3RlcyA6XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGFycmF5KSBpcyB0aGUgZmFzdGVzdCwgc2VlXG4gICAgLy8gc2VlIGh0dHA6Ly9qc3BlcmYuY29tL2NvbnZlcnRpbmctYS11aW50OGFycmF5LXRvLWEtc3RyaW5nLzJcbiAgICAvLyBidXQgdGhlIHN0YWNrIGlzIGxpbWl0ZWQgKGFuZCB3ZSBjYW4gZ2V0IGh1Z2UgYXJyYXlzICEpLlxuICAgIC8vXG4gICAgLy8gcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYXJyYXlbaV0pOyBnZW5lcmF0ZSB0b28gbWFueSBzdHJpbmdzICFcbiAgICAvL1xuICAgIC8vIFRoaXMgY29kZSBpcyBpbnNwaXJlZCBieSBodHRwOi8vanNwZXJmLmNvbS9hcnJheWJ1ZmZlci10by1zdHJpbmctYXBwbHktcGVyZm9ybWFuY2UvMlxuICAgIHZhciBjaHVuayA9IDY1NTM2O1xuICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgICAgbGVuID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICB0eXBlID0gZXhwb3J0cy5nZXRUeXBlT2YoYXJyYXkpLFxuICAgICAgICBrID0gMCxcbiAgICAgICAgY2FuVXNlQXBwbHkgPSB0cnVlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgIHN3aXRjaCh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwidWludDhhcnJheVwiOlxuICAgICAgICAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheSgwKSk7XG4gICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJub2RlYnVmZmVyXCI6XG4gICAgICAgICAgICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5vZGVCdWZmZXIoMCkpO1xuICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICB9XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgIGNhblVzZUFwcGx5ID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIG5vIGFwcGx5IDogc2xvdyBhbmQgcGFpbmZ1bCBhbGdvcml0aG1cbiAgICAgIC8vIGRlZmF1bHQgYnJvd3NlciBvbiBhbmRyb2lkIDQuKlxuICAgICAgaWYgKCFjYW5Vc2VBcHBseSkge1xuICAgICAgICAgdmFyIHJlc3VsdFN0ciA9IFwiXCI7XG4gICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoO2krKykge1xuICAgICAgICAgICAgcmVzdWx0U3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYXJyYXlbaV0pO1xuICAgICAgICAgfVxuICAgIHJldHVybiByZXN1bHRTdHI7XG4gICAgfVxuICAgIHdoaWxlIChrIDwgbGVuICYmIGNodW5rID4gMSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiYXJyYXlcIiB8fCB0eXBlID09PSBcIm5vZGVidWZmZXJcIikge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYXJyYXkuc2xpY2UoaywgTWF0aC5taW4oayArIGNodW5rLCBsZW4pKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBhcnJheS5zdWJhcnJheShrLCBNYXRoLm1pbihrICsgY2h1bmssIGxlbikpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBrICs9IGNodW5rO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjaHVuayA9IE1hdGguZmxvb3IoY2h1bmsgLyAyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LmpvaW4oXCJcIik7XG59XG5cbmV4cG9ydHMuYXBwbHlGcm9tQ2hhckNvZGUgPSBhcnJheUxpa2VUb1N0cmluZztcblxuXG4vKipcbiAqIENvcHkgdGhlIGRhdGEgZnJvbSBhbiBhcnJheS1saWtlIHRvIGFuIG90aGVyIGFycmF5LWxpa2UuXG4gKiBAcGFyYW0ge0FycmF5fEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBhcnJheUZyb20gdGhlIG9yaWdpbiBhcnJheS5cbiAqIEBwYXJhbSB7QXJyYXl8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGFycmF5VG8gdGhlIGRlc3RpbmF0aW9uIGFycmF5IHdoaWNoIHdpbGwgYmUgbXV0YXRlZC5cbiAqIEByZXR1cm4ge0FycmF5fEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSB0aGUgdXBkYXRlZCBkZXN0aW5hdGlvbiBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlVG9BcnJheUxpa2UoYXJyYXlGcm9tLCBhcnJheVRvKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheUZyb20ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyYXlUb1tpXSA9IGFycmF5RnJvbVtpXTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5VG87XG59XG5cbi8vIGEgbWF0cml4IGNvbnRhaW5pbmcgZnVuY3Rpb25zIHRvIHRyYW5zZm9ybSBldmVyeXRoaW5nIGludG8gZXZlcnl0aGluZy5cbnZhciB0cmFuc2Zvcm0gPSB7fTtcblxuLy8gc3RyaW5nIHRvID9cbnRyYW5zZm9ybVtcInN0cmluZ1wiXSA9IHtcbiAgICBcInN0cmluZ1wiOiBpZGVudGl0eSxcbiAgICBcImFycmF5XCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdUb0FycmF5TGlrZShpbnB1dCwgbmV3IEFycmF5KGlucHV0Lmxlbmd0aCkpO1xuICAgIH0sXG4gICAgXCJhcnJheWJ1ZmZlclwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtW1wic3RyaW5nXCJdW1widWludDhhcnJheVwiXShpbnB1dCkuYnVmZmVyO1xuICAgIH0sXG4gICAgXCJ1aW50OGFycmF5XCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdUb0FycmF5TGlrZShpbnB1dCwgbmV3IFVpbnQ4QXJyYXkoaW5wdXQubGVuZ3RoKSk7XG4gICAgfSxcbiAgICBcIm5vZGVidWZmZXJcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ1RvQXJyYXlMaWtlKGlucHV0LCBub2RlQnVmZmVyKGlucHV0Lmxlbmd0aCkpO1xuICAgIH1cbn07XG5cbi8vIGFycmF5IHRvID9cbnRyYW5zZm9ybVtcImFycmF5XCJdID0ge1xuICAgIFwic3RyaW5nXCI6IGFycmF5TGlrZVRvU3RyaW5nLFxuICAgIFwiYXJyYXlcIjogaWRlbnRpdHksXG4gICAgXCJhcnJheWJ1ZmZlclwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gKG5ldyBVaW50OEFycmF5KGlucHV0KSkuYnVmZmVyO1xuICAgIH0sXG4gICAgXCJ1aW50OGFycmF5XCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShpbnB1dCk7XG4gICAgfSxcbiAgICBcIm5vZGVidWZmZXJcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVCdWZmZXIoaW5wdXQpO1xuICAgIH1cbn07XG5cbi8vIGFycmF5YnVmZmVyIHRvID9cbnRyYW5zZm9ybVtcImFycmF5YnVmZmVyXCJdID0ge1xuICAgIFwic3RyaW5nXCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBhcnJheUxpa2VUb1N0cmluZyhuZXcgVWludDhBcnJheShpbnB1dCkpO1xuICAgIH0sXG4gICAgXCJhcnJheVwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gYXJyYXlMaWtlVG9BcnJheUxpa2UobmV3IFVpbnQ4QXJyYXkoaW5wdXQpLCBuZXcgQXJyYXkoaW5wdXQuYnl0ZUxlbmd0aCkpO1xuICAgIH0sXG4gICAgXCJhcnJheWJ1ZmZlclwiOiBpZGVudGl0eSxcbiAgICBcInVpbnQ4YXJyYXlcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGlucHV0KTtcbiAgICB9LFxuICAgIFwibm9kZWJ1ZmZlclwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gbm9kZUJ1ZmZlcihuZXcgVWludDhBcnJheShpbnB1dCkpO1xuICAgIH1cbn07XG5cbi8vIHVpbnQ4YXJyYXkgdG8gP1xudHJhbnNmb3JtW1widWludDhhcnJheVwiXSA9IHtcbiAgICBcInN0cmluZ1wiOiBhcnJheUxpa2VUb1N0cmluZyxcbiAgICBcImFycmF5XCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBhcnJheUxpa2VUb0FycmF5TGlrZShpbnB1dCwgbmV3IEFycmF5KGlucHV0Lmxlbmd0aCkpO1xuICAgIH0sXG4gICAgXCJhcnJheWJ1ZmZlclwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQuYnVmZmVyO1xuICAgIH0sXG4gICAgXCJ1aW50OGFycmF5XCI6IGlkZW50aXR5LFxuICAgIFwibm9kZWJ1ZmZlclwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gbm9kZUJ1ZmZlcihpbnB1dCk7XG4gICAgfVxufTtcblxuLy8gbm9kZWJ1ZmZlciB0byA/XG50cmFuc2Zvcm1bXCJub2RlYnVmZmVyXCJdID0ge1xuICAgIFwic3RyaW5nXCI6IGFycmF5TGlrZVRvU3RyaW5nLFxuICAgIFwiYXJyYXlcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXlMaWtlKGlucHV0LCBuZXcgQXJyYXkoaW5wdXQubGVuZ3RoKSk7XG4gICAgfSxcbiAgICBcImFycmF5YnVmZmVyXCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1bXCJub2RlYnVmZmVyXCJdW1widWludDhhcnJheVwiXShpbnB1dCkuYnVmZmVyO1xuICAgIH0sXG4gICAgXCJ1aW50OGFycmF5XCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBhcnJheUxpa2VUb0FycmF5TGlrZShpbnB1dCwgbmV3IFVpbnQ4QXJyYXkoaW5wdXQubGVuZ3RoKSk7XG4gICAgfSxcbiAgICBcIm5vZGVidWZmZXJcIjogaWRlbnRpdHlcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtIGFuIGlucHV0IGludG8gYW55IHR5cGUuXG4gKiBUaGUgc3VwcG9ydGVkIG91dHB1dCB0eXBlIGFyZSA6IHN0cmluZywgYXJyYXksIHVpbnQ4YXJyYXksIGFycmF5YnVmZmVyLCBub2RlYnVmZmVyLlxuICogSWYgbm8gb3V0cHV0IHR5cGUgaXMgc3BlY2lmaWVkLCB0aGUgdW5tb2RpZmllZCBpbnB1dCB3aWxsIGJlIHJldHVybmVkLlxuICogQHBhcmFtIHtTdHJpbmd9IG91dHB1dFR5cGUgdGhlIG91dHB1dCB0eXBlLlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGlucHV0IHRoZSBpbnB1dCB0byBjb252ZXJ0LlxuICogQHRocm93cyB7RXJyb3J9IGFuIEVycm9yIGlmIHRoZSBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCB0aGUgcmVxdWVzdGVkIG91dHB1dCB0eXBlLlxuICovXG5leHBvcnRzLnRyYW5zZm9ybVRvID0gZnVuY3Rpb24ob3V0cHV0VHlwZSwgaW5wdXQpIHtcbiAgICBpZiAoIWlucHV0KSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZCwgbnVsbCwgZXRjXG4gICAgICAgIC8vIGFuIGVtcHR5IHN0cmluZyB3b24ndCBoYXJtLlxuICAgICAgICBpbnB1dCA9IFwiXCI7XG4gICAgfVxuICAgIGlmICghb3V0cHV0VHlwZSkge1xuICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuICAgIGV4cG9ydHMuY2hlY2tTdXBwb3J0KG91dHB1dFR5cGUpO1xuICAgIHZhciBpbnB1dFR5cGUgPSBleHBvcnRzLmdldFR5cGVPZihpbnB1dCk7XG4gICAgdmFyIHJlc3VsdCA9IHRyYW5zZm9ybVtpbnB1dFR5cGVdW291dHB1dFR5cGVdKGlucHV0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIHR5cGUgb2YgdGhlIGlucHV0LlxuICogVGhlIHR5cGUgd2lsbCBiZSBpbiBhIGZvcm1hdCB2YWxpZCBmb3IgSlNaaXAudXRpbHMudHJhbnNmb3JtVG8gOiBzdHJpbmcsIGFycmF5LCB1aW50OGFycmF5LCBhcnJheWJ1ZmZlci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCB0aGUgaW5wdXQgdG8gaWRlbnRpZnkuXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSAobG93ZXJjYXNlKSB0eXBlIG9mIHRoZSBpbnB1dC5cbiAqL1xuZXhwb3J0cy5nZXRUeXBlT2YgPSBmdW5jdGlvbihpbnB1dCkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgfVxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSBcIltvYmplY3QgQXJyYXldXCIpIHtcbiAgICAgICAgcmV0dXJuIFwiYXJyYXlcIjtcbiAgICB9XG4gICAgaWYgKHN1cHBvcnQubm9kZWJ1ZmZlciAmJiBub2RlQnVmZmVyLnRlc3QoaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBcIm5vZGVidWZmZXJcIjtcbiAgICB9XG4gICAgaWYgKHN1cHBvcnQudWludDhhcnJheSAmJiBpbnB1dCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIFwidWludDhhcnJheVwiO1xuICAgIH1cbiAgICBpZiAoc3VwcG9ydC5hcnJheWJ1ZmZlciAmJiBpbnB1dCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBcImFycmF5YnVmZmVyXCI7XG4gICAgfVxufTtcblxuLyoqXG4gKiBUaHJvdyBhbiBleGNlcHRpb24gaWYgdGhlIHR5cGUgaXMgbm90IHN1cHBvcnRlZC5cbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHRoZSB0eXBlIHRvIGNoZWNrLlxuICogQHRocm93cyB7RXJyb3J9IGFuIEVycm9yIGlmIHRoZSBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCB0aGUgcmVxdWVzdGVkIHR5cGUuXG4gKi9cbmV4cG9ydHMuY2hlY2tTdXBwb3J0ID0gZnVuY3Rpb24odHlwZSkge1xuICAgIHZhciBzdXBwb3J0ZWQgPSBzdXBwb3J0W3R5cGUudG9Mb3dlckNhc2UoKV07XG4gICAgaWYgKCFzdXBwb3J0ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHR5cGUgKyBcIiBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgYnJvd3NlclwiKTtcbiAgICB9XG59O1xuZXhwb3J0cy5NQVhfVkFMVUVfMTZCSVRTID0gNjU1MzU7XG5leHBvcnRzLk1BWF9WQUxVRV8zMkJJVFMgPSAtMTsgLy8gd2VsbCwgXCJcXHhGRlxceEZGXFx4RkZcXHhGRlxceEZGXFx4RkZcXHhGRlxceEZGXCIgaXMgcGFyc2VkIGFzIC0xXG5cbi8qKlxuICogUHJldHRpZnkgYSBzdHJpbmcgcmVhZCBhcyBiaW5hcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIHRoZSBzdHJpbmcgdG8gcHJldHRpZnkuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGEgcHJldHR5IHN0cmluZy5cbiAqL1xuZXhwb3J0cy5wcmV0dHkgPSBmdW5jdGlvbihzdHIpIHtcbiAgICB2YXIgcmVzID0gJycsXG4gICAgICAgIGNvZGUsIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IChzdHIgfHwgXCJcIikubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICByZXMgKz0gJ1xcXFx4JyArIChjb2RlIDwgMTYgPyBcIjBcIiA6IFwiXCIpICsgY29kZS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn07XG5cbi8qKlxuICogRmluZCBhIGNvbXByZXNzaW9uIHJlZ2lzdGVyZWQgaW4gSlNaaXAuXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcHJlc3Npb25NZXRob2QgdGhlIG1ldGhvZCBtYWdpYyB0byBmaW5kLlxuICogQHJldHVybiB7T2JqZWN0fG51bGx9IHRoZSBKU1ppcCBjb21wcmVzc2lvbiBvYmplY3QsIG51bGwgaWYgbm9uZSBmb3VuZC5cbiAqL1xuZXhwb3J0cy5maW5kQ29tcHJlc3Npb24gPSBmdW5jdGlvbihjb21wcmVzc2lvbk1ldGhvZCkge1xuICAgIGZvciAodmFyIG1ldGhvZCBpbiBjb21wcmVzc2lvbnMpIHtcbiAgICAgICAgaWYgKCFjb21wcmVzc2lvbnMuaGFzT3duUHJvcGVydHkobWV0aG9kKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXByZXNzaW9uc1ttZXRob2RdLm1hZ2ljID09PSBjb21wcmVzc2lvbk1ldGhvZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXByZXNzaW9uc1ttZXRob2RdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcbi8qKlxuKiBDcm9zcy13aW5kb3csIGNyb3NzLU5vZGUtY29udGV4dCByZWd1bGFyIGV4cHJlc3Npb24gZGV0ZWN0aW9uXG4qIEBwYXJhbSAge09iamVjdH0gIG9iamVjdCBBbnl0aGluZ1xuKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgdHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIGEgcmVndWxhciBleHByZXNzaW9uLFxuKiBmYWxzZSBvdGhlcndpc2VcbiovXG5leHBvcnRzLmlzUmVnRXhwID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PT0gXCJbb2JqZWN0IFJlZ0V4cF1cIjtcbn07XG5cbi8qKlxuICogTWVyZ2UgdGhlIG9iamVjdHMgcGFzc2VkIGFzIHBhcmFtZXRlcnMgaW50byBhIG5ldyBvbmUuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsuLi5PYmplY3R9IHZhcl9hcmdzIEFsbCBvYmplY3RzIHRvIG1lcmdlLlxuICogQHJldHVybiB7T2JqZWN0fSBhIG5ldyBvYmplY3Qgd2l0aCB0aGUgZGF0YSBvZiB0aGUgb3RoZXJzLlxuICovXG5leHBvcnRzLmV4dGVuZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXN1bHQgPSB7fSwgaSwgYXR0cjtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IC8vIGFyZ3VtZW50cyBpcyBub3QgZW51bWVyYWJsZSBpbiBzb21lIGJyb3dzZXJzXG4gICAgICAgIGZvciAoYXR0ciBpbiBhcmd1bWVudHNbaV0pIHtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHNbaV0uaGFzT3duUHJvcGVydHkoYXR0cikgJiYgdHlwZW9mIHJlc3VsdFthdHRyXSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHJlc3VsdFthdHRyXSA9IGFyZ3VtZW50c1tpXVthdHRyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2pzemlwL2xpYi91dGlscy5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9')},function(module,exports,__webpack_require__){"use strict";eval("\n\n// TODO revisit if we still need rv- in these constants.\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar states = { // these are used as css classes; hence the `rv` prefix\n    NEW: 'rv-new',\n    REFRESH: 'rv-refresh',\n    LOADING: 'rv-loading',\n    LOADED: 'rv-loaded', // TODO maybe loaded and default are the same?\n    DEFAULT: 'rv-default',\n    ERROR: 'rv-error'\n};\n\n// these match strings in the client.\nvar clientLayerType = {\n    ESRI_DYNAMIC: 'esriDynamic',\n    ESRI_FEATURE: 'esriFeature',\n    ESRI_IMAGE: 'esriImage',\n    ESRI_TILE: 'esriTile',\n    ESRI_GROUP: 'esriGroup',\n    ESRI_RASTER: 'esriRaster',\n    OGC_WMS: 'ogcWms',\n    UNRESOLVED: 'unresolved',\n    UNKNOWN: 'unknown'\n};\n\n// legend data is our modified legend structure.\n// it is similar to esri's server output, but all individual\n// items are promises.\n// TODO proper docs\nfunction makeSymbologyArray(legendData) {\n    return legendData.map(function (item) {\n\n        var symbologyItem = {\n            svgcode: null,\n            name: null\n        };\n\n        // file-based layers don't have symbology labels, default to ''\n        // legend items are promises\n        item.then(function (data) {\n            symbologyItem.svgcode = data.svgcode;\n            symbologyItem.name = data.label || '';\n        });\n\n        return symbologyItem;\n    });\n}\n\nfunction parseUrlIndex(url) {\n    // break url into root and index\n\n    // note we are returning index as a string for now.\n    var result = {\n        rootUrl: url,\n        index: '0'\n    };\n    var re = /\\/(\\d+)\\/?$/;\n    var matches = url.match(re);\n\n    if (matches) {\n        result.index = matches[1];\n        result.rootUrl = url.substr(0, url.length - matches[0].length); // will drop trailing slash\n    } else {\n        // give up, dont crash with error.\n        // default configuration will make sense for non-feature urls,\n        // even though they should not be using this.\n        console.warn('Cannot extract layer index from url ' + url);\n    }\n\n    return result;\n}\n\nfunction layerLoaded(state) {\n    switch (state) {\n        case states.ERROR:\n        case states.LOADING:\n        case states.NEW:\n            return false;\n        default:\n            return true;\n    }\n}\n\n/**\r\n * @class IdentifyResult\r\n */\n\nvar IdentifyResult =\n/**\r\n * @param  {Object} proxy   proxy to the logical layer containing the results (i.e. a feature class)\r\n */\nfunction IdentifyResult(proxy) {\n    _classCallCheck(this, IdentifyResult);\n\n    // TODO revisit what should be in this class, and what belongs in the app\n    // also what can be abstacted to come from layerRec\n    this.isLoading = true;\n    this.requestId = -1;\n    this.requester = {\n        proxy: proxy\n    };\n    this.data = [];\n};\n\nmodule.exports = function () {\n    return {\n        states: states,\n        clientLayerType: clientLayerType,\n        makeSymbologyArray: makeSymbologyArray,\n        IdentifyResult: IdentifyResult,\n        parseUrlIndex: parseUrlIndex,\n        layerLoaded: layerLoaded\n    };\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXIvbGF5ZXJSZWMvc2hhcmVkLmpzPzNjZjkiXSwibmFtZXMiOlsic3RhdGVzIiwiTkVXIiwiUkVGUkVTSCIsIkxPQURJTkciLCJMT0FERUQiLCJERUZBVUxUIiwiRVJST1IiLCJjbGllbnRMYXllclR5cGUiLCJFU1JJX0RZTkFNSUMiLCJFU1JJX0ZFQVRVUkUiLCJFU1JJX0lNQUdFIiwiRVNSSV9USUxFIiwiRVNSSV9HUk9VUCIsIkVTUklfUkFTVEVSIiwiT0dDX1dNUyIsIlVOUkVTT0xWRUQiLCJVTktOT1dOIiwibWFrZVN5bWJvbG9neUFycmF5IiwibGVnZW5kRGF0YSIsIm1hcCIsInN5bWJvbG9neUl0ZW0iLCJzdmdjb2RlIiwibmFtZSIsIml0ZW0iLCJ0aGVuIiwiZGF0YSIsImxhYmVsIiwicGFyc2VVcmxJbmRleCIsInVybCIsInJlc3VsdCIsInJvb3RVcmwiLCJpbmRleCIsInJlIiwibWF0Y2hlcyIsIm1hdGNoIiwic3Vic3RyIiwibGVuZ3RoIiwiY29uc29sZSIsIndhcm4iLCJsYXllckxvYWRlZCIsInN0YXRlIiwiSWRlbnRpZnlSZXN1bHQiLCJwcm94eSIsImlzTG9hZGluZyIsInJlcXVlc3RJZCIsInJlcXVlc3RlciIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBOzs7O0FBQ0EsSUFBTUEsU0FBUyxFQUFFO0FBQ2JDLFNBQUssUUFETTtBQUVYQyxhQUFTLFlBRkU7QUFHWEMsYUFBUyxZQUhFO0FBSVhDLFlBQVEsV0FKRyxFQUlVO0FBQ3JCQyxhQUFTLFlBTEU7QUFNWEMsV0FBTztBQU5JLENBQWY7O0FBU0E7QUFDQSxJQUFNQyxrQkFBa0I7QUFDcEJDLGtCQUFjLGFBRE07QUFFcEJDLGtCQUFjLGFBRk07QUFHcEJDLGdCQUFZLFdBSFE7QUFJcEJDLGVBQVcsVUFKUztBQUtwQkMsZ0JBQVksV0FMUTtBQU1wQkMsaUJBQWEsWUFOTztBQU9wQkMsYUFBUyxRQVBXO0FBUXBCQyxnQkFBWSxZQVJRO0FBU3BCQyxhQUFTO0FBVFcsQ0FBeEI7O0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTQyxrQkFBVCxDQUE0QkMsVUFBNUIsRUFBd0M7QUFDcEMsV0FBT0EsV0FBV0MsR0FBWCxDQUFlLGdCQUFROztBQUUxQixZQUFNQyxnQkFBZ0I7QUFDbEJDLHFCQUFTLElBRFM7QUFFbEJDLGtCQUFNO0FBRlksU0FBdEI7O0FBS0E7QUFDQTtBQUNBQyxhQUFLQyxJQUFMLENBQVUsZ0JBQVE7QUFDZEosMEJBQWNDLE9BQWQsR0FBd0JJLEtBQUtKLE9BQTdCO0FBQ0FELDBCQUFjRSxJQUFkLEdBQXFCRyxLQUFLQyxLQUFMLElBQWMsRUFBbkM7QUFDSCxTQUhEOztBQUtBLGVBQU9OLGFBQVA7QUFDSCxLQWZNLENBQVA7QUFnQkg7O0FBRUQsU0FBU08sYUFBVCxDQUF1QkMsR0FBdkIsRUFBNEI7QUFDeEI7O0FBRUE7QUFDQSxRQUFNQyxTQUFTO0FBQ1hDLGlCQUFTRixHQURFO0FBRVhHLGVBQU87QUFGSSxLQUFmO0FBSUEsUUFBTUMsS0FBSyxhQUFYO0FBQ0EsUUFBTUMsVUFBVUwsSUFBSU0sS0FBSixDQUFVRixFQUFWLENBQWhCOztBQUVBLFFBQUlDLE9BQUosRUFBYTtBQUNUSixlQUFPRSxLQUFQLEdBQWVFLFFBQVEsQ0FBUixDQUFmO0FBQ0FKLGVBQU9DLE9BQVAsR0FBaUJGLElBQUlPLE1BQUosQ0FBVyxDQUFYLEVBQWNQLElBQUlRLE1BQUosR0FBYUgsUUFBUSxDQUFSLEVBQVdHLE1BQXRDLENBQWpCLENBRlMsQ0FFdUQ7QUFDbkUsS0FIRCxNQUdPO0FBQ0g7QUFDQTtBQUNBO0FBQ0FDLGdCQUFRQyxJQUFSLENBQWEseUNBQXlDVixHQUF0RDtBQUNIOztBQUVELFdBQU9DLE1BQVA7QUFDSDs7QUFFRCxTQUFTVSxXQUFULENBQXFCQyxLQUFyQixFQUE0QjtBQUN4QixZQUFRQSxLQUFSO0FBQ0ksYUFBS3hDLE9BQU9NLEtBQVo7QUFDQSxhQUFLTixPQUFPRyxPQUFaO0FBQ0EsYUFBS0gsT0FBT0MsR0FBWjtBQUNJLG1CQUFPLEtBQVA7QUFDSjtBQUNJLG1CQUFPLElBQVA7QUFOUjtBQVFIOztBQUVEOzs7O0lBR013QyxjO0FBQ0Y7OztBQUdBLHdCQUFhQyxLQUFiLEVBQW9CO0FBQUE7O0FBQ2hCO0FBQ0E7QUFDQSxTQUFLQyxTQUFMLEdBQWlCLElBQWpCO0FBQ0EsU0FBS0MsU0FBTCxHQUFpQixDQUFDLENBQWxCO0FBQ0EsU0FBS0MsU0FBTCxHQUFpQjtBQUNiSDtBQURhLEtBQWpCO0FBR0EsU0FBS2pCLElBQUwsR0FBWSxFQUFaO0FBQ0gsQzs7QUFHTHFCLE9BQU9DLE9BQVAsR0FBaUI7QUFBQSxXQUFPO0FBQ3BCL0Msc0JBRG9CO0FBRXBCTyx3Q0FGb0I7QUFHcEJVLDhDQUhvQjtBQUlwQndCLHNDQUpvQjtBQUtwQmQsb0NBTG9CO0FBTXBCWTtBQU5vQixLQUFQO0FBQUEsQ0FBakIiLCJmaWxlIjoiMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuXHJcbi8vIFRPRE8gcmV2aXNpdCBpZiB3ZSBzdGlsbCBuZWVkIHJ2LSBpbiB0aGVzZSBjb25zdGFudHMuXHJcbmNvbnN0IHN0YXRlcyA9IHsgLy8gdGhlc2UgYXJlIHVzZWQgYXMgY3NzIGNsYXNzZXM7IGhlbmNlIHRoZSBgcnZgIHByZWZpeFxyXG4gICAgTkVXOiAncnYtbmV3JyxcclxuICAgIFJFRlJFU0g6ICdydi1yZWZyZXNoJyxcclxuICAgIExPQURJTkc6ICdydi1sb2FkaW5nJyxcclxuICAgIExPQURFRDogJ3J2LWxvYWRlZCcsIC8vIFRPRE8gbWF5YmUgbG9hZGVkIGFuZCBkZWZhdWx0IGFyZSB0aGUgc2FtZT9cclxuICAgIERFRkFVTFQ6ICdydi1kZWZhdWx0JyxcclxuICAgIEVSUk9SOiAncnYtZXJyb3InXHJcbn07XHJcblxyXG4vLyB0aGVzZSBtYXRjaCBzdHJpbmdzIGluIHRoZSBjbGllbnQuXHJcbmNvbnN0IGNsaWVudExheWVyVHlwZSA9IHtcclxuICAgIEVTUklfRFlOQU1JQzogJ2VzcmlEeW5hbWljJyxcclxuICAgIEVTUklfRkVBVFVSRTogJ2VzcmlGZWF0dXJlJyxcclxuICAgIEVTUklfSU1BR0U6ICdlc3JpSW1hZ2UnLFxyXG4gICAgRVNSSV9USUxFOiAnZXNyaVRpbGUnLFxyXG4gICAgRVNSSV9HUk9VUDogJ2VzcmlHcm91cCcsXHJcbiAgICBFU1JJX1JBU1RFUjogJ2VzcmlSYXN0ZXInLFxyXG4gICAgT0dDX1dNUzogJ29nY1dtcycsXHJcbiAgICBVTlJFU09MVkVEOiAndW5yZXNvbHZlZCcsXHJcbiAgICBVTktOT1dOOiAndW5rbm93bidcclxufTtcclxuXHJcbi8vIGxlZ2VuZCBkYXRhIGlzIG91ciBtb2RpZmllZCBsZWdlbmQgc3RydWN0dXJlLlxyXG4vLyBpdCBpcyBzaW1pbGFyIHRvIGVzcmkncyBzZXJ2ZXIgb3V0cHV0LCBidXQgYWxsIGluZGl2aWR1YWxcclxuLy8gaXRlbXMgYXJlIHByb21pc2VzLlxyXG4vLyBUT0RPIHByb3BlciBkb2NzXHJcbmZ1bmN0aW9uIG1ha2VTeW1ib2xvZ3lBcnJheShsZWdlbmREYXRhKSB7XHJcbiAgICByZXR1cm4gbGVnZW5kRGF0YS5tYXAoaXRlbSA9PiB7XHJcblxyXG4gICAgICAgIGNvbnN0IHN5bWJvbG9neUl0ZW0gPSB7XHJcbiAgICAgICAgICAgIHN2Z2NvZGU6IG51bGwsXHJcbiAgICAgICAgICAgIG5hbWU6IG51bGxcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBmaWxlLWJhc2VkIGxheWVycyBkb24ndCBoYXZlIHN5bWJvbG9neSBsYWJlbHMsIGRlZmF1bHQgdG8gJydcclxuICAgICAgICAvLyBsZWdlbmQgaXRlbXMgYXJlIHByb21pc2VzXHJcbiAgICAgICAgaXRlbS50aGVuKGRhdGEgPT4ge1xyXG4gICAgICAgICAgICBzeW1ib2xvZ3lJdGVtLnN2Z2NvZGUgPSBkYXRhLnN2Z2NvZGU7XHJcbiAgICAgICAgICAgIHN5bWJvbG9neUl0ZW0ubmFtZSA9IGRhdGEubGFiZWwgfHwgJyc7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBzeW1ib2xvZ3lJdGVtO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhcnNlVXJsSW5kZXgodXJsKSB7XHJcbiAgICAvLyBicmVhayB1cmwgaW50byByb290IGFuZCBpbmRleFxyXG5cclxuICAgIC8vIG5vdGUgd2UgYXJlIHJldHVybmluZyBpbmRleCBhcyBhIHN0cmluZyBmb3Igbm93LlxyXG4gICAgY29uc3QgcmVzdWx0ID0ge1xyXG4gICAgICAgIHJvb3RVcmw6IHVybCxcclxuICAgICAgICBpbmRleDogJzAnXHJcbiAgICB9O1xyXG4gICAgY29uc3QgcmUgPSAvXFwvKFxcZCspXFwvPyQvO1xyXG4gICAgY29uc3QgbWF0Y2hlcyA9IHVybC5tYXRjaChyZSk7XHJcblxyXG4gICAgaWYgKG1hdGNoZXMpIHtcclxuICAgICAgICByZXN1bHQuaW5kZXggPSBtYXRjaGVzWzFdO1xyXG4gICAgICAgIHJlc3VsdC5yb290VXJsID0gdXJsLnN1YnN0cigwLCB1cmwubGVuZ3RoIC0gbWF0Y2hlc1swXS5sZW5ndGgpOyAvLyB3aWxsIGRyb3AgdHJhaWxpbmcgc2xhc2hcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gZ2l2ZSB1cCwgZG9udCBjcmFzaCB3aXRoIGVycm9yLlxyXG4gICAgICAgIC8vIGRlZmF1bHQgY29uZmlndXJhdGlvbiB3aWxsIG1ha2Ugc2Vuc2UgZm9yIG5vbi1mZWF0dXJlIHVybHMsXHJcbiAgICAgICAgLy8gZXZlbiB0aG91Z2ggdGhleSBzaG91bGQgbm90IGJlIHVzaW5nIHRoaXMuXHJcbiAgICAgICAgY29uc29sZS53YXJuKCdDYW5ub3QgZXh0cmFjdCBsYXllciBpbmRleCBmcm9tIHVybCAnICsgdXJsKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBsYXllckxvYWRlZChzdGF0ZSkge1xyXG4gICAgc3dpdGNoIChzdGF0ZSkge1xyXG4gICAgICAgIGNhc2Ugc3RhdGVzLkVSUk9SOlxyXG4gICAgICAgIGNhc2Ugc3RhdGVzLkxPQURJTkc6XHJcbiAgICAgICAgY2FzZSBzdGF0ZXMuTkVXOlxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAY2xhc3MgSWRlbnRpZnlSZXN1bHRcclxuICovXHJcbmNsYXNzIElkZW50aWZ5UmVzdWx0IHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBwcm94eSAgIHByb3h5IHRvIHRoZSBsb2dpY2FsIGxheWVyIGNvbnRhaW5pbmcgdGhlIHJlc3VsdHMgKGkuZS4gYSBmZWF0dXJlIGNsYXNzKVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvciAocHJveHkpIHtcclxuICAgICAgICAvLyBUT0RPIHJldmlzaXQgd2hhdCBzaG91bGQgYmUgaW4gdGhpcyBjbGFzcywgYW5kIHdoYXQgYmVsb25ncyBpbiB0aGUgYXBwXHJcbiAgICAgICAgLy8gYWxzbyB3aGF0IGNhbiBiZSBhYnN0YWN0ZWQgdG8gY29tZSBmcm9tIGxheWVyUmVjXHJcbiAgICAgICAgdGhpcy5pc0xvYWRpbmcgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMucmVxdWVzdElkID0gLTE7XHJcbiAgICAgICAgdGhpcy5yZXF1ZXN0ZXIgPSB7XHJcbiAgICAgICAgICAgIHByb3h5XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmRhdGEgPSBbXTtcclxuICAgIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSAoKSA9PiAoe1xyXG4gICAgc3RhdGVzLFxyXG4gICAgY2xpZW50TGF5ZXJUeXBlLFxyXG4gICAgbWFrZVN5bWJvbG9neUFycmF5LFxyXG4gICAgSWRlbnRpZnlSZXN1bHQsXHJcbiAgICBwYXJzZVVybEluZGV4LFxyXG4gICAgbGF5ZXJMb2FkZWRcclxufSk7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9sYXllci9sYXllclJlYy9zaGFyZWQuanMiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){"use strict";eval("\n\n\nvar TYPED_OK =  (typeof Uint8Array !== 'undefined') &&\n                (typeof Uint16Array !== 'undefined') &&\n                (typeof Int32Array !== 'undefined');\n\n\nexports.assign = function (obj /*from1, from2, from3, ...*/) {\n  var sources = Array.prototype.slice.call(arguments, 1);\n  while (sources.length) {\n    var source = sources.shift();\n    if (!source) { continue; }\n\n    if (typeof source !== 'object') {\n      throw new TypeError(source + 'must be non-object');\n    }\n\n    for (var p in source) {\n      if (source.hasOwnProperty(p)) {\n        obj[p] = source[p];\n      }\n    }\n  }\n\n  return obj;\n};\n\n\n// reduce buffer size, avoiding mem copy\nexports.shrinkBuf = function (buf, size) {\n  if (buf.length === size) { return buf; }\n  if (buf.subarray) { return buf.subarray(0, size); }\n  buf.length = size;\n  return buf;\n};\n\n\nvar fnTyped = {\n  arraySet: function (dest, src, src_offs, len, dest_offs) {\n    if (src.subarray && dest.subarray) {\n      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);\n      return;\n    }\n    // Fallback to ordinary array\n    for (var i = 0; i < len; i++) {\n      dest[dest_offs + i] = src[src_offs + i];\n    }\n  },\n  // Join array of chunks to single array.\n  flattenChunks: function (chunks) {\n    var i, l, len, pos, chunk, result;\n\n    // calculate data length\n    len = 0;\n    for (i = 0, l = chunks.length; i < l; i++) {\n      len += chunks[i].length;\n    }\n\n    // join chunks\n    result = new Uint8Array(len);\n    pos = 0;\n    for (i = 0, l = chunks.length; i < l; i++) {\n      chunk = chunks[i];\n      result.set(chunk, pos);\n      pos += chunk.length;\n    }\n\n    return result;\n  }\n};\n\nvar fnUntyped = {\n  arraySet: function (dest, src, src_offs, len, dest_offs) {\n    for (var i = 0; i < len; i++) {\n      dest[dest_offs + i] = src[src_offs + i];\n    }\n  },\n  // Join array of chunks to single array.\n  flattenChunks: function (chunks) {\n    return [].concat.apply([], chunks);\n  }\n};\n\n\n// Enable/Disable typed arrays use, for testing\n//\nexports.setTyped = function (on) {\n  if (on) {\n    exports.Buf8  = Uint8Array;\n    exports.Buf16 = Uint16Array;\n    exports.Buf32 = Int32Array;\n    exports.assign(exports, fnTyped);\n  } else {\n    exports.Buf8  = Array;\n    exports.Buf16 = Array;\n    exports.Buf32 = Array;\n    exports.assign(exports, fnUntyped);\n  }\n};\n\nexports.setTyped(TYPED_OK);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2pzemlwL34vcGFrby9saWIvdXRpbHMvY29tbW9uLmpzPzA2OTMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVTs7QUFFNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsNEJBQTRCLFlBQVk7QUFDeEMscUJBQXFCLDhCQUE4QjtBQUNuRDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cblxudmFyIFRZUEVEX09LID0gICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpICYmXG4gICAgICAgICAgICAgICAgKHR5cGVvZiBVaW50MTZBcnJheSAhPT0gJ3VuZGVmaW5lZCcpICYmXG4gICAgICAgICAgICAgICAgKHR5cGVvZiBJbnQzMkFycmF5ICE9PSAndW5kZWZpbmVkJyk7XG5cblxuZXhwb3J0cy5hc3NpZ24gPSBmdW5jdGlvbiAob2JqIC8qZnJvbTEsIGZyb20yLCBmcm9tMywgLi4uKi8pIHtcbiAgdmFyIHNvdXJjZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB3aGlsZSAoc291cmNlcy5sZW5ndGgpIHtcbiAgICB2YXIgc291cmNlID0gc291cmNlcy5zaGlmdCgpO1xuICAgIGlmICghc291cmNlKSB7IGNvbnRpbnVlOyB9XG5cbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3Ioc291cmNlICsgJ211c3QgYmUgbm9uLW9iamVjdCcpO1xuICAgIH1cblxuICAgIGZvciAodmFyIHAgaW4gc291cmNlKSB7XG4gICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KHApKSB7XG4gICAgICAgIG9ialtwXSA9IHNvdXJjZVtwXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxuXG4vLyByZWR1Y2UgYnVmZmVyIHNpemUsIGF2b2lkaW5nIG1lbSBjb3B5XG5leHBvcnRzLnNocmlua0J1ZiA9IGZ1bmN0aW9uIChidWYsIHNpemUpIHtcbiAgaWYgKGJ1Zi5sZW5ndGggPT09IHNpemUpIHsgcmV0dXJuIGJ1ZjsgfVxuICBpZiAoYnVmLnN1YmFycmF5KSB7IHJldHVybiBidWYuc3ViYXJyYXkoMCwgc2l6ZSk7IH1cbiAgYnVmLmxlbmd0aCA9IHNpemU7XG4gIHJldHVybiBidWY7XG59O1xuXG5cbnZhciBmblR5cGVkID0ge1xuICBhcnJheVNldDogZnVuY3Rpb24gKGRlc3QsIHNyYywgc3JjX29mZnMsIGxlbiwgZGVzdF9vZmZzKSB7XG4gICAgaWYgKHNyYy5zdWJhcnJheSAmJiBkZXN0LnN1YmFycmF5KSB7XG4gICAgICBkZXN0LnNldChzcmMuc3ViYXJyYXkoc3JjX29mZnMsIHNyY19vZmZzICsgbGVuKSwgZGVzdF9vZmZzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gRmFsbGJhY2sgdG8gb3JkaW5hcnkgYXJyYXlcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZXN0W2Rlc3Rfb2ZmcyArIGldID0gc3JjW3NyY19vZmZzICsgaV07XG4gICAgfVxuICB9LFxuICAvLyBKb2luIGFycmF5IG9mIGNodW5rcyB0byBzaW5nbGUgYXJyYXkuXG4gIGZsYXR0ZW5DaHVua3M6IGZ1bmN0aW9uIChjaHVua3MpIHtcbiAgICB2YXIgaSwgbCwgbGVuLCBwb3MsIGNodW5rLCByZXN1bHQ7XG5cbiAgICAvLyBjYWxjdWxhdGUgZGF0YSBsZW5ndGhcbiAgICBsZW4gPSAwO1xuICAgIGZvciAoaSA9IDAsIGwgPSBjaHVua3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBsZW4gKz0gY2h1bmtzW2ldLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyBqb2luIGNodW5rc1xuICAgIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbik7XG4gICAgcG9zID0gMDtcbiAgICBmb3IgKGkgPSAwLCBsID0gY2h1bmtzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgY2h1bmsgPSBjaHVua3NbaV07XG4gICAgICByZXN1bHQuc2V0KGNodW5rLCBwb3MpO1xuICAgICAgcG9zICs9IGNodW5rLmxlbmd0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuXG52YXIgZm5VbnR5cGVkID0ge1xuICBhcnJheVNldDogZnVuY3Rpb24gKGRlc3QsIHNyYywgc3JjX29mZnMsIGxlbiwgZGVzdF9vZmZzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdFtkZXN0X29mZnMgKyBpXSA9IHNyY1tzcmNfb2ZmcyArIGldO1xuICAgIH1cbiAgfSxcbiAgLy8gSm9pbiBhcnJheSBvZiBjaHVua3MgdG8gc2luZ2xlIGFycmF5LlxuICBmbGF0dGVuQ2h1bmtzOiBmdW5jdGlvbiAoY2h1bmtzKSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdC5hcHBseShbXSwgY2h1bmtzKTtcbiAgfVxufTtcblxuXG4vLyBFbmFibGUvRGlzYWJsZSB0eXBlZCBhcnJheXMgdXNlLCBmb3IgdGVzdGluZ1xuLy9cbmV4cG9ydHMuc2V0VHlwZWQgPSBmdW5jdGlvbiAob24pIHtcbiAgaWYgKG9uKSB7XG4gICAgZXhwb3J0cy5CdWY4ICA9IFVpbnQ4QXJyYXk7XG4gICAgZXhwb3J0cy5CdWYxNiA9IFVpbnQxNkFycmF5O1xuICAgIGV4cG9ydHMuQnVmMzIgPSBJbnQzMkFycmF5O1xuICAgIGV4cG9ydHMuYXNzaWduKGV4cG9ydHMsIGZuVHlwZWQpO1xuICB9IGVsc2Uge1xuICAgIGV4cG9ydHMuQnVmOCAgPSBBcnJheTtcbiAgICBleHBvcnRzLkJ1ZjE2ID0gQXJyYXk7XG4gICAgZXhwb3J0cy5CdWYzMiA9IEFycmF5O1xuICAgIGV4cG9ydHMuYXNzaWduKGV4cG9ydHMsIGZuVW50eXBlZCk7XG4gIH1cbn07XG5cbmV4cG9ydHMuc2V0VHlwZWQoVFlQRURfT0spO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2pzemlwL34vcGFrby9saWIvdXRpbHMvY29tbW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){"use strict";eval("\nvar tryCatch = __webpack_require__(57);\nvar resolveThenable = __webpack_require__(55);\nvar states = __webpack_require__(56);\n\nexports.resolve = function (self, value) {\n  var result = tryCatch(getThen, value);\n  if (result.status === 'error') {\n    return exports.reject(self, result.value);\n  }\n  var thenable = result.value;\n\n  if (thenable) {\n    resolveThenable.safely(self, thenable);\n  } else {\n    self.state = states.FULFILLED;\n    self.outcome = value;\n    var i = -1;\n    var len = self.queue.length;\n    while (++i < len) {\n      self.queue[i].callFulfilled(value);\n    }\n  }\n  return self;\n};\nexports.reject = function (self, error) {\n  self.state = states.REJECTED;\n  self.outcome = error;\n  /* istanbul ignore else */\n  if (!process.browser) {\n    if (self.handled === states.UNHANDLED) {\n      __webpack_require__(40)(function () {\n        if (self.handled === states.UNHANDLED) {\n          process.emit('unhandledRejection', error, self);\n        }\n      });\n    }\n  }\n  var i = -1;\n  var len = self.queue.length;\n  while (++i < len) {\n    self.queue[i].callRejected(error);\n  }\n  return self;\n};\n\nfunction getThen(obj) {\n  // Make sure we only access the accessor once as required by the spec\n  var then = obj && obj.then;\n  if (obj && typeof obj === 'object' && typeof then === 'function') {\n    return function appyThen() {\n      then.apply(obj, arguments);\n    };\n  }\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2xpZS9saWIvaGFuZGxlcnMuanM/MzY1YiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciB0cnlDYXRjaCA9IHJlcXVpcmUoJy4vdHJ5Q2F0Y2gnKTtcbnZhciByZXNvbHZlVGhlbmFibGUgPSByZXF1aXJlKCcuL3Jlc29sdmVUaGVuYWJsZScpO1xudmFyIHN0YXRlcyA9IHJlcXVpcmUoJy4vc3RhdGVzJyk7XG5cbmV4cG9ydHMucmVzb2x2ZSA9IGZ1bmN0aW9uIChzZWxmLCB2YWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2goZ2V0VGhlbiwgdmFsdWUpO1xuICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gJ2Vycm9yJykge1xuICAgIHJldHVybiBleHBvcnRzLnJlamVjdChzZWxmLCByZXN1bHQudmFsdWUpO1xuICB9XG4gIHZhciB0aGVuYWJsZSA9IHJlc3VsdC52YWx1ZTtcblxuICBpZiAodGhlbmFibGUpIHtcbiAgICByZXNvbHZlVGhlbmFibGUuc2FmZWx5KHNlbGYsIHRoZW5hYmxlKTtcbiAgfSBlbHNlIHtcbiAgICBzZWxmLnN0YXRlID0gc3RhdGVzLkZVTEZJTExFRDtcbiAgICBzZWxmLm91dGNvbWUgPSB2YWx1ZTtcbiAgICB2YXIgaSA9IC0xO1xuICAgIHZhciBsZW4gPSBzZWxmLnF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgICBzZWxmLnF1ZXVlW2ldLmNhbGxGdWxmaWxsZWQodmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2VsZjtcbn07XG5leHBvcnRzLnJlamVjdCA9IGZ1bmN0aW9uIChzZWxmLCBlcnJvcikge1xuICBzZWxmLnN0YXRlID0gc3RhdGVzLlJFSkVDVEVEO1xuICBzZWxmLm91dGNvbWUgPSBlcnJvcjtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKCFwcm9jZXNzLmJyb3dzZXIpIHtcbiAgICBpZiAoc2VsZi5oYW5kbGVkID09PSBzdGF0ZXMuVU5IQU5ETEVEKSB7XG4gICAgICByZXF1aXJlKCdpbW1lZGlhdGUnKShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChzZWxmLmhhbmRsZWQgPT09IHN0YXRlcy5VTkhBTkRMRUQpIHtcbiAgICAgICAgICBwcm9jZXNzLmVtaXQoJ3VuaGFuZGxlZFJlamVjdGlvbicsIGVycm9yLCBzZWxmKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHZhciBpID0gLTE7XG4gIHZhciBsZW4gPSBzZWxmLnF1ZXVlLmxlbmd0aDtcbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIHNlbGYucXVldWVbaV0uY2FsbFJlamVjdGVkKGVycm9yKTtcbiAgfVxuICByZXR1cm4gc2VsZjtcbn07XG5cbmZ1bmN0aW9uIGdldFRoZW4ob2JqKSB7XG4gIC8vIE1ha2Ugc3VyZSB3ZSBvbmx5IGFjY2VzcyB0aGUgYWNjZXNzb3Igb25jZSBhcyByZXF1aXJlZCBieSB0aGUgc3BlY1xuICB2YXIgdGhlbiA9IG9iaiAmJiBvYmoudGhlbjtcbiAgaWYgKG9iaiAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmdW5jdGlvbiBhcHB5VGhlbigpIHtcbiAgICAgIHRoZW4uYXBwbHkob2JqLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9saWUvbGliL2hhbmRsZXJzLmpzXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){"use strict";eval('\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar root = __webpack_require__(39)();\nvar shared = __webpack_require__(2)();\nvar rcolour = __webpack_require__(163);\n\nvar PlaceholderFC = function (_root$Root) {\n    _inherits(PlaceholderFC, _root$Root);\n\n    // contains dummy stuff to stop placeholder states from freaking out\n    // prior to a layer being loaded.\n\n    function PlaceholderFC(parent, name) {\n        _classCallCheck(this, PlaceholderFC);\n\n        var _this = _possibleConstructorReturn(this, (PlaceholderFC.__proto__ || Object.getPrototypeOf(PlaceholderFC)).call(this));\n\n        _this._parent = parent;\n        _this.name = name;\n        _this._layerType = shared.clientLayerType.UNKNOWN;\n\n        var c = rcolour({ saturation: 0.4, value: 0.8 });\n        _this.symbology = [parent._apiRef.symbology.generatePlaceholderSymbology(name || \'?\', c)];\n        return _this;\n    }\n\n    _createClass(PlaceholderFC, [{\n        key: \'getVisibility\',\n        value: function getVisibility() {\n            // TODO enhance to have some default value, assigned in constructor?\n            // TODO can a user toggle placeholders? does state need to be updated?\n            return true;\n        }\n\n        // TODO do we need to check if parent exists? Placeholder use-cases are not flushed out right now.\n\n    }, {\n        key: \'state\',\n        get: function get() {\n            return this._parent._state;\n        }\n    }, {\n        key: \'layerType\',\n        get: function get() {\n            return this._layerType;\n        },\n        set: function set(value) {\n            this._layerType = value;\n        }\n    }]);\n\n    return PlaceholderFC;\n}(root.Root);\n\nmodule.exports = function () {\n    return {\n        PlaceholderFC: PlaceholderFC\n    };\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXIvbGF5ZXJSZWMvcGxhY2Vob2xkZXJGQy5qcz9hZTFiIl0sIm5hbWVzIjpbInJvb3QiLCJyZXF1aXJlIiwic2hhcmVkIiwicmNvbG91ciIsIlBsYWNlaG9sZGVyRkMiLCJwYXJlbnQiLCJuYW1lIiwiX3BhcmVudCIsIl9sYXllclR5cGUiLCJjbGllbnRMYXllclR5cGUiLCJVTktOT1dOIiwiYyIsInNhdHVyYXRpb24iLCJ2YWx1ZSIsInN5bWJvbG9neSIsIl9hcGlSZWYiLCJnZW5lcmF0ZVBsYWNlaG9sZGVyU3ltYm9sb2d5IiwiX3N0YXRlIiwiUm9vdCIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7O0FBQ0EsSUFBTUEsT0FBTyxtQkFBQUMsQ0FBUSxFQUFSLEdBQWI7QUFDQSxJQUFNQyxTQUFTLG1CQUFBRCxDQUFRLENBQVIsR0FBZjtBQUNBLElBQU1FLFVBQVUsbUJBQUFGLENBQVEsR0FBUixDQUFoQjs7SUFFTUcsYTs7O0FBQ0Y7QUFDQTs7QUFFQSwyQkFBYUMsTUFBYixFQUFxQkMsSUFBckIsRUFBMkI7QUFBQTs7QUFBQTs7QUFFdkIsY0FBS0MsT0FBTCxHQUFlRixNQUFmO0FBQ0EsY0FBS0MsSUFBTCxHQUFZQSxJQUFaO0FBQ0EsY0FBS0UsVUFBTCxHQUFrQk4sT0FBT08sZUFBUCxDQUF1QkMsT0FBekM7O0FBRUEsWUFBTUMsSUFBSVIsUUFBUSxFQUFFUyxZQUFZLEdBQWQsRUFBbUJDLE9BQU8sR0FBMUIsRUFBUixDQUFWO0FBQ0EsY0FBS0MsU0FBTCxHQUFpQixDQUFDVCxPQUFPVSxPQUFQLENBQWVELFNBQWYsQ0FBeUJFLDRCQUF6QixDQUFzRFYsUUFBUSxHQUE5RCxFQUFtRUssQ0FBbkUsQ0FBRCxDQUFqQjtBQVB1QjtBQVExQjs7Ozt3Q0FFZ0I7QUFDYjtBQUNBO0FBQ0EsbUJBQU8sSUFBUDtBQUNIOztBQUVEOzs7OzRCQUNhO0FBQUUsbUJBQU8sS0FBS0osT0FBTCxDQUFhVSxNQUFwQjtBQUE2Qjs7OzRCQUUzQjtBQUFDLG1CQUFPLEtBQUtULFVBQVo7QUFBeUIsUzswQkFDNUJLLEssRUFBTztBQUFFLGlCQUFLTCxVQUFMLEdBQWtCSyxLQUFsQjtBQUEwQjs7OztFQXhCMUJiLEtBQUtrQixJOztBQTRCakNDLE9BQU9DLE9BQVAsR0FBaUI7QUFBQSxXQUFPO0FBQ3BCaEI7QUFEb0IsS0FBUDtBQUFBLENBQWpCIiwiZmlsZSI6IjUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcbmNvbnN0IHJvb3QgPSByZXF1aXJlKCcuL3Jvb3QuanMnKSgpO1xyXG5jb25zdCBzaGFyZWQgPSByZXF1aXJlKCcuL3NoYXJlZC5qcycpKCk7XHJcbmNvbnN0IHJjb2xvdXIgPSByZXF1aXJlKCdyY29sb3InKTtcclxuXHJcbmNsYXNzIFBsYWNlaG9sZGVyRkMgZXh0ZW5kcyByb290LlJvb3Qge1xyXG4gICAgLy8gY29udGFpbnMgZHVtbXkgc3R1ZmYgdG8gc3RvcCBwbGFjZWhvbGRlciBzdGF0ZXMgZnJvbSBmcmVha2luZyBvdXRcclxuICAgIC8vIHByaW9yIHRvIGEgbGF5ZXIgYmVpbmcgbG9hZGVkLlxyXG5cclxuICAgIGNvbnN0cnVjdG9yIChwYXJlbnQsIG5hbWUpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMuX2xheWVyVHlwZSA9IHNoYXJlZC5jbGllbnRMYXllclR5cGUuVU5LTk9XTjtcclxuXHJcbiAgICAgICAgY29uc3QgYyA9IHJjb2xvdXIoeyBzYXR1cmF0aW9uOiAwLjQsIHZhbHVlOiAwLjggfSk7XHJcbiAgICAgICAgdGhpcy5zeW1ib2xvZ3kgPSBbcGFyZW50Ll9hcGlSZWYuc3ltYm9sb2d5LmdlbmVyYXRlUGxhY2Vob2xkZXJTeW1ib2xvZ3kobmFtZSB8fCAnPycsIGMpXTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRWaXNpYmlsaXR5ICgpIHtcclxuICAgICAgICAvLyBUT0RPIGVuaGFuY2UgdG8gaGF2ZSBzb21lIGRlZmF1bHQgdmFsdWUsIGFzc2lnbmVkIGluIGNvbnN0cnVjdG9yP1xyXG4gICAgICAgIC8vIFRPRE8gY2FuIGEgdXNlciB0b2dnbGUgcGxhY2Vob2xkZXJzPyBkb2VzIHN0YXRlIG5lZWQgdG8gYmUgdXBkYXRlZD9cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUT0RPIGRvIHdlIG5lZWQgdG8gY2hlY2sgaWYgcGFyZW50IGV4aXN0cz8gUGxhY2Vob2xkZXIgdXNlLWNhc2VzIGFyZSBub3QgZmx1c2hlZCBvdXQgcmlnaHQgbm93LlxyXG4gICAgZ2V0IHN0YXRlICgpIHsgcmV0dXJuIHRoaXMuX3BhcmVudC5fc3RhdGU7IH1cclxuXHJcbiAgICBnZXQgbGF5ZXJUeXBlICgpIHtyZXR1cm4gdGhpcy5fbGF5ZXJUeXBlOyB9XHJcbiAgICBzZXQgbGF5ZXJUeXBlICh2YWx1ZSkgeyB0aGlzLl9sYXllclR5cGUgPSB2YWx1ZTsgfVxyXG5cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSAoKSA9PiAoe1xyXG4gICAgUGxhY2Vob2xkZXJGQ1xyXG59KTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2xheWVyL2xheWVyUmVjL3BsYWNlaG9sZGVyRkMuanMiXSwic291cmNlUm9vdCI6IiJ9')},function(module,exports,__webpack_require__){"use strict";eval('\nexports.base64 = true;\nexports.array = true;\nexports.string = true;\nexports.arraybuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";\n// contains true if JSZip can read/generate nodejs Buffer, false otherwise.\n// Browserify will provide a Buffer implementation for browsers, which is\n// an augmented Uint8Array (i.e., can be used as either Buffer or U8).\nexports.nodebuffer = typeof Buffer !== "undefined";\n// contains true if JSZip can read/generate Uint8Array, false otherwise.\nexports.uint8array = typeof Uint8Array !== "undefined";\n\nif (typeof ArrayBuffer === "undefined") {\n    exports.blob = false;\n}\nelse {\n    var buffer = new ArrayBuffer(0);\n    try {\n        exports.blob = new Blob([buffer], {\n            type: "application/zip"\n        }).size === 0;\n    }\n    catch (e) {\n        try {\n            var Builder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;\n            var builder = new Builder();\n            builder.append(buffer);\n            exports.blob = builder.getBlob(\'application/zip\').size === 0;\n        }\n        catch (e) {\n            exports.blob = false;\n        }\n    }\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2pzemlwL2xpYi9zdXBwb3J0LmpzPzZiNDgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5leHBvcnRzLmJhc2U2NCA9IHRydWU7XG5leHBvcnRzLmFycmF5ID0gdHJ1ZTtcbmV4cG9ydHMuc3RyaW5nID0gdHJ1ZTtcbmV4cG9ydHMuYXJyYXlidWZmZXIgPSB0eXBlb2YgQXJyYXlCdWZmZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIFVpbnQ4QXJyYXkgIT09IFwidW5kZWZpbmVkXCI7XG4vLyBjb250YWlucyB0cnVlIGlmIEpTWmlwIGNhbiByZWFkL2dlbmVyYXRlIG5vZGVqcyBCdWZmZXIsIGZhbHNlIG90aGVyd2lzZS5cbi8vIEJyb3dzZXJpZnkgd2lsbCBwcm92aWRlIGEgQnVmZmVyIGltcGxlbWVudGF0aW9uIGZvciBicm93c2Vycywgd2hpY2ggaXNcbi8vIGFuIGF1Z21lbnRlZCBVaW50OEFycmF5IChpLmUuLCBjYW4gYmUgdXNlZCBhcyBlaXRoZXIgQnVmZmVyIG9yIFU4KS5cbmV4cG9ydHMubm9kZWJ1ZmZlciA9IHR5cGVvZiBCdWZmZXIgIT09IFwidW5kZWZpbmVkXCI7XG4vLyBjb250YWlucyB0cnVlIGlmIEpTWmlwIGNhbiByZWFkL2dlbmVyYXRlIFVpbnQ4QXJyYXksIGZhbHNlIG90aGVyd2lzZS5cbmV4cG9ydHMudWludDhhcnJheSA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSBcInVuZGVmaW5lZFwiO1xuXG5pZiAodHlwZW9mIEFycmF5QnVmZmVyID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgZXhwb3J0cy5ibG9iID0gZmFsc2U7XG59XG5lbHNlIHtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKDApO1xuICAgIHRyeSB7XG4gICAgICAgIGV4cG9ydHMuYmxvYiA9IG5ldyBCbG9iKFtidWZmZXJdLCB7XG4gICAgICAgICAgICB0eXBlOiBcImFwcGxpY2F0aW9uL3ppcFwiXG4gICAgICAgIH0pLnNpemUgPT09IDA7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgQnVpbGRlciA9IHdpbmRvdy5CbG9iQnVpbGRlciB8fCB3aW5kb3cuV2ViS2l0QmxvYkJ1aWxkZXIgfHwgd2luZG93Lk1vekJsb2JCdWlsZGVyIHx8IHdpbmRvdy5NU0Jsb2JCdWlsZGVyO1xuICAgICAgICAgICAgdmFyIGJ1aWxkZXIgPSBuZXcgQnVpbGRlcigpO1xuICAgICAgICAgICAgYnVpbGRlci5hcHBlbmQoYnVmZmVyKTtcbiAgICAgICAgICAgIGV4cG9ydHMuYmxvYiA9IGJ1aWxkZXIuZ2V0QmxvYignYXBwbGljYXRpb24vemlwJykuc2l6ZSA9PT0gMDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZXhwb3J0cy5ibG9iID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vanN6aXAvbGliL3N1cHBvcnQuanNcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports){eval("module.exports = function(x) {\n  if (Math.abs(x) > 1) {\n    x = (x > 1) ? 1 : -1;\n  }\n  return Math.asin(x);\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9jb21tb24vYXNpbnouanM/OTNkNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oeCkge1xuICBpZiAoTWF0aC5hYnMoeCkgPiAxKSB7XG4gICAgeCA9ICh4ID4gMSkgPyAxIDogLTE7XG4gIH1cbiAgcmV0dXJuIE1hdGguYXNpbih4KTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Byb2o0L2xpYi9jb21tb24vYXNpbnouanNcbi8vIG1vZHVsZSBpZCA9IDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports){eval("module.exports = function(eccent, sinphi, cosphi) {\n  var con = eccent * sinphi;\n  return cosphi / (Math.sqrt(1 - con * con));\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9jb21tb24vbXNmbnouanM/OTRiYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI4LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihlY2NlbnQsIHNpbnBoaSwgY29zcGhpKSB7XG4gIHZhciBjb24gPSBlY2NlbnQgKiBzaW5waGk7XG4gIHJldHVybiBjb3NwaGkgLyAoTWF0aC5zcXJ0KDEgLSBjb24gKiBjb24pKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Byb2o0L2xpYi9jb21tb24vbXNmbnouanNcbi8vIG1vZHVsZSBpZCA9IDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = INTERNAL;\n\nfunction INTERNAL() {}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2xpZS9saWIvSU5URVJOQUwuanM/YmEwNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTs7QUFFQSIsImZpbGUiOiI5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IElOVEVSTkFMO1xuXG5mdW5jdGlvbiBJTlRFUk5BTCgpIHt9XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xpZS9saWIvSU5URVJOQUwuanNcbi8vIG1vZHVsZSBpZCA9IDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar unwrap = __webpack_require__(58);\nvar INTERNAL = __webpack_require__(9);\nvar resolveThenable = __webpack_require__(55);\nvar states = __webpack_require__(56);\nvar QueueItem = __webpack_require__(116);\n\nmodule.exports = Promise;\nfunction Promise(resolver) {\n  if (!(this instanceof Promise)) {\n    return new Promise(resolver);\n  }\n  if (typeof resolver !== 'function') {\n    throw new TypeError('resolver must be a function');\n  }\n  this.state = states.PENDING;\n  this.queue = [];\n  this.outcome = void 0;\n  /* istanbul ignore else */\n  if (!process.browser) {\n    this.handled = states.UNHANDLED;\n  }\n  if (resolver !== INTERNAL) {\n    resolveThenable.safely(this, resolver);\n  }\n}\n\nPromise.prototype['catch'] = function (onRejected) {\n  return this.then(null, onRejected);\n};\nPromise.prototype.then = function (onFulfilled, onRejected) {\n  if (typeof onFulfilled !== 'function' && this.state === states.FULFILLED ||\n    typeof onRejected !== 'function' && this.state === states.REJECTED) {\n    return this;\n  }\n  var promise = new Promise(INTERNAL);\n  /* istanbul ignore else */\n  if (!process.browser) {\n    if (typeof onRejected === 'function' && this.handled === states.UNHANDLED) {\n      this.handled = this.HANDLED;\n    }\n  }\n  if (this.state !== states.PENDING) {\n    var resolver = this.state === states.FULFILLED ? onFulfilled : onRejected;\n    unwrap(promise, resolver, this.outcome);\n  } else {\n    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));\n  }\n\n  return promise;\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2xpZS9saWIvcHJvbWlzZS5qcz81MGIyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQSIsImZpbGUiOiIxMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHVud3JhcCA9IHJlcXVpcmUoJy4vdW53cmFwJyk7XG52YXIgSU5URVJOQUwgPSByZXF1aXJlKCcuL0lOVEVSTkFMJyk7XG52YXIgcmVzb2x2ZVRoZW5hYmxlID0gcmVxdWlyZSgnLi9yZXNvbHZlVGhlbmFibGUnKTtcbnZhciBzdGF0ZXMgPSByZXF1aXJlKCcuL3N0YXRlcycpO1xudmFyIFF1ZXVlSXRlbSA9IHJlcXVpcmUoJy4vcXVldWVJdGVtJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvbWlzZTtcbmZ1bmN0aW9uIFByb21pc2UocmVzb2x2ZXIpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFByb21pc2UpKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmVyKTtcbiAgfVxuICBpZiAodHlwZW9mIHJlc29sdmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncmVzb2x2ZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cbiAgdGhpcy5zdGF0ZSA9IHN0YXRlcy5QRU5ESU5HO1xuICB0aGlzLnF1ZXVlID0gW107XG4gIHRoaXMub3V0Y29tZSA9IHZvaWQgMDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKCFwcm9jZXNzLmJyb3dzZXIpIHtcbiAgICB0aGlzLmhhbmRsZWQgPSBzdGF0ZXMuVU5IQU5ETEVEO1xuICB9XG4gIGlmIChyZXNvbHZlciAhPT0gSU5URVJOQUwpIHtcbiAgICByZXNvbHZlVGhlbmFibGUuc2FmZWx5KHRoaXMsIHJlc29sdmVyKTtcbiAgfVxufVxuXG5Qcm9taXNlLnByb3RvdHlwZVsnY2F0Y2gnXSA9IGZ1bmN0aW9uIChvblJlamVjdGVkKSB7XG4gIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3RlZCk7XG59O1xuUHJvbWlzZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uIChvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICBpZiAodHlwZW9mIG9uRnVsZmlsbGVkICE9PSAnZnVuY3Rpb24nICYmIHRoaXMuc3RhdGUgPT09IHN0YXRlcy5GVUxGSUxMRUQgfHxcbiAgICB0eXBlb2Ygb25SZWplY3RlZCAhPT0gJ2Z1bmN0aW9uJyAmJiB0aGlzLnN0YXRlID09PSBzdGF0ZXMuUkVKRUNURUQpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKCFwcm9jZXNzLmJyb3dzZXIpIHtcbiAgICBpZiAodHlwZW9mIG9uUmVqZWN0ZWQgPT09ICdmdW5jdGlvbicgJiYgdGhpcy5oYW5kbGVkID09PSBzdGF0ZXMuVU5IQU5ETEVEKSB7XG4gICAgICB0aGlzLmhhbmRsZWQgPSB0aGlzLkhBTkRMRUQ7XG4gICAgfVxuICB9XG4gIGlmICh0aGlzLnN0YXRlICE9PSBzdGF0ZXMuUEVORElORykge1xuICAgIHZhciByZXNvbHZlciA9IHRoaXMuc3RhdGUgPT09IHN0YXRlcy5GVUxGSUxMRUQgPyBvbkZ1bGZpbGxlZCA6IG9uUmVqZWN0ZWQ7XG4gICAgdW53cmFwKHByb21pc2UsIHJlc29sdmVyLCB0aGlzLm91dGNvbWUpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucXVldWUucHVzaChuZXcgUXVldWVJdGVtKHByb21pc2UsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSk7XG4gIH1cblxuICByZXR1cm4gcHJvbWlzZTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbGllL2xpYi9wcm9taXNlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("var HALF_PI = Math.PI/2;\nvar sign = __webpack_require__(17);\n\nmodule.exports = function(x) {\n  return (Math.abs(x) < HALF_PI) ? x : (x - (sign(x) * Math.PI));\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9jb21tb24vYWRqdXN0X2xhdC5qcz8zNjM4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwiZmlsZSI6IjExLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIEhBTEZfUEkgPSBNYXRoLlBJLzI7XG52YXIgc2lnbiA9IHJlcXVpcmUoJy4vc2lnbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIChNYXRoLmFicyh4KSA8IEhBTEZfUEkpID8geCA6ICh4IC0gKHNpZ24oeCkgKiBNYXRoLlBJKSk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcm9qNC9saWIvY29tbW9uL2FkanVzdF9sYXQuanNcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports){eval("module.exports = function(x) {\n  return (1 - 0.25 * x * (1 + x / 16 * (3 + 1.25 * x)));\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9jb21tb24vZTBmbi5qcz83NGMyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSIsImZpbGUiOiIxMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4gKDEgLSAwLjI1ICogeCAqICgxICsgeCAvIDE2ICogKDMgKyAxLjI1ICogeCkpKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Byb2o0L2xpYi9jb21tb24vZTBmbi5qc1xuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports){eval("module.exports = function(x) {\n  return (0.375 * x * (1 + 0.25 * x * (1 + 0.46875 * x)));\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9jb21tb24vZTFmbi5qcz8zZmVjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSIsImZpbGUiOiIxMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4gKDAuMzc1ICogeCAqICgxICsgMC4yNSAqIHggKiAoMSArIDAuNDY4NzUgKiB4KSkpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHJvajQvbGliL2NvbW1vbi9lMWZuLmpzXG4vLyBtb2R1bGUgaWQgPSAxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports){eval("module.exports = function(x) {\n  return (0.05859375 * x * x * (1 + 0.75 * x));\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9jb21tb24vZTJmbi5qcz8zYjAwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSIsImZpbGUiOiIxNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4gKDAuMDU4NTkzNzUgKiB4ICogeCAqICgxICsgMC43NSAqIHgpKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Byb2o0L2xpYi9jb21tb24vZTJmbi5qc1xuLy8gbW9kdWxlIGlkID0gMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports){eval("module.exports = function(x) {\n  return (x * x * x * (35 / 3072));\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9jb21tb24vZTNmbi5qcz9mZmQwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSIsImZpbGUiOiIxNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4gKHggKiB4ICogeCAqICgzNSAvIDMwNzIpKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Byb2o0L2xpYi9jb21tb24vZTNmbi5qc1xuLy8gbW9kdWxlIGlkID0gMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports){eval("module.exports = function(e0, e1, e2, e3, phi) {\n  return (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi));\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9jb21tb24vbWxmbi5qcz8zN2YyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSIsImZpbGUiOiIxNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZTAsIGUxLCBlMiwgZTMsIHBoaSkge1xuICByZXR1cm4gKGUwICogcGhpIC0gZTEgKiBNYXRoLnNpbigyICogcGhpKSArIGUyICogTWF0aC5zaW4oNCAqIHBoaSkgLSBlMyAqIE1hdGguc2luKDYgKiBwaGkpKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Byb2o0L2xpYi9jb21tb24vbWxmbi5qc1xuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports){eval("module.exports = function(x) {\n  return x<0 ? -1 : 1;\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9jb21tb24vc2lnbi5qcz8wYmE0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSIsImZpbGUiOiIxNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4geDwwID8gLTEgOiAxO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHJvajQvbGliL2NvbW1vbi9zaWduLmpzXG4vLyBtb2R1bGUgaWQgPSAxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar shared = __webpack_require__(2)();\nvar basicFC = __webpack_require__(19)();\n\n/**\r\n * @class AttribFC\r\n */\n\nvar AttribFC = function (_basicFC$BasicFC) {\n    _inherits(AttribFC, _basicFC$BasicFC);\n\n    // attribute-specific variant for feature class object.\n    // deals with stuff specific to a feature class that has attributes\n\n    /**\r\n     * Create an attribute specific feature class object\r\n     * @param {Object} parent        the Record object that this Feature Class belongs to\r\n     * @param {String} idx           the service index of this Feature Class. an integer in string format. use '0' for non-indexed sources.\r\n     * @param {Object} layerPackage  a layer package object from the attribute module for this feature class\r\n     * @param {Object} config        the config object for this sublayer\r\n     */\n    function AttribFC(parent, idx, layerPackage, config) {\n        _classCallCheck(this, AttribFC);\n\n        var _this = _possibleConstructorReturn(this, (AttribFC.__proto__ || Object.getPrototypeOf(AttribFC)).call(this, parent, idx, config));\n\n        _this._layerPackage = layerPackage;\n        _this._geometryType = undefined; // this indicates unknown to the ui.\n        _this._fcount = undefined;\n        _this._quickCache = {};\n        return _this;\n    }\n\n    /**\r\n    * Returns attribute data for this FC.\r\n    *\r\n    * @function getAttribs\r\n    * @returns {Promise}         resolves with a layer attribute data object\r\n    */\n\n\n    _createClass(AttribFC, [{\n        key: 'getAttribs',\n        value: function getAttribs() {\n            return this._layerPackage.getAttribs();\n        }\n    }, {\n        key: 'attribsLoaded',\n        value: function attribsLoaded() {\n            return !!this._layerPackage._attribData;\n        }\n\n        /**\r\n        * Returns layer-specific data for this FC.\r\n        *\r\n        * @function getLayerData\r\n        * @returns {Promise}         resolves with a layer data object\r\n        */\n\n    }, {\n        key: 'getLayerData',\n        value: function getLayerData() {\n            return this._layerPackage.layerData;\n        }\n\n        // this will actively download / refresh the internal symbology\n\n    }, {\n        key: 'loadSymbology',\n        value: function loadSymbology() {\n            var _this2 = this;\n\n            return this.getLayerData().then(function (lData) {\n                if (lData.layerType === 'Feature Layer') {\n                    // feature always has a single item, so index 0\n                    _this2.symbology = shared.makeSymbologyArray(lData.legend.layers[0].legend);\n                } else {\n                    // non-feature source. use legend server\n                    return _get(AttribFC.prototype.__proto__ || Object.getPrototypeOf(AttribFC.prototype), 'loadSymbology', _this2).call(_this2);\n                }\n            });\n        }\n\n        /**\r\n        * Extract the feature name from a feature as best we can.\r\n        *\r\n        * @function getFeatureName\r\n        * @param {String} objId      the object id of the attribute\r\n        * @param {Object} attribs    the dictionary of attributes for the feature.\r\n        * @returns {String}          the name of the feature\r\n        */\n\n    }, {\n        key: 'getFeatureName',\n        value: function getFeatureName(objId, attribs) {\n            // TODO revisit the objId parameter.  Do we actually need this fallback anymore?\n            // NOTE: we used to have fallback logic here that would use layer settings\n            //       if this.nameField had no value. Logic has changed to now push\n            //       layer settings to this.nameField during the load event of the\n            //       Record.\n\n            if (this.nameField && attribs) {\n                // extract name\n                return attribs[this.nameField];\n            } else {\n                // FIXME wire in \"feature\" to translation service\n                return 'Feature ' + objId;\n            }\n        }\n\n        /**\r\n         * Retrieves attributes from a layer for a specified feature index\r\n         * @return {Promise}            promise resolving with formatted attributes to be consumed by the datagrid and esri feature identify\r\n         */\n\n    }, {\n        key: 'getFormattedAttributes',\n        value: function getFormattedAttributes() {\n            var _this3 = this;\n\n            if (this._formattedAttributes) {\n                return this._formattedAttributes;\n            }\n\n            // TODO after refactor, consider changing this to a warning and just return some dummy value\n            if (this.layerType === shared.clientLayerType.ESRI_RASTER) {\n                throw new Error('Attempting to get attributes on a raster layer.');\n            }\n\n            this._formattedAttributes = Promise.all([this.getAttribs(), this.getLayerData()]).then(function (_ref) {\n                var _ref2 = _slicedToArray(_ref, 2),\n                    aData = _ref2[0],\n                    lData = _ref2[1];\n\n                // create columns array consumable by datables\n                var columns = lData.fields.filter(function (field) {\n                    return (\n\n                        // assuming there is at least one attribute - empty attribute budnle promises should be rejected, so it never even gets this far\n                        // filter out fields where there is no corresponding attribute data\n                        aData.features[0].attributes.hasOwnProperty(field.name)\n                    );\n                }).map(function (field) {\n                    return {\n                        data: field.name,\n                        title: field.alias || field.name\n                    };\n                });\n\n                // derive the icon for the row\n                var rows = aData.features.map(function (feature) {\n                    var att = feature.attributes;\n                    att.rvInteractive = '';\n                    att.rvSymbol = _this3._parent._apiRef.symbology.getGraphicIcon(att, lData.renderer);\n                    return att;\n                });\n\n                return {\n                    columns: columns,\n                    rows: rows,\n                    fields: lData.fields, // keep fields for reference ...\n                    oidField: lData.oidField, // ... keep a reference to id field ...\n                    oidIndex: aData.oidIndex, // ... and keep id mapping array\n                    renderer: lData.renderer\n                };\n            }).catch(function () {\n                delete _this3._formattedAttributes; // delete cached promise when the geoApi `getAttribs` call fails, so it will be requested again next time `getAttributes` is called;\n                throw new Error('Attrib loading failed');\n            });\n\n            return this._formattedAttributes;\n        }\n\n        /**\r\n         * Check to see if the attribute in question is an esriFieldTypeDate type.\r\n         *\r\n         * @param {String} attribName     the attribute name we want to check if it's a date or not\r\n         * @return {Promise}              resolves to true or false based on the attribName type being esriFieldTypeDate\r\n         */\n\n    }, {\n        key: 'checkDateType',\n        value: function checkDateType(attribName) {\n            // TEST STATUS none\n            // grab attribute info (waiting for it it finish loading)\n            return this.getLayerData().then(function (lData) {\n                // inspect attribute fields\n                if (lData.fields) {\n                    var attribField = lData.fields.find(function (field) {\n                        return field.name === attribName;\n                    });\n                    if (attribField && attribField.type) {\n                        return attribField.type === 'esriFieldTypeDate';\n                    }\n                }\n                return false;\n            });\n        }\n\n        /**\r\n         * Get the best user-friendly name of a field. Uses alias if alias is defined, else uses the system attribute name.\r\n         *\r\n         * @param {String} attribName     the attribute name we want a nice name for\r\n         * @return {Promise}              resolves to the best available user friendly attribute name\r\n         */\n\n    }, {\n        key: 'aliasedFieldName',\n        value: function aliasedFieldName(attribName) {\n            // TEST STATUS none\n            // grab attribute info (waiting for it it finish loading)\n            return this.getLayerData().then(function (lData) {\n                return AttribFC.aliasedFieldNameDirect(attribName, lData.fields);\n            });\n        }\n    }, {\n        key: 'getServerFeatureInfo',\n\n\n        /**\r\n        * Fetches feature information, including geometry, from esri servers for feature layer.\r\n        * @param {Integer} objectId for feature to be retrived from the server\r\n        * @returns {Promise} promise resolves with an esri Graphic (http://resources.arcgis.com/en/help/arcgis-rest-api/#/Feature_Map_Service_Layer/02r3000000r9000000/)\r\n        */\n        value: function getServerFeatureInfo(objectId) {\n            var _this4 = this;\n\n            if (this._quickCache[objectId]) {\n                return Promise.resolve(this._quickCache[objectId]);\n            }\n            return new Promise(function (resolve, reject) {\n                var parent = _this4._parent;\n                var defData = parent._esriRequest({\n                    url: parent.rootUrl + '/' + _this4._idx + '/' + objectId,\n                    content: {\n                        f: 'json'\n                    },\n                    callbackParamName: 'callback',\n                    handleAs: 'json'\n                });\n\n                defData.then(function (serverFeature) {\n                    // server result omits spatial reference\n                    serverFeature.feature.geometry.spatialReference = parent._layer.spatialReference;\n                    _this4._quickCache[objectId] = serverFeature;\n                    resolve(serverFeature);\n                }, function (error) {\n                    console.warn(error);\n                    reject(error);\n                });\n            });\n        }\n\n        /**\r\n         * Fetches a graphic from the given layer.\r\n         * Will attempt local copy, will hit the server if not available.\r\n         *\r\n         * @function fetchGraphic\r\n         * @param  {Integer} objId          ID of object being searched for\r\n         * @param  {Boolean} ignoreLocal    indicates if we should ignore any local graphic in the layer. cached or server value will be used. defaults to false.\r\n         * @returns {Promise} resolves with a bundle of information. .graphic is the graphic; .source is where it came from - 'layer' or 'server'; also .layerFC for convenience\r\n         */\n\n    }, {\n        key: 'fetchGraphic',\n        value: function fetchGraphic(objId) {\n            var ignoreLocal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n\n            var layerObj = this._parent._layer;\n            var result = {\n                graphic: null,\n                source: null,\n                layerFC: this\n            };\n\n            // if feature layer, check if graphic is already loaded on the client. return it if found.\n            if (!ignoreLocal && layerObj.graphics) {\n                var myG = layerObj.graphics.find(function (g) {\n                    return g.attributes[layerObj.objectIdField] === objId;\n                });\n                if (myG) {\n                    result.graphic = myG;\n                    result.source = 'layer';\n                    return Promise.resolve(result);\n                }\n            }\n\n            // were not able to get a local copy of the graphic. to the server!\n            // TODO add some error handling. Cases: failed server call. server call is not a feature\n            return this.getServerFeatureInfo(objId).then(function (featureInfo) {\n                result.graphic = featureInfo.feature;\n                result.source = 'server';\n                return result;\n            });\n        }\n    }], [{\n        key: 'aliasedFieldNameDirect',\n        value: function aliasedFieldNameDirect(attribName, fields) {\n            // TEST STATUS none\n            var fName = attribName;\n\n            // search for aliases\n            if (fields) {\n                var attribField = fields.find(function (field) {\n                    return field.name === attribName;\n                });\n                if (attribField && attribField.alias && attribField.alias.length > 0) {\n                    fName = attribField.alias;\n                }\n            }\n            return fName;\n        }\n\n        /**\r\n         * Convert an attribute set so that any keys using aliases are converted to proper fields\r\n         *\r\n         * @param  {Object} attribs      attribute key-value mapping, potentially with aliases as keys\r\n         * @param  {Array} fields       fields definition array for layer\r\n         * @return {Object}              attribute key-value mapping with fields as keys\r\n         */\n\n    }, {\n        key: 'unAliasAttribs',\n        value: function unAliasAttribs(attribs, fields) {\n            var newA = {};\n            fields.forEach(function (field) {\n                // attempt to extract on name. if not found, attempt to extract on alias\n                // dump value into the result\n                newA[field.name] = attribs.hasOwnProperty(field.name) ? attribs[field.name] : attribs[field.alias];\n            });\n            return newA;\n        }\n    }]);\n\n    return AttribFC;\n}(basicFC.BasicFC);\n\nmodule.exports = function () {\n    return {\n        AttribFC: AttribFC\n    };\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXIvbGF5ZXJSZWMvYXR0cmliRkMuanM/N2FhZCJdLCJuYW1lcyI6WyJzaGFyZWQiLCJyZXF1aXJlIiwiYmFzaWNGQyIsIkF0dHJpYkZDIiwicGFyZW50IiwiaWR4IiwibGF5ZXJQYWNrYWdlIiwiY29uZmlnIiwiX2xheWVyUGFja2FnZSIsIl9nZW9tZXRyeVR5cGUiLCJ1bmRlZmluZWQiLCJfZmNvdW50IiwiX3F1aWNrQ2FjaGUiLCJnZXRBdHRyaWJzIiwiX2F0dHJpYkRhdGEiLCJsYXllckRhdGEiLCJnZXRMYXllckRhdGEiLCJ0aGVuIiwibERhdGEiLCJsYXllclR5cGUiLCJzeW1ib2xvZ3kiLCJtYWtlU3ltYm9sb2d5QXJyYXkiLCJsZWdlbmQiLCJsYXllcnMiLCJvYmpJZCIsImF0dHJpYnMiLCJuYW1lRmllbGQiLCJfZm9ybWF0dGVkQXR0cmlidXRlcyIsImNsaWVudExheWVyVHlwZSIsIkVTUklfUkFTVEVSIiwiRXJyb3IiLCJQcm9taXNlIiwiYWxsIiwiYURhdGEiLCJjb2x1bW5zIiwiZmllbGRzIiwiZmlsdGVyIiwiZmVhdHVyZXMiLCJhdHRyaWJ1dGVzIiwiaGFzT3duUHJvcGVydHkiLCJmaWVsZCIsIm5hbWUiLCJtYXAiLCJkYXRhIiwidGl0bGUiLCJhbGlhcyIsInJvd3MiLCJhdHQiLCJmZWF0dXJlIiwicnZJbnRlcmFjdGl2ZSIsInJ2U3ltYm9sIiwiX3BhcmVudCIsIl9hcGlSZWYiLCJnZXRHcmFwaGljSWNvbiIsInJlbmRlcmVyIiwib2lkRmllbGQiLCJvaWRJbmRleCIsImNhdGNoIiwiYXR0cmliTmFtZSIsImF0dHJpYkZpZWxkIiwiZmluZCIsInR5cGUiLCJhbGlhc2VkRmllbGROYW1lRGlyZWN0Iiwib2JqZWN0SWQiLCJyZXNvbHZlIiwicmVqZWN0IiwiZGVmRGF0YSIsIl9lc3JpUmVxdWVzdCIsInVybCIsInJvb3RVcmwiLCJfaWR4IiwiY29udGVudCIsImYiLCJjYWxsYmFja1BhcmFtTmFtZSIsImhhbmRsZUFzIiwic2VydmVyRmVhdHVyZSIsImdlb21ldHJ5Iiwic3BhdGlhbFJlZmVyZW5jZSIsIl9sYXllciIsImNvbnNvbGUiLCJ3YXJuIiwiZXJyb3IiLCJpZ25vcmVMb2NhbCIsImxheWVyT2JqIiwicmVzdWx0IiwiZ3JhcGhpYyIsInNvdXJjZSIsImxheWVyRkMiLCJncmFwaGljcyIsIm15RyIsImciLCJvYmplY3RJZEZpZWxkIiwiZ2V0U2VydmVyRmVhdHVyZUluZm8iLCJmZWF0dXJlSW5mbyIsImZOYW1lIiwibGVuZ3RoIiwibmV3QSIsImZvckVhY2giLCJCYXNpY0ZDIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7O0FBRUEsSUFBTUEsU0FBUyxtQkFBQUMsQ0FBUSxDQUFSLEdBQWY7QUFDQSxJQUFNQyxVQUFVLG1CQUFBRCxDQUFRLEVBQVIsR0FBaEI7O0FBRUE7Ozs7SUFHTUUsUTs7O0FBQ0Y7QUFDQTs7QUFFQTs7Ozs7OztBQU9BLHNCQUFhQyxNQUFiLEVBQXFCQyxHQUFyQixFQUEwQkMsWUFBMUIsRUFBd0NDLE1BQXhDLEVBQWdEO0FBQUE7O0FBQUEsd0hBQ3RDSCxNQURzQyxFQUM5QkMsR0FEOEIsRUFDekJFLE1BRHlCOztBQUc1QyxjQUFLQyxhQUFMLEdBQXFCRixZQUFyQjtBQUNBLGNBQUtHLGFBQUwsR0FBcUJDLFNBQXJCLENBSjRDLENBSVo7QUFDaEMsY0FBS0MsT0FBTCxHQUFlRCxTQUFmO0FBQ0EsY0FBS0UsV0FBTCxHQUFtQixFQUFuQjtBQU40QztBQU8vQzs7QUFFRDs7Ozs7Ozs7OztxQ0FNYztBQUNWLG1CQUFPLEtBQUtKLGFBQUwsQ0FBbUJLLFVBQW5CLEVBQVA7QUFDSDs7O3dDQUVnQjtBQUNiLG1CQUFPLENBQUMsQ0FBQyxLQUFLTCxhQUFMLENBQW1CTSxXQUE1QjtBQUNIOztBQUVEOzs7Ozs7Ozs7dUNBTWdCO0FBQ1osbUJBQU8sS0FBS04sYUFBTCxDQUFtQk8sU0FBMUI7QUFDSDs7QUFFRDs7Ozt3Q0FDaUI7QUFBQTs7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RUFBWXZCLE0sRUFBUTtBQUMvQztBQUNBLGdCQUFJMkQsUUFBUXBDLFVBQVo7O0FBRUE7QUFDQSxnQkFBSXZCLE1BQUosRUFBWTtBQUNSLG9CQUFNd0IsY0FBY3hCLE9BQU95QixJQUFQLENBQVksaUJBQVM7QUFDckMsMkJBQU9wQixNQUFNQyxJQUFOLEtBQWVpQixVQUF0QjtBQUNILGlCQUZtQixDQUFwQjtBQUdBLG9CQUFJQyxlQUFlQSxZQUFZZCxLQUEzQixJQUFvQ2MsWUFBWWQsS0FBWixDQUFrQmtELE1BQWxCLEdBQTJCLENBQW5FLEVBQXNFO0FBQ2xFRCw0QkFBUW5DLFlBQVlkLEtBQXBCO0FBQ0g7QUFDSjtBQUNELG1CQUFPaUQsS0FBUDtBQUNIOztBQUVEOzs7Ozs7Ozs7O3VDQU91QnJFLE8sRUFBU1UsTSxFQUFRO0FBQ3BDLGdCQUFNNkQsT0FBTyxFQUFiO0FBQ0E3RCxtQkFBTzhELE9BQVAsQ0FBZSxpQkFBUztBQUNwQjtBQUNBO0FBQ0FELHFCQUFLeEQsTUFBTUMsSUFBWCxJQUFtQmhCLFFBQVFjLGNBQVIsQ0FBdUJDLE1BQU1DLElBQTdCLElBQXFDaEIsUUFBUWUsTUFBTUMsSUFBZCxDQUFyQyxHQUEyRGhCLFFBQVFlLE1BQU1LLEtBQWQsQ0FBOUU7QUFDSCxhQUpEO0FBS0EsbUJBQU9tRCxJQUFQO0FBQ0g7Ozs7RUEzTWtCOUYsUUFBUWdHLE87O0FBeVIvQkMsT0FBT0MsT0FBUCxHQUFpQjtBQUFBLFdBQU87QUFDcEJqRztBQURvQixLQUFQO0FBQUEsQ0FBakIiLCJmaWxlIjoiMTguanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG5jb25zdCBzaGFyZWQgPSByZXF1aXJlKCcuL3NoYXJlZC5qcycpKCk7XHJcbmNvbnN0IGJhc2ljRkMgPSByZXF1aXJlKCcuL2Jhc2ljRkMuanMnKSgpO1xyXG5cclxuLyoqXHJcbiAqIEBjbGFzcyBBdHRyaWJGQ1xyXG4gKi9cclxuY2xhc3MgQXR0cmliRkMgZXh0ZW5kcyBiYXNpY0ZDLkJhc2ljRkMge1xyXG4gICAgLy8gYXR0cmlidXRlLXNwZWNpZmljIHZhcmlhbnQgZm9yIGZlYXR1cmUgY2xhc3Mgb2JqZWN0LlxyXG4gICAgLy8gZGVhbHMgd2l0aCBzdHVmZiBzcGVjaWZpYyB0byBhIGZlYXR1cmUgY2xhc3MgdGhhdCBoYXMgYXR0cmlidXRlc1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGFuIGF0dHJpYnV0ZSBzcGVjaWZpYyBmZWF0dXJlIGNsYXNzIG9iamVjdFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmVudCAgICAgICAgdGhlIFJlY29yZCBvYmplY3QgdGhhdCB0aGlzIEZlYXR1cmUgQ2xhc3MgYmVsb25ncyB0b1xyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkeCAgICAgICAgICAgdGhlIHNlcnZpY2UgaW5kZXggb2YgdGhpcyBGZWF0dXJlIENsYXNzLiBhbiBpbnRlZ2VyIGluIHN0cmluZyBmb3JtYXQuIHVzZSAnMCcgZm9yIG5vbi1pbmRleGVkIHNvdXJjZXMuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbGF5ZXJQYWNrYWdlICBhIGxheWVyIHBhY2thZ2Ugb2JqZWN0IGZyb20gdGhlIGF0dHJpYnV0ZSBtb2R1bGUgZm9yIHRoaXMgZmVhdHVyZSBjbGFzc1xyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyAgICAgICAgdGhlIGNvbmZpZyBvYmplY3QgZm9yIHRoaXMgc3VibGF5ZXJcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IgKHBhcmVudCwgaWR4LCBsYXllclBhY2thZ2UsIGNvbmZpZykge1xyXG4gICAgICAgIHN1cGVyKHBhcmVudCwgaWR4LCBjb25maWcpO1xyXG5cclxuICAgICAgICB0aGlzLl9sYXllclBhY2thZ2UgPSBsYXllclBhY2thZ2U7XHJcbiAgICAgICAgdGhpcy5fZ2VvbWV0cnlUeXBlID0gdW5kZWZpbmVkOyAvLyB0aGlzIGluZGljYXRlcyB1bmtub3duIHRvIHRoZSB1aS5cclxuICAgICAgICB0aGlzLl9mY291bnQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5fcXVpY2tDYWNoZSA9IHt9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBSZXR1cm5zIGF0dHJpYnV0ZSBkYXRhIGZvciB0aGlzIEZDLlxyXG4gICAgKlxyXG4gICAgKiBAZnVuY3Rpb24gZ2V0QXR0cmlic1xyXG4gICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gICAgICAgICByZXNvbHZlcyB3aXRoIGEgbGF5ZXIgYXR0cmlidXRlIGRhdGEgb2JqZWN0XHJcbiAgICAqL1xyXG4gICAgZ2V0QXR0cmlicyAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xheWVyUGFja2FnZS5nZXRBdHRyaWJzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgYXR0cmlic0xvYWRlZCAoKSB7XHJcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fbGF5ZXJQYWNrYWdlLl9hdHRyaWJEYXRhO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBSZXR1cm5zIGxheWVyLXNwZWNpZmljIGRhdGEgZm9yIHRoaXMgRkMuXHJcbiAgICAqXHJcbiAgICAqIEBmdW5jdGlvbiBnZXRMYXllckRhdGFcclxuICAgICogQHJldHVybnMge1Byb21pc2V9ICAgICAgICAgcmVzb2x2ZXMgd2l0aCBhIGxheWVyIGRhdGEgb2JqZWN0XHJcbiAgICAqL1xyXG4gICAgZ2V0TGF5ZXJEYXRhICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbGF5ZXJQYWNrYWdlLmxheWVyRGF0YTtcclxuICAgIH1cclxuXHJcbiAgICAvLyB0aGlzIHdpbGwgYWN0aXZlbHkgZG93bmxvYWQgLyByZWZyZXNoIHRoZSBpbnRlcm5hbCBzeW1ib2xvZ3lcclxuICAgIGxvYWRTeW1ib2xvZ3kgKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldExheWVyRGF0YSgpLnRoZW4obERhdGEgPT4ge1xyXG4gICAgICAgICAgICBpZiAobERhdGEubGF5ZXJUeXBlID09PSAnRmVhdHVyZSBMYXllcicpIHtcclxuICAgICAgICAgICAgICAgIC8vIGZlYXR1cmUgYWx3YXlzIGhhcyBhIHNpbmdsZSBpdGVtLCBzbyBpbmRleCAwXHJcbiAgICAgICAgICAgICAgICB0aGlzLnN5bWJvbG9neSA9IHNoYXJlZC5tYWtlU3ltYm9sb2d5QXJyYXkobERhdGEubGVnZW5kLmxheWVyc1swXS5sZWdlbmQpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gbm9uLWZlYXR1cmUgc291cmNlLiB1c2UgbGVnZW5kIHNlcnZlclxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1cGVyLmxvYWRTeW1ib2xvZ3koKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBFeHRyYWN0IHRoZSBmZWF0dXJlIG5hbWUgZnJvbSBhIGZlYXR1cmUgYXMgYmVzdCB3ZSBjYW4uXHJcbiAgICAqXHJcbiAgICAqIEBmdW5jdGlvbiBnZXRGZWF0dXJlTmFtZVxyXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gb2JqSWQgICAgICB0aGUgb2JqZWN0IGlkIG9mIHRoZSBhdHRyaWJ1dGVcclxuICAgICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnMgICAgdGhlIGRpY3Rpb25hcnkgb2YgYXR0cmlidXRlcyBmb3IgdGhlIGZlYXR1cmUuXHJcbiAgICAqIEByZXR1cm5zIHtTdHJpbmd9ICAgICAgICAgIHRoZSBuYW1lIG9mIHRoZSBmZWF0dXJlXHJcbiAgICAqL1xyXG4gICAgZ2V0RmVhdHVyZU5hbWUgKG9iaklkLCBhdHRyaWJzKSB7XHJcbiAgICAgICAgLy8gVE9ETyByZXZpc2l0IHRoZSBvYmpJZCBwYXJhbWV0ZXIuICBEbyB3ZSBhY3R1YWxseSBuZWVkIHRoaXMgZmFsbGJhY2sgYW55bW9yZT9cclxuICAgICAgICAvLyBOT1RFOiB3ZSB1c2VkIHRvIGhhdmUgZmFsbGJhY2sgbG9naWMgaGVyZSB0aGF0IHdvdWxkIHVzZSBsYXllciBzZXR0aW5nc1xyXG4gICAgICAgIC8vICAgICAgIGlmIHRoaXMubmFtZUZpZWxkIGhhZCBubyB2YWx1ZS4gTG9naWMgaGFzIGNoYW5nZWQgdG8gbm93IHB1c2hcclxuICAgICAgICAvLyAgICAgICBsYXllciBzZXR0aW5ncyB0byB0aGlzLm5hbWVGaWVsZCBkdXJpbmcgdGhlIGxvYWQgZXZlbnQgb2YgdGhlXHJcbiAgICAgICAgLy8gICAgICAgUmVjb3JkLlxyXG5cclxuICAgICAgICBpZiAodGhpcy5uYW1lRmllbGQgJiYgYXR0cmlicykge1xyXG4gICAgICAgICAgICAvLyBleHRyYWN0IG5hbWVcclxuICAgICAgICAgICAgcmV0dXJuIGF0dHJpYnNbdGhpcy5uYW1lRmllbGRdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIEZJWE1FIHdpcmUgaW4gXCJmZWF0dXJlXCIgdG8gdHJhbnNsYXRpb24gc2VydmljZVxyXG4gICAgICAgICAgICByZXR1cm4gJ0ZlYXR1cmUgJyArIG9iaklkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlcyBhdHRyaWJ1dGVzIGZyb20gYSBsYXllciBmb3IgYSBzcGVjaWZpZWQgZmVhdHVyZSBpbmRleFxyXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgICBwcm9taXNlIHJlc29sdmluZyB3aXRoIGZvcm1hdHRlZCBhdHRyaWJ1dGVzIHRvIGJlIGNvbnN1bWVkIGJ5IHRoZSBkYXRhZ3JpZCBhbmQgZXNyaSBmZWF0dXJlIGlkZW50aWZ5XHJcbiAgICAgKi9cclxuICAgIGdldEZvcm1hdHRlZEF0dHJpYnV0ZXMgKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9mb3JtYXR0ZWRBdHRyaWJ1dGVzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9mb3JtYXR0ZWRBdHRyaWJ1dGVzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVE9ETyBhZnRlciByZWZhY3RvciwgY29uc2lkZXIgY2hhbmdpbmcgdGhpcyB0byBhIHdhcm5pbmcgYW5kIGp1c3QgcmV0dXJuIHNvbWUgZHVtbXkgdmFsdWVcclxuICAgICAgICBpZiAodGhpcy5sYXllclR5cGUgPT09IHNoYXJlZC5jbGllbnRMYXllclR5cGUuRVNSSV9SQVNURVIpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdHRlbXB0aW5nIHRvIGdldCBhdHRyaWJ1dGVzIG9uIGEgcmFzdGVyIGxheWVyLicpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5fZm9ybWF0dGVkQXR0cmlidXRlcyA9IFByb21pc2UuYWxsKFt0aGlzLmdldEF0dHJpYnMoKSwgdGhpcy5nZXRMYXllckRhdGEoKV0pXHJcbiAgICAgICAgICAgIC50aGVuKChbYURhdGEsIGxEYXRhXSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIGNvbHVtbnMgYXJyYXkgY29uc3VtYWJsZSBieSBkYXRhYmxlc1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29sdW1ucyA9IGxEYXRhLmZpZWxkc1xyXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZmllbGQgPT5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFzc3VtaW5nIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBhdHRyaWJ1dGUgLSBlbXB0eSBhdHRyaWJ1dGUgYnVkbmxlIHByb21pc2VzIHNob3VsZCBiZSByZWplY3RlZCwgc28gaXQgbmV2ZXIgZXZlbiBnZXRzIHRoaXMgZmFyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpbHRlciBvdXQgZmllbGRzIHdoZXJlIHRoZXJlIGlzIG5vIGNvcnJlc3BvbmRpbmcgYXR0cmlidXRlIGRhdGFcclxuICAgICAgICAgICAgICAgICAgICAgICAgYURhdGEuZmVhdHVyZXNbMF0uYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShmaWVsZC5uYW1lKSlcclxuICAgICAgICAgICAgICAgICAgICAubWFwKGZpZWxkID0+ICh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGZpZWxkLm5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiBmaWVsZC5hbGlhcyB8fCBmaWVsZC5uYW1lXHJcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGRlcml2ZSB0aGUgaWNvbiBmb3IgdGhlIHJvd1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgcm93cyA9IGFEYXRhLmZlYXR1cmVzLm1hcChmZWF0dXJlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhdHQgPSBmZWF0dXJlLmF0dHJpYnV0ZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgYXR0LnJ2SW50ZXJhY3RpdmUgPSAnJztcclxuICAgICAgICAgICAgICAgICAgICBhdHQucnZTeW1ib2wgPSB0aGlzLl9wYXJlbnQuX2FwaVJlZi5zeW1ib2xvZ3kuZ2V0R3JhcGhpY0ljb24oYXR0LCBsRGF0YS5yZW5kZXJlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF0dDtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sdW1ucyxcclxuICAgICAgICAgICAgICAgICAgICByb3dzLFxyXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkczogbERhdGEuZmllbGRzLCAvLyBrZWVwIGZpZWxkcyBmb3IgcmVmZXJlbmNlIC4uLlxyXG4gICAgICAgICAgICAgICAgICAgIG9pZEZpZWxkOiBsRGF0YS5vaWRGaWVsZCwgLy8gLi4uIGtlZXAgYSByZWZlcmVuY2UgdG8gaWQgZmllbGQgLi4uXHJcbiAgICAgICAgICAgICAgICAgICAgb2lkSW5kZXg6IGFEYXRhLm9pZEluZGV4LCAvLyAuLi4gYW5kIGtlZXAgaWQgbWFwcGluZyBhcnJheVxyXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyOiBsRGF0YS5yZW5kZXJlclxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmNhdGNoKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9mb3JtYXR0ZWRBdHRyaWJ1dGVzOyAvLyBkZWxldGUgY2FjaGVkIHByb21pc2Ugd2hlbiB0aGUgZ2VvQXBpIGBnZXRBdHRyaWJzYCBjYWxsIGZhaWxzLCBzbyBpdCB3aWxsIGJlIHJlcXVlc3RlZCBhZ2FpbiBuZXh0IHRpbWUgYGdldEF0dHJpYnV0ZXNgIGlzIGNhbGxlZDtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXR0cmliIGxvYWRpbmcgZmFpbGVkJyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5fZm9ybWF0dGVkQXR0cmlidXRlcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrIHRvIHNlZSBpZiB0aGUgYXR0cmlidXRlIGluIHF1ZXN0aW9uIGlzIGFuIGVzcmlGaWVsZFR5cGVEYXRlIHR5cGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHJpYk5hbWUgICAgIHRoZSBhdHRyaWJ1dGUgbmFtZSB3ZSB3YW50IHRvIGNoZWNrIGlmIGl0J3MgYSBkYXRlIG9yIG5vdFxyXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgICAgIHJlc29sdmVzIHRvIHRydWUgb3IgZmFsc2UgYmFzZWQgb24gdGhlIGF0dHJpYk5hbWUgdHlwZSBiZWluZyBlc3JpRmllbGRUeXBlRGF0ZVxyXG4gICAgICovXHJcbiAgICBjaGVja0RhdGVUeXBlIChhdHRyaWJOYW1lKSB7XHJcbiAgICAgICAgLy8gVEVTVCBTVEFUVVMgbm9uZVxyXG4gICAgICAgIC8vIGdyYWIgYXR0cmlidXRlIGluZm8gKHdhaXRpbmcgZm9yIGl0IGl0IGZpbmlzaCBsb2FkaW5nKVxyXG4gICAgICAgIHJldHVybiB0aGlzLmdldExheWVyRGF0YSgpLnRoZW4obERhdGEgPT4ge1xyXG4gICAgICAgICAgICAvLyBpbnNwZWN0IGF0dHJpYnV0ZSBmaWVsZHNcclxuICAgICAgICAgICAgaWYgKGxEYXRhLmZpZWxkcykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYXR0cmliRmllbGQgPSBsRGF0YS5maWVsZHMuZmluZChmaWVsZCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpZWxkLm5hbWUgPT09IGF0dHJpYk5hbWU7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGlmIChhdHRyaWJGaWVsZCAmJiBhdHRyaWJGaWVsZC50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF0dHJpYkZpZWxkLnR5cGUgPT09ICdlc3JpRmllbGRUeXBlRGF0ZSc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBiZXN0IHVzZXItZnJpZW5kbHkgbmFtZSBvZiBhIGZpZWxkLiBVc2VzIGFsaWFzIGlmIGFsaWFzIGlzIGRlZmluZWQsIGVsc2UgdXNlcyB0aGUgc3lzdGVtIGF0dHJpYnV0ZSBuYW1lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyaWJOYW1lICAgICB0aGUgYXR0cmlidXRlIG5hbWUgd2Ugd2FudCBhIG5pY2UgbmFtZSBmb3JcclxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICAgICByZXNvbHZlcyB0byB0aGUgYmVzdCBhdmFpbGFibGUgdXNlciBmcmllbmRseSBhdHRyaWJ1dGUgbmFtZVxyXG4gICAgICovXHJcbiAgICBhbGlhc2VkRmllbGROYW1lIChhdHRyaWJOYW1lKSB7XHJcbiAgICAgICAgLy8gVEVTVCBTVEFUVVMgbm9uZVxyXG4gICAgICAgIC8vIGdyYWIgYXR0cmlidXRlIGluZm8gKHdhaXRpbmcgZm9yIGl0IGl0IGZpbmlzaCBsb2FkaW5nKVxyXG4gICAgICAgIHJldHVybiB0aGlzLmdldExheWVyRGF0YSgpLnRoZW4obERhdGEgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gQXR0cmliRkMuYWxpYXNlZEZpZWxkTmFtZURpcmVjdChhdHRyaWJOYW1lLCBsRGF0YS5maWVsZHMpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgYWxpYXNlZEZpZWxkTmFtZURpcmVjdCAoYXR0cmliTmFtZSwgZmllbGRzKSB7XHJcbiAgICAgICAgLy8gVEVTVCBTVEFUVVMgbm9uZVxyXG4gICAgICAgIGxldCBmTmFtZSA9IGF0dHJpYk5hbWU7XHJcblxyXG4gICAgICAgIC8vIHNlYXJjaCBmb3IgYWxpYXNlc1xyXG4gICAgICAgIGlmIChmaWVsZHMpIHtcclxuICAgICAgICAgICAgY29uc3QgYXR0cmliRmllbGQgPSBmaWVsZHMuZmluZChmaWVsZCA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmllbGQubmFtZSA9PT0gYXR0cmliTmFtZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChhdHRyaWJGaWVsZCAmJiBhdHRyaWJGaWVsZC5hbGlhcyAmJiBhdHRyaWJGaWVsZC5hbGlhcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBmTmFtZSA9IGF0dHJpYkZpZWxkLmFsaWFzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmTmFtZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnQgYW4gYXR0cmlidXRlIHNldCBzbyB0aGF0IGFueSBrZXlzIHVzaW5nIGFsaWFzZXMgYXJlIGNvbnZlcnRlZCB0byBwcm9wZXIgZmllbGRzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBhdHRyaWJzICAgICAgYXR0cmlidXRlIGtleS12YWx1ZSBtYXBwaW5nLCBwb3RlbnRpYWxseSB3aXRoIGFsaWFzZXMgYXMga2V5c1xyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IGZpZWxkcyAgICAgICBmaWVsZHMgZGVmaW5pdGlvbiBhcnJheSBmb3IgbGF5ZXJcclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICAgIGF0dHJpYnV0ZSBrZXktdmFsdWUgbWFwcGluZyB3aXRoIGZpZWxkcyBhcyBrZXlzXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyB1bkFsaWFzQXR0cmlicyAoYXR0cmlicywgZmllbGRzKSB7XHJcbiAgICAgICAgY29uc3QgbmV3QSA9IHt9O1xyXG4gICAgICAgIGZpZWxkcy5mb3JFYWNoKGZpZWxkID0+IHtcclxuICAgICAgICAgICAgLy8gYXR0ZW1wdCB0byBleHRyYWN0IG9uIG5hbWUuIGlmIG5vdCBmb3VuZCwgYXR0ZW1wdCB0byBleHRyYWN0IG9uIGFsaWFzXHJcbiAgICAgICAgICAgIC8vIGR1bXAgdmFsdWUgaW50byB0aGUgcmVzdWx0XHJcbiAgICAgICAgICAgIG5ld0FbZmllbGQubmFtZV0gPSBhdHRyaWJzLmhhc093blByb3BlcnR5KGZpZWxkLm5hbWUpID8gYXR0cmlic1tmaWVsZC5uYW1lXSA6IGF0dHJpYnNbZmllbGQuYWxpYXNdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBuZXdBO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBGZXRjaGVzIGZlYXR1cmUgaW5mb3JtYXRpb24sIGluY2x1ZGluZyBnZW9tZXRyeSwgZnJvbSBlc3JpIHNlcnZlcnMgZm9yIGZlYXR1cmUgbGF5ZXIuXHJcbiAgICAqIEBwYXJhbSB7SW50ZWdlcn0gb2JqZWN0SWQgZm9yIGZlYXR1cmUgdG8gYmUgcmV0cml2ZWQgZnJvbSB0aGUgc2VydmVyXHJcbiAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBwcm9taXNlIHJlc29sdmVzIHdpdGggYW4gZXNyaSBHcmFwaGljIChodHRwOi8vcmVzb3VyY2VzLmFyY2dpcy5jb20vZW4vaGVscC9hcmNnaXMtcmVzdC1hcGkvIy9GZWF0dXJlX01hcF9TZXJ2aWNlX0xheWVyLzAycjMwMDAwMDByOTAwMDAwMC8pXHJcbiAgICAqL1xyXG4gICAgZ2V0U2VydmVyRmVhdHVyZUluZm8gKG9iamVjdElkKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3F1aWNrQ2FjaGVbb2JqZWN0SWRdKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fcXVpY2tDYWNoZVtvYmplY3RJZF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoXHJcbiAgICAgICAgICAgIChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuX3BhcmVudDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRlZkRhdGEgPSBwYXJlbnQuX2VzcmlSZXF1ZXN0KHtcclxuICAgICAgICAgICAgICAgICAgICB1cmw6IGAke3BhcmVudC5yb290VXJsfS8ke3RoaXMuX2lkeH0vJHtvYmplY3RJZH1gLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZjogJ2pzb24nLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tQYXJhbU5hbWU6ICdjYWxsYmFjaycsXHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlQXM6ICdqc29uJ1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgZGVmRGF0YS50aGVuKFxyXG4gICAgICAgICAgICAgICAgICAgIHNlcnZlckZlYXR1cmUgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXJ2ZXIgcmVzdWx0IG9taXRzIHNwYXRpYWwgcmVmZXJlbmNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZlckZlYXR1cmUuZmVhdHVyZS5nZW9tZXRyeS5zcGF0aWFsUmVmZXJlbmNlID0gcGFyZW50Ll9sYXllci5zcGF0aWFsUmVmZXJlbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9xdWlja0NhY2hlW29iamVjdElkXSA9IHNlcnZlckZlYXR1cmU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoc2VydmVyRmVhdHVyZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgZXJyb3IgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmV0Y2hlcyBhIGdyYXBoaWMgZnJvbSB0aGUgZ2l2ZW4gbGF5ZXIuXHJcbiAgICAgKiBXaWxsIGF0dGVtcHQgbG9jYWwgY29weSwgd2lsbCBoaXQgdGhlIHNlcnZlciBpZiBub3QgYXZhaWxhYmxlLlxyXG4gICAgICpcclxuICAgICAqIEBmdW5jdGlvbiBmZXRjaEdyYXBoaWNcclxuICAgICAqIEBwYXJhbSAge0ludGVnZXJ9IG9iaklkICAgICAgICAgIElEIG9mIG9iamVjdCBiZWluZyBzZWFyY2hlZCBmb3JcclxuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IGlnbm9yZUxvY2FsICAgIGluZGljYXRlcyBpZiB3ZSBzaG91bGQgaWdub3JlIGFueSBsb2NhbCBncmFwaGljIGluIHRoZSBsYXllci4gY2FjaGVkIG9yIHNlcnZlciB2YWx1ZSB3aWxsIGJlIHVzZWQuIGRlZmF1bHRzIHRvIGZhbHNlLlxyXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IHJlc29sdmVzIHdpdGggYSBidW5kbGUgb2YgaW5mb3JtYXRpb24uIC5ncmFwaGljIGlzIHRoZSBncmFwaGljOyAuc291cmNlIGlzIHdoZXJlIGl0IGNhbWUgZnJvbSAtICdsYXllcicgb3IgJ3NlcnZlcic7IGFsc28gLmxheWVyRkMgZm9yIGNvbnZlbmllbmNlXHJcbiAgICAgKi9cclxuICAgIGZldGNoR3JhcGhpYyAob2JqSWQsIGlnbm9yZUxvY2FsID0gZmFsc2UpIHtcclxuXHJcbiAgICAgICAgY29uc3QgbGF5ZXJPYmogPSB0aGlzLl9wYXJlbnQuX2xheWVyO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcclxuICAgICAgICAgICAgZ3JhcGhpYzogbnVsbCxcclxuICAgICAgICAgICAgc291cmNlOiBudWxsLFxyXG4gICAgICAgICAgICBsYXllckZDOiB0aGlzXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gaWYgZmVhdHVyZSBsYXllciwgY2hlY2sgaWYgZ3JhcGhpYyBpcyBhbHJlYWR5IGxvYWRlZCBvbiB0aGUgY2xpZW50LiByZXR1cm4gaXQgaWYgZm91bmQuXHJcbiAgICAgICAgaWYgKCFpZ25vcmVMb2NhbCAmJiBsYXllck9iai5ncmFwaGljcykge1xyXG4gICAgICAgICAgICBjb25zdCBteUcgPSBsYXllck9iai5ncmFwaGljcy5maW5kKGcgPT5cclxuICAgICAgICAgICAgICAgIGcuYXR0cmlidXRlc1tsYXllck9iai5vYmplY3RJZEZpZWxkXSA9PT0gb2JqSWQpO1xyXG4gICAgICAgICAgICBpZiAobXlHKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuZ3JhcGhpYyA9IG15RztcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5zb3VyY2UgPSAnbGF5ZXInO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB3ZXJlIG5vdCBhYmxlIHRvIGdldCBhIGxvY2FsIGNvcHkgb2YgdGhlIGdyYXBoaWMuIHRvIHRoZSBzZXJ2ZXIhXHJcbiAgICAgICAgLy8gVE9ETyBhZGQgc29tZSBlcnJvciBoYW5kbGluZy4gQ2FzZXM6IGZhaWxlZCBzZXJ2ZXIgY2FsbC4gc2VydmVyIGNhbGwgaXMgbm90IGEgZmVhdHVyZVxyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFNlcnZlckZlYXR1cmVJbmZvKG9iaklkKVxyXG4gICAgICAgICAgICAudGhlbihmZWF0dXJlSW5mbyA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuZ3JhcGhpYyA9IGZlYXR1cmVJbmZvLmZlYXR1cmU7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuc291cmNlID0gJ3NlcnZlcic7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gKCkgPT4gKHtcclxuICAgIEF0dHJpYkZDXHJcbn0pO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbGF5ZXIvbGF5ZXJSZWMvYXR0cmliRkMuanMiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar shared = __webpack_require__(2)();\nvar placeholderFC = __webpack_require__(5)();\n\n/**\r\n * @class BasicFC\r\n */\n\nvar BasicFC = function (_placeholderFC$Placeh) {\n    _inherits(BasicFC, _placeholderFC$Placeh);\n\n    _createClass(BasicFC, [{\n        key: 'queryable',\n\n        // base class for feature class object. deals with stuff specific to a feature class (or raster equivalent)\n\n        get: function get() {\n            return this._queryable;\n        },\n        set: function set(value) {\n            this._queryable = value;\n        }\n\n        // non-attributes have no geometry.\n        // TODO decide on proper defaulting or handling of non-geometry layers.\n\n    }, {\n        key: 'geomType',\n        get: function get() {\n            return Promise.resolve('none');\n        }\n\n        /**\r\n         * @param {Object} parent        the Record object that this Feature Class belongs to\r\n         * @param {String} idx           the service index of this Feature Class. an integer in string format. use '0' for non-indexed sources.\r\n         * @param {Object} config        the config object for this sublayer\r\n         */\n\n    }]);\n\n    function BasicFC(parent, idx, config) {\n        _classCallCheck(this, BasicFC);\n\n        var _this = _possibleConstructorReturn(this, (BasicFC.__proto__ || Object.getPrototypeOf(BasicFC)).call(this, parent, config.name || ''));\n\n        _this._idx = idx;\n        _this.queryable = config.state.query;\n        _this.extent = config.extent; // if missing, will fill more values after layer loads\n\n        // TODO do we need to store a copy of the config? for the memories?\n\n        return _this;\n    }\n\n    // returns an object with minScale and maxScale values for the feature class\n\n\n    _createClass(BasicFC, [{\n        key: 'getScaleSet',\n        value: function getScaleSet() {\n            // basic case - we get it from the esri layer\n            // TODO need to test for missing layer??\n            var l = this._parent._layer;\n            return {\n                minScale: l.minScale,\n                maxScale: l.maxScale\n            };\n        }\n    }, {\n        key: 'isOffScale',\n        value: function isOffScale(mapScale) {\n            var scaleSet = this.getScaleSet();\n\n            // GIS for dummies.\n            // scale increases as you zoom out, decreases as you zoom in\n            // minScale means if you zoom out beyond this number, hide the layer\n            // maxScale means if you zoom in past this number, hide the layer\n            // 0 value for min or max scale means there is no hiding in effect\n            var result = {\n                offScale: false,\n                zoomIn: false\n            };\n\n            // check if out of scale and set zoom direction to scaleSet\n            if (mapScale < scaleSet.maxScale && scaleSet.maxScale !== 0) {\n                result.offScale = true;\n                result.zoomIn = false;\n            } else if (mapScale > scaleSet.minScale && scaleSet.minScale !== 0) {\n                result.offScale = true;\n                result.zoomIn = true;\n            }\n\n            return result;\n        }\n\n        // TODO docs\n\n    }, {\n        key: 'getVisibility',\n        value: function getVisibility() {\n            return this._parent._layer.visible;\n        }\n\n        // TODO docs\n\n    }, {\n        key: 'setVisibility',\n        value: function setVisibility(value) {\n            // basic case - set layer visibility\n            this._parent._layer.setVisibility(value);\n        }\n\n        // this will actively download / refresh the internal symbology\n        // mergeAllLayers indicates we should collate entire parent legend into one block\n        //                e.g. for basemap tile. this._idx would have value 0, but we want all indexes\n\n    }, {\n        key: 'loadSymbology',\n        value: function loadSymbology() {\n            var _this2 = this;\n\n            var mergeAllLayers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n            // get symbology from service legend.\n            // this is used for non-feature based sources (tiles, image, raster).\n            // wms will override with own special logic.\n            var url = this._parent._layer.url;\n            if (url) {\n                // fetch legend from server, convert to local format, process local format\n                var legendIndex = mergeAllLayers ? undefined : this._idx;\n                return this._parent._apiRef.symbology.mapServerToLocalLegend(url, legendIndex).then(function (legendData) {\n                    _this2.symbology = shared.makeSymbologyArray(legendData.layers[0].legend);\n                });\n            } else {\n                // this shouldn't happen. non-url layers should be files, which are features,\n                // which will have a basic renderer and will use FeatureFC override.\n                throw new Error('encountered layer with no renderer and no url');\n            }\n        }\n    }, {\n        key: 'zoomToBoundary',\n        value: function zoomToBoundary(map) {\n            return this._parent.zoomToExtent(map, this.extent);\n        }\n    }]);\n\n    return BasicFC;\n}(placeholderFC.PlaceholderFC);\n\nmodule.exports = function () {\n    return {\n        BasicFC: BasicFC\n    };\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXIvbGF5ZXJSZWMvYmFzaWNGQy5qcz85OWMyIl0sIm5hbWVzIjpbInNoYXJlZCIsInJlcXVpcmUiLCJwbGFjZWhvbGRlckZDIiwiQmFzaWNGQyIsIl9xdWVyeWFibGUiLCJ2YWx1ZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicGFyZW50IiwiaWR4IiwiY29uZmlnIiwibmFtZSIsIl9pZHgiLCJxdWVyeWFibGUiLCJzdGF0ZSIsInF1ZXJ5IiwiZXh0ZW50IiwibCIsIl9wYXJlbnQiLCJfbGF5ZXIiLCJtaW5TY2FsZSIsIm1heFNjYWxlIiwibWFwU2NhbGUiLCJzY2FsZVNldCIsImdldFNjYWxlU2V0IiwicmVzdWx0Iiwib2ZmU2NhbGUiLCJ6b29tSW4iLCJ2aXNpYmxlIiwic2V0VmlzaWJpbGl0eSIsIm1lcmdlQWxsTGF5ZXJzIiwidXJsIiwibGVnZW5kSW5kZXgiLCJ1bmRlZmluZWQiLCJfYXBpUmVmIiwic3ltYm9sb2d5IiwibWFwU2VydmVyVG9Mb2NhbExlZ2VuZCIsInRoZW4iLCJtYWtlU3ltYm9sb2d5QXJyYXkiLCJsZWdlbmREYXRhIiwibGF5ZXJzIiwibGVnZW5kIiwiRXJyb3IiLCJtYXAiLCJ6b29tVG9FeHRlbnQiLCJQbGFjZWhvbGRlckZDIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7QUFFQSxJQUFNQSxTQUFTLG1CQUFBQyxDQUFRLENBQVIsR0FBZjtBQUNBLElBQU1DLGdCQUFnQixtQkFBQUQsQ0FBUSxDQUFSLEdBQXRCOztBQUVBOzs7O0lBR01FLE87Ozs7OztBQUNGOzs0QkFFaUI7QUFBRSxtQkFBTyxLQUFLQyxVQUFaO0FBQXlCLFM7MEJBQzdCQyxLLEVBQU87QUFBRSxpQkFBS0QsVUFBTCxHQUFrQkMsS0FBbEI7QUFBMEI7O0FBRWxEO0FBQ0E7Ozs7NEJBQ2dCO0FBQUUsbUJBQU9DLFFBQVFDLE9BQVIsQ0FBZ0IsTUFBaEIsQ0FBUDtBQUFpQzs7QUFFbkQ7Ozs7Ozs7O0FBS0EscUJBQWFDLE1BQWIsRUFBcUJDLEdBQXJCLEVBQTBCQyxNQUExQixFQUFrQztBQUFBOztBQUFBLHNIQUN4QkYsTUFEd0IsRUFDaEJFLE9BQU9DLElBQVAsSUFBZSxFQURDOztBQUU5QixjQUFLQyxJQUFMLEdBQVlILEdBQVo7QUFDQSxjQUFLSSxTQUFMLEdBQWlCSCxPQUFPSSxLQUFQLENBQWFDLEtBQTlCO0FBQ0EsY0FBS0MsTUFBTCxHQUFjTixPQUFPTSxNQUFyQixDQUo4QixDQUlBOztBQUU5Qjs7QUFOOEI7QUFRakM7O0FBRUQ7Ozs7O3NDQUNlO0FBQ1g7QUFDQTtBQUNBLGdCQUFNQyxJQUFJLEtBQUtDLE9BQUwsQ0FBYUMsTUFBdkI7QUFDQSxtQkFBTztBQUNIQywwQkFBVUgsRUFBRUcsUUFEVDtBQUVIQywwQkFBVUosRUFBRUk7QUFGVCxhQUFQO0FBSUg7OzttQ0FFV0MsUSxFQUFVO0FBQ2xCLGdCQUFNQyxXQUFXLEtBQUtDLFdBQUwsRUFBakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFNQyxTQUFTO0FBQ1hDLDBCQUFVLEtBREM7QUFFWEMsd0JBQVE7QUFGRyxhQUFmOztBQUtBO0FBQ0EsZ0JBQUlMLFdBQVdDLFNBQVNGLFFBQXBCLElBQWdDRSxTQUFTRixRQUFULEtBQXNCLENBQTFELEVBQTZEO0FBQ3pESSx1QkFBT0MsUUFBUCxHQUFrQixJQUFsQjtBQUNBRCx1QkFBT0UsTUFBUCxHQUFnQixLQUFoQjtBQUNILGFBSEQsTUFHTyxJQUFJTCxXQUFXQyxTQUFTSCxRQUFwQixJQUFnQ0csU0FBU0gsUUFBVCxLQUFzQixDQUExRCxFQUE2RDtBQUNoRUssdUJBQU9DLFFBQVAsR0FBa0IsSUFBbEI7QUFDQUQsdUJBQU9FLE1BQVAsR0FBZ0IsSUFBaEI7QUFDSDs7QUFFRCxtQkFBT0YsTUFBUDtBQUNIOztBQUVEOzs7O3dDQUNpQjtBQUNiLG1CQUFPLEtBQUtQLE9BQUwsQ0FBYUMsTUFBYixDQUFvQlMsT0FBM0I7QUFDSDs7QUFFRDs7OztzQ0FDZXZCLEssRUFBTztBQUNsQjtBQUNBLGlCQUFLYSxPQUFMLENBQWFDLE1BQWIsQ0FBb0JVLGFBQXBCLENBQWtDeEIsS0FBbEM7QUFDSDs7QUFFRDtBQUNBO0FBQ0E7Ozs7d0NBQ3VDO0FBQUE7O0FBQUEsZ0JBQXhCeUIsY0FBd0IsdUVBQVAsS0FBTzs7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsZ0JBQU1DLE1BQU0sS0FBS2IsT0FBTCxDQUFhQyxNQUFiLENBQW9CWSxHQUFoQztBQUNBLGdCQUFJQSxHQUFKLEVBQVM7QUFDTDtBQUNBLG9CQUFNQyxjQUFjRixpQkFBaUJHLFNBQWpCLEdBQTZCLEtBQUtyQixJQUF0RDtBQUNBLHVCQUFPLEtBQUtNLE9BQUwsQ0FBYWdCLE9BQWIsQ0FBcUJDLFNBQXJCLENBQStCQyxzQkFBL0IsQ0FBc0RMLEdBQXRELEVBQTJEQyxXQUEzRCxFQUNGSyxJQURFLENBQ0csc0JBQWM7QUFDaEIsMkJBQUtGLFNBQUwsR0FBaUJuQyxPQUFPc0Msa0JBQVAsQ0FBMEJDLFdBQVdDLE1BQVgsQ0FBa0IsQ0FBbEIsRUFBcUJDLE1BQS9DLENBQWpCO0FBQ0gsaUJBSEUsQ0FBUDtBQUlILGFBUEQsTUFPTztBQUNIO0FBQ0E7QUFDQSxzQkFBTSxJQUFJQyxLQUFKLENBQVUsK0NBQVYsQ0FBTjtBQUNIO0FBQ0o7Ozt1Q0FFZUMsRyxFQUFLO0FBQ2pCLG1CQUFPLEtBQUt6QixPQUFMLENBQWEwQixZQUFiLENBQTBCRCxHQUExQixFQUErQixLQUFLM0IsTUFBcEMsQ0FBUDtBQUNIOzs7O0VBaEdpQmQsY0FBYzJDLGE7O0FBb0dwQ0MsT0FBT0MsT0FBUCxHQUFpQjtBQUFBLFdBQU87QUFDcEI1QztBQURvQixLQUFQO0FBQUEsQ0FBakIiLCJmaWxlIjoiMTkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG5jb25zdCBzaGFyZWQgPSByZXF1aXJlKCcuL3NoYXJlZC5qcycpKCk7XHJcbmNvbnN0IHBsYWNlaG9sZGVyRkMgPSByZXF1aXJlKCcuL3BsYWNlaG9sZGVyRkMuanMnKSgpO1xyXG5cclxuLyoqXHJcbiAqIEBjbGFzcyBCYXNpY0ZDXHJcbiAqL1xyXG5jbGFzcyBCYXNpY0ZDIGV4dGVuZHMgcGxhY2Vob2xkZXJGQy5QbGFjZWhvbGRlckZDIHtcclxuICAgIC8vIGJhc2UgY2xhc3MgZm9yIGZlYXR1cmUgY2xhc3Mgb2JqZWN0LiBkZWFscyB3aXRoIHN0dWZmIHNwZWNpZmljIHRvIGEgZmVhdHVyZSBjbGFzcyAob3IgcmFzdGVyIGVxdWl2YWxlbnQpXHJcblxyXG4gICAgZ2V0IHF1ZXJ5YWJsZSAoKSB7IHJldHVybiB0aGlzLl9xdWVyeWFibGU7IH1cclxuICAgIHNldCBxdWVyeWFibGUgKHZhbHVlKSB7IHRoaXMuX3F1ZXJ5YWJsZSA9IHZhbHVlOyB9XHJcblxyXG4gICAgLy8gbm9uLWF0dHJpYnV0ZXMgaGF2ZSBubyBnZW9tZXRyeS5cclxuICAgIC8vIFRPRE8gZGVjaWRlIG9uIHByb3BlciBkZWZhdWx0aW5nIG9yIGhhbmRsaW5nIG9mIG5vbi1nZW9tZXRyeSBsYXllcnMuXHJcbiAgICBnZXQgZ2VvbVR5cGUgKCkgeyByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCdub25lJyk7IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJlbnQgICAgICAgIHRoZSBSZWNvcmQgb2JqZWN0IHRoYXQgdGhpcyBGZWF0dXJlIENsYXNzIGJlbG9uZ3MgdG9cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZHggICAgICAgICAgIHRoZSBzZXJ2aWNlIGluZGV4IG9mIHRoaXMgRmVhdHVyZSBDbGFzcy4gYW4gaW50ZWdlciBpbiBzdHJpbmcgZm9ybWF0LiB1c2UgJzAnIGZvciBub24taW5kZXhlZCBzb3VyY2VzLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyAgICAgICAgdGhlIGNvbmZpZyBvYmplY3QgZm9yIHRoaXMgc3VibGF5ZXJcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IgKHBhcmVudCwgaWR4LCBjb25maWcpIHtcclxuICAgICAgICBzdXBlcihwYXJlbnQsIGNvbmZpZy5uYW1lIHx8ICcnKTtcclxuICAgICAgICB0aGlzLl9pZHggPSBpZHg7XHJcbiAgICAgICAgdGhpcy5xdWVyeWFibGUgPSBjb25maWcuc3RhdGUucXVlcnk7XHJcbiAgICAgICAgdGhpcy5leHRlbnQgPSBjb25maWcuZXh0ZW50OyAgLy8gaWYgbWlzc2luZywgd2lsbCBmaWxsIG1vcmUgdmFsdWVzIGFmdGVyIGxheWVyIGxvYWRzXHJcblxyXG4gICAgICAgIC8vIFRPRE8gZG8gd2UgbmVlZCB0byBzdG9yZSBhIGNvcHkgb2YgdGhlIGNvbmZpZz8gZm9yIHRoZSBtZW1vcmllcz9cclxuXHJcbiAgICB9XHJcblxyXG4gICAgLy8gcmV0dXJucyBhbiBvYmplY3Qgd2l0aCBtaW5TY2FsZSBhbmQgbWF4U2NhbGUgdmFsdWVzIGZvciB0aGUgZmVhdHVyZSBjbGFzc1xyXG4gICAgZ2V0U2NhbGVTZXQgKCkge1xyXG4gICAgICAgIC8vIGJhc2ljIGNhc2UgLSB3ZSBnZXQgaXQgZnJvbSB0aGUgZXNyaSBsYXllclxyXG4gICAgICAgIC8vIFRPRE8gbmVlZCB0byB0ZXN0IGZvciBtaXNzaW5nIGxheWVyPz9cclxuICAgICAgICBjb25zdCBsID0gdGhpcy5fcGFyZW50Ll9sYXllcjtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBtaW5TY2FsZTogbC5taW5TY2FsZSxcclxuICAgICAgICAgICAgbWF4U2NhbGU6IGwubWF4U2NhbGVcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGlzT2ZmU2NhbGUgKG1hcFNjYWxlKSB7XHJcbiAgICAgICAgY29uc3Qgc2NhbGVTZXQgPSB0aGlzLmdldFNjYWxlU2V0KCk7XHJcblxyXG4gICAgICAgIC8vIEdJUyBmb3IgZHVtbWllcy5cclxuICAgICAgICAvLyBzY2FsZSBpbmNyZWFzZXMgYXMgeW91IHpvb20gb3V0LCBkZWNyZWFzZXMgYXMgeW91IHpvb20gaW5cclxuICAgICAgICAvLyBtaW5TY2FsZSBtZWFucyBpZiB5b3Ugem9vbSBvdXQgYmV5b25kIHRoaXMgbnVtYmVyLCBoaWRlIHRoZSBsYXllclxyXG4gICAgICAgIC8vIG1heFNjYWxlIG1lYW5zIGlmIHlvdSB6b29tIGluIHBhc3QgdGhpcyBudW1iZXIsIGhpZGUgdGhlIGxheWVyXHJcbiAgICAgICAgLy8gMCB2YWx1ZSBmb3IgbWluIG9yIG1heCBzY2FsZSBtZWFucyB0aGVyZSBpcyBubyBoaWRpbmcgaW4gZWZmZWN0XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xyXG4gICAgICAgICAgICBvZmZTY2FsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIHpvb21JbjogZmFsc2VcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBjaGVjayBpZiBvdXQgb2Ygc2NhbGUgYW5kIHNldCB6b29tIGRpcmVjdGlvbiB0byBzY2FsZVNldFxyXG4gICAgICAgIGlmIChtYXBTY2FsZSA8IHNjYWxlU2V0Lm1heFNjYWxlICYmIHNjYWxlU2V0Lm1heFNjYWxlICE9PSAwKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5vZmZTY2FsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHJlc3VsdC56b29tSW4gPSBmYWxzZTtcclxuICAgICAgICB9IGVsc2UgaWYgKG1hcFNjYWxlID4gc2NhbGVTZXQubWluU2NhbGUgJiYgc2NhbGVTZXQubWluU2NhbGUgIT09IDApIHtcclxuICAgICAgICAgICAgcmVzdWx0Lm9mZlNjYWxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgcmVzdWx0Lnpvb21JbiA9IHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRPRE8gZG9jc1xyXG4gICAgZ2V0VmlzaWJpbGl0eSAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudC5fbGF5ZXIudmlzaWJsZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUT0RPIGRvY3NcclxuICAgIHNldFZpc2liaWxpdHkgKHZhbHVlKSB7XHJcbiAgICAgICAgLy8gYmFzaWMgY2FzZSAtIHNldCBsYXllciB2aXNpYmlsaXR5XHJcbiAgICAgICAgdGhpcy5fcGFyZW50Ll9sYXllci5zZXRWaXNpYmlsaXR5KHZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyB0aGlzIHdpbGwgYWN0aXZlbHkgZG93bmxvYWQgLyByZWZyZXNoIHRoZSBpbnRlcm5hbCBzeW1ib2xvZ3lcclxuICAgIC8vIG1lcmdlQWxsTGF5ZXJzIGluZGljYXRlcyB3ZSBzaG91bGQgY29sbGF0ZSBlbnRpcmUgcGFyZW50IGxlZ2VuZCBpbnRvIG9uZSBibG9ja1xyXG4gICAgLy8gICAgICAgICAgICAgICAgZS5nLiBmb3IgYmFzZW1hcCB0aWxlLiB0aGlzLl9pZHggd291bGQgaGF2ZSB2YWx1ZSAwLCBidXQgd2Ugd2FudCBhbGwgaW5kZXhlc1xyXG4gICAgbG9hZFN5bWJvbG9neSAobWVyZ2VBbGxMYXllcnMgPSBmYWxzZSkge1xyXG4gICAgICAgIC8vIGdldCBzeW1ib2xvZ3kgZnJvbSBzZXJ2aWNlIGxlZ2VuZC5cclxuICAgICAgICAvLyB0aGlzIGlzIHVzZWQgZm9yIG5vbi1mZWF0dXJlIGJhc2VkIHNvdXJjZXMgKHRpbGVzLCBpbWFnZSwgcmFzdGVyKS5cclxuICAgICAgICAvLyB3bXMgd2lsbCBvdmVycmlkZSB3aXRoIG93biBzcGVjaWFsIGxvZ2ljLlxyXG4gICAgICAgIGNvbnN0IHVybCA9IHRoaXMuX3BhcmVudC5fbGF5ZXIudXJsO1xyXG4gICAgICAgIGlmICh1cmwpIHtcclxuICAgICAgICAgICAgLy8gZmV0Y2ggbGVnZW5kIGZyb20gc2VydmVyLCBjb252ZXJ0IHRvIGxvY2FsIGZvcm1hdCwgcHJvY2VzcyBsb2NhbCBmb3JtYXRcclxuICAgICAgICAgICAgY29uc3QgbGVnZW5kSW5kZXggPSBtZXJnZUFsbExheWVycyA/IHVuZGVmaW5lZCA6IHRoaXMuX2lkeDtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudC5fYXBpUmVmLnN5bWJvbG9neS5tYXBTZXJ2ZXJUb0xvY2FsTGVnZW5kKHVybCwgbGVnZW5kSW5kZXgpXHJcbiAgICAgICAgICAgICAgICAudGhlbihsZWdlbmREYXRhID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN5bWJvbG9neSA9IHNoYXJlZC5tYWtlU3ltYm9sb2d5QXJyYXkobGVnZW5kRGF0YS5sYXllcnNbMF0ubGVnZW5kKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHRoaXMgc2hvdWxkbid0IGhhcHBlbi4gbm9uLXVybCBsYXllcnMgc2hvdWxkIGJlIGZpbGVzLCB3aGljaCBhcmUgZmVhdHVyZXMsXHJcbiAgICAgICAgICAgIC8vIHdoaWNoIHdpbGwgaGF2ZSBhIGJhc2ljIHJlbmRlcmVyIGFuZCB3aWxsIHVzZSBGZWF0dXJlRkMgb3ZlcnJpZGUuXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZW5jb3VudGVyZWQgbGF5ZXIgd2l0aCBubyByZW5kZXJlciBhbmQgbm8gdXJsJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHpvb21Ub0JvdW5kYXJ5IChtYXApIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50Lnpvb21Ub0V4dGVudChtYXAsIHRoaXMuZXh0ZW50KTtcclxuICAgIH1cclxuXHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gKCkgPT4gKHtcclxuICAgIEJhc2ljRkNcclxufSk7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9sYXllci9sYXllclJlYy9iYXNpY0ZDLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar layerInterface = __webpack_require__(24)();\nvar shared = __webpack_require__(2)();\nvar root = __webpack_require__(39)();\n\n/**\r\n * @class LayerRecord\r\n */\n\nvar LayerRecord = function (_root$Root) {\n    _inherits(LayerRecord, _root$Root);\n\n    _createClass(LayerRecord, [{\n        key: 'bindEvents',\n\n\n        /**\r\n         * Attach event handlers to layer events\r\n         */\n        value: function bindEvents(layer) {\n            var _this2 = this;\n\n            // TODO optional refactor.  Rather than making the events object in the parameter,\n            //      do it as a variable, and only add mouse-over, mouse-out events if we are\n            //      in an app configuration that will use it. May save a bit of processing\n            //      by not having unused events being handled and ignored.\n            //      Second optional thing. Call a separate wrapEvents in FeatuerRecord class\n            // TODO apply johann update here\n            this._apiRef.events.wrapEvents(layer, {\n                // wrapping the function calls to keep `this` bound correctly\n                load: function load() {\n                    return _this2.onLoad();\n                },\n                error: function error(e) {\n                    return _this2.onError(e);\n                },\n                'update-start': function updateStart() {\n                    return _this2.onUpdateStart();\n                },\n                'update-end': function updateEnd() {\n                    return _this2.onUpdateEnd();\n                },\n                'mouse-over': function mouseOver(e) {\n                    return _this2.onMouseOver(e);\n                },\n                'mouse-out': function mouseOut(e) {\n                    return _this2.onMouseOut(e);\n                }\n            });\n        }\n\n        /**\r\n         * Perform layer initialization tasks\r\n         */\n\n    }, {\n        key: 'constructLayer',\n        value: function constructLayer() {\n            this._layer = this.layerClass(this.config.url, this.makeLayerConfig());\n            this.bindEvents(this._layer);\n            return this._layer;\n        }\n\n        /**\r\n         * Handle a change in layer state\r\n         */\n\n    }, {\n        key: '_stateChange',\n        value: function _stateChange(newState) {\n            this._state = newState;\n            console.log('State change for ' + this.layerId + ' to ' + newState);\n\n            // if we don't copy the array we could be looping on an array\n            // that is being modified as it is being read\n            this._fireEvent(this._stateListeners, this._state);\n        }\n\n        /**\r\n         * Wire up state change listener\r\n         */\n\n    }, {\n        key: 'addStateListener',\n        value: function addStateListener(listenerCallback) {\n            this._stateListeners.push(listenerCallback);\n            return listenerCallback;\n        }\n\n        /**\r\n         * Remove a state change listener\r\n         */\n\n    }, {\n        key: 'removeStateListener',\n        value: function removeStateListener(listenerCallback) {\n            var idx = this._stateListeners.indexOf(listenerCallback);\n            if (idx < 0) {\n                throw new Error('Attempting to remove a listener which is not registered.');\n            }\n            this._stateListeners.splice(idx, 1);\n        }\n\n        /**\r\n         * Wire up mouse hover listener\r\n         */\n\n    }, {\n        key: 'addHoverListener',\n        value: function addHoverListener(listenerCallback) {\n            this._hoverListeners.push(listenerCallback);\n            return listenerCallback;\n        }\n\n        /**\r\n         * Remove a mouse hover listener\r\n         */\n\n    }, {\n        key: 'removeHoverListener',\n        value: function removeHoverListener(listenerCallback) {\n            var idx = this._hoverListeners.indexOf(listenerCallback);\n            if (idx < 0) {\n                throw new Error('Attempting to remove a listener which is not registered.');\n            }\n            this._hoverListeners.splice(idx, 1);\n        }\n\n        /**\r\n        * Triggers when the layer loads.\r\n        * Returns an array of promises that need to resolve for layer to be loaded.\r\n        *\r\n        * @function onLoad\r\n        */\n\n    }, {\n        key: 'onLoad',\n        value: function onLoad() {\n            // only super-general stuff in here, that all layers should run.\n            console.info('Layer loaded: ' + this._layer.id);\n\n            if (!this.name) {\n                // no name from config. attempt layer name\n                this.name = this._layer.name;\n            }\n\n            if (!this.extent) {\n                // no extent from config. attempt layer extent\n                this.extent = this._layer.fullExtent;\n            }\n\n            var lookupPromise = Promise.resolve();\n            if (this._epsgLookup) {\n                var check = this._apiRef.proj.checkProj(this.spatialReference, this._epsgLookup);\n                if (check.lookupPromise) {\n                    lookupPromise = check.lookupPromise;\n                }\n\n                // TODO if we don't find a projection, the app will show the layer loading forever.\n                //      might need to handle the fail case and show something to the user.\n            }\n            return [lookupPromise];\n        }\n\n        /**\r\n         * Handles when the layer has an error\r\n         */\n\n    }, {\n        key: 'onError',\n        value: function onError(e) {\n            console.warn('Layer error: ' + e);\n            console.warn(e);\n            this._stateChange(shared.states.ERROR);\n        }\n\n        /**\r\n         * Handles when the layer starts to update\r\n         */\n\n    }, {\n        key: 'onUpdateStart',\n        value: function onUpdateStart() {\n            this._stateChange(shared.states.REFRESH);\n        }\n\n        /**\r\n         * Handles when the layer finishes updating\r\n         */\n\n    }, {\n        key: 'onUpdateEnd',\n        value: function onUpdateEnd() {\n            this._stateChange(shared.states.LOADED);\n        }\n\n        /**\r\n         * Handles when the mouse enters a layer\r\n         */\n\n    }, {\n        key: 'onMouseOver',\n        value: function onMouseOver() {}\n        // do nothing in baseclass\n\n\n        /**\r\n         * Handles when the mouse leaves a layer\r\n         */\n\n    }, {\n        key: 'onMouseOut',\n        value: function onMouseOut() {}\n        // do nothing in baseclass\n\n\n        /**\r\n         * Creates an options object for the physical layer\r\n         */\n\n    }, {\n        key: 'makeLayerConfig',\n        value: function makeLayerConfig() {\n            return {\n                id: this.config.id,\n                opacity: this.config.state.opacity,\n                visible: this.config.state.visibility\n            };\n        }\n\n        /**\r\n         * Figure out visibility scale.  Will use layer minScale/maxScale\r\n         * and map levels of detail to determine scale boundaries.\r\n         *\r\n         * @param {Array} lods            array of valid levels of detail for the map\r\n         * @param {Object} scaleSet       contains .minScale and .maxScale for valid viewing scales\r\n         * @param {Boolean} zoomIn        the zoom to scale direction; true need to zoom in; false need to zoom out\r\n         * @param {Boolean} zoomGraphic   an optional value when zoomToScale is use to zoom to a graphic element;\r\n         *                                    true used to zoom to a graphic element; false not used to zoom to a graphic element\r\n         * @returns {Object} a level of detail (lod) object for the appropriate scale to zoom to\r\n         */\n\n    }, {\n        key: 'findZoomScale',\n        value: function findZoomScale(lods, scaleSet, zoomIn) {\n            var zoomGraphic = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n            // TODO rename function to getZoomScale?\n            // TODO take a second look at parameters zoomIn and zoomGraphic. how are they derived (in the caller code)?\n            //      seems weird to me to do it this way\n            // TODO naming of \"zoomIn\" is very misleading and confusing. in practice, we are often\n            //      setting the value to false when we are zooming down close to the ground.\n            //      Need full analysis of usage, possibly rename parameter or update param docs.\n            // TODO update function parameters once things are working\n\n            // if the function is used to zoom to a graphic element and the layer is out of scale we always want\n            // the layer to zoom to the maximum scale allowed for the layer. In this case, zoomIn must be\n            // always false\n\n            zoomIn = zoomGraphic ? false : zoomIn;\n\n            // TODO double-check where lods are coming from in old code\n            // change search order of lods depending if we are zooming in or out\n            var modLods = zoomIn ? lods : [].concat(_toConsumableArray(lods)).reverse();\n\n            return modLods.find(function (currentLod) {\n                return zoomIn ? currentLod.scale < scaleSet.minScale : currentLod.scale > scaleSet.maxScale;\n            });\n        }\n\n        /**\r\n        * Set map scale depending on zooming in or zooming out of layer visibility scale\r\n        *\r\n        * @param {Object} map layer to zoom to scale to for feature layers; parent layer for dynamic layers\r\n        * @param {Object} lod scale object the map will be set to\r\n        * @param {Boolean} zoomIn the zoom to scale direction; true need to zoom in; false need to zoom out\r\n        * @returns {Promise} resolves after map is done changing its extent\r\n        */\n\n    }, {\n        key: 'setMapScale',\n        value: function setMapScale(map, lod, zoomIn) {\n            // TODO possible this would live in the map manager in a bigger refactor.\n            // NOTE because we utilize the layer object's full extent (and not child feature class extents),\n            //      this function stays in this class.\n\n            // if zoom in is needed; must find center of layer's full extent and perform center&zoom\n            if (zoomIn) {\n                // need to reproject in case full extent in a different sr than basemap\n                var gextent = this._apiRef.proj.localProjectExtent(this._layer.fullExtent, map.spatialReference);\n\n                var reprojLayerFullExt = this._apiRef.Map.Extent(gextent.x0, gextent.y0, gextent.x1, gextent.y1, gextent.sr);\n\n                // check if current map extent already in layer extent\n                return map.setScale(lod.scale).then(function () {\n                    // if map extent not in layer extent, zoom to center of layer extent\n                    // don't need to return Deferred otherwise because setScale already resolved here\n                    if (!reprojLayerFullExt.intersects(map.extent)) {\n                        return map.centerAt(reprojLayerFullExt.getCenter());\n                    }\n                });\n            } else {\n                return map.setScale(lod.scale);\n            }\n        }\n\n        /**\r\n         * Figure out visibility scale and zoom to it.  Will use layer minScale/maxScale\r\n         * and map levels of detail to determine scale boundaries.\r\n         *\r\n         * @private\r\n         * @param {Object} map            the map object\r\n         * @param {Array} lods            level of details array for basemap\r\n         * @param {Boolean} zoomIn        the zoom to scale direction; true need to zoom in; false need to zoom out\r\n         * @param {Object} scaleSet       contains min and max scales for the layer.\r\n         * @param {Boolean} zoomGraphic   an optional value when zoomToScale is use to zoom to a graphic element;\r\n         *                                    true used to zoom to a graphic element; false not used to zoom to a graphic element\r\n         */\n\n    }, {\n        key: '_zoomToScaleSet',\n        value: function _zoomToScaleSet(map, lods, zoomIn, scaleSet) {\n            var zoomGraphic = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n            // TODO update function parameters once things are working\n\n            // if the function is used to zoom to a graphic element and the layer is out of scale we always want\n            // the layer to zoom to the maximum scale allowed for the layer. In this case, zoomIn must be\n            // always false\n            zoomIn = zoomGraphic ? false : zoomIn;\n\n            // NOTE we use lods provided by config rather that system-ish map.__tileInfo.lods\n            var zoomLod = this.findZoomScale(lods, scaleSet, zoomIn, zoomGraphic = false);\n\n            // TODO ponder on the implementation of this\n            return this.setMapScale(this._layer, zoomLod, zoomIn);\n        }\n\n        // TODO docs\n\n    }, {\n        key: 'zoomToScale',\n        value: function zoomToScale(map, lods, zoomIn) {\n            var zoomGraphic = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n            // get scale set from child, then execute zoom\n            var scaleSet = this._featClasses[this._defaultFC].getScaleSet();\n            return this._zoomToScaleSet(map, lods, zoomIn, scaleSet, zoomGraphic);\n        }\n\n        // TODO docs\n\n    }, {\n        key: 'isOffScale',\n        value: function isOffScale(mapScale) {\n            return this._featClasses[this._defaultFC].isOffScale(mapScale);\n        }\n\n        /**\r\n        * Zoom to layer boundary of the layer specified by layerId\r\n        * @param {Object} map  map object we want to execute the zoom on\r\n        * @return {Promise} resolves when map is done zooming\r\n        */\n\n    }, {\n        key: 'zoomToBoundary',\n        value: function zoomToBoundary(map) {\n            return this.zoomToExtent(map, this.extent);\n        }\n\n        /**\r\n         * Worker function to zoom the map to an extent of possibly\r\n         * @param {Object} map        map object we want to execute the zoom on\r\n         * @param {Object} extent     map object we want to execute the zoom on\r\n         * @private\r\n         * @return {Promise} resolves when map is done zooming\r\n         */\n\n    }, {\n        key: 'zoomToExtent',\n        value: function zoomToExtent(map, extent) {\n            // TODO add some caching? make sure it will get wiped if we end up changing projections\n            //      or use wkid as caching key?\n            //      trickyier now that we are in shared function.\n            //      maybe return an object {promise, projected extent}, and caller can cache it?\n\n            var projRawExtent = this._apiRef.proj.localProjectExtent(extent, map.spatialReference);\n\n            var projFancyExtent = this._apiRef.Map.Extent(projRawExtent.x0, projRawExtent.y0, projRawExtent.x1, projRawExtent.y1, projRawExtent.sr);\n\n            return map.setExtent(projFancyExtent);\n        }\n\n        /**\r\n        * Returns the visible scale values of the layer\r\n        * @returns {Object} has properties .minScale and .maxScale\r\n        */\n\n    }, {\n        key: 'getVisibleScales',\n        value: function getVisibleScales() {\n            // default layer, take from layer object\n            // TODO do we need to handle a missing layer case?\n            //      no one should be calling this until layer is loaded anyways\n            return {\n                minScale: this._layer.minScale,\n                maxScale: this._layer.maxScale\n            };\n        }\n\n        /**\r\n        * Returns the feature count\r\n        * @returns {Promise} resolves feature count\r\n        */\n\n    }, {\n        key: 'getFeatureCount',\n        value: function getFeatureCount() {\n            // TODO determine best result to indicate that layer does not have features\n            //      we may want a null so that UI can display a different message (or suppress the message).\n            //      of note, the proxy is currently returning undefined for non-feature things\n            return Promise.resolve(0);\n        }\n\n        /**\r\n         * Create an extent centered around a point, that is appropriate for the current map scale.\r\n         * @param {Object} point       point on the map for extent center\r\n         * @param {Object} map         map object the extent is relevant for\r\n         * @param {Integer} tolerance  optional. distance in pixels from mouse point that qualifies as a hit. default is 5\r\n         * @return {Object} an extent of desired size and location\r\n         */\n\n    }, {\n        key: 'makeClickBuffer',\n        value: function makeClickBuffer(point, map) {\n            var tolerance = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 5;\n\n            // take pixel tolerance, convert to map units at current scale. x2 to turn radius into diameter\n            var buffSize = 2 * tolerance * map.extent.getWidth() / map.width;\n\n            // Build tolerance envelope of correct size\n            var cBuff = this._apiRef.Map.Extent(0, 0, buffSize, buffSize, point.spatialReference);\n\n            // move the envelope so it is centered around the point\n            return cBuff.centerAt(point);\n        }\n\n        // TODO docs\n\n    }, {\n        key: 'isQueryable',\n\n\n        // TODO docs\n        value: function isQueryable() {\n            return this._featClasses[this._defaultFC].queryable;\n        }\n\n        // TODO docs\n\n    }, {\n        key: 'setQueryable',\n        value: function setQueryable(value) {\n            this._featClasses[this._defaultFC].queryable = value;\n        }\n    }, {\n        key: 'getGeomType',\n        value: function getGeomType() {\n            // standard case, layer has no geometry. This gets overridden in feature-based Record classes.\n            return undefined;\n        }\n\n        // returns the proxy interface object for the root of the layer (i.e. main entry in legend, not nested child things)\n        // TODO docs\n\n    }, {\n        key: 'getProxy',\n        value: function getProxy() {\n            // NOTE baseclass used by things like WMSRecord, ImageRecord, TileRecord\n            if (!this._rootProxy) {\n                this._rootProxy = new layerInterface.LayerInterface(this, this.initialConfig.controls);\n                this._rootProxy.convertToSingleLayer(this);\n            }\n            return this._rootProxy;\n        }\n\n        /**\r\n         * Create a layer record with the appropriate geoApi layer type.  Layer config\r\n         * should be fully merged with all layer options defined (i.e. this constructor\r\n         * will not apply any defaults).\r\n         * @param {Object} layerClass    the ESRI api object for the layer\r\n         * @param {Object} apiRef        object pointing to the geoApi. allows us to call other geoApi functions.\r\n         * @param {Object} config        layer config values\r\n         * @param {Object} esriLayer     an optional pre-constructed layer\r\n         * @param {Function} epsgLookup  an optional lookup function for EPSG codes (see geoService for signature)\r\n         */\n\n    }, {\n        key: 'layerClass',\n\n        // NOTE: we used to override layerClass in each specific class.\n        //       since we require the class in the generic constructor,\n        //       and since it was requested that the esri class be passed in\n        //       as a constructor parameter instead of holding a ref to the esriBundle,\n        //       and since you must call `super` first in a constructor,\n        //       it was impossible to assign the specific class before the generic\n        //       constructor executed, resulting in null-dereferences.\n        //       this approach solves the problem.\n        get: function get() {\n            return this._layerClass;\n        }\n    }, {\n        key: 'config',\n        get: function get() {\n            return this.initialConfig;\n        } // TODO: add a live config reference if needed\n\n    }, {\n        key: 'legendEntry',\n        get: function get() {\n            return this._legendEntry;\n        } // legend entry class corresponding to those defined in legend entry service\n        ,\n        set: function set(value) {\n            this._legendEntry = value;\n        } // TODO: determine if we still link legends inside this class\n\n    }, {\n        key: 'state',\n        get: function get() {\n            return this._state;\n        },\n        set: function set(value) {\n            this._state = value;\n        }\n    }, {\n        key: 'layerId',\n        get: function get() {\n            return this.config.id;\n        }\n    }, {\n        key: 'rootUrl',\n        get: function get() {\n            return this._rootUrl;\n        },\n        set: function set(value) {\n            this._rootUrl = value;\n        }\n\n        // TODO should probably remove passthrough bindings?\n\n    }, {\n        key: '_layerPassthroughBindings',\n        get: function get() {\n            return ['setOpacity', 'setVisibility'];\n        } // TODO when jshint parses instance fields properly we can change this from a property to a field\n\n    }, {\n        key: '_layerPassthroughProperties',\n        get: function get() {\n            return ['visibleAtMapScale', 'visible', 'spatialReference'];\n        } // TODO when jshint parses instance fields properly we can change this from a property to a field\n\n    }, {\n        key: 'userLayer',\n        get: function get() {\n            return this._user;\n        } // indicates if layer was added by a user\n        ,\n        set: function set(value) {\n            this._user = value;\n        }\n    }, {\n        key: 'visibility',\n        get: function get() {\n            if (this._layer) {\n                return this._layer.visible;\n            } else {\n                return true; // TODO what should a proper default be? example of this situation??\n            }\n        },\n        set: function set(value) {\n            if (this._layer) {\n                this._layer.setVisibility(value);\n            }\n\n            // TODO do we need an ELSE case here?\n        }\n    }, {\n        key: 'opacity',\n        get: function get() {\n            if (this._layer) {\n                return this._layer.opacity;\n            } else {\n                return 1; // TODO what should a proper default be? example of this situation??\n            }\n        },\n        set: function set(value) {\n            if (this._layer) {\n                this._layer.setOpacity(value);\n            }\n\n            // TODO do we need an ELSE case here?\n        }\n    }, {\n        key: 'symbology',\n        get: function get() {\n            return this._featClasses[this._defaultFC].symbology;\n        }\n    }]);\n\n    function LayerRecord(layerClass, apiRef, config, esriLayer, epsgLookup) {\n        _classCallCheck(this, LayerRecord);\n\n        var _this = _possibleConstructorReturn(this, (LayerRecord.__proto__ || Object.getPrototypeOf(LayerRecord)).call(this));\n\n        _this._layerClass = layerClass;\n        _this.name = config.name || '';\n        _this._featClasses = {};\n        _this._defaultFC = '0';\n        _this._apiRef = apiRef;\n        _this.initialConfig = config;\n        _this._stateListeners = [];\n        _this._hoverListeners = [];\n        _this._user = false;\n        _this._epsgLookup = epsgLookup;\n        _this.extent = config.extent; // if missing, will fill more values after layer loads\n\n        // TODO verify we still use passthrough bindings.\n        _this._layerPassthroughBindings.forEach(function (bindingName) {\n            return _this[bindingName] = function () {\n                var _this$_layer;\n\n                return (_this$_layer = _this._layer)[bindingName].apply(_this$_layer, arguments);\n            };\n        });\n        _this._layerPassthroughProperties.forEach(function (propName) {\n            var descriptor = {\n                enumerable: true,\n                get: function get() {\n                    return _this._layer[propName];\n                }\n            };\n            Object.defineProperty(_this, propName, descriptor);\n        });\n\n        if (esriLayer) {\n            _this.constructLayer = function () {\n                throw new Error('Cannot construct pre-made layers');\n            };\n            _this._layer = esriLayer;\n            _this.bindEvents(_this._layer);\n            _this._rootUrl = esriLayer.url || '';\n\n            // TODO might want to change this to be whatever layer says it is\n            _this._state = shared.states.LOADING;\n            if (!_this.name) {\n                // no name from config. attempt layer name\n                _this.name = esriLayer.name;\n            }\n\n            if (!esriLayer.url) {\n                // file layer. force snapshot, force an onload\n                _this._snapshot = true;\n                _this.onLoad();\n            }\n        } else {\n            _this._rootUrl = config.url;\n            _this.constructLayer(config);\n            _this._state = shared.states.LOADING;\n        }\n        return _this;\n    }\n\n    return LayerRecord;\n}(root.Root);\n\nmodule.exports = function () {\n    return {\n        LayerRecord: LayerRecord\n    };\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXIvbGF5ZXJSZWMvbGF5ZXJSZWNvcmQuanM/OGM4YiJdLCJuYW1lcyI6WyJsYXllckludGVyZmFjZSIsInJlcXVpcmUiLCJzaGFyZWQiLCJyb290IiwiTGF5ZXJSZWNvcmQiLCJsYXllciIsIl9hcGlSZWYiLCJldmVudHMiLCJ3cmFwRXZlbnRzIiwibG9hZCIsIm9uTG9hZCIsImVycm9yIiwib25FcnJvciIsImUiLCJvblVwZGF0ZVN0YXJ0Iiwib25VcGRhdGVFbmQiLCJvbk1vdXNlT3ZlciIsIm9uTW91c2VPdXQiLCJfbGF5ZXIiLCJsYXllckNsYXNzIiwiY29uZmlnIiwidXJsIiwibWFrZUxheWVyQ29uZmlnIiwiYmluZEV2ZW50cyIsIm5ld1N0YXRlIiwiX3N0YXRlIiwiY29uc29sZSIsImxvZyIsImxheWVySWQiLCJfZmlyZUV2ZW50IiwiX3N0YXRlTGlzdGVuZXJzIiwibGlzdGVuZXJDYWxsYmFjayIsInB1c2giLCJpZHgiLCJpbmRleE9mIiwiRXJyb3IiLCJzcGxpY2UiLCJfaG92ZXJMaXN0ZW5lcnMiLCJpbmZvIiwiaWQiLCJuYW1lIiwiZXh0ZW50IiwiZnVsbEV4dGVudCIsImxvb2t1cFByb21pc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsIl9lcHNnTG9va3VwIiwiY2hlY2siLCJwcm9qIiwiY2hlY2tQcm9qIiwic3BhdGlhbFJlZmVyZW5jZSIsIndhcm4iLCJfc3RhdGVDaGFuZ2UiLCJzdGF0ZXMiLCJFUlJPUiIsIlJFRlJFU0giLCJMT0FERUQiLCJvcGFjaXR5Iiwic3RhdGUiLCJ2aXNpYmxlIiwidmlzaWJpbGl0eSIsImxvZHMiLCJzY2FsZVNldCIsInpvb21JbiIsInpvb21HcmFwaGljIiwibW9kTG9kcyIsInJldmVyc2UiLCJmaW5kIiwiY3VycmVudExvZCIsInNjYWxlIiwibWluU2NhbGUiLCJtYXhTY2FsZSIsIm1hcCIsImxvZCIsImdleHRlbnQiLCJsb2NhbFByb2plY3RFeHRlbnQiLCJyZXByb2pMYXllckZ1bGxFeHQiLCJNYXAiLCJFeHRlbnQiLCJ4MCIsInkwIiwieDEiLCJ5MSIsInNyIiwic2V0U2NhbGUiLCJ0aGVuIiwiaW50ZXJzZWN0cyIsImNlbnRlckF0IiwiZ2V0Q2VudGVyIiwiem9vbUxvZCIsImZpbmRab29tU2NhbGUiLCJzZXRNYXBTY2FsZSIsIl9mZWF0Q2xhc3NlcyIsIl9kZWZhdWx0RkMiLCJnZXRTY2FsZVNldCIsIl96b29tVG9TY2FsZVNldCIsIm1hcFNjYWxlIiwiaXNPZmZTY2FsZSIsInpvb21Ub0V4dGVudCIsInByb2pSYXdFeHRlbnQiLCJwcm9qRmFuY3lFeHRlbnQiLCJzZXRFeHRlbnQiLCJwb2ludCIsInRvbGVyYW5jZSIsImJ1ZmZTaXplIiwiZ2V0V2lkdGgiLCJ3aWR0aCIsImNCdWZmIiwicXVlcnlhYmxlIiwidmFsdWUiLCJ1bmRlZmluZWQiLCJfcm9vdFByb3h5IiwiTGF5ZXJJbnRlcmZhY2UiLCJpbml0aWFsQ29uZmlnIiwiY29udHJvbHMiLCJjb252ZXJ0VG9TaW5nbGVMYXllciIsIl9sYXllckNsYXNzIiwiX2xlZ2VuZEVudHJ5IiwiX3Jvb3RVcmwiLCJfdXNlciIsInNldFZpc2liaWxpdHkiLCJzZXRPcGFjaXR5Iiwic3ltYm9sb2d5IiwiYXBpUmVmIiwiZXNyaUxheWVyIiwiZXBzZ0xvb2t1cCIsIl9sYXllclBhc3N0aHJvdWdoQmluZGluZ3MiLCJmb3JFYWNoIiwiYmluZGluZ05hbWUiLCJfbGF5ZXJQYXNzdGhyb3VnaFByb3BlcnRpZXMiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImdldCIsInByb3BOYW1lIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJjb25zdHJ1Y3RMYXllciIsIkxPQURJTkciLCJfc25hcHNob3QiLCJSb290IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7OztBQUVBLElBQU1BLGlCQUFpQixtQkFBQUMsQ0FBUSxFQUFSLEdBQXZCO0FBQ0EsSUFBTUMsU0FBUyxtQkFBQUQsQ0FBUSxD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Z0I7QUFDWjtBQUNBLHNCQUFLQSxJQUFMLEdBQVlvRixVQUFVcEYsSUFBdEI7QUFDSDs7QUFFRCxnQkFBSSxDQUFDb0YsVUFBVXZHLEdBQWYsRUFBb0I7QUFDaEI7QUFDQSxzQkFBS3FILFNBQUwsR0FBaUIsSUFBakI7QUFDQSxzQkFBS2hJLE1BQUw7QUFDSDtBQUVKLFNBbkJELE1BbUJPO0FBQ0gsa0JBQUs0RyxRQUFMLEdBQWdCbEcsT0FBT0MsR0FBdkI7QUFDQSxrQkFBS21ILGNBQUwsQ0FBb0JwSCxNQUFwQjtBQUNBLGtCQUFLSyxNQUFMLEdBQWN2QixPQUFPbUQsTUFBUCxDQUFjb0YsT0FBNUI7QUFDSDtBQWhEMkQ7QUFpRC9EOzs7RUF0ZXFCdEksS0FBS3dJLEk7O0FBeWUvQkMsT0FBT0MsT0FBUCxHQUFpQjtBQUFBLFdBQU87QUFDcEJ6STtBQURvQixLQUFQO0FBQUEsQ0FBakIiLCJmaWxlIjoiMjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG5jb25zdCBsYXllckludGVyZmFjZSA9IHJlcXVpcmUoJy4vbGF5ZXJJbnRlcmZhY2UuanMnKSgpO1xyXG5jb25zdCBzaGFyZWQgPSByZXF1aXJlKCcuL3NoYXJlZC5qcycpKCk7XHJcbmNvbnN0IHJvb3QgPSByZXF1aXJlKCcuL3Jvb3QuanMnKSgpO1xyXG5cclxuLyoqXHJcbiAqIEBjbGFzcyBMYXllclJlY29yZFxyXG4gKi9cclxuY2xhc3MgTGF5ZXJSZWNvcmQgZXh0ZW5kcyByb290LlJvb3Qge1xyXG4gICAgLy8gTk9URTogd2UgdXNlZCB0byBvdmVycmlkZSBsYXllckNsYXNzIGluIGVhY2ggc3BlY2lmaWMgY2xhc3MuXHJcbiAgICAvLyAgICAgICBzaW5jZSB3ZSByZXF1aXJlIHRoZSBjbGFzcyBpbiB0aGUgZ2VuZXJpYyBjb25zdHJ1Y3RvcixcclxuICAgIC8vICAgICAgIGFuZCBzaW5jZSBpdCB3YXMgcmVxdWVzdGVkIHRoYXQgdGhlIGVzcmkgY2xhc3MgYmUgcGFzc2VkIGluXHJcbiAgICAvLyAgICAgICBhcyBhIGNvbnN0cnVjdG9yIHBhcmFtZXRlciBpbnN0ZWFkIG9mIGhvbGRpbmcgYSByZWYgdG8gdGhlIGVzcmlCdW5kbGUsXHJcbiAgICAvLyAgICAgICBhbmQgc2luY2UgeW91IG11c3QgY2FsbCBgc3VwZXJgIGZpcnN0IGluIGEgY29uc3RydWN0b3IsXHJcbiAgICAvLyAgICAgICBpdCB3YXMgaW1wb3NzaWJsZSB0byBhc3NpZ24gdGhlIHNwZWNpZmljIGNsYXNzIGJlZm9yZSB0aGUgZ2VuZXJpY1xyXG4gICAgLy8gICAgICAgY29uc3RydWN0b3IgZXhlY3V0ZWQsIHJlc3VsdGluZyBpbiBudWxsLWRlcmVmZXJlbmNlcy5cclxuICAgIC8vICAgICAgIHRoaXMgYXBwcm9hY2ggc29sdmVzIHRoZSBwcm9ibGVtLlxyXG4gICAgZ2V0IGxheWVyQ2xhc3MgKCkgeyByZXR1cm4gdGhpcy5fbGF5ZXJDbGFzczsgfVxyXG4gICAgZ2V0IGNvbmZpZyAoKSB7IHJldHVybiB0aGlzLmluaXRpYWxDb25maWc7IH0gLy8gVE9ETzogYWRkIGEgbGl2ZSBjb25maWcgcmVmZXJlbmNlIGlmIG5lZWRlZFxyXG4gICAgZ2V0IGxlZ2VuZEVudHJ5ICgpIHsgcmV0dXJuIHRoaXMuX2xlZ2VuZEVudHJ5OyB9IC8vIGxlZ2VuZCBlbnRyeSBjbGFzcyBjb3JyZXNwb25kaW5nIHRvIHRob3NlIGRlZmluZWQgaW4gbGVnZW5kIGVudHJ5IHNlcnZpY2VcclxuICAgIHNldCBsZWdlbmRFbnRyeSAodmFsdWUpIHsgdGhpcy5fbGVnZW5kRW50cnkgPSB2YWx1ZTsgfSAvLyBUT0RPOiBkZXRlcm1pbmUgaWYgd2Ugc3RpbGwgbGluayBsZWdlbmRzIGluc2lkZSB0aGlzIGNsYXNzXHJcbiAgICBnZXQgc3RhdGUgKCkgeyByZXR1cm4gdGhpcy5fc3RhdGU7IH1cclxuICAgIHNldCBzdGF0ZSAodmFsdWUpIHsgdGhpcy5fc3RhdGUgPSB2YWx1ZTsgfVxyXG4gICAgZ2V0IGxheWVySWQgKCkgeyByZXR1cm4gdGhpcy5jb25maWcuaWQ7IH1cclxuXHJcbiAgICBnZXQgcm9vdFVybCAoKSB7IHJldHVybiB0aGlzLl9yb290VXJsOyB9XHJcbiAgICBzZXQgcm9vdFVybCAodmFsdWUpIHsgdGhpcy5fcm9vdFVybCA9IHZhbHVlOyB9XHJcblxyXG4gICAgLy8gVE9ETyBzaG91bGQgcHJvYmFibHkgcmVtb3ZlIHBhc3N0aHJvdWdoIGJpbmRpbmdzP1xyXG4gICAgZ2V0IF9sYXllclBhc3N0aHJvdWdoQmluZGluZ3MgKCkgeyByZXR1cm4gWydzZXRPcGFjaXR5JywgJ3NldFZpc2liaWxpdHknXTsgfSAvLyBUT0RPIHdoZW4ganNoaW50IHBhcnNlcyBpbnN0YW5jZSBmaWVsZHMgcHJvcGVybHkgd2UgY2FuIGNoYW5nZSB0aGlzIGZyb20gYSBwcm9wZXJ0eSB0byBhIGZpZWxkXHJcbiAgICBnZXQgX2xheWVyUGFzc3Rocm91Z2hQcm9wZXJ0aWVzICgpIHsgcmV0dXJuIFsndmlzaWJsZUF0TWFwU2NhbGUnLCAndmlzaWJsZScsICdzcGF0aWFsUmVmZXJlbmNlJ107IH0gLy8gVE9ETyB3aGVuIGpzaGludCBwYXJzZXMgaW5zdGFuY2UgZmllbGRzIHByb3Blcmx5IHdlIGNhbiBjaGFuZ2UgdGhpcyBmcm9tIGEgcHJvcGVydHkgdG8gYSBmaWVsZFxyXG4gICAgZ2V0IHVzZXJMYXllciAoKSB7IHJldHVybiB0aGlzLl91c2VyOyB9IC8vIGluZGljYXRlcyBpZiBsYXllciB3YXMgYWRkZWQgYnkgYSB1c2VyXHJcbiAgICBzZXQgdXNlckxheWVyICh2YWx1ZSkgeyB0aGlzLl91c2VyID0gdmFsdWU7IH1cclxuXHJcbiAgICBnZXQgdmlzaWJpbGl0eSAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2xheWVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sYXllci52aXNpYmxlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBUT0RPIHdoYXQgc2hvdWxkIGEgcHJvcGVyIGRlZmF1bHQgYmU/IGV4YW1wbGUgb2YgdGhpcyBzaXR1YXRpb24/P1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHNldCB2aXNpYmlsaXR5ICh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9sYXllcikge1xyXG4gICAgICAgICAgICB0aGlzLl9sYXllci5zZXRWaXNpYmlsaXR5KHZhbHVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFRPRE8gZG8gd2UgbmVlZCBhbiBFTFNFIGNhc2UgaGVyZT9cclxuICAgIH1cclxuXHJcbiAgICBnZXQgb3BhY2l0eSAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2xheWVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sYXllci5vcGFjaXR5O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAxOyAvLyBUT0RPIHdoYXQgc2hvdWxkIGEgcHJvcGVyIGRlZmF1bHQgYmU/IGV4YW1wbGUgb2YgdGhpcyBzaXR1YXRpb24/P1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHNldCBvcGFjaXR5ICh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9sYXllcikge1xyXG4gICAgICAgICAgICB0aGlzLl9sYXllci5zZXRPcGFjaXR5KHZhbHVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFRPRE8gZG8gd2UgbmVlZCBhbiBFTFNFIGNhc2UgaGVyZT9cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEF0dGFjaCBldmVudCBoYW5kbGVycyB0byBsYXllciBldmVudHNcclxuICAgICAqL1xyXG4gICAgYmluZEV2ZW50cyAobGF5ZXIpIHtcclxuICAgICAgICAvLyBUT0RPIG9wdGlvbmFsIHJlZmFjdG9yLiAgUmF0aGVyIHRoYW4gbWFraW5nIHRoZSBldmVudHMgb2JqZWN0IGluIHRoZSBwYXJhbWV0ZXIsXHJcbiAgICAgICAgLy8gICAgICBkbyBpdCBhcyBhIHZhcmlhYmxlLCBhbmQgb25seSBhZGQgbW91c2Utb3ZlciwgbW91c2Utb3V0IGV2ZW50cyBpZiB3ZSBhcmVcclxuICAgICAgICAvLyAgICAgIGluIGFuIGFwcCBjb25maWd1cmF0aW9uIHRoYXQgd2lsbCB1c2UgaXQuIE1heSBzYXZlIGEgYml0IG9mIHByb2Nlc3NpbmdcclxuICAgICAgICAvLyAgICAgIGJ5IG5vdCBoYXZpbmcgdW51c2VkIGV2ZW50cyBiZWluZyBoYW5kbGVkIGFuZCBpZ25vcmVkLlxyXG4gICAgICAgIC8vICAgICAgU2Vjb25kIG9wdGlvbmFsIHRoaW5nLiBDYWxsIGEgc2VwYXJhdGUgd3JhcEV2ZW50cyBpbiBGZWF0dWVyUmVjb3JkIGNsYXNzXHJcbiAgICAgICAgLy8gVE9ETyBhcHBseSBqb2hhbm4gdXBkYXRlIGhlcmVcclxuICAgICAgICB0aGlzLl9hcGlSZWYuZXZlbnRzLndyYXBFdmVudHMobGF5ZXIsIHtcclxuICAgICAgICAgICAgLy8gd3JhcHBpbmcgdGhlIGZ1bmN0aW9uIGNhbGxzIHRvIGtlZXAgYHRoaXNgIGJvdW5kIGNvcnJlY3RseVxyXG4gICAgICAgICAgICBsb2FkOiAoKSA9PiB0aGlzLm9uTG9hZCgpLFxyXG4gICAgICAgICAgICBlcnJvcjogZSA9PiB0aGlzLm9uRXJyb3IoZSksXHJcbiAgICAgICAgICAgICd1cGRhdGUtc3RhcnQnOiAoKSA9PiB0aGlzLm9uVXBkYXRlU3RhcnQoKSxcclxuICAgICAgICAgICAgJ3VwZGF0ZS1lbmQnOiAoKSA9PiB0aGlzLm9uVXBkYXRlRW5kKCksXHJcbiAgICAgICAgICAgICdtb3VzZS1vdmVyJzogZSA9PiB0aGlzLm9uTW91c2VPdmVyKGUpLFxyXG4gICAgICAgICAgICAnbW91c2Utb3V0JzogZSA9PiB0aGlzLm9uTW91c2VPdXQoZSlcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFBlcmZvcm0gbGF5ZXIgaW5pdGlhbGl6YXRpb24gdGFza3NcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0TGF5ZXIgKCkge1xyXG4gICAgICAgIHRoaXMuX2xheWVyID0gdGhpcy5sYXllckNsYXNzKHRoaXMuY29uZmlnLnVybCwgdGhpcy5tYWtlTGF5ZXJDb25maWcoKSk7XHJcbiAgICAgICAgdGhpcy5iaW5kRXZlbnRzKHRoaXMuX2xheWVyKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbGF5ZXI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGUgYSBjaGFuZ2UgaW4gbGF5ZXIgc3RhdGVcclxuICAgICAqL1xyXG4gICAgX3N0YXRlQ2hhbmdlIChuZXdTdGF0ZSkge1xyXG4gICAgICAgIHRoaXMuX3N0YXRlID0gbmV3U3RhdGU7XHJcbiAgICAgICAgY29uc29sZS5sb2coYFN0YXRlIGNoYW5nZSBmb3IgJHt0aGlzLmxheWVySWR9IHRvICR7bmV3U3RhdGV9YCk7XHJcblxyXG4gICAgICAgIC8vIGlmIHdlIGRvbid0IGNvcHkgdGhlIGFycmF5IHdlIGNvdWxkIGJlIGxvb3Bpbmcgb24gYW4gYXJyYXlcclxuICAgICAgICAvLyB0aGF0IGlzIGJlaW5nIG1vZGlmaWVkIGFzIGl0IGlzIGJlaW5nIHJlYWRcclxuICAgICAgICB0aGlzLl9maXJlRXZlbnQodGhpcy5fc3RhdGVMaXN0ZW5lcnMsIHRoaXMuX3N0YXRlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFdpcmUgdXAgc3RhdGUgY2hhbmdlIGxpc3RlbmVyXHJcbiAgICAgKi9cclxuICAgIGFkZFN0YXRlTGlzdGVuZXIgKGxpc3RlbmVyQ2FsbGJhY2spIHtcclxuICAgICAgICB0aGlzLl9zdGF0ZUxpc3RlbmVycy5wdXNoKGxpc3RlbmVyQ2FsbGJhY2spO1xyXG4gICAgICAgIHJldHVybiBsaXN0ZW5lckNhbGxiYWNrO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlIGEgc3RhdGUgY2hhbmdlIGxpc3RlbmVyXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZVN0YXRlTGlzdGVuZXIgKGxpc3RlbmVyQ2FsbGJhY2spIHtcclxuICAgICAgICBjb25zdCBpZHggPSB0aGlzLl9zdGF0ZUxpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyQ2FsbGJhY2spO1xyXG4gICAgICAgIGlmIChpZHggPCAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGluZyB0byByZW1vdmUgYSBsaXN0ZW5lciB3aGljaCBpcyBub3QgcmVnaXN0ZXJlZC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fc3RhdGVMaXN0ZW5lcnMuc3BsaWNlKGlkeCwgMSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaXJlIHVwIG1vdXNlIGhvdmVyIGxpc3RlbmVyXHJcbiAgICAgKi9cclxuICAgIGFkZEhvdmVyTGlzdGVuZXIgKGxpc3RlbmVyQ2FsbGJhY2spIHtcclxuICAgICAgICB0aGlzLl9ob3Zlckxpc3RlbmVycy5wdXNoKGxpc3RlbmVyQ2FsbGJhY2spO1xyXG4gICAgICAgIHJldHVybiBsaXN0ZW5lckNhbGxiYWNrO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlIGEgbW91c2UgaG92ZXIgbGlzdGVuZXJcclxuICAgICAqL1xyXG4gICAgcmVtb3ZlSG92ZXJMaXN0ZW5lciAobGlzdGVuZXJDYWxsYmFjaykge1xyXG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMuX2hvdmVyTGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXJDYWxsYmFjayk7XHJcbiAgICAgICAgaWYgKGlkeCA8IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdHRlbXB0aW5nIHRvIHJlbW92ZSBhIGxpc3RlbmVyIHdoaWNoIGlzIG5vdCByZWdpc3RlcmVkLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9ob3Zlckxpc3RlbmVycy5zcGxpY2UoaWR4LCAxKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogVHJpZ2dlcnMgd2hlbiB0aGUgbGF5ZXIgbG9hZHMuXHJcbiAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgcHJvbWlzZXMgdGhhdCBuZWVkIHRvIHJlc29sdmUgZm9yIGxheWVyIHRvIGJlIGxvYWRlZC5cclxuICAgICpcclxuICAgICogQGZ1bmN0aW9uIG9uTG9hZFxyXG4gICAgKi9cclxuICAgIG9uTG9hZCAoKSB7XHJcbiAgICAgICAgLy8gb25seSBzdXBlci1nZW5lcmFsIHN0dWZmIGluIGhlcmUsIHRoYXQgYWxsIGxheWVycyBzaG91bGQgcnVuLlxyXG4gICAgICAgIGNvbnNvbGUuaW5mbyhgTGF5ZXIgbG9hZGVkOiAke3RoaXMuX2xheWVyLmlkfWApO1xyXG5cclxuICAgICAgICBpZiAoIXRoaXMubmFtZSkge1xyXG4gICAgICAgICAgICAvLyBubyBuYW1lIGZyb20gY29uZmlnLiBhdHRlbXB0IGxheWVyIG5hbWVcclxuICAgICAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5fbGF5ZXIubmFtZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5leHRlbnQpIHtcclxuICAgICAgICAgICAgLy8gbm8gZXh0ZW50IGZyb20gY29uZmlnLiBhdHRlbXB0IGxheWVyIGV4dGVudFxyXG4gICAgICAgICAgICB0aGlzLmV4dGVudCA9IHRoaXMuX2xheWVyLmZ1bGxFeHRlbnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgbG9va3VwUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIGlmICh0aGlzLl9lcHNnTG9va3VwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrID0gdGhpcy5fYXBpUmVmLnByb2ouY2hlY2tQcm9qKHRoaXMuc3BhdGlhbFJlZmVyZW5jZSwgdGhpcy5fZXBzZ0xvb2t1cCk7XHJcbiAgICAgICAgICAgIGlmIChjaGVjay5sb29rdXBQcm9taXNlKSB7XHJcbiAgICAgICAgICAgICAgICBsb29rdXBQcm9taXNlID0gY2hlY2subG9va3VwUHJvbWlzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gVE9ETyBpZiB3ZSBkb24ndCBmaW5kIGEgcHJvamVjdGlvbiwgdGhlIGFwcCB3aWxsIHNob3cgdGhlIGxheWVyIGxvYWRpbmcgZm9yZXZlci5cclxuICAgICAgICAgICAgLy8gICAgICBtaWdodCBuZWVkIHRvIGhhbmRsZSB0aGUgZmFpbCBjYXNlIGFuZCBzaG93IHNvbWV0aGluZyB0byB0aGUgdXNlci5cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFtsb29rdXBQcm9taXNlXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZXMgd2hlbiB0aGUgbGF5ZXIgaGFzIGFuIGVycm9yXHJcbiAgICAgKi9cclxuICAgIG9uRXJyb3IgKGUpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oYExheWVyIGVycm9yOiAke2V9YCk7XHJcbiAgICAgICAgY29uc29sZS53YXJuKGUpO1xyXG4gICAgICAgIHRoaXMuX3N0YXRlQ2hhbmdlKHNoYXJlZC5zdGF0ZXMuRVJST1IpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSGFuZGxlcyB3aGVuIHRoZSBsYXllciBzdGFydHMgdG8gdXBkYXRlXHJcbiAgICAgKi9cclxuICAgIG9uVXBkYXRlU3RhcnQgKCkge1xyXG4gICAgICAgIHRoaXMuX3N0YXRlQ2hhbmdlKHNoYXJlZC5zdGF0ZXMuUkVGUkVTSCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGVzIHdoZW4gdGhlIGxheWVyIGZpbmlzaGVzIHVwZGF0aW5nXHJcbiAgICAgKi9cclxuICAgIG9uVXBkYXRlRW5kICgpIHtcclxuICAgICAgICB0aGlzLl9zdGF0ZUNoYW5nZShzaGFyZWQuc3RhdGVzLkxPQURFRCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGVzIHdoZW4gdGhlIG1vdXNlIGVudGVycyBhIGxheWVyXHJcbiAgICAgKi9cclxuICAgIG9uTW91c2VPdmVyICgpIHtcclxuICAgICAgICAvLyBkbyBub3RoaW5nIGluIGJhc2VjbGFzc1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSGFuZGxlcyB3aGVuIHRoZSBtb3VzZSBsZWF2ZXMgYSBsYXllclxyXG4gICAgICovXHJcbiAgICBvbk1vdXNlT3V0ICgpIHtcclxuICAgICAgICAvLyBkbyBub3RoaW5nIGluIGJhc2VjbGFzc1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBvcHRpb25zIG9iamVjdCBmb3IgdGhlIHBoeXNpY2FsIGxheWVyXHJcbiAgICAgKi9cclxuICAgIG1ha2VMYXllckNvbmZpZyAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgaWQ6IHRoaXMuY29uZmlnLmlkLFxyXG4gICAgICAgICAgICBvcGFjaXR5OiB0aGlzLmNvbmZpZy5zdGF0ZS5vcGFjaXR5LFxyXG4gICAgICAgICAgICB2aXNpYmxlOiB0aGlzLmNvbmZpZy5zdGF0ZS52aXNpYmlsaXR5XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpZ3VyZSBvdXQgdmlzaWJpbGl0eSBzY2FsZS4gIFdpbGwgdXNlIGxheWVyIG1pblNjYWxlL21heFNjYWxlXHJcbiAgICAgKiBhbmQgbWFwIGxldmVscyBvZiBkZXRhaWwgdG8gZGV0ZXJtaW5lIHNjYWxlIGJvdW5kYXJpZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gbG9kcyAgICAgICAgICAgIGFycmF5IG9mIHZhbGlkIGxldmVscyBvZiBkZXRhaWwgZm9yIHRoZSBtYXBcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzY2FsZVNldCAgICAgICBjb250YWlucyAubWluU2NhbGUgYW5kIC5tYXhTY2FsZSBmb3IgdmFsaWQgdmlld2luZyBzY2FsZXNcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gem9vbUluICAgICAgICB0aGUgem9vbSB0byBzY2FsZSBkaXJlY3Rpb247IHRydWUgbmVlZCB0byB6b29tIGluOyBmYWxzZSBuZWVkIHRvIHpvb20gb3V0XHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHpvb21HcmFwaGljICAgYW4gb3B0aW9uYWwgdmFsdWUgd2hlbiB6b29tVG9TY2FsZSBpcyB1c2UgdG8gem9vbSB0byBhIGdyYXBoaWMgZWxlbWVudDtcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZSB1c2VkIHRvIHpvb20gdG8gYSBncmFwaGljIGVsZW1lbnQ7IGZhbHNlIG5vdCB1c2VkIHRvIHpvb20gdG8gYSBncmFwaGljIGVsZW1lbnRcclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGEgbGV2ZWwgb2YgZGV0YWlsIChsb2QpIG9iamVjdCBmb3IgdGhlIGFwcHJvcHJpYXRlIHNjYWxlIHRvIHpvb20gdG9cclxuICAgICAqL1xyXG4gICAgZmluZFpvb21TY2FsZSAobG9kcywgc2NhbGVTZXQsIHpvb21Jbiwgem9vbUdyYXBoaWMgPSBmYWxzZSkge1xyXG4gICAgICAgIC8vIFRPRE8gcmVuYW1lIGZ1bmN0aW9uIHRvIGdldFpvb21TY2FsZT9cclxuICAgICAgICAvLyBUT0RPIHRha2UgYSBzZWNvbmQgbG9vayBhdCBwYXJhbWV0ZXJzIHpvb21JbiBhbmQgem9vbUdyYXBoaWMuIGhvdyBhcmUgdGhleSBkZXJpdmVkIChpbiB0aGUgY2FsbGVyIGNvZGUpP1xyXG4gICAgICAgIC8vICAgICAgc2VlbXMgd2VpcmQgdG8gbWUgdG8gZG8gaXQgdGhpcyB3YXlcclxuICAgICAgICAvLyBUT0RPIG5hbWluZyBvZiBcInpvb21JblwiIGlzIHZlcnkgbWlzbGVhZGluZyBhbmQgY29uZnVzaW5nLiBpbiBwcmFjdGljZSwgd2UgYXJlIG9mdGVuXHJcbiAgICAgICAgLy8gICAgICBzZXR0aW5nIHRoZSB2YWx1ZSB0byBmYWxzZSB3aGVuIHdlIGFyZSB6b29taW5nIGRvd24gY2xvc2UgdG8gdGhlIGdyb3VuZC5cclxuICAgICAgICAvLyAgICAgIE5lZWQgZnVsbCBhbmFseXNpcyBvZiB1c2FnZSwgcG9zc2libHkgcmVuYW1lIHBhcmFtZXRlciBvciB1cGRhdGUgcGFyYW0gZG9jcy5cclxuICAgICAgICAvLyBUT0RPIHVwZGF0ZSBmdW5jdGlvbiBwYXJhbWV0ZXJzIG9uY2UgdGhpbmdzIGFyZSB3b3JraW5nXHJcblxyXG4gICAgICAgIC8vIGlmIHRoZSBmdW5jdGlvbiBpcyB1c2VkIHRvIHpvb20gdG8gYSBncmFwaGljIGVsZW1lbnQgYW5kIHRoZSBsYXllciBpcyBvdXQgb2Ygc2NhbGUgd2UgYWx3YXlzIHdhbnRcclxuICAgICAgICAvLyB0aGUgbGF5ZXIgdG8gem9vbSB0byB0aGUgbWF4aW11bSBzY2FsZSBhbGxvd2VkIGZvciB0aGUgbGF5ZXIuIEluIHRoaXMgY2FzZSwgem9vbUluIG11c3QgYmVcclxuICAgICAgICAvLyBhbHdheXMgZmFsc2VcclxuXHJcbiAgICAgICAgem9vbUluID0gKHpvb21HcmFwaGljKSA/IGZhbHNlIDogem9vbUluO1xyXG5cclxuICAgICAgICAvLyBUT0RPIGRvdWJsZS1jaGVjayB3aGVyZSBsb2RzIGFyZSBjb21pbmcgZnJvbSBpbiBvbGQgY29kZVxyXG4gICAgICAgIC8vIGNoYW5nZSBzZWFyY2ggb3JkZXIgb2YgbG9kcyBkZXBlbmRpbmcgaWYgd2UgYXJlIHpvb21pbmcgaW4gb3Igb3V0XHJcbiAgICAgICAgY29uc3QgbW9kTG9kcyA9IHpvb21JbiA/IGxvZHMgOiBbLi4ubG9kc10ucmV2ZXJzZSgpO1xyXG5cclxuICAgICAgICByZXR1cm4gbW9kTG9kcy5maW5kKGN1cnJlbnRMb2QgPT4gem9vbUluID8gY3VycmVudExvZC5zY2FsZSA8IHNjYWxlU2V0Lm1pblNjYWxlIDpcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRMb2Quc2NhbGUgPiBzY2FsZVNldC5tYXhTY2FsZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFNldCBtYXAgc2NhbGUgZGVwZW5kaW5nIG9uIHpvb21pbmcgaW4gb3Igem9vbWluZyBvdXQgb2YgbGF5ZXIgdmlzaWJpbGl0eSBzY2FsZVxyXG4gICAgKlxyXG4gICAgKiBAcGFyYW0ge09iamVjdH0gbWFwIGxheWVyIHRvIHpvb20gdG8gc2NhbGUgdG8gZm9yIGZlYXR1cmUgbGF5ZXJzOyBwYXJlbnQgbGF5ZXIgZm9yIGR5bmFtaWMgbGF5ZXJzXHJcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBsb2Qgc2NhbGUgb2JqZWN0IHRoZSBtYXAgd2lsbCBiZSBzZXQgdG9cclxuICAgICogQHBhcmFtIHtCb29sZWFufSB6b29tSW4gdGhlIHpvb20gdG8gc2NhbGUgZGlyZWN0aW9uOyB0cnVlIG5lZWQgdG8gem9vbSBpbjsgZmFsc2UgbmVlZCB0byB6b29tIG91dFxyXG4gICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gcmVzb2x2ZXMgYWZ0ZXIgbWFwIGlzIGRvbmUgY2hhbmdpbmcgaXRzIGV4dGVudFxyXG4gICAgKi9cclxuICAgIHNldE1hcFNjYWxlIChtYXAsIGxvZCwgem9vbUluKSB7XHJcbiAgICAgICAgLy8gVE9ETyBwb3NzaWJsZSB0aGlzIHdvdWxkIGxpdmUgaW4gdGhlIG1hcCBtYW5hZ2VyIGluIGEgYmlnZ2VyIHJlZmFjdG9yLlxyXG4gICAgICAgIC8vIE5PVEUgYmVjYXVzZSB3ZSB1dGlsaXplIHRoZSBsYXllciBvYmplY3QncyBmdWxsIGV4dGVudCAoYW5kIG5vdCBjaGlsZCBmZWF0dXJlIGNsYXNzIGV4dGVudHMpLFxyXG4gICAgICAgIC8vICAgICAgdGhpcyBmdW5jdGlvbiBzdGF5cyBpbiB0aGlzIGNsYXNzLlxyXG5cclxuICAgICAgICAvLyBpZiB6b29tIGluIGlzIG5lZWRlZDsgbXVzdCBmaW5kIGNlbnRlciBvZiBsYXllcidzIGZ1bGwgZXh0ZW50IGFuZCBwZXJmb3JtIGNlbnRlciZ6b29tXHJcbiAgICAgICAgaWYgKHpvb21Jbikge1xyXG4gICAgICAgICAgICAvLyBuZWVkIHRvIHJlcHJvamVjdCBpbiBjYXNlIGZ1bGwgZXh0ZW50IGluIGEgZGlmZmVyZW50IHNyIHRoYW4gYmFzZW1hcFxyXG4gICAgICAgICAgICBjb25zdCBnZXh0ZW50ID0gdGhpcy5fYXBpUmVmLnByb2oubG9jYWxQcm9qZWN0RXh0ZW50KHRoaXMuX2xheWVyLmZ1bGxFeHRlbnQsIG1hcC5zcGF0aWFsUmVmZXJlbmNlKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHJlcHJvakxheWVyRnVsbEV4dCA9IHRoaXMuX2FwaVJlZi5NYXAuRXh0ZW50KGdleHRlbnQueDAsIGdleHRlbnQueTAsXHJcbiAgICAgICAgICAgICAgICBnZXh0ZW50LngxLCBnZXh0ZW50LnkxLCBnZXh0ZW50LnNyKTtcclxuXHJcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIGN1cnJlbnQgbWFwIGV4dGVudCBhbHJlYWR5IGluIGxheWVyIGV4dGVudFxyXG4gICAgICAgICAgICByZXR1cm4gbWFwLnNldFNjYWxlKGxvZC5zY2FsZSkudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiBtYXAgZXh0ZW50IG5vdCBpbiBsYXllciBleHRlbnQsIHpvb20gdG8gY2VudGVyIG9mIGxheWVyIGV4dGVudFxyXG4gICAgICAgICAgICAgICAgLy8gZG9uJ3QgbmVlZCB0byByZXR1cm4gRGVmZXJyZWQgb3RoZXJ3aXNlIGJlY2F1c2Ugc2V0U2NhbGUgYWxyZWFkeSByZXNvbHZlZCBoZXJlXHJcbiAgICAgICAgICAgICAgICBpZiAoIXJlcHJvakxheWVyRnVsbEV4dC5pbnRlcnNlY3RzKG1hcC5leHRlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hcC5jZW50ZXJBdChyZXByb2pMYXllckZ1bGxFeHQuZ2V0Q2VudGVyKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbWFwLnNldFNjYWxlKGxvZC5zY2FsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmlndXJlIG91dCB2aXNpYmlsaXR5IHNjYWxlIGFuZCB6b29tIHRvIGl0LiAgV2lsbCB1c2UgbGF5ZXIgbWluU2NhbGUvbWF4U2NhbGVcclxuICAgICAqIGFuZCBtYXAgbGV2ZWxzIG9mIGRldGFpbCB0byBkZXRlcm1pbmUgc2NhbGUgYm91bmRhcmllcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1hcCAgICAgICAgICAgIHRoZSBtYXAgb2JqZWN0XHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBsb2RzICAgICAgICAgICAgbGV2ZWwgb2YgZGV0YWlscyBhcnJheSBmb3IgYmFzZW1hcFxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB6b29tSW4gICAgICAgIHRoZSB6b29tIHRvIHNjYWxlIGRpcmVjdGlvbjsgdHJ1ZSBuZWVkIHRvIHpvb20gaW47IGZhbHNlIG5lZWQgdG8gem9vbSBvdXRcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzY2FsZVNldCAgICAgICBjb250YWlucyBtaW4gYW5kIG1heCBzY2FsZXMgZm9yIHRoZSBsYXllci5cclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gem9vbUdyYXBoaWMgICBhbiBvcHRpb25hbCB2YWx1ZSB3aGVuIHpvb21Ub1NjYWxlIGlzIHVzZSB0byB6b29tIHRvIGEgZ3JhcGhpYyBlbGVtZW50O1xyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnVlIHVzZWQgdG8gem9vbSB0byBhIGdyYXBoaWMgZWxlbWVudDsgZmFsc2Ugbm90IHVzZWQgdG8gem9vbSB0byBhIGdyYXBoaWMgZWxlbWVudFxyXG4gICAgICovXHJcbiAgICBfem9vbVRvU2NhbGVTZXQgKG1hcCwgbG9kcywgem9vbUluLCBzY2FsZVNldCwgem9vbUdyYXBoaWMgPSBmYWxzZSkge1xyXG4gICAgICAgIC8vIFRPRE8gdXBkYXRlIGZ1bmN0aW9uIHBhcmFtZXRlcnMgb25jZSB0aGluZ3MgYXJlIHdvcmtpbmdcclxuXHJcbiAgICAgICAgLy8gaWYgdGhlIGZ1bmN0aW9uIGlzIHVzZWQgdG8gem9vbSB0byBhIGdyYXBoaWMgZWxlbWVudCBhbmQgdGhlIGxheWVyIGlzIG91dCBvZiBzY2FsZSB3ZSBhbHdheXMgd2FudFxyXG4gICAgICAgIC8vIHRoZSBsYXllciB0byB6b29tIHRvIHRoZSBtYXhpbXVtIHNjYWxlIGFsbG93ZWQgZm9yIHRoZSBsYXllci4gSW4gdGhpcyBjYXNlLCB6b29tSW4gbXVzdCBiZVxyXG4gICAgICAgIC8vIGFsd2F5cyBmYWxzZVxyXG4gICAgICAgIHpvb21JbiA9ICh6b29tR3JhcGhpYykgPyBmYWxzZSA6IHpvb21JbjtcclxuXHJcbiAgICAgICAgLy8gTk9URSB3ZSB1c2UgbG9kcyBwcm92aWRlZCBieSBjb25maWcgcmF0aGVyIHRoYXQgc3lzdGVtLWlzaCBtYXAuX190aWxlSW5mby5sb2RzXHJcbiAgICAgICAgY29uc3Qgem9vbUxvZCA9IHRoaXMuZmluZFpvb21TY2FsZShsb2RzLCBzY2FsZVNldCwgem9vbUluLCB6b29tR3JhcGhpYyA9IGZhbHNlKTtcclxuXHJcbiAgICAgICAgLy8gVE9ETyBwb25kZXIgb24gdGhlIGltcGxlbWVudGF0aW9uIG9mIHRoaXNcclxuICAgICAgICByZXR1cm4gdGhpcy5zZXRNYXBTY2FsZSh0aGlzLl9sYXllciwgem9vbUxvZCwgem9vbUluKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLy8gVE9ETyBkb2NzXHJcbiAgICB6b29tVG9TY2FsZSAobWFwLCBsb2RzLCB6b29tSW4sIHpvb21HcmFwaGljID0gZmFsc2UpIHtcclxuICAgICAgICAvLyBnZXQgc2NhbGUgc2V0IGZyb20gY2hpbGQsIHRoZW4gZXhlY3V0ZSB6b29tXHJcbiAgICAgICAgY29uc3Qgc2NhbGVTZXQgPSB0aGlzLl9mZWF0Q2xhc3Nlc1t0aGlzLl9kZWZhdWx0RkNdLmdldFNjYWxlU2V0KCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3pvb21Ub1NjYWxlU2V0KG1hcCwgbG9kcywgem9vbUluLCBzY2FsZVNldCwgem9vbUdyYXBoaWMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRPRE8gZG9jc1xyXG4gICAgaXNPZmZTY2FsZSAobWFwU2NhbGUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZmVhdENsYXNzZXNbdGhpcy5fZGVmYXVsdEZDXS5pc09mZlNjYWxlKG1hcFNjYWxlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogWm9vbSB0byBsYXllciBib3VuZGFyeSBvZiB0aGUgbGF5ZXIgc3BlY2lmaWVkIGJ5IGxheWVySWRcclxuICAgICogQHBhcmFtIHtPYmplY3R9IG1hcCAgbWFwIG9iamVjdCB3ZSB3YW50IHRvIGV4ZWN1dGUgdGhlIHpvb20gb25cclxuICAgICogQHJldHVybiB7UHJvbWlzZX0gcmVzb2x2ZXMgd2hlbiBtYXAgaXMgZG9uZSB6b29taW5nXHJcbiAgICAqL1xyXG4gICAgem9vbVRvQm91bmRhcnkgKG1hcCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnpvb21Ub0V4dGVudChtYXAsIHRoaXMuZXh0ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFdvcmtlciBmdW5jdGlvbiB0byB6b29tIHRoZSBtYXAgdG8gYW4gZXh0ZW50IG9mIHBvc3NpYmx5XHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbWFwICAgICAgICBtYXAgb2JqZWN0IHdlIHdhbnQgdG8gZXhlY3V0ZSB0aGUgem9vbSBvblxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV4dGVudCAgICAgbWFwIG9iamVjdCB3ZSB3YW50IHRvIGV4ZWN1dGUgdGhlIHpvb20gb25cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSByZXNvbHZlcyB3aGVuIG1hcCBpcyBkb25lIHpvb21pbmdcclxuICAgICAqL1xyXG4gICAgem9vbVRvRXh0ZW50IChtYXAsIGV4dGVudCkge1xyXG4gICAgICAgIC8vIFRPRE8gYWRkIHNvbWUgY2FjaGluZz8gbWFrZSBzdXJlIGl0IHdpbGwgZ2V0IHdpcGVkIGlmIHdlIGVuZCB1cCBjaGFuZ2luZyBwcm9qZWN0aW9uc1xyXG4gICAgICAgIC8vICAgICAgb3IgdXNlIHdraWQgYXMgY2FjaGluZyBrZXk/XHJcbiAgICAgICAgLy8gICAgICB0cmlja3lpZXIgbm93IHRoYXQgd2UgYXJlIGluIHNoYXJlZCBmdW5jdGlvbi5cclxuICAgICAgICAvLyAgICAgIG1heWJlIHJldHVybiBhbiBvYmplY3Qge3Byb21pc2UsIHByb2plY3RlZCBleHRlbnR9LCBhbmQgY2FsbGVyIGNhbiBjYWNoZSBpdD9cclxuXHJcbiAgICAgICAgY29uc3QgcHJvalJhd0V4dGVudCA9IHRoaXMuX2FwaVJlZi5wcm9qLmxvY2FsUHJvamVjdEV4dGVudChleHRlbnQsIG1hcC5zcGF0aWFsUmVmZXJlbmNlKTtcclxuXHJcbiAgICAgICAgY29uc3QgcHJvakZhbmN5RXh0ZW50ID0gdGhpcy5fYXBpUmVmLk1hcC5FeHRlbnQocHJvalJhd0V4dGVudC54MCwgcHJvalJhd0V4dGVudC55MCxcclxuICAgICAgICAgICAgcHJvalJhd0V4dGVudC54MSwgcHJvalJhd0V4dGVudC55MSwgcHJvalJhd0V4dGVudC5zcik7XHJcblxyXG4gICAgICAgIHJldHVybiBtYXAuc2V0RXh0ZW50KHByb2pGYW5jeUV4dGVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFJldHVybnMgdGhlIHZpc2libGUgc2NhbGUgdmFsdWVzIG9mIHRoZSBsYXllclxyXG4gICAgKiBAcmV0dXJucyB7T2JqZWN0fSBoYXMgcHJvcGVydGllcyAubWluU2NhbGUgYW5kIC5tYXhTY2FsZVxyXG4gICAgKi9cclxuICAgIGdldFZpc2libGVTY2FsZXMgKCkge1xyXG4gICAgICAgIC8vIGRlZmF1bHQgbGF5ZXIsIHRha2UgZnJvbSBsYXllciBvYmplY3RcclxuICAgICAgICAvLyBUT0RPIGRvIHdlIG5lZWQgdG8gaGFuZGxlIGEgbWlzc2luZyBsYXllciBjYXNlP1xyXG4gICAgICAgIC8vICAgICAgbm8gb25lIHNob3VsZCBiZSBjYWxsaW5nIHRoaXMgdW50aWwgbGF5ZXIgaXMgbG9hZGVkIGFueXdheXNcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBtaW5TY2FsZTogdGhpcy5fbGF5ZXIubWluU2NhbGUsXHJcbiAgICAgICAgICAgIG1heFNjYWxlOiB0aGlzLl9sYXllci5tYXhTY2FsZVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFJldHVybnMgdGhlIGZlYXR1cmUgY291bnRcclxuICAgICogQHJldHVybnMge1Byb21pc2V9IHJlc29sdmVzIGZlYXR1cmUgY291bnRcclxuICAgICovXHJcbiAgICBnZXRGZWF0dXJlQ291bnQgKCkge1xyXG4gICAgICAgIC8vIFRPRE8gZGV0ZXJtaW5lIGJlc3QgcmVzdWx0IHRvIGluZGljYXRlIHRoYXQgbGF5ZXIgZG9lcyBub3QgaGF2ZSBmZWF0dXJlc1xyXG4gICAgICAgIC8vICAgICAgd2UgbWF5IHdhbnQgYSBudWxsIHNvIHRoYXQgVUkgY2FuIGRpc3BsYXkgYSBkaWZmZXJlbnQgbWVzc2FnZSAob3Igc3VwcHJlc3MgdGhlIG1lc3NhZ2UpLlxyXG4gICAgICAgIC8vICAgICAgb2Ygbm90ZSwgdGhlIHByb3h5IGlzIGN1cnJlbnRseSByZXR1cm5pbmcgdW5kZWZpbmVkIGZvciBub24tZmVhdHVyZSB0aGluZ3NcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKDApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGFuIGV4dGVudCBjZW50ZXJlZCBhcm91bmQgYSBwb2ludCwgdGhhdCBpcyBhcHByb3ByaWF0ZSBmb3IgdGhlIGN1cnJlbnQgbWFwIHNjYWxlLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ICAgICAgIHBvaW50IG9uIHRoZSBtYXAgZm9yIGV4dGVudCBjZW50ZXJcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgICAgICAgICBtYXAgb2JqZWN0IHRoZSBleHRlbnQgaXMgcmVsZXZhbnQgZm9yXHJcbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IHRvbGVyYW5jZSAgb3B0aW9uYWwuIGRpc3RhbmNlIGluIHBpeGVscyBmcm9tIG1vdXNlIHBvaW50IHRoYXQgcXVhbGlmaWVzIGFzIGEgaGl0LiBkZWZhdWx0IGlzIDVcclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gYW4gZXh0ZW50IG9mIGRlc2lyZWQgc2l6ZSBhbmQgbG9jYXRpb25cclxuICAgICAqL1xyXG4gICAgbWFrZUNsaWNrQnVmZmVyIChwb2ludCwgbWFwLCB0b2xlcmFuY2UgPSA1KSB7XHJcbiAgICAgICAgLy8gdGFrZSBwaXhlbCB0b2xlcmFuY2UsIGNvbnZlcnQgdG8gbWFwIHVuaXRzIGF0IGN1cnJlbnQgc2NhbGUuIHgyIHRvIHR1cm4gcmFkaXVzIGludG8gZGlhbWV0ZXJcclxuICAgICAgICBjb25zdCBidWZmU2l6ZSA9IDIgKiB0b2xlcmFuY2UgKiBtYXAuZXh0ZW50LmdldFdpZHRoKCkgLyBtYXAud2lkdGg7XHJcblxyXG4gICAgICAgIC8vIEJ1aWxkIHRvbGVyYW5jZSBlbnZlbG9wZSBvZiBjb3JyZWN0IHNpemVcclxuICAgICAgICBjb25zdCBjQnVmZiA9IHRoaXMuX2FwaVJlZi5NYXAuRXh0ZW50KDAsIDAsIGJ1ZmZTaXplLCBidWZmU2l6ZSwgcG9pbnQuc3BhdGlhbFJlZmVyZW5jZSk7XHJcblxyXG4gICAgICAgIC8vIG1vdmUgdGhlIGVudmVsb3BlIHNvIGl0IGlzIGNlbnRlcmVkIGFyb3VuZCB0aGUgcG9pbnRcclxuICAgICAgICByZXR1cm4gY0J1ZmYuY2VudGVyQXQocG9pbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRPRE8gZG9jc1xyXG4gICAgZ2V0IHN5bWJvbG9neSAoKSB7IHJldHVybiB0aGlzLl9mZWF0Q2xhc3Nlc1t0aGlzLl9kZWZhdWx0RkNdLnN5bWJvbG9neTsgfVxyXG5cclxuICAgIC8vIFRPRE8gZG9jc1xyXG4gICAgaXNRdWVyeWFibGUgKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9mZWF0Q2xhc3Nlc1t0aGlzLl9kZWZhdWx0RkNdLnF1ZXJ5YWJsZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUT0RPIGRvY3NcclxuICAgIHNldFF1ZXJ5YWJsZSAodmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9mZWF0Q2xhc3Nlc1t0aGlzLl9kZWZhdWx0RkNdLnF1ZXJ5YWJsZSA9IHZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIGdldEdlb21UeXBlICgpIHtcclxuICAgICAgICAvLyBzdGFuZGFyZCBjYXNlLCBsYXllciBoYXMgbm8gZ2VvbWV0cnkuIFRoaXMgZ2V0cyBvdmVycmlkZGVuIGluIGZlYXR1cmUtYmFzZWQgUmVjb3JkIGNsYXNzZXMuXHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICAvLyByZXR1cm5zIHRoZSBwcm94eSBpbnRlcmZhY2Ugb2JqZWN0IGZvciB0aGUgcm9vdCBvZiB0aGUgbGF5ZXIgKGkuZS4gbWFpbiBlbnRyeSBpbiBsZWdlbmQsIG5vdCBuZXN0ZWQgY2hpbGQgdGhpbmdzKVxyXG4gICAgLy8gVE9ETyBkb2NzXHJcbiAgICBnZXRQcm94eSAoKSB7XHJcbiAgICAgICAgLy8gTk9URSBiYXNlY2xhc3MgdXNlZCBieSB0aGluZ3MgbGlrZSBXTVNSZWNvcmQsIEltYWdlUmVjb3JkLCBUaWxlUmVjb3JkXHJcbiAgICAgICAgaWYgKCF0aGlzLl9yb290UHJveHkpIHtcclxuICAgICAgICAgICAgdGhpcy5fcm9vdFByb3h5ID0gbmV3IGxheWVySW50ZXJmYWNlLkxheWVySW50ZXJmYWNlKHRoaXMsIHRoaXMuaW5pdGlhbENvbmZpZy5jb250cm9scyk7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RQcm94eS5jb252ZXJ0VG9TaW5nbGVMYXllcih0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3RQcm94eTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIGxheWVyIHJlY29yZCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBnZW9BcGkgbGF5ZXIgdHlwZS4gIExheWVyIGNvbmZpZ1xyXG4gICAgICogc2hvdWxkIGJlIGZ1bGx5IG1lcmdlZCB3aXRoIGFsbCBsYXllciBvcHRpb25zIGRlZmluZWQgKGkuZS4gdGhpcyBjb25zdHJ1Y3RvclxyXG4gICAgICogd2lsbCBub3QgYXBwbHkgYW55IGRlZmF1bHRzKS5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBsYXllckNsYXNzICAgIHRoZSBFU1JJIGFwaSBvYmplY3QgZm9yIHRoZSBsYXllclxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFwaVJlZiAgICAgICAgb2JqZWN0IHBvaW50aW5nIHRvIHRoZSBnZW9BcGkuIGFsbG93cyB1cyB0byBjYWxsIG90aGVyIGdlb0FwaSBmdW5jdGlvbnMuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnICAgICAgICBsYXllciBjb25maWcgdmFsdWVzXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXNyaUxheWVyICAgICBhbiBvcHRpb25hbCBwcmUtY29uc3RydWN0ZWQgbGF5ZXJcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVwc2dMb29rdXAgIGFuIG9wdGlvbmFsIGxvb2t1cCBmdW5jdGlvbiBmb3IgRVBTRyBjb2RlcyAoc2VlIGdlb1NlcnZpY2UgZm9yIHNpZ25hdHVyZSlcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IgKGxheWVyQ2xhc3MsIGFwaVJlZiwgY29uZmlnLCBlc3JpTGF5ZXIsIGVwc2dMb29rdXApIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuX2xheWVyQ2xhc3MgPSBsYXllckNsYXNzO1xyXG4gICAgICAgIHRoaXMubmFtZSA9IGNvbmZpZy5uYW1lIHx8ICcnO1xyXG4gICAgICAgIHRoaXMuX2ZlYXRDbGFzc2VzID0ge307XHJcbiAgICAgICAgdGhpcy5fZGVmYXVsdEZDID0gJzAnO1xyXG4gICAgICAgIHRoaXMuX2FwaVJlZiA9IGFwaVJlZjtcclxuICAgICAgICB0aGlzLmluaXRpYWxDb25maWcgPSBjb25maWc7XHJcbiAgICAgICAgdGhpcy5fc3RhdGVMaXN0ZW5lcnMgPSBbXTtcclxuICAgICAgICB0aGlzLl9ob3Zlckxpc3RlbmVycyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3VzZXIgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9lcHNnTG9va3VwID0gZXBzZ0xvb2t1cDtcclxuICAgICAgICB0aGlzLmV4dGVudCA9IGNvbmZpZy5leHRlbnQ7IC8vIGlmIG1pc3NpbmcsIHdpbGwgZmlsbCBtb3JlIHZhbHVlcyBhZnRlciBsYXllciBsb2Fkc1xyXG5cclxuICAgICAgICAvLyBUT0RPIHZlcmlmeSB3ZSBzdGlsbCB1c2UgcGFzc3Rocm91Z2ggYmluZGluZ3MuXHJcbiAgICAgICAgdGhpcy5fbGF5ZXJQYXNzdGhyb3VnaEJpbmRpbmdzLmZvckVhY2goYmluZGluZ05hbWUgPT5cclxuICAgICAgICAgICAgdGhpc1tiaW5kaW5nTmFtZV0gPSAoLi4uYXJncykgPT4gdGhpcy5fbGF5ZXJbYmluZGluZ05hbWVdKC4uLmFyZ3MpKTtcclxuICAgICAgICB0aGlzLl9sYXllclBhc3N0aHJvdWdoUHJvcGVydGllcy5mb3JFYWNoKHByb3BOYW1lID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IHtcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IHRoaXMuX2xheWVyW3Byb3BOYW1lXVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgcHJvcE5hbWUsIGRlc2NyaXB0b3IpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpZiAoZXNyaUxheWVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29uc3RydWN0TGF5ZXIgPSAoKSA9PiB7IHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbnN0cnVjdCBwcmUtbWFkZSBsYXllcnMnKTsgfTtcclxuICAgICAgICAgICAgdGhpcy5fbGF5ZXIgPSBlc3JpTGF5ZXI7XHJcbiAgICAgICAgICAgIHRoaXMuYmluZEV2ZW50cyh0aGlzLl9sYXllcik7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RVcmwgPSBlc3JpTGF5ZXIudXJsIHx8ICcnO1xyXG5cclxuICAgICAgICAgICAgLy8gVE9ETyBtaWdodCB3YW50IHRvIGNoYW5nZSB0aGlzIHRvIGJlIHdoYXRldmVyIGxheWVyIHNheXMgaXQgaXNcclxuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBzaGFyZWQuc3RhdGVzLkxPQURJTkc7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5uYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBubyBuYW1lIGZyb20gY29uZmlnLiBhdHRlbXB0IGxheWVyIG5hbWVcclxuICAgICAgICAgICAgICAgIHRoaXMubmFtZSA9IGVzcmlMYXllci5uYW1lO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIWVzcmlMYXllci51cmwpIHtcclxuICAgICAgICAgICAgICAgIC8vIGZpbGUgbGF5ZXIuIGZvcmNlIHNuYXBzaG90LCBmb3JjZSBhbiBvbmxvYWRcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NuYXBzaG90ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMub25Mb2FkKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fcm9vdFVybCA9IGNvbmZpZy51cmw7XHJcbiAgICAgICAgICAgIHRoaXMuY29uc3RydWN0TGF5ZXIoY29uZmlnKTtcclxuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBzaGFyZWQuc3RhdGVzLkxPQURJTkc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9ICgpID0+ICh7XHJcbiAgICBMYXllclJlY29yZFxyXG59KTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2xheWVyL2xheWVyUmVjL2xheWVyUmVjb3JkLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports){eval('var HALF_PI = Math.PI/2;\nmodule.exports = function(eccent, ts) {\n  var eccnth = 0.5 * eccent;\n  var con, dphi;\n  var phi = HALF_PI - 2 * Math.atan(ts);\n  for (var i = 0; i <= 15; i++) {\n    con = eccent * Math.sin(phi);\n    dphi = HALF_PI - 2 * Math.atan(ts * (Math.pow(((1 - con) / (1 + con)), eccnth))) - phi;\n    phi += dphi;\n    if (Math.abs(dphi) <= 0.0000000001) {\n      return phi;\n    }\n  }\n  //console.log("phi2z has NoConvergence");\n  return -9999;\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9jb21tb24vcGhpMnouanM/NWZkYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgSEFMRl9QSSA9IE1hdGguUEkvMjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZWNjZW50LCB0cykge1xuICB2YXIgZWNjbnRoID0gMC41ICogZWNjZW50O1xuICB2YXIgY29uLCBkcGhpO1xuICB2YXIgcGhpID0gSEFMRl9QSSAtIDIgKiBNYXRoLmF0YW4odHMpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8PSAxNTsgaSsrKSB7XG4gICAgY29uID0gZWNjZW50ICogTWF0aC5zaW4ocGhpKTtcbiAgICBkcGhpID0gSEFMRl9QSSAtIDIgKiBNYXRoLmF0YW4odHMgKiAoTWF0aC5wb3coKCgxIC0gY29uKSAvICgxICsgY29uKSksIGVjY250aCkpKSAtIHBoaTtcbiAgICBwaGkgKz0gZHBoaTtcbiAgICBpZiAoTWF0aC5hYnMoZHBoaSkgPD0gMC4wMDAwMDAwMDAxKSB7XG4gICAgICByZXR1cm4gcGhpO1xuICAgIH1cbiAgfVxuICAvL2NvbnNvbGUubG9nKFwicGhpMnogaGFzIE5vQ29udmVyZ2VuY2VcIik7XG4gIHJldHVybiAtOTk5OTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Byb2o0L2xpYi9jb21tb24vcGhpMnouanNcbi8vIG1vZHVsZSBpZCA9IDIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,exports){eval("var HALF_PI = Math.PI/2;\n\nmodule.exports = function(eccent, phi, sinphi) {\n  var con = eccent * sinphi;\n  var com = 0.5 * eccent;\n  con = Math.pow(((1 - con) / (1 + con)), com);\n  return (Math.tan(0.5 * (HALF_PI - phi)) / con);\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9jb21tb24vdHNmbnouanM/MGQyYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgSEFMRl9QSSA9IE1hdGguUEkvMjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihlY2NlbnQsIHBoaSwgc2lucGhpKSB7XG4gIHZhciBjb24gPSBlY2NlbnQgKiBzaW5waGk7XG4gIHZhciBjb20gPSAwLjUgKiBlY2NlbnQ7XG4gIGNvbiA9IE1hdGgucG93KCgoMSAtIGNvbikgLyAoMSArIGNvbikpLCBjb20pO1xuICByZXR1cm4gKE1hdGgudGFuKDAuNSAqIChIQUxGX1BJIC0gcGhpKSkgLyBjb24pO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHJvajQvbGliL2NvbW1vbi90c2Zuei5qc1xuLy8gbW9kdWxlIGlkID0gMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){"use strict";eval("// Common functions for use across other geoApi modules\n\n\nfunction getLayerTypeBuilder(esriBundle) {\n    /**\r\n    * Will return a string indicating the type of layer a layer object is.\r\n    * @method getLayerType\r\n    * @param  {Object} layer an ESRI API layer object\r\n    * @return {String} layer type\r\n    */\n    return function (layer) {\n        if (layer instanceof esriBundle.FeatureLayer) {\n            return 'FeatureLayer';\n        } else if (layer instanceof esriBundle.WmsLayer) {\n            return 'WmsLayer';\n        } else if (layer instanceof esriBundle.ArcGISDynamicMapServiceLayer) {\n            return 'ArcGISDynamicMapServiceLayer';\n        } else if (layer instanceof esriBundle.ArcGISTiledMapServiceLayer) {\n            return 'ArcGISTiledMapServiceLayer';\n        } else {\n            // Can add more types above as we support them\n            return 'UNKNOWN';\n        }\n    };\n}\n\n/**\r\n* Get a 'good enough' uuid. For backup purposes if client does not supply its own\r\n* unique layer id\r\n*\r\n* @method  generateUUID\r\n* @returns {String} a uuid\r\n*/\nfunction generateUUID() {\n    var d = Date.now();\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n        // do math!\n        /*jslint bitwise: true */\n        var r = (d + Math.random() * 16) % 16 | 0;\n        d = Math.floor(d / 16);\n        return (c === 'x' ? r : r & 0x3 | 0x8).toString(16);\n        /*jslint bitwise: false */\n    });\n}\n\n/**\r\n* Convert an image to a canvas element\r\n*\r\n* @param {String} url image url to convert (result from the esri print task)\r\n* @param {Object} canvas [optional = null] canvas to draw the image upon; if not supplied, a new canvas will be made\r\n* @param {Boolean} crossOrigin [optional = true] when set, tries to fetch an image with crossOrigin = anonymous\r\n* @return {Promise} conversion promise resolving into a canvas of the image\r\n*/\nfunction convertImageToCanvas(url) {\n    var canvas = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var crossOrigin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n    canvas = canvas || document.createElement('canvas');\n\n    var image = document.createElement('img'); // create image node\n\n    if (crossOrigin) {\n        image.crossOrigin = 'Anonymous'; // configure the CORS request\n    }\n\n    var conversionPromise = new Promise(function (resolve, reject) {\n        image.addEventListener('load', function () {\n\n            canvas.width = image.width; // changing canvas size will clear all previous content\n            canvas.height = image.height;\n            canvas.getContext('2d').drawImage(image, 0, 0); // draw image onto a canvas\n\n            // return canvas\n            resolve(canvas);\n        });\n        image.addEventListener('error', function (error) {\n            return reject(error);\n        });\n    });\n\n    // set image source to the one generated from the print task\n    image.src = url;\n\n    return conversionPromise;\n}\n\n/**\r\n * Loads an image (as crossing) and converts it to dataURL. If a supplied imageUri is already a dataURL, just return it.\r\n * If an image fails to load with the crossing attribute, return the original imageUri\r\n *\r\n * @function convertImagetoDataURL\r\n * @param {String} imageUri url of the image to load and convert\r\n * @param {String} imageType [optional = 'image/png'] format of the image representation\r\n * @return {Promise} promise resolving with the dataURL of the image\r\n */\nfunction convertImagetoDataURL(imageUri) {\n    var imageType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'image/png';\n\n    // this is already a dataUrl, just return\n    if (imageUri.startsWith('data')) {\n        console.log('ImageUri is already a data url');\n        return Promise.resolve(imageUri);\n    }\n\n    var loadingPromise = convertImageToCanvas(imageUri).then(function (canvas) {\n        console.log('Converting image to dataURL');\n        return canvas.toDataURL(imageType);\n    }).catch(function (error) {\n        console.error('Failed to load crossorigin image', imageUri, error);\n        return imageUri;\n    });\n\n    return loadingPromise;\n}\n\nmodule.exports = function (esriBundle) {\n    return {\n        getLayerType: getLayerTypeBuilder(esriBundle),\n        generateUUID: generateUUID,\n        convertImageToCanvas: convertImageToCanvas,\n        convertImagetoDataURL: convertImagetoDataURL\n    };\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc2hhcmVkLmpzPzA4NmUiXSwibmFtZXMiOlsiZ2V0TGF5ZXJUeXBlQnVpbGRlciIsImVzcmlCdW5kbGUiLCJsYXllciIsIkZlYXR1cmVMYXllciIsIldtc0xheWVyIiwiQXJjR0lTRHluYW1pY01hcFNlcnZpY2VMYXllciIsIkFyY0dJU1RpbGVkTWFwU2VydmljZUxheWVyIiwiZ2VuZXJhdGVVVUlEIiwiZCIsIkRhdGUiLCJub3ciLCJyZXBsYWNlIiwiciIsIk1hdGgiLCJyYW5kb20iLCJmbG9vciIsImMiLCJ0b1N0cmluZyIsImNvbnZlcnRJbWFnZVRvQ2FudmFzIiwidXJsIiwiY2FudmFzIiwiY3Jvc3NPcmlnaW4iLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJpbWFnZSIsImNvbnZlcnNpb25Qcm9taXNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJhZGRFdmVudExpc3RlbmVyIiwid2lkdGgiLCJoZWlnaHQiLCJnZXRDb250ZXh0IiwiZHJhd0ltYWdlIiwiZXJyb3IiLCJzcmMiLCJjb252ZXJ0SW1hZ2V0b0RhdGFVUkwiLCJpbWFnZVVyaSIsImltYWdlVHlwZSIsInN0YXJ0c1dpdGgiLCJjb25zb2xlIiwibG9nIiwibG9hZGluZ1Byb21pc2UiLCJ0aGVuIiwidG9EYXRhVVJMIiwiY2F0Y2giLCJtb2R1bGUiLCJleHBvcnRzIiwiZ2V0TGF5ZXJUeXBlIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBLFNBQVNBLG1CQUFULENBQTZCQyxVQUE3QixFQUF5QztBQUNyQzs7Ozs7O0FBTUEsV0FBTyxpQkFBUztBQUNaLFlBQUlDLGlCQUFpQkQsV0FBV0UsWUFBaEMsRUFBOEM7QUFDMUMsbUJBQU8sY0FBUDtBQUNILFNBRkQsTUFFTyxJQUFJRCxpQkFBaUJELFdBQVdHLFFBQWhDLEVBQTBDO0FBQzdDLG1CQUFPLFVBQVA7QUFDSCxTQUZNLE1BRUEsSUFBSUYsaUJBQWlCRCxXQUFXSSw0QkFBaEMsRUFBOEQ7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VUFBcEIsQ0FEYztBQUU1Qk0sa0NBRjRCO0FBRzVCVyxrREFINEI7QUFJNUJrQjtBQUo0QixLQUFmO0FBQUEsQ0FBakIiLCJmaWxlIjoiMjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb21tb24gZnVuY3Rpb25zIGZvciB1c2UgYWNyb3NzIG90aGVyIGdlb0FwaSBtb2R1bGVzXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbmZ1bmN0aW9uIGdldExheWVyVHlwZUJ1aWxkZXIoZXNyaUJ1bmRsZSkge1xyXG4gICAgLyoqXHJcbiAgICAqIFdpbGwgcmV0dXJuIGEgc3RyaW5nIGluZGljYXRpbmcgdGhlIHR5cGUgb2YgbGF5ZXIgYSBsYXllciBvYmplY3QgaXMuXHJcbiAgICAqIEBtZXRob2QgZ2V0TGF5ZXJUeXBlXHJcbiAgICAqIEBwYXJhbSAge09iamVjdH0gbGF5ZXIgYW4gRVNSSSBBUEkgbGF5ZXIgb2JqZWN0XHJcbiAgICAqIEByZXR1cm4ge1N0cmluZ30gbGF5ZXIgdHlwZVxyXG4gICAgKi9cclxuICAgIHJldHVybiBsYXllciA9PiB7XHJcbiAgICAgICAgaWYgKGxheWVyIGluc3RhbmNlb2YgZXNyaUJ1bmRsZS5GZWF0dXJlTGF5ZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdGZWF0dXJlTGF5ZXInO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobGF5ZXIgaW5zdGFuY2VvZiBlc3JpQnVuZGxlLldtc0xheWVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnV21zTGF5ZXInO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobGF5ZXIgaW5zdGFuY2VvZiBlc3JpQnVuZGxlLkFyY0dJU0R5bmFtaWNNYXBTZXJ2aWNlTGF5ZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdBcmNHSVNEeW5hbWljTWFwU2VydmljZUxheWVyJztcclxuICAgICAgICB9IGVsc2UgaWYgKGxheWVyIGluc3RhbmNlb2YgZXNyaUJ1bmRsZS5BcmNHSVNUaWxlZE1hcFNlcnZpY2VMYXllcikge1xyXG4gICAgICAgICAgICByZXR1cm4gJ0FyY0dJU1RpbGVkTWFwU2VydmljZUxheWVyJztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBDYW4gYWRkIG1vcmUgdHlwZXMgYWJvdmUgYXMgd2Ugc3VwcG9ydCB0aGVtXHJcbiAgICAgICAgICAgIHJldHVybiAnVU5LTk9XTic7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbn1cclxuXHJcbi8qKlxyXG4qIEdldCBhICdnb29kIGVub3VnaCcgdXVpZC4gRm9yIGJhY2t1cCBwdXJwb3NlcyBpZiBjbGllbnQgZG9lcyBub3Qgc3VwcGx5IGl0cyBvd25cclxuKiB1bmlxdWUgbGF5ZXIgaWRcclxuKlxyXG4qIEBtZXRob2QgIGdlbmVyYXRlVVVJRFxyXG4qIEByZXR1cm5zIHtTdHJpbmd9IGEgdXVpZFxyXG4qL1xyXG5mdW5jdGlvbiBnZW5lcmF0ZVVVSUQoKSB7XHJcbiAgICBsZXQgZCA9IERhdGUubm93KCk7XHJcbiAgICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBjID0+IHtcclxuICAgICAgICAvLyBkbyBtYXRoIVxyXG4gICAgICAgIC8qanNsaW50IGJpdHdpc2U6IHRydWUgKi9cclxuICAgICAgICBjb25zdCByID0gKGQgKyBNYXRoLnJhbmRvbSgpICogMTYpICUgMTYgfCAwO1xyXG4gICAgICAgIGQgPSBNYXRoLmZsb29yKGQgLyAxNik7XHJcbiAgICAgICAgcmV0dXJuIChjID09PSAneCcgPyByIDogKHIgJiAweDMgfCAweDgpKS50b1N0cmluZygxNik7XHJcbiAgICAgICAgLypqc2xpbnQgYml0d2lzZTogZmFsc2UgKi9cclxuICAgIH0pO1xyXG59XHJcblxyXG4vKipcclxuKiBDb252ZXJ0IGFuIGltYWdlIHRvIGEgY2FudmFzIGVsZW1lbnRcclxuKlxyXG4qIEBwYXJhbSB7U3RyaW5nfSB1cmwgaW1hZ2UgdXJsIHRvIGNvbnZlcnQgKHJlc3VsdCBmcm9tIHRoZSBlc3JpIHByaW50IHRhc2spXHJcbiogQHBhcmFtIHtPYmplY3R9IGNhbnZhcyBbb3B0aW9uYWwgPSBudWxsXSBjYW52YXMgdG8gZHJhdyB0aGUgaW1hZ2UgdXBvbjsgaWYgbm90IHN1cHBsaWVkLCBhIG5ldyBjYW52YXMgd2lsbCBiZSBtYWRlXHJcbiogQHBhcmFtIHtCb29sZWFufSBjcm9zc09yaWdpbiBbb3B0aW9uYWwgPSB0cnVlXSB3aGVuIHNldCwgdHJpZXMgdG8gZmV0Y2ggYW4gaW1hZ2Ugd2l0aCBjcm9zc09yaWdpbiA9IGFub255bW91c1xyXG4qIEByZXR1cm4ge1Byb21pc2V9IGNvbnZlcnNpb24gcHJvbWlzZSByZXNvbHZpbmcgaW50byBhIGNhbnZhcyBvZiB0aGUgaW1hZ2VcclxuKi9cclxuZnVuY3Rpb24gY29udmVydEltYWdlVG9DYW52YXModXJsLCBjYW52YXMgPSBudWxsLCBjcm9zc09yaWdpbiA9IHRydWUpIHtcclxuICAgIGNhbnZhcyA9IGNhbnZhcyB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuXHJcbiAgICBjb25zdCBpbWFnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpOyAvLyBjcmVhdGUgaW1hZ2Ugbm9kZVxyXG5cclxuICAgIGlmIChjcm9zc09yaWdpbikge1xyXG4gICAgICAgIGltYWdlLmNyb3NzT3JpZ2luID0gJ0Fub255bW91cyc7IC8vIGNvbmZpZ3VyZSB0aGUgQ09SUyByZXF1ZXN0XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgY29udmVyc2lvblByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcclxuXHJcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGltYWdlLndpZHRoOyAvLyBjaGFuZ2luZyBjYW52YXMgc2l6ZSB3aWxsIGNsZWFyIGFsbCBwcmV2aW91cyBjb250ZW50XHJcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XHJcbiAgICAgICAgICAgIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLmRyYXdJbWFnZShpbWFnZSwgMCwgMCk7IC8vIGRyYXcgaW1hZ2Ugb250byBhIGNhbnZhc1xyXG5cclxuICAgICAgICAgICAgLy8gcmV0dXJuIGNhbnZhc1xyXG4gICAgICAgICAgICByZXNvbHZlKGNhbnZhcyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBlcnJvciA9PlxyXG4gICAgICAgICAgICByZWplY3QoZXJyb3IpKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIHNldCBpbWFnZSBzb3VyY2UgdG8gdGhlIG9uZSBnZW5lcmF0ZWQgZnJvbSB0aGUgcHJpbnQgdGFza1xyXG4gICAgaW1hZ2Uuc3JjID0gdXJsO1xyXG5cclxuICAgIHJldHVybiBjb252ZXJzaW9uUHJvbWlzZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIExvYWRzIGFuIGltYWdlIChhcyBjcm9zc2luZykgYW5kIGNvbnZlcnRzIGl0IHRvIGRhdGFVUkwuIElmIGEgc3VwcGxpZWQgaW1hZ2VVcmkgaXMgYWxyZWFkeSBhIGRhdGFVUkwsIGp1c3QgcmV0dXJuIGl0LlxyXG4gKiBJZiBhbiBpbWFnZSBmYWlscyB0byBsb2FkIHdpdGggdGhlIGNyb3NzaW5nIGF0dHJpYnV0ZSwgcmV0dXJuIHRoZSBvcmlnaW5hbCBpbWFnZVVyaVxyXG4gKlxyXG4gKiBAZnVuY3Rpb24gY29udmVydEltYWdldG9EYXRhVVJMXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbWFnZVVyaSB1cmwgb2YgdGhlIGltYWdlIHRvIGxvYWQgYW5kIGNvbnZlcnRcclxuICogQHBhcmFtIHtTdHJpbmd9IGltYWdlVHlwZSBbb3B0aW9uYWwgPSAnaW1hZ2UvcG5nJ10gZm9ybWF0IG9mIHRoZSBpbWFnZSByZXByZXNlbnRhdGlvblxyXG4gKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHJlc29sdmluZyB3aXRoIHRoZSBkYXRhVVJMIG9mIHRoZSBpbWFnZVxyXG4gKi9cclxuZnVuY3Rpb24gY29udmVydEltYWdldG9EYXRhVVJMKGltYWdlVXJpLCBpbWFnZVR5cGUgPSAnaW1hZ2UvcG5nJykge1xyXG4gICAgLy8gdGhpcyBpcyBhbHJlYWR5IGEgZGF0YVVybCwganVzdCByZXR1cm5cclxuICAgIGlmIChpbWFnZVVyaS5zdGFydHNXaXRoKCdkYXRhJykpIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnSW1hZ2VVcmkgaXMgYWxyZWFkeSBhIGRhdGEgdXJsJyk7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShpbWFnZVVyaSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgbG9hZGluZ1Byb21pc2UgPSBjb252ZXJ0SW1hZ2VUb0NhbnZhcyhpbWFnZVVyaSlcclxuICAgICAgICAudGhlbihjYW52YXMgPT4ge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnQ29udmVydGluZyBpbWFnZSB0byBkYXRhVVJMJyk7XHJcbiAgICAgICAgICAgIHJldHVybiBjYW52YXMudG9EYXRhVVJMKGltYWdlVHlwZSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuY2F0Y2goZXJyb3IgPT4ge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gbG9hZCBjcm9zc29yaWdpbiBpbWFnZScsIGltYWdlVXJpLCBlcnJvcik7XHJcbiAgICAgICAgICAgIHJldHVybiBpbWFnZVVyaTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gbG9hZGluZ1Byb21pc2U7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZXNyaUJ1bmRsZSA9PiAoe1xyXG4gICAgZ2V0TGF5ZXJUeXBlOiBnZXRMYXllclR5cGVCdWlsZGVyKGVzcmlCdW5kbGUpLFxyXG4gICAgZ2VuZXJhdGVVVUlELFxyXG4gICAgY29udmVydEltYWdlVG9DYW52YXMsXHJcbiAgICBjb252ZXJ0SW1hZ2V0b0RhdGFVUkxcclxufSk7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9zaGFyZWQuanMiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){"use strict";eval("\n\n// Controls Interface class is used to provide something to the UI that it can bind to.\n// It helps the UI keep in line with the layer state.\n// Due to bindings, we cannot destroy & recreate an interface when a legend item\n// goes from 'Unknown Placeholder' to 'Specific Layer Type'. This means we cannot\n// do object heirarchies, as to go from PlaceholderInterface to FeatureLayerInterface\n// would require a new object. Instead, we have a class that exposes all possible\n// methods and properties as error throwing stubs. Then we replace those functions\n// with real ones once we know the flavour of interface we want.\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar LayerInterface = function () {\n\n    /**\r\n     * @param {Object} source     object that provides info to the interface. usually a LayerRecord or FeatureClass\r\n     */\n    function LayerInterface(source) {\n        _classCallCheck(this, LayerInterface);\n\n        this._source = source;\n\n        // TODO revisit isPlaceholder after grand refactor\n        this._isPlaceholder = true;\n    }\n\n    _createClass(LayerInterface, [{\n        key: 'getFeatureName',\n        // returns Promise of Object\n\n        // returns a feature name of an attribute set\n        value: function getFeatureName() {\n            return undefined;\n        } // returns String\n\n        // formats an attribute to standard details\n\n    }, {\n        key: 'attributesToDetails',\n        value: function attributesToDetails() {\n            return undefined;\n        } // returns Array\n\n        // these set values to the corresponding controls\n\n    }, {\n        key: 'setVisibility',\n        value: function setVisibility() {\n            return undefined;\n        }\n    }, {\n        key: 'setOpacity',\n        value: function setOpacity() {\n            return undefined;\n        }\n    }, {\n        key: 'setQuery',\n        value: function setQuery() {\n            return undefined;\n        }\n    }, {\n        key: 'fetchGraphic',\n        value: function fetchGraphic() {\n            return undefined;\n        } // returns promise that resolves with object containing graphics info\n\n    }, {\n        key: 'zoomToBoundary',\n        value: function zoomToBoundary() {\n            return undefined;\n        } // returns promise that resolves after zoom completes\n\n        // updates what this interface is pointing to, in terms of layer data source.\n        // often, the interface starts with a placeholder to avoid errors and return\n        // defaults. This update happens after a layer has loaded, and new now want\n        // the interface reading off the real FC.\n        // TODO docs\n\n    }, {\n        key: 'updateSource',\n        value: function updateSource(newSource) {\n            this._source = newSource;\n        }\n    }, {\n        key: 'convertToSingleLayer',\n        value: function convertToSingleLayer(layerRecord) {\n            this._source = layerRecord;\n            this._isPlaceholder = false;\n\n            newProp(this, 'symbology', standardGetSymbology);\n            newProp(this, 'state', standardGetState);\n\n            newProp(this, 'visibility', standardGetVisibility);\n            newProp(this, 'opacity', standardGetOpacity);\n            newProp(this, 'query', standardGetQuery);\n\n            newProp(this, 'name', standardGetName);\n\n            newProp(this, 'geometryType', standardGetGeometryType);\n            newProp(this, 'layerType', standardGetLayerType);\n            newProp(this, 'featureCount', standardGetFeatureCount);\n            newProp(this, 'extent', standardGetExtent);\n\n            this.setVisibility = standardSetVisibility;\n            this.setOpacity = standardSetOpacity;\n            this.setQuery = standardSetQuery;\n            this.zoomToBoundary = standardZoomToBoundary;\n        }\n    }, {\n        key: 'convertToFeatureLayer',\n        value: function convertToFeatureLayer(layerRecord) {\n            this.convertToSingleLayer(layerRecord);\n\n            newProp(this, 'snapshot', featureGetSnapshot);\n            newProp(this, 'formattedAttributes', standardGetFormattedAttributes);\n            newProp(this, 'geometryType', featureGetGeometryType);\n            newProp(this, 'featureCount', featureGetFeatureCount);\n            newProp(this, 'highlightFeature', featureGetHighlightFeature);\n\n            this.getFeatureName = featureGetFeatureName;\n            this.attributesToDetails = featureAttributesToDetails;\n            this.fetchGraphic = featureFetchGraphic;\n        }\n    }, {\n        key: 'convertToDynamicLeaf',\n        value: function convertToDynamicLeaf(dynamicFC) {\n            this._source = dynamicFC;\n            this._isPlaceholder = false;\n\n            newProp(this, 'symbology', dynamicLeafGetSymbology);\n            newProp(this, 'state', dynamicLeafGetState);\n\n            newProp(this, 'name', dynamicLeafGetName);\n\n            newProp(this, 'visibility', dynamicLeafGetVisibility);\n            newProp(this, 'opacity', dynamicLeafGetOpacity);\n            newProp(this, 'query', dynamicLeafGetQuery);\n            newProp(this, 'formattedAttributes', dynamicLeafGetFormattedAttributes);\n\n            newProp(this, 'geometryType', dynamicLeafGetGeometryType);\n            newProp(this, 'layerType', dynamicLeafGetLayerType);\n            newProp(this, 'featureCount', dynamicLeafGetFeatureCount);\n            newProp(this, 'extent', dynamicLeafGetExtent);\n\n            newProp(this, 'highlightFeature', dynamicLeafGetHighlightFeature);\n\n            this.setVisibility = dynamicLeafSetVisibility;\n            this.setOpacity = dynamicLeafSetOpacity;\n            this.setQuery = dynamicLeafSetQuery;\n            this.zoomToBoundary = dynamicLeafZoomToBoundary;\n            this.getFeatureName = featureGetFeatureName;\n            this.attributesToDetails = dynamicLeafAttributesToDetails;\n            this.fetchGraphic = dynamicLeafFetchGraphic;\n        }\n    }, {\n        key: 'convertToPlaceholder',\n        value: function convertToPlaceholder(placeholderFC) {\n            this._source = placeholderFC;\n            this._isPlaceholder = true;\n\n            newProp(this, 'symbology', standardGetSymbology);\n            newProp(this, 'name', standardGetName);\n            newProp(this, 'state', standardGetState);\n            newProp(this, 'layerType', standardGetLayerType);\n        }\n    }, {\n        key: 'isPlaceholder',\n        get: function get() {\n            return this._isPlaceholder;\n        } // returns Boolean\n\n        // these expose ui controls available on the interface and indicate which ones are disabled\n\n    }, {\n        key: 'symbology',\n        get: function get() {\n            return undefined;\n        } // returns Array\n\n        // can be group or node name\n\n    }, {\n        key: 'name',\n        get: function get() {\n            return undefined;\n        } // returns String\n\n        // these are needed for the type flag\n\n    }, {\n        key: 'layerType',\n        get: function get() {\n            return undefined;\n        } // returns String\n\n    }, {\n        key: 'geometryType',\n        get: function get() {\n            return undefined;\n        } // returns String\n\n    }, {\n        key: 'featureCount',\n        get: function get() {\n            return undefined;\n        } // returns Integer\n\n    }, {\n        key: 'extent',\n        get: function get() {\n            return undefined;\n        } // returns Object (Esri Extent)\n\n        // layer states\n\n    }, {\n        key: 'state',\n        get: function get() {\n            return undefined;\n        } // returns String\n\n        // these return the current values of the corresponding controls\n\n    }, {\n        key: 'visibility',\n        get: function get() {\n            return undefined;\n        } // returns Boolean\n\n    }, {\n        key: 'opacity',\n        get: function get() {\n            return undefined;\n        } // returns Decimal\n\n    }, {\n        key: 'query',\n        get: function get() {\n            return undefined;\n        } // returns Boolean\n\n    }, {\n        key: 'snapshot',\n        get: function get() {\n            return undefined;\n        } // returns Boolean\n\n    }, {\n        key: 'highlightFeature',\n        get: function get() {\n            return undefined;\n        } // returns Boolean\n\n        // fetches attributes for use in the datatable\n\n    }, {\n        key: 'formattedAttributes',\n        get: function get() {\n            return undefined;\n        }\n    }]);\n\n    return LayerInterface;\n}();\n\n/**\r\n * Worker function to add or override a get property on an object\r\n *\r\n * @function newProp\r\n * @private\r\n * @param {Object} target     the object that will receive the new property\r\n * @param {String} propName   name of the get property\r\n * @param {Function} getter   the function defining the guts of the get property.\r\n */\n\n\nfunction newProp(target, propName, getter) {\n    Object.defineProperty(target, propName, {\n        get: getter,\n        enumerable: true,\n        configurable: true\n    });\n}\n\n// these functions are upgrades to the duds above.\n// we don't use arrow notation, as we want the `this` to point at the object\n// that these functions get smashed into.\n\nfunction standardGetState() {\n    /* jshint validthis: true */\n    return this._source.state;\n}\n\nfunction dynamicLeafGetState() {\n    /* jshint validthis: true */\n    return this._source.state;\n}\n\nfunction standardGetVisibility() {\n    /* jshint validthis: true */\n    return this._source.visibility;\n}\n\nfunction dynamicLeafGetVisibility() {\n    /* jshint validthis: true */\n    return this._source.getVisibility();\n}\n\nfunction standardGetName() {\n    /* jshint validthis: true */\n    return this._source.name;\n}\n\nfunction dynamicLeafGetName() {\n    /* jshint validthis: true */\n    return this._source.name;\n}\n\nfunction standardGetOpacity() {\n    /* jshint validthis: true */\n    return this._source.opacity;\n}\n\nfunction dynamicLeafGetOpacity() {\n    /* jshint validthis: true */\n    return this._source.opacity;\n}\n\nfunction standardGetLayerType() {\n    /* jshint validthis: true */\n    return this._source.layerType;\n}\n\nfunction dynamicLeafGetLayerType() {\n    /* jshint validthis: true */\n    return this._source.layerType;\n}\n\nfunction standardGetExtent() {\n    /* jshint validthis: true */\n    return this._source.extent;\n}\n\nfunction dynamicLeafGetExtent() {\n    /* jshint validthis: true */\n    return this._source.extent;\n}\n\nfunction standardGetQuery() {\n    /* jshint validthis: true */\n    return this._source.isQueryable();\n}\n\nfunction dynamicLeafGetQuery() {\n    /* jshint validthis: true */\n    return this._source.queryable;\n}\n\nfunction standardGetFormattedAttributes() {\n    /* jshint validthis: true */\n\n    return this._source.getFormattedAttributes();\n}\n\nfunction dynamicLeafGetFormattedAttributes() {\n    /* jshint validthis: true */\n\n    // TODO code-wise this looks identical to standardGetFormattedAttributes.\n    //      however in this case, ._source is a DynamicFC, not a LayerRecord.\n    //      This is safer. Deleting this would avoid the duplication. Decide.\n    return this._source.getFormattedAttributes();\n}\n\nfunction standardGetSymbology() {\n    /* jshint validthis: true */\n    return this._source.symbology;\n}\n\nfunction dynamicLeafGetSymbology() {\n    /* jshint validthis: true */\n\n    // TODO code-wise this looks identical to standardGetSymbology.\n    //      however in this case, ._source is a DynamicFC, not a LayerRecord.\n    //      This is safer. Deleting this would avoid the duplication. Decide.\n    return this._source.symbology;\n}\n\nfunction standardGetGeometryType() {\n    /* jshint validthis: true */\n    return undefined;\n}\n\nfunction featureGetGeometryType() {\n    /* jshint validthis: true */\n    return this._source.getGeomType();\n}\n\nfunction dynamicLeafGetGeometryType() {\n    /* jshint validthis: true */\n\n    // TEST STATUS none\n    return this._source.geomType;\n}\n\nfunction standardGetFeatureCount() {\n    /* jshint validthis: true */\n    return undefined;\n}\n\nfunction featureGetFeatureCount() {\n    /* jshint validthis: true */\n    return this._source.featureCount;\n}\n\nfunction dynamicLeafGetFeatureCount() {\n    /* jshint validthis: true */\n    return this._source.featureCount;\n}\n\nfunction standardSetVisibility(value) {\n    /* jshint validthis: true */\n    this._source.visibility = value;\n}\n\nfunction dynamicLeafSetVisibility(value) {\n    /* jshint validthis: true */\n    this._source.setVisibility(value);\n}\n\nfunction standardSetOpacity(value) {\n    /* jshint validthis: true */\n    this._source.opacity = value;\n}\n\nfunction dynamicLeafSetOpacity(value) {\n    /* jshint validthis: true */\n    this._source.opacity = value;\n}\n\nfunction standardSetQuery(value) {\n    /* jshint validthis: true */\n    this._source.setQueryable(value);\n}\n\nfunction dynamicLeafSetQuery(value) {\n    /* jshint validthis: true */\n    this._source.queryable = value;\n}\n\nfunction featureGetSnapshot() {\n    /* jshint validthis: true */\n    return this._source.isSnapshot;\n}\n\nfunction featureGetHighlightFeature() {\n    return true;\n}\n\nfunction dynamicLeafGetHighlightFeature() {\n    /* jshint validthis: true */\n    return this._source.highlightFeature;\n}\n\nfunction standardZoomToBoundary(map) {\n    /* jshint validthis: true */\n    this._source.zoomToBoundary(map);\n}\n\nfunction dynamicLeafZoomToBoundary(map) {\n    /* jshint validthis: true */\n    this._source.zoomToBoundary(map);\n}\n\nfunction featureGetFeatureName(objId, attribs) {\n    /* jshint validthis: true */\n    return this._source.getFeatureName(objId, attribs);\n}\n\nfunction featureAttributesToDetails(attribs, fields) {\n    /* jshint validthis: true */\n    return this._source.attributesToDetails(attribs, fields);\n}\n\nfunction dynamicLeafAttributesToDetails(attribs, fields) {\n    /* jshint validthis: true */\n    return this._source._parent.attributesToDetails(attribs, fields);\n}\n\nfunction featureFetchGraphic(oid) {\n    var ignoreLocal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    /* jshint validthis: true */\n    return this._source.fetchGraphic(oid, ignoreLocal);\n}\n\nfunction dynamicLeafFetchGraphic(oid) {\n    var ignoreLocal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    /* jshint validthis: true */\n    return this._source.fetchGraphic(oid, ignoreLocal);\n}\n\nmodule.exports = function () {\n    return {\n        LayerInterface: LayerInterface\n    };\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXIvbGF5ZXJSZWMvbGF5ZXJJbnRlcmZhY2UuanM/ZWEwMiJdLCJuYW1lcyI6WyJMYXllckludGVyZmFjZSIsInNvdXJjZSIsIl9zb3VyY2UiLCJfaXNQbGFjZWhvbGRlciIsInVuZGVmaW5lZCIsIm5ld1NvdXJjZSIsImxheWVyUmVjb3JkIiwibmV3UHJvcCIsInN0YW5kYXJkR2V0U3ltYm9sb2d5Iiwic3RhbmRhcmRHZXRTdGF0ZSIsInN0YW5kYXJkR2V0VmlzaWJpbGl0eSIsInN0YW5kYXJkR2V0T3BhY2l0eSIsInN0YW5kYXJkR2V0UXVlcnkiLCJzdGFuZGFyZEdldE5hbWUiLCJzdGFuZGFyZEdldEdlb21ldHJ5VHlwZSIsInN0YW5kYXJkR2V0TGF5ZXJUeXBlIiwic3RhbmRhcmRHZXRGZWF0dXJlQ291bnQiLCJzdGFuZGFyZEdldEV4dGVudCIsInNldFZpc2liaWxpdHkiLCJzdGFuZGFyZFNldFZpc2liaWxpdHkiLCJzZXRPcGFjaXR5Iiwic3RhbmRhcmRTZXRPcGFjaXR5Iiwic2V0UXVlcnkiLCJzdGFuZGFyZFNldFF1ZXJ5Iiwiem9vbVRvQm91bmRhcnkiLCJzdGFuZGFyZFpvb21Ub0JvdW5kYXJ5IiwiY29udmVydFRvU2luZ2xlTGF5ZXIiLCJmZWF0dXJlR2V0U25hcHNob3QiLCJzdGFuZGFyZEdldEZvcm1hdHRlZEF0dHJpYnV0ZXMiLCJmZWF0dXJlR2V0R2VvbWV0cnlUeXBlIiwiZmVhdHVyZUdldEZlYXR1cmVDb3VudCIsImZlYXR1cmVHZXRIaWdobGlnaHRGZWF0dXJlIiwiZ2V0RmVhdHVyZU5hbWUiLCJmZWF0dXJlR2V0RmVhdHVyZU5hbWUiLCJhdHRyaWJ1dGVzVG9EZXRhaWxzIiwiZmVhdHVyZUF0dHJpYnV0ZXNUb0RldGFpbHMiLCJmZXRjaEdyYXBoaWMiLCJmZWF0dXJlRmV0Y2hHcmFwaGljIiwiZHluYW1pY0ZDIiwiZHluYW1pY0xlYWZHZXRTeW1ib2xvZ3kiLCJkeW5hbWljTGVhZkdldFN0YXRlIiwiZHluYW1pY0xlYWZHZXROYW1lIiwiZHluYW1pY0xlYWZHZXRWaXNpYmlsaXR5IiwiZHluYW1pY0xlYWZHZXRPcGFjaXR5IiwiZHluYW1pY0xlYWZHZXRRdWVyeSIsImR5bmFtaWNMZWFmR2V0Rm9ybWF0dGVkQXR0cmlidXRlcyIsImR5bmFtaWNMZWFmR2V0R2VvbWV0cnlUeXBlIiwiZHluYW1pY0xlYWZHZXRMYXllclR5cGUiLCJkeW5hbWljTGVhZkdldEZlYXR1cmVDb3VudCIsImR5bmFtaWNMZWFmR2V0RXh0ZW50IiwiZHluYW1pY0xlYWZHZXRIaWdobGlnaHRGZWF0dXJlIiwiZHluYW1pY0xlYWZTZXRWaXNpYmlsaXR5IiwiZHluYW1pY0xlYWZTZXRPcGFjaXR5IiwiZHluYW1pY0xlYWZTZXRRdWVyeSIsImR5bmFtaWNMZWFmWm9vbVRvQm91bmRhcnkiLCJkeW5hbWljTGVhZkF0dHJpYnV0ZXNUb0RldGFpbHMiLCJkeW5hbWljTGVhZkZldGNoR3JhcGhpYyIsInBsYWNlaG9sZGVyRkMiLCJ0YXJnZXQiLCJwcm9wTmFtZSIsImdldHRlciIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZ2V0IiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsInN0YXRlIiwidmlzaWJpbGl0eSIsImdldFZpc2liaWxpdHkiLCJuYW1lIiwib3BhY2l0eSIsImxheWVyVHlwZSIsImV4dGVudCIsImlzUXVlcnlhYmxlIiwicXVlcnlhYmxlIiwiZ2V0Rm9ybWF0dGVkQXR0cmlidXRlcyIsInN5bWJvbG9neSIsImdldEdlb21UeXBlIiwiZ2VvbVR5cGUiLCJmZWF0dXJlQ291bnQiLCJ2YWx1ZSIsInNldFF1ZXJ5YWJsZSIsImlzU25hcHNob3QiLCJoaWdobGlnaHRGZWF0dXJlIiwibWFwIiwib2JqSWQiLCJhdHRyaWJzIiwiZmllbGRzIiwiX3BhcmVudCIsIm9pZCIsImlnbm9yZUxvY2FsIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUF3QytCLE9BQXhDLEVBQWlEQyxNQUFqRCxFQUF5RDtBQUNyRDtBQUNBLFdBQU8sS0FBS3JGLE9BQUwsQ0FBYXNGLE9BQWIsQ0FBcUJ0RCxtQkFBckIsQ0FBeUNvRCxPQUF6QyxFQUFrREMsTUFBbEQsQ0FBUDtBQUNIOztBQUVELFNBQVNsRCxtQkFBVCxDQUE2Qm9ELEdBQTdCLEVBQXVEO0FBQUEsUUFBckJDLFdBQXFCLHVFQUFQLEtBQU87O0FBQ25EO0FBQ0EsV0FBTyxLQUFLeEYsT0FBTCxDQUFha0MsWUFBYixDQUEwQnFELEdBQTFCLEVBQStCQyxXQUEvQixDQUFQO0FBQ0g7O0FBRUQsU0FBU2xDLHVCQUFULENBQWlDaUMsR0FBakMsRUFBMkQ7QUFBQSxRQUFyQkMsV0FBcUIsdUVBQVAsS0FBTzs7QUFDdkQ7QUFDQSxXQUFPLEtBQUt4RixPQUFMLENBQWFrQyxZQUFiLENBQTBCcUQsR0FBMUIsRUFBK0JDLFdBQS9CLENBQVA7QUFDSDs7QUFFREMsT0FBT0MsT0FBUCxHQUFpQjtBQUFBLFdBQU87QUFDcEI1RjtBQURvQixLQUFQO0FBQUEsQ0FBakIiLCJmaWxlIjoiMjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG4vLyBDb250cm9scyBJbnRlcmZhY2UgY2xhc3MgaXMgdXNlZCB0byBwcm92aWRlIHNvbWV0aGluZyB0byB0aGUgVUkgdGhhdCBpdCBjYW4gYmluZCB0by5cclxuLy8gSXQgaGVscHMgdGhlIFVJIGtlZXAgaW4gbGluZSB3aXRoIHRoZSBsYXllciBzdGF0ZS5cclxuLy8gRHVlIHRvIGJpbmRpbmdzLCB3ZSBjYW5ub3QgZGVzdHJveSAmIHJlY3JlYXRlIGFuIGludGVyZmFjZSB3aGVuIGEgbGVnZW5kIGl0ZW1cclxuLy8gZ29lcyBmcm9tICdVbmtub3duIFBsYWNlaG9sZGVyJyB0byAnU3BlY2lmaWMgTGF5ZXIgVHlwZScuIFRoaXMgbWVhbnMgd2UgY2Fubm90XHJcbi8vIGRvIG9iamVjdCBoZWlyYXJjaGllcywgYXMgdG8gZ28gZnJvbSBQbGFjZWhvbGRlckludGVyZmFjZSB0byBGZWF0dXJlTGF5ZXJJbnRlcmZhY2VcclxuLy8gd291bGQgcmVxdWlyZSBhIG5ldyBvYmplY3QuIEluc3RlYWQsIHdlIGhhdmUgYSBjbGFzcyB0aGF0IGV4cG9zZXMgYWxsIHBvc3NpYmxlXHJcbi8vIG1ldGhvZHMgYW5kIHByb3BlcnRpZXMgYXMgZXJyb3IgdGhyb3dpbmcgc3R1YnMuIFRoZW4gd2UgcmVwbGFjZSB0aG9zZSBmdW5jdGlvbnNcclxuLy8gd2l0aCByZWFsIG9uZXMgb25jZSB3ZSBrbm93IHRoZSBmbGF2b3VyIG9mIGludGVyZmFjZSB3ZSB3YW50LlxyXG5cclxuY2xhc3MgTGF5ZXJJbnRlcmZhY2Uge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSAgICAgb2JqZWN0IHRoYXQgcHJvdmlkZXMgaW5mbyB0byB0aGUgaW50ZXJmYWNlLiB1c3VhbGx5IGEgTGF5ZXJSZWNvcmQgb3IgRmVhdHVyZUNsYXNzXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yIChzb3VyY2UpIHtcclxuICAgICAgICB0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XHJcblxyXG4gICAgICAgIC8vIFRPRE8gcmV2aXNpdCBpc1BsYWNlaG9sZGVyIGFmdGVyIGdyYW5kIHJlZmFjdG9yXHJcbiAgICAgICAgdGhpcy5faXNQbGFjZWhvbGRlciA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IGlzUGxhY2Vob2xkZXIgKCkgeyByZXR1cm4gdGhpcy5faXNQbGFjZWhvbGRlcjsgfSAvLyByZXR1cm5zIEJvb2xlYW5cclxuXHJcbiAgICAvLyB0aGVzZSBleHBvc2UgdWkgY29udHJvbHMgYXZhaWxhYmxlIG9uIHRoZSBpbnRlcmZhY2UgYW5kIGluZGljYXRlIHdoaWNoIG9uZXMgYXJlIGRpc2FibGVkXHJcbiAgICBnZXQgc3ltYm9sb2d5ICgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSAvLyByZXR1cm5zIEFycmF5XHJcblxyXG4gICAgLy8gY2FuIGJlIGdyb3VwIG9yIG5vZGUgbmFtZVxyXG4gICAgZ2V0IG5hbWUgKCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IC8vIHJldHVybnMgU3RyaW5nXHJcblxyXG4gICAgLy8gdGhlc2UgYXJlIG5lZWRlZCBmb3IgdGhlIHR5cGUgZmxhZ1xyXG4gICAgZ2V0IGxheWVyVHlwZSAoKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gLy8gcmV0dXJucyBTdHJpbmdcclxuICAgIGdldCBnZW9tZXRyeVR5cGUgKCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IC8vIHJldHVybnMgU3RyaW5nXHJcbiAgICBnZXQgZmVhdHVyZUNvdW50ICgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSAvLyByZXR1cm5zIEludGVnZXJcclxuICAgIGdldCBleHRlbnQgKCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IC8vIHJldHVybnMgT2JqZWN0IChFc3JpIEV4dGVudClcclxuXHJcbiAgICAvLyBsYXllciBzdGF0ZXNcclxuICAgIGdldCBzdGF0ZSAoKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gLy8gcmV0dXJucyBTdHJpbmdcclxuXHJcbiAgICAvLyB0aGVzZSByZXR1cm4gdGhlIGN1cnJlbnQgdmFsdWVzIG9mIHRoZSBjb3JyZXNwb25kaW5nIGNvbnRyb2xzXHJcbiAgICBnZXQgdmlzaWJpbGl0eSAoKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gLy8gcmV0dXJucyBCb29sZWFuXHJcbiAgICBnZXQgb3BhY2l0eSAoKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gLy8gcmV0dXJucyBEZWNpbWFsXHJcbiAgICBnZXQgcXVlcnkgKCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IC8vIHJldHVybnMgQm9vbGVhblxyXG4gICAgZ2V0IHNuYXBzaG90ICgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSAvLyByZXR1cm5zIEJvb2xlYW5cclxuICAgIGdldCBoaWdobGlnaHRGZWF0dXJlICgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSAvLyByZXR1cm5zIEJvb2xlYW5cclxuXHJcbiAgICAvLyBmZXRjaGVzIGF0dHJpYnV0ZXMgZm9yIHVzZSBpbiB0aGUgZGF0YXRhYmxlXHJcbiAgICBnZXQgZm9ybWF0dGVkQXR0cmlidXRlcyAoKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gLy8gcmV0dXJucyBQcm9taXNlIG9mIE9iamVjdFxyXG5cclxuICAgIC8vIHJldHVybnMgYSBmZWF0dXJlIG5hbWUgb2YgYW4gYXR0cmlidXRlIHNldFxyXG4gICAgZ2V0RmVhdHVyZU5hbWUgKCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IC8vIHJldHVybnMgU3RyaW5nXHJcblxyXG4gICAgLy8gZm9ybWF0cyBhbiBhdHRyaWJ1dGUgdG8gc3RhbmRhcmQgZGV0YWlsc1xyXG4gICAgYXR0cmlidXRlc1RvRGV0YWlscyAoKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gLy8gcmV0dXJucyBBcnJheVxyXG5cclxuICAgIC8vIHRoZXNlIHNldCB2YWx1ZXMgdG8gdGhlIGNvcnJlc3BvbmRpbmcgY29udHJvbHNcclxuICAgIHNldFZpc2liaWxpdHkgKCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XHJcbiAgICBzZXRPcGFjaXR5ICgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxyXG4gICAgc2V0UXVlcnkgKCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XHJcblxyXG4gICAgZmV0Y2hHcmFwaGljICgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSAvLyByZXR1cm5zIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIG9iamVjdCBjb250YWluaW5nIGdyYXBoaWNzIGluZm9cclxuICAgIHpvb21Ub0JvdW5kYXJ5ICgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSAvLyByZXR1cm5zIHByb21pc2UgdGhhdCByZXNvbHZlcyBhZnRlciB6b29tIGNvbXBsZXRlc1xyXG5cclxuICAgIC8vIHVwZGF0ZXMgd2hhdCB0aGlzIGludGVyZmFjZSBpcyBwb2ludGluZyB0bywgaW4gdGVybXMgb2YgbGF5ZXIgZGF0YSBzb3VyY2UuXHJcbiAgICAvLyBvZnRlbiwgdGhlIGludGVyZmFjZSBzdGFydHMgd2l0aCBhIHBsYWNlaG9sZGVyIHRvIGF2b2lkIGVycm9ycyBhbmQgcmV0dXJuXHJcbiAgICAvLyBkZWZhdWx0cy4gVGhpcyB1cGRhdGUgaGFwcGVucyBhZnRlciBhIGxheWVyIGhhcyBsb2FkZWQsIGFuZCBuZXcgbm93IHdhbnRcclxuICAgIC8vIHRoZSBpbnRlcmZhY2UgcmVhZGluZyBvZmYgdGhlIHJlYWwgRkMuXHJcbiAgICAvLyBUT0RPIGRvY3NcclxuICAgIHVwZGF0ZVNvdXJjZSAobmV3U291cmNlKSB7XHJcbiAgICAgICAgdGhpcy5fc291cmNlID0gbmV3U291cmNlO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnZlcnRUb1NpbmdsZUxheWVyIChsYXllclJlY29yZCkge1xyXG4gICAgICAgIHRoaXMuX3NvdXJjZSA9IGxheWVyUmVjb3JkO1xyXG4gICAgICAgIHRoaXMuX2lzUGxhY2Vob2xkZXIgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgbmV3UHJvcCh0aGlzLCAnc3ltYm9sb2d5Jywgc3RhbmRhcmRHZXRTeW1ib2xvZ3kpO1xyXG4gICAgICAgIG5ld1Byb3AodGhpcywgJ3N0YXRlJywgc3RhbmRhcmRHZXRTdGF0ZSk7XHJcblxyXG4gICAgICAgIG5ld1Byb3AodGhpcywgJ3Zpc2liaWxpdHknLCBzdGFuZGFyZEdldFZpc2liaWxpdHkpO1xyXG4gICAgICAgIG5ld1Byb3AodGhpcywgJ29wYWNpdHknLCBzdGFuZGFyZEdldE9wYWNpdHkpO1xyXG4gICAgICAgIG5ld1Byb3AodGhpcywgJ3F1ZXJ5Jywgc3RhbmRhcmRHZXRRdWVyeSk7XHJcblxyXG4gICAgICAgIG5ld1Byb3AodGhpcywgJ25hbWUnLCBzdGFuZGFyZEdldE5hbWUpO1xyXG5cclxuICAgICAgICBuZXdQcm9wKHRoaXMsICdnZW9tZXRyeVR5cGUnLCBzdGFuZGFyZEdldEdlb21ldHJ5VHlwZSk7XHJcbiAgICAgICAgbmV3UHJvcCh0aGlzLCAnbGF5ZXJUeXBlJywgc3RhbmRhcmRHZXRMYXllclR5cGUpO1xyXG4gICAgICAgIG5ld1Byb3AodGhpcywgJ2ZlYXR1cmVDb3VudCcsIHN0YW5kYXJkR2V0RmVhdHVyZUNvdW50KTtcclxuICAgICAgICBuZXdQcm9wKHRoaXMsICdleHRlbnQnLCBzdGFuZGFyZEdldEV4dGVudCk7XHJcblxyXG4gICAgICAgIHRoaXMuc2V0VmlzaWJpbGl0eSA9IHN0YW5kYXJkU2V0VmlzaWJpbGl0eTtcclxuICAgICAgICB0aGlzLnNldE9wYWNpdHkgPSBzdGFuZGFyZFNldE9wYWNpdHk7XHJcbiAgICAgICAgdGhpcy5zZXRRdWVyeSA9IHN0YW5kYXJkU2V0UXVlcnk7XHJcbiAgICAgICAgdGhpcy56b29tVG9Cb3VuZGFyeSA9IHN0YW5kYXJkWm9vbVRvQm91bmRhcnk7XHJcbiAgICB9XHJcblxyXG4gICAgY29udmVydFRvRmVhdHVyZUxheWVyIChsYXllclJlY29yZCkge1xyXG4gICAgICAgIHRoaXMuY29udmVydFRvU2luZ2xlTGF5ZXIobGF5ZXJSZWNvcmQpO1xyXG5cclxuICAgICAgICBuZXdQcm9wKHRoaXMsICdzbmFwc2hvdCcsIGZlYXR1cmVHZXRTbmFwc2hvdCk7XHJcbiAgICAgICAgbmV3UHJvcCh0aGlzLCAnZm9ybWF0dGVkQXR0cmlidXRlcycsIHN0YW5kYXJkR2V0Rm9ybWF0dGVkQXR0cmlidXRlcyk7XHJcbiAgICAgICAgbmV3UHJvcCh0aGlzLCAnZ2VvbWV0cnlUeXBlJywgZmVhdHVyZUdldEdlb21ldHJ5VHlwZSk7XHJcbiAgICAgICAgbmV3UHJvcCh0aGlzLCAnZmVhdHVyZUNvdW50JywgZmVhdHVyZUdldEZlYXR1cmVDb3VudCk7XHJcbiAgICAgICAgbmV3UHJvcCh0aGlzLCAnaGlnaGxpZ2h0RmVhdHVyZScsIGZlYXR1cmVHZXRIaWdobGlnaHRGZWF0dXJlKTtcclxuXHJcbiAgICAgICAgdGhpcy5nZXRGZWF0dXJlTmFtZSA9IGZlYXR1cmVHZXRGZWF0dXJlTmFtZTtcclxuICAgICAgICB0aGlzLmF0dHJpYnV0ZXNUb0RldGFpbHMgPSBmZWF0dXJlQXR0cmlidXRlc1RvRGV0YWlscztcclxuICAgICAgICB0aGlzLmZldGNoR3JhcGhpYyA9IGZlYXR1cmVGZXRjaEdyYXBoaWM7XHJcbiAgICB9XHJcblxyXG4gICAgY29udmVydFRvRHluYW1pY0xlYWYgKGR5bmFtaWNGQykge1xyXG4gICAgICAgIHRoaXMuX3NvdXJjZSA9IGR5bmFtaWNGQztcclxuICAgICAgICB0aGlzLl9pc1BsYWNlaG9sZGVyID0gZmFsc2U7XHJcblxyXG4gICAgICAgIG5ld1Byb3AodGhpcywgJ3N5bWJvbG9neScsIGR5bmFtaWNMZWFmR2V0U3ltYm9sb2d5KTtcclxuICAgICAgICBuZXdQcm9wKHRoaXMsICdzdGF0ZScsIGR5bmFtaWNMZWFmR2V0U3RhdGUpO1xyXG5cclxuICAgICAgICBuZXdQcm9wKHRoaXMsICduYW1lJywgZHluYW1pY0xlYWZHZXROYW1lKTtcclxuXHJcbiAgICAgICAgbmV3UHJvcCh0aGlzLCAndmlzaWJpbGl0eScsIGR5bmFtaWNMZWFmR2V0VmlzaWJpbGl0eSk7XHJcbiAgICAgICAgbmV3UHJvcCh0aGlzLCAnb3BhY2l0eScsIGR5bmFtaWNMZWFmR2V0T3BhY2l0eSk7XHJcbiAgICAgICAgbmV3UHJvcCh0aGlzLCAncXVlcnknLCBkeW5hbWljTGVhZkdldFF1ZXJ5KTtcclxuICAgICAgICBuZXdQcm9wKHRoaXMsICdmb3JtYXR0ZWRBdHRyaWJ1dGVzJywgZHluYW1pY0xlYWZHZXRGb3JtYXR0ZWRBdHRyaWJ1dGVzKTtcclxuXHJcbiAgICAgICAgbmV3UHJvcCh0aGlzLCAnZ2VvbWV0cnlUeXBlJywgZHluYW1pY0xlYWZHZXRHZW9tZXRyeVR5cGUpO1xyXG4gICAgICAgIG5ld1Byb3AodGhpcywgJ2xheWVyVHlwZScsIGR5bmFtaWNMZWFmR2V0TGF5ZXJUeXBlKTtcclxuICAgICAgICBuZXdQcm9wKHRoaXMsICdmZWF0dXJlQ291bnQnLCBkeW5hbWljTGVhZkdldEZlYXR1cmVDb3VudCk7XHJcbiAgICAgICAgbmV3UHJvcCh0aGlzLCAnZXh0ZW50JywgZHluYW1pY0xlYWZHZXRFeHRlbnQpO1xyXG5cclxuICAgICAgICBuZXdQcm9wKHRoaXMsICdoaWdobGlnaHRGZWF0dXJlJywgZHluYW1pY0xlYWZHZXRIaWdobGlnaHRGZWF0dXJlKTtcclxuXHJcbiAgICAgICAgdGhpcy5zZXRWaXNpYmlsaXR5ID0gZHluYW1pY0xlYWZTZXRWaXNpYmlsaXR5O1xyXG4gICAgICAgIHRoaXMuc2V0T3BhY2l0eSA9IGR5bmFtaWNMZWFmU2V0T3BhY2l0eTtcclxuICAgICAgICB0aGlzLnNldFF1ZXJ5ID0gZHluYW1pY0xlYWZTZXRRdWVyeTtcclxuICAgICAgICB0aGlzLnpvb21Ub0JvdW5kYXJ5ID0gZHluYW1pY0xlYWZab29tVG9Cb3VuZGFyeTtcclxuICAgICAgICB0aGlzLmdldEZlYXR1cmVOYW1lID0gZmVhdHVyZUdldEZlYXR1cmVOYW1lO1xyXG4gICAgICAgIHRoaXMuYXR0cmlidXRlc1RvRGV0YWlscyA9IGR5bmFtaWNMZWFmQXR0cmlidXRlc1RvRGV0YWlscztcclxuICAgICAgICB0aGlzLmZldGNoR3JhcGhpYyA9IGR5bmFtaWNMZWFmRmV0Y2hHcmFwaGljO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnZlcnRUb1BsYWNlaG9sZGVyIChwbGFjZWhvbGRlckZDKSB7XHJcbiAgICAgICAgdGhpcy5fc291cmNlID0gcGxhY2Vob2xkZXJGQztcclxuICAgICAgICB0aGlzLl9pc1BsYWNlaG9sZGVyID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgbmV3UHJvcCh0aGlzLCAnc3ltYm9sb2d5Jywgc3RhbmRhcmRHZXRTeW1ib2xvZ3kpO1xyXG4gICAgICAgIG5ld1Byb3AodGhpcywgJ25hbWUnLCBzdGFuZGFyZEdldE5hbWUpO1xyXG4gICAgICAgIG5ld1Byb3AodGhpcywgJ3N0YXRlJywgc3RhbmRhcmRHZXRTdGF0ZSk7XHJcbiAgICAgICAgbmV3UHJvcCh0aGlzLCAnbGF5ZXJUeXBlJywgc3RhbmRhcmRHZXRMYXllclR5cGUpO1xyXG4gICAgfVxyXG5cclxufVxyXG5cclxuLyoqXHJcbiAqIFdvcmtlciBmdW5jdGlvbiB0byBhZGQgb3Igb3ZlcnJpZGUgYSBnZXQgcHJvcGVydHkgb24gYW4gb2JqZWN0XHJcbiAqXHJcbiAqIEBmdW5jdGlvbiBuZXdQcm9wXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgICAgIHRoZSBvYmplY3QgdGhhdCB3aWxsIHJlY2VpdmUgdGhlIG5ldyBwcm9wZXJ0eVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcE5hbWUgICBuYW1lIG9mIHRoZSBnZXQgcHJvcGVydHlcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZ2V0dGVyICAgdGhlIGZ1bmN0aW9uIGRlZmluaW5nIHRoZSBndXRzIG9mIHRoZSBnZXQgcHJvcGVydHkuXHJcbiAqL1xyXG5mdW5jdGlvbiBuZXdQcm9wKHRhcmdldCwgcHJvcE5hbWUsIGdldHRlcikge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcE5hbWUsIHtcclxuICAgICAgICBnZXQ6IGdldHRlcixcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbn1cclxuXHJcbi8vIHRoZXNlIGZ1bmN0aW9ucyBhcmUgdXBncmFkZXMgdG8gdGhlIGR1ZHMgYWJvdmUuXHJcbi8vIHdlIGRvbid0IHVzZSBhcnJvdyBub3RhdGlvbiwgYXMgd2Ugd2FudCB0aGUgYHRoaXNgIHRvIHBvaW50IGF0IHRoZSBvYmplY3RcclxuLy8gdGhhdCB0aGVzZSBmdW5jdGlvbnMgZ2V0IHNtYXNoZWQgaW50by5cclxuXHJcbmZ1bmN0aW9uIHN0YW5kYXJkR2V0U3RhdGUoKSB7XHJcbiAgICAvKiBqc2hpbnQgdmFsaWR0aGlzOiB0cnVlICovXHJcbiAgICByZXR1cm4gdGhpcy5fc291cmNlLnN0YXRlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBkeW5hbWljTGVhZkdldFN0YXRlKCkge1xyXG4gICAgLyoganNoaW50IHZhbGlkdGhpczogdHJ1ZSAqL1xyXG4gICAgcmV0dXJuIHRoaXMuX3NvdXJjZS5zdGF0ZTtcclxufVxyXG5cclxuZnVuY3Rpb24gc3RhbmRhcmRHZXRWaXNpYmlsaXR5KCkge1xyXG4gICAgLyoganNoaW50IHZhbGlkdGhpczogdHJ1ZSAqL1xyXG4gICAgcmV0dXJuIHRoaXMuX3NvdXJjZS52aXNpYmlsaXR5O1xyXG59XHJcblxyXG5mdW5jdGlvbiBkeW5hbWljTGVhZkdldFZpc2liaWxpdHkoKSB7XHJcbiAgICAvKiBqc2hpbnQgdmFsaWR0aGlzOiB0cnVlICovXHJcbiAgICByZXR1cm4gdGhpcy5fc291cmNlLmdldFZpc2liaWxpdHkoKTtcclxufVxyXG5cclxuZnVuY3Rpb24gc3RhbmRhcmRHZXROYW1lKCkge1xyXG4gICAgLyoganNoaW50IHZhbGlkdGhpczogdHJ1ZSAqL1xyXG4gICAgcmV0dXJuIHRoaXMuX3NvdXJjZS5uYW1lO1xyXG59XHJcblxyXG5mdW5jdGlvbiBkeW5hbWljTGVhZkdldE5hbWUoKSB7XHJcbiAgICAvKiBqc2hpbnQgdmFsaWR0aGlzOiB0cnVlICovXHJcbiAgICByZXR1cm4gdGhpcy5fc291cmNlLm5hbWU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHN0YW5kYXJkR2V0T3BhY2l0eSgpIHtcclxuICAgIC8qIGpzaGludCB2YWxpZHRoaXM6IHRydWUgKi9cclxuICAgIHJldHVybiB0aGlzLl9zb3VyY2Uub3BhY2l0eTtcclxufVxyXG5cclxuZnVuY3Rpb24gZHluYW1pY0xlYWZHZXRPcGFjaXR5KCkge1xyXG4gICAgLyoganNoaW50IHZhbGlkdGhpczogdHJ1ZSAqL1xyXG4gICAgcmV0dXJuIHRoaXMuX3NvdXJjZS5vcGFjaXR5O1xyXG59XHJcblxyXG5mdW5jdGlvbiBzdGFuZGFyZEdldExheWVyVHlwZSgpIHtcclxuICAgIC8qIGpzaGludCB2YWxpZHRoaXM6IHRydWUgKi9cclxuICAgIHJldHVybiB0aGlzLl9zb3VyY2UubGF5ZXJUeXBlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBkeW5hbWljTGVhZkdldExheWVyVHlwZSgpIHtcclxuICAgIC8qIGpzaGludCB2YWxpZHRoaXM6IHRydWUgKi9cclxuICAgIHJldHVybiB0aGlzLl9zb3VyY2UubGF5ZXJUeXBlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzdGFuZGFyZEdldEV4dGVudCgpIHtcclxuICAgIC8qIGpzaGludCB2YWxpZHRoaXM6IHRydWUgKi9cclxuICAgIHJldHVybiB0aGlzLl9zb3VyY2UuZXh0ZW50O1xyXG59XHJcblxyXG5mdW5jdGlvbiBkeW5hbWljTGVhZkdldEV4dGVudCgpIHtcclxuICAgIC8qIGpzaGludCB2YWxpZHRoaXM6IHRydWUgKi9cclxuICAgIHJldHVybiB0aGlzLl9zb3VyY2UuZXh0ZW50O1xyXG59XHJcblxyXG5mdW5jdGlvbiBzdGFuZGFyZEdldFF1ZXJ5KCkge1xyXG4gICAgLyoganNoaW50IHZhbGlkdGhpczogdHJ1ZSAqL1xyXG4gICAgcmV0dXJuIHRoaXMuX3NvdXJjZS5pc1F1ZXJ5YWJsZSgpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBkeW5hbWljTGVhZkdldFF1ZXJ5KCkge1xyXG4gICAgLyoganNoaW50IHZhbGlkdGhpczogdHJ1ZSAqL1xyXG4gICAgcmV0dXJuIHRoaXMuX3NvdXJjZS5xdWVyeWFibGU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHN0YW5kYXJkR2V0Rm9ybWF0dGVkQXR0cmlidXRlcygpIHtcclxuICAgIC8qIGpzaGludCB2YWxpZHRoaXM6IHRydWUgKi9cclxuXHJcbiAgICByZXR1cm4gdGhpcy5fc291cmNlLmdldEZvcm1hdHRlZEF0dHJpYnV0ZXMoKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZHluYW1pY0xlYWZHZXRGb3JtYXR0ZWRBdHRyaWJ1dGVzKCkge1xyXG4gICAgLyoganNoaW50IHZhbGlkdGhpczogdHJ1ZSAqL1xyXG5cclxuICAgIC8vIFRPRE8gY29kZS13aXNlIHRoaXMgbG9va3MgaWRlbnRpY2FsIHRvIHN0YW5kYXJkR2V0Rm9ybWF0dGVkQXR0cmlidXRlcy5cclxuICAgIC8vICAgICAgaG93ZXZlciBpbiB0aGlzIGNhc2UsIC5fc291cmNlIGlzIGEgRHluYW1pY0ZDLCBub3QgYSBMYXllclJlY29yZC5cclxuICAgIC8vICAgICAgVGhpcyBpcyBzYWZlci4gRGVsZXRpbmcgdGhpcyB3b3VsZCBhdm9pZCB0aGUgZHVwbGljYXRpb24uIERlY2lkZS5cclxuICAgIHJldHVybiB0aGlzLl9zb3VyY2UuZ2V0Rm9ybWF0dGVkQXR0cmlidXRlcygpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzdGFuZGFyZEdldFN5bWJvbG9neSgpIHtcclxuICAgIC8qIGpzaGludCB2YWxpZHRoaXM6IHRydWUgKi9cclxuICAgIHJldHVybiB0aGlzLl9zb3VyY2Uuc3ltYm9sb2d5O1xyXG59XHJcblxyXG5mdW5jdGlvbiBkeW5hbWljTGVhZkdldFN5bWJvbG9neSgpIHtcclxuICAgIC8qIGpzaGludCB2YWxpZHRoaXM6IHRydWUgKi9cclxuXHJcbiAgICAvLyBUT0RPIGNvZGUtd2lzZSB0aGlzIGxvb2tzIGlkZW50aWNhbCB0byBzdGFuZGFyZEdldFN5bWJvbG9neS5cclxuICAgIC8vICAgICAgaG93ZXZlciBpbiB0aGlzIGNhc2UsIC5fc291cmNlIGlzIGEgRHluYW1pY0ZDLCBub3QgYSBMYXllclJlY29yZC5cclxuICAgIC8vICAgICAgVGhpcyBpcyBzYWZlci4gRGVsZXRpbmcgdGhpcyB3b3VsZCBhdm9pZCB0aGUgZHVwbGljYXRpb24uIERlY2lkZS5cclxuICAgIHJldHVybiB0aGlzLl9zb3VyY2Uuc3ltYm9sb2d5O1xyXG59XHJcblxyXG5mdW5jdGlvbiBzdGFuZGFyZEdldEdlb21ldHJ5VHlwZSgpIHtcclxuICAgIC8qIGpzaGludCB2YWxpZHRoaXM6IHRydWUgKi9cclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZlYXR1cmVHZXRHZW9tZXRyeVR5cGUoKSB7XHJcbiAgICAvKiBqc2hpbnQgdmFsaWR0aGlzOiB0cnVlICovXHJcbiAgICByZXR1cm4gdGhpcy5fc291cmNlLmdldEdlb21UeXBlKCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGR5bmFtaWNMZWFmR2V0R2VvbWV0cnlUeXBlKCkge1xyXG4gICAgLyoganNoaW50IHZhbGlkdGhpczogdHJ1ZSAqL1xyXG5cclxuICAgIC8vIFRFU1QgU1RBVFVTIG5vbmVcclxuICAgIHJldHVybiB0aGlzLl9zb3VyY2UuZ2VvbVR5cGU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHN0YW5kYXJkR2V0RmVhdHVyZUNvdW50KCkge1xyXG4gICAgLyoganNoaW50IHZhbGlkdGhpczogdHJ1ZSAqL1xyXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcclxufVxyXG5cclxuZnVuY3Rpb24gZmVhdHVyZUdldEZlYXR1cmVDb3VudCgpIHtcclxuICAgIC8qIGpzaGludCB2YWxpZHRoaXM6IHRydWUgKi9cclxuICAgIHJldHVybiB0aGlzLl9zb3VyY2UuZmVhdHVyZUNvdW50O1xyXG59XHJcblxyXG5mdW5jdGlvbiBkeW5hbWljTGVhZkdldEZlYXR1cmVDb3VudCgpIHtcclxuICAgIC8qIGpzaGludCB2YWxpZHRoaXM6IHRydWUgKi9cclxuICAgIHJldHVybiB0aGlzLl9zb3VyY2UuZmVhdHVyZUNvdW50O1xyXG59XHJcblxyXG5mdW5jdGlvbiBzdGFuZGFyZFNldFZpc2liaWxpdHkodmFsdWUpIHtcclxuICAgIC8qIGpzaGludCB2YWxpZHRoaXM6IHRydWUgKi9cclxuICAgIHRoaXMuX3NvdXJjZS52aXNpYmlsaXR5ID0gdmFsdWU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGR5bmFtaWNMZWFmU2V0VmlzaWJpbGl0eSh2YWx1ZSkge1xyXG4gICAgLyoganNoaW50IHZhbGlkdGhpczogdHJ1ZSAqL1xyXG4gICAgdGhpcy5fc291cmNlLnNldFZpc2liaWxpdHkodmFsdWUpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBzdGFuZGFyZFNldE9wYWNpdHkodmFsdWUpIHtcclxuICAgIC8qIGpzaGludCB2YWxpZHRoaXM6IHRydWUgKi9cclxuICAgIHRoaXMuX3NvdXJjZS5vcGFjaXR5ID0gdmFsdWU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGR5bmFtaWNMZWFmU2V0T3BhY2l0eSh2YWx1ZSkge1xyXG4gICAgLyoganNoaW50IHZhbGlkdGhpczogdHJ1ZSAqL1xyXG4gICAgdGhpcy5fc291cmNlLm9wYWNpdHkgPSB2YWx1ZTtcclxufVxyXG5cclxuZnVuY3Rpb24gc3RhbmRhcmRTZXRRdWVyeSh2YWx1ZSkge1xyXG4gICAgLyoganNoaW50IHZhbGlkdGhpczogdHJ1ZSAqL1xyXG4gICAgdGhpcy5fc291cmNlLnNldFF1ZXJ5YWJsZSh2YWx1ZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGR5bmFtaWNMZWFmU2V0UXVlcnkodmFsdWUpIHtcclxuICAgIC8qIGpzaGludCB2YWxpZHRoaXM6IHRydWUgKi9cclxuICAgIHRoaXMuX3NvdXJjZS5xdWVyeWFibGUgPSB2YWx1ZTtcclxufVxyXG5cclxuZnVuY3Rpb24gZmVhdHVyZUdldFNuYXBzaG90KCkge1xyXG4gICAgLyoganNoaW50IHZhbGlkdGhpczogdHJ1ZSAqL1xyXG4gICAgcmV0dXJuIHRoaXMuX3NvdXJjZS5pc1NuYXBzaG90O1xyXG59XHJcblxyXG5mdW5jdGlvbiBmZWF0dXJlR2V0SGlnaGxpZ2h0RmVhdHVyZSgpIHtcclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBkeW5hbWljTGVhZkdldEhpZ2hsaWdodEZlYXR1cmUoKSB7XHJcbiAgICAvKiBqc2hpbnQgdmFsaWR0aGlzOiB0cnVlICovXHJcbiAgICByZXR1cm4gdGhpcy5fc291cmNlLmhpZ2hsaWdodEZlYXR1cmU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHN0YW5kYXJkWm9vbVRvQm91bmRhcnkobWFwKSB7XHJcbiAgICAvKiBqc2hpbnQgdmFsaWR0aGlzOiB0cnVlICovXHJcbiAgICB0aGlzLl9zb3VyY2Uuem9vbVRvQm91bmRhcnkobWFwKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZHluYW1pY0xlYWZab29tVG9Cb3VuZGFyeShtYXApIHtcclxuICAgIC8qIGpzaGludCB2YWxpZHRoaXM6IHRydWUgKi9cclxuICAgIHRoaXMuX3NvdXJjZS56b29tVG9Cb3VuZGFyeShtYXApO1xyXG59XHJcblxyXG5mdW5jdGlvbiBmZWF0dXJlR2V0RmVhdHVyZU5hbWUob2JqSWQsIGF0dHJpYnMpIHtcclxuICAgIC8qIGpzaGludCB2YWxpZHRoaXM6IHRydWUgKi9cclxuICAgIHJldHVybiB0aGlzLl9zb3VyY2UuZ2V0RmVhdHVyZU5hbWUob2JqSWQsIGF0dHJpYnMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBmZWF0dXJlQXR0cmlidXRlc1RvRGV0YWlscyhhdHRyaWJzLCBmaWVsZHMpIHtcclxuICAgIC8qIGpzaGludCB2YWxpZHRoaXM6IHRydWUgKi9cclxuICAgIHJldHVybiB0aGlzLl9zb3VyY2UuYXR0cmlidXRlc1RvRGV0YWlscyhhdHRyaWJzLCBmaWVsZHMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBkeW5hbWljTGVhZkF0dHJpYnV0ZXNUb0RldGFpbHMoYXR0cmlicywgZmllbGRzKSB7XHJcbiAgICAvKiBqc2hpbnQgdmFsaWR0aGlzOiB0cnVlICovXHJcbiAgICByZXR1cm4gdGhpcy5fc291cmNlLl9wYXJlbnQuYXR0cmlidXRlc1RvRGV0YWlscyhhdHRyaWJzLCBmaWVsZHMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBmZWF0dXJlRmV0Y2hHcmFwaGljKG9pZCwgaWdub3JlTG9jYWwgPSBmYWxzZSkge1xyXG4gICAgLyoganNoaW50IHZhbGlkdGhpczogdHJ1ZSAqL1xyXG4gICAgcmV0dXJuIHRoaXMuX3NvdXJjZS5mZXRjaEdyYXBoaWMob2lkLCBpZ25vcmVMb2NhbCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGR5bmFtaWNMZWFmRmV0Y2hHcmFwaGljKG9pZCwgaWdub3JlTG9jYWwgPSBmYWxzZSkge1xyXG4gICAgLyoganNoaW50IHZhbGlkdGhpczogdHJ1ZSAqL1xyXG4gICAgcmV0dXJuIHRoaXMuX3NvdXJjZS5mZXRjaEdyYXBoaWMob2lkLCBpZ25vcmVMb2NhbCk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gKCkgPT4gKHtcclxuICAgIExheWVySW50ZXJmYWNlXHJcbn0pO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbGF5ZXIvbGF5ZXJSZWMvbGF5ZXJJbnRlcmZhY2UuanMiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){"use strict";eval('\n// private property\nvar _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";\n\n\n// public method for encoding\nexports.encode = function(input, utf8) {\n    var output = "";\n    var chr1, chr2, chr3, enc1, enc2, enc3, enc4;\n    var i = 0;\n\n    while (i < input.length) {\n\n        chr1 = input.charCodeAt(i++);\n        chr2 = input.charCodeAt(i++);\n        chr3 = input.charCodeAt(i++);\n\n        enc1 = chr1 >> 2;\n        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\n        enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\n        enc4 = chr3 & 63;\n\n        if (isNaN(chr2)) {\n            enc3 = enc4 = 64;\n        }\n        else if (isNaN(chr3)) {\n            enc4 = 64;\n        }\n\n        output = output + _keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4);\n\n    }\n\n    return output;\n};\n\n// public method for decoding\nexports.decode = function(input, utf8) {\n    var output = "";\n    var chr1, chr2, chr3;\n    var enc1, enc2, enc3, enc4;\n    var i = 0;\n\n    input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, "");\n\n    while (i < input.length) {\n\n        enc1 = _keyStr.indexOf(input.charAt(i++));\n        enc2 = _keyStr.indexOf(input.charAt(i++));\n        enc3 = _keyStr.indexOf(input.charAt(i++));\n        enc4 = _keyStr.indexOf(input.charAt(i++));\n\n        chr1 = (enc1 << 2) | (enc2 >> 4);\n        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);\n        chr3 = ((enc3 & 3) << 6) | enc4;\n\n        output = output + String.fromCharCode(chr1);\n\n        if (enc3 != 64) {\n            output = output + String.fromCharCode(chr2);\n        }\n        if (enc4 != 64) {\n            output = output + String.fromCharCode(chr3);\n        }\n\n    }\n\n    return output;\n\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2pzemlwL2xpYi9iYXNlNjQuanM/NjJjNCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBIiwiZmlsZSI6IjI1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLy8gcHJpdmF0ZSBwcm9wZXJ0eVxudmFyIF9rZXlTdHIgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XCI7XG5cblxuLy8gcHVibGljIG1ldGhvZCBmb3IgZW5jb2RpbmdcbmV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24oaW5wdXQsIHV0ZjgpIHtcbiAgICB2YXIgb3V0cHV0ID0gXCJcIjtcbiAgICB2YXIgY2hyMSwgY2hyMiwgY2hyMywgZW5jMSwgZW5jMiwgZW5jMywgZW5jNDtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICB3aGlsZSAoaSA8IGlucHV0Lmxlbmd0aCkge1xuXG4gICAgICAgIGNocjEgPSBpbnB1dC5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICAgIGNocjIgPSBpbnB1dC5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICAgIGNocjMgPSBpbnB1dC5jaGFyQ29kZUF0KGkrKyk7XG5cbiAgICAgICAgZW5jMSA9IGNocjEgPj4gMjtcbiAgICAgICAgZW5jMiA9ICgoY2hyMSAmIDMpIDw8IDQpIHwgKGNocjIgPj4gNCk7XG4gICAgICAgIGVuYzMgPSAoKGNocjIgJiAxNSkgPDwgMikgfCAoY2hyMyA+PiA2KTtcbiAgICAgICAgZW5jNCA9IGNocjMgJiA2MztcblxuICAgICAgICBpZiAoaXNOYU4oY2hyMikpIHtcbiAgICAgICAgICAgIGVuYzMgPSBlbmM0ID0gNjQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNOYU4oY2hyMykpIHtcbiAgICAgICAgICAgIGVuYzQgPSA2NDtcbiAgICAgICAgfVxuXG4gICAgICAgIG91dHB1dCA9IG91dHB1dCArIF9rZXlTdHIuY2hhckF0KGVuYzEpICsgX2tleVN0ci5jaGFyQXQoZW5jMikgKyBfa2V5U3RyLmNoYXJBdChlbmMzKSArIF9rZXlTdHIuY2hhckF0KGVuYzQpO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIG91dHB1dDtcbn07XG5cbi8vIHB1YmxpYyBtZXRob2QgZm9yIGRlY29kaW5nXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uKGlucHV0LCB1dGY4KSB7XG4gICAgdmFyIG91dHB1dCA9IFwiXCI7XG4gICAgdmFyIGNocjEsIGNocjIsIGNocjM7XG4gICAgdmFyIGVuYzEsIGVuYzIsIGVuYzMsIGVuYzQ7XG4gICAgdmFyIGkgPSAwO1xuXG4gICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC9bXkEtWmEtejAtOVxcK1xcL1xcPV0vZywgXCJcIik7XG5cbiAgICB3aGlsZSAoaSA8IGlucHV0Lmxlbmd0aCkge1xuXG4gICAgICAgIGVuYzEgPSBfa2V5U3RyLmluZGV4T2YoaW5wdXQuY2hhckF0KGkrKykpO1xuICAgICAgICBlbmMyID0gX2tleVN0ci5pbmRleE9mKGlucHV0LmNoYXJBdChpKyspKTtcbiAgICAgICAgZW5jMyA9IF9rZXlTdHIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaSsrKSk7XG4gICAgICAgIGVuYzQgPSBfa2V5U3RyLmluZGV4T2YoaW5wdXQuY2hhckF0KGkrKykpO1xuXG4gICAgICAgIGNocjEgPSAoZW5jMSA8PCAyKSB8IChlbmMyID4+IDQpO1xuICAgICAgICBjaHIyID0gKChlbmMyICYgMTUpIDw8IDQpIHwgKGVuYzMgPj4gMik7XG4gICAgICAgIGNocjMgPSAoKGVuYzMgJiAzKSA8PCA2KSB8IGVuYzQ7XG5cbiAgICAgICAgb3V0cHV0ID0gb3V0cHV0ICsgU3RyaW5nLmZyb21DaGFyQ29kZShjaHIxKTtcblxuICAgICAgICBpZiAoZW5jMyAhPSA2NCkge1xuICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0ICsgU3RyaW5nLmZyb21DaGFyQ29kZShjaHIyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5jNCAhPSA2NCkge1xuICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0ICsgU3RyaW5nLmZyb21DaGFyQ29kZShjaHIzKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIG91dHB1dDtcblxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9qc3ppcC9saWIvYmFzZTY0LmpzXG4vLyBtb2R1bGUgaWQgPSAyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9')},function(module,exports,__webpack_require__){"use strict";eval('\nexports.STORE = {\n    magic: "\\x00\\x00",\n    compress: function(content, compressionOptions) {\n        return content; // no compression\n    },\n    uncompress: function(content) {\n        return content; // no compression\n    },\n    compressInputType: null,\n    uncompressInputType: null\n};\nexports.DEFLATE = __webpack_require__(98);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2pzemlwL2xpYi9jb21wcmVzc2lvbnMuanM/NjdjNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixLQUFLO0FBQ0w7QUFDQSx1QkFBdUI7QUFDdkIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjI2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuZXhwb3J0cy5TVE9SRSA9IHtcbiAgICBtYWdpYzogXCJcXHgwMFxceDAwXCIsXG4gICAgY29tcHJlc3M6IGZ1bmN0aW9uKGNvbnRlbnQsIGNvbXByZXNzaW9uT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gY29udGVudDsgLy8gbm8gY29tcHJlc3Npb25cbiAgICB9LFxuICAgIHVuY29tcHJlc3M6IGZ1bmN0aW9uKGNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7IC8vIG5vIGNvbXByZXNzaW9uXG4gICAgfSxcbiAgICBjb21wcmVzc0lucHV0VHlwZTogbnVsbCxcbiAgICB1bmNvbXByZXNzSW5wdXRUeXBlOiBudWxsXG59O1xuZXhwb3J0cy5ERUZMQVRFID0gcmVxdWlyZSgnLi9mbGF0ZScpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2pzemlwL2xpYi9jb21wcmVzc2lvbnMuanNcbi8vIG1vZHVsZSBpZCA9IDI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,exports,__webpack_require__){"use strict";eval("\nmodule.exports = function(data, encoding){\n    return new Buffer(data, encoding);\n};\nmodule.exports.test = function(b){\n    return Buffer.isBuffer(b);\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2pzemlwL2xpYi9ub2RlQnVmZmVyLmpzPzBjZmQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMjcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGRhdGEsIGVuY29kaW5nKXtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihkYXRhLCBlbmNvZGluZyk7XG59O1xubW9kdWxlLmV4cG9ydHMudGVzdCA9IGZ1bmN0aW9uKGIpe1xuICAgIHJldHVybiBCdWZmZXIuaXNCdWZmZXIoYik7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2pzemlwL2xpYi9ub2RlQnVmZmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){"use strict";eval('\nvar support = __webpack_require__(6);\nvar utils = __webpack_require__(1);\nvar crc32 = __webpack_require__(96);\nvar signature = __webpack_require__(45);\nvar defaults = __webpack_require__(44);\nvar base64 = __webpack_require__(25);\nvar compressions = __webpack_require__(26);\nvar CompressedObject = __webpack_require__(42);\nvar nodeBuffer = __webpack_require__(27);\nvar utf8 = __webpack_require__(48);\nvar StringWriter = __webpack_require__(102);\nvar Uint8ArrayWriter = __webpack_require__(103);\n\n/**\n * Returns the raw data of a ZipObject, decompress the content if necessary.\n * @param {ZipObject} file the file to use.\n * @return {String|ArrayBuffer|Uint8Array|Buffer} the data.\n */\nvar getRawData = function(file) {\n    if (file._data instanceof CompressedObject) {\n        file._data = file._data.getContent();\n        file.options.binary = true;\n        file.options.base64 = false;\n\n        if (utils.getTypeOf(file._data) === "uint8array") {\n            var copy = file._data;\n            // when reading an arraybuffer, the CompressedObject mechanism will keep it and subarray() a Uint8Array.\n            // if we request a file in the same format, we might get the same Uint8Array or its ArrayBuffer (the original zip file).\n            file._data = new Uint8Array(copy.length);\n            // with an empty Uint8Array, Opera fails with a "Offset larger than array size"\n            if (copy.length !== 0) {\n                file._data.set(copy, 0);\n            }\n        }\n    }\n    return file._data;\n};\n\n/**\n * Returns the data of a ZipObject in a binary form. If the content is an unicode string, encode it.\n * @param {ZipObject} file the file to use.\n * @return {String|ArrayBuffer|Uint8Array|Buffer} the data.\n */\nvar getBinaryData = function(file) {\n    var result = getRawData(file),\n        type = utils.getTypeOf(result);\n    if (type === "string") {\n        if (!file.options.binary) {\n            // unicode text !\n            // unicode string => binary string is a painful process, check if we can avoid it.\n            if (support.nodebuffer) {\n                return nodeBuffer(result, "utf-8");\n            }\n        }\n        return file.asBinary();\n    }\n    return result;\n};\n\n/**\n * Transform this._data into a string.\n * @param {function} filter a function String -> String, applied if not null on the result.\n * @return {String} the string representing this._data.\n */\nvar dataToString = function(asUTF8) {\n    var result = getRawData(this);\n    if (result === null || typeof result === "undefined") {\n        return "";\n    }\n    // if the data is a base64 string, we decode it before checking the encoding !\n    if (this.options.base64) {\n        result = base64.decode(result);\n    }\n    if (asUTF8 && this.options.binary) {\n        // JSZip.prototype.utf8decode supports arrays as input\n        // skip to array => string step, utf8decode will do it.\n        result = out.utf8decode(result);\n    }\n    else {\n        // no utf8 transformation, do the array => string step.\n        result = utils.transformTo("string", result);\n    }\n\n    if (!asUTF8 && !this.options.binary) {\n        result = utils.transformTo("string", out.utf8encode(result));\n    }\n    return result;\n};\n/**\n * A simple object representing a file in the zip file.\n * @constructor\n * @param {string} name the name of the file\n * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data\n * @param {Object} options the options of the file\n */\nvar ZipObject = function(name, data, options) {\n    this.name = name;\n    this.dir = options.dir;\n    this.date = options.date;\n    this.comment = options.comment;\n    this.unixPermissions = options.unixPermissions;\n    this.dosPermissions = options.dosPermissions;\n\n    this._data = data;\n    this.options = options;\n\n    /*\n     * This object contains initial values for dir and date.\n     * With them, we can check if the user changed the deprecated metadata in\n     * `ZipObject#options` or not.\n     */\n    this._initialMetadata = {\n      dir : options.dir,\n      date : options.date\n    };\n};\n\nZipObject.prototype = {\n    /**\n     * Return the content as UTF8 string.\n     * @return {string} the UTF8 string.\n     */\n    asText: function() {\n        return dataToString.call(this, true);\n    },\n    /**\n     * Returns the binary content.\n     * @return {string} the content as binary.\n     */\n    asBinary: function() {\n        return dataToString.call(this, false);\n    },\n    /**\n     * Returns the content as a nodejs Buffer.\n     * @return {Buffer} the content as a Buffer.\n     */\n    asNodeBuffer: function() {\n        var result = getBinaryData(this);\n        return utils.transformTo("nodebuffer", result);\n    },\n    /**\n     * Returns the content as an Uint8Array.\n     * @return {Uint8Array} the content as an Uint8Array.\n     */\n    asUint8Array: function() {\n        var result = getBinaryData(this);\n        return utils.transformTo("uint8array", result);\n    },\n    /**\n     * Returns the content as an ArrayBuffer.\n     * @return {ArrayBuffer} the content as an ArrayBufer.\n     */\n    asArrayBuffer: function() {\n        return this.asUint8Array().buffer;\n    }\n};\n\n/**\n * Transform an integer into a string in hexadecimal.\n * @private\n * @param {number} dec the number to convert.\n * @param {number} bytes the number of bytes to generate.\n * @returns {string} the result.\n */\nvar decToHex = function(dec, bytes) {\n    var hex = "",\n        i;\n    for (i = 0; i < bytes; i++) {\n        hex += String.fromCharCode(dec & 0xff);\n        dec = dec >>> 8;\n    }\n    return hex;\n};\n\n/**\n * Transforms the (incomplete) options from the user into the complete\n * set of options to create a file.\n * @private\n * @param {Object} o the options from the user.\n * @return {Object} the complete set of options.\n */\nvar prepareFileAttrs = function(o) {\n    o = o || {};\n    if (o.base64 === true && (o.binary === null || o.binary === undefined)) {\n        o.binary = true;\n    }\n    o = utils.extend(o, defaults);\n    o.date = o.date || new Date();\n    if (o.compression !== null) o.compression = o.compression.toUpperCase();\n\n    return o;\n};\n\n/**\n * Add a file in the current folder.\n * @private\n * @param {string} name the name of the file\n * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data of the file\n * @param {Object} o the options of the file\n * @return {Object} the new file.\n */\nvar fileAdd = function(name, data, o) {\n    // be sure sub folders exist\n    var dataType = utils.getTypeOf(data),\n        parent;\n\n    o = prepareFileAttrs(o);\n\n    if (typeof o.unixPermissions === "string") {\n        o.unixPermissions = parseInt(o.unixPermissions, 8);\n    }\n\n    // UNX_IFDIR  0040000 see zipinfo.c\n    if (o.unixPermissions && (o.unixPermissions & 0x4000)) {\n        o.dir = true;\n    }\n    // Bit 4    Directory\n    if (o.dosPermissions && (o.dosPermissions & 0x0010)) {\n        o.dir = true;\n    }\n\n    if (o.dir) {\n        name = forceTrailingSlash(name);\n    }\n\n    if (o.createFolders && (parent = parentFolder(name))) {\n        folderAdd.call(this, parent, true);\n    }\n\n    if (o.dir || data === null || typeof data === "undefined") {\n        o.base64 = false;\n        o.binary = false;\n        data = null;\n        dataType = null;\n    }\n    else if (dataType === "string") {\n        if (o.binary && !o.base64) {\n            // optimizedBinaryString == true means that the file has already been filtered with a 0xFF mask\n            if (o.optimizedBinaryString !== true) {\n                // this is a string, not in a base64 format.\n                // Be sure that this is a correct "binary string"\n                data = utils.string2binary(data);\n            }\n        }\n    }\n    else { // arraybuffer, uint8array, ...\n        o.base64 = false;\n        o.binary = true;\n\n        if (!dataType && !(data instanceof CompressedObject)) {\n            throw new Error("The data of \'" + name + "\' is in an unsupported format !");\n        }\n\n        // special case : it\'s way easier to work with Uint8Array than with ArrayBuffer\n        if (dataType === "arraybuffer") {\n            data = utils.transformTo("uint8array", data);\n        }\n    }\n\n    var object = new ZipObject(name, data, o);\n    this.files[name] = object;\n    return object;\n};\n\n/**\n * Find the parent folder of the path.\n * @private\n * @param {string} path the path to use\n * @return {string} the parent folder, or ""\n */\nvar parentFolder = function (path) {\n    if (path.slice(-1) == \'/\') {\n        path = path.substring(0, path.length - 1);\n    }\n    var lastSlash = path.lastIndexOf(\'/\');\n    return (lastSlash > 0) ? path.substring(0, lastSlash) : "";\n};\n\n\n/**\n * Returns the path with a slash at the end.\n * @private\n * @param {String} path the path to check.\n * @return {String} the path with a trailing slash.\n */\nvar forceTrailingSlash = function(path) {\n    // Check the name ends with a /\n    if (path.slice(-1) != "/") {\n        path += "/"; // IE doesn\'t like substr(-1)\n    }\n    return path;\n};\n/**\n * Add a (sub) folder in the current folder.\n * @private\n * @param {string} name the folder\'s name\n * @param {boolean=} [createFolders] If true, automatically create sub\n *  folders. Defaults to false.\n * @return {Object} the new folder.\n */\nvar folderAdd = function(name, createFolders) {\n    createFolders = (typeof createFolders !== \'undefined\') ? createFolders : false;\n\n    name = forceTrailingSlash(name);\n\n    // Does this folder already exist?\n    if (!this.files[name]) {\n        fileAdd.call(this, name, null, {\n            dir: true,\n            createFolders: createFolders\n        });\n    }\n    return this.files[name];\n};\n\n/**\n * Generate a JSZip.CompressedObject for a given zipOject.\n * @param {ZipObject} file the object to read.\n * @param {JSZip.compression} compression the compression to use.\n * @param {Object} compressionOptions the options to use when compressing.\n * @return {JSZip.CompressedObject} the compressed result.\n */\nvar generateCompressedObjectFrom = function(file, compression, compressionOptions) {\n    var result = new CompressedObject(),\n        content;\n\n    // the data has not been decompressed, we might reuse things !\n    if (file._data instanceof CompressedObject) {\n        result.uncompressedSize = file._data.uncompressedSize;\n        result.crc32 = file._data.crc32;\n\n        if (result.uncompressedSize === 0 || file.dir) {\n            compression = compressions[\'STORE\'];\n            result.compressedContent = "";\n            result.crc32 = 0;\n        }\n        else if (file._data.compressionMethod === compression.magic) {\n            result.compressedContent = file._data.getCompressedContent();\n        }\n        else {\n            content = file._data.getContent();\n            // need to decompress / recompress\n            result.compressedContent = compression.compress(utils.transformTo(compression.compressInputType, content), compressionOptions);\n        }\n    }\n    else {\n        // have uncompressed data\n        content = getBinaryData(file);\n        if (!content || content.length === 0 || file.dir) {\n            compression = compressions[\'STORE\'];\n            content = "";\n        }\n        result.uncompressedSize = content.length;\n        result.crc32 = crc32(content);\n        result.compressedContent = compression.compress(utils.transformTo(compression.compressInputType, content), compressionOptions);\n    }\n\n    result.compressedSize = result.compressedContent.length;\n    result.compressionMethod = compression.magic;\n\n    return result;\n};\n\n\n\n\n/**\n * Generate the UNIX part of the external file attributes.\n * @param {Object} unixPermissions the unix permissions or null.\n * @param {Boolean} isDir true if the entry is a directory, false otherwise.\n * @return {Number} a 32 bit integer.\n *\n * adapted from http://unix.stackexchange.com/questions/14705/the-zip-formats-external-file-attribute :\n *\n * TTTTsstrwxrwxrwx0000000000ADVSHR\n * ^^^^____________________________ file type, see zipinfo.c (UNX_*)\n *     ^^^_________________________ setuid, setgid, sticky\n *        ^^^^^^^^^________________ permissions\n *                 ^^^^^^^^^^______ not used ?\n *                           ^^^^^^ DOS attribute bits : Archive, Directory, Volume label, System file, Hidden, Read only\n */\nvar generateUnixExternalFileAttr = function (unixPermissions, isDir) {\n\n    var result = unixPermissions;\n    if (!unixPermissions) {\n        // I can\'t use octal values in strict mode, hence the hexa.\n        //  040775 => 0x41fd\n        // 0100664 => 0x81b4\n        result = isDir ? 0x41fd : 0x81b4;\n    }\n\n    return (result & 0xFFFF) << 16;\n};\n\n/**\n * Generate the DOS part of the external file attributes.\n * @param {Object} dosPermissions the dos permissions or null.\n * @param {Boolean} isDir true if the entry is a directory, false otherwise.\n * @return {Number} a 32 bit integer.\n *\n * Bit 0     Read-Only\n * Bit 1     Hidden\n * Bit 2     System\n * Bit 3     Volume Label\n * Bit 4     Directory\n * Bit 5     Archive\n */\nvar generateDosExternalFileAttr = function (dosPermissions, isDir) {\n\n    // the dir flag is already set for compatibility\n\n    return (dosPermissions || 0)  & 0x3F;\n};\n\n/**\n * Generate the various parts used in the construction of the final zip file.\n * @param {string} name the file name.\n * @param {ZipObject} file the file content.\n * @param {JSZip.CompressedObject} compressedObject the compressed object.\n * @param {number} offset the current offset from the start of the zip file.\n * @param {String} platform let\'s pretend we are this platform (change platform dependents fields)\n * @param {Function} encodeFileName the function to encode the file name / comment.\n * @return {object} the zip parts.\n */\nvar generateZipParts = function(name, file, compressedObject, offset, platform, encodeFileName) {\n    var data = compressedObject.compressedContent,\n        useCustomEncoding = encodeFileName !== utf8.utf8encode,\n        encodedFileName = utils.transformTo("string", encodeFileName(file.name)),\n        utfEncodedFileName = utils.transformTo("string", utf8.utf8encode(file.name)),\n        comment = file.comment || "",\n        encodedComment = utils.transformTo("string", encodeFileName(comment)),\n        utfEncodedComment = utils.transformTo("string", utf8.utf8encode(comment)),\n        useUTF8ForFileName = utfEncodedFileName.length !== file.name.length,\n        useUTF8ForComment = utfEncodedComment.length !== comment.length,\n        o = file.options,\n        dosTime,\n        dosDate,\n        extraFields = "",\n        unicodePathExtraField = "",\n        unicodeCommentExtraField = "",\n        dir, date;\n\n\n    // handle the deprecated options.dir\n    if (file._initialMetadata.dir !== file.dir) {\n        dir = file.dir;\n    } else {\n        dir = o.dir;\n    }\n\n    // handle the deprecated options.date\n    if(file._initialMetadata.date !== file.date) {\n        date = file.date;\n    } else {\n        date = o.date;\n    }\n\n    var extFileAttr = 0;\n    var versionMadeBy = 0;\n    if (dir) {\n        // dos or unix, we set the dos dir flag\n        extFileAttr |= 0x00010;\n    }\n    if(platform === "UNIX") {\n        versionMadeBy = 0x031E; // UNIX, version 3.0\n        extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir);\n    } else { // DOS or other, fallback to DOS\n        versionMadeBy = 0x0014; // DOS, version 2.0\n        extFileAttr |= generateDosExternalFileAttr(file.dosPermissions, dir);\n    }\n\n    // date\n    // @see http://www.delorie.com/djgpp/doc/rbinter/it/52/13.html\n    // @see http://www.delorie.com/djgpp/doc/rbinter/it/65/16.html\n    // @see http://www.delorie.com/djgpp/doc/rbinter/it/66/16.html\n\n    dosTime = date.getHours();\n    dosTime = dosTime << 6;\n    dosTime = dosTime | date.getMinutes();\n    dosTime = dosTime << 5;\n    dosTime = dosTime | date.getSeconds() / 2;\n\n    dosDate = date.getFullYear() - 1980;\n    dosDate = dosDate << 4;\n    dosDate = dosDate | (date.getMonth() + 1);\n    dosDate = dosDate << 5;\n    dosDate = dosDate | date.getDate();\n\n    if (useUTF8ForFileName) {\n        // set the unicode path extra field. unzip needs at least one extra\n        // field to correctly handle unicode path, so using the path is as good\n        // as any other information. This could improve the situation with\n        // other archive managers too.\n        // This field is usually used without the utf8 flag, with a non\n        // unicode path in the header (winrar, winzip). This helps (a bit)\n        // with the messy Windows\' default compressed folders feature but\n        // breaks on p7zip which doesn\'t seek the unicode path extra field.\n        // So for now, UTF-8 everywhere !\n        unicodePathExtraField =\n            // Version\n            decToHex(1, 1) +\n            // NameCRC32\n            decToHex(crc32(encodedFileName), 4) +\n            // UnicodeName\n            utfEncodedFileName;\n\n        extraFields +=\n            // Info-ZIP Unicode Path Extra Field\n            "\\x75\\x70" +\n            // size\n            decToHex(unicodePathExtraField.length, 2) +\n            // content\n            unicodePathExtraField;\n    }\n\n    if(useUTF8ForComment) {\n\n        unicodeCommentExtraField =\n            // Version\n            decToHex(1, 1) +\n            // CommentCRC32\n            decToHex(this.crc32(encodedComment), 4) +\n            // UnicodeName\n            utfEncodedComment;\n\n        extraFields +=\n            // Info-ZIP Unicode Path Extra Field\n            "\\x75\\x63" +\n            // size\n            decToHex(unicodeCommentExtraField.length, 2) +\n            // content\n            unicodeCommentExtraField;\n    }\n\n    var header = "";\n\n    // version needed to extract\n    header += "\\x0A\\x00";\n    // general purpose bit flag\n    // set bit 11 if utf8\n    header += !useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment) ? "\\x00\\x08" : "\\x00\\x00";\n    // compression method\n    header += compressedObject.compressionMethod;\n    // last mod file time\n    header += decToHex(dosTime, 2);\n    // last mod file date\n    header += decToHex(dosDate, 2);\n    // crc-32\n    header += decToHex(compressedObject.crc32, 4);\n    // compressed size\n    header += decToHex(compressedObject.compressedSize, 4);\n    // uncompressed size\n    header += decToHex(compressedObject.uncompressedSize, 4);\n    // file name length\n    header += decToHex(encodedFileName.length, 2);\n    // extra field length\n    header += decToHex(extraFields.length, 2);\n\n\n    var fileRecord = signature.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;\n\n    var dirRecord = signature.CENTRAL_FILE_HEADER +\n    // version made by (00: DOS)\n    decToHex(versionMadeBy, 2) +\n    // file header (common to file and central directory)\n    header +\n    // file comment length\n    decToHex(encodedComment.length, 2) +\n    // disk number start\n    "\\x00\\x00" +\n    // internal file attributes TODO\n    "\\x00\\x00" +\n    // external file attributes\n    decToHex(extFileAttr, 4) +\n    // relative offset of local header\n    decToHex(offset, 4) +\n    // file name\n    encodedFileName +\n    // extra field\n    extraFields +\n    // file comment\n    encodedComment;\n\n    return {\n        fileRecord: fileRecord,\n        dirRecord: dirRecord,\n        compressedObject: compressedObject\n    };\n};\n\n\n// return the actual prototype of JSZip\nvar out = {\n    /**\n     * Read an existing zip and merge the data in the current JSZip object.\n     * The implementation is in jszip-load.js, don\'t forget to include it.\n     * @param {String|ArrayBuffer|Uint8Array|Buffer} stream  The stream to load\n     * @param {Object} options Options for loading the stream.\n     *  options.base64 : is the stream in base64 ? default : false\n     * @return {JSZip} the current JSZip object\n     */\n    load: function(stream, options) {\n        throw new Error("Load method is not defined. Is the file jszip-load.js included ?");\n    },\n\n    /**\n     * Filter nested files/folders with the specified function.\n     * @param {Function} search the predicate to use :\n     * function (relativePath, file) {...}\n     * It takes 2 arguments : the relative path and the file.\n     * @return {Array} An array of matching elements.\n     */\n    filter: function(search) {\n        var result = [],\n            filename, relativePath, file, fileClone;\n        for (filename in this.files) {\n            if (!this.files.hasOwnProperty(filename)) {\n                continue;\n            }\n            file = this.files[filename];\n            // return a new object, don\'t let the user mess with our internal objects :)\n            fileClone = new ZipObject(file.name, file._data, utils.extend(file.options));\n            relativePath = filename.slice(this.root.length, filename.length);\n            if (filename.slice(0, this.root.length) === this.root && // the file is in the current root\n            search(relativePath, fileClone)) { // and the file matches the function\n                result.push(fileClone);\n            }\n        }\n        return result;\n    },\n\n    /**\n     * Add a file to the zip file, or search a file.\n     * @param   {string|RegExp} name The name of the file to add (if data is defined),\n     * the name of the file to find (if no data) or a regex to match files.\n     * @param   {String|ArrayBuffer|Uint8Array|Buffer} data  The file data, either raw or base64 encoded\n     * @param   {Object} o     File options\n     * @return  {JSZip|Object|Array} this JSZip object (when adding a file),\n     * a file (when searching by string) or an array of files (when searching by regex).\n     */\n    file: function(name, data, o) {\n        if (arguments.length === 1) {\n            if (utils.isRegExp(name)) {\n                var regexp = name;\n                return this.filter(function(relativePath, file) {\n                    return !file.dir && regexp.test(relativePath);\n                });\n            }\n            else { // text\n                return this.filter(function(relativePath, file) {\n                    return !file.dir && relativePath === name;\n                })[0] || null;\n            }\n        }\n        else { // more than one argument : we have data !\n            name = this.root + name;\n            fileAdd.call(this, name, data, o);\n        }\n        return this;\n    },\n\n    /**\n     * Add a directory to the zip file, or search.\n     * @param   {String|RegExp} arg The name of the directory to add, or a regex to search folders.\n     * @return  {JSZip} an object with the new directory as the root, or an array containing matching folders.\n     */\n    folder: function(arg) {\n        if (!arg) {\n            return this;\n        }\n\n        if (utils.isRegExp(arg)) {\n            return this.filter(function(relativePath, file) {\n                return file.dir && arg.test(relativePath);\n            });\n        }\n\n        // else, name is a new folder\n        var name = this.root + arg;\n        var newFolder = folderAdd.call(this, name);\n\n        // Allow chaining by returning a new object with this folder as the root\n        var ret = this.clone();\n        ret.root = newFolder.name;\n        return ret;\n    },\n\n    /**\n     * Delete a file, or a directory and all sub-files, from the zip\n     * @param {string} name the name of the file to delete\n     * @return {JSZip} this JSZip object\n     */\n    remove: function(name) {\n        name = this.root + name;\n        var file = this.files[name];\n        if (!file) {\n            // Look for any folders\n            if (name.slice(-1) != "/") {\n                name += "/";\n            }\n            file = this.files[name];\n        }\n\n        if (file && !file.dir) {\n            // file\n            delete this.files[name];\n        } else {\n            // maybe a folder, delete recursively\n            var kids = this.filter(function(relativePath, file) {\n                return file.name.slice(0, name.length) === name;\n            });\n            for (var i = 0; i < kids.length; i++) {\n                delete this.files[kids[i].name];\n            }\n        }\n\n        return this;\n    },\n\n    /**\n     * Generate the complete zip file\n     * @param {Object} options the options to generate the zip file :\n     * - base64, (deprecated, use type instead) true to generate base64.\n     * - compression, "STORE" by default.\n     * - type, "base64" by default. Values are : string, base64, uint8array, arraybuffer, blob.\n     * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the zip file\n     */\n    generate: function(options) {\n        options = utils.extend(options || {}, {\n            base64: true,\n            compression: "STORE",\n            compressionOptions : null,\n            type: "base64",\n            platform: "DOS",\n            comment: null,\n            mimeType: \'application/zip\',\n            encodeFileName: utf8.utf8encode\n        });\n\n        utils.checkSupport(options.type);\n\n        // accept nodejs `process.platform`\n        if(\n          options.platform === \'darwin\' ||\n          options.platform === \'freebsd\' ||\n          options.platform === \'linux\' ||\n          options.platform === \'sunos\'\n        ) {\n          options.platform = "UNIX";\n        }\n        if (options.platform === \'win32\') {\n          options.platform = "DOS";\n        }\n\n        var zipData = [],\n            localDirLength = 0,\n            centralDirLength = 0,\n            writer, i,\n            encodedComment = utils.transformTo("string", options.encodeFileName(options.comment || this.comment || ""));\n\n        // first, generate all the zip parts.\n        for (var name in this.files) {\n            if (!this.files.hasOwnProperty(name)) {\n                continue;\n            }\n            var file = this.files[name];\n\n            var compressionName = file.options.compression || options.compression.toUpperCase();\n            var compression = compressions[compressionName];\n            if (!compression) {\n                throw new Error(compressionName + " is not a valid compression method !");\n            }\n            var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};\n\n            var compressedObject = generateCompressedObjectFrom.call(this, file, compression, compressionOptions);\n\n            var zipPart = generateZipParts.call(this, name, file, compressedObject, localDirLength, options.platform, options.encodeFileName);\n            localDirLength += zipPart.fileRecord.length + compressedObject.compressedSize;\n            centralDirLength += zipPart.dirRecord.length;\n            zipData.push(zipPart);\n        }\n\n        var dirEnd = "";\n\n        // end of central dir signature\n        dirEnd = signature.CENTRAL_DIRECTORY_END +\n        // number of this disk\n        "\\x00\\x00" +\n        // number of the disk with the start of the central directory\n        "\\x00\\x00" +\n        // total number of entries in the central directory on this disk\n        decToHex(zipData.length, 2) +\n        // total number of entries in the central directory\n        decToHex(zipData.length, 2) +\n        // size of the central directory   4 bytes\n        decToHex(centralDirLength, 4) +\n        // offset of start of central directory with respect to the starting disk number\n        decToHex(localDirLength, 4) +\n        // .ZIP file comment length\n        decToHex(encodedComment.length, 2) +\n        // .ZIP file comment\n        encodedComment;\n\n\n        // we have all the parts (and the total length)\n        // time to create a writer !\n        var typeName = options.type.toLowerCase();\n        if(typeName==="uint8array"||typeName==="arraybuffer"||typeName==="blob"||typeName==="nodebuffer") {\n            writer = new Uint8ArrayWriter(localDirLength + centralDirLength + dirEnd.length);\n        }else{\n            writer = new StringWriter(localDirLength + centralDirLength + dirEnd.length);\n        }\n\n        for (i = 0; i < zipData.length; i++) {\n            writer.append(zipData[i].fileRecord);\n            writer.append(zipData[i].compressedObject.compressedContent);\n        }\n        for (i = 0; i < zipData.length; i++) {\n            writer.append(zipData[i].dirRecord);\n        }\n\n        writer.append(dirEnd);\n\n        var zip = writer.finalize();\n\n\n\n        switch(options.type.toLowerCase()) {\n            // case "zip is an Uint8Array"\n            case "uint8array" :\n            case "arraybuffer" :\n            case "nodebuffer" :\n               return utils.transformTo(options.type.toLowerCase(), zip);\n            case "blob" :\n               return utils.arrayBuffer2Blob(utils.transformTo("arraybuffer", zip), options.mimeType);\n            // case "zip is a string"\n            case "base64" :\n               return (options.base64) ? base64.encode(zip) : zip;\n            default : // case "string" :\n               return zip;\n         }\n\n    },\n\n    /**\n     * @deprecated\n     * This method will be removed in a future version without replacement.\n     */\n    crc32: function (input, crc) {\n        return crc32(input, crc);\n    },\n\n    /**\n     * @deprecated\n     * This method will be removed in a future version without replacement.\n     */\n    utf8encode: function (string) {\n        return utils.transformTo("string", utf8.utf8encode(string));\n    },\n\n    /**\n     * @deprecated\n     * This method will be removed in a future version without replacement.\n     */\n    utf8decode: function (input) {\n        return utf8.utf8decode(input);\n    }\n};\nmodule.exports = out;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2pzemlwL2xpYi9vYmplY3QuanM/NjI5NyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFlBQVkscUNBQXFDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFlBQVkscUNBQXFDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxxQ0FBcUM7QUFDaEQsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFD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O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEsbUJBQW1CLG9CQUFvQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIyOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciBzdXBwb3J0ID0gcmVxdWlyZSgnLi9zdXBwb3J0Jyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgY3JjMzIgPSByZXF1aXJlKCcuL2NyYzMyJyk7XG52YXIgc2lnbmF0dXJlID0gcmVxdWlyZSgnLi9zaWduYXR1cmUnKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4vZGVmYXVsdHMnKTtcbnZhciBiYXNlNjQgPSByZXF1aXJlKCcuL2Jhc2U2NCcpO1xudmFyIGNvbXByZXNzaW9ucyA9IHJlcXVpcmUoJy4vY29tcHJlc3Npb25zJyk7XG52YXIgQ29tcHJlc3NlZE9iamVjdCA9IHJlcXVpcmUoJy4vY29tcHJlc3NlZE9iamVjdCcpO1xudmFyIG5vZGVCdWZmZXIgPSByZXF1aXJlKCcuL25vZGVCdWZmZXInKTtcbnZhciB1dGY4ID0gcmVxdWlyZSgnLi91dGY4Jyk7XG52YXIgU3RyaW5nV3JpdGVyID0gcmVxdWlyZSgnLi9zdHJpbmdXcml0ZXInKTtcbnZhciBVaW50OEFycmF5V3JpdGVyID0gcmVxdWlyZSgnLi91aW50OEFycmF5V3JpdGVyJyk7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcmF3IGRhdGEgb2YgYSBaaXBPYmplY3QsIGRlY29tcHJlc3MgdGhlIGNvbnRlbnQgaWYgbmVjZXNzYXJ5LlxuICogQHBhcmFtIHtaaXBPYmplY3R9IGZpbGUgdGhlIGZpbGUgdG8gdXNlLlxuICogQHJldHVybiB7U3RyaW5nfEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSB0aGUgZGF0YS5cbiAqL1xudmFyIGdldFJhd0RhdGEgPSBmdW5jdGlvbihmaWxlKSB7XG4gICAgaWYgKGZpbGUuX2RhdGEgaW5zdGFuY2VvZiBDb21wcmVzc2VkT2JqZWN0KSB7XG4gICAgICAgIGZpbGUuX2RhdGEgPSBmaWxlLl9kYXRhLmdldENvbnRlbnQoKTtcbiAgICAgICAgZmlsZS5vcHRpb25zLmJpbmFyeSA9IHRydWU7XG4gICAgICAgIGZpbGUub3B0aW9ucy5iYXNlNjQgPSBmYWxzZTtcblxuICAgICAgICBpZiAodXRpbHMuZ2V0VHlwZU9mKGZpbGUuX2RhdGEpID09PSBcInVpbnQ4YXJyYXlcIikge1xuICAgICAgICAgICAgdmFyIGNvcHkgPSBmaWxlLl9kYXRhO1xuICAgICAgICAgICAgLy8gd2hlbiByZWFkaW5nIGFuIGFycmF5YnVmZmVyLCB0aGUgQ29tcHJlc3NlZE9iamVjdCBtZWNoYW5pc20gd2lsbCBrZWVwIGl0IGFuZCBzdWJhcnJheSgpIGEgVWludDhBcnJheS5cbiAgICAgICAgICAgIC8vIGlmIHdlIHJlcXVlc3QgYSBmaWxlIGluIHRoZSBzYW1lIGZvcm1hdCwgd2UgbWlnaHQgZ2V0IHRoZSBzYW1lIFVpbnQ4QXJyYXkgb3IgaXRzIEFycmF5QnVmZmVyICh0aGUgb3JpZ2luYWwgemlwIGZpbGUpLlxuICAgICAgICAgICAgZmlsZS5fZGF0YSA9IG5ldyBVaW50OEFycmF5KGNvcHkubGVuZ3RoKTtcbiAgICAgICAgICAgIC8vIHdpdGggYW4gZW1wdHkgVWludDhBcnJheSwgT3BlcmEgZmFpbHMgd2l0aCBhIFwiT2Zmc2V0IGxhcmdlciB0aGFuIGFycmF5IHNpemVcIlxuICAgICAgICAgICAgaWYgKGNvcHkubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgZmlsZS5fZGF0YS5zZXQoY29weSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZpbGUuX2RhdGE7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGRhdGEgb2YgYSBaaXBPYmplY3QgaW4gYSBiaW5hcnkgZm9ybS4gSWYgdGhlIGNvbnRlbnQgaXMgYW4gdW5pY29kZSBzdHJpbmcsIGVuY29kZSBpdC5cbiAqIEBwYXJhbSB7WmlwT2JqZWN0fSBmaWxlIHRoZSBmaWxlIHRvIHVzZS5cbiAqIEByZXR1cm4ge1N0cmluZ3xBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gdGhlIGRhdGEuXG4gKi9cbnZhciBnZXRCaW5hcnlEYXRhID0gZnVuY3Rpb24oZmlsZSkge1xuICAgIHZhciByZXN1bHQgPSBnZXRSYXdEYXRhKGZpbGUpLFxuICAgICAgICB0eXBlID0gdXRpbHMuZ2V0VHlwZU9mKHJlc3VsdCk7XG4gICAgaWYgKHR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKCFmaWxlLm9wdGlvbnMuYmluYXJ5KSB7XG4gICAgICAgICAgICAvLyB1bmljb2RlIHRleHQgIVxuICAgICAgICAgICAgLy8gdW5pY29kZSBzdHJpbmcgPT4gYmluYXJ5IHN0cmluZyBpcyBhIHBhaW5mdWwgcHJvY2VzcywgY2hlY2sgaWYgd2UgY2FuIGF2b2lkIGl0LlxuICAgICAgICAgICAgaWYgKHN1cHBvcnQubm9kZWJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlQnVmZmVyKHJlc3VsdCwgXCJ1dGYtOFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmlsZS5hc0JpbmFyeSgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gdGhpcy5fZGF0YSBpbnRvIGEgc3RyaW5nLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gZmlsdGVyIGEgZnVuY3Rpb24gU3RyaW5nIC0+IFN0cmluZywgYXBwbGllZCBpZiBub3QgbnVsbCBvbiB0aGUgcmVzdWx0LlxuICogQHJldHVybiB7U3RyaW5nfSB0aGUgc3RyaW5nIHJlcHJlc2VudGluZyB0aGlzLl9kYXRhLlxuICovXG52YXIgZGF0YVRvU3RyaW5nID0gZnVuY3Rpb24oYXNVVEY4KSB7XG4gICAgdmFyIHJlc3VsdCA9IGdldFJhd0RhdGEodGhpcyk7XG4gICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCB0eXBlb2YgcmVzdWx0ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICAvLyBpZiB0aGUgZGF0YSBpcyBhIGJhc2U2NCBzdHJpbmcsIHdlIGRlY29kZSBpdCBiZWZvcmUgY2hlY2tpbmcgdGhlIGVuY29kaW5nICFcbiAgICBpZiAodGhpcy5vcHRpb25zLmJhc2U2NCkge1xuICAgICAgICByZXN1bHQgPSBiYXNlNjQuZGVjb2RlKHJlc3VsdCk7XG4gICAgfVxuICAgIGlmIChhc1VURjggJiYgdGhpcy5vcHRpb25zLmJpbmFyeSkge1xuICAgICAgICAvLyBKU1ppcC5wcm90b3R5cGUudXRmOGRlY29kZSBzdXBwb3J0cyBhcnJheXMgYXMgaW5wdXRcbiAgICAgICAgLy8gc2tpcCB0byBhcnJheSA9PiBzdHJpbmcgc3RlcCwgdXRmOGRlY29kZSB3aWxsIGRvIGl0LlxuICAgICAgICByZXN1bHQgPSBvdXQudXRmOGRlY29kZShyZXN1bHQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gbm8gdXRmOCB0cmFuc2Zvcm1hdGlvbiwgZG8gdGhlIGFycmF5ID0+IHN0cmluZyBzdGVwLlxuICAgICAgICByZXN1bHQgPSB1dGlscy50cmFuc2Zvcm1UbyhcInN0cmluZ1wiLCByZXN1bHQpO1xuICAgIH1cblxuICAgIGlmICghYXNVVEY4ICYmICF0aGlzLm9wdGlvbnMuYmluYXJ5KSB7XG4gICAgICAgIHJlc3VsdCA9IHV0aWxzLnRyYW5zZm9ybVRvKFwic3RyaW5nXCIsIG91dC51dGY4ZW5jb2RlKHJlc3VsdCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbi8qKlxuICogQSBzaW1wbGUgb2JqZWN0IHJlcHJlc2VudGluZyBhIGZpbGUgaW4gdGhlIHppcCBmaWxlLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgZmlsZVxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGRhdGEgdGhlIGRhdGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHRoZSBvcHRpb25zIG9mIHRoZSBmaWxlXG4gKi9cbnZhciBaaXBPYmplY3QgPSBmdW5jdGlvbihuYW1lLCBkYXRhLCBvcHRpb25zKSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmRpciA9IG9wdGlvbnMuZGlyO1xuICAgIHRoaXMuZGF0ZSA9IG9wdGlvbnMuZGF0ZTtcbiAgICB0aGlzLmNvbW1lbnQgPSBvcHRpb25zLmNvbW1lbnQ7XG4gICAgdGhpcy51bml4UGVybWlzc2lvbnMgPSBvcHRpb25zLnVuaXhQZXJtaXNzaW9ucztcbiAgICB0aGlzLmRvc1Blcm1pc3Npb25zID0gb3B0aW9ucy5kb3NQZXJtaXNzaW9ucztcblxuICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgICAvKlxuICAgICAqIFRoaXMgb2JqZWN0IGNvbnRhaW5zIGluaXRpYWwgdmFsdWVzIGZvciBkaXIgYW5kIGRhdGUuXG4gICAgICogV2l0aCB0aGVtLCB3ZSBjYW4gY2hlY2sgaWYgdGhlIHVzZXIgY2hhbmdlZCB0aGUgZGVwcmVjYXRlZCBtZXRhZGF0YSBpblxuICAgICAqIGBaaXBPYmplY3Qjb3B0aW9uc2Agb3Igbm90LlxuICAgICAqL1xuICAgIHRoaXMuX2luaXRpYWxNZXRhZGF0YSA9IHtcbiAgICAgIGRpciA6IG9wdGlvbnMuZGlyLFxuICAgICAgZGF0ZSA6IG9wdGlvbnMuZGF0ZVxuICAgIH07XG59O1xuXG5aaXBPYmplY3QucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgY29udGVudCBhcyBVVEY4IHN0cmluZy5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBVVEY4IHN0cmluZy5cbiAgICAgKi9cbiAgICBhc1RleHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZGF0YVRvU3RyaW5nLmNhbGwodGhpcywgdHJ1ZSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBiaW5hcnkgY29udGVudC5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBjb250ZW50IGFzIGJpbmFyeS5cbiAgICAgKi9cbiAgICBhc0JpbmFyeTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBkYXRhVG9TdHJpbmcuY2FsbCh0aGlzLCBmYWxzZSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb250ZW50IGFzIGEgbm9kZWpzIEJ1ZmZlci5cbiAgICAgKiBAcmV0dXJuIHtCdWZmZXJ9IHRoZSBjb250ZW50IGFzIGEgQnVmZmVyLlxuICAgICAqL1xuICAgIGFzTm9kZUJ1ZmZlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBnZXRCaW5hcnlEYXRhKHRoaXMpO1xuICAgICAgICByZXR1cm4gdXRpbHMudHJhbnNmb3JtVG8oXCJub2RlYnVmZmVyXCIsIHJlc3VsdCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb250ZW50IGFzIGFuIFVpbnQ4QXJyYXkuXG4gICAgICogQHJldHVybiB7VWludDhBcnJheX0gdGhlIGNvbnRlbnQgYXMgYW4gVWludDhBcnJheS5cbiAgICAgKi9cbiAgICBhc1VpbnQ4QXJyYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gZ2V0QmluYXJ5RGF0YSh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHV0aWxzLnRyYW5zZm9ybVRvKFwidWludDhhcnJheVwiLCByZXN1bHQpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29udGVudCBhcyBhbiBBcnJheUJ1ZmZlci5cbiAgICAgKiBAcmV0dXJuIHtBcnJheUJ1ZmZlcn0gdGhlIGNvbnRlbnQgYXMgYW4gQXJyYXlCdWZlci5cbiAgICAgKi9cbiAgICBhc0FycmF5QnVmZmVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXNVaW50OEFycmF5KCkuYnVmZmVyO1xuICAgIH1cbn07XG5cbi8qKlxuICogVHJhbnNmb3JtIGFuIGludGVnZXIgaW50byBhIHN0cmluZyBpbiBoZXhhZGVjaW1hbC5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gZGVjIHRoZSBudW1iZXIgdG8gY29udmVydC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBieXRlcyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIGdlbmVyYXRlLlxuICogQHJldHVybnMge3N0cmluZ30gdGhlIHJlc3VsdC5cbiAqL1xudmFyIGRlY1RvSGV4ID0gZnVuY3Rpb24oZGVjLCBieXRlcykge1xuICAgIHZhciBoZXggPSBcIlwiLFxuICAgICAgICBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBieXRlczsgaSsrKSB7XG4gICAgICAgIGhleCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRlYyAmIDB4ZmYpO1xuICAgICAgICBkZWMgPSBkZWMgPj4+IDg7XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIChpbmNvbXBsZXRlKSBvcHRpb25zIGZyb20gdGhlIHVzZXIgaW50byB0aGUgY29tcGxldGVcbiAqIHNldCBvZiBvcHRpb25zIHRvIGNyZWF0ZSBhIGZpbGUuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG8gdGhlIG9wdGlvbnMgZnJvbSB0aGUgdXNlci5cbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIGNvbXBsZXRlIHNldCBvZiBvcHRpb25zLlxuICovXG52YXIgcHJlcGFyZUZpbGVBdHRycyA9IGZ1bmN0aW9uKG8pIHtcbiAgICBvID0gbyB8fCB7fTtcbiAgICBpZiAoby5iYXNlNjQgPT09IHRydWUgJiYgKG8uYmluYXJ5ID09PSBudWxsIHx8IG8uYmluYXJ5ID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIG8uYmluYXJ5ID0gdHJ1ZTtcbiAgICB9XG4gICAgbyA9IHV0aWxzLmV4dGVuZChvLCBkZWZhdWx0cyk7XG4gICAgby5kYXRlID0gby5kYXRlIHx8IG5ldyBEYXRlKCk7XG4gICAgaWYgKG8uY29tcHJlc3Npb24gIT09IG51bGwpIG8uY29tcHJlc3Npb24gPSBvLmNvbXByZXNzaW9uLnRvVXBwZXJDYXNlKCk7XG5cbiAgICByZXR1cm4gbztcbn07XG5cbi8qKlxuICogQWRkIGEgZmlsZSBpbiB0aGUgY3VycmVudCBmb2xkZXIuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIGZpbGVcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBkYXRhIHRoZSBkYXRhIG9mIHRoZSBmaWxlXG4gKiBAcGFyYW0ge09iamVjdH0gbyB0aGUgb3B0aW9ucyBvZiB0aGUgZmlsZVxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgbmV3IGZpbGUuXG4gKi9cbnZhciBmaWxlQWRkID0gZnVuY3Rpb24obmFtZSwgZGF0YSwgbykge1xuICAgIC8vIGJlIHN1cmUgc3ViIGZvbGRlcnMgZXhpc3RcbiAgICB2YXIgZGF0YVR5cGUgPSB1dGlscy5nZXRUeXBlT2YoZGF0YSksXG4gICAgICAgIHBhcmVudDtcblxuICAgIG8gPSBwcmVwYXJlRmlsZUF0dHJzKG8pO1xuXG4gICAgaWYgKHR5cGVvZiBvLnVuaXhQZXJtaXNzaW9ucyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBvLnVuaXhQZXJtaXNzaW9ucyA9IHBhcnNlSW50KG8udW5peFBlcm1pc3Npb25zLCA4KTtcbiAgICB9XG5cbiAgICAvLyBVTlhfSUZESVIgIDAwNDAwMDAgc2VlIHppcGluZm8uY1xuICAgIGlmIChvLnVuaXhQZXJtaXNzaW9ucyAmJiAoby51bml4UGVybWlzc2lvbnMgJiAweDQwMDApKSB7XG4gICAgICAgIG8uZGlyID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gQml0IDQgICAgRGlyZWN0b3J5XG4gICAgaWYgKG8uZG9zUGVybWlzc2lvbnMgJiYgKG8uZG9zUGVybWlzc2lvbnMgJiAweDAwMTApKSB7XG4gICAgICAgIG8uZGlyID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoby5kaXIpIHtcbiAgICAgICAgbmFtZSA9IGZvcmNlVHJhaWxpbmdTbGFzaChuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoby5jcmVhdGVGb2xkZXJzICYmIChwYXJlbnQgPSBwYXJlbnRGb2xkZXIobmFtZSkpKSB7XG4gICAgICAgIGZvbGRlckFkZC5jYWxsKHRoaXMsIHBhcmVudCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgaWYgKG8uZGlyIHx8IGRhdGEgPT09IG51bGwgfHwgdHlwZW9mIGRhdGEgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgby5iYXNlNjQgPSBmYWxzZTtcbiAgICAgICAgby5iaW5hcnkgPSBmYWxzZTtcbiAgICAgICAgZGF0YSA9IG51bGw7XG4gICAgICAgIGRhdGFUeXBlID0gbnVsbDtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGF0YVR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKG8uYmluYXJ5ICYmICFvLmJhc2U2NCkge1xuICAgICAgICAgICAgLy8gb3B0aW1pemVkQmluYXJ5U3RyaW5nID09IHRydWUgbWVhbnMgdGhhdCB0aGUgZmlsZSBoYXMgYWxyZWFkeSBiZWVuIGZpbHRlcmVkIHdpdGggYSAweEZGIG1hc2tcbiAgICAgICAgICAgIGlmIChvLm9wdGltaXplZEJpbmFyeVN0cmluZyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgYSBzdHJpbmcsIG5vdCBpbiBhIGJhc2U2NCBmb3JtYXQuXG4gICAgICAgICAgICAgICAgLy8gQmUgc3VyZSB0aGF0IHRoaXMgaXMgYSBjb3JyZWN0IFwiYmluYXJ5IHN0cmluZ1wiXG4gICAgICAgICAgICAgICAgZGF0YSA9IHV0aWxzLnN0cmluZzJiaW5hcnkoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7IC8vIGFycmF5YnVmZmVyLCB1aW50OGFycmF5LCAuLi5cbiAgICAgICAgby5iYXNlNjQgPSBmYWxzZTtcbiAgICAgICAgby5iaW5hcnkgPSB0cnVlO1xuXG4gICAgICAgIGlmICghZGF0YVR5cGUgJiYgIShkYXRhIGluc3RhbmNlb2YgQ29tcHJlc3NlZE9iamVjdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBkYXRhIG9mICdcIiArIG5hbWUgKyBcIicgaXMgaW4gYW4gdW5zdXBwb3J0ZWQgZm9ybWF0ICFcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzcGVjaWFsIGNhc2UgOiBpdCdzIHdheSBlYXNpZXIgdG8gd29yayB3aXRoIFVpbnQ4QXJyYXkgdGhhbiB3aXRoIEFycmF5QnVmZmVyXG4gICAgICAgIGlmIChkYXRhVHlwZSA9PT0gXCJhcnJheWJ1ZmZlclwiKSB7XG4gICAgICAgICAgICBkYXRhID0gdXRpbHMudHJhbnNmb3JtVG8oXCJ1aW50OGFycmF5XCIsIGRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG9iamVjdCA9IG5ldyBaaXBPYmplY3QobmFtZSwgZGF0YSwgbyk7XG4gICAgdGhpcy5maWxlc1tuYW1lXSA9IG9iamVjdDtcbiAgICByZXR1cm4gb2JqZWN0O1xufTtcblxuLyoqXG4gKiBGaW5kIHRoZSBwYXJlbnQgZm9sZGVyIG9mIHRoZSBwYXRoLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIHRoZSBwYXRoIHRvIHVzZVxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgcGFyZW50IGZvbGRlciwgb3IgXCJcIlxuICovXG52YXIgcGFyZW50Rm9sZGVyID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICBpZiAocGF0aC5zbGljZSgtMSkgPT0gJy8nKSB7XG4gICAgICAgIHBhdGggPSBwYXRoLnN1YnN0cmluZygwLCBwYXRoLmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgICB2YXIgbGFzdFNsYXNoID0gcGF0aC5sYXN0SW5kZXhPZignLycpO1xuICAgIHJldHVybiAobGFzdFNsYXNoID4gMCkgPyBwYXRoLnN1YnN0cmluZygwLCBsYXN0U2xhc2gpIDogXCJcIjtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwYXRoIHdpdGggYSBzbGFzaCBhdCB0aGUgZW5kLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIHRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHJldHVybiB7U3RyaW5nfSB0aGUgcGF0aCB3aXRoIGEgdHJhaWxpbmcgc2xhc2guXG4gKi9cbnZhciBmb3JjZVRyYWlsaW5nU2xhc2ggPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgLy8gQ2hlY2sgdGhlIG5hbWUgZW5kcyB3aXRoIGEgL1xuICAgIGlmIChwYXRoLnNsaWNlKC0xKSAhPSBcIi9cIikge1xuICAgICAgICBwYXRoICs9IFwiL1wiOyAvLyBJRSBkb2Vzbid0IGxpa2Ugc3Vic3RyKC0xKVxuICAgIH1cbiAgICByZXR1cm4gcGF0aDtcbn07XG4vKipcbiAqIEFkZCBhIChzdWIpIGZvbGRlciBpbiB0aGUgY3VycmVudCBmb2xkZXIuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIGZvbGRlcidzIG5hbWVcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IFtjcmVhdGVGb2xkZXJzXSBJZiB0cnVlLCBhdXRvbWF0aWNhbGx5IGNyZWF0ZSBzdWJcbiAqICBmb2xkZXJzLiBEZWZhdWx0cyB0byBmYWxzZS5cbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIG5ldyBmb2xkZXIuXG4gKi9cbnZhciBmb2xkZXJBZGQgPSBmdW5jdGlvbihuYW1lLCBjcmVhdGVGb2xkZXJzKSB7XG4gICAgY3JlYXRlRm9sZGVycyA9ICh0eXBlb2YgY3JlYXRlRm9sZGVycyAhPT0gJ3VuZGVmaW5lZCcpID8gY3JlYXRlRm9sZGVycyA6IGZhbHNlO1xuXG4gICAgbmFtZSA9IGZvcmNlVHJhaWxpbmdTbGFzaChuYW1lKTtcblxuICAgIC8vIERvZXMgdGhpcyBmb2xkZXIgYWxyZWFkeSBleGlzdD9cbiAgICBpZiAoIXRoaXMuZmlsZXNbbmFtZV0pIHtcbiAgICAgICAgZmlsZUFkZC5jYWxsKHRoaXMsIG5hbWUsIG51bGwsIHtcbiAgICAgICAgICAgIGRpcjogdHJ1ZSxcbiAgICAgICAgICAgIGNyZWF0ZUZvbGRlcnM6IGNyZWF0ZUZvbGRlcnNcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbGVzW25hbWVdO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIEpTWmlwLkNvbXByZXNzZWRPYmplY3QgZm9yIGEgZ2l2ZW4gemlwT2plY3QuXG4gKiBAcGFyYW0ge1ppcE9iamVjdH0gZmlsZSB0aGUgb2JqZWN0IHRvIHJlYWQuXG4gKiBAcGFyYW0ge0pTWmlwLmNvbXByZXNzaW9ufSBjb21wcmVzc2lvbiB0aGUgY29tcHJlc3Npb24gdG8gdXNlLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbXByZXNzaW9uT3B0aW9ucyB0aGUgb3B0aW9ucyB0byB1c2Ugd2hlbiBjb21wcmVzc2luZy5cbiAqIEByZXR1cm4ge0pTWmlwLkNvbXByZXNzZWRPYmplY3R9IHRoZSBjb21wcmVzc2VkIHJlc3VsdC5cbiAqL1xudmFyIGdlbmVyYXRlQ29tcHJlc3NlZE9iamVjdEZyb20gPSBmdW5jdGlvbihmaWxlLCBjb21wcmVzc2lvbiwgY29tcHJlc3Npb25PcHRpb25zKSB7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBDb21wcmVzc2VkT2JqZWN0KCksXG4gICAgICAgIGNvbnRlbnQ7XG5cbiAgICAvLyB0aGUgZGF0YSBoYXMgbm90IGJlZW4gZGVjb21wcmVzc2VkLCB3ZSBtaWdodCByZXVzZSB0aGluZ3MgIVxuICAgIGlmIChmaWxlLl9kYXRhIGluc3RhbmNlb2YgQ29tcHJlc3NlZE9iamVjdCkge1xuICAgICAgICByZXN1bHQudW5jb21wcmVzc2VkU2l6ZSA9IGZpbGUuX2RhdGEudW5jb21wcmVzc2VkU2l6ZTtcbiAgICAgICAgcmVzdWx0LmNyYzMyID0gZmlsZS5fZGF0YS5jcmMzMjtcblxuICAgICAgICBpZiAocmVzdWx0LnVuY29tcHJlc3NlZFNpemUgPT09IDAgfHwgZmlsZS5kaXIpIHtcbiAgICAgICAgICAgIGNvbXByZXNzaW9uID0gY29tcHJlc3Npb25zWydTVE9SRSddO1xuICAgICAgICAgICAgcmVzdWx0LmNvbXByZXNzZWRDb250ZW50ID0gXCJcIjtcbiAgICAgICAgICAgIHJlc3VsdC5jcmMzMiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmlsZS5fZGF0YS5jb21wcmVzc2lvbk1ldGhvZCA9PT0gY29tcHJlc3Npb24ubWFnaWMpIHtcbiAgICAgICAgICAgIHJlc3VsdC5jb21wcmVzc2VkQ29udGVudCA9IGZpbGUuX2RhdGEuZ2V0Q29tcHJlc3NlZENvbnRlbnQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRlbnQgPSBmaWxlLl9kYXRhLmdldENvbnRlbnQoKTtcbiAgICAgICAgICAgIC8vIG5lZWQgdG8gZGVjb21wcmVzcyAvIHJlY29tcHJlc3NcbiAgICAgICAgICAgIHJlc3VsdC5jb21wcmVzc2VkQ29udGVudCA9IGNvbXByZXNzaW9uLmNvbXByZXNzKHV0aWxzLnRyYW5zZm9ybVRvKGNvbXByZXNzaW9uLmNvbXByZXNzSW5wdXRUeXBlLCBjb250ZW50KSwgY29tcHJlc3Npb25PcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gaGF2ZSB1bmNvbXByZXNzZWQgZGF0YVxuICAgICAgICBjb250ZW50ID0gZ2V0QmluYXJ5RGF0YShmaWxlKTtcbiAgICAgICAgaWYgKCFjb250ZW50IHx8IGNvbnRlbnQubGVuZ3RoID09PSAwIHx8IGZpbGUuZGlyKSB7XG4gICAgICAgICAgICBjb21wcmVzc2lvbiA9IGNvbXByZXNzaW9uc1snU1RPUkUnXTtcbiAgICAgICAgICAgIGNvbnRlbnQgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC51bmNvbXByZXNzZWRTaXplID0gY29udGVudC5sZW5ndGg7XG4gICAgICAgIHJlc3VsdC5jcmMzMiA9IGNyYzMyKGNvbnRlbnQpO1xuICAgICAgICByZXN1bHQuY29tcHJlc3NlZENvbnRlbnQgPSBjb21wcmVzc2lvbi5jb21wcmVzcyh1dGlscy50cmFuc2Zvcm1Ubyhjb21wcmVzc2lvbi5jb21wcmVzc0lucHV0VHlwZSwgY29udGVudCksIGNvbXByZXNzaW9uT3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcmVzdWx0LmNvbXByZXNzZWRTaXplID0gcmVzdWx0LmNvbXByZXNzZWRDb250ZW50Lmxlbmd0aDtcbiAgICByZXN1bHQuY29tcHJlc3Npb25NZXRob2QgPSBjb21wcmVzc2lvbi5tYWdpYztcblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5cblxuXG4vKipcbiAqIEdlbmVyYXRlIHRoZSBVTklYIHBhcnQgb2YgdGhlIGV4dGVybmFsIGZpbGUgYXR0cmlidXRlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSB1bml4UGVybWlzc2lvbnMgdGhlIHVuaXggcGVybWlzc2lvbnMgb3IgbnVsbC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNEaXIgdHJ1ZSBpZiB0aGUgZW50cnkgaXMgYSBkaXJlY3RvcnksIGZhbHNlIG90aGVyd2lzZS5cbiAqIEByZXR1cm4ge051bWJlcn0gYSAzMiBiaXQgaW50ZWdlci5cbiAqXG4gKiBhZGFwdGVkIGZyb20gaHR0cDovL3VuaXguc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzE0NzA1L3RoZS16aXAtZm9ybWF0cy1leHRlcm5hbC1maWxlLWF0dHJpYnV0ZSA6XG4gKlxuICogVFRUVHNzdHJ3eHJ3eHJ3eDAwMDAwMDAwMDBBRFZTSFJcbiAqIF5eXl5fX19fX19fX19fX19fX19fX19fX19fX19fX19fIGZpbGUgdHlwZSwgc2VlIHppcGluZm8uYyAoVU5YXyopXG4gKiAgICAgXl5eX19fX19fX19fX19fX19fX19fX19fX19fXyBzZXR1aWQsIHNldGdpZCwgc3RpY2t5XG4gKiAgICAgICAgXl5eXl5eXl5eX19fX19fX19fX19fX19fXyBwZXJtaXNzaW9uc1xuICogICAgICAgICAgICAgICAgIF5eXl5eXl5eXl5fX19fX18gbm90IHVzZWQgP1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICBeXl5eXl4gRE9TIGF0dHJpYnV0ZSBiaXRzIDogQXJjaGl2ZSwgRGlyZWN0b3J5LCBWb2x1bWUgbGFiZWwsIFN5c3RlbSBmaWxlLCBIaWRkZW4sIFJlYWQgb25seVxuICovXG52YXIgZ2VuZXJhdGVVbml4RXh0ZXJuYWxGaWxlQXR0ciA9IGZ1bmN0aW9uICh1bml4UGVybWlzc2lvbnMsIGlzRGlyKSB7XG5cbiAgICB2YXIgcmVzdWx0ID0gdW5peFBlcm1pc3Npb25zO1xuICAgIGlmICghdW5peFBlcm1pc3Npb25zKSB7XG4gICAgICAgIC8vIEkgY2FuJ3QgdXNlIG9jdGFsIHZhbHVlcyBpbiBzdHJpY3QgbW9kZSwgaGVuY2UgdGhlIGhleGEuXG4gICAgICAgIC8vICAwNDA3NzUgPT4gMHg0MWZkXG4gICAgICAgIC8vIDAxMDA2NjQgPT4gMHg4MWI0XG4gICAgICAgIHJlc3VsdCA9IGlzRGlyID8gMHg0MWZkIDogMHg4MWI0O1xuICAgIH1cblxuICAgIHJldHVybiAocmVzdWx0ICYgMHhGRkZGKSA8PCAxNjtcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgdGhlIERPUyBwYXJ0IG9mIHRoZSBleHRlcm5hbCBmaWxlIGF0dHJpYnV0ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gZG9zUGVybWlzc2lvbnMgdGhlIGRvcyBwZXJtaXNzaW9ucyBvciBudWxsLlxuICogQHBhcmFtIHtCb29sZWFufSBpc0RpciB0cnVlIGlmIHRoZSBlbnRyeSBpcyBhIGRpcmVjdG9yeSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICogQHJldHVybiB7TnVtYmVyfSBhIDMyIGJpdCBpbnRlZ2VyLlxuICpcbiAqIEJpdCAwICAgICBSZWFkLU9ubHlcbiAqIEJpdCAxICAgICBIaWRkZW5cbiAqIEJpdCAyICAgICBTeXN0ZW1cbiAqIEJpdCAzICAgICBWb2x1bWUgTGFiZWxcbiAqIEJpdCA0ICAgICBEaXJlY3RvcnlcbiAqIEJpdCA1ICAgICBBcmNoaXZlXG4gKi9cbnZhciBnZW5lcmF0ZURvc0V4dGVybmFsRmlsZUF0dHIgPSBmdW5jdGlvbiAoZG9zUGVybWlzc2lvbnMsIGlzRGlyKSB7XG5cbiAgICAvLyB0aGUgZGlyIGZsYWcgaXMgYWxyZWFkeSBzZXQgZm9yIGNvbXBhdGliaWxpdHlcblxuICAgIHJldHVybiAoZG9zUGVybWlzc2lvbnMgfHwgMCkgICYgMHgzRjtcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgdGhlIHZhcmlvdXMgcGFydHMgdXNlZCBpbiB0aGUgY29uc3RydWN0aW9uIG9mIHRoZSBmaW5hbCB6aXAgZmlsZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBmaWxlIG5hbWUuXG4gKiBAcGFyYW0ge1ppcE9iamVjdH0gZmlsZSB0aGUgZmlsZSBjb250ZW50LlxuICogQHBhcmFtIHtKU1ppcC5Db21wcmVzc2VkT2JqZWN0fSBjb21wcmVzc2VkT2JqZWN0IHRoZSBjb21wcmVzc2VkIG9iamVjdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgdGhlIGN1cnJlbnQgb2Zmc2V0IGZyb20gdGhlIHN0YXJ0IG9mIHRoZSB6aXAgZmlsZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwbGF0Zm9ybSBsZXQncyBwcmV0ZW5kIHdlIGFyZSB0aGlzIHBsYXRmb3JtIChjaGFuZ2UgcGxhdGZvcm0gZGVwZW5kZW50cyBmaWVsZHMpXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlbmNvZGVGaWxlTmFtZSB0aGUgZnVuY3Rpb24gdG8gZW5jb2RlIHRoZSBmaWxlIG5hbWUgLyBjb21tZW50LlxuICogQHJldHVybiB7b2JqZWN0fSB0aGUgemlwIHBhcnRzLlxuICovXG52YXIgZ2VuZXJhdGVaaXBQYXJ0cyA9IGZ1bmN0aW9uKG5hbWUsIGZpbGUsIGNvbXByZXNzZWRPYmplY3QsIG9mZnNldCwgcGxhdGZvcm0sIGVuY29kZUZpbGVOYW1lKSB7XG4gICAgdmFyIGRhdGEgPSBjb21wcmVzc2VkT2JqZWN0LmNvbXByZXNzZWRDb250ZW50LFxuICAgICAgICB1c2VDdXN0b21FbmNvZGluZyA9IGVuY29kZUZpbGVOYW1lICE9PSB1dGY4LnV0ZjhlbmNvZGUsXG4gICAgICAgIGVuY29kZWRGaWxlTmFtZSA9IHV0aWxzLnRyYW5zZm9ybVRvKFwic3RyaW5nXCIsIGVuY29kZUZpbGVOYW1lKGZpbGUubmFtZSkpLFxuICAgICAgICB1dGZFbmNvZGVkRmlsZU5hbWUgPSB1dGlscy50cmFuc2Zvcm1UbyhcInN0cmluZ1wiLCB1dGY4LnV0ZjhlbmNvZGUoZmlsZS5uYW1lKSksXG4gICAgICAgIGNvbW1lbnQgPSBmaWxlLmNvbW1lbnQgfHwgXCJcIixcbiAgICAgICAgZW5jb2RlZENvbW1lbnQgPSB1dGlscy50cmFuc2Zvcm1UbyhcInN0cmluZ1wiLCBlbmNvZGVGaWxlTmFtZShjb21tZW50KSksXG4gICAgICAgIHV0ZkVuY29kZWRDb21tZW50ID0gdXRpbHMudHJhbnNmb3JtVG8oXCJzdHJpbmdcIiwgdXRmOC51dGY4ZW5jb2RlKGNvbW1lbnQpKSxcbiAgICAgICAgdXNlVVRGOEZvckZpbGVOYW1lID0gdXRmRW5jb2RlZEZpbGVOYW1lLmxlbmd0aCAhPT0gZmlsZS5uYW1lLmxlbmd0aCxcbiAgICAgICAgdXNlVVRGOEZvckNvbW1lbnQgPSB1dGZFbmNvZGVkQ29tbWVudC5sZW5ndGggIT09IGNvbW1lbnQubGVuZ3RoLFxuICAgICAgICBvID0gZmlsZS5vcHRpb25zLFxuICAgICAgICBkb3NUaW1lLFxuICAgICAgICBkb3NEYXRlLFxuICAgICAgICBleHRyYUZpZWxkcyA9IFwiXCIsXG4gICAgICAgIHVuaWNvZGVQYXRoRXh0cmFGaWVsZCA9IFwiXCIsXG4gICAgICAgIHVuaWNvZGVDb21tZW50RXh0cmFGaWVsZCA9IFwiXCIsXG4gICAgICAgIGRpciwgZGF0ZTtcblxuXG4gICAgLy8gaGFuZGxlIHRoZSBkZXByZWNhdGVkIG9wdGlvbnMuZGlyXG4gICAgaWYgKGZpbGUuX2luaXRpYWxNZXRhZGF0YS5kaXIgIT09IGZpbGUuZGlyKSB7XG4gICAgICAgIGRpciA9IGZpbGUuZGlyO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRpciA9IG8uZGlyO1xuICAgIH1cblxuICAgIC8vIGhhbmRsZSB0aGUgZGVwcmVjYXRlZCBvcHRpb25zLmRhdGVcbiAgICBpZihmaWxlLl9pbml0aWFsTWV0YWRhdGEuZGF0ZSAhPT0gZmlsZS5kYXRlKSB7XG4gICAgICAgIGRhdGUgPSBmaWxlLmRhdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZGF0ZSA9IG8uZGF0ZTtcbiAgICB9XG5cbiAgICB2YXIgZXh0RmlsZUF0dHIgPSAwO1xuICAgIHZhciB2ZXJzaW9uTWFkZUJ5ID0gMDtcbiAgICBpZiAoZGlyKSB7XG4gICAgICAgIC8vIGRvcyBvciB1bml4LCB3ZSBzZXQgdGhlIGRvcyBkaXIgZmxhZ1xuICAgICAgICBleHRGaWxlQXR0ciB8PSAweDAwMDEwO1xuICAgIH1cbiAgICBpZihwbGF0Zm9ybSA9PT0gXCJVTklYXCIpIHtcbiAgICAgICAgdmVyc2lvbk1hZGVCeSA9IDB4MDMxRTsgLy8gVU5JWCwgdmVyc2lvbiAzLjBcbiAgICAgICAgZXh0RmlsZUF0dHIgfD0gZ2VuZXJhdGVVbml4RXh0ZXJuYWxGaWxlQXR0cihmaWxlLnVuaXhQZXJtaXNzaW9ucywgZGlyKTtcbiAgICB9IGVsc2UgeyAvLyBET1Mgb3Igb3RoZXIsIGZhbGxiYWNrIHRvIERPU1xuICAgICAgICB2ZXJzaW9uTWFkZUJ5ID0gMHgwMDE0OyAvLyBET1MsIHZlcnNpb24gMi4wXG4gICAgICAgIGV4dEZpbGVBdHRyIHw9IGdlbmVyYXRlRG9zRXh0ZXJuYWxGaWxlQXR0cihmaWxlLmRvc1Blcm1pc3Npb25zLCBkaXIpO1xuICAgIH1cblxuICAgIC8vIGRhdGVcbiAgICAvLyBAc2VlIGh0dHA6Ly93d3cuZGVsb3JpZS5jb20vZGpncHAvZG9jL3JiaW50ZXIvaXQvNTIvMTMuaHRtbFxuICAgIC8vIEBzZWUgaHR0cDovL3d3dy5kZWxvcmllLmNvbS9kamdwcC9kb2MvcmJpbnRlci9pdC82NS8xNi5odG1sXG4gICAgLy8gQHNlZSBodHRwOi8vd3d3LmRlbG9yaWUuY29tL2RqZ3BwL2RvYy9yYmludGVyL2l0LzY2LzE2Lmh0bWxcblxuICAgIGRvc1RpbWUgPSBkYXRlLmdldEhvdXJzKCk7XG4gICAgZG9zVGltZSA9IGRvc1RpbWUgPDwgNjtcbiAgICBkb3NUaW1lID0gZG9zVGltZSB8IGRhdGUuZ2V0TWludXRlcygpO1xuICAgIGRvc1RpbWUgPSBkb3NUaW1lIDw8IDU7XG4gICAgZG9zVGltZSA9IGRvc1RpbWUgfCBkYXRlLmdldFNlY29uZHMoKSAvIDI7XG5cbiAgICBkb3NEYXRlID0gZGF0ZS5nZXRGdWxsWWVhcigpIC0gMTk4MDtcbiAgICBkb3NEYXRlID0gZG9zRGF0ZSA8PCA0O1xuICAgIGRvc0RhdGUgPSBkb3NEYXRlIHwgKGRhdGUuZ2V0TW9udGgoKSArIDEpO1xuICAgIGRvc0RhdGUgPSBkb3NEYXRlIDw8IDU7XG4gICAgZG9zRGF0ZSA9IGRvc0RhdGUgfCBkYXRlLmdldERhdGUoKTtcblxuICAgIGlmICh1c2VVVEY4Rm9yRmlsZU5hbWUpIHtcbiAgICAgICAgLy8gc2V0IHRoZSB1bmljb2RlIHBhdGggZXh0cmEgZmllbGQuIHVuemlwIG5lZWRzIGF0IGxlYXN0IG9uZSBleHRyYVxuICAgICAgICAvLyBmaWVsZCB0byBjb3JyZWN0bHkgaGFuZGxlIHVuaWNvZGUgcGF0aCwgc28gdXNpbmcgdGhlIHBhdGggaXMgYXMgZ29vZFxuICAgICAgICAvLyBhcyBhbnkgb3RoZXIgaW5mb3JtYXRpb24uIFRoaXMgY291bGQgaW1wcm92ZSB0aGUgc2l0dWF0aW9uIHdpdGhcbiAgICAgICAgLy8gb3RoZXIgYXJjaGl2ZSBtYW5hZ2VycyB0b28uXG4gICAgICAgIC8vIFRoaXMgZmllbGQgaXMgdXN1YWxseSB1c2VkIHdpdGhvdXQgdGhlIHV0ZjggZmxhZywgd2l0aCBhIG5vblxuICAgICAgICAvLyB1bmljb2RlIHBhdGggaW4gdGhlIGhlYWRlciAod2lucmFyLCB3aW56aXApLiBUaGlzIGhlbHBzIChhIGJpdClcbiAgICAgICAgLy8gd2l0aCB0aGUgbWVzc3kgV2luZG93cycgZGVmYXVsdCBjb21wcmVzc2VkIGZvbGRlcnMgZmVhdHVyZSBidXRcbiAgICAgICAgLy8gYnJlYWtzIG9uIHA3emlwIHdoaWNoIGRvZXNuJ3Qgc2VlayB0aGUgdW5pY29kZSBwYXRoIGV4dHJhIGZpZWxkLlxuICAgICAgICAvLyBTbyBmb3Igbm93LCBVVEYtOCBldmVyeXdoZXJlICFcbiAgICAgICAgdW5pY29kZVBhdGhFeHRyYUZpZWxkID1cbiAgICAgICAgICAgIC8vIFZlcnNpb25cbiAgICAgICAgICAgIGRlY1RvSGV4KDEsIDEpICtcbiAgICAgICAgICAgIC8vIE5hbWVDUkMzMlxuICAgICAgICAgICAgZGVjVG9IZXgoY3JjMzIoZW5jb2RlZEZpbGVOYW1lKSwgNCkgK1xuICAgICAgICAgICAgLy8gVW5pY29kZU5hbWVcbiAgICAgICAgICAgIHV0ZkVuY29kZWRGaWxlTmFtZTtcblxuICAgICAgICBleHRyYUZpZWxkcyArPVxuICAgICAgICAgICAgLy8gSW5mby1aSVAgVW5pY29kZSBQYXRoIEV4dHJhIEZpZWxkXG4gICAgICAgICAgICBcIlxceDc1XFx4NzBcIiArXG4gICAgICAgICAgICAvLyBzaXplXG4gICAgICAgICAgICBkZWNUb0hleCh1bmljb2RlUGF0aEV4dHJhRmllbGQubGVuZ3RoLCAyKSArXG4gICAgICAgICAgICAvLyBjb250ZW50XG4gICAgICAgICAgICB1bmljb2RlUGF0aEV4dHJhRmllbGQ7XG4gICAgfVxuXG4gICAgaWYodXNlVVRGOEZvckNvbW1lbnQpIHtcblxuICAgICAgICB1bmljb2RlQ29tbWVudEV4dHJhRmllbGQgPVxuICAgICAgICAgICAgLy8gVmVyc2lvblxuICAgICAgICAgICAgZGVjVG9IZXgoMSwgMSkgK1xuICAgICAgICAgICAgLy8gQ29tbWVudENSQzMyXG4gICAgICAgICAgICBkZWNUb0hleCh0aGlzLmNyYzMyKGVuY29kZWRDb21tZW50KSwgNCkgK1xuICAgICAgICAgICAgLy8gVW5pY29kZU5hbWVcbiAgICAgICAgICAgIHV0ZkVuY29kZWRDb21tZW50O1xuXG4gICAgICAgIGV4dHJhRmllbGRzICs9XG4gICAgICAgICAgICAvLyBJbmZvLVpJUCBVbmljb2RlIFBhdGggRXh0cmEgRmllbGRcbiAgICAgICAgICAgIFwiXFx4NzVcXHg2M1wiICtcbiAgICAgICAgICAgIC8vIHNpemVcbiAgICAgICAgICAgIGRlY1RvSGV4KHVuaWNvZGVDb21tZW50RXh0cmFGaWVsZC5sZW5ndGgsIDIpICtcbiAgICAgICAgICAgIC8vIGNvbnRlbnRcbiAgICAgICAgICAgIHVuaWNvZGVDb21tZW50RXh0cmFGaWVsZDtcbiAgICB9XG5cbiAgICB2YXIgaGVhZGVyID0gXCJcIjtcblxuICAgIC8vIHZlcnNpb24gbmVlZGVkIHRvIGV4dHJhY3RcbiAgICBoZWFkZXIgKz0gXCJcXHgwQVxceDAwXCI7XG4gICAgLy8gZ2VuZXJhbCBwdXJwb3NlIGJpdCBmbGFnXG4gICAgLy8gc2V0IGJpdCAxMSBpZiB1dGY4XG4gICAgaGVhZGVyICs9ICF1c2VDdXN0b21FbmNvZGluZyAmJiAodXNlVVRGOEZvckZpbGVOYW1lIHx8IHVzZVVURjhGb3JDb21tZW50KSA/IFwiXFx4MDBcXHgwOFwiIDogXCJcXHgwMFxceDAwXCI7XG4gICAgLy8gY29tcHJlc3Npb24gbWV0aG9kXG4gICAgaGVhZGVyICs9IGNvbXByZXNzZWRPYmplY3QuY29tcHJlc3Npb25NZXRob2Q7XG4gICAgLy8gbGFzdCBtb2QgZmlsZSB0aW1lXG4gICAgaGVhZGVyICs9IGRlY1RvSGV4KGRvc1RpbWUsIDIpO1xuICAgIC8vIGxhc3QgbW9kIGZpbGUgZGF0ZVxuICAgIGhlYWRlciArPSBkZWNUb0hleChkb3NEYXRlLCAyKTtcbiAgICAvLyBjcmMtMzJcbiAgICBoZWFkZXIgKz0gZGVjVG9IZXgoY29tcHJlc3NlZE9iamVjdC5jcmMzMiwgNCk7XG4gICAgLy8gY29tcHJlc3NlZCBzaXplXG4gICAgaGVhZGVyICs9IGRlY1RvSGV4KGNvbXByZXNzZWRPYmplY3QuY29tcHJlc3NlZFNpemUsIDQpO1xuICAgIC8vIHVuY29tcHJlc3NlZCBzaXplXG4gICAgaGVhZGVyICs9IGRlY1RvSGV4KGNvbXByZXNzZWRPYmplY3QudW5jb21wcmVzc2VkU2l6ZSwgNCk7XG4gICAgLy8gZmlsZSBuYW1lIGxlbmd0aFxuICAgIGhlYWRlciArPSBkZWNUb0hleChlbmNvZGVkRmlsZU5hbWUubGVuZ3RoLCAyKTtcbiAgICAvLyBleHRyYSBmaWVsZCBsZW5ndGhcbiAgICBoZWFkZXIgKz0gZGVjVG9IZXgoZXh0cmFGaWVsZHMubGVuZ3RoLCAyKTtcblxuXG4gICAgdmFyIGZpbGVSZWNvcmQgPSBzaWduYXR1cmUuTE9DQUxfRklMRV9IRUFERVIgKyBoZWFkZXIgKyBlbmNvZGVkRmlsZU5hbWUgKyBleHRyYUZpZWxkcztcblxuICAgIHZhciBkaXJSZWNvcmQgPSBzaWduYXR1cmUuQ0VOVFJBTF9GSUxFX0hFQURFUiArXG4gICAgLy8gdmVyc2lvbiBtYWRlIGJ5ICgwMDogRE9TKVxuICAgIGRlY1RvSGV4KHZlcnNpb25NYWRlQnksIDIpICtcbiAgICAvLyBmaWxlIGhlYWRlciAoY29tbW9uIHRvIGZpbGUgYW5kIGNlbnRyYWwgZGlyZWN0b3J5KVxuICAgIGhlYWRlciArXG4gICAgLy8gZmlsZSBjb21tZW50IGxlbmd0aFxuICAgIGRlY1RvSGV4KGVuY29kZWRDb21tZW50Lmxlbmd0aCwgMikgK1xuICAgIC8vIGRpc2sgbnVtYmVyIHN0YXJ0XG4gICAgXCJcXHgwMFxceDAwXCIgK1xuICAgIC8vIGludGVybmFsIGZpbGUgYXR0cmlidXRlcyBUT0RPXG4gICAgXCJcXHgwMFxceDAwXCIgK1xuICAgIC8vIGV4dGVybmFsIGZpbGUgYXR0cmlidXRlc1xuICAgIGRlY1RvSGV4KGV4dEZpbGVBdHRyLCA0KSArXG4gICAgLy8gcmVsYXRpdmUgb2Zmc2V0IG9mIGxvY2FsIGhlYWRlclxuICAgIGRlY1RvSGV4KG9mZnNldCwgNCkgK1xuICAgIC8vIGZpbGUgbmFtZVxuICAgIGVuY29kZWRGaWxlTmFtZSArXG4gICAgLy8gZXh0cmEgZmllbGRcbiAgICBleHRyYUZpZWxkcyArXG4gICAgLy8gZmlsZSBjb21tZW50XG4gICAgZW5jb2RlZENvbW1lbnQ7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBmaWxlUmVjb3JkOiBmaWxlUmVjb3JkLFxuICAgICAgICBkaXJSZWNvcmQ6IGRpclJlY29yZCxcbiAgICAgICAgY29tcHJlc3NlZE9iamVjdDogY29tcHJlc3NlZE9iamVjdFxuICAgIH07XG59O1xuXG5cbi8vIHJldHVybiB0aGUgYWN0dWFsIHByb3RvdHlwZSBvZiBKU1ppcFxudmFyIG91dCA9IHtcbiAgICAvKipcbiAgICAgKiBSZWFkIGFuIGV4aXN0aW5nIHppcCBhbmQgbWVyZ2UgdGhlIGRhdGEgaW4gdGhlIGN1cnJlbnQgSlNaaXAgb2JqZWN0LlxuICAgICAqIFRoZSBpbXBsZW1lbnRhdGlvbiBpcyBpbiBqc3ppcC1sb2FkLmpzLCBkb24ndCBmb3JnZXQgdG8gaW5jbHVkZSBpdC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gc3RyZWFtICBUaGUgc3RyZWFtIHRvIGxvYWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIGZvciBsb2FkaW5nIHRoZSBzdHJlYW0uXG4gICAgICogIG9wdGlvbnMuYmFzZTY0IDogaXMgdGhlIHN0cmVhbSBpbiBiYXNlNjQgPyBkZWZhdWx0IDogZmFsc2VcbiAgICAgKiBAcmV0dXJuIHtKU1ppcH0gdGhlIGN1cnJlbnQgSlNaaXAgb2JqZWN0XG4gICAgICovXG4gICAgbG9hZDogZnVuY3Rpb24oc3RyZWFtLCBvcHRpb25zKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkxvYWQgbWV0aG9kIGlzIG5vdCBkZWZpbmVkLiBJcyB0aGUgZmlsZSBqc3ppcC1sb2FkLmpzIGluY2x1ZGVkID9cIik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbHRlciBuZXN0ZWQgZmlsZXMvZm9sZGVycyB3aXRoIHRoZSBzcGVjaWZpZWQgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2VhcmNoIHRoZSBwcmVkaWNhdGUgdG8gdXNlIDpcbiAgICAgKiBmdW5jdGlvbiAocmVsYXRpdmVQYXRoLCBmaWxlKSB7Li4ufVxuICAgICAqIEl0IHRha2VzIDIgYXJndW1lbnRzIDogdGhlIHJlbGF0aXZlIHBhdGggYW5kIHRoZSBmaWxlLlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBvZiBtYXRjaGluZyBlbGVtZW50cy5cbiAgICAgKi9cbiAgICBmaWx0ZXI6IGZ1bmN0aW9uKHNlYXJjaCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgICAgICBmaWxlbmFtZSwgcmVsYXRpdmVQYXRoLCBmaWxlLCBmaWxlQ2xvbmU7XG4gICAgICAgIGZvciAoZmlsZW5hbWUgaW4gdGhpcy5maWxlcykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmZpbGVzLmhhc093blByb3BlcnR5KGZpbGVuYW1lKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlsZSA9IHRoaXMuZmlsZXNbZmlsZW5hbWVdO1xuICAgICAgICAgICAgLy8gcmV0dXJuIGEgbmV3IG9iamVjdCwgZG9uJ3QgbGV0IHRoZSB1c2VyIG1lc3Mgd2l0aCBvdXIgaW50ZXJuYWwgb2JqZWN0cyA6KVxuICAgICAgICAgICAgZmlsZUNsb25lID0gbmV3IFppcE9iamVjdChmaWxlLm5hbWUsIGZpbGUuX2RhdGEsIHV0aWxzLmV4dGVuZChmaWxlLm9wdGlvbnMpKTtcbiAgICAgICAgICAgIHJlbGF0aXZlUGF0aCA9IGZpbGVuYW1lLnNsaWNlKHRoaXMucm9vdC5sZW5ndGgsIGZpbGVuYW1lLmxlbmd0aCk7XG4gICAgICAgICAgICBpZiAoZmlsZW5hbWUuc2xpY2UoMCwgdGhpcy5yb290Lmxlbmd0aCkgPT09IHRoaXMucm9vdCAmJiAvLyB0aGUgZmlsZSBpcyBpbiB0aGUgY3VycmVudCByb290XG4gICAgICAgICAgICBzZWFyY2gocmVsYXRpdmVQYXRoLCBmaWxlQ2xvbmUpKSB7IC8vIGFuZCB0aGUgZmlsZSBtYXRjaGVzIHRoZSBmdW5jdGlvblxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZpbGVDbG9uZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgZmlsZSB0byB0aGUgemlwIGZpbGUsIG9yIHNlYXJjaCBhIGZpbGUuXG4gICAgICogQHBhcmFtICAge3N0cmluZ3xSZWdFeHB9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGZpbGUgdG8gYWRkIChpZiBkYXRhIGlzIGRlZmluZWQpLFxuICAgICAqIHRoZSBuYW1lIG9mIHRoZSBmaWxlIHRvIGZpbmQgKGlmIG5vIGRhdGEpIG9yIGEgcmVnZXggdG8gbWF0Y2ggZmlsZXMuXG4gICAgICogQHBhcmFtICAge1N0cmluZ3xBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gZGF0YSAgVGhlIGZpbGUgZGF0YSwgZWl0aGVyIHJhdyBvciBiYXNlNjQgZW5jb2RlZFxuICAgICAqIEBwYXJhbSAgIHtPYmplY3R9IG8gICAgIEZpbGUgb3B0aW9uc1xuICAgICAqIEByZXR1cm4gIHtKU1ppcHxPYmplY3R8QXJyYXl9IHRoaXMgSlNaaXAgb2JqZWN0ICh3aGVuIGFkZGluZyBhIGZpbGUpLFxuICAgICAqIGEgZmlsZSAod2hlbiBzZWFyY2hpbmcgYnkgc3RyaW5nKSBvciBhbiBhcnJheSBvZiBmaWxlcyAod2hlbiBzZWFyY2hpbmcgYnkgcmVnZXgpLlxuICAgICAqL1xuICAgIGZpbGU6IGZ1bmN0aW9uKG5hbWUsIGRhdGEsIG8pIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGlmICh1dGlscy5pc1JlZ0V4cChuYW1lKSkge1xuICAgICAgICAgICAgICAgIHZhciByZWdleHAgPSBuYW1lO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbihyZWxhdGl2ZVBhdGgsIGZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFmaWxlLmRpciAmJiByZWdleHAudGVzdChyZWxhdGl2ZVBhdGgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7IC8vIHRleHRcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24ocmVsYXRpdmVQYXRoLCBmaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhZmlsZS5kaXIgJiYgcmVsYXRpdmVQYXRoID09PSBuYW1lO1xuICAgICAgICAgICAgICAgIH0pWzBdIHx8IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQgOiB3ZSBoYXZlIGRhdGEgIVxuICAgICAgICAgICAgbmFtZSA9IHRoaXMucm9vdCArIG5hbWU7XG4gICAgICAgICAgICBmaWxlQWRkLmNhbGwodGhpcywgbmFtZSwgZGF0YSwgbyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBhIGRpcmVjdG9yeSB0byB0aGUgemlwIGZpbGUsIG9yIHNlYXJjaC5cbiAgICAgKiBAcGFyYW0gICB7U3RyaW5nfFJlZ0V4cH0gYXJnIFRoZSBuYW1lIG9mIHRoZSBkaXJlY3RvcnkgdG8gYWRkLCBvciBhIHJlZ2V4IHRvIHNlYXJjaCBmb2xkZXJzLlxuICAgICAqIEByZXR1cm4gIHtKU1ppcH0gYW4gb2JqZWN0IHdpdGggdGhlIG5ldyBkaXJlY3RvcnkgYXMgdGhlIHJvb3QsIG9yIGFuIGFycmF5IGNvbnRhaW5pbmcgbWF0Y2hpbmcgZm9sZGVycy5cbiAgICAgKi9cbiAgICBmb2xkZXI6IGZ1bmN0aW9uKGFyZykge1xuICAgICAgICBpZiAoIWFyZykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXRpbHMuaXNSZWdFeHAoYXJnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGZ1bmN0aW9uKHJlbGF0aXZlUGF0aCwgZmlsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWxlLmRpciAmJiBhcmcudGVzdChyZWxhdGl2ZVBhdGgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBlbHNlLCBuYW1lIGlzIGEgbmV3IGZvbGRlclxuICAgICAgICB2YXIgbmFtZSA9IHRoaXMucm9vdCArIGFyZztcbiAgICAgICAgdmFyIG5ld0ZvbGRlciA9IGZvbGRlckFkZC5jYWxsKHRoaXMsIG5hbWUpO1xuXG4gICAgICAgIC8vIEFsbG93IGNoYWluaW5nIGJ5IHJldHVybmluZyBhIG5ldyBvYmplY3Qgd2l0aCB0aGlzIGZvbGRlciBhcyB0aGUgcm9vdFxuICAgICAgICB2YXIgcmV0ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICByZXQucm9vdCA9IG5ld0ZvbGRlci5uYW1lO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYSBmaWxlLCBvciBhIGRpcmVjdG9yeSBhbmQgYWxsIHN1Yi1maWxlcywgZnJvbSB0aGUgemlwXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIGZpbGUgdG8gZGVsZXRlXG4gICAgICogQHJldHVybiB7SlNaaXB9IHRoaXMgSlNaaXAgb2JqZWN0XG4gICAgICovXG4gICAgcmVtb3ZlOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIG5hbWUgPSB0aGlzLnJvb3QgKyBuYW1lO1xuICAgICAgICB2YXIgZmlsZSA9IHRoaXMuZmlsZXNbbmFtZV07XG4gICAgICAgIGlmICghZmlsZSkge1xuICAgICAgICAgICAgLy8gTG9vayBmb3IgYW55IGZvbGRlcnNcbiAgICAgICAgICAgIGlmIChuYW1lLnNsaWNlKC0xKSAhPSBcIi9cIikge1xuICAgICAgICAgICAgICAgIG5hbWUgKz0gXCIvXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaWxlID0gdGhpcy5maWxlc1tuYW1lXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmaWxlICYmICFmaWxlLmRpcikge1xuICAgICAgICAgICAgLy8gZmlsZVxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuZmlsZXNbbmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBtYXliZSBhIGZvbGRlciwgZGVsZXRlIHJlY3Vyc2l2ZWx5XG4gICAgICAgICAgICB2YXIga2lkcyA9IHRoaXMuZmlsdGVyKGZ1bmN0aW9uKHJlbGF0aXZlUGF0aCwgZmlsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWxlLm5hbWUuc2xpY2UoMCwgbmFtZS5sZW5ndGgpID09PSBuYW1lO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5maWxlc1traWRzW2ldLm5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIHRoZSBjb21wbGV0ZSB6aXAgZmlsZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHRoZSBvcHRpb25zIHRvIGdlbmVyYXRlIHRoZSB6aXAgZmlsZSA6XG4gICAgICogLSBiYXNlNjQsIChkZXByZWNhdGVkLCB1c2UgdHlwZSBpbnN0ZWFkKSB0cnVlIHRvIGdlbmVyYXRlIGJhc2U2NC5cbiAgICAgKiAtIGNvbXByZXNzaW9uLCBcIlNUT1JFXCIgYnkgZGVmYXVsdC5cbiAgICAgKiAtIHR5cGUsIFwiYmFzZTY0XCIgYnkgZGVmYXVsdC4gVmFsdWVzIGFyZSA6IHN0cmluZywgYmFzZTY0LCB1aW50OGFycmF5LCBhcnJheWJ1ZmZlciwgYmxvYi5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd8VWludDhBcnJheXxBcnJheUJ1ZmZlcnxCdWZmZXJ8QmxvYn0gdGhlIHppcCBmaWxlXG4gICAgICovXG4gICAgZ2VuZXJhdGU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IHV0aWxzLmV4dGVuZChvcHRpb25zIHx8IHt9LCB7XG4gICAgICAgICAgICBiYXNlNjQ6IHRydWUsXG4gICAgICAgICAgICBjb21wcmVzc2lvbjogXCJTVE9SRVwiLFxuICAgICAgICAgICAgY29tcHJlc3Npb25PcHRpb25zIDogbnVsbCxcbiAgICAgICAgICAgIHR5cGU6IFwiYmFzZTY0XCIsXG4gICAgICAgICAgICBwbGF0Zm9ybTogXCJET1NcIixcbiAgICAgICAgICAgIGNvbW1lbnQ6IG51bGwsXG4gICAgICAgICAgICBtaW1lVHlwZTogJ2FwcGxpY2F0aW9uL3ppcCcsXG4gICAgICAgICAgICBlbmNvZGVGaWxlTmFtZTogdXRmOC51dGY4ZW5jb2RlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHV0aWxzLmNoZWNrU3VwcG9ydChvcHRpb25zLnR5cGUpO1xuXG4gICAgICAgIC8vIGFjY2VwdCBub2RlanMgYHByb2Nlc3MucGxhdGZvcm1gXG4gICAgICAgIGlmKFxuICAgICAgICAgIG9wdGlvbnMucGxhdGZvcm0gPT09ICdkYXJ3aW4nIHx8XG4gICAgICAgICAgb3B0aW9ucy5wbGF0Zm9ybSA9PT0gJ2ZyZWVic2QnIHx8XG4gICAgICAgICAgb3B0aW9ucy5wbGF0Zm9ybSA9PT0gJ2xpbnV4JyB8fFxuICAgICAgICAgIG9wdGlvbnMucGxhdGZvcm0gPT09ICdzdW5vcydcbiAgICAgICAgKSB7XG4gICAgICAgICAgb3B0aW9ucy5wbGF0Zm9ybSA9IFwiVU5JWFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnBsYXRmb3JtID09PSAnd2luMzInKSB7XG4gICAgICAgICAgb3B0aW9ucy5wbGF0Zm9ybSA9IFwiRE9TXCI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgemlwRGF0YSA9IFtdLFxuICAgICAgICAgICAgbG9jYWxEaXJMZW5ndGggPSAwLFxuICAgICAgICAgICAgY2VudHJhbERpckxlbmd0aCA9IDAsXG4gICAgICAgICAgICB3cml0ZXIsIGksXG4gICAgICAgICAgICBlbmNvZGVkQ29tbWVudCA9IHV0aWxzLnRyYW5zZm9ybVRvKFwic3RyaW5nXCIsIG9wdGlvbnMuZW5jb2RlRmlsZU5hbWUob3B0aW9ucy5jb21tZW50IHx8IHRoaXMuY29tbWVudCB8fCBcIlwiKSk7XG5cbiAgICAgICAgLy8gZmlyc3QsIGdlbmVyYXRlIGFsbCB0aGUgemlwIHBhcnRzLlxuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMuZmlsZXMpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5maWxlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGZpbGUgPSB0aGlzLmZpbGVzW25hbWVdO1xuXG4gICAgICAgICAgICB2YXIgY29tcHJlc3Npb25OYW1lID0gZmlsZS5vcHRpb25zLmNvbXByZXNzaW9uIHx8IG9wdGlvbnMuY29tcHJlc3Npb24udG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIHZhciBjb21wcmVzc2lvbiA9IGNvbXByZXNzaW9uc1tjb21wcmVzc2lvbk5hbWVdO1xuICAgICAgICAgICAgaWYgKCFjb21wcmVzc2lvbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihjb21wcmVzc2lvbk5hbWUgKyBcIiBpcyBub3QgYSB2YWxpZCBjb21wcmVzc2lvbiBtZXRob2QgIVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjb21wcmVzc2lvbk9wdGlvbnMgPSBmaWxlLm9wdGlvbnMuY29tcHJlc3Npb25PcHRpb25zIHx8IG9wdGlvbnMuY29tcHJlc3Npb25PcHRpb25zIHx8IHt9O1xuXG4gICAgICAgICAgICB2YXIgY29tcHJlc3NlZE9iamVjdCA9IGdlbmVyYXRlQ29tcHJlc3NlZE9iamVjdEZyb20uY2FsbCh0aGlzLCBmaWxlLCBjb21wcmVzc2lvbiwgY29tcHJlc3Npb25PcHRpb25zKTtcblxuICAgICAgICAgICAgdmFyIHppcFBhcnQgPSBnZW5lcmF0ZVppcFBhcnRzLmNhbGwodGhpcywgbmFtZSwgZmlsZSwgY29tcHJlc3NlZE9iamVjdCwgbG9jYWxEaXJMZW5ndGgsIG9wdGlvbnMucGxhdGZvcm0sIG9wdGlvbnMuZW5jb2RlRmlsZU5hbWUpO1xuICAgICAgICAgICAgbG9jYWxEaXJMZW5ndGggKz0gemlwUGFydC5maWxlUmVjb3JkLmxlbmd0aCArIGNvbXByZXNzZWRPYmplY3QuY29tcHJlc3NlZFNpemU7XG4gICAgICAgICAgICBjZW50cmFsRGlyTGVuZ3RoICs9IHppcFBhcnQuZGlyUmVjb3JkLmxlbmd0aDtcbiAgICAgICAgICAgIHppcERhdGEucHVzaCh6aXBQYXJ0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkaXJFbmQgPSBcIlwiO1xuXG4gICAgICAgIC8vIGVuZCBvZiBjZW50cmFsIGRpciBzaWduYXR1cmVcbiAgICAgICAgZGlyRW5kID0gc2lnbmF0dXJlLkNFTlRSQUxfRElSRUNUT1JZX0VORCArXG4gICAgICAgIC8vIG51bWJlciBvZiB0aGlzIGRpc2tcbiAgICAgICAgXCJcXHgwMFxceDAwXCIgK1xuICAgICAgICAvLyBudW1iZXIgb2YgdGhlIGRpc2sgd2l0aCB0aGUgc3RhcnQgb2YgdGhlIGNlbnRyYWwgZGlyZWN0b3J5XG4gICAgICAgIFwiXFx4MDBcXHgwMFwiICtcbiAgICAgICAgLy8gdG90YWwgbnVtYmVyIG9mIGVudHJpZXMgaW4gdGhlIGNlbnRyYWwgZGlyZWN0b3J5IG9uIHRoaXMgZGlza1xuICAgICAgICBkZWNUb0hleCh6aXBEYXRhLmxlbmd0aCwgMikgK1xuICAgICAgICAvLyB0b3RhbCBudW1iZXIgb2YgZW50cmllcyBpbiB0aGUgY2VudHJhbCBkaXJlY3RvcnlcbiAgICAgICAgZGVjVG9IZXgoemlwRGF0YS5sZW5ndGgsIDIpICtcbiAgICAgICAgLy8gc2l6ZSBvZiB0aGUgY2VudHJhbCBkaXJlY3RvcnkgICA0IGJ5dGVzXG4gICAgICAgIGRlY1RvSGV4KGNlbnRyYWxEaXJMZW5ndGgsIDQpICtcbiAgICAgICAgLy8gb2Zmc2V0IG9mIHN0YXJ0IG9mIGNlbnRyYWwgZGlyZWN0b3J5IHdpdGggcmVzcGVjdCB0byB0aGUgc3RhcnRpbmcgZGlzayBudW1iZXJcbiAgICAgICAgZGVjVG9IZXgobG9jYWxEaXJMZW5ndGgsIDQpICtcbiAgICAgICAgLy8gLlpJUCBmaWxlIGNvbW1lbnQgbGVuZ3RoXG4gICAgICAgIGRlY1RvSGV4KGVuY29kZWRDb21tZW50Lmxlbmd0aCwgMikgK1xuICAgICAgICAvLyAuWklQIGZpbGUgY29tbWVudFxuICAgICAgICBlbmNvZGVkQ29tbWVudDtcblxuXG4gICAgICAgIC8vIHdlIGhhdmUgYWxsIHRoZSBwYXJ0cyAoYW5kIHRoZSB0b3RhbCBsZW5ndGgpXG4gICAgICAgIC8vIHRpbWUgdG8gY3JlYXRlIGEgd3JpdGVyICFcbiAgICAgICAgdmFyIHR5cGVOYW1lID0gb3B0aW9ucy50eXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmKHR5cGVOYW1lPT09XCJ1aW50OGFycmF5XCJ8fHR5cGVOYW1lPT09XCJhcnJheWJ1ZmZlclwifHx0eXBlTmFtZT09PVwiYmxvYlwifHx0eXBlTmFtZT09PVwibm9kZWJ1ZmZlclwiKSB7XG4gICAgICAgICAgICB3cml0ZXIgPSBuZXcgVWludDhBcnJheVdyaXRlcihsb2NhbERpckxlbmd0aCArIGNlbnRyYWxEaXJMZW5ndGggKyBkaXJFbmQubGVuZ3RoKTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICB3cml0ZXIgPSBuZXcgU3RyaW5nV3JpdGVyKGxvY2FsRGlyTGVuZ3RoICsgY2VudHJhbERpckxlbmd0aCArIGRpckVuZC5sZW5ndGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHppcERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHdyaXRlci5hcHBlbmQoemlwRGF0YVtpXS5maWxlUmVjb3JkKTtcbiAgICAgICAgICAgIHdyaXRlci5hcHBlbmQoemlwRGF0YVtpXS5jb21wcmVzc2VkT2JqZWN0LmNvbXByZXNzZWRDb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgemlwRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgd3JpdGVyLmFwcGVuZCh6aXBEYXRhW2ldLmRpclJlY29yZCk7XG4gICAgICAgIH1cblxuICAgICAgICB3cml0ZXIuYXBwZW5kKGRpckVuZCk7XG5cbiAgICAgICAgdmFyIHppcCA9IHdyaXRlci5maW5hbGl6ZSgpO1xuXG5cblxuICAgICAgICBzd2l0Y2gob3B0aW9ucy50eXBlLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIC8vIGNhc2UgXCJ6aXAgaXMgYW4gVWludDhBcnJheVwiXG4gICAgICAgICAgICBjYXNlIFwidWludDhhcnJheVwiIDpcbiAgICAgICAgICAgIGNhc2UgXCJhcnJheWJ1ZmZlclwiIDpcbiAgICAgICAgICAgIGNhc2UgXCJub2RlYnVmZmVyXCIgOlxuICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxzLnRyYW5zZm9ybVRvKG9wdGlvbnMudHlwZS50b0xvd2VyQ2FzZSgpLCB6aXApO1xuICAgICAgICAgICAgY2FzZSBcImJsb2JcIiA6XG4gICAgICAgICAgICAgICByZXR1cm4gdXRpbHMuYXJyYXlCdWZmZXIyQmxvYih1dGlscy50cmFuc2Zvcm1UbyhcImFycmF5YnVmZmVyXCIsIHppcCksIG9wdGlvbnMubWltZVR5cGUpO1xuICAgICAgICAgICAgLy8gY2FzZSBcInppcCBpcyBhIHN0cmluZ1wiXG4gICAgICAgICAgICBjYXNlIFwiYmFzZTY0XCIgOlxuICAgICAgICAgICAgICAgcmV0dXJuIChvcHRpb25zLmJhc2U2NCkgPyBiYXNlNjQuZW5jb2RlKHppcCkgOiB6aXA7XG4gICAgICAgICAgICBkZWZhdWx0IDogLy8gY2FzZSBcInN0cmluZ1wiIDpcbiAgICAgICAgICAgICAgIHJldHVybiB6aXA7XG4gICAgICAgICB9XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbiB3aXRob3V0IHJlcGxhY2VtZW50LlxuICAgICAqL1xuICAgIGNyYzMyOiBmdW5jdGlvbiAoaW5wdXQsIGNyYykge1xuICAgICAgICByZXR1cm4gY3JjMzIoaW5wdXQsIGNyYyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24gd2l0aG91dCByZXBsYWNlbWVudC5cbiAgICAgKi9cbiAgICB1dGY4ZW5jb2RlOiBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiB1dGlscy50cmFuc2Zvcm1UbyhcInN0cmluZ1wiLCB1dGY4LnV0ZjhlbmNvZGUoc3RyaW5nKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24gd2l0aG91dCByZXBsYWNlbWVudC5cbiAgICAgKi9cbiAgICB1dGY4ZGVjb2RlOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHV0ZjgudXRmOGRlY29kZShpbnB1dCk7XG4gICAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gb3V0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2pzemlwL2xpYi9vYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = {\n  2:      'need dictionary',     /* Z_NEED_DICT       2  */\n  1:      'stream end',          /* Z_STREAM_END      1  */\n  0:      '',                    /* Z_OK              0  */\n  '-1':   'file error',          /* Z_ERRNO         (-1) */\n  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */\n  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */\n  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */\n  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */\n  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2pzemlwL34vcGFrby9saWIvemxpYi9tZXNzYWdlcy5qcz81Yjk0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMjkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAyOiAgICAgICduZWVkIGRpY3Rpb25hcnknLCAgICAgLyogWl9ORUVEX0RJQ1QgICAgICAgMiAgKi9cbiAgMTogICAgICAnc3RyZWFtIGVuZCcsICAgICAgICAgIC8qIFpfU1RSRUFNX0VORCAgICAgIDEgICovXG4gIDA6ICAgICAgJycsICAgICAgICAgICAgICAgICAgICAvKiBaX09LICAgICAgICAgICAgICAwICAqL1xuICAnLTEnOiAgICdmaWxlIGVycm9yJywgICAgICAgICAgLyogWl9FUlJOTyAgICAgICAgICgtMSkgKi9cbiAgJy0yJzogICAnc3RyZWFtIGVycm9yJywgICAgICAgIC8qIFpfU1RSRUFNX0VSUk9SICAoLTIpICovXG4gICctMyc6ICAgJ2RhdGEgZXJyb3InLCAgICAgICAgICAvKiBaX0RBVEFfRVJST1IgICAgKC0zKSAqL1xuICAnLTQnOiAgICdpbnN1ZmZpY2llbnQgbWVtb3J5JywgLyogWl9NRU1fRVJST1IgICAgICgtNCkgKi9cbiAgJy01JzogICAnYnVmZmVyIGVycm9yJywgICAgICAgIC8qIFpfQlVGX0VSUk9SICAgICAoLTUpICovXG4gICctNic6ICAgJ2luY29tcGF0aWJsZSB2ZXJzaW9uJyAvKiBaX1ZFUlNJT05fRVJST1IgKC02KSAqL1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9qc3ppcC9+L3Bha28vbGliL3psaWIvbWVzc2FnZXMuanNcbi8vIG1vZHVsZSBpZCA9IDI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar Promise = __webpack_require__(10);\nvar INTERNAL = __webpack_require__(9);\nvar handlers = __webpack_require__(4);\nmodule.exports = reject;\n\nfunction reject(reason) {\n\tvar promise = new Promise(INTERNAL);\n\treturn handlers.reject(promise, reason);\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2xpZS9saWIvcmVqZWN0LmpzPzcwZjUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMzAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBQcm9taXNlID0gcmVxdWlyZSgnLi9wcm9taXNlJyk7XG52YXIgSU5URVJOQUwgPSByZXF1aXJlKCcuL0lOVEVSTkFMJyk7XG52YXIgaGFuZGxlcnMgPSByZXF1aXJlKCcuL2hhbmRsZXJzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlamVjdDtcblxuZnVuY3Rpb24gcmVqZWN0KHJlYXNvbikge1xuXHR2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcblx0cmV0dXJuIGhhbmRsZXJzLnJlamVjdChwcm9taXNlLCByZWFzb24pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9saWUvbGliL3JlamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar Promise = __webpack_require__(10);\nvar INTERNAL = __webpack_require__(9);\nvar handlers = __webpack_require__(4);\nmodule.exports = resolve;\n\nvar FALSE = handlers.resolve(new Promise(INTERNAL), false);\nvar NULL = handlers.resolve(new Promise(INTERNAL), null);\nvar UNDEFINED = handlers.resolve(new Promise(INTERNAL), void 0);\nvar ZERO = handlers.resolve(new Promise(INTERNAL), 0);\nvar EMPTYSTRING = handlers.resolve(new Promise(INTERNAL), '');\n\nfunction resolve(value) {\n  if (value) {\n    if (value instanceof Promise) {\n      return value;\n    }\n    return handlers.resolve(new Promise(INTERNAL), value);\n  }\n  var valueType = typeof value;\n  switch (valueType) {\n    case 'boolean':\n      return FALSE;\n    case 'undefined':\n      return UNDEFINED;\n    case 'object':\n      return NULL;\n    case 'number':\n      return ZERO;\n    case 'string':\n      return EMPTYSTRING;\n  }\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2xpZS9saWIvcmVzb2x2ZS5qcz85NTMyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjMxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUHJvbWlzZSA9IHJlcXVpcmUoJy4vcHJvbWlzZScpO1xudmFyIElOVEVSTkFMID0gcmVxdWlyZSgnLi9JTlRFUk5BTCcpO1xudmFyIGhhbmRsZXJzID0gcmVxdWlyZSgnLi9oYW5kbGVycycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXNvbHZlO1xuXG52YXIgRkFMU0UgPSBoYW5kbGVycy5yZXNvbHZlKG5ldyBQcm9taXNlKElOVEVSTkFMKSwgZmFsc2UpO1xudmFyIE5VTEwgPSBoYW5kbGVycy5yZXNvbHZlKG5ldyBQcm9taXNlKElOVEVSTkFMKSwgbnVsbCk7XG52YXIgVU5ERUZJTkVEID0gaGFuZGxlcnMucmVzb2x2ZShuZXcgUHJvbWlzZShJTlRFUk5BTCksIHZvaWQgMCk7XG52YXIgWkVSTyA9IGhhbmRsZXJzLnJlc29sdmUobmV3IFByb21pc2UoSU5URVJOQUwpLCAwKTtcbnZhciBFTVBUWVNUUklORyA9IGhhbmRsZXJzLnJlc29sdmUobmV3IFByb21pc2UoSU5URVJOQUwpLCAnJyk7XG5cbmZ1bmN0aW9uIHJlc29sdmUodmFsdWUpIHtcbiAgaWYgKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gaGFuZGxlcnMucmVzb2x2ZShuZXcgUHJvbWlzZShJTlRFUk5BTCksIHZhbHVlKTtcbiAgfVxuICB2YXIgdmFsdWVUeXBlID0gdHlwZW9mIHZhbHVlO1xuICBzd2l0Y2ggKHZhbHVlVHlwZSkge1xuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIEZBTFNFO1xuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICByZXR1cm4gVU5ERUZJTkVEO1xuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICByZXR1cm4gTlVMTDtcbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIFpFUk87XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiBFTVBUWVNUUklORztcbiAgfVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9saWUvbGliL3Jlc29sdmUuanNcbi8vIG1vZHVsZSBpZCA9IDMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("var parseCode = __webpack_require__(136);\nvar extend = __webpack_require__(36);\nvar projections = __webpack_require__(137);\nvar deriveConstants = __webpack_require__(133);\n\nfunction Projection(srsCode,callback) {\n  if (!(this instanceof Projection)) {\n    return new Projection(srsCode);\n  }\n  callback = callback || function(error){\n    if(error){\n      throw error;\n    }\n  };\n  var json = parseCode(srsCode);\n  if(typeof json !== 'object'){\n    callback(srsCode);\n    return;\n  }\n  var modifiedJSON = deriveConstants(json);\n  var ourProj = Projection.projections.get(modifiedJSON.projName);\n  if(ourProj){\n    extend(this, modifiedJSON);\n    extend(this, ourProj);\n    this.init();\n    callback(null, this);\n  }else{\n    callback(srsCode);\n  }\n}\nProjection.projections = projections;\nProjection.projections.start();\nmodule.exports = Projection;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9Qcm9qLmpzP2JkMzQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIzMi5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBwYXJzZUNvZGUgPSByZXF1aXJlKFwiLi9wYXJzZUNvZGVcIik7XG52YXIgZXh0ZW5kID0gcmVxdWlyZSgnLi9leHRlbmQnKTtcbnZhciBwcm9qZWN0aW9ucyA9IHJlcXVpcmUoJy4vcHJvamVjdGlvbnMnKTtcbnZhciBkZXJpdmVDb25zdGFudHMgPSByZXF1aXJlKCcuL2Rlcml2ZUNvbnN0YW50cycpO1xuXG5mdW5jdGlvbiBQcm9qZWN0aW9uKHNyc0NvZGUsY2FsbGJhY2spIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFByb2plY3Rpb24pKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9qZWN0aW9uKHNyc0NvZGUpO1xuICB9XG4gIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24oZXJyb3Ipe1xuICAgIGlmKGVycm9yKXtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfTtcbiAgdmFyIGpzb24gPSBwYXJzZUNvZGUoc3JzQ29kZSk7XG4gIGlmKHR5cGVvZiBqc29uICE9PSAnb2JqZWN0Jyl7XG4gICAgY2FsbGJhY2soc3JzQ29kZSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtb2RpZmllZEpTT04gPSBkZXJpdmVDb25zdGFudHMoanNvbik7XG4gIHZhciBvdXJQcm9qID0gUHJvamVjdGlvbi5wcm9qZWN0aW9ucy5nZXQobW9kaWZpZWRKU09OLnByb2pOYW1lKTtcbiAgaWYob3VyUHJvail7XG4gICAgZXh0ZW5kKHRoaXMsIG1vZGlmaWVkSlNPTik7XG4gICAgZXh0ZW5kKHRoaXMsIG91clByb2opO1xuICAgIHRoaXMuaW5pdCgpO1xuICAgIGNhbGxiYWNrKG51bGwsIHRoaXMpO1xuICB9ZWxzZXtcbiAgICBjYWxsYmFjayhzcnNDb2RlKTtcbiAgfVxufVxuUHJvamVjdGlvbi5wcm9qZWN0aW9ucyA9IHByb2plY3Rpb25zO1xuUHJvamVjdGlvbi5wcm9qZWN0aW9ucy5zdGFydCgpO1xubW9kdWxlLmV4cG9ydHMgPSBQcm9qZWN0aW9uO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Byb2o0L2xpYi9Qcm9qLmpzXG4vLyBtb2R1bGUgaWQgPSAzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports){eval("module.exports = function(a, e, sinphi) {\n  var temp = e * sinphi;\n  return a / Math.sqrt(1 - temp * temp);\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9jb21tb24vZ04uanM/ZTVhYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIzMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYSwgZSwgc2lucGhpKSB7XG4gIHZhciB0ZW1wID0gZSAqIHNpbnBoaTtcbiAgcmV0dXJuIGEgLyBNYXRoLnNxcnQoMSAtIHRlbXAgKiB0ZW1wKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Byb2o0L2xpYi9jb21tb24vZ04uanNcbi8vIG1vZHVsZSBpZCA9IDMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports){eval('module.exports = function(ml, e0, e1, e2, e3) {\n  var phi;\n  var dphi;\n\n  phi = ml / e0;\n  for (var i = 0; i < 15; i++) {\n    dphi = (ml - (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi))) / (e0 - 2 * e1 * Math.cos(2 * phi) + 4 * e2 * Math.cos(4 * phi) - 6 * e3 * Math.cos(6 * phi));\n    phi += dphi;\n    if (Math.abs(dphi) <= 0.0000000001) {\n      return phi;\n    }\n  }\n\n  //..reportError("IMLFN-CONV:Latitude failed to converge after 15 iterations");\n  return NaN;\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9jb21tb24vaW1sZm4uanM/ODU4NiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwiZmlsZSI6IjM0LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtbCwgZTAsIGUxLCBlMiwgZTMpIHtcbiAgdmFyIHBoaTtcbiAgdmFyIGRwaGk7XG5cbiAgcGhpID0gbWwgLyBlMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNTsgaSsrKSB7XG4gICAgZHBoaSA9IChtbCAtIChlMCAqIHBoaSAtIGUxICogTWF0aC5zaW4oMiAqIHBoaSkgKyBlMiAqIE1hdGguc2luKDQgKiBwaGkpIC0gZTMgKiBNYXRoLnNpbig2ICogcGhpKSkpIC8gKGUwIC0gMiAqIGUxICogTWF0aC5jb3MoMiAqIHBoaSkgKyA0ICogZTIgKiBNYXRoLmNvcyg0ICogcGhpKSAtIDYgKiBlMyAqIE1hdGguY29zKDYgKiBwaGkpKTtcbiAgICBwaGkgKz0gZHBoaTtcbiAgICBpZiAoTWF0aC5hYnMoZHBoaSkgPD0gMC4wMDAwMDAwMDAxKSB7XG4gICAgICByZXR1cm4gcGhpO1xuICAgIH1cbiAgfVxuXG4gIC8vLi5yZXBvcnRFcnJvcihcIklNTEZOLUNPTlY6TGF0aXR1ZGUgZmFpbGVkIHRvIGNvbnZlcmdlIGFmdGVyIDE1IGl0ZXJhdGlvbnNcIik7XG4gIHJldHVybiBOYU47XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcm9qNC9saWIvY29tbW9uL2ltbGZuLmpzXG4vLyBtb2R1bGUgaWQgPSAzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9')},function(module,exports){eval("module.exports = function(eccent, sinphi) {\n  var con;\n  if (eccent > 1.0e-7) {\n    con = eccent * sinphi;\n    return ((1 - eccent * eccent) * (sinphi / (1 - con * con) - (0.5 / eccent) * Math.log((1 - con) / (1 + con))));\n  }\n  else {\n    return (2 * sinphi);\n  }\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9jb21tb24vcXNmbnouanM/N2M3MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIzNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZWNjZW50LCBzaW5waGkpIHtcbiAgdmFyIGNvbjtcbiAgaWYgKGVjY2VudCA+IDEuMGUtNykge1xuICAgIGNvbiA9IGVjY2VudCAqIHNpbnBoaTtcbiAgICByZXR1cm4gKCgxIC0gZWNjZW50ICogZWNjZW50KSAqIChzaW5waGkgLyAoMSAtIGNvbiAqIGNvbikgLSAoMC41IC8gZWNjZW50KSAqIE1hdGgubG9nKCgxIC0gY29uKSAvICgxICsgY29uKSkpKTtcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gKDIgKiBzaW5waGkpO1xuICB9XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcm9qNC9saWIvY29tbW9uL3FzZm56LmpzXG4vLyBtb2R1bGUgaWQgPSAzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports){eval("module.exports = function(destination, source) {\n  destination = destination || {};\n  var value, property;\n  if (!source) {\n    return destination;\n  }\n  for (property in source) {\n    value = source[property];\n    if (value !== undefined) {\n      destination[property] = value;\n    }\n  }\n  return destination;\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9leHRlbmQuanM/ZWE5MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjM2LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkZXN0aW5hdGlvbiwgc291cmNlKSB7XG4gIGRlc3RpbmF0aW9uID0gZGVzdGluYXRpb24gfHwge307XG4gIHZhciB2YWx1ZSwgcHJvcGVydHk7XG4gIGlmICghc291cmNlKSB7XG4gICAgcmV0dXJuIGRlc3RpbmF0aW9uO1xuICB9XG4gIGZvciAocHJvcGVydHkgaW4gc291cmNlKSB7XG4gICAgdmFsdWUgPSBzb3VyY2VbcHJvcGVydHldO1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBkZXN0aW5hdGlvbltwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlc3RpbmF0aW9uO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcm9qNC9saWIvZXh0ZW5kLmpzXG4vLyBtb2R1bGUgaWQgPSAzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports){eval('(function (root, factory) {\n\n  // Node.\n  if(typeof module === \'object\' && typeof module.exports === \'object\') {\n    exports = module.exports = factory();\n  }\n\n  // Browser Global.\n  if(typeof window === "object") {\n    root.Terraformer = factory();\n  }\n\n}(this, function(){\n  var exports = {},\n      EarthRadius = 6378137,\n      DegreesPerRadian = 57.295779513082320,\n      RadiansPerDegree =  0.017453292519943,\n      MercatorCRS = {\n        "type": "link",\n        "properties": {\n          "href": "http://spatialreference.org/ref/sr-org/6928/ogcwkt/",\n          "type": "ogcwkt"\n        }\n      },\n      GeographicCRS = {\n        "type": "link",\n        "properties": {\n          "href": "http://spatialreference.org/ref/epsg/4326/ogcwkt/",\n          "type": "ogcwkt"\n        }\n      };\n\n  /*\n  Internal: isArray function\n  */\n  function isArray(obj) {\n    return Object.prototype.toString.call(obj) === "[object Array]";\n  }\n\n  /*\n  Internal: safe warning\n  */\n  function warn() {\n    var args = Array.prototype.slice.apply(arguments);\n\n    if (typeof console !== undefined && console.warn) {\n      console.warn.apply(console, args);\n    }\n  }\n\n  /*\n  Internal: Extend one object with another.\n  */\n  function extend(destination, source) {\n    for (var k in source) {\n      if (source.hasOwnProperty(k)) {\n        destination[k] = source[k];\n      }\n    }\n    return destination;\n  }\n\n  /*\n  Public: Calculate an bounding box for a geojson object\n  */\n  function calculateBounds (geojson) {\n    if(geojson.type){\n      switch (geojson.type) {\n        case \'Point\':\n          return [ geojson.coordinates[0], geojson.coordinates[1], geojson.coordinates[0], geojson.coordinates[1]];\n\n        case \'MultiPoint\':\n          return calculateBoundsFromArray(geojson.coordinates);\n\n        case \'LineString\':\n          return calculateBoundsFromArray(geojson.coordinates);\n\n        case \'MultiLineString\':\n          return calculateBoundsFromNestedArrays(geojson.coordinates);\n\n        case \'Polygon\':\n          return calculateBoundsFromNestedArrays(geojson.coordinates);\n\n        case \'MultiPolygon\':\n          return calculateBoundsFromNestedArrayOfArrays(geojson.coordinates);\n\n        case \'Feature\':\n          return geojson.geometry? calculateBounds(geojson.geometry) : null;\n\n        case \'FeatureCollection\':\n          return calculateBoundsForFeatureCollection(geojson);\n\n        case \'GeometryCollection\':\n          return calculateBoundsForGeometryCollection(geojson);\n\n        default:\n          throw new Error("Unknown type: " + geojson.type);\n      }\n    }\n    return null;\n  }\n\n  /*\n  Internal: Calculate an bounding box from an nested array of positions\n  [\n    [\n      [ [lng, lat],[lng, lat],[lng, lat] ]\n    ]\n    [\n      [lng, lat],[lng, lat],[lng, lat]\n    ]\n    [\n      [lng, lat],[lng, lat],[lng, lat]\n    ]\n  ]\n  */\n  function calculateBoundsFromNestedArrays (array) {\n    var x1 = null, x2 = null, y1 = null, y2 = null;\n\n    for (var i = 0; i < array.length; i++) {\n      var inner = array[i];\n\n      for (var j = 0; j < inner.length; j++) {\n        var lonlat = inner[j];\n\n        var lon = lonlat[0];\n        var lat = lonlat[1];\n\n        if (x1 === null) {\n          x1 = lon;\n        } else if (lon < x1) {\n          x1 = lon;\n        }\n\n        if (x2 === null) {\n          x2 = lon;\n        } else if (lon > x2) {\n          x2 = lon;\n        }\n\n        if (y1 === null) {\n          y1 = lat;\n        } else if (lat < y1) {\n          y1 = lat;\n        }\n\n        if (y2 === null) {\n          y2 = lat;\n        } else if (lat > y2) {\n          y2 = lat;\n        }\n      }\n    }\n\n    return [x1, y1, x2, y2 ];\n  }\n\n  /*\n  Internal: Calculate a bounding box from an array of arrays of arrays\n  [\n    [ [lng, lat],[lng, lat],[lng, lat] ]\n    [ [lng, lat],[lng, lat],[lng, lat] ]\n    [ [lng, lat],[lng, lat],[lng, lat] ]\n  ]\n  */\n  function calculateBoundsFromNestedArrayOfArrays (array) {\n    var x1 = null, x2 = null, y1 = null, y2 = null;\n\n    for (var i = 0; i < array.length; i++) {\n      var inner = array[i];\n\n      for (var j = 0; j < inner.length; j++) {\n        var innerinner = inner[j];\n        for (var k = 0; k < innerinner.length; k++) {\n          var lonlat = innerinner[k];\n\n          var lon = lonlat[0];\n          var lat = lonlat[1];\n\n          if (x1 === null) {\n            x1 = lon;\n          } else if (lon < x1) {\n            x1 = lon;\n          }\n\n          if (x2 === null) {\n            x2 = lon;\n          } else if (lon > x2) {\n            x2 = lon;\n          }\n\n          if (y1 === null) {\n            y1 = lat;\n          } else if (lat < y1) {\n            y1 = lat;\n          }\n\n          if (y2 === null) {\n            y2 = lat;\n          } else if (lat > y2) {\n            y2 = lat;\n          }\n        }\n      }\n    }\n\n    return [x1, y1, x2, y2];\n  }\n\n  /*\n  Internal: Calculate a bounding box from an array of positions\n  [\n    [lng, lat],[lng, lat],[lng, lat]\n  ]\n  */\n  function calculateBoundsFromArray (array) {\n    var x1 = null, x2 = null, y1 = null, y2 = null;\n\n    for (var i = 0; i < array.length; i++) {\n      var lonlat = array[i];\n      var lon = lonlat[0];\n      var lat = lonlat[1];\n\n      if (x1 === null) {\n        x1 = lon;\n      } else if (lon < x1) {\n        x1 = lon;\n      }\n\n      if (x2 === null) {\n        x2 = lon;\n      } else if (lon > x2) {\n        x2 = lon;\n      }\n\n      if (y1 === null) {\n        y1 = lat;\n      } else if (lat < y1) {\n        y1 = lat;\n      }\n\n      if (y2 === null) {\n        y2 = lat;\n      } else if (lat > y2) {\n        y2 = lat;\n      }\n    }\n\n    return [x1, y1, x2, y2 ];\n  }\n\n  /*\n  Internal: Calculate an bounding box for a feature collection\n  */\n  function calculateBoundsForFeatureCollection(featureCollection){\n    var extents = [], extent;\n    for (var i = featureCollection.features.length - 1; i >= 0; i--) {\n      extent = calculateBounds(featureCollection.features[i].geometry);\n      extents.push([extent[0],extent[1]]);\n      extents.push([extent[2],extent[3]]);\n    }\n\n    return calculateBoundsFromArray(extents);\n  }\n\n  /*\n  Internal: Calculate an bounding box for a geometry collection\n  */\n  function calculateBoundsForGeometryCollection(geometryCollection){\n    var extents = [], extent;\n\n    for (var i = geometryCollection.geometries.length - 1; i >= 0; i--) {\n      extent = calculateBounds(geometryCollection.geometries[i]);\n      extents.push([extent[0],extent[1]]);\n      extents.push([extent[2],extent[3]]);\n    }\n\n    return calculateBoundsFromArray(extents);\n  }\n\n  function calculateEnvelope(geojson){\n    var bounds = calculateBounds(geojson);\n    return {\n      x: bounds[0],\n      y: bounds[1],\n      w: Math.abs(bounds[0] - bounds[2]),\n      h: Math.abs(bounds[1] - bounds[3])\n    };\n  }\n\n  /*\n  Internal: Convert radians to degrees. Used by spatial reference converters.\n  */\n  function radToDeg(rad) {\n    return rad * DegreesPerRadian;\n  }\n\n  /*\n  Internal: Convert degrees to radians. Used by spatial reference converters.\n  */\n  function degToRad(deg) {\n    return deg * RadiansPerDegree;\n  }\n\n  /*\n  Internal: Loop over each array in a geojson object and apply a function to it. Used by spatial reference converters.\n  */\n  function eachPosition(coordinates, func) {\n    for (var i = 0; i < coordinates.length; i++) {\n      // we found a number so lets convert this pair\n      if(typeof coordinates[i][0] === "number"){\n        coordinates[i] = func(coordinates[i]);\n      }\n      // we found an coordinates array it again and run THIS function against it\n      if(typeof coordinates[i] === "object"){\n        coordinates[i] = eachPosition(coordinates[i], func);\n      }\n    }\n    return coordinates;\n  }\n\n  /*\n  Public: Convert a GeoJSON Position object to Geographic (4326)\n  */\n  function positionToGeographic(position) {\n    var x = position[0];\n    var y = position[1];\n    return [radToDeg(x / EarthRadius) - (Math.floor((radToDeg(x / EarthRadius) + 180) / 360) * 360), radToDeg((Math.PI / 2) - (2 * Math.atan(Math.exp(-1.0 * y / EarthRadius))))];\n  }\n\n  /*\n  Public: Convert a GeoJSON Position object to Web Mercator (102100)\n  */\n  function positionToMercator(position) {\n    var lng = position[0];\n    var lat = Math.max(Math.min(position[1], 89.99999), -89.99999);\n    return [degToRad(lng) * EarthRadius, EarthRadius/2.0 * Math.log( (1.0 + Math.sin(degToRad(lat))) / (1.0 - Math.sin(degToRad(lat))) )];\n  }\n\n  /*\n  Public: Apply a function agaist all positions in a geojson object. Used by spatial reference converters.\n  */\n  function applyConverter(geojson, converter, noCrs){\n    if(geojson.type === "Point") {\n      geojson.coordinates = converter(geojson.coordinates);\n    } else if(geojson.type === "Feature") {\n      geojson.geometry = applyConverter(geojson.geometry, converter, true);\n    } else if(geojson.type === "FeatureCollection") {\n      for (var f = 0; f < geojson.features.length; f++) {\n        geojson.features[f] = applyConverter(geojson.features[f], converter, true);\n      }\n    } else if(geojson.type === "GeometryCollection") {\n      for (var g = 0; g < geojson.geometries.length; g++) {\n        geojson.geometries[g] = applyConverter(geojson.geometries[g], converter, true);\n      }\n    } else {\n      geojson.coordinates = eachPosition(geojson.coordinates, converter);\n    }\n\n    if(!noCrs){\n      if(converter === positionToMercator){\n        geojson.crs = MercatorCRS;\n      }\n    }\n\n    if(converter === positionToGeographic){\n      delete geojson.crs;\n    }\n\n    return geojson;\n  }\n\n  /*\n  Public: Convert a GeoJSON object to ESRI Web Mercator (102100)\n  */\n  function toMercator(geojson) {\n    return applyConverter(geojson, positionToMercator);\n  }\n\n  /*\n  Convert a GeoJSON object to Geographic coordinates (WSG84, 4326)\n  */\n  function toGeographic(geojson) {\n    return applyConverter(geojson, positionToGeographic);\n  }\n\n\n  /*\n  Internal: -1,0,1 comparison function\n  */\n  function cmp(a, b) {\n    if(a < b) {\n      return -1;\n    } else if(a > b) {\n      return 1;\n    } else {\n      return 0;\n    }\n  }\n\n  /*\n  Internal: used for sorting\n  */\n  function compSort(p1, p2) {\n    if (p1[0] > p2[0]) {\n      return -1;\n    } else if (p1[0] < p2[0]) {\n      return 1;\n    } else if (p1[1] > p2[1]) {\n      return -1;\n    } else if (p1[1] < p2[1]) {\n      return 1;\n    } else {\n      return 0;\n    }\n  }\n\n\n  /*\n  Internal: used to determine turn\n  */\n  function turn(p, q, r) {\n    // Returns -1, 0, 1 if p,q,r forms a right, straight, or left turn.\n    return cmp((q[0] - p[0]) * (r[1] - p[1]) - (r[0] - p[0]) * (q[1] - p[1]), 0);\n  }\n\n  /*\n  Internal: used to determine euclidean distance between two points\n  */\n  function euclideanDistance(p, q) {\n    // Returns the squared Euclidean distance between p and q.\n    var dx = q[0] - p[0];\n    var dy = q[1] - p[1];\n\n    return dx * dx + dy * dy;\n  }\n\n  function nextHullPoint(points, p) {\n    // Returns the next point on the convex hull in CCW from p.\n    var q = p;\n    for(var r in points) {\n      var t = turn(p, q, points[r]);\n      if(t === -1 || t === 0 && euclideanDistance(p, points[r]) > euclideanDistance(p, q)) {\n        q = points[r];\n      }\n    }\n    return q;\n  }\n\n  function convexHull(points) {\n    // implementation of the Jarvis March algorithm\n    // adapted from http://tixxit.wordpress.com/2009/12/09/jarvis-march/\n\n    if(points.length === 0) {\n      return [];\n    } else if(points.length === 1) {\n      return points;\n    }\n\n    // Returns the points on the convex hull of points in CCW order.\n    var hull = [points.sort(compSort)[0]];\n\n    for(var p = 0; p < hull.length; p++) {\n      var q = nextHullPoint(points, hull[p]);\n\n      if(q !== hull[0]) {\n        hull.push(q);\n      }\n    }\n\n    return hull;\n  }\n\n  function isConvex(points) {\n    var ltz;\n\n    for (var i = 0; i < points.length - 3; i++) {\n      var p1 = points[i];\n      var p2 = points[i + 1];\n      var p3 = points[i + 2];\n      var v = [p2[0] - p1[0], p2[1] - p1[1]];\n\n      // p3.x * v.y - p3.y * v.x + v.x * p1.y - v.y * p1.x\n      var res = p3[0] * v[1] - p3[1] * v[0] + v[0] * p1[1] - v[1] * p1[0];\n\n      if (i === 0) {\n        if (res < 0) {\n          ltz = true;\n        } else {\n          ltz = false;\n        }\n      } else {\n        if (ltz && (res > 0) || !ltz && (res < 0)) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  function coordinatesContainPoint(coordinates, point) {\n    var contains = false;\n    for(var i = -1, l = coordinates.length, j = l - 1; ++i < l; j = i) {\n      if (((coordinates[i][1] <= point[1] && point[1] < coordinates[j][1]) ||\n           (coordinates[j][1] <= point[1] && point[1] < coordinates[i][1])) &&\n          (point[0] < (coordinates[j][0] - coordinates[i][0]) * (point[1] - coordinates[i][1]) / (coordinates[j][1] - coordinates[i][1]) + coordinates[i][0])) {\n        contains = !contains;\n      }\n    }\n    return contains;\n  }\n\n  function polygonContainsPoint(polygon, point) {\n    if (polygon && polygon.length) {\n      if (polygon.length === 1) { // polygon with no holes\n        return coordinatesContainPoint(polygon[0], point);\n      } else { // polygon with holes\n        if (coordinatesContainPoint(polygon[0], point)) {\n          for (var i = 1; i < polygon.length; i++) {\n            if (coordinatesContainPoint(polygon[i], point)) {\n              return false; // found in hole\n            }\n          }\n\n          return true;\n        } else {\n          return false;\n        }\n      }\n    } else {\n      return false;\n    }\n  }\n\n  function edgeIntersectsEdge(a1, a2, b1, b2) {\n    var ua_t = (b2[0] - b1[0]) * (a1[1] - b1[1]) - (b2[1] - b1[1]) * (a1[0] - b1[0]);\n    var ub_t = (a2[0] - a1[0]) * (a1[1] - b1[1]) - (a2[1] - a1[1]) * (a1[0] - b1[0]);\n    var u_b  = (b2[1] - b1[1]) * (a2[0] - a1[0]) - (b2[0] - b1[0]) * (a2[1] - a1[1]);\n\n    if ( u_b !== 0 ) {\n      var ua = ua_t / u_b;\n      var ub = ub_t / u_b;\n\n      if ( 0 <= ua && ua <= 1 && 0 <= ub && ub <= 1 ) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function isNumber(n) {\n    return !isNaN(parseFloat(n)) && isFinite(n);\n  }\n\n  function arraysIntersectArrays(a, b) {\n    if (isNumber(a[0][0])) {\n      if (isNumber(b[0][0])) {\n        for (var i = 0; i < a.length - 1; i++) {\n          for (var j = 0; j < b.length - 1; j++) {\n            if (edgeIntersectsEdge(a[i], a[i + 1], b[j], b[j + 1])) {\n              return true;\n            }\n          }\n        }\n      } else {\n        for (var k = 0; k < b.length; k++) {\n          if (arraysIntersectArrays(a, b[k])) {\n            return true;\n          }\n        }\n      }\n    } else {\n      for (var l = 0; l < a.length; l++) {\n        if (arraysIntersectArrays(a[l], b)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /*\n  Internal: Returns a copy of coordinates for s closed polygon\n  */\n  function closedPolygon(coordinates) {\n    var outer = [ ];\n\n    for (var i = 0; i < coordinates.length; i++) {\n      var inner = coordinates[i].slice();\n      if (pointsEqual(inner[0], inner[inner.length - 1]) === false) {\n        inner.push(inner[0]);\n      }\n\n      outer.push(inner);\n    }\n\n    return outer;\n  }\n\n  function pointsEqual(a, b) {\n    for (var i = 0; i < a.length; i++) {\n\n      if (a[i] !== b[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function coordinatesEqual(a, b) {\n    if (a.length !== b.length) {\n      return false;\n    }\n\n    var na = a.slice().sort(compSort);\n    var nb = b.slice().sort(compSort);\n\n    for (var i = 0; i < na.length; i++) {\n      if (na[i].length !== nb[i].length) {\n        return false;\n      }\n      for (var j = 0; j < na.length; j++) {\n        if (na[i][j] !== nb[i][j]) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  /*\n  Internal: An array of variables that will be excluded form JSON objects.\n  */\n  var excludeFromJSON = ["length"];\n\n  /*\n  Internal: Base GeoJSON Primitive\n  */\n  function Primitive(geojson){\n    if(geojson){\n      switch (geojson.type) {\n      case \'Point\':\n        return new Point(geojson);\n\n      case \'MultiPoint\':\n        return new MultiPoint(geojson);\n\n      case \'LineString\':\n        return new LineString(geojson);\n\n      case \'MultiLineString\':\n        return new MultiLineString(geojson);\n\n      case \'Polygon\':\n        return new Polygon(geojson);\n\n      case \'MultiPolygon\':\n        return new MultiPolygon(geojson);\n\n      case \'Feature\':\n        return new Feature(geojson);\n\n      case \'FeatureCollection\':\n        return new FeatureCollection(geojson);\n\n      case \'GeometryCollection\':\n        return new GeometryCollection(geojson);\n\n      default:\n        throw new Error("Unknown type: " + geojson.type);\n      }\n    }\n  }\n\n  Primitive.prototype.toMercator = function(){\n    return toMercator(this);\n  };\n\n  Primitive.prototype.toGeographic = function(){\n    return toGeographic(this);\n  };\n\n  Primitive.prototype.envelope = function(){\n    return calculateEnvelope(this);\n  };\n\n  Primitive.prototype.bbox = function(){\n    return calculateBounds(this);\n  };\n\n  Primitive.prototype.convexHull = function(){\n    var coordinates = [ ], i, j;\n    if (this.type === \'Point\') {\n      return null;\n    } else if (this.type === \'LineString\' || this.type === \'MultiPoint\') {\n      if (this.coordinates && this.coordinates.length >= 3) {\n        coordinates = this.coordinates;\n      } else {\n        return null;\n      }\n    } else if (this.type === \'Polygon\' || this.type === \'MultiLineString\') {\n      if (this.coordinates && this.coordinates.length > 0) {\n        for (i = 0; i < this.coordinates.length; i++) {\n          coordinates = coordinates.concat(this.coordinates[i]);\n        }\n        if(coordinates.length < 3){\n          return null;\n        }\n      } else {\n        return null;\n      }\n    } else if (this.type === \'MultiPolygon\') {\n      if (this.coordinates && this.coordinates.length > 0) {\n        for (i = 0; i < this.coordinates.length; i++) {\n          for (j = 0; j < this.coordinates[i].length; j++) {\n            coordinates = coordinates.concat(this.coordinates[i][j]);\n          }\n        }\n        if(coordinates.length < 3){\n          return null;\n        }\n      } else {\n        return null;\n      }\n    } else if(this.type === "Feature"){\n      var primitive = new Primitive(this.geometry);\n      return primitive.convexHull();\n    }\n\n    return new Polygon({\n      type: \'Polygon\',\n      coordinates: closedPolygon([convexHull(coordinates)])\n    });\n  };\n\n  Primitive.prototype.toJSON = function(){\n    var obj = {};\n    for (var key in this) {\n      if (this.hasOwnProperty(key) && excludeFromJSON.indexOf(key) === -1) {\n        obj[key] = this[key];\n      }\n    }\n    obj.bbox = calculateBounds(this);\n    return obj;\n  };\n\n  Primitive.prototype.contains = function(primitive){\n    return new Primitive(primitive).within(this);\n  };\n\n  Primitive.prototype.within = function(primitive) {\n    var coordinates, i, contains;\n\n    // if we are passed a feature, use the polygon inside instead\n    if (primitive.type === \'Feature\') {\n      primitive = primitive.geometry;\n    }\n\n    // point.within(point) :: equality\n    if (primitive.type === "Point") {\n      if (this.type === "Point") {\n        return pointsEqual(this.coordinates, primitive.coordinates);\n\n      }\n    }\n\n    // point.within(multilinestring)\n    if (primitive.type === "MultiLineString") {\n      if (this.type === "Point") {\n        for (i = 0; i < primitive.coordinates.length; i++) {\n          var linestring = { type: "LineString", coordinates: primitive.coordinates[i] };\n\n          if (this.within(linestring)) {\n            return true;\n          }\n        }\n      }\n    }\n\n    // point.within(linestring), point.within(multipoint)\n    if (primitive.type === "LineString" || primitive.type === "MultiPoint") {\n      if (this.type === "Point") {\n        for (i = 0; i < primitive.coordinates.length; i++) {\n          if (this.coordinates.length !== primitive.coordinates[i].length) {\n            return false;\n          }\n\n          if (pointsEqual(this.coordinates, primitive.coordinates[i])) {\n            return true;\n          }\n        }\n      }\n    }\n\n    if (primitive.type === "Polygon") {\n      // polygon.within(polygon)\n      if (this.type === "Polygon") {\n        // check for equal polygons\n        if (primitive.coordinates.length === this.coordinates.length) {\n          for (i = 0; i < this.coordinates.length; i++) {\n            if (coordinatesEqual(this.coordinates[i], primitive.coordinates[i])) {\n              return true;\n            }\n          }\n        }\n\n        if (this.coordinates.length && polygonContainsPoint(primitive.coordinates, this.coordinates[0][0])) {\n          return !arraysIntersectArrays(closedPolygon(this.coordinates), closedPolygon(primitive.coordinates));\n        } else {\n          return false;\n        }\n\n      // point.within(polygon)\n      } else if (this.type === "Point") {\n        return polygonContainsPoint(primitive.coordinates, this.coordinates);\n\n      // linestring/multipoint withing polygon\n      } else if (this.type === "LineString" || this.type === "MultiPoint") {\n        if (!this.coordinates || this.coordinates.length === 0) {\n          return false;\n        }\n\n        for (i = 0; i < this.coordinates.length; i++) {\n          if (polygonContainsPoint(primitive.coordinates, this.coordinates[i]) === false) {\n            return false;\n          }\n        }\n\n        return true;\n\n      // multilinestring.within(polygon)\n      } else if (this.type === "MultiLineString") {\n        for (i = 0; i < this.coordinates.length; i++) {\n          var ls = new LineString(this.coordinates[i]);\n\n          if (ls.within(primitive) === false) {\n            contains++;\n            return false;\n          }\n        }\n\n        return true;\n\n      // multipolygon.within(polygon)\n      } else if (this.type === "MultiPolygon") {\n        for (i = 0; i < this.coordinates.length; i++) {\n          var p1 = new Primitive({ type: "Polygon", coordinates: this.coordinates[i] });\n\n          if (p1.within(primitive) === false) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n\n    }\n\n    if (primitive.type === "MultiPolygon") {\n      // point.within(multipolygon)\n      if (this.type === "Point") {\n        if (primitive.coordinates.length) {\n          for (i = 0; i < primitive.coordinates.length; i++) {\n            coordinates = primitive.coordinates[i];\n            if (polygonContainsPoint(coordinates, this.coordinates) && arraysIntersectArrays([this.coordinates], primitive.coordinates) === false) {\n              return true;\n            }\n          }\n        }\n\n        return false;\n      // polygon.within(multipolygon)\n      } else if (this.type === "Polygon") {\n        for (i = 0; i < this.coordinates.length; i++) {\n          if (primitive.coordinates[i].length === this.coordinates.length) {\n            for (j = 0; j < this.coordinates.length; j++) {\n              if (coordinatesEqual(this.coordinates[j], primitive.coordinates[i][j])) {\n                return true;\n              }\n            }\n          }\n        }\n\n        if (arraysIntersectArrays(this.coordinates, primitive.coordinates) === false) {\n          if (primitive.coordinates.length) {\n            for (i = 0; i < primitive.coordinates.length; i++) {\n              coordinates = primitive.coordinates[i];\n              if (polygonContainsPoint(coordinates, this.coordinates[0][0]) === false) {\n                contains = false;\n              } else {\n                contains = true;\n              }\n            }\n\n            return contains;\n          }\n        }\n\n      // linestring.within(multipolygon), multipoint.within(multipolygon)\n      } else if (this.type === "LineString" || this.type === "MultiPoint") {\n        for (i = 0; i < primitive.coordinates.length; i++) {\n          var p = { type: "Polygon", coordinates: primitive.coordinates[i] };\n\n          if (this.within(p)) {\n            return true;\n          }\n\n          return false;\n        }\n\n      // multilinestring.within(multipolygon)\n      } else if (this.type === "MultiLineString") {\n        for (i = 0; i < this.coordinates.length; i++) {\n          var lines = new LineString(this.coordinates[i]);\n\n          if (lines.within(primitive) === false) {\n            return false;\n          }\n        }\n\n        return true;\n\n      // multipolygon.within(multipolygon)\n      } else if (this.type === "MultiPolygon") {\n        for (i = 0; i < primitive.coordinates.length; i++) {\n          var mpoly = { type: "Polygon", coordinates: primitive.coordinates[i] };\n\n          if (this.within(mpoly) === false) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n    }\n\n    // default to false\n    return false;\n  };\n\n  Primitive.prototype.intersects = function(primitive) {\n    // if we are passed a feature, use the polygon inside instead\n    if (primitive.type === \'Feature\') {\n      primitive = primitive.geometry;\n    }\n\n    var p = new Primitive(primitive);\n    if (this.within(primitive) || p.within(this)) {\n      return true;\n    }\n\n\n    if (this.type !== \'Point\' && this.type !== \'MultiPoint\' &&\n        primitive.type !== \'Point\' && primitive.type !== \'MultiPoint\') {\n      return arraysIntersectArrays(this.coordinates, primitive.coordinates);\n    } else if (this.type === \'Feature\') {\n      // in the case of a Feature, use the internal primitive for intersection\n      var inner = new Primitive(this.geometry);\n      return inner.intersects(primitive);\n    }\n\n    warn("Type " + this.type + " to " + primitive.type + " intersection is not supported by intersects");\n    return false;\n  };\n\n\n  /*\n  GeoJSON Point Class\n    new Point();\n    new Point(x,y,z,wtf);\n    new Point([x,y,z,wtf]);\n    new Point([x,y]);\n    new Point({\n      type: "Point",\n      coordinates: [x,y]\n    });\n  */\n  function Point(input){\n    var args = Array.prototype.slice.call(arguments);\n\n    if(input && input.type === "Point" && input.coordinates){\n      extend(this, input);\n    } else if(input && isArray(input)) {\n      this.coordinates = input;\n    } else if(args.length >= 2) {\n      this.coordinates = args;\n    } else {\n      throw "Terraformer: invalid input for Terraformer.Point";\n    }\n\n    this.type = "Point";\n  }\n\n  Point.prototype = new Primitive();\n  Point.prototype.constructor = Point;\n\n  /*\n  GeoJSON MultiPoint Class\n      new MultiPoint();\n      new MultiPoint([[x,y], [x1,y1]]);\n      new MultiPoint({\n        type: "MultiPoint",\n        coordinates: [x,y]\n      });\n  */\n  function MultiPoint(input){\n    if(input && input.type === "MultiPoint" && input.coordinates){\n      extend(this, input);\n    } else if(isArray(input)) {\n      this.coordinates = input;\n    } else {\n      throw "Terraformer: invalid input for Terraformer.MultiPoint";\n    }\n\n    this.type = "MultiPoint";\n  }\n\n  MultiPoint.prototype = new Primitive();\n  MultiPoint.prototype.constructor = MultiPoint;\n  MultiPoint.prototype.forEach = function(func){\n    for (var i = 0; i < this.coordinates.length; i++) {\n      func.apply(this, [this.coordinates[i], i, this.coordinates]);\n    }\n    return this;\n  };\n  MultiPoint.prototype.addPoint = function(point){\n    this.coordinates.push(point);\n    return this;\n  };\n  MultiPoint.prototype.insertPoint = function(point, index){\n    this.coordinates.splice(index, 0, point);\n    return this;\n  };\n  MultiPoint.prototype.removePoint = function(remove){\n    if(typeof remove === "number"){\n      this.coordinates.splice(remove, 1);\n    } else {\n      this.coordinates.splice(this.coordinates.indexOf(remove), 1);\n    }\n    return this;\n  };\n  MultiPoint.prototype.get = function(i){\n    return new Point(this.coordinates[i]);\n  };\n\n  /*\n  GeoJSON LineString Class\n      new LineString();\n      new LineString([[x,y], [x1,y1]]);\n      new LineString({\n        type: "LineString",\n        coordinates: [x,y]\n      });\n  */\n  function LineString(input){\n    if(input && input.type === "LineString" && input.coordinates){\n      extend(this, input);\n    } else if(isArray(input)) {\n      this.coordinates = input;\n    } else {\n      throw "Terraformer: invalid input for Terraformer.LineString";\n    }\n\n    this.type = "LineString";\n  }\n\n  LineString.prototype = new Primitive();\n  LineString.prototype.constructor = LineString;\n  LineString.prototype.addVertex = function(point){\n    this.coordinates.push(point);\n    return this;\n  };\n  LineString.prototype.insertVertex = function(point, index){\n    this.coordinates.splice(index, 0, point);\n    return this;\n  };\n  LineString.prototype.removeVertex = function(remove){\n    this.coordinates.splice(remove, 1);\n    return this;\n  };\n\n  /*\n  GeoJSON MultiLineString Class\n      new MultiLineString();\n      new MultiLineString([ [[x,y], [x1,y1]], [[x2,y2], [x3,y3]] ]);\n      new MultiLineString({\n        type: "MultiLineString",\n        coordinates: [ [[x,y], [x1,y1]], [[x2,y2], [x3,y3]] ]\n      });\n  */\n  function MultiLineString(input){\n    if(input && input.type === "MultiLineString" && input.coordinates){\n      extend(this, input);\n    } else if(isArray(input)) {\n      this.coordinates = input;\n    } else {\n      throw "Terraformer: invalid input for Terraformer.MultiLineString";\n    }\n\n    this.type = "MultiLineString";\n  }\n\n  MultiLineString.prototype = new Primitive();\n  MultiLineString.prototype.constructor = MultiLineString;\n  MultiLineString.prototype.forEach = function(func){\n    for (var i = 0; i < this.coordinates.length; i++) {\n      func.apply(this, [this.coordinates[i], i, this.coordinates ]);\n    }\n  };\n  MultiLineString.prototype.get = function(i){\n    return new LineString(this.coordinates[i]);\n  };\n\n  /*\n  GeoJSON Polygon Class\n      new Polygon();\n      new Polygon([ [[x,y], [x1,y1], [x2,y2]] ]);\n      new Polygon({\n        type: "Polygon",\n        coordinates: [ [[x,y], [x1,y1], [x2,y2]] ]\n      });\n  */\n  function Polygon(input){\n    if(input && input.type === "Polygon" && input.coordinates){\n      extend(this, input);\n    } else if(isArray(input)) {\n      this.coordinates = input;\n    } else {\n      throw "Terraformer: invalid input for Terraformer.Polygon";\n    }\n\n    this.type = "Polygon";\n  }\n\n  Polygon.prototype = new Primitive();\n  Polygon.prototype.constructor = Polygon;\n  Polygon.prototype.addVertex = function(point){\n    this.insertVertex(point, this.coordinates[0].length - 1);\n    return this;\n  };\n  Polygon.prototype.insertVertex = function(point, index){\n    this.coordinates[0].splice(index, 0, point);\n    return this;\n  };\n  Polygon.prototype.removeVertex = function(remove){\n    this.coordinates[0].splice(remove, 1);\n    return this;\n  };\n  Polygon.prototype.close = function() {\n    this.coordinates = closedPolygon(this.coordinates);\n  };\n  Polygon.prototype.hasHoles = function() {\n    return this.coordinates.length > 1;\n  };\n  Polygon.prototype.holes = function() {\n    holes = [];\n    if (this.hasHoles()) {\n      for (var i = 1; i < this.coordinates.length; i++) {\n        holes.push(new Polygon([this.coordinates[i]]));\n      }\n    }\n    return holes;\n  };\n\n  /*\n  GeoJSON MultiPolygon Class\n      new MultiPolygon();\n      new MultiPolygon([ [ [[x,y], [x1,y1]], [[x2,y2], [x3,y3]] ] ]);\n      new MultiPolygon({\n        type: "MultiPolygon",\n        coordinates: [ [ [[x,y], [x1,y1]], [[x2,y2], [x3,y3]] ] ]\n      });\n  */\n  function MultiPolygon(input){\n    if(input && input.type === "MultiPolygon" && input.coordinates){\n      extend(this, input);\n    } else if(isArray(input)) {\n      this.coordinates = input;\n    } else {\n      throw "Terraformer: invalid input for Terraformer.MultiPolygon";\n    }\n\n    this.type = "MultiPolygon";\n  }\n\n  MultiPolygon.prototype = new Primitive();\n  MultiPolygon.prototype.constructor = MultiPolygon;\n  MultiPolygon.prototype.forEach = function(func){\n    for (var i = 0; i < this.coordinates.length; i++) {\n      func.apply(this, [this.coordinates[i], i, this.coordinates ]);\n    }\n  };\n  MultiPolygon.prototype.get = function(i){\n    return new Polygon(this.coordinates[i]);\n  };\n  MultiPolygon.prototype.close = function(){\n    var outer = [];\n    this.forEach(function(polygon){\n      outer.push(closedPolygon(polygon));\n    });\n    this.coordinates = outer;\n    return this;\n  };\n\n  /*\n  GeoJSON Feature Class\n      new Feature();\n      new Feature({\n        type: "Feature",\n        geometry: {\n          type: "Polygon",\n          coordinates: [ [ [[x,y], [x1,y1]], [[x2,y2], [x3,y3]] ] ]\n        }\n      });\n      new Feature({\n        type: "Polygon",\n        coordinates: [ [ [[x,y], [x1,y1]], [[x2,y2], [x3,y3]] ] ]\n      });\n  */\n  function Feature(input){\n    if(input && input.type === "Feature"){\n      extend(this, input);\n    } else if(input && input.type && input.coordinates) {\n      this.geometry = input;\n    } else {\n      throw "Terraformer: invalid input for Terraformer.Feature";\n    }\n\n    this.type = "Feature";\n  }\n\n  Feature.prototype = new Primitive();\n  Feature.prototype.constructor = Feature;\n\n  /*\n  GeoJSON FeatureCollection Class\n      new FeatureCollection();\n      new FeatureCollection([feature, feature1]);\n      new FeatureCollection({\n        type: "FeatureCollection",\n        coordinates: [feature, feature1]\n      });\n  */\n  function FeatureCollection(input){\n    if(input && input.type === "FeatureCollection" && input.features){\n      extend(this, input);\n    } else if(isArray(input)) {\n      this.features = input;\n    } else {\n      throw "Terraformer: invalid input for Terraformer.FeatureCollection";\n    }\n\n    this.type = "FeatureCollection";\n  }\n\n  FeatureCollection.prototype = new Primitive();\n  FeatureCollection.prototype.constructor = FeatureCollection;\n  FeatureCollection.prototype.forEach = function(func){\n    for (var i = 0; i < this.features.length; i++) {\n      func.apply(this, [this.features[i], i, this.features]);\n    }\n  };\n  FeatureCollection.prototype.get = function(id){\n    var found;\n    this.forEach(function(feature){\n      if(feature.id === id){\n        found = feature;\n      }\n    });\n    return new Feature(found);\n  };\n\n  /*\n  GeoJSON GeometryCollection Class\n      new GeometryCollection();\n      new GeometryCollection([geometry, geometry1]);\n      new GeometryCollection({\n        type: "GeometryCollection",\n        coordinates: [geometry, geometry1]\n      });\n  */\n  function GeometryCollection(input){\n    if(input && input.type === "GeometryCollection" && input.geometries){\n      extend(this, input);\n    } else if(isArray(input)) {\n      this.geometries = input;\n    } else if(input.coordinates && input.type){\n      this.type = "GeometryCollection";\n      this.geometries = [input];\n    } else {\n      throw "Terraformer: invalid input for Terraformer.GeometryCollection";\n    }\n\n    this.type = "GeometryCollection";\n  }\n\n  GeometryCollection.prototype = new Primitive();\n  GeometryCollection.prototype.constructor = GeometryCollection;\n  GeometryCollection.prototype.forEach = function(func){\n    for (var i = 0; i < this.geometries.length; i++) {\n      func.apply(this, [this.geometries[i], i, this.geometries]);\n    }\n  };\n  GeometryCollection.prototype.get = function(i){\n    return new Primitive(this.geometries[i]);\n  };\n\n  function createCircle(center, radius, interpolate){\n    var mercatorPosition = positionToMercator(center);\n    var steps = interpolate || 64;\n    var polygon = {\n      type: "Polygon",\n      coordinates: [[]]\n    };\n    for(var i=1; i<=steps; i++) {\n      var radians = i * (360/steps) * Math.PI / 180;\n      polygon.coordinates[0].push([mercatorPosition[0] + radius * Math.cos(radians), mercatorPosition[1] + radius * Math.sin(radians)]);\n    }\n    polygon.coordinates = closedPolygon(polygon.coordinates);\n\n    return toGeographic(polygon);\n  }\n\n  function Circle (center, radius, interpolate) {\n    var steps = interpolate || 64;\n    var rad = radius || 250;\n\n    if(!center || center.length < 2 || !rad || !steps) {\n      throw new Error("Terraformer: missing parameter for Terraformer.Circle");\n    }\n\n    extend(this, new Feature({\n      type: "Feature",\n      geometry: createCircle(center, rad, steps),\n      properties: {\n        radius: rad,\n        center: center,\n        steps: steps\n      }\n    }));\n  }\n\n  Circle.prototype = new Primitive();\n  Circle.prototype.constructor = Circle;\n  Circle.prototype.recalculate = function(){\n    this.geometry = createCircle(this.properties.center, this.properties.radius, this.properties.steps);\n    return this;\n  };\n  Circle.prototype.center = function(coordinates){\n    if(coordinates){\n      this.properties.center = coordinates;\n      this.recalculate();\n    }\n    return this.properties.center;\n  };\n  Circle.prototype.radius = function(radius){\n    if(radius){\n      this.properties.radius = radius;\n      this.recalculate();\n    }\n    return this.properties.radius;\n  };\n  Circle.prototype.steps = function(steps){\n    if(steps){\n      this.properties.steps = steps;\n      this.recalculate();\n    }\n    return this.properties.steps;\n  };\n\n  Circle.prototype.toJSON = function() {\n    var output = Primitive.prototype.toJSON.call(this);\n    return output;\n  };\n\n  exports.Primitive = Primitive;\n  exports.Point = Point;\n  exports.MultiPoint = MultiPoint;\n  exports.LineString = LineString;\n  exports.MultiLineString = MultiLineString;\n  exports.Polygon = Polygon;\n  exports.MultiPolygon = MultiPolygon;\n  exports.Feature = Feature;\n  exports.FeatureCollection = FeatureCollection;\n  exports.GeometryCollection = GeometryCollection;\n  exports.Circle = Circle;\n\n  exports.toMercator = toMercator;\n  exports.toGeographic = toGeographic;\n\n  exports.Tools = {};\n  exports.Tools.positionToMercator = positionToMercator;\n  exports.Tools.positionToGeographic = positionToGeographic;\n  exports.Tools.applyConverter = applyConverter;\n  exports.Tools.toMercator = toMercator;\n  exports.Tools.toGeographic = toGeographic;\n  exports.Tools.createCircle = createCircle;\n\n  exports.Tools.calculateBounds = calculateBounds;\n  exports.Tools.calculateEnvelope = calculateEnvelope;\n\n  exports.Tools.coordinatesContainPoint = coordinatesContainPoint;\n  exports.Tools.polygonContainsPoint = polygonContainsPoint;\n  exports.Tools.arraysIntersectArrays = arraysIntersectArrays;\n  exports.Tools.coordinatesContainPoint = coordinatesContainPoint;\n  exports.Tools.coordinatesEqual = coordinatesEqual;\n  exports.Tools.convexHull = convexHull;\n  exports.Tools.isConvex = isConvex;\n\n  exports.MercatorCRS = MercatorCRS;\n  exports.GeographicCRS = GeographicCRS;\n\n  return exports;\n}));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3RlcnJhZm9ybWVyL3RlcnJhZm9ybWVyLmpzPzNjOWYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGtCQUFrQjtBQUNyQzs7QUFFQSxxQkFBcUIsa0JBQWtCO0FBQ3ZDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1C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TztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNkJBQTZCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDZCQUE2QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNkJBQTZCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw2QkFBNkI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwwQkFBMEI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDRCQUE0QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUMiLCJmaWxlIjoiMzcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblxuICAvLyBOb2RlLlxuICBpZih0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICB9XG5cbiAgLy8gQnJvd3NlciBHbG9iYWwuXG4gIGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIHtcbiAgICByb290LlRlcnJhZm9ybWVyID0gZmFjdG9yeSgpO1xuICB9XG5cbn0odGhpcywgZnVuY3Rpb24oKXtcbiAgdmFyIGV4cG9ydHMgPSB7fSxcbiAgICAgIEVhcnRoUmFkaXVzID0gNjM3ODEzNyxcbiAgICAgIERlZ3JlZXNQZXJSYWRpYW4gPSA1Ny4yOTU3Nzk1MTMwODIzMjAsXG4gICAgICBSYWRpYW5zUGVyRGVncmVlID0gIDAuMDE3NDUzMjkyNTE5OTQzLFxuICAgICAgTWVyY2F0b3JDUlMgPSB7XG4gICAgICAgIFwidHlwZVwiOiBcImxpbmtcIixcbiAgICAgICAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICAgICAgICBcImhyZWZcIjogXCJodHRwOi8vc3BhdGlhbHJlZmVyZW5jZS5vcmcvcmVmL3NyLW9yZy82OTI4L29nY3drdC9cIixcbiAgICAgICAgICBcInR5cGVcIjogXCJvZ2N3a3RcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgR2VvZ3JhcGhpY0NSUyA9IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwibGlua1wiLFxuICAgICAgICBcInByb3BlcnRpZXNcIjoge1xuICAgICAgICAgIFwiaHJlZlwiOiBcImh0dHA6Ly9zcGF0aWFscmVmZXJlbmNlLm9yZy9yZWYvZXBzZy80MzI2L29nY3drdC9cIixcbiAgICAgICAgICBcInR5cGVcIjogXCJvZ2N3a3RcIlxuICAgICAgICB9XG4gICAgICB9O1xuXG4gIC8qXG4gIEludGVybmFsOiBpc0FycmF5IGZ1bmN0aW9uXG4gICovXG4gIGZ1bmN0aW9uIGlzQXJyYXkob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSBcIltvYmplY3QgQXJyYXldXCI7XG4gIH1cblxuICAvKlxuICBJbnRlcm5hbDogc2FmZSB3YXJuaW5nXG4gICovXG4gIGZ1bmN0aW9uIHdhcm4oKSB7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoYXJndW1lbnRzKTtcblxuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gdW5kZWZpbmVkICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgY29uc29sZS53YXJuLmFwcGx5KGNvbnNvbGUsIGFyZ3MpO1xuICAgIH1cbiAgfVxuXG4gIC8qXG4gIEludGVybmFsOiBFeHRlbmQgb25lIG9iamVjdCB3aXRoIGFub3RoZXIuXG4gICovXG4gIGZ1bmN0aW9uIGV4dGVuZChkZXN0aW5hdGlvbiwgc291cmNlKSB7XG4gICAgZm9yICh2YXIgayBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkoaykpIHtcbiAgICAgICAgZGVzdGluYXRpb25ba10gPSBzb3VyY2Vba107XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZXN0aW5hdGlvbjtcbiAgfVxuXG4gIC8qXG4gIFB1YmxpYzogQ2FsY3VsYXRlIGFuIGJvdW5kaW5nIGJveCBmb3IgYSBnZW9qc29uIG9iamVjdFxuICAqL1xuICBmdW5jdGlvbiBjYWxjdWxhdGVCb3VuZHMgKGdlb2pzb24pIHtcbiAgICBpZihnZW9qc29uLnR5cGUpe1xuICAgICAgc3dpdGNoIChnZW9qc29uLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnUG9pbnQnOlxuICAgICAgICAgIHJldHVybiBbIGdlb2pzb24uY29vcmRpbmF0ZXNbMF0sIGdlb2pzb24uY29vcmRpbmF0ZXNbMV0sIGdlb2pzb24uY29vcmRpbmF0ZXNbMF0sIGdlb2pzb24uY29vcmRpbmF0ZXNbMV1dO1xuXG4gICAgICAgIGNhc2UgJ011bHRpUG9pbnQnOlxuICAgICAgICAgIHJldHVybiBjYWxjdWxhdGVCb3VuZHNGcm9tQXJyYXkoZ2VvanNvbi5jb29yZGluYXRlcyk7XG5cbiAgICAgICAgY2FzZSAnTGluZVN0cmluZyc6XG4gICAgICAgICAgcmV0dXJuIGNhbGN1bGF0ZUJvdW5kc0Zyb21BcnJheShnZW9qc29uLmNvb3JkaW5hdGVzKTtcblxuICAgICAgICBjYXNlICdNdWx0aUxpbmVTdHJpbmcnOlxuICAgICAgICAgIHJldHVybiBjYWxjdWxhdGVCb3VuZHNGcm9tTmVzdGVkQXJyYXlzKGdlb2pzb24uY29vcmRpbmF0ZXMpO1xuXG4gICAgICAgIGNhc2UgJ1BvbHlnb24nOlxuICAgICAgICAgIHJldHVybiBjYWxjdWxhdGVCb3VuZHNGcm9tTmVzdGVkQXJyYXlzKGdlb2pzb24uY29vcmRpbmF0ZXMpO1xuXG4gICAgICAgIGNhc2UgJ011bHRpUG9seWdvbic6XG4gICAgICAgICAgcmV0dXJuIGNhbGN1bGF0ZUJvdW5kc0Zyb21OZXN0ZWRBcnJheU9mQXJyYXlzKGdlb2pzb24uY29vcmRpbmF0ZXMpO1xuXG4gICAgICAgIGNhc2UgJ0ZlYXR1cmUnOlxuICAgICAgICAgIHJldHVybiBnZW9qc29uLmdlb21ldHJ5PyBjYWxjdWxhdGVCb3VuZHMoZ2VvanNvbi5nZW9tZXRyeSkgOiBudWxsO1xuXG4gICAgICAgIGNhc2UgJ0ZlYXR1cmVDb2xsZWN0aW9uJzpcbiAgICAgICAgICByZXR1cm4gY2FsY3VsYXRlQm91bmRzRm9yRmVhdHVyZUNvbGxlY3Rpb24oZ2VvanNvbik7XG5cbiAgICAgICAgY2FzZSAnR2VvbWV0cnlDb2xsZWN0aW9uJzpcbiAgICAgICAgICByZXR1cm4gY2FsY3VsYXRlQm91bmRzRm9yR2VvbWV0cnlDb2xsZWN0aW9uKGdlb2pzb24pO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB0eXBlOiBcIiArIGdlb2pzb24udHlwZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLypcbiAgSW50ZXJuYWw6IENhbGN1bGF0ZSBhbiBib3VuZGluZyBib3ggZnJvbSBhbiBuZXN0ZWQgYXJyYXkgb2YgcG9zaXRpb25zXG4gIFtcbiAgICBbXG4gICAgICBbIFtsbmcsIGxhdF0sW2xuZywgbGF0XSxbbG5nLCBsYXRdIF1cbiAgICBdXG4gICAgW1xuICAgICAgW2xuZywgbGF0XSxbbG5nLCBsYXRdLFtsbmcsIGxhdF1cbiAgICBdXG4gICAgW1xuICAgICAgW2xuZywgbGF0XSxbbG5nLCBsYXRdLFtsbmcsIGxhdF1cbiAgICBdXG4gIF1cbiAgKi9cbiAgZnVuY3Rpb24gY2FsY3VsYXRlQm91bmRzRnJvbU5lc3RlZEFycmF5cyAoYXJyYXkpIHtcbiAgICB2YXIgeDEgPSBudWxsLCB4MiA9IG51bGwsIHkxID0gbnVsbCwgeTIgPSBudWxsO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlubmVyID0gYXJyYXlbaV07XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaW5uZXIubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGxvbmxhdCA9IGlubmVyW2pdO1xuXG4gICAgICAgIHZhciBsb24gPSBsb25sYXRbMF07XG4gICAgICAgIHZhciBsYXQgPSBsb25sYXRbMV07XG5cbiAgICAgICAgaWYgKHgxID09PSBudWxsKSB7XG4gICAgICAgICAgeDEgPSBsb247XG4gICAgICAgIH0gZWxzZSBpZiAobG9uIDwgeDEpIHtcbiAgICAgICAgICB4MSA9IGxvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh4MiA9PT0gbnVsbCkge1xuICAgICAgICAgIHgyID0gbG9uO1xuICAgICAgICB9IGVsc2UgaWYgKGxvbiA+IHgyKSB7XG4gICAgICAgICAgeDIgPSBsb247XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoeTEgPT09IG51bGwpIHtcbiAgICAgICAgICB5MSA9IGxhdDtcbiAgICAgICAgfSBlbHNlIGlmIChsYXQgPCB5MSkge1xuICAgICAgICAgIHkxID0gbGF0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHkyID09PSBudWxsKSB7XG4gICAgICAgICAgeTIgPSBsYXQ7XG4gICAgICAgIH0gZWxzZSBpZiAobGF0ID4geTIpIHtcbiAgICAgICAgICB5MiA9IGxhdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbeDEsIHkxLCB4MiwgeTIgXTtcbiAgfVxuXG4gIC8qXG4gIEludGVybmFsOiBDYWxjdWxhdGUgYSBib3VuZGluZyBib3ggZnJvbSBhbiBhcnJheSBvZiBhcnJheXMgb2YgYXJyYXlzXG4gIFtcbiAgICBbIFtsbmcsIGxhdF0sW2xuZywgbGF0XSxbbG5nLCBsYXRdIF1cbiAgICBbIFtsbmcsIGxhdF0sW2xuZywgbGF0XSxbbG5nLCBsYXRdIF1cbiAgICBbIFtsbmcsIGxhdF0sW2xuZywgbGF0XSxbbG5nLCBsYXRdIF1cbiAgXVxuICAqL1xuICBmdW5jdGlvbiBjYWxjdWxhdGVCb3VuZHNGcm9tTmVzdGVkQXJyYXlPZkFycmF5cyAoYXJyYXkpIHtcbiAgICB2YXIgeDEgPSBudWxsLCB4MiA9IG51bGwsIHkxID0gbnVsbCwgeTIgPSBudWxsO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlubmVyID0gYXJyYXlbaV07XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaW5uZXIubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGlubmVyaW5uZXIgPSBpbm5lcltqXTtcbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBpbm5lcmlubmVyLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgdmFyIGxvbmxhdCA9IGlubmVyaW5uZXJba107XG5cbiAgICAgICAgICB2YXIgbG9uID0gbG9ubGF0WzBdO1xuICAgICAgICAgIHZhciBsYXQgPSBsb25sYXRbMV07XG5cbiAgICAgICAgICBpZiAoeDEgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHgxID0gbG9uO1xuICAgICAgICAgIH0gZWxzZSBpZiAobG9uIDwgeDEpIHtcbiAgICAgICAgICAgIHgxID0gbG9uO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh4MiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgeDIgPSBsb247XG4gICAgICAgICAgfSBlbHNlIGlmIChsb24gPiB4Mikge1xuICAgICAgICAgICAgeDIgPSBsb247XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHkxID09PSBudWxsKSB7XG4gICAgICAgICAgICB5MSA9IGxhdDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGxhdCA8IHkxKSB7XG4gICAgICAgICAgICB5MSA9IGxhdDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoeTIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHkyID0gbGF0O1xuICAgICAgICAgIH0gZWxzZSBpZiAobGF0ID4geTIpIHtcbiAgICAgICAgICAgIHkyID0gbGF0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbeDEsIHkxLCB4MiwgeTJdO1xuICB9XG5cbiAgLypcbiAgSW50ZXJuYWw6IENhbGN1bGF0ZSBhIGJvdW5kaW5nIGJveCBmcm9tIGFuIGFycmF5IG9mIHBvc2l0aW9uc1xuICBbXG4gICAgW2xuZywgbGF0XSxbbG5nLCBsYXRdLFtsbmcsIGxhdF1cbiAgXVxuICAqL1xuICBmdW5jdGlvbiBjYWxjdWxhdGVCb3VuZHNGcm9tQXJyYXkgKGFycmF5KSB7XG4gICAgdmFyIHgxID0gbnVsbCwgeDIgPSBudWxsLCB5MSA9IG51bGwsIHkyID0gbnVsbDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBsb25sYXQgPSBhcnJheVtpXTtcbiAgICAgIHZhciBsb24gPSBsb25sYXRbMF07XG4gICAgICB2YXIgbGF0ID0gbG9ubGF0WzFdO1xuXG4gICAgICBpZiAoeDEgPT09IG51bGwpIHtcbiAgICAgICAgeDEgPSBsb247XG4gICAgICB9IGVsc2UgaWYgKGxvbiA8IHgxKSB7XG4gICAgICAgIHgxID0gbG9uO1xuICAgICAgfVxuXG4gICAgICBpZiAoeDIgPT09IG51bGwpIHtcbiAgICAgICAgeDIgPSBsb247XG4gICAgICB9IGVsc2UgaWYgKGxvbiA+IHgyKSB7XG4gICAgICAgIHgyID0gbG9uO1xuICAgICAgfVxuXG4gICAgICBpZiAoeTEgPT09IG51bGwpIHtcbiAgICAgICAgeTEgPSBsYXQ7XG4gICAgICB9IGVsc2UgaWYgKGxhdCA8IHkxKSB7XG4gICAgICAgIHkxID0gbGF0O1xuICAgICAgfVxuXG4gICAgICBpZiAoeTIgPT09IG51bGwpIHtcbiAgICAgICAgeTIgPSBsYXQ7XG4gICAgICB9IGVsc2UgaWYgKGxhdCA+IHkyKSB7XG4gICAgICAgIHkyID0gbGF0O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbeDEsIHkxLCB4MiwgeTIgXTtcbiAgfVxuXG4gIC8qXG4gIEludGVybmFsOiBDYWxjdWxhdGUgYW4gYm91bmRpbmcgYm94IGZvciBhIGZlYXR1cmUgY29sbGVjdGlvblxuICAqL1xuICBmdW5jdGlvbiBjYWxjdWxhdGVCb3VuZHNGb3JGZWF0dXJlQ29sbGVjdGlvbihmZWF0dXJlQ29sbGVjdGlvbil7XG4gICAgdmFyIGV4dGVudHMgPSBbXSwgZXh0ZW50O1xuICAgIGZvciAodmFyIGkgPSBmZWF0dXJlQ29sbGVjdGlvbi5mZWF0dXJlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgZXh0ZW50ID0gY2FsY3VsYXRlQm91bmRzKGZlYXR1cmVDb2xsZWN0aW9uLmZlYXR1cmVzW2ldLmdlb21ldHJ5KTtcbiAgICAgIGV4dGVudHMucHVzaChbZXh0ZW50WzBdLGV4dGVudFsxXV0pO1xuICAgICAgZXh0ZW50cy5wdXNoKFtleHRlbnRbMl0sZXh0ZW50WzNdXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNhbGN1bGF0ZUJvdW5kc0Zyb21BcnJheShleHRlbnRzKTtcbiAgfVxuXG4gIC8qXG4gIEludGVybmFsOiBDYWxjdWxhdGUgYW4gYm91bmRpbmcgYm94IGZvciBhIGdlb21ldHJ5IGNvbGxlY3Rpb25cbiAgKi9cbiAgZnVuY3Rpb24gY2FsY3VsYXRlQm91bmRzRm9yR2VvbWV0cnlDb2xsZWN0aW9uKGdlb21ldHJ5Q29sbGVjdGlvbil7XG4gICAgdmFyIGV4dGVudHMgPSBbXSwgZXh0ZW50O1xuXG4gICAgZm9yICh2YXIgaSA9IGdlb21ldHJ5Q29sbGVjdGlvbi5nZW9tZXRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBleHRlbnQgPSBjYWxjdWxhdGVCb3VuZHMoZ2VvbWV0cnlDb2xsZWN0aW9uLmdlb21ldHJpZXNbaV0pO1xuICAgICAgZXh0ZW50cy5wdXNoKFtleHRlbnRbMF0sZXh0ZW50WzFdXSk7XG4gICAgICBleHRlbnRzLnB1c2goW2V4dGVudFsyXSxleHRlbnRbM11dKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2FsY3VsYXRlQm91bmRzRnJvbUFycmF5KGV4dGVudHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FsY3VsYXRlRW52ZWxvcGUoZ2VvanNvbil7XG4gICAgdmFyIGJvdW5kcyA9IGNhbGN1bGF0ZUJvdW5kcyhnZW9qc29uKTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogYm91bmRzWzBdLFxuICAgICAgeTogYm91bmRzWzFdLFxuICAgICAgdzogTWF0aC5hYnMoYm91bmRzWzBdIC0gYm91bmRzWzJdKSxcbiAgICAgIGg6IE1hdGguYWJzKGJvdW5kc1sxXSAtIGJvdW5kc1szXSlcbiAgICB9O1xuICB9XG5cbiAgLypcbiAgSW50ZXJuYWw6IENvbnZlcnQgcmFkaWFucyB0byBkZWdyZWVzLiBVc2VkIGJ5IHNwYXRpYWwgcmVmZXJlbmNlIGNvbnZlcnRlcnMuXG4gICovXG4gIGZ1bmN0aW9uIHJhZFRvRGVnKHJhZCkge1xuICAgIHJldHVybiByYWQgKiBEZWdyZWVzUGVyUmFkaWFuO1xuICB9XG5cbiAgLypcbiAgSW50ZXJuYWw6IENvbnZlcnQgZGVncmVlcyB0byByYWRpYW5zLiBVc2VkIGJ5IHNwYXRpYWwgcmVmZXJlbmNlIGNvbnZlcnRlcnMuXG4gICovXG4gIGZ1bmN0aW9uIGRlZ1RvUmFkKGRlZykge1xuICAgIHJldHVybiBkZWcgKiBSYWRpYW5zUGVyRGVncmVlO1xuICB9XG5cbiAgLypcbiAgSW50ZXJuYWw6IExvb3Agb3ZlciBlYWNoIGFycmF5IGluIGEgZ2VvanNvbiBvYmplY3QgYW5kIGFwcGx5IGEgZnVuY3Rpb24gdG8gaXQuIFVzZWQgYnkgc3BhdGlhbCByZWZlcmVuY2UgY29udmVydGVycy5cbiAgKi9cbiAgZnVuY3Rpb24gZWFjaFBvc2l0aW9uKGNvb3JkaW5hdGVzLCBmdW5jKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZGluYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gd2UgZm91bmQgYSBudW1iZXIgc28gbGV0cyBjb252ZXJ0IHRoaXMgcGFpclxuICAgICAgaWYodHlwZW9mIGNvb3JkaW5hdGVzW2ldWzBdID09PSBcIm51bWJlclwiKXtcbiAgICAgICAgY29vcmRpbmF0ZXNbaV0gPSBmdW5jKGNvb3JkaW5hdGVzW2ldKTtcbiAgICAgIH1cbiAgICAgIC8vIHdlIGZvdW5kIGFuIGNvb3JkaW5hdGVzIGFycmF5IGl0IGFnYWluIGFuZCBydW4gVEhJUyBmdW5jdGlvbiBhZ2FpbnN0IGl0XG4gICAgICBpZih0eXBlb2YgY29vcmRpbmF0ZXNbaV0gPT09IFwib2JqZWN0XCIpe1xuICAgICAgICBjb29yZGluYXRlc1tpXSA9IGVhY2hQb3NpdGlvbihjb29yZGluYXRlc1tpXSwgZnVuYyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb29yZGluYXRlcztcbiAgfVxuXG4gIC8qXG4gIFB1YmxpYzogQ29udmVydCBhIEdlb0pTT04gUG9zaXRpb24gb2JqZWN0IHRvIEdlb2dyYXBoaWMgKDQzMjYpXG4gICovXG4gIGZ1bmN0aW9uIHBvc2l0aW9uVG9HZW9ncmFwaGljKHBvc2l0aW9uKSB7XG4gICAgdmFyIHggPSBwb3NpdGlvblswXTtcbiAgICB2YXIgeSA9IHBvc2l0aW9uWzFdO1xuICAgIHJldHVybiBbcmFkVG9EZWcoeCAvIEVhcnRoUmFkaXVzKSAtIChNYXRoLmZsb29yKChyYWRUb0RlZyh4IC8gRWFydGhSYWRpdXMpICsgMTgwKSAvIDM2MCkgKiAzNjApLCByYWRUb0RlZygoTWF0aC5QSSAvIDIpIC0gKDIgKiBNYXRoLmF0YW4oTWF0aC5leHAoLTEuMCAqIHkgLyBFYXJ0aFJhZGl1cykpKSldO1xuICB9XG5cbiAgLypcbiAgUHVibGljOiBDb252ZXJ0IGEgR2VvSlNPTiBQb3NpdGlvbiBvYmplY3QgdG8gV2ViIE1lcmNhdG9yICgxMDIxMDApXG4gICovXG4gIGZ1bmN0aW9uIHBvc2l0aW9uVG9NZXJjYXRvcihwb3NpdGlvbikge1xuICAgIHZhciBsbmcgPSBwb3NpdGlvblswXTtcbiAgICB2YXIgbGF0ID0gTWF0aC5tYXgoTWF0aC5taW4ocG9zaXRpb25bMV0sIDg5Ljk5OTk5KSwgLTg5Ljk5OTk5KTtcbiAgICByZXR1cm4gW2RlZ1RvUmFkKGxuZykgKiBFYXJ0aFJhZGl1cywgRWFydGhSYWRpdXMvMi4wICogTWF0aC5sb2coICgxLjAgKyBNYXRoLnNpbihkZWdUb1JhZChsYXQpKSkgLyAoMS4wIC0gTWF0aC5zaW4oZGVnVG9SYWQobGF0KSkpICldO1xuICB9XG5cbiAgLypcbiAgUHVibGljOiBBcHBseSBhIGZ1bmN0aW9uIGFnYWlzdCBhbGwgcG9zaXRpb25zIGluIGEgZ2VvanNvbiBvYmplY3QuIFVzZWQgYnkgc3BhdGlhbCByZWZlcmVuY2UgY29udmVydGVycy5cbiAgKi9cbiAgZnVuY3Rpb24gYXBwbHlDb252ZXJ0ZXIoZ2VvanNvbiwgY29udmVydGVyLCBub0Nycyl7XG4gICAgaWYoZ2VvanNvbi50eXBlID09PSBcIlBvaW50XCIpIHtcbiAgICAgIGdlb2pzb24uY29vcmRpbmF0ZXMgPSBjb252ZXJ0ZXIoZ2VvanNvbi5jb29yZGluYXRlcyk7XG4gICAgfSBlbHNlIGlmKGdlb2pzb24udHlwZSA9PT0gXCJGZWF0dXJlXCIpIHtcbiAgICAgIGdlb2pzb24uZ2VvbWV0cnkgPSBhcHBseUNvbnZlcnRlcihnZW9qc29uLmdlb21ldHJ5LCBjb252ZXJ0ZXIsIHRydWUpO1xuICAgIH0gZWxzZSBpZihnZW9qc29uLnR5cGUgPT09IFwiRmVhdHVyZUNvbGxlY3Rpb25cIikge1xuICAgICAgZm9yICh2YXIgZiA9IDA7IGYgPCBnZW9qc29uLmZlYXR1cmVzLmxlbmd0aDsgZisrKSB7XG4gICAgICAgIGdlb2pzb24uZmVhdHVyZXNbZl0gPSBhcHBseUNvbnZlcnRlcihnZW9qc29uLmZlYXR1cmVzW2ZdLCBjb252ZXJ0ZXIsIHRydWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZihnZW9qc29uLnR5cGUgPT09IFwiR2VvbWV0cnlDb2xsZWN0aW9uXCIpIHtcbiAgICAgIGZvciAodmFyIGcgPSAwOyBnIDwgZ2VvanNvbi5nZW9tZXRyaWVzLmxlbmd0aDsgZysrKSB7XG4gICAgICAgIGdlb2pzb24uZ2VvbWV0cmllc1tnXSA9IGFwcGx5Q29udmVydGVyKGdlb2pzb24uZ2VvbWV0cmllc1tnXSwgY29udmVydGVyLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZ2VvanNvbi5jb29yZGluYXRlcyA9IGVhY2hQb3NpdGlvbihnZW9qc29uLmNvb3JkaW5hdGVzLCBjb252ZXJ0ZXIpO1xuICAgIH1cblxuICAgIGlmKCFub0Nycyl7XG4gICAgICBpZihjb252ZXJ0ZXIgPT09IHBvc2l0aW9uVG9NZXJjYXRvcil7XG4gICAgICAgIGdlb2pzb24uY3JzID0gTWVyY2F0b3JDUlM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYoY29udmVydGVyID09PSBwb3NpdGlvblRvR2VvZ3JhcGhpYyl7XG4gICAgICBkZWxldGUgZ2VvanNvbi5jcnM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdlb2pzb247XG4gIH1cblxuICAvKlxuICBQdWJsaWM6IENvbnZlcnQgYSBHZW9KU09OIG9iamVjdCB0byBFU1JJIFdlYiBNZXJjYXRvciAoMTAyMTAwKVxuICAqL1xuICBmdW5jdGlvbiB0b01lcmNhdG9yKGdlb2pzb24pIHtcbiAgICByZXR1cm4gYXBwbHlDb252ZXJ0ZXIoZ2VvanNvbiwgcG9zaXRpb25Ub01lcmNhdG9yKTtcbiAgfVxuXG4gIC8qXG4gIENvbnZlcnQgYSBHZW9KU09OIG9iamVjdCB0byBHZW9ncmFwaGljIGNvb3JkaW5hdGVzIChXU0c4NCwgNDMyNilcbiAgKi9cbiAgZnVuY3Rpb24gdG9HZW9ncmFwaGljKGdlb2pzb24pIHtcbiAgICByZXR1cm4gYXBwbHlDb252ZXJ0ZXIoZ2VvanNvbiwgcG9zaXRpb25Ub0dlb2dyYXBoaWMpO1xuICB9XG5cblxuICAvKlxuICBJbnRlcm5hbDogLTEsMCwxIGNvbXBhcmlzb24gZnVuY3Rpb25cbiAgKi9cbiAgZnVuY3Rpb24gY21wKGEsIGIpIHtcbiAgICBpZihhIDwgYikge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH0gZWxzZSBpZihhID4gYikge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfVxuXG4gIC8qXG4gIEludGVybmFsOiB1c2VkIGZvciBzb3J0aW5nXG4gICovXG4gIGZ1bmN0aW9uIGNvbXBTb3J0KHAxLCBwMikge1xuICAgIGlmIChwMVswXSA+IHAyWzBdKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfSBlbHNlIGlmIChwMVswXSA8IHAyWzBdKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKHAxWzFdID4gcDJbMV0pIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9IGVsc2UgaWYgKHAxWzFdIDwgcDJbMV0pIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH1cblxuXG4gIC8qXG4gIEludGVybmFsOiB1c2VkIHRvIGRldGVybWluZSB0dXJuXG4gICovXG4gIGZ1bmN0aW9uIHR1cm4ocCwgcSwgcikge1xuICAgIC8vIFJldHVybnMgLTEsIDAsIDEgaWYgcCxxLHIgZm9ybXMgYSByaWdodCwgc3RyYWlnaHQsIG9yIGxlZnQgdHVybi5cbiAgICByZXR1cm4gY21wKChxWzBdIC0gcFswXSkgKiAoclsxXSAtIHBbMV0pIC0gKHJbMF0gLSBwWzBdKSAqIChxWzFdIC0gcFsxXSksIDApO1xuICB9XG5cbiAgLypcbiAgSW50ZXJuYWw6IHVzZWQgdG8gZGV0ZXJtaW5lIGV1Y2xpZGVhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHNcbiAgKi9cbiAgZnVuY3Rpb24gZXVjbGlkZWFuRGlzdGFuY2UocCwgcSkge1xuICAgIC8vIFJldHVybnMgdGhlIHNxdWFyZWQgRXVjbGlkZWFuIGRpc3RhbmNlIGJldHdlZW4gcCBhbmQgcS5cbiAgICB2YXIgZHggPSBxWzBdIC0gcFswXTtcbiAgICB2YXIgZHkgPSBxWzFdIC0gcFsxXTtcblxuICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5leHRIdWxsUG9pbnQocG9pbnRzLCBwKSB7XG4gICAgLy8gUmV0dXJucyB0aGUgbmV4dCBwb2ludCBvbiB0aGUgY29udmV4IGh1bGwgaW4gQ0NXIGZyb20gcC5cbiAgICB2YXIgcSA9IHA7XG4gICAgZm9yKHZhciByIGluIHBvaW50cykge1xuICAgICAgdmFyIHQgPSB0dXJuKHAsIHEsIHBvaW50c1tyXSk7XG4gICAgICBpZih0ID09PSAtMSB8fCB0ID09PSAwICYmIGV1Y2xpZGVhbkRpc3RhbmNlKHAsIHBvaW50c1tyXSkgPiBldWNsaWRlYW5EaXN0YW5jZShwLCBxKSkge1xuICAgICAgICBxID0gcG9pbnRzW3JdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnZleEh1bGwocG9pbnRzKSB7XG4gICAgLy8gaW1wbGVtZW50YXRpb24gb2YgdGhlIEphcnZpcyBNYXJjaCBhbGdvcml0aG1cbiAgICAvLyBhZGFwdGVkIGZyb20gaHR0cDovL3RpeHhpdC53b3JkcHJlc3MuY29tLzIwMDkvMTIvMDkvamFydmlzLW1hcmNoL1xuXG4gICAgaWYocG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH0gZWxzZSBpZihwb2ludHMubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gcG9pbnRzO1xuICAgIH1cblxuICAgIC8vIFJldHVybnMgdGhlIHBvaW50cyBvbiB0aGUgY29udmV4IGh1bGwgb2YgcG9pbnRzIGluIENDVyBvcmRlci5cbiAgICB2YXIgaHVsbCA9IFtwb2ludHMuc29ydChjb21wU29ydClbMF1dO1xuXG4gICAgZm9yKHZhciBwID0gMDsgcCA8IGh1bGwubGVuZ3RoOyBwKyspIHtcbiAgICAgIHZhciBxID0gbmV4dEh1bGxQb2ludChwb2ludHMsIGh1bGxbcF0pO1xuXG4gICAgICBpZihxICE9PSBodWxsWzBdKSB7XG4gICAgICAgIGh1bGwucHVzaChxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaHVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQ29udmV4KHBvaW50cykge1xuICAgIHZhciBsdHo7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGggLSAzOyBpKyspIHtcbiAgICAgIHZhciBwMSA9IHBvaW50c1tpXTtcbiAgICAgIHZhciBwMiA9IHBvaW50c1tpICsgMV07XG4gICAgICB2YXIgcDMgPSBwb2ludHNbaSArIDJdO1xuICAgICAgdmFyIHYgPSBbcDJbMF0gLSBwMVswXSwgcDJbMV0gLSBwMVsxXV07XG5cbiAgICAgIC8vIHAzLnggKiB2LnkgLSBwMy55ICogdi54ICsgdi54ICogcDEueSAtIHYueSAqIHAxLnhcbiAgICAgIHZhciByZXMgPSBwM1swXSAqIHZbMV0gLSBwM1sxXSAqIHZbMF0gKyB2WzBdICogcDFbMV0gLSB2WzFdICogcDFbMF07XG5cbiAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgIGlmIChyZXMgPCAwKSB7XG4gICAgICAgICAgbHR6ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsdHogPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGx0eiAmJiAocmVzID4gMCkgfHwgIWx0eiAmJiAocmVzIDwgMCkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvb3JkaW5hdGVzQ29udGFpblBvaW50KGNvb3JkaW5hdGVzLCBwb2ludCkge1xuICAgIHZhciBjb250YWlucyA9IGZhbHNlO1xuICAgIGZvcih2YXIgaSA9IC0xLCBsID0gY29vcmRpbmF0ZXMubGVuZ3RoLCBqID0gbCAtIDE7ICsraSA8IGw7IGogPSBpKSB7XG4gICAgICBpZiAoKChjb29yZGluYXRlc1tpXVsxXSA8PSBwb2ludFsxXSAmJiBwb2ludFsxXSA8IGNvb3JkaW5hdGVzW2pdWzFdKSB8fFxuICAgICAgICAgICAoY29vcmRpbmF0ZXNbal1bMV0gPD0gcG9pbnRbMV0gJiYgcG9pbnRbMV0gPCBjb29yZGluYXRlc1tpXVsxXSkpICYmXG4gICAgICAgICAgKHBvaW50WzBdIDwgKGNvb3JkaW5hdGVzW2pdWzBdIC0gY29vcmRpbmF0ZXNbaV1bMF0pICogKHBvaW50WzFdIC0gY29vcmRpbmF0ZXNbaV1bMV0pIC8gKGNvb3JkaW5hdGVzW2pdWzFdIC0gY29vcmRpbmF0ZXNbaV1bMV0pICsgY29vcmRpbmF0ZXNbaV1bMF0pKSB7XG4gICAgICAgIGNvbnRhaW5zID0gIWNvbnRhaW5zO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29udGFpbnM7XG4gIH1cblxuICBmdW5jdGlvbiBwb2x5Z29uQ29udGFpbnNQb2ludChwb2x5Z29uLCBwb2ludCkge1xuICAgIGlmIChwb2x5Z29uICYmIHBvbHlnb24ubGVuZ3RoKSB7XG4gICAgICBpZiAocG9seWdvbi5sZW5ndGggPT09IDEpIHsgLy8gcG9seWdvbiB3aXRoIG5vIGhvbGVzXG4gICAgICAgIHJldHVybiBjb29yZGluYXRlc0NvbnRhaW5Qb2ludChwb2x5Z29uWzBdLCBwb2ludCk7XG4gICAgICB9IGVsc2UgeyAvLyBwb2x5Z29uIHdpdGggaG9sZXNcbiAgICAgICAgaWYgKGNvb3JkaW5hdGVzQ29udGFpblBvaW50KHBvbHlnb25bMF0sIHBvaW50KSkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgcG9seWdvbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGNvb3JkaW5hdGVzQ29udGFpblBvaW50KHBvbHlnb25baV0sIHBvaW50KSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIGZvdW5kIGluIGhvbGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVkZ2VJbnRlcnNlY3RzRWRnZShhMSwgYTIsIGIxLCBiMikge1xuICAgIHZhciB1YV90ID0gKGIyWzBdIC0gYjFbMF0pICogKGExWzFdIC0gYjFbMV0pIC0gKGIyWzFdIC0gYjFbMV0pICogKGExWzBdIC0gYjFbMF0pO1xuICAgIHZhciB1Yl90ID0gKGEyWzBdIC0gYTFbMF0pICogKGExWzFdIC0gYjFbMV0pIC0gKGEyWzFdIC0gYTFbMV0pICogKGExWzBdIC0gYjFbMF0pO1xuICAgIHZhciB1X2IgID0gKGIyWzFdIC0gYjFbMV0pICogKGEyWzBdIC0gYTFbMF0pIC0gKGIyWzBdIC0gYjFbMF0pICogKGEyWzFdIC0gYTFbMV0pO1xuXG4gICAgaWYgKCB1X2IgIT09IDAgKSB7XG4gICAgICB2YXIgdWEgPSB1YV90IC8gdV9iO1xuICAgICAgdmFyIHViID0gdWJfdCAvIHVfYjtcblxuICAgICAgaWYgKCAwIDw9IHVhICYmIHVhIDw9IDEgJiYgMCA8PSB1YiAmJiB1YiA8PSAxICkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBpc051bWJlcihuKSB7XG4gICAgcmV0dXJuICFpc05hTihwYXJzZUZsb2F0KG4pKSAmJiBpc0Zpbml0ZShuKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFycmF5c0ludGVyc2VjdEFycmF5cyhhLCBiKSB7XG4gICAgaWYgKGlzTnVtYmVyKGFbMF1bMF0pKSB7XG4gICAgICBpZiAoaXNOdW1iZXIoYlswXVswXSkpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYi5sZW5ndGggLSAxOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChlZGdlSW50ZXJzZWN0c0VkZ2UoYVtpXSwgYVtpICsgMV0sIGJbal0sIGJbaiArIDFdKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgYi5sZW5ndGg7IGsrKykge1xuICAgICAgICAgIGlmIChhcnJheXNJbnRlcnNlY3RBcnJheXMoYSwgYltrXSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBsID0gMDsgbCA8IGEubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgaWYgKGFycmF5c0ludGVyc2VjdEFycmF5cyhhW2xdLCBiKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qXG4gIEludGVybmFsOiBSZXR1cm5zIGEgY29weSBvZiBjb29yZGluYXRlcyBmb3IgcyBjbG9zZWQgcG9seWdvblxuICAqL1xuICBmdW5jdGlvbiBjbG9zZWRQb2x5Z29uKGNvb3JkaW5hdGVzKSB7XG4gICAgdmFyIG91dGVyID0gWyBdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZGluYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlubmVyID0gY29vcmRpbmF0ZXNbaV0uc2xpY2UoKTtcbiAgICAgIGlmIChwb2ludHNFcXVhbChpbm5lclswXSwgaW5uZXJbaW5uZXIubGVuZ3RoIC0gMV0pID09PSBmYWxzZSkge1xuICAgICAgICBpbm5lci5wdXNoKGlubmVyWzBdKTtcbiAgICAgIH1cblxuICAgICAgb3V0ZXIucHVzaChpbm5lcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dGVyO1xuICB9XG5cbiAgZnVuY3Rpb24gcG9pbnRzRXF1YWwoYSwgYikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuXG4gICAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBjb29yZGluYXRlc0VxdWFsKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIG5hID0gYS5zbGljZSgpLnNvcnQoY29tcFNvcnQpO1xuICAgIHZhciBuYiA9IGIuc2xpY2UoKS5zb3J0KGNvbXBTb3J0KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChuYVtpXS5sZW5ndGggIT09IG5iW2ldLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5hLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChuYVtpXVtqXSAhPT0gbmJbaV1bal0pIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qXG4gIEludGVybmFsOiBBbiBhcnJheSBvZiB2YXJpYWJsZXMgdGhhdCB3aWxsIGJlIGV4Y2x1ZGVkIGZvcm0gSlNPTiBvYmplY3RzLlxuICAqL1xuICB2YXIgZXhjbHVkZUZyb21KU09OID0gW1wibGVuZ3RoXCJdO1xuXG4gIC8qXG4gIEludGVybmFsOiBCYXNlIEdlb0pTT04gUHJpbWl0aXZlXG4gICovXG4gIGZ1bmN0aW9uIFByaW1pdGl2ZShnZW9qc29uKXtcbiAgICBpZihnZW9qc29uKXtcbiAgICAgIHN3aXRjaCAoZ2VvanNvbi50eXBlKSB7XG4gICAgICBjYXNlICdQb2ludCc6XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQoZ2VvanNvbik7XG5cbiAgICAgIGNhc2UgJ011bHRpUG9pbnQnOlxuICAgICAgICByZXR1cm4gbmV3IE11bHRpUG9pbnQoZ2VvanNvbik7XG5cbiAgICAgIGNhc2UgJ0xpbmVTdHJpbmcnOlxuICAgICAgICByZXR1cm4gbmV3IExpbmVTdHJpbmcoZ2VvanNvbik7XG5cbiAgICAgIGNhc2UgJ011bHRpTGluZVN0cmluZyc6XG4gICAgICAgIHJldHVybiBuZXcgTXVsdGlMaW5lU3RyaW5nKGdlb2pzb24pO1xuXG4gICAgICBjYXNlICdQb2x5Z29uJzpcbiAgICAgICAgcmV0dXJuIG5ldyBQb2x5Z29uKGdlb2pzb24pO1xuXG4gICAgICBjYXNlICdNdWx0aVBvbHlnb24nOlxuICAgICAgICByZXR1cm4gbmV3IE11bHRpUG9seWdvbihnZW9qc29uKTtcblxuICAgICAgY2FzZSAnRmVhdHVyZSc6XG4gICAgICAgIHJldHVybiBuZXcgRmVhdHVyZShnZW9qc29uKTtcblxuICAgICAgY2FzZSAnRmVhdHVyZUNvbGxlY3Rpb24nOlxuICAgICAgICByZXR1cm4gbmV3IEZlYXR1cmVDb2xsZWN0aW9uKGdlb2pzb24pO1xuXG4gICAgICBjYXNlICdHZW9tZXRyeUNvbGxlY3Rpb24nOlxuICAgICAgICByZXR1cm4gbmV3IEdlb21ldHJ5Q29sbGVjdGlvbihnZW9qc29uKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB0eXBlOiBcIiArIGdlb2pzb24udHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgUHJpbWl0aXZlLnByb3RvdHlwZS50b01lcmNhdG9yID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdG9NZXJjYXRvcih0aGlzKTtcbiAgfTtcblxuICBQcmltaXRpdmUucHJvdG90eXBlLnRvR2VvZ3JhcGhpYyA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRvR2VvZ3JhcGhpYyh0aGlzKTtcbiAgfTtcblxuICBQcmltaXRpdmUucHJvdG90eXBlLmVudmVsb3BlID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gY2FsY3VsYXRlRW52ZWxvcGUodGhpcyk7XG4gIH07XG5cbiAgUHJpbWl0aXZlLnByb3RvdHlwZS5iYm94ID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gY2FsY3VsYXRlQm91bmRzKHRoaXMpO1xuICB9O1xuXG4gIFByaW1pdGl2ZS5wcm90b3R5cGUuY29udmV4SHVsbCA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGNvb3JkaW5hdGVzID0gWyBdLCBpLCBqO1xuICAgIGlmICh0aGlzLnR5cGUgPT09ICdQb2ludCcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSAnTGluZVN0cmluZycgfHwgdGhpcy50eXBlID09PSAnTXVsdGlQb2ludCcpIHtcbiAgICAgIGlmICh0aGlzLmNvb3JkaW5hdGVzICYmIHRoaXMuY29vcmRpbmF0ZXMubGVuZ3RoID49IDMpIHtcbiAgICAgICAgY29vcmRpbmF0ZXMgPSB0aGlzLmNvb3JkaW5hdGVzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09ICdQb2x5Z29uJyB8fCB0aGlzLnR5cGUgPT09ICdNdWx0aUxpbmVTdHJpbmcnKSB7XG4gICAgICBpZiAodGhpcy5jb29yZGluYXRlcyAmJiB0aGlzLmNvb3JkaW5hdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuY29vcmRpbmF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb29yZGluYXRlcyA9IGNvb3JkaW5hdGVzLmNvbmNhdCh0aGlzLmNvb3JkaW5hdGVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBpZihjb29yZGluYXRlcy5sZW5ndGggPCAzKXtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09ICdNdWx0aVBvbHlnb24nKSB7XG4gICAgICBpZiAodGhpcy5jb29yZGluYXRlcyAmJiB0aGlzLmNvb3JkaW5hdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuY29vcmRpbmF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgdGhpcy5jb29yZGluYXRlc1tpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgY29vcmRpbmF0ZXMgPSBjb29yZGluYXRlcy5jb25jYXQodGhpcy5jb29yZGluYXRlc1tpXVtqXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmKGNvb3JkaW5hdGVzLmxlbmd0aCA8IDMpe1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYodGhpcy50eXBlID09PSBcIkZlYXR1cmVcIil7XG4gICAgICB2YXIgcHJpbWl0aXZlID0gbmV3IFByaW1pdGl2ZSh0aGlzLmdlb21ldHJ5KTtcbiAgICAgIHJldHVybiBwcmltaXRpdmUuY29udmV4SHVsbCgpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUG9seWdvbih7XG4gICAgICB0eXBlOiAnUG9seWdvbicsXG4gICAgICBjb29yZGluYXRlczogY2xvc2VkUG9seWdvbihbY29udmV4SHVsbChjb29yZGluYXRlcyldKVxuICAgIH0pO1xuICB9O1xuXG4gIFByaW1pdGl2ZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgb2JqID0ge307XG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMpIHtcbiAgICAgIGlmICh0aGlzLmhhc093blByb3BlcnR5KGtleSkgJiYgZXhjbHVkZUZyb21KU09OLmluZGV4T2Yoa2V5KSA9PT0gLTEpIHtcbiAgICAgICAgb2JqW2tleV0gPSB0aGlzW2tleV07XG4gICAgICB9XG4gICAgfVxuICAgIG9iai5iYm94ID0gY2FsY3VsYXRlQm91bmRzKHRoaXMpO1xuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgUHJpbWl0aXZlLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uKHByaW1pdGl2ZSl7XG4gICAgcmV0dXJuIG5ldyBQcmltaXRpdmUocHJpbWl0aXZlKS53aXRoaW4odGhpcyk7XG4gIH07XG5cbiAgUHJpbWl0aXZlLnByb3RvdHlwZS53aXRoaW4gPSBmdW5jdGlvbihwcmltaXRpdmUpIHtcbiAgICB2YXIgY29vcmRpbmF0ZXMsIGksIGNvbnRhaW5zO1xuXG4gICAgLy8gaWYgd2UgYXJlIHBhc3NlZCBhIGZlYXR1cmUsIHVzZSB0aGUgcG9seWdvbiBpbnNpZGUgaW5zdGVhZFxuICAgIGlmIChwcmltaXRpdmUudHlwZSA9PT0gJ0ZlYXR1cmUnKSB7XG4gICAgICBwcmltaXRpdmUgPSBwcmltaXRpdmUuZ2VvbWV0cnk7XG4gICAgfVxuXG4gICAgLy8gcG9pbnQud2l0aGluKHBvaW50KSA6OiBlcXVhbGl0eVxuICAgIGlmIChwcmltaXRpdmUudHlwZSA9PT0gXCJQb2ludFwiKSB7XG4gICAgICBpZiAodGhpcy50eXBlID09PSBcIlBvaW50XCIpIHtcbiAgICAgICAgcmV0dXJuIHBvaW50c0VxdWFsKHRoaXMuY29vcmRpbmF0ZXMsIHByaW1pdGl2ZS5jb29yZGluYXRlcyk7XG5cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwb2ludC53aXRoaW4obXVsdGlsaW5lc3RyaW5nKVxuICAgIGlmIChwcmltaXRpdmUudHlwZSA9PT0gXCJNdWx0aUxpbmVTdHJpbmdcIikge1xuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gXCJQb2ludFwiKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwcmltaXRpdmUuY29vcmRpbmF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbGluZXN0cmluZyA9IHsgdHlwZTogXCJMaW5lU3RyaW5nXCIsIGNvb3JkaW5hdGVzOiBwcmltaXRpdmUuY29vcmRpbmF0ZXNbaV0gfTtcblxuICAgICAgICAgIGlmICh0aGlzLndpdGhpbihsaW5lc3RyaW5nKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcG9pbnQud2l0aGluKGxpbmVzdHJpbmcpLCBwb2ludC53aXRoaW4obXVsdGlwb2ludClcbiAgICBpZiAocHJpbWl0aXZlLnR5cGUgPT09IFwiTGluZVN0cmluZ1wiIHx8IHByaW1pdGl2ZS50eXBlID09PSBcIk11bHRpUG9pbnRcIikge1xuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gXCJQb2ludFwiKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwcmltaXRpdmUuY29vcmRpbmF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAodGhpcy5jb29yZGluYXRlcy5sZW5ndGggIT09IHByaW1pdGl2ZS5jb29yZGluYXRlc1tpXS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocG9pbnRzRXF1YWwodGhpcy5jb29yZGluYXRlcywgcHJpbWl0aXZlLmNvb3JkaW5hdGVzW2ldKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByaW1pdGl2ZS50eXBlID09PSBcIlBvbHlnb25cIikge1xuICAgICAgLy8gcG9seWdvbi53aXRoaW4ocG9seWdvbilcbiAgICAgIGlmICh0aGlzLnR5cGUgPT09IFwiUG9seWdvblwiKSB7XG4gICAgICAgIC8vIGNoZWNrIGZvciBlcXVhbCBwb2x5Z29uc1xuICAgICAgICBpZiAocHJpbWl0aXZlLmNvb3JkaW5hdGVzLmxlbmd0aCA9PT0gdGhpcy5jb29yZGluYXRlcy5sZW5ndGgpIHtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5jb29yZGluYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGNvb3JkaW5hdGVzRXF1YWwodGhpcy5jb29yZGluYXRlc1tpXSwgcHJpbWl0aXZlLmNvb3JkaW5hdGVzW2ldKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5jb29yZGluYXRlcy5sZW5ndGggJiYgcG9seWdvbkNvbnRhaW5zUG9pbnQocHJpbWl0aXZlLmNvb3JkaW5hdGVzLCB0aGlzLmNvb3JkaW5hdGVzWzBdWzBdKSkge1xuICAgICAgICAgIHJldHVybiAhYXJyYXlzSW50ZXJzZWN0QXJyYXlzKGNsb3NlZFBvbHlnb24odGhpcy5jb29yZGluYXRlcyksIGNsb3NlZFBvbHlnb24ocHJpbWl0aXZlLmNvb3JkaW5hdGVzKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgIC8vIHBvaW50LndpdGhpbihwb2x5Z29uKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09IFwiUG9pbnRcIikge1xuICAgICAgICByZXR1cm4gcG9seWdvbkNvbnRhaW5zUG9pbnQocHJpbWl0aXZlLmNvb3JkaW5hdGVzLCB0aGlzLmNvb3JkaW5hdGVzKTtcblxuICAgICAgLy8gbGluZXN0cmluZy9tdWx0aXBvaW50IHdpdGhpbmcgcG9seWdvblxuICAgICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09IFwiTGluZVN0cmluZ1wiIHx8IHRoaXMudHlwZSA9PT0gXCJNdWx0aVBvaW50XCIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvb3JkaW5hdGVzIHx8IHRoaXMuY29vcmRpbmF0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuY29vcmRpbmF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAocG9seWdvbkNvbnRhaW5zUG9pbnQocHJpbWl0aXZlLmNvb3JkaW5hdGVzLCB0aGlzLmNvb3JkaW5hdGVzW2ldKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgLy8gbXVsdGlsaW5lc3RyaW5nLndpdGhpbihwb2x5Z29uKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09IFwiTXVsdGlMaW5lU3RyaW5nXCIpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuY29vcmRpbmF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbHMgPSBuZXcgTGluZVN0cmluZyh0aGlzLmNvb3JkaW5hdGVzW2ldKTtcblxuICAgICAgICAgIGlmIChscy53aXRoaW4ocHJpbWl0aXZlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnRhaW5zKys7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgIC8vIG11bHRpcG9seWdvbi53aXRoaW4ocG9seWdvbilcbiAgICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSBcIk11bHRpUG9seWdvblwiKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmNvb3JkaW5hdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHAxID0gbmV3IFByaW1pdGl2ZSh7IHR5cGU6IFwiUG9seWdvblwiLCBjb29yZGluYXRlczogdGhpcy5jb29yZGluYXRlc1tpXSB9KTtcblxuICAgICAgICAgIGlmIChwMS53aXRoaW4ocHJpbWl0aXZlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgIH1cblxuICAgIGlmIChwcmltaXRpdmUudHlwZSA9PT0gXCJNdWx0aVBvbHlnb25cIikge1xuICAgICAgLy8gcG9pbnQud2l0aGluKG11bHRpcG9seWdvbilcbiAgICAgIGlmICh0aGlzLnR5cGUgPT09IFwiUG9pbnRcIikge1xuICAgICAgICBpZiAocHJpbWl0aXZlLmNvb3JkaW5hdGVzLmxlbmd0aCkge1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBwcmltaXRpdmUuY29vcmRpbmF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzID0gcHJpbWl0aXZlLmNvb3JkaW5hdGVzW2ldO1xuICAgICAgICAgICAgaWYgKHBvbHlnb25Db250YWluc1BvaW50KGNvb3JkaW5hdGVzLCB0aGlzLmNvb3JkaW5hdGVzKSAmJiBhcnJheXNJbnRlcnNlY3RBcnJheXMoW3RoaXMuY29vcmRpbmF0ZXNdLCBwcmltaXRpdmUuY29vcmRpbmF0ZXMpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAvLyBwb2x5Z29uLndpdGhpbihtdWx0aXBvbHlnb24pXG4gICAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gXCJQb2x5Z29uXCIpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuY29vcmRpbmF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAocHJpbWl0aXZlLmNvb3JkaW5hdGVzW2ldLmxlbmd0aCA9PT0gdGhpcy5jb29yZGluYXRlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCB0aGlzLmNvb3JkaW5hdGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIGlmIChjb29yZGluYXRlc0VxdWFsKHRoaXMuY29vcmRpbmF0ZXNbal0sIHByaW1pdGl2ZS5jb29yZGluYXRlc1tpXVtqXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhcnJheXNJbnRlcnNlY3RBcnJheXModGhpcy5jb29yZGluYXRlcywgcHJpbWl0aXZlLmNvb3JkaW5hdGVzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBpZiAocHJpbWl0aXZlLmNvb3JkaW5hdGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHByaW1pdGl2ZS5jb29yZGluYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBjb29yZGluYXRlcyA9IHByaW1pdGl2ZS5jb29yZGluYXRlc1tpXTtcbiAgICAgICAgICAgICAgaWYgKHBvbHlnb25Db250YWluc1BvaW50KGNvb3JkaW5hdGVzLCB0aGlzLmNvb3JkaW5hdGVzWzBdWzBdKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBjb250YWlucyA9IGZhbHNlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5zID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY29udGFpbnM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIC8vIGxpbmVzdHJpbmcud2l0aGluKG11bHRpcG9seWdvbiksIG11bHRpcG9pbnQud2l0aGluKG11bHRpcG9seWdvbilcbiAgICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSBcIkxpbmVTdHJpbmdcIiB8fCB0aGlzLnR5cGUgPT09IFwiTXVsdGlQb2ludFwiKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwcmltaXRpdmUuY29vcmRpbmF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgcCA9IHsgdHlwZTogXCJQb2x5Z29uXCIsIGNvb3JkaW5hdGVzOiBwcmltaXRpdmUuY29vcmRpbmF0ZXNbaV0gfTtcblxuICAgICAgICAgIGlmICh0aGlzLndpdGhpbihwKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgIC8vIG11bHRpbGluZXN0cmluZy53aXRoaW4obXVsdGlwb2x5Z29uKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT09IFwiTXVsdGlMaW5lU3RyaW5nXCIpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuY29vcmRpbmF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbGluZXMgPSBuZXcgTGluZVN0cmluZyh0aGlzLmNvb3JkaW5hdGVzW2ldKTtcblxuICAgICAgICAgIGlmIChsaW5lcy53aXRoaW4ocHJpbWl0aXZlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgLy8gbXVsdGlwb2x5Z29uLndpdGhpbihtdWx0aXBvbHlnb24pXG4gICAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gXCJNdWx0aVBvbHlnb25cIikge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcHJpbWl0aXZlLmNvb3JkaW5hdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIG1wb2x5ID0geyB0eXBlOiBcIlBvbHlnb25cIiwgY29vcmRpbmF0ZXM6IHByaW1pdGl2ZS5jb29yZGluYXRlc1tpXSB9O1xuXG4gICAgICAgICAgaWYgKHRoaXMud2l0aGluKG1wb2x5KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkZWZhdWx0IHRvIGZhbHNlXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIFByaW1pdGl2ZS5wcm90b3R5cGUuaW50ZXJzZWN0cyA9IGZ1bmN0aW9uKHByaW1pdGl2ZSkge1xuICAgIC8vIGlmIHdlIGFyZSBwYXNzZWQgYSBmZWF0dXJlLCB1c2UgdGhlIHBvbHlnb24gaW5zaWRlIGluc3RlYWRcbiAgICBpZiAocHJpbWl0aXZlLnR5cGUgPT09ICdGZWF0dXJlJykge1xuICAgICAgcHJpbWl0aXZlID0gcHJpbWl0aXZlLmdlb21ldHJ5O1xuICAgIH1cblxuICAgIHZhciBwID0gbmV3IFByaW1pdGl2ZShwcmltaXRpdmUpO1xuICAgIGlmICh0aGlzLndpdGhpbihwcmltaXRpdmUpIHx8IHAud2l0aGluKHRoaXMpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cblxuICAgIGlmICh0aGlzLnR5cGUgIT09ICdQb2ludCcgJiYgdGhpcy50eXBlICE9PSAnTXVsdGlQb2ludCcgJiZcbiAgICAgICAgcHJpbWl0aXZlLnR5cGUgIT09ICdQb2ludCcgJiYgcHJpbWl0aXZlLnR5cGUgIT09ICdNdWx0aVBvaW50Jykge1xuICAgICAgcmV0dXJuIGFycmF5c0ludGVyc2VjdEFycmF5cyh0aGlzLmNvb3JkaW5hdGVzLCBwcmltaXRpdmUuY29vcmRpbmF0ZXMpO1xuICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSAnRmVhdHVyZScpIHtcbiAgICAgIC8vIGluIHRoZSBjYXNlIG9mIGEgRmVhdHVyZSwgdXNlIHRoZSBpbnRlcm5hbCBwcmltaXRpdmUgZm9yIGludGVyc2VjdGlvblxuICAgICAgdmFyIGlubmVyID0gbmV3IFByaW1pdGl2ZSh0aGlzLmdlb21ldHJ5KTtcbiAgICAgIHJldHVybiBpbm5lci5pbnRlcnNlY3RzKHByaW1pdGl2ZSk7XG4gICAgfVxuXG4gICAgd2FybihcIlR5cGUgXCIgKyB0aGlzLnR5cGUgKyBcIiB0byBcIiArIHByaW1pdGl2ZS50eXBlICsgXCIgaW50ZXJzZWN0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgYnkgaW50ZXJzZWN0c1wiKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cblxuICAvKlxuICBHZW9KU09OIFBvaW50IENsYXNzXG4gICAgbmV3IFBvaW50KCk7XG4gICAgbmV3IFBvaW50KHgseSx6LHd0Zik7XG4gICAgbmV3IFBvaW50KFt4LHkseix3dGZdKTtcbiAgICBuZXcgUG9pbnQoW3gseV0pO1xuICAgIG5ldyBQb2ludCh7XG4gICAgICB0eXBlOiBcIlBvaW50XCIsXG4gICAgICBjb29yZGluYXRlczogW3gseV1cbiAgICB9KTtcbiAgKi9cbiAgZnVuY3Rpb24gUG9pbnQoaW5wdXQpe1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuICAgIGlmKGlucHV0ICYmIGlucHV0LnR5cGUgPT09IFwiUG9pbnRcIiAmJiBpbnB1dC5jb29yZGluYXRlcyl7XG4gICAgICBleHRlbmQodGhpcywgaW5wdXQpO1xuICAgIH0gZWxzZSBpZihpbnB1dCAmJiBpc0FycmF5KGlucHV0KSkge1xuICAgICAgdGhpcy5jb29yZGluYXRlcyA9IGlucHV0O1xuICAgIH0gZWxzZSBpZihhcmdzLmxlbmd0aCA+PSAyKSB7XG4gICAgICB0aGlzLmNvb3JkaW5hdGVzID0gYXJncztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgXCJUZXJyYWZvcm1lcjogaW52YWxpZCBpbnB1dCBmb3IgVGVycmFmb3JtZXIuUG9pbnRcIjtcbiAgICB9XG5cbiAgICB0aGlzLnR5cGUgPSBcIlBvaW50XCI7XG4gIH1cblxuICBQb2ludC5wcm90b3R5cGUgPSBuZXcgUHJpbWl0aXZlKCk7XG4gIFBvaW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBvaW50O1xuXG4gIC8qXG4gIEdlb0pTT04gTXVsdGlQb2ludCBDbGFzc1xuICAgICAgbmV3IE11bHRpUG9pbnQoKTtcbiAgICAgIG5ldyBNdWx0aVBvaW50KFtbeCx5XSwgW3gxLHkxXV0pO1xuICAgICAgbmV3IE11bHRpUG9pbnQoe1xuICAgICAgICB0eXBlOiBcIk11bHRpUG9pbnRcIixcbiAgICAgICAgY29vcmRpbmF0ZXM6IFt4LHldXG4gICAgICB9KTtcbiAgKi9cbiAgZnVuY3Rpb24gTXVsdGlQb2ludChpbnB1dCl7XG4gICAgaWYoaW5wdXQgJiYgaW5wdXQudHlwZSA9PT0gXCJNdWx0aVBvaW50XCIgJiYgaW5wdXQuY29vcmRpbmF0ZXMpe1xuICAgICAgZXh0ZW5kKHRoaXMsIGlucHV0KTtcbiAgICB9IGVsc2UgaWYoaXNBcnJheShpbnB1dCkpIHtcbiAgICAgIHRoaXMuY29vcmRpbmF0ZXMgPSBpbnB1dDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgXCJUZXJyYWZvcm1lcjogaW52YWxpZCBpbnB1dCBmb3IgVGVycmFmb3JtZXIuTXVsdGlQb2ludFwiO1xuICAgIH1cblxuICAgIHRoaXMudHlwZSA9IFwiTXVsdGlQb2ludFwiO1xuICB9XG5cbiAgTXVsdGlQb2ludC5wcm90b3R5cGUgPSBuZXcgUHJpbWl0aXZlKCk7XG4gIE11bHRpUG9pbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTXVsdGlQb2ludDtcbiAgTXVsdGlQb2ludC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uKGZ1bmMpe1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb29yZGluYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgZnVuYy5hcHBseSh0aGlzLCBbdGhpcy5jb29yZGluYXRlc1tpXSwgaSwgdGhpcy5jb29yZGluYXRlc10pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgTXVsdGlQb2ludC5wcm90b3R5cGUuYWRkUG9pbnQgPSBmdW5jdGlvbihwb2ludCl7XG4gICAgdGhpcy5jb29yZGluYXRlcy5wdXNoKHBvaW50KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgTXVsdGlQb2ludC5wcm90b3R5cGUuaW5zZXJ0UG9pbnQgPSBmdW5jdGlvbihwb2ludCwgaW5kZXgpe1xuICAgIHRoaXMuY29vcmRpbmF0ZXMuc3BsaWNlKGluZGV4LCAwLCBwb2ludCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIE11bHRpUG9pbnQucHJvdG90eXBlLnJlbW92ZVBvaW50ID0gZnVuY3Rpb24ocmVtb3ZlKXtcbiAgICBpZih0eXBlb2YgcmVtb3ZlID09PSBcIm51bWJlclwiKXtcbiAgICAgIHRoaXMuY29vcmRpbmF0ZXMuc3BsaWNlKHJlbW92ZSwgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29vcmRpbmF0ZXMuc3BsaWNlKHRoaXMuY29vcmRpbmF0ZXMuaW5kZXhPZihyZW1vdmUpLCAxKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIE11bHRpUG9pbnQucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGkpe1xuICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy5jb29yZGluYXRlc1tpXSk7XG4gIH07XG5cbiAgLypcbiAgR2VvSlNPTiBMaW5lU3RyaW5nIENsYXNzXG4gICAgICBuZXcgTGluZVN0cmluZygpO1xuICAgICAgbmV3IExpbmVTdHJpbmcoW1t4LHldLCBbeDEseTFdXSk7XG4gICAgICBuZXcgTGluZVN0cmluZyh7XG4gICAgICAgIHR5cGU6IFwiTGluZVN0cmluZ1wiLFxuICAgICAgICBjb29yZGluYXRlczogW3gseV1cbiAgICAgIH0pO1xuICAqL1xuICBmdW5jdGlvbiBMaW5lU3RyaW5nKGlucHV0KXtcbiAgICBpZihpbnB1dCAmJiBpbnB1dC50eXBlID09PSBcIkxpbmVTdHJpbmdcIiAmJiBpbnB1dC5jb29yZGluYXRlcyl7XG4gICAgICBleHRlbmQodGhpcywgaW5wdXQpO1xuICAgIH0gZWxzZSBpZihpc0FycmF5KGlucHV0KSkge1xuICAgICAgdGhpcy5jb29yZGluYXRlcyA9IGlucHV0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBcIlRlcnJhZm9ybWVyOiBpbnZhbGlkIGlucHV0IGZvciBUZXJyYWZvcm1lci5MaW5lU3RyaW5nXCI7XG4gICAgfVxuXG4gICAgdGhpcy50eXBlID0gXCJMaW5lU3RyaW5nXCI7XG4gIH1cblxuICBMaW5lU3RyaW5nLnByb3RvdHlwZSA9IG5ldyBQcmltaXRpdmUoKTtcbiAgTGluZVN0cmluZy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMaW5lU3RyaW5nO1xuICBMaW5lU3RyaW5nLnByb3RvdHlwZS5hZGRWZXJ0ZXggPSBmdW5jdGlvbihwb2ludCl7XG4gICAgdGhpcy5jb29yZGluYXRlcy5wdXNoKHBvaW50KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgTGluZVN0cmluZy5wcm90b3R5cGUuaW5zZXJ0VmVydGV4ID0gZnVuY3Rpb24ocG9pbnQsIGluZGV4KXtcbiAgICB0aGlzLmNvb3JkaW5hdGVzLnNwbGljZShpbmRleCwgMCwgcG9pbnQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBMaW5lU3RyaW5nLnByb3RvdHlwZS5yZW1vdmVWZXJ0ZXggPSBmdW5jdGlvbihyZW1vdmUpe1xuICAgIHRoaXMuY29vcmRpbmF0ZXMuc3BsaWNlKHJlbW92ZSwgMSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLypcbiAgR2VvSlNPTiBNdWx0aUxpbmVTdHJpbmcgQ2xhc3NcbiAgICAgIG5ldyBNdWx0aUxpbmVTdHJpbmcoKTtcbiAgICAgIG5ldyBNdWx0aUxpbmVTdHJpbmcoWyBbW3gseV0sIFt4MSx5MV1dLCBbW3gyLHkyXSwgW3gzLHkzXV0gXSk7XG4gICAgICBuZXcgTXVsdGlMaW5lU3RyaW5nKHtcbiAgICAgICAgdHlwZTogXCJNdWx0aUxpbmVTdHJpbmdcIixcbiAgICAgICAgY29vcmRpbmF0ZXM6IFsgW1t4LHldLCBbeDEseTFdXSwgW1t4Mix5Ml0sIFt4Myx5M11dIF1cbiAgICAgIH0pO1xuICAqL1xuICBmdW5jdGlvbiBNdWx0aUxpbmVTdHJpbmcoaW5wdXQpe1xuICAgIGlmKGlucHV0ICYmIGlucHV0LnR5cGUgPT09IFwiTXVsdGlMaW5lU3RyaW5nXCIgJiYgaW5wdXQuY29vcmRpbmF0ZXMpe1xuICAgICAgZXh0ZW5kKHRoaXMsIGlucHV0KTtcbiAgICB9IGVsc2UgaWYoaXNBcnJheShpbnB1dCkpIHtcbiAgICAgIHRoaXMuY29vcmRpbmF0ZXMgPSBpbnB1dDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgXCJUZXJyYWZvcm1lcjogaW52YWxpZCBpbnB1dCBmb3IgVGVycmFmb3JtZXIuTXVsdGlMaW5lU3RyaW5nXCI7XG4gICAgfVxuXG4gICAgdGhpcy50eXBlID0gXCJNdWx0aUxpbmVTdHJpbmdcIjtcbiAgfVxuXG4gIE11bHRpTGluZVN0cmluZy5wcm90b3R5cGUgPSBuZXcgUHJpbWl0aXZlKCk7XG4gIE11bHRpTGluZVN0cmluZy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNdWx0aUxpbmVTdHJpbmc7XG4gIE11bHRpTGluZVN0cmluZy5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uKGZ1bmMpe1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb29yZGluYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgZnVuYy5hcHBseSh0aGlzLCBbdGhpcy5jb29yZGluYXRlc1tpXSwgaSwgdGhpcy5jb29yZGluYXRlcyBdKTtcbiAgICB9XG4gIH07XG4gIE11bHRpTGluZVN0cmluZy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oaSl7XG4gICAgcmV0dXJuIG5ldyBMaW5lU3RyaW5nKHRoaXMuY29vcmRpbmF0ZXNbaV0pO1xuICB9O1xuXG4gIC8qXG4gIEdlb0pTT04gUG9seWdvbiBDbGFzc1xuICAgICAgbmV3IFBvbHlnb24oKTtcbiAgICAgIG5ldyBQb2x5Z29uKFsgW1t4LHldLCBbeDEseTFdLCBbeDIseTJdXSBdKTtcbiAgICAgIG5ldyBQb2x5Z29uKHtcbiAgICAgICAgdHlwZTogXCJQb2x5Z29uXCIsXG4gICAgICAgIGNvb3JkaW5hdGVzOiBbIFtbeCx5XSwgW3gxLHkxXSwgW3gyLHkyXV0gXVxuICAgICAgfSk7XG4gICovXG4gIGZ1bmN0aW9uIFBvbHlnb24oaW5wdXQpe1xuICAgIGlmKGlucHV0ICYmIGlucHV0LnR5cGUgPT09IFwiUG9seWdvblwiICYmIGlucHV0LmNvb3JkaW5hdGVzKXtcbiAgICAgIGV4dGVuZCh0aGlzLCBpbnB1dCk7XG4gICAgfSBlbHNlIGlmKGlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICB0aGlzLmNvb3JkaW5hdGVzID0gaW5wdXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IFwiVGVycmFmb3JtZXI6IGludmFsaWQgaW5wdXQgZm9yIFRlcnJhZm9ybWVyLlBvbHlnb25cIjtcbiAgICB9XG5cbiAgICB0aGlzLnR5cGUgPSBcIlBvbHlnb25cIjtcbiAgfVxuXG4gIFBvbHlnb24ucHJvdG90eXBlID0gbmV3IFByaW1pdGl2ZSgpO1xuICBQb2x5Z29uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBvbHlnb247XG4gIFBvbHlnb24ucHJvdG90eXBlLmFkZFZlcnRleCA9IGZ1bmN0aW9uKHBvaW50KXtcbiAgICB0aGlzLmluc2VydFZlcnRleChwb2ludCwgdGhpcy5jb29yZGluYXRlc1swXS5sZW5ndGggLSAxKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgUG9seWdvbi5wcm90b3R5cGUuaW5zZXJ0VmVydGV4ID0gZnVuY3Rpb24ocG9pbnQsIGluZGV4KXtcbiAgICB0aGlzLmNvb3JkaW5hdGVzWzBdLnNwbGljZShpbmRleCwgMCwgcG9pbnQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBQb2x5Z29uLnByb3RvdHlwZS5yZW1vdmVWZXJ0ZXggPSBmdW5jdGlvbihyZW1vdmUpe1xuICAgIHRoaXMuY29vcmRpbmF0ZXNbMF0uc3BsaWNlKHJlbW92ZSwgMSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIFBvbHlnb24ucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jb29yZGluYXRlcyA9IGNsb3NlZFBvbHlnb24odGhpcy5jb29yZGluYXRlcyk7XG4gIH07XG4gIFBvbHlnb24ucHJvdG90eXBlLmhhc0hvbGVzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuY29vcmRpbmF0ZXMubGVuZ3RoID4gMTtcbiAgfTtcbiAgUG9seWdvbi5wcm90b3R5cGUuaG9sZXMgPSBmdW5jdGlvbigpIHtcbiAgICBob2xlcyA9IFtdO1xuICAgIGlmICh0aGlzLmhhc0hvbGVzKCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5jb29yZGluYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBob2xlcy5wdXNoKG5ldyBQb2x5Z29uKFt0aGlzLmNvb3JkaW5hdGVzW2ldXSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaG9sZXM7XG4gIH07XG5cbiAgLypcbiAgR2VvSlNPTiBNdWx0aVBvbHlnb24gQ2xhc3NcbiAgICAgIG5ldyBNdWx0aVBvbHlnb24oKTtcbiAgICAgIG5ldyBNdWx0aVBvbHlnb24oWyBbIFtbeCx5XSwgW3gxLHkxXV0sIFtbeDIseTJdLCBbeDMseTNdXSBdIF0pO1xuICAgICAgbmV3IE11bHRpUG9seWdvbih7XG4gICAgICAgIHR5cGU6IFwiTXVsdGlQb2x5Z29uXCIsXG4gICAgICAgIGNvb3JkaW5hdGVzOiBbIFsgW1t4LHldLCBbeDEseTFdXSwgW1t4Mix5Ml0sIFt4Myx5M11dIF0gXVxuICAgICAgfSk7XG4gICovXG4gIGZ1bmN0aW9uIE11bHRpUG9seWdvbihpbnB1dCl7XG4gICAgaWYoaW5wdXQgJiYgaW5wdXQudHlwZSA9PT0gXCJNdWx0aVBvbHlnb25cIiAmJiBpbnB1dC5jb29yZGluYXRlcyl7XG4gICAgICBleHRlbmQodGhpcywgaW5wdXQpO1xuICAgIH0gZWxzZSBpZihpc0FycmF5KGlucHV0KSkge1xuICAgICAgdGhpcy5jb29yZGluYXRlcyA9IGlucHV0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBcIlRlcnJhZm9ybWVyOiBpbnZhbGlkIGlucHV0IGZvciBUZXJyYWZvcm1lci5NdWx0aVBvbHlnb25cIjtcbiAgICB9XG5cbiAgICB0aGlzLnR5cGUgPSBcIk11bHRpUG9seWdvblwiO1xuICB9XG5cbiAgTXVsdGlQb2x5Z29uLnByb3RvdHlwZSA9IG5ldyBQcmltaXRpdmUoKTtcbiAgTXVsdGlQb2x5Z29uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE11bHRpUG9seWdvbjtcbiAgTXVsdGlQb2x5Z29uLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24oZnVuYyl7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvb3JkaW5hdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmdW5jLmFwcGx5KHRoaXMsIFt0aGlzLmNvb3JkaW5hdGVzW2ldLCBpLCB0aGlzLmNvb3JkaW5hdGVzIF0pO1xuICAgIH1cbiAgfTtcbiAgTXVsdGlQb2x5Z29uLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihpKXtcbiAgICByZXR1cm4gbmV3IFBvbHlnb24odGhpcy5jb29yZGluYXRlc1tpXSk7XG4gIH07XG4gIE11bHRpUG9seWdvbi5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpe1xuICAgIHZhciBvdXRlciA9IFtdO1xuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbihwb2x5Z29uKXtcbiAgICAgIG91dGVyLnB1c2goY2xvc2VkUG9seWdvbihwb2x5Z29uKSk7XG4gICAgfSk7XG4gICAgdGhpcy5jb29yZGluYXRlcyA9IG91dGVyO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qXG4gIEdlb0pTT04gRmVhdHVyZSBDbGFzc1xuICAgICAgbmV3IEZlYXR1cmUoKTtcbiAgICAgIG5ldyBGZWF0dXJlKHtcbiAgICAgICAgdHlwZTogXCJGZWF0dXJlXCIsXG4gICAgICAgIGdlb21ldHJ5OiB7XG4gICAgICAgICAgdHlwZTogXCJQb2x5Z29uXCIsXG4gICAgICAgICAgY29vcmRpbmF0ZXM6IFsgWyBbW3gseV0sIFt4MSx5MV1dLCBbW3gyLHkyXSwgW3gzLHkzXV0gXSBdXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgbmV3IEZlYXR1cmUoe1xuICAgICAgICB0eXBlOiBcIlBvbHlnb25cIixcbiAgICAgICAgY29vcmRpbmF0ZXM6IFsgWyBbW3gseV0sIFt4MSx5MV1dLCBbW3gyLHkyXSwgW3gzLHkzXV0gXSBdXG4gICAgICB9KTtcbiAgKi9cbiAgZnVuY3Rpb24gRmVhdHVyZShpbnB1dCl7XG4gICAgaWYoaW5wdXQgJiYgaW5wdXQudHlwZSA9PT0gXCJGZWF0dXJlXCIpe1xuICAgICAgZXh0ZW5kKHRoaXMsIGlucHV0KTtcbiAgICB9IGVsc2UgaWYoaW5wdXQgJiYgaW5wdXQudHlwZSAmJiBpbnB1dC5jb29yZGluYXRlcykge1xuICAgICAgdGhpcy5nZW9tZXRyeSA9IGlucHV0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBcIlRlcnJhZm9ybWVyOiBpbnZhbGlkIGlucHV0IGZvciBUZXJyYWZvcm1lci5GZWF0dXJlXCI7XG4gICAgfVxuXG4gICAgdGhpcy50eXBlID0gXCJGZWF0dXJlXCI7XG4gIH1cblxuICBGZWF0dXJlLnByb3RvdHlwZSA9IG5ldyBQcmltaXRpdmUoKTtcbiAgRmVhdHVyZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGZWF0dXJlO1xuXG4gIC8qXG4gIEdlb0pTT04gRmVhdHVyZUNvbGxlY3Rpb24gQ2xhc3NcbiAgICAgIG5ldyBGZWF0dXJlQ29sbGVjdGlvbigpO1xuICAgICAgbmV3IEZlYXR1cmVDb2xsZWN0aW9uKFtmZWF0dXJlLCBmZWF0dXJlMV0pO1xuICAgICAgbmV3IEZlYXR1cmVDb2xsZWN0aW9uKHtcbiAgICAgICAgdHlwZTogXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICAgICAgICBjb29yZGluYXRlczogW2ZlYXR1cmUsIGZlYXR1cmUxXVxuICAgICAgfSk7XG4gICovXG4gIGZ1bmN0aW9uIEZlYXR1cmVDb2xsZWN0aW9uKGlucHV0KXtcbiAgICBpZihpbnB1dCAmJiBpbnB1dC50eXBlID09PSBcIkZlYXR1cmVDb2xsZWN0aW9uXCIgJiYgaW5wdXQuZmVhdHVyZXMpe1xuICAgICAgZXh0ZW5kKHRoaXMsIGlucHV0KTtcbiAgICB9IGVsc2UgaWYoaXNBcnJheShpbnB1dCkpIHtcbiAgICAgIHRoaXMuZmVhdHVyZXMgPSBpbnB1dDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgXCJUZXJyYWZvcm1lcjogaW52YWxpZCBpbnB1dCBmb3IgVGVycmFmb3JtZXIuRmVhdHVyZUNvbGxlY3Rpb25cIjtcbiAgICB9XG5cbiAgICB0aGlzLnR5cGUgPSBcIkZlYXR1cmVDb2xsZWN0aW9uXCI7XG4gIH1cblxuICBGZWF0dXJlQ29sbGVjdGlvbi5wcm90b3R5cGUgPSBuZXcgUHJpbWl0aXZlKCk7XG4gIEZlYXR1cmVDb2xsZWN0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEZlYXR1cmVDb2xsZWN0aW9uO1xuICBGZWF0dXJlQ29sbGVjdGlvbi5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uKGZ1bmMpe1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5mZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgZnVuYy5hcHBseSh0aGlzLCBbdGhpcy5mZWF0dXJlc1tpXSwgaSwgdGhpcy5mZWF0dXJlc10pO1xuICAgIH1cbiAgfTtcbiAgRmVhdHVyZUNvbGxlY3Rpb24ucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGlkKXtcbiAgICB2YXIgZm91bmQ7XG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKGZlYXR1cmUpe1xuICAgICAgaWYoZmVhdHVyZS5pZCA9PT0gaWQpe1xuICAgICAgICBmb3VuZCA9IGZlYXR1cmU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBGZWF0dXJlKGZvdW5kKTtcbiAgfTtcblxuICAvKlxuICBHZW9KU09OIEdlb21ldHJ5Q29sbGVjdGlvbiBDbGFzc1xuICAgICAgbmV3IEdlb21ldHJ5Q29sbGVjdGlvbigpO1xuICAgICAgbmV3IEdlb21ldHJ5Q29sbGVjdGlvbihbZ2VvbWV0cnksIGdlb21ldHJ5MV0pO1xuICAgICAgbmV3IEdlb21ldHJ5Q29sbGVjdGlvbih7XG4gICAgICAgIHR5cGU6IFwiR2VvbWV0cnlDb2xsZWN0aW9uXCIsXG4gICAgICAgIGNvb3JkaW5hdGVzOiBbZ2VvbWV0cnksIGdlb21ldHJ5MV1cbiAgICAgIH0pO1xuICAqL1xuICBmdW5jdGlvbiBHZW9tZXRyeUNvbGxlY3Rpb24oaW5wdXQpe1xuICAgIGlmKGlucHV0ICYmIGlucHV0LnR5cGUgPT09IFwiR2VvbWV0cnlDb2xsZWN0aW9uXCIgJiYgaW5wdXQuZ2VvbWV0cmllcyl7XG4gICAgICBleHRlbmQodGhpcywgaW5wdXQpO1xuICAgIH0gZWxzZSBpZihpc0FycmF5KGlucHV0KSkge1xuICAgICAgdGhpcy5nZW9tZXRyaWVzID0gaW5wdXQ7XG4gICAgfSBlbHNlIGlmKGlucHV0LmNvb3JkaW5hdGVzICYmIGlucHV0LnR5cGUpe1xuICAgICAgdGhpcy50eXBlID0gXCJHZW9tZXRyeUNvbGxlY3Rpb25cIjtcbiAgICAgIHRoaXMuZ2VvbWV0cmllcyA9IFtpbnB1dF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IFwiVGVycmFmb3JtZXI6IGludmFsaWQgaW5wdXQgZm9yIFRlcnJhZm9ybWVyLkdlb21ldHJ5Q29sbGVjdGlvblwiO1xuICAgIH1cblxuICAgIHRoaXMudHlwZSA9IFwiR2VvbWV0cnlDb2xsZWN0aW9uXCI7XG4gIH1cblxuICBHZW9tZXRyeUNvbGxlY3Rpb24ucHJvdG90eXBlID0gbmV3IFByaW1pdGl2ZSgpO1xuICBHZW9tZXRyeUNvbGxlY3Rpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VvbWV0cnlDb2xsZWN0aW9uO1xuICBHZW9tZXRyeUNvbGxlY3Rpb24ucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbihmdW5jKXtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZ2VvbWV0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgZnVuYy5hcHBseSh0aGlzLCBbdGhpcy5nZW9tZXRyaWVzW2ldLCBpLCB0aGlzLmdlb21ldHJpZXNdKTtcbiAgICB9XG4gIH07XG4gIEdlb21ldHJ5Q29sbGVjdGlvbi5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oaSl7XG4gICAgcmV0dXJuIG5ldyBQcmltaXRpdmUodGhpcy5nZW9tZXRyaWVzW2ldKTtcbiAgfTtcblxuICBmdW5jdGlvbiBjcmVhdGVDaXJjbGUoY2VudGVyLCByYWRpdXMsIGludGVycG9sYXRlKXtcbiAgICB2YXIgbWVyY2F0b3JQb3NpdGlvbiA9IHBvc2l0aW9uVG9NZXJjYXRvcihjZW50ZXIpO1xuICAgIHZhciBzdGVwcyA9IGludGVycG9sYXRlIHx8IDY0O1xuICAgIHZhciBwb2x5Z29uID0ge1xuICAgICAgdHlwZTogXCJQb2x5Z29uXCIsXG4gICAgICBjb29yZGluYXRlczogW1tdXVxuICAgIH07XG4gICAgZm9yKHZhciBpPTE7IGk8PXN0ZXBzOyBpKyspIHtcbiAgICAgIHZhciByYWRpYW5zID0gaSAqICgzNjAvc3RlcHMpICogTWF0aC5QSSAvIDE4MDtcbiAgICAgIHBvbHlnb24uY29vcmRpbmF0ZXNbMF0ucHVzaChbbWVyY2F0b3JQb3NpdGlvblswXSArIHJhZGl1cyAqIE1hdGguY29zKHJhZGlhbnMpLCBtZXJjYXRvclBvc2l0aW9uWzFdICsgcmFkaXVzICogTWF0aC5zaW4ocmFkaWFucyldKTtcbiAgICB9XG4gICAgcG9seWdvbi5jb29yZGluYXRlcyA9IGNsb3NlZFBvbHlnb24ocG9seWdvbi5jb29yZGluYXRlcyk7XG5cbiAgICByZXR1cm4gdG9HZW9ncmFwaGljKHBvbHlnb24pO1xuICB9XG5cbiAgZnVuY3Rpb24gQ2lyY2xlIChjZW50ZXIsIHJhZGl1cywgaW50ZXJwb2xhdGUpIHtcbiAgICB2YXIgc3RlcHMgPSBpbnRlcnBvbGF0ZSB8fCA2NDtcbiAgICB2YXIgcmFkID0gcmFkaXVzIHx8IDI1MDtcblxuICAgIGlmKCFjZW50ZXIgfHwgY2VudGVyLmxlbmd0aCA8IDIgfHwgIXJhZCB8fCAhc3RlcHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRlcnJhZm9ybWVyOiBtaXNzaW5nIHBhcmFtZXRlciBmb3IgVGVycmFmb3JtZXIuQ2lyY2xlXCIpO1xuICAgIH1cblxuICAgIGV4dGVuZCh0aGlzLCBuZXcgRmVhdHVyZSh7XG4gICAgICB0eXBlOiBcIkZlYXR1cmVcIixcbiAgICAgIGdlb21ldHJ5OiBjcmVhdGVDaXJjbGUoY2VudGVyLCByYWQsIHN0ZXBzKSxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgcmFkaXVzOiByYWQsXG4gICAgICAgIGNlbnRlcjogY2VudGVyLFxuICAgICAgICBzdGVwczogc3RlcHNcbiAgICAgIH1cbiAgICB9KSk7XG4gIH1cblxuICBDaXJjbGUucHJvdG90eXBlID0gbmV3IFByaW1pdGl2ZSgpO1xuICBDaXJjbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2lyY2xlO1xuICBDaXJjbGUucHJvdG90eXBlLnJlY2FsY3VsYXRlID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmdlb21ldHJ5ID0gY3JlYXRlQ2lyY2xlKHRoaXMucHJvcGVydGllcy5jZW50ZXIsIHRoaXMucHJvcGVydGllcy5yYWRpdXMsIHRoaXMucHJvcGVydGllcy5zdGVwcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIENpcmNsZS5wcm90b3R5cGUuY2VudGVyID0gZnVuY3Rpb24oY29vcmRpbmF0ZXMpe1xuICAgIGlmKGNvb3JkaW5hdGVzKXtcbiAgICAgIHRoaXMucHJvcGVydGllcy5jZW50ZXIgPSBjb29yZGluYXRlcztcbiAgICAgIHRoaXMucmVjYWxjdWxhdGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucHJvcGVydGllcy5jZW50ZXI7XG4gIH07XG4gIENpcmNsZS5wcm90b3R5cGUucmFkaXVzID0gZnVuY3Rpb24ocmFkaXVzKXtcbiAgICBpZihyYWRpdXMpe1xuICAgICAgdGhpcy5wcm9wZXJ0aWVzLnJhZGl1cyA9IHJhZGl1cztcbiAgICAgIHRoaXMucmVjYWxjdWxhdGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucHJvcGVydGllcy5yYWRpdXM7XG4gIH07XG4gIENpcmNsZS5wcm90b3R5cGUuc3RlcHMgPSBmdW5jdGlvbihzdGVwcyl7XG4gICAgaWYoc3RlcHMpe1xuICAgICAgdGhpcy5wcm9wZXJ0aWVzLnN0ZXBzID0gc3RlcHM7XG4gICAgICB0aGlzLnJlY2FsY3VsYXRlKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXMuc3RlcHM7XG4gIH07XG5cbiAgQ2lyY2xlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0cHV0ID0gUHJpbWl0aXZlLnByb3RvdHlwZS50b0pTT04uY2FsbCh0aGlzKTtcbiAgICByZXR1cm4gb3V0cHV0O1xuICB9O1xuXG4gIGV4cG9ydHMuUHJpbWl0aXZlID0gUHJpbWl0aXZlO1xuICBleHBvcnRzLlBvaW50ID0gUG9pbnQ7XG4gIGV4cG9ydHMuTXVsdGlQb2ludCA9IE11bHRpUG9pbnQ7XG4gIGV4cG9ydHMuTGluZVN0cmluZyA9IExpbmVTdHJpbmc7XG4gIGV4cG9ydHMuTXVsdGlMaW5lU3RyaW5nID0gTXVsdGlMaW5lU3RyaW5nO1xuICBleHBvcnRzLlBvbHlnb24gPSBQb2x5Z29uO1xuICBleHBvcnRzLk11bHRpUG9seWdvbiA9IE11bHRpUG9seWdvbjtcbiAgZXhwb3J0cy5GZWF0dXJlID0gRmVhdHVyZTtcbiAgZXhwb3J0cy5GZWF0dXJlQ29sbGVjdGlvbiA9IEZlYXR1cmVDb2xsZWN0aW9uO1xuICBleHBvcnRzLkdlb21ldHJ5Q29sbGVjdGlvbiA9IEdlb21ldHJ5Q29sbGVjdGlvbjtcbiAgZXhwb3J0cy5DaXJjbGUgPSBDaXJjbGU7XG5cbiAgZXhwb3J0cy50b01lcmNhdG9yID0gdG9NZXJjYXRvcjtcbiAgZXhwb3J0cy50b0dlb2dyYXBoaWMgPSB0b0dlb2dyYXBoaWM7XG5cbiAgZXhwb3J0cy5Ub29scyA9IHt9O1xuICBleHBvcnRzLlRvb2xzLnBvc2l0aW9uVG9NZXJjYXRvciA9IHBvc2l0aW9uVG9NZXJjYXRvcjtcbiAgZXhwb3J0cy5Ub29scy5wb3NpdGlvblRvR2VvZ3JhcGhpYyA9IHBvc2l0aW9uVG9HZW9ncmFwaGljO1xuICBleHBvcnRzLlRvb2xzLmFwcGx5Q29udmVydGVyID0gYXBwbHlDb252ZXJ0ZXI7XG4gIGV4cG9ydHMuVG9vbHMudG9NZXJjYXRvciA9IHRvTWVyY2F0b3I7XG4gIGV4cG9ydHMuVG9vbHMudG9HZW9ncmFwaGljID0gdG9HZW9ncmFwaGljO1xuICBleHBvcnRzLlRvb2xzLmNyZWF0ZUNpcmNsZSA9IGNyZWF0ZUNpcmNsZTtcblxuICBleHBvcnRzLlRvb2xzLmNhbGN1bGF0ZUJvdW5kcyA9IGNhbGN1bGF0ZUJvdW5kcztcbiAgZXhwb3J0cy5Ub29scy5jYWxjdWxhdGVFbnZlbG9wZSA9IGNhbGN1bGF0ZUVudmVsb3BlO1xuXG4gIGV4cG9ydHMuVG9vbHMuY29vcmRpbmF0ZXNDb250YWluUG9pbnQgPSBjb29yZGluYXRlc0NvbnRhaW5Qb2ludDtcbiAgZXhwb3J0cy5Ub29scy5wb2x5Z29uQ29udGFpbnNQb2ludCA9IHBvbHlnb25Db250YWluc1BvaW50O1xuICBleHBvcnRzLlRvb2xzLmFycmF5c0ludGVyc2VjdEFycmF5cyA9IGFycmF5c0ludGVyc2VjdEFycmF5cztcbiAgZXhwb3J0cy5Ub29scy5jb29yZGluYXRlc0NvbnRhaW5Qb2ludCA9IGNvb3JkaW5hdGVzQ29udGFpblBvaW50O1xuICBleHBvcnRzLlRvb2xzLmNvb3JkaW5hdGVzRXF1YWwgPSBjb29yZGluYXRlc0VxdWFsO1xuICBleHBvcnRzLlRvb2xzLmNvbnZleEh1bGwgPSBjb252ZXhIdWxsO1xuICBleHBvcnRzLlRvb2xzLmlzQ29udmV4ID0gaXNDb252ZXg7XG5cbiAgZXhwb3J0cy5NZXJjYXRvckNSUyA9IE1lcmNhdG9yQ1JTO1xuICBleHBvcnRzLkdlb2dyYXBoaWNDUlMgPSBHZW9ncmFwaGljQ1JTO1xuXG4gIHJldHVybiBleHBvcnRzO1xufSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3RlcnJhZm9ybWVyL3RlcnJhZm9ybWVyLmpzXG4vLyBtb2R1bGUgaWQgPSAzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9')},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar layerRecord = __webpack_require__(20)();\nvar attribFC = __webpack_require__(18)();\n\n/**\r\n * @class AttribRecord\r\n */\n\nvar AttribRecord = function (_layerRecord$LayerRec) {\n    _inherits(AttribRecord, _layerRecord$LayerRec);\n\n    _createClass(AttribRecord, [{\n        key: 'clickTolerance',\n\n        // this class has functions common to layers that have attributes\n\n        get: function get() {\n            return this._tolerance;\n        }\n\n        /**\r\n         * Create a layer record with the appropriate geoApi layer type.  Layer config\r\n         * should be fully merged with all layer options defined (i.e. this constructor\r\n         * will not apply any defaults).\r\n         * @param {Object} layerClass    the ESRI api object for the layer\r\n         * @param {Object} esriRequest   the ESRI api object for making web requests with proxy support\r\n         * @param {Object} apiRef        object pointing to the geoApi. allows us to call other geoApi functions.\r\n         * @param {Object} config        layer config values\r\n         * @param {Object} esriLayer     an optional pre-constructed layer\r\n         * @param {Function} epsgLookup  an optional lookup function for EPSG codes (see geoService for signature)\r\n         */\n\n    }]);\n\n    function AttribRecord(layerClass, esriRequest, apiRef, config, esriLayer, epsgLookup) {\n        _classCallCheck(this, AttribRecord);\n\n        var _this = _possibleConstructorReturn(this, (AttribRecord.__proto__ || Object.getPrototypeOf(AttribRecord)).call(this, layerClass, apiRef, config, esriLayer, epsgLookup));\n\n        _this._esriRequest = esriRequest;\n        _this._tolerance = _this.config.tolerance;\n        return _this;\n    }\n\n    /**\r\n     * Get the best user-friendly name of a field. Uses alias if alias is defined, else uses the system attribute name.\r\n     *\r\n     * @param {String} attribName     the attribute name we want a nice name for\r\n     * @return {Promise}              resolves to the best available user friendly attribute name\r\n     */\n\n\n    _createClass(AttribRecord, [{\n        key: 'aliasedFieldName',\n        value: function aliasedFieldName(attribName) {\n            return this._featClasses[this._defaultFC].aliasedFieldName(attribName);\n        }\n\n        /**\r\n         * Retrieves attributes from a layer for a specified feature index\r\n         * @return {Promise}            promise resolving with formatted attributes to be consumed by the datagrid and esri feature identify\r\n         */\n\n    }, {\n        key: 'getFormattedAttributes',\n        value: function getFormattedAttributes() {\n            return this._featClasses[this._defaultFC].getFormattedAttributes();\n        }\n    }, {\n        key: 'checkDateType',\n        value: function checkDateType(attribName) {\n            return this._featClasses[this._defaultFC].checkDateType(attribName);\n        }\n\n        /**\r\n        * Returns attribute data for this layer.\r\n        *\r\n        * @function getAttribs\r\n        * @returns {Promise}         resolves with a layer attribute data object\r\n        */\n\n    }, {\n        key: 'getAttribs',\n        value: function getAttribs() {\n            return this._featClasses[this._defaultFC].getAttribs();\n        }\n\n        /**\r\n        * Returns layer-specific data for this Record\r\n        *\r\n        * @function getLayerData\r\n        * @returns {Promise}         resolves with a layer data object\r\n        */\n\n    }, {\n        key: 'getLayerData',\n        value: function getLayerData() {\n            return this._featClasses[this._defaultFC].getLayerData();\n        }\n    }, {\n        key: 'getFeatureName',\n        value: function getFeatureName(objId, attribs) {\n            return this._featClasses[this._defaultFC].getFeatureName(objId, attribs);\n        }\n    }, {\n        key: 'fetchGraphic',\n        value: function fetchGraphic(objId) {\n            var ignoreLocal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n            return this._featClasses[this._defaultFC].fetchGraphic(objId, ignoreLocal);\n        }\n    }, {\n        key: 'getFeatureCount',\n        value: function getFeatureCount(url) {\n            var _this2 = this;\n\n            if (url) {\n                // wrapping server call in a function, as we regularly encounter sillyness\n                // where we need to execute the count request twice.\n                // having a function (with finalTry flag) lets us handle the double-request\n                var esriServerCount = function esriServerCount(layerUrl) {\n                    var finalTry = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n                    // extract info for this service\n                    var defService = _this2._esriRequest({\n                        url: layerUrl + '/query',\n                        content: {\n                            f: 'json',\n                            where: '1=1',\n                            returnCountOnly: true,\n                            returnGeometry: false\n                        },\n                        callbackParamName: 'callback',\n                        handleAs: 'json'\n                    });\n\n                    return new Promise(function (resolve) {\n                        defService.then(function (serviceResult) {\n                            if (serviceResult && typeof serviceResult.error === 'undefined' && typeof serviceResult.count !== 'undefined') {\n                                // we got a row count\n                                resolve(serviceResult.count);\n                            } else if (!finalTry) {\n                                // do a second attempt\n                                resolve(esriServerCount(layerUrl, true));\n                            } else {\n                                // tells the app it failed\n                                resolve(-1);\n                            }\n                        }, function (error) {\n                            // failed to load service info.\n                            // TODO any tricks to avoid duplicating the error case in both blocks?\n                            if (!finalTry) {\n                                // do a second attempt\n                                resolve(esriServerCount(layerUrl, true));\n                            } else {\n                                // tells the app it failed\n                                console.warn(error);\n                                resolve(-1);\n                            }\n                        });\n                    });\n                };\n\n                return esriServerCount(url);\n            } else {\n                // file based layer.  count local features\n                return Promise.resolve(this._layer.graphics.length);\n            }\n        }\n\n        /**\r\n         * Transforms esri key-value attribute object into key value array with format suitable\r\n         * for consumption by the details pane.\r\n         *\r\n         * @param  {Object} attribs      attribute key-value mapping, potentially with aliases as keys\r\n         * @param  {Array} fields        optional. fields definition array for layer. no aliasing done if not provided\r\n         * @return {Array}               attribute data transformed into a list, with potential field aliasing applied\r\n         */\n\n    }, {\n        key: 'attributesToDetails',\n        value: function attributesToDetails(attribs, fields) {\n            // TODO make this extensible / modifiable / configurable to allow different details looks for different data\n            // simple array of text mapping for demonstration purposes. fancy grid formatting later?\n            return Object.keys(attribs).map(function (key) {\n                var fieldType = fields ? fields.find(function (f) {\n                    return f.name === key;\n                }) : null;\n                return {\n                    key: attribFC.AttribFC.aliasedFieldNameDirect(key, fields), // need synchronous variant of alias lookup\n                    value: attribs[key],\n                    type: fieldType ? fieldType.type : fieldType\n                };\n            });\n        }\n    }]);\n\n    return AttribRecord;\n}(layerRecord.LayerRecord);\n\nmodule.exports = function () {\n    return {\n        AttribRecord: AttribRecord\n    };\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXIvbGF5ZXJSZWMvYXR0cmliUmVjb3JkLmpzPzM1YmUiXSwibmFtZXMiOlsibGF5ZXJSZWNvcmQiLCJyZXF1aXJlIiwiYXR0cmliRkMiLCJBdHRyaWJSZWNvcmQiLCJfdG9sZXJhbmNlIiwibGF5ZXJDbGFzcyIsImVzcmlSZXF1ZXN0IiwiYXBpUmVmIiwiY29uZmlnIiwiZXNyaUxheWVyIiwiZXBzZ0xvb2t1cCIsIl9lc3JpUmVxdWVzdCIsInRvbGVyYW5jZSIsImF0dHJpYk5hbWUiLCJfZmVhdENsYXNzZXMiLCJfZGVmYXVsdEZDIiwiYWxpYXNlZEZpZWxkTmFtZSIsImdldEZvcm1hdHRlZEF0dHJpYnV0ZXMiLCJjaGVja0RhdGVUeXBlIiwiZ2V0QXR0cmlicyIsImdldExheWVyRGF0YSIsIm9iaklkIiwiYXR0cmlicyIsImdldEZlYXR1cmVOYW1lIiwiaWdub3JlTG9jYWwiLCJmZXRjaEdyYXBoaWMiLCJ1cmwiLCJlc3JpU2VydmVyQ291bnQiLCJsYXllclVybCIsImZpbmFsVHJ5IiwiZGVmU2VydmljZSIsImNvbnRlbnQiLCJmIiwid2hlcmUiLCJyZXR1cm5Db3VudE9ubHkiLCJyZXR1cm5HZW9tZXRyeSIsImNhbGxiYWNrUGFyYW1OYW1lIiwiaGFuZGxlQXMiLCJQcm9taXNlIiwidGhlbiIsInNlcnZpY2VSZXN1bHQiLCJlcnJvciIsImNvdW50IiwicmVzb2x2ZSIsImNvbnNvbGUiLCJ3YXJuIiwiX2xheWVyIiwiZ3JhcGhpY3MiLCJsZW5ndGgiLCJmaWVsZHMiLCJPYmplY3QiLCJrZXlzIiwibWFwIiwiZmllbGRUeXBlIiwiZmluZCIsIm5hbWUiLCJrZXkiLCJBdHRyaWJGQyIsImFsaWFzZWRGaWVsZE5hbWVEaXJlY3QiLCJ2YWx1ZSIsInR5cGUiLCJMYXllclJlY29yZCIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7O0FBRUEsSUFBTUEsY0FBYyxtQkFBQUMsQ0FBUSxFQUFS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LENBQUNkLFFBQUwsRUFBZTtBQUNYO0FBQ0FjLHdDQUFRaEIsZ0JBQWdCQyxRQUFoQixFQUEwQixJQUExQixDQUFSO0FBQ0gsNkJBSEQsTUFHTztBQUNIO0FBQ0FnQix3Q0FBUUMsSUFBUixDQUFhSixLQUFiO0FBQ0FFLHdDQUFRLENBQUMsQ0FBVDtBQUNIO0FBQ0oseUJBdkJEO0FBd0JILHFCQXpCTSxDQUFQO0FBMEJILGlCQXhDRDs7QUEwQ0EsdUJBQU9oQixnQkFBZ0JELEdBQWhCLENBQVA7QUFFSCxhQWhERCxNQWdETztBQUNIO0FBQ0EsdUJBQU9ZLFFBQVFLLE9BQVIsQ0FBZ0IsS0FBS0csTUFBTCxDQUFZQyxRQUFaLENBQXFCQyxNQUFyQyxDQUFQO0FBQ0g7QUFDSjs7QUFFRDs7Ozs7Ozs7Ozs7NENBUXFCMUIsTyxFQUFTMkIsTSxFQUFRO0FBQ2xDO0FBQ0E7QUFDQSxtQkFBT0MsT0FBT0MsSUFBUCxDQUFZN0IsT0FBWixFQUNGOEIsR0FERSxDQUNFLGVBQU87QUFDUixvQkFBTUMsWUFBWUosU0FBU0EsT0FBT0ssSUFBUCxDQUFZO0FBQUEsMkJBQUt0QixFQUFFdUIsSUFBRixLQUFXQyxHQUFoQjtBQUFBLGlCQUFaLENBQVQsR0FBNEMsSUFBOUQ7QUFDQSx1QkFBTztBQUNIQSx5QkFBS3RELFNBQVN1RCxRQUFULENBQWtCQyxzQkFBbEIsQ0FBeUNGLEdBQXpDLEVBQThDUCxNQUE5QyxDQURGLEVBQ3lEO0FBQzVEVSwyQkFBT3JDLFFBQVFrQyxHQUFSLENBRko7QUFHSEksMEJBQU1QLFlBQVlBLFVBQVVPLElBQXRCLEdBQTZCUDtBQUhoQyxpQkFBUDtBQUtILGFBUkUsQ0FBUDtBQVNIOzs7O0VBcEpzQnJELFlBQVk2RCxXOztBQXVKdkNDLE9BQU9DLE9BQVAsR0FBaUI7QUFBQSxXQUFPO0FBQ3BCNUQ7QUFEb0IsS0FBUDtBQUFBLENBQWpCIiwiZmlsZSI6IjM4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxuY29uc3QgbGF5ZXJSZWNvcmQgPSByZXF1aXJlKCcuL2xheWVyUmVjb3JkLmpzJykoKTtcclxuY29uc3QgYXR0cmliRkMgPSByZXF1aXJlKCcuL2F0dHJpYkZDLmpzJykoKTtcclxuXHJcbi8qKlxyXG4gKiBAY2xhc3MgQXR0cmliUmVjb3JkXHJcbiAqL1xyXG5jbGFzcyBBdHRyaWJSZWNvcmQgZXh0ZW5kcyBsYXllclJlY29yZC5MYXllclJlY29yZCB7XHJcbiAgICAvLyB0aGlzIGNsYXNzIGhhcyBmdW5jdGlvbnMgY29tbW9uIHRvIGxheWVycyB0aGF0IGhhdmUgYXR0cmlidXRlc1xyXG5cclxuICAgIGdldCBjbGlja1RvbGVyYW5jZSAoKSB7IHJldHVybiB0aGlzLl90b2xlcmFuY2U7IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIGxheWVyIHJlY29yZCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBnZW9BcGkgbGF5ZXIgdHlwZS4gIExheWVyIGNvbmZpZ1xyXG4gICAgICogc2hvdWxkIGJlIGZ1bGx5IG1lcmdlZCB3aXRoIGFsbCBsYXllciBvcHRpb25zIGRlZmluZWQgKGkuZS4gdGhpcyBjb25zdHJ1Y3RvclxyXG4gICAgICogd2lsbCBub3QgYXBwbHkgYW55IGRlZmF1bHRzKS5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBsYXllckNsYXNzICAgIHRoZSBFU1JJIGFwaSBvYmplY3QgZm9yIHRoZSBsYXllclxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVzcmlSZXF1ZXN0ICAgdGhlIEVTUkkgYXBpIG9iamVjdCBmb3IgbWFraW5nIHdlYiByZXF1ZXN0cyB3aXRoIHByb3h5IHN1cHBvcnRcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcGlSZWYgICAgICAgIG9iamVjdCBwb2ludGluZyB0byB0aGUgZ2VvQXBpLiBhbGxvd3MgdXMgdG8gY2FsbCBvdGhlciBnZW9BcGkgZnVuY3Rpb25zLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyAgICAgICAgbGF5ZXIgY29uZmlnIHZhbHVlc1xyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVzcmlMYXllciAgICAgYW4gb3B0aW9uYWwgcHJlLWNvbnN0cnVjdGVkIGxheWVyXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcHNnTG9va3VwICBhbiBvcHRpb25hbCBsb29rdXAgZnVuY3Rpb24gZm9yIEVQU0cgY29kZXMgKHNlZSBnZW9TZXJ2aWNlIGZvciBzaWduYXR1cmUpXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yIChsYXllckNsYXNzLCBlc3JpUmVxdWVzdCwgYXBpUmVmLCBjb25maWcsIGVzcmlMYXllciwgZXBzZ0xvb2t1cCkge1xyXG4gICAgICAgIHN1cGVyKGxheWVyQ2xhc3MsIGFwaVJlZiwgY29uZmlnLCBlc3JpTGF5ZXIsIGVwc2dMb29rdXApO1xyXG5cclxuICAgICAgICB0aGlzLl9lc3JpUmVxdWVzdCA9IGVzcmlSZXF1ZXN0O1xyXG4gICAgICAgIHRoaXMuX3RvbGVyYW5jZSA9IHRoaXMuY29uZmlnLnRvbGVyYW5jZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgYmVzdCB1c2VyLWZyaWVuZGx5IG5hbWUgb2YgYSBmaWVsZC4gVXNlcyBhbGlhcyBpZiBhbGlhcyBpcyBkZWZpbmVkLCBlbHNlIHVzZXMgdGhlIHN5c3RlbSBhdHRyaWJ1dGUgbmFtZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0cmliTmFtZSAgICAgdGhlIGF0dHJpYnV0ZSBuYW1lIHdlIHdhbnQgYSBuaWNlIG5hbWUgZm9yXHJcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgICAgcmVzb2x2ZXMgdG8gdGhlIGJlc3QgYXZhaWxhYmxlIHVzZXIgZnJpZW5kbHkgYXR0cmlidXRlIG5hbWVcclxuICAgICAqL1xyXG4gICAgYWxpYXNlZEZpZWxkTmFtZSAoYXR0cmliTmFtZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9mZWF0Q2xhc3Nlc1t0aGlzLl9kZWZhdWx0RkNdLmFsaWFzZWRGaWVsZE5hbWUoYXR0cmliTmFtZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgYXR0cmlidXRlcyBmcm9tIGEgbGF5ZXIgZm9yIGEgc3BlY2lmaWVkIGZlYXR1cmUgaW5kZXhcclxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICAgcHJvbWlzZSByZXNvbHZpbmcgd2l0aCBmb3JtYXR0ZWQgYXR0cmlidXRlcyB0byBiZSBjb25zdW1lZCBieSB0aGUgZGF0YWdyaWQgYW5kIGVzcmkgZmVhdHVyZSBpZGVudGlmeVxyXG4gICAgICovXHJcbiAgICBnZXRGb3JtYXR0ZWRBdHRyaWJ1dGVzICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZmVhdENsYXNzZXNbdGhpcy5fZGVmYXVsdEZDXS5nZXRGb3JtYXR0ZWRBdHRyaWJ1dGVzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgY2hlY2tEYXRlVHlwZSAoYXR0cmliTmFtZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9mZWF0Q2xhc3Nlc1t0aGlzLl9kZWZhdWx0RkNdLmNoZWNrRGF0ZVR5cGUoYXR0cmliTmFtZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFJldHVybnMgYXR0cmlidXRlIGRhdGEgZm9yIHRoaXMgbGF5ZXIuXHJcbiAgICAqXHJcbiAgICAqIEBmdW5jdGlvbiBnZXRBdHRyaWJzXHJcbiAgICAqIEByZXR1cm5zIHtQcm9taXNlfSAgICAgICAgIHJlc29sdmVzIHdpdGggYSBsYXllciBhdHRyaWJ1dGUgZGF0YSBvYmplY3RcclxuICAgICovXHJcbiAgICBnZXRBdHRyaWJzICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZmVhdENsYXNzZXNbdGhpcy5fZGVmYXVsdEZDXS5nZXRBdHRyaWJzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFJldHVybnMgbGF5ZXItc3BlY2lmaWMgZGF0YSBmb3IgdGhpcyBSZWNvcmRcclxuICAgICpcclxuICAgICogQGZ1bmN0aW9uIGdldExheWVyRGF0YVxyXG4gICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gICAgICAgICByZXNvbHZlcyB3aXRoIGEgbGF5ZXIgZGF0YSBvYmplY3RcclxuICAgICovXHJcbiAgICBnZXRMYXllckRhdGEgKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9mZWF0Q2xhc3Nlc1t0aGlzLl9kZWZhdWx0RkNdLmdldExheWVyRGF0YSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldEZlYXR1cmVOYW1lIChvYmpJZCwgYXR0cmlicykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9mZWF0Q2xhc3Nlc1t0aGlzLl9kZWZhdWx0RkNdLmdldEZlYXR1cmVOYW1lKG9iaklkLCBhdHRyaWJzKTtcclxuICAgIH1cclxuXHJcbiAgICBmZXRjaEdyYXBoaWMgKG9iaklkLCBpZ25vcmVMb2NhbCA9IGZhbHNlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZlYXRDbGFzc2VzW3RoaXMuX2RlZmF1bHRGQ10uZmV0Y2hHcmFwaGljKG9iaklkLCBpZ25vcmVMb2NhbCk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0RmVhdHVyZUNvdW50ICh1cmwpIHtcclxuICAgICAgICBpZiAodXJsKSB7XHJcbiAgICAgICAgICAgIC8vIHdyYXBwaW5nIHNlcnZlciBjYWxsIGluIGEgZnVuY3Rpb24sIGFzIHdlIHJlZ3VsYXJseSBlbmNvdW50ZXIgc2lsbHluZXNzXHJcbiAgICAgICAgICAgIC8vIHdoZXJlIHdlIG5lZWQgdG8gZXhlY3V0ZSB0aGUgY291bnQgcmVxdWVzdCB0d2ljZS5cclxuICAgICAgICAgICAgLy8gaGF2aW5nIGEgZnVuY3Rpb24gKHdpdGggZmluYWxUcnkgZmxhZykgbGV0cyB1cyBoYW5kbGUgdGhlIGRvdWJsZS1yZXF1ZXN0XHJcbiAgICAgICAgICAgIGNvbnN0IGVzcmlTZXJ2ZXJDb3VudCA9IChsYXllclVybCwgZmluYWxUcnkgPSBmYWxzZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gZXh0cmFjdCBpbmZvIGZvciB0aGlzIHNlcnZpY2VcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRlZlNlcnZpY2UgPSB0aGlzLl9lc3JpUmVxdWVzdCh7XHJcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBgJHtsYXllclVybH0vcXVlcnlgLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZjogJ2pzb24nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGVyZTogJzE9MScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybkNvdW50T25seTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuR2VvbWV0cnk6IGZhbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja1BhcmFtTmFtZTogJ2NhbGxiYWNrJyxcclxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVBczogJ2pzb24nLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZlNlcnZpY2UudGhlbihzZXJ2aWNlUmVzdWx0ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlcnZpY2VSZXN1bHQgJiYgKHR5cGVvZiBzZXJ2aWNlUmVzdWx0LmVycm9yID09PSAndW5kZWZpbmVkJykgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2Ygc2VydmljZVJlc3VsdC5jb3VudCAhPT0gJ3VuZGVmaW5lZCcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBnb3QgYSByb3cgY291bnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoc2VydmljZVJlc3VsdC5jb3VudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWZpbmFsVHJ5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkbyBhIHNlY29uZCBhdHRlbXB0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGVzcmlTZXJ2ZXJDb3VudChsYXllclVybCwgdHJ1ZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGVsbHMgdGhlIGFwcCBpdCBmYWlsZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoLTEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgZXJyb3IgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmYWlsZWQgdG8gbG9hZCBzZXJ2aWNlIGluZm8uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gYW55IHRyaWNrcyB0byBhdm9pZCBkdXBsaWNhdGluZyB0aGUgZXJyb3IgY2FzZSBpbiBib3RoIGJsb2Nrcz9cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmaW5hbFRyeSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG8gYSBzZWNvbmQgYXR0ZW1wdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShlc3JpU2VydmVyQ291bnQobGF5ZXJVcmwsIHRydWUpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRlbGxzIHRoZSBhcHAgaXQgZmFpbGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgtMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGVzcmlTZXJ2ZXJDb3VudCh1cmwpO1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBmaWxlIGJhc2VkIGxheWVyLiAgY291bnQgbG9jYWwgZmVhdHVyZXNcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9sYXllci5ncmFwaGljcy5sZW5ndGgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRyYW5zZm9ybXMgZXNyaSBrZXktdmFsdWUgYXR0cmlidXRlIG9iamVjdCBpbnRvIGtleSB2YWx1ZSBhcnJheSB3aXRoIGZvcm1hdCBzdWl0YWJsZVxyXG4gICAgICogZm9yIGNvbnN1bXB0aW9uIGJ5IHRoZSBkZXRhaWxzIHBhbmUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBhdHRyaWJzICAgICAgYXR0cmlidXRlIGtleS12YWx1ZSBtYXBwaW5nLCBwb3RlbnRpYWxseSB3aXRoIGFsaWFzZXMgYXMga2V5c1xyXG4gICAgICogQHBhcmFtICB7QXJyYXl9IGZpZWxkcyAgICAgICAgb3B0aW9uYWwuIGZpZWxkcyBkZWZpbml0aW9uIGFycmF5IGZvciBsYXllci4gbm8gYWxpYXNpbmcgZG9uZSBpZiBub3QgcHJvdmlkZWRcclxuICAgICAqIEByZXR1cm4ge0FycmF5fSAgICAgICAgICAgICAgIGF0dHJpYnV0ZSBkYXRhIHRyYW5zZm9ybWVkIGludG8gYSBsaXN0LCB3aXRoIHBvdGVudGlhbCBmaWVsZCBhbGlhc2luZyBhcHBsaWVkXHJcbiAgICAgKi9cclxuICAgIGF0dHJpYnV0ZXNUb0RldGFpbHMgKGF0dHJpYnMsIGZpZWxkcykge1xyXG4gICAgICAgIC8vIFRPRE8gbWFrZSB0aGlzIGV4dGVuc2libGUgLyBtb2RpZmlhYmxlIC8gY29uZmlndXJhYmxlIHRvIGFsbG93IGRpZmZlcmVudCBkZXRhaWxzIGxvb2tzIGZvciBkaWZmZXJlbnQgZGF0YVxyXG4gICAgICAgIC8vIHNpbXBsZSBhcnJheSBvZiB0ZXh0IG1hcHBpbmcgZm9yIGRlbW9uc3RyYXRpb24gcHVycG9zZXMuIGZhbmN5IGdyaWQgZm9ybWF0dGluZyBsYXRlcj9cclxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoYXR0cmlicylcclxuICAgICAgICAgICAgLm1hcChrZXkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGRUeXBlID0gZmllbGRzID8gZmllbGRzLmZpbmQoZiA9PiBmLm5hbWUgPT09IGtleSkgOiBudWxsO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBrZXk6IGF0dHJpYkZDLkF0dHJpYkZDLmFsaWFzZWRGaWVsZE5hbWVEaXJlY3Qoa2V5LCBmaWVsZHMpLCAvLyBuZWVkIHN5bmNocm9ub3VzIHZhcmlhbnQgb2YgYWxpYXMgbG9va3VwXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGF0dHJpYnNba2V5XSxcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBmaWVsZFR5cGUgPyBmaWVsZFR5cGUudHlwZSA6IGZpZWxkVHlwZVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gKCkgPT4gKHtcclxuICAgIEF0dHJpYlJlY29yZFxyXG59KTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2xheWVyL2xheWVyUmVjL2F0dHJpYlJlY29yZC5qcyJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){"use strict";eval("\n\n/**\r\n * @class Root\r\n */\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Root = function () {\n    // the thing every thing else inherits from.\n    // thing in here should be applicable to both layer-ish classes (including FCs),\n    // and legend-ish classes.\n\n    function Root() {\n        _classCallCheck(this, Root);\n\n        // TODO maybe pass in config, store it?\n\n        this._name = '';\n    }\n\n    // everyone needs a name\n\n\n    _createClass(Root, [{\n        key: '_fireEvent',\n\n\n        /**\r\n         * Utility for triggering an event and giving it to the listeners\r\n         */\n        value: function _fireEvent(handlerArray) {\n            for (var _len = arguments.length, eventParams = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                eventParams[_key - 1] = arguments[_key];\n            }\n\n            // if we don't copy the array we could be looping on an array\n            // that is being modified as it is being read\n            handlerArray.slice(0).forEach(function (l) {\n                return l.apply(undefined, eventParams);\n            });\n        }\n    }, {\n        key: 'name',\n        get: function get() {\n            return this._name;\n        },\n        set: function set(value) {\n            this._name = value;\n        }\n    }, {\n        key: 'symbology',\n        get: function get() {\n            return this._symbology;\n        },\n        set: function set(value) {\n            this._symbology = value;\n        }\n    }, {\n        key: 'extent',\n        get: function get() {\n            return this._extent;\n        },\n        set: function set(value) {\n            this._extent = value;\n        }\n    }]);\n\n    return Root;\n}();\n\nmodule.exports = function () {\n    return {\n        Root: Root\n    };\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXIvbGF5ZXJSZWMvcm9vdC5qcz9hNGI0Il0sIm5hbWVzIjpbIlJvb3QiLCJfbmFtZSIsImhhbmRsZXJBcnJheSIsImV2ZW50UGFyYW1zIiwic2xpY2UiLCJmb3JFYWNoIiwibCIsInZhbHVlIiwiX3N5bWJvbG9neSIsIl9leHRlbnQiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTs7Ozs7Ozs7SUFHTUEsSTtBQUNGO0FBQ0E7QUFDQTs7QUFFQSxvQkFBZTtBQUFBOztBQUNYOztBQUVBLGFBQUtDLEtBQUwsR0FBYSxFQUFiO0FBQ0g7O0FBRUQ7Ozs7Ozs7QUFVQTs7O21DQUdZQyxZLEVBQThCO0FBQUEsOENBQWJDLFdBQWE7QUFBYkEsMkJBQWE7QUFBQTs7QUFDdEM7QUFDQTtBQUNBRCx5QkFBYUUsS0FBYixDQUFtQixDQUFuQixFQUFzQkMsT0FBdEIsQ0FBOEI7QUFBQSx1QkFBS0MsbUJBQUtILFdBQUwsQ0FBTDtBQUFBLGFBQTlCO0FBQ0g7Ozs0QkFoQlc7QUFBRSxtQkFBTyxLQUFLRixLQUFaO0FBQW9CLFM7MEJBQ3hCTSxLLEVBQU87QUFBRSxpQkFBS04sS0FBTCxHQUFhTSxLQUFiO0FBQXFCOzs7NEJBRXZCO0FBQUUsbUJBQU8sS0FBS0MsVUFBWjtBQUF5QixTOzBCQUM3QkQsSyxFQUFPO0FBQUUsaUJBQUtDLFVBQUwsR0FBa0JELEtBQWxCO0FBQTBCOzs7NEJBRXBDO0FBQUUsbUJBQU8sS0FBS0UsT0FBWjtBQUFzQixTOzBCQUMxQkYsSyxFQUFPO0FBQUUsaUJBQUtFLE9BQUwsR0FBZUYsS0FBZjtBQUF1Qjs7Ozs7O0FBYWhERyxPQUFPQyxPQUFQLEdBQWlCO0FBQUEsV0FBTztBQUNwQlg7QUFEb0IsS0FBUDtBQUFBLENBQWpCIiwiZmlsZSI6IjM5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxuLyoqXHJcbiAqIEBjbGFzcyBSb290XHJcbiAqL1xyXG5jbGFzcyBSb290IHtcclxuICAgIC8vIHRoZSB0aGluZyBldmVyeSB0aGluZyBlbHNlIGluaGVyaXRzIGZyb20uXHJcbiAgICAvLyB0aGluZyBpbiBoZXJlIHNob3VsZCBiZSBhcHBsaWNhYmxlIHRvIGJvdGggbGF5ZXItaXNoIGNsYXNzZXMgKGluY2x1ZGluZyBGQ3MpLFxyXG4gICAgLy8gYW5kIGxlZ2VuZC1pc2ggY2xhc3Nlcy5cclxuXHJcbiAgICBjb25zdHJ1Y3RvciAoKSB7XHJcbiAgICAgICAgLy8gVE9ETyBtYXliZSBwYXNzIGluIGNvbmZpZywgc3RvcmUgaXQ/XHJcblxyXG4gICAgICAgIHRoaXMuX25hbWUgPSAnJztcclxuICAgIH1cclxuXHJcbiAgICAvLyBldmVyeW9uZSBuZWVkcyBhIG5hbWVcclxuICAgIGdldCBuYW1lICgpIHsgcmV0dXJuIHRoaXMuX25hbWU7IH1cclxuICAgIHNldCBuYW1lICh2YWx1ZSkgeyB0aGlzLl9uYW1lID0gdmFsdWU7IH1cclxuXHJcbiAgICBnZXQgc3ltYm9sb2d5ICgpIHsgcmV0dXJuIHRoaXMuX3N5bWJvbG9neTsgfVxyXG4gICAgc2V0IHN5bWJvbG9neSAodmFsdWUpIHsgdGhpcy5fc3ltYm9sb2d5ID0gdmFsdWU7IH1cclxuXHJcbiAgICBnZXQgZXh0ZW50ICgpIHsgcmV0dXJuIHRoaXMuX2V4dGVudDsgfVxyXG4gICAgc2V0IGV4dGVudCAodmFsdWUpIHsgdGhpcy5fZXh0ZW50ID0gdmFsdWU7IH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFV0aWxpdHkgZm9yIHRyaWdnZXJpbmcgYW4gZXZlbnQgYW5kIGdpdmluZyBpdCB0byB0aGUgbGlzdGVuZXJzXHJcbiAgICAgKi9cclxuICAgIF9maXJlRXZlbnQgKGhhbmRsZXJBcnJheSwgLi4uZXZlbnRQYXJhbXMpIHtcclxuICAgICAgICAvLyBpZiB3ZSBkb24ndCBjb3B5IHRoZSBhcnJheSB3ZSBjb3VsZCBiZSBsb29waW5nIG9uIGFuIGFycmF5XHJcbiAgICAgICAgLy8gdGhhdCBpcyBiZWluZyBtb2RpZmllZCBhcyBpdCBpcyBiZWluZyByZWFkXHJcbiAgICAgICAgaGFuZGxlckFycmF5LnNsaWNlKDApLmZvckVhY2gobCA9PiBsKC4uLmV2ZW50UGFyYW1zKSk7XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9ICgpID0+ICh7XHJcbiAgICBSb290XHJcbn0pO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbGF5ZXIvbGF5ZXJSZWMvcm9vdC5qcyJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){"use strict";eval("\nvar Mutation = global.MutationObserver || global.WebKitMutationObserver;\n\nvar scheduleDrain;\n\nif (process.browser) {\n  if (Mutation) {\n    var called = 0;\n    var observer = new Mutation(nextTick);\n    var element = global.document.createTextNode('');\n    observer.observe(element, {\n      characterData: true\n    });\n    scheduleDrain = function () {\n      element.data = (called = ++called % 2);\n    };\n  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {\n    var channel = new global.MessageChannel();\n    channel.port1.onmessage = nextTick;\n    scheduleDrain = function () {\n      channel.port2.postMessage(0);\n    };\n  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {\n    scheduleDrain = function () {\n\n      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n      var scriptEl = global.document.createElement('script');\n      scriptEl.onreadystatechange = function () {\n        nextTick();\n\n        scriptEl.onreadystatechange = null;\n        scriptEl.parentNode.removeChild(scriptEl);\n        scriptEl = null;\n      };\n      global.document.documentElement.appendChild(scriptEl);\n    };\n  } else {\n    scheduleDrain = function () {\n      setTimeout(nextTick, 0);\n    };\n  }\n} else {\n  scheduleDrain = function () {\n    process.nextTick(nextTick);\n  };\n}\n\nvar draining;\nvar queue = [];\n//named nextTick for less confusing stack traces\nfunction nextTick() {\n  draining = true;\n  var i, oldQueue;\n  var len = queue.length;\n  while (len) {\n    oldQueue = queue;\n    queue = [];\n    i = -1;\n    while (++i < len) {\n      oldQueue[i]();\n    }\n    len = queue.length;\n  }\n  draining = false;\n}\n\nmodule.exports = immediate;\nfunction immediate(task) {\n  if (queue.push(task) === 1 && !draining) {\n    scheduleDrain();\n  }\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2ltbWVkaWF0ZS9saWIvaW5kZXguanM/ZWU4NCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI0MC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciBNdXRhdGlvbiA9IGdsb2JhbC5NdXRhdGlvbk9ic2VydmVyIHx8IGdsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xuXG52YXIgc2NoZWR1bGVEcmFpbjtcblxuaWYgKHByb2Nlc3MuYnJvd3Nlcikge1xuICBpZiAoTXV0YXRpb24pIHtcbiAgICB2YXIgY2FsbGVkID0gMDtcbiAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb24obmV4dFRpY2spO1xuICAgIHZhciBlbGVtZW50ID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKGVsZW1lbnQsIHtcbiAgICAgIGNoYXJhY3RlckRhdGE6IHRydWVcbiAgICB9KTtcbiAgICBzY2hlZHVsZURyYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgZWxlbWVudC5kYXRhID0gKGNhbGxlZCA9ICsrY2FsbGVkICUgMik7XG4gICAgfTtcbiAgfSBlbHNlIGlmICghZ2xvYmFsLnNldEltbWVkaWF0ZSAmJiB0eXBlb2YgZ2xvYmFsLk1lc3NhZ2VDaGFubmVsICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBjaGFubmVsID0gbmV3IGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCgpO1xuICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gbmV4dFRpY2s7XG4gICAgc2NoZWR1bGVEcmFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoMCk7XG4gICAgfTtcbiAgfSBlbHNlIGlmICgnZG9jdW1lbnQnIGluIGdsb2JhbCAmJiAnb25yZWFkeXN0YXRlY2hhbmdlJyBpbiBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JykpIHtcbiAgICBzY2hlZHVsZURyYWluID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICB2YXIgc2NyaXB0RWwgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICBzY3JpcHRFbC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG5leHRUaWNrKCk7XG5cbiAgICAgICAgc2NyaXB0RWwub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgc2NyaXB0RWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHRFbCk7XG4gICAgICAgIHNjcmlwdEVsID0gbnVsbDtcbiAgICAgIH07XG4gICAgICBnbG9iYWwuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKHNjcmlwdEVsKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHNjaGVkdWxlRHJhaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzZXRUaW1lb3V0KG5leHRUaWNrLCAwKTtcbiAgICB9O1xuICB9XG59IGVsc2Uge1xuICBzY2hlZHVsZURyYWluID0gZnVuY3Rpb24gKCkge1xuICAgIHByb2Nlc3MubmV4dFRpY2sobmV4dFRpY2spO1xuICB9O1xufVxuXG52YXIgZHJhaW5pbmc7XG52YXIgcXVldWUgPSBbXTtcbi8vbmFtZWQgbmV4dFRpY2sgZm9yIGxlc3MgY29uZnVzaW5nIHN0YWNrIHRyYWNlc1xuZnVuY3Rpb24gbmV4dFRpY2soKSB7XG4gIGRyYWluaW5nID0gdHJ1ZTtcbiAgdmFyIGksIG9sZFF1ZXVlO1xuICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICB3aGlsZSAobGVuKSB7XG4gICAgb2xkUXVldWUgPSBxdWV1ZTtcbiAgICBxdWV1ZSA9IFtdO1xuICAgIGkgPSAtMTtcbiAgICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgICBvbGRRdWV1ZVtpXSgpO1xuICAgIH1cbiAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gIH1cbiAgZHJhaW5pbmcgPSBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbW1lZGlhdGU7XG5mdW5jdGlvbiBpbW1lZGlhdGUodGFzaykge1xuICBpZiAocXVldWUucHVzaCh0YXNrKSA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICBzY2hlZHVsZURyYWluKCk7XG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9pbW1lZGlhdGUvbGliL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){"use strict";eval("\nvar DataReader = __webpack_require__(43);\n\nfunction ArrayReader(data) {\n    if (data) {\n        this.data = data;\n        this.length = this.data.length;\n        this.index = 0;\n        this.zero = 0;\n\n        for(var i = 0; i < this.data.length; i++) {\n            data[i] = data[i] & 0xFF;\n        }\n    }\n}\nArrayReader.prototype = new DataReader();\n/**\n * @see DataReader.byteAt\n */\nArrayReader.prototype.byteAt = function(i) {\n    return this.data[this.zero + i];\n};\n/**\n * @see DataReader.lastIndexOfSignature\n */\nArrayReader.prototype.lastIndexOfSignature = function(sig) {\n    var sig0 = sig.charCodeAt(0),\n        sig1 = sig.charCodeAt(1),\n        sig2 = sig.charCodeAt(2),\n        sig3 = sig.charCodeAt(3);\n    for (var i = this.length - 4; i >= 0; --i) {\n        if (this.data[i] === sig0 && this.data[i + 1] === sig1 && this.data[i + 2] === sig2 && this.data[i + 3] === sig3) {\n            return i - this.zero;\n        }\n    }\n\n    return -1;\n};\n/**\n * @see DataReader.readData\n */\nArrayReader.prototype.readData = function(size) {\n    this.checkOffset(size);\n    if(size === 0) {\n        return [];\n    }\n    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);\n    this.index += size;\n    return result;\n};\nmodule.exports = ArrayReader;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2pzemlwL2xpYi9hcnJheVJlYWRlci5qcz80YjY0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsUUFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNDEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgRGF0YVJlYWRlciA9IHJlcXVpcmUoJy4vZGF0YVJlYWRlcicpO1xuXG5mdW5jdGlvbiBBcnJheVJlYWRlcihkYXRhKSB7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSB0aGlzLmRhdGEubGVuZ3RoO1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgdGhpcy56ZXJvID0gMDtcblxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBkYXRhW2ldID0gZGF0YVtpXSAmIDB4RkY7XG4gICAgICAgIH1cbiAgICB9XG59XG5BcnJheVJlYWRlci5wcm90b3R5cGUgPSBuZXcgRGF0YVJlYWRlcigpO1xuLyoqXG4gKiBAc2VlIERhdGFSZWFkZXIuYnl0ZUF0XG4gKi9cbkFycmF5UmVhZGVyLnByb3RvdHlwZS5ieXRlQXQgPSBmdW5jdGlvbihpKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YVt0aGlzLnplcm8gKyBpXTtcbn07XG4vKipcbiAqIEBzZWUgRGF0YVJlYWRlci5sYXN0SW5kZXhPZlNpZ25hdHVyZVxuICovXG5BcnJheVJlYWRlci5wcm90b3R5cGUubGFzdEluZGV4T2ZTaWduYXR1cmUgPSBmdW5jdGlvbihzaWcpIHtcbiAgICB2YXIgc2lnMCA9IHNpZy5jaGFyQ29kZUF0KDApLFxuICAgICAgICBzaWcxID0gc2lnLmNoYXJDb2RlQXQoMSksXG4gICAgICAgIHNpZzIgPSBzaWcuY2hhckNvZGVBdCgyKSxcbiAgICAgICAgc2lnMyA9IHNpZy5jaGFyQ29kZUF0KDMpO1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDQ7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGFbaV0gPT09IHNpZzAgJiYgdGhpcy5kYXRhW2kgKyAxXSA9PT0gc2lnMSAmJiB0aGlzLmRhdGFbaSArIDJdID09PSBzaWcyICYmIHRoaXMuZGF0YVtpICsgM10gPT09IHNpZzMpIHtcbiAgICAgICAgICAgIHJldHVybiBpIC0gdGhpcy56ZXJvO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xufTtcbi8qKlxuICogQHNlZSBEYXRhUmVhZGVyLnJlYWREYXRhXG4gKi9cbkFycmF5UmVhZGVyLnByb3RvdHlwZS5yZWFkRGF0YSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgICB0aGlzLmNoZWNrT2Zmc2V0KHNpemUpO1xuICAgIGlmKHNpemUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5kYXRhLnNsaWNlKHRoaXMuemVybyArIHRoaXMuaW5kZXgsIHRoaXMuemVybyArIHRoaXMuaW5kZXggKyBzaXplKTtcbiAgICB0aGlzLmluZGV4ICs9IHNpemU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5UmVhZGVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2pzemlwL2xpYi9hcnJheVJlYWRlci5qc1xuLy8gbW9kdWxlIGlkID0gNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){"use strict";eval("\nfunction CompressedObject() {\n    this.compressedSize = 0;\n    this.uncompressedSize = 0;\n    this.crc32 = 0;\n    this.compressionMethod = null;\n    this.compressedContent = null;\n}\n\nCompressedObject.prototype = {\n    /**\n     * Return the decompressed content in an unspecified format.\n     * The format will depend on the decompressor.\n     * @return {Object} the decompressed content.\n     */\n    getContent: function() {\n        return null; // see implementation\n    },\n    /**\n     * Return the compressed content in an unspecified format.\n     * The format will depend on the compressed conten source.\n     * @return {Object} the compressed content.\n     */\n    getCompressedContent: function() {\n        return null; // see implementation\n    }\n};\nmodule.exports = CompressedObject;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2pzemlwL2xpYi9jb21wcmVzc2VkT2JqZWN0LmpzPzI5ZTMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBIiwiZmlsZSI6IjQyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuZnVuY3Rpb24gQ29tcHJlc3NlZE9iamVjdCgpIHtcbiAgICB0aGlzLmNvbXByZXNzZWRTaXplID0gMDtcbiAgICB0aGlzLnVuY29tcHJlc3NlZFNpemUgPSAwO1xuICAgIHRoaXMuY3JjMzIgPSAwO1xuICAgIHRoaXMuY29tcHJlc3Npb25NZXRob2QgPSBudWxsO1xuICAgIHRoaXMuY29tcHJlc3NlZENvbnRlbnQgPSBudWxsO1xufVxuXG5Db21wcmVzc2VkT2JqZWN0LnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGRlY29tcHJlc3NlZCBjb250ZW50IGluIGFuIHVuc3BlY2lmaWVkIGZvcm1hdC5cbiAgICAgKiBUaGUgZm9ybWF0IHdpbGwgZGVwZW5kIG9uIHRoZSBkZWNvbXByZXNzb3IuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSB0aGUgZGVjb21wcmVzc2VkIGNvbnRlbnQuXG4gICAgICovXG4gICAgZ2V0Q29udGVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBudWxsOyAvLyBzZWUgaW1wbGVtZW50YXRpb25cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgY29tcHJlc3NlZCBjb250ZW50IGluIGFuIHVuc3BlY2lmaWVkIGZvcm1hdC5cbiAgICAgKiBUaGUgZm9ybWF0IHdpbGwgZGVwZW5kIG9uIHRoZSBjb21wcmVzc2VkIGNvbnRlbiBzb3VyY2UuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSB0aGUgY29tcHJlc3NlZCBjb250ZW50LlxuICAgICAqL1xuICAgIGdldENvbXByZXNzZWRDb250ZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7IC8vIHNlZSBpbXBsZW1lbnRhdGlvblxuICAgIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IENvbXByZXNzZWRPYmplY3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vanN6aXAvbGliL2NvbXByZXNzZWRPYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){"use strict";eval('\nvar utils = __webpack_require__(1);\n\nfunction DataReader(data) {\n    this.data = null; // type : see implementation\n    this.length = 0;\n    this.index = 0;\n    this.zero = 0;\n}\nDataReader.prototype = {\n    /**\n     * Check that the offset will not go too far.\n     * @param {string} offset the additional offset to check.\n     * @throws {Error} an Error if the offset is out of bounds.\n     */\n    checkOffset: function(offset) {\n        this.checkIndex(this.index + offset);\n    },\n    /**\n     * Check that the specifed index will not be too far.\n     * @param {string} newIndex the index to check.\n     * @throws {Error} an Error if the index is out of bounds.\n     */\n    checkIndex: function(newIndex) {\n        if (this.length < this.zero + newIndex || newIndex < 0) {\n            throw new Error("End of data reached (data length = " + this.length + ", asked index = " + (newIndex) + "). Corrupted zip ?");\n        }\n    },\n    /**\n     * Change the index.\n     * @param {number} newIndex The new index.\n     * @throws {Error} if the new index is out of the data.\n     */\n    setIndex: function(newIndex) {\n        this.checkIndex(newIndex);\n        this.index = newIndex;\n    },\n    /**\n     * Skip the next n bytes.\n     * @param {number} n the number of bytes to skip.\n     * @throws {Error} if the new index is out of the data.\n     */\n    skip: function(n) {\n        this.setIndex(this.index + n);\n    },\n    /**\n     * Get the byte at the specified index.\n     * @param {number} i the index to use.\n     * @return {number} a byte.\n     */\n    byteAt: function(i) {\n        // see implementations\n    },\n    /**\n     * Get the next number with a given byte size.\n     * @param {number} size the number of bytes to read.\n     * @return {number} the corresponding number.\n     */\n    readInt: function(size) {\n        var result = 0,\n            i;\n        this.checkOffset(size);\n        for (i = this.index + size - 1; i >= this.index; i--) {\n            result = (result << 8) + this.byteAt(i);\n        }\n        this.index += size;\n        return result;\n    },\n    /**\n     * Get the next string with a given byte size.\n     * @param {number} size the number of bytes to read.\n     * @return {string} the corresponding string.\n     */\n    readString: function(size) {\n        return utils.transformTo("string", this.readData(size));\n    },\n    /**\n     * Get raw data without conversion, <size> bytes.\n     * @param {number} size the number of bytes to read.\n     * @return {Object} the raw data, implementation specific.\n     */\n    readData: function(size) {\n        // see implementations\n    },\n    /**\n     * Find the last occurence of a zip signature (4 bytes).\n     * @param {string} sig the signature to find.\n     * @return {number} the index of the last occurence, -1 if not found.\n     */\n    lastIndexOfSignature: function(sig) {\n        // see implementations\n    },\n    /**\n     * Get the next date.\n     * @return {Date} the date.\n     */\n    readDate: function() {\n        var dostime = this.readInt(4);\n        return new Date(\n        ((dostime >> 25) & 0x7f) + 1980, // year\n        ((dostime >> 21) & 0x0f) - 1, // month\n        (dostime >> 16) & 0x1f, // day\n        (dostime >> 11) & 0x1f, // hour\n        (dostime >> 5) & 0x3f, // minute\n        (dostime & 0x1f) << 1); // second\n    }\n};\nmodule.exports = DataReader;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2pzemlwL2xpYi9kYXRhUmVhZGVyLmpzPzAzZWIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGlCQUFpQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZ0JBQWdCLEtBQUs7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSIsImZpbGUiOiI0My5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuZnVuY3Rpb24gRGF0YVJlYWRlcihkYXRhKSB7XG4gICAgdGhpcy5kYXRhID0gbnVsbDsgLy8gdHlwZSA6IHNlZSBpbXBsZW1lbnRhdGlvblxuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICB0aGlzLmluZGV4ID0gMDtcbiAgICB0aGlzLnplcm8gPSAwO1xufVxuRGF0YVJlYWRlci5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogQ2hlY2sgdGhhdCB0aGUgb2Zmc2V0IHdpbGwgbm90IGdvIHRvbyBmYXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9mZnNldCB0aGUgYWRkaXRpb25hbCBvZmZzZXQgdG8gY2hlY2suXG4gICAgICogQHRocm93cyB7RXJyb3J9IGFuIEVycm9yIGlmIHRoZSBvZmZzZXQgaXMgb3V0IG9mIGJvdW5kcy5cbiAgICAgKi9cbiAgICBjaGVja09mZnNldDogZnVuY3Rpb24ob2Zmc2V0KSB7XG4gICAgICAgIHRoaXMuY2hlY2tJbmRleCh0aGlzLmluZGV4ICsgb2Zmc2V0KTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENoZWNrIHRoYXQgdGhlIHNwZWNpZmVkIGluZGV4IHdpbGwgbm90IGJlIHRvbyBmYXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5ld0luZGV4IHRoZSBpbmRleCB0byBjaGVjay5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gYW4gRXJyb3IgaWYgdGhlIGluZGV4IGlzIG91dCBvZiBib3VuZHMuXG4gICAgICovXG4gICAgY2hlY2tJbmRleDogZnVuY3Rpb24obmV3SW5kZXgpIHtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoIDwgdGhpcy56ZXJvICsgbmV3SW5kZXggfHwgbmV3SW5kZXggPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbmQgb2YgZGF0YSByZWFjaGVkIChkYXRhIGxlbmd0aCA9IFwiICsgdGhpcy5sZW5ndGggKyBcIiwgYXNrZWQgaW5kZXggPSBcIiArIChuZXdJbmRleCkgKyBcIikuIENvcnJ1cHRlZCB6aXAgP1wiKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ2hhbmdlIHRoZSBpbmRleC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbmV3SW5kZXggVGhlIG5ldyBpbmRleC5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIG5ldyBpbmRleCBpcyBvdXQgb2YgdGhlIGRhdGEuXG4gICAgICovXG4gICAgc2V0SW5kZXg6IGZ1bmN0aW9uKG5ld0luZGV4KSB7XG4gICAgICAgIHRoaXMuY2hlY2tJbmRleChuZXdJbmRleCk7XG4gICAgICAgIHRoaXMuaW5kZXggPSBuZXdJbmRleDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFNraXAgdGhlIG5leHQgbiBieXRlcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAuXG4gICAgICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBuZXcgaW5kZXggaXMgb3V0IG9mIHRoZSBkYXRhLlxuICAgICAqL1xuICAgIHNraXA6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgdGhpcy5zZXRJbmRleCh0aGlzLmluZGV4ICsgbik7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGJ5dGUgYXQgdGhlIHNwZWNpZmllZCBpbmRleC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaSB0aGUgaW5kZXggdG8gdXNlLlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gYSBieXRlLlxuICAgICAqL1xuICAgIGJ5dGVBdDogZnVuY3Rpb24oaSkge1xuICAgICAgICAvLyBzZWUgaW1wbGVtZW50YXRpb25zXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG5leHQgbnVtYmVyIHdpdGggYSBnaXZlbiBieXRlIHNpemUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgdGhlIG51bWJlciBvZiBieXRlcyB0byByZWFkLlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gdGhlIGNvcnJlc3BvbmRpbmcgbnVtYmVyLlxuICAgICAqL1xuICAgIHJlYWRJbnQ6IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IDAsXG4gICAgICAgICAgICBpO1xuICAgICAgICB0aGlzLmNoZWNrT2Zmc2V0KHNpemUpO1xuICAgICAgICBmb3IgKGkgPSB0aGlzLmluZGV4ICsgc2l6ZSAtIDE7IGkgPj0gdGhpcy5pbmRleDsgaS0tKSB7XG4gICAgICAgICAgICByZXN1bHQgPSAocmVzdWx0IDw8IDgpICsgdGhpcy5ieXRlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmRleCArPSBzaXplO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBuZXh0IHN0cmluZyB3aXRoIGEgZ2l2ZW4gYnl0ZSBzaXplLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gcmVhZC5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBjb3JyZXNwb25kaW5nIHN0cmluZy5cbiAgICAgKi9cbiAgICByZWFkU3RyaW5nOiBmdW5jdGlvbihzaXplKSB7XG4gICAgICAgIHJldHVybiB1dGlscy50cmFuc2Zvcm1UbyhcInN0cmluZ1wiLCB0aGlzLnJlYWREYXRhKHNpemUpKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCByYXcgZGF0YSB3aXRob3V0IGNvbnZlcnNpb24sIDxzaXplPiBieXRlcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHJlYWQuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSB0aGUgcmF3IGRhdGEsIGltcGxlbWVudGF0aW9uIHNwZWNpZmljLlxuICAgICAqL1xuICAgIHJlYWREYXRhOiBmdW5jdGlvbihzaXplKSB7XG4gICAgICAgIC8vIHNlZSBpbXBsZW1lbnRhdGlvbnNcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIGxhc3Qgb2NjdXJlbmNlIG9mIGEgemlwIHNpZ25hdHVyZSAoNCBieXRlcykuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNpZyB0aGUgc2lnbmF0dXJlIHRvIGZpbmQuXG4gICAgICogQHJldHVybiB7bnVtYmVyfSB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgb2NjdXJlbmNlLCAtMSBpZiBub3QgZm91bmQuXG4gICAgICovXG4gICAgbGFzdEluZGV4T2ZTaWduYXR1cmU6IGZ1bmN0aW9uKHNpZykge1xuICAgICAgICAvLyBzZWUgaW1wbGVtZW50YXRpb25zXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG5leHQgZGF0ZS5cbiAgICAgKiBAcmV0dXJuIHtEYXRlfSB0aGUgZGF0ZS5cbiAgICAgKi9cbiAgICByZWFkRGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkb3N0aW1lID0gdGhpcy5yZWFkSW50KDQpO1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoXG4gICAgICAgICgoZG9zdGltZSA+PiAyNSkgJiAweDdmKSArIDE5ODAsIC8vIHllYXJcbiAgICAgICAgKChkb3N0aW1lID4+IDIxKSAmIDB4MGYpIC0gMSwgLy8gbW9udGhcbiAgICAgICAgKGRvc3RpbWUgPj4gMTYpICYgMHgxZiwgLy8gZGF5XG4gICAgICAgIChkb3N0aW1lID4+IDExKSAmIDB4MWYsIC8vIGhvdXJcbiAgICAgICAgKGRvc3RpbWUgPj4gNSkgJiAweDNmLCAvLyBtaW51dGVcbiAgICAgICAgKGRvc3RpbWUgJiAweDFmKSA8PCAxKTsgLy8gc2Vjb25kXG4gICAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gRGF0YVJlYWRlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9qc3ppcC9saWIvZGF0YVJlYWRlci5qc1xuLy8gbW9kdWxlIGlkID0gNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports,__webpack_require__){"use strict";eval("\nexports.base64 = false;\nexports.binary = false;\nexports.dir = false;\nexports.createFolders = false;\nexports.date = null;\nexports.compression = null;\nexports.compressionOptions = null;\nexports.comment = null;\nexports.unixPermissions = null;\nexports.dosPermissions = null;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2pzemlwL2xpYi9kZWZhdWx0cy5qcz9hZjgwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNDQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5leHBvcnRzLmJhc2U2NCA9IGZhbHNlO1xuZXhwb3J0cy5iaW5hcnkgPSBmYWxzZTtcbmV4cG9ydHMuZGlyID0gZmFsc2U7XG5leHBvcnRzLmNyZWF0ZUZvbGRlcnMgPSBmYWxzZTtcbmV4cG9ydHMuZGF0ZSA9IG51bGw7XG5leHBvcnRzLmNvbXByZXNzaW9uID0gbnVsbDtcbmV4cG9ydHMuY29tcHJlc3Npb25PcHRpb25zID0gbnVsbDtcbmV4cG9ydHMuY29tbWVudCA9IG51bGw7XG5leHBvcnRzLnVuaXhQZXJtaXNzaW9ucyA9IG51bGw7XG5leHBvcnRzLmRvc1Blcm1pc3Npb25zID0gbnVsbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9qc3ppcC9saWIvZGVmYXVsdHMuanNcbi8vIG1vZHVsZSBpZCA9IDQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){"use strict";eval('\nexports.LOCAL_FILE_HEADER = "PK\\x03\\x04";\nexports.CENTRAL_FILE_HEADER = "PK\\x01\\x02";\nexports.CENTRAL_DIRECTORY_END = "PK\\x05\\x06";\nexports.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\\x06\\x07";\nexports.ZIP64_CENTRAL_DIRECTORY_END = "PK\\x06\\x06";\nexports.DATA_DESCRIPTOR = "PK\\x07\\x08";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2pzemlwL2xpYi9zaWduYXR1cmUuanM/ZDJlNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI0NS5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbmV4cG9ydHMuTE9DQUxfRklMRV9IRUFERVIgPSBcIlBLXFx4MDNcXHgwNFwiO1xuZXhwb3J0cy5DRU5UUkFMX0ZJTEVfSEVBREVSID0gXCJQS1xceDAxXFx4MDJcIjtcbmV4cG9ydHMuQ0VOVFJBTF9ESVJFQ1RPUllfRU5EID0gXCJQS1xceDA1XFx4MDZcIjtcbmV4cG9ydHMuWklQNjRfQ0VOVFJBTF9ESVJFQ1RPUllfTE9DQVRPUiA9IFwiUEtcXHgwNlxceDA3XCI7XG5leHBvcnRzLlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0VORCA9IFwiUEtcXHgwNlxceDA2XCI7XG5leHBvcnRzLkRBVEFfREVTQ1JJUFRPUiA9IFwiUEtcXHgwN1xceDA4XCI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vanN6aXAvbGliL3NpZ25hdHVyZS5qc1xuLy8gbW9kdWxlIGlkID0gNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports,__webpack_require__){"use strict";eval('\nvar DataReader = __webpack_require__(43);\nvar utils = __webpack_require__(1);\n\nfunction StringReader(data, optimizedBinaryString) {\n    this.data = data;\n    if (!optimizedBinaryString) {\n        this.data = utils.string2binary(this.data);\n    }\n    this.length = this.data.length;\n    this.index = 0;\n    this.zero = 0;\n}\nStringReader.prototype = new DataReader();\n/**\n * @see DataReader.byteAt\n */\nStringReader.prototype.byteAt = function(i) {\n    return this.data.charCodeAt(this.zero + i);\n};\n/**\n * @see DataReader.lastIndexOfSignature\n */\nStringReader.prototype.lastIndexOfSignature = function(sig) {\n    return this.data.lastIndexOf(sig) - this.zero;\n};\n/**\n * @see DataReader.readData\n */\nStringReader.prototype.readData = function(size) {\n    this.checkOffset(size);\n    // this will work because the constructor applied the "& 0xff" mask.\n    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);\n    this.index += size;\n    return result;\n};\nmodule.exports = StringReader;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2pzemlwL2xpYi9zdHJpbmdSZWFkZXIuanM/ZTdhMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjQ2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xudmFyIERhdGFSZWFkZXIgPSByZXF1aXJlKCcuL2RhdGFSZWFkZXInKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuZnVuY3Rpb24gU3RyaW5nUmVhZGVyKGRhdGEsIG9wdGltaXplZEJpbmFyeVN0cmluZykge1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgaWYgKCFvcHRpbWl6ZWRCaW5hcnlTdHJpbmcpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gdXRpbHMuc3RyaW5nMmJpbmFyeSh0aGlzLmRhdGEpO1xuICAgIH1cbiAgICB0aGlzLmxlbmd0aCA9IHRoaXMuZGF0YS5sZW5ndGg7XG4gICAgdGhpcy5pbmRleCA9IDA7XG4gICAgdGhpcy56ZXJvID0gMDtcbn1cblN0cmluZ1JlYWRlci5wcm90b3R5cGUgPSBuZXcgRGF0YVJlYWRlcigpO1xuLyoqXG4gKiBAc2VlIERhdGFSZWFkZXIuYnl0ZUF0XG4gKi9cblN0cmluZ1JlYWRlci5wcm90b3R5cGUuYnl0ZUF0ID0gZnVuY3Rpb24oaSkge1xuICAgIHJldHVybiB0aGlzLmRhdGEuY2hhckNvZGVBdCh0aGlzLnplcm8gKyBpKTtcbn07XG4vKipcbiAqIEBzZWUgRGF0YVJlYWRlci5sYXN0SW5kZXhPZlNpZ25hdHVyZVxuICovXG5TdHJpbmdSZWFkZXIucHJvdG90eXBlLmxhc3RJbmRleE9mU2lnbmF0dXJlID0gZnVuY3Rpb24oc2lnKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5sYXN0SW5kZXhPZihzaWcpIC0gdGhpcy56ZXJvO1xufTtcbi8qKlxuICogQHNlZSBEYXRhUmVhZGVyLnJlYWREYXRhXG4gKi9cblN0cmluZ1JlYWRlci5wcm90b3R5cGUucmVhZERhdGEgPSBmdW5jdGlvbihzaXplKSB7XG4gICAgdGhpcy5jaGVja09mZnNldChzaXplKTtcbiAgICAvLyB0aGlzIHdpbGwgd29yayBiZWNhdXNlIHRoZSBjb25zdHJ1Y3RvciBhcHBsaWVkIHRoZSBcIiYgMHhmZlwiIG1hc2suXG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuZGF0YS5zbGljZSh0aGlzLnplcm8gKyB0aGlzLmluZGV4LCB0aGlzLnplcm8gKyB0aGlzLmluZGV4ICsgc2l6ZSk7XG4gICAgdGhpcy5pbmRleCArPSBzaXplO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBTdHJpbmdSZWFkZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vanN6aXAvbGliL3N0cmluZ1JlYWRlci5qc1xuLy8gbW9kdWxlIGlkID0gNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports,__webpack_require__){"use strict";eval("\nvar ArrayReader = __webpack_require__(41);\n\nfunction Uint8ArrayReader(data) {\n    if (data) {\n        this.data = data;\n        this.length = this.data.length;\n        this.index = 0;\n        this.zero = 0;\n    }\n}\nUint8ArrayReader.prototype = new ArrayReader();\n/**\n * @see DataReader.readData\n */\nUint8ArrayReader.prototype.readData = function(size) {\n    this.checkOffset(size);\n    if(size === 0) {\n        // in IE10, when using subarray(idx, idx), we get the array [0x00] instead of [].\n        return new Uint8Array(0);\n    }\n    var result = this.data.subarray(this.zero + this.index, this.zero + this.index + size);\n    this.index += size;\n    return result;\n};\nmodule.exports = Uint8ArrayReader;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2pzemlwL2xpYi91aW50OEFycmF5UmVhZGVyLmpzPzE1NDgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjQ3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xudmFyIEFycmF5UmVhZGVyID0gcmVxdWlyZSgnLi9hcnJheVJlYWRlcicpO1xuXG5mdW5jdGlvbiBVaW50OEFycmF5UmVhZGVyKGRhdGEpIHtcbiAgICBpZiAoZGF0YSkge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IHRoaXMuZGF0YS5sZW5ndGg7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICB0aGlzLnplcm8gPSAwO1xuICAgIH1cbn1cblVpbnQ4QXJyYXlSZWFkZXIucHJvdG90eXBlID0gbmV3IEFycmF5UmVhZGVyKCk7XG4vKipcbiAqIEBzZWUgRGF0YVJlYWRlci5yZWFkRGF0YVxuICovXG5VaW50OEFycmF5UmVhZGVyLnByb3RvdHlwZS5yZWFkRGF0YSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgICB0aGlzLmNoZWNrT2Zmc2V0KHNpemUpO1xuICAgIGlmKHNpemUgPT09IDApIHtcbiAgICAgICAgLy8gaW4gSUUxMCwgd2hlbiB1c2luZyBzdWJhcnJheShpZHgsIGlkeCksIHdlIGdldCB0aGUgYXJyYXkgWzB4MDBdIGluc3RlYWQgb2YgW10uXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgwKTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuZGF0YS5zdWJhcnJheSh0aGlzLnplcm8gKyB0aGlzLmluZGV4LCB0aGlzLnplcm8gKyB0aGlzLmluZGV4ICsgc2l6ZSk7XG4gICAgdGhpcy5pbmRleCArPSBzaXplO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBVaW50OEFycmF5UmVhZGVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2pzemlwL2xpYi91aW50OEFycmF5UmVhZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){"use strict";eval('\n\nvar utils = __webpack_require__(1);\nvar support = __webpack_require__(6);\nvar nodeBuffer = __webpack_require__(27);\n\n/**\n * The following functions come from pako, from pako/lib/utils/strings\n * released under the MIT license, see pako https://github.com/nodeca/pako/\n */\n\n// Table with utf8 lengths (calculated by first byte of sequence)\n// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n// because max possible codepoint is 0x10ffff\nvar _utf8len = new Array(256);\nfor (var i=0; i<256; i++) {\n  _utf8len[i] = (i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1);\n}\n_utf8len[254]=_utf8len[254]=1; // Invalid sequence start\n\n// convert string to array (typed, when possible)\nvar string2buf = function (str) {\n    var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n\n    // count binary size\n    for (m_pos = 0; m_pos < str_len; m_pos++) {\n        c = str.charCodeAt(m_pos);\n        if ((c & 0xfc00) === 0xd800 && (m_pos+1 < str_len)) {\n            c2 = str.charCodeAt(m_pos+1);\n            if ((c2 & 0xfc00) === 0xdc00) {\n                c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n                m_pos++;\n            }\n        }\n        buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n    }\n\n    // allocate buffer\n    if (support.uint8array) {\n        buf = new Uint8Array(buf_len);\n    } else {\n        buf = new Array(buf_len);\n    }\n\n    // convert\n    for (i=0, m_pos = 0; i < buf_len; m_pos++) {\n        c = str.charCodeAt(m_pos);\n        if ((c & 0xfc00) === 0xd800 && (m_pos+1 < str_len)) {\n            c2 = str.charCodeAt(m_pos+1);\n            if ((c2 & 0xfc00) === 0xdc00) {\n                c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n                m_pos++;\n            }\n        }\n        if (c < 0x80) {\n            /* one byte */\n            buf[i++] = c;\n        } else if (c < 0x800) {\n            /* two bytes */\n            buf[i++] = 0xC0 | (c >>> 6);\n            buf[i++] = 0x80 | (c & 0x3f);\n        } else if (c < 0x10000) {\n            /* three bytes */\n            buf[i++] = 0xE0 | (c >>> 12);\n            buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n            buf[i++] = 0x80 | (c & 0x3f);\n        } else {\n            /* four bytes */\n            buf[i++] = 0xf0 | (c >>> 18);\n            buf[i++] = 0x80 | (c >>> 12 & 0x3f);\n            buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n            buf[i++] = 0x80 | (c & 0x3f);\n        }\n    }\n\n    return buf;\n};\n\n// Calculate max possible position in utf8 buffer,\n// that will not break sequence. If that\'s not possible\n// - (very small limits) return max size as is.\n//\n// buf[] - utf8 bytes array\n// max   - length limit (mandatory);\nvar utf8border = function(buf, max) {\n    var pos;\n\n    max = max || buf.length;\n    if (max > buf.length) { max = buf.length; }\n\n    // go back from last position, until start of sequence found\n    pos = max-1;\n    while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }\n\n    // Fuckup - very small and broken sequence,\n    // return max, because we should return something anyway.\n    if (pos < 0) { return max; }\n\n    // If we came to start of buffer - that means vuffer is too small,\n    // return max too.\n    if (pos === 0) { return max; }\n\n    return (pos + _utf8len[buf[pos]] > max) ? pos : max;\n};\n\n// convert array to string\nvar buf2string = function (buf) {\n    var str, i, out, c, c_len;\n    var len = buf.length;\n\n    // Reserve max possible length (2 words per char)\n    // NB: by unknown reasons, Array is significantly faster for\n    //     String.fromCharCode.apply than Uint16Array.\n    var utf16buf = new Array(len*2);\n\n    for (out=0, i=0; i<len;) {\n        c = buf[i++];\n        // quick process ascii\n        if (c < 0x80) { utf16buf[out++] = c; continue; }\n\n        c_len = _utf8len[c];\n        // skip 5 & 6 byte codes\n        if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len-1; continue; }\n\n        // apply mask on first byte\n        c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n        // join the rest\n        while (c_len > 1 && i < len) {\n            c = (c << 6) | (buf[i++] & 0x3f);\n            c_len--;\n        }\n\n        // terminated by end of string?\n        if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }\n\n        if (c < 0x10000) {\n            utf16buf[out++] = c;\n        } else {\n            c -= 0x10000;\n            utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);\n            utf16buf[out++] = 0xdc00 | (c & 0x3ff);\n        }\n    }\n\n    // shrinkBuf(utf16buf, out)\n    if (utf16buf.length !== out) {\n        if(utf16buf.subarray) {\n            utf16buf = utf16buf.subarray(0, out);\n        } else {\n            utf16buf.length = out;\n        }\n    }\n\n    // return String.fromCharCode.apply(null, utf16buf);\n    return utils.applyFromCharCode(utf16buf);\n};\n\n\n// That\'s all for the pako functions.\n\n\n/**\n * Transform a javascript string into an array (typed if possible) of bytes,\n * UTF-8 encoded.\n * @param {String} str the string to encode\n * @return {Array|Uint8Array|Buffer} the UTF-8 encoded string.\n */\nexports.utf8encode = function utf8encode(str) {\n    if (support.nodebuffer) {\n        return nodeBuffer(str, "utf-8");\n    }\n\n    return string2buf(str);\n};\n\n\n/**\n * Transform a bytes array (or a representation) representing an UTF-8 encoded\n * string into a javascript string.\n * @param {Array|Uint8Array|Buffer} buf the data de decode\n * @return {String} the decoded string.\n */\nexports.utf8decode = function utf8decode(buf) {\n    if (support.nodebuffer) {\n        return utils.transformTo("nodebuffer", buf).toString("utf-8");\n    }\n\n    buf = utils.transformTo(support.uint8array ? "uint8array" : "array", buf);\n\n    // return buf2string(buf);\n    // Chrome prefers to work with "small" chunks of data\n    // for the method buf2string.\n    // Firefox and Chrome has their own shortcut, IE doesn\'t seem to really care.\n    var result = [], k = 0, len = buf.length, chunk = 65536;\n    while (k < len) {\n        var nextBoundary = utf8border(buf, Math.min(k + chunk, len));\n        if (support.uint8array) {\n            result.push(buf2string(buf.subarray(k, nextBoundary)));\n        } else {\n            result.push(buf2string(buf.slice(k, nextBoundary)));\n        }\n        k = nextBoundary;\n    }\n    return result.join("");\n\n};\n// vim: set shiftwidth=4 softtabstop=4:\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2pzemlwL2xpYi91dGY4LmpzPzQyMWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsYUFBYTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsa0JBQWtCOztBQUU3QztBQUNBO0FBQ0Esb0RBQW9ELE9BQU87O0FBRTNEO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTs7QUFFOUI7QUFDQTtBQUNBLG9CQUFvQixZQUFZOztBQUVoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQSx1QkFBdUIscUJBQXFCLFVBQVU7O0FBRXREO0FBQ0E7QUFDQSx3QkFBd0IsMEJBQTBCLGNBQWMsVUFBVTs7QUFFMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsMEJBQTBCLFVBQVU7O0FBRTVEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksd0JBQXdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx3QkFBd0I7QUFDbkMsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsImZpbGUiOiI0OC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIHN1cHBvcnQgPSByZXF1aXJlKCcuL3N1cHBvcnQnKTtcbnZhciBub2RlQnVmZmVyID0gcmVxdWlyZSgnLi9ub2RlQnVmZmVyJyk7XG5cbi8qKlxuICogVGhlIGZvbGxvd2luZyBmdW5jdGlvbnMgY29tZSBmcm9tIHBha28sIGZyb20gcGFrby9saWIvdXRpbHMvc3RyaW5nc1xuICogcmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLCBzZWUgcGFrbyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWNhL3Bha28vXG4gKi9cblxuLy8gVGFibGUgd2l0aCB1dGY4IGxlbmd0aHMgKGNhbGN1bGF0ZWQgYnkgZmlyc3QgYnl0ZSBvZiBzZXF1ZW5jZSlcbi8vIE5vdGUsIHRoYXQgNSAmIDYtYnl0ZSB2YWx1ZXMgYW5kIHNvbWUgNC1ieXRlIHZhbHVlcyBjYW4gbm90IGJlIHJlcHJlc2VudGVkIGluIEpTLFxuLy8gYmVjYXVzZSBtYXggcG9zc2libGUgY29kZXBvaW50IGlzIDB4MTBmZmZmXG52YXIgX3V0ZjhsZW4gPSBuZXcgQXJyYXkoMjU2KTtcbmZvciAodmFyIGk9MDsgaTwyNTY7IGkrKykge1xuICBfdXRmOGxlbltpXSA9IChpID49IDI1MiA/IDYgOiBpID49IDI0OCA/IDUgOiBpID49IDI0MCA/IDQgOiBpID49IDIyNCA/IDMgOiBpID49IDE5MiA/IDIgOiAxKTtcbn1cbl91dGY4bGVuWzI1NF09X3V0ZjhsZW5bMjU0XT0xOyAvLyBJbnZhbGlkIHNlcXVlbmNlIHN0YXJ0XG5cbi8vIGNvbnZlcnQgc3RyaW5nIHRvIGFycmF5ICh0eXBlZCwgd2hlbiBwb3NzaWJsZSlcbnZhciBzdHJpbmcyYnVmID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHZhciBidWYsIGMsIGMyLCBtX3BvcywgaSwgc3RyX2xlbiA9IHN0ci5sZW5ndGgsIGJ1Zl9sZW4gPSAwO1xuXG4gICAgLy8gY291bnQgYmluYXJ5IHNpemVcbiAgICBmb3IgKG1fcG9zID0gMDsgbV9wb3MgPCBzdHJfbGVuOyBtX3BvcysrKSB7XG4gICAgICAgIGMgPSBzdHIuY2hhckNvZGVBdChtX3Bvcyk7XG4gICAgICAgIGlmICgoYyAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJiAobV9wb3MrMSA8IHN0cl9sZW4pKSB7XG4gICAgICAgICAgICBjMiA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zKzEpO1xuICAgICAgICAgICAgaWYgKChjMiAmIDB4ZmMwMCkgPT09IDB4ZGMwMCkge1xuICAgICAgICAgICAgICAgIGMgPSAweDEwMDAwICsgKChjIC0gMHhkODAwKSA8PCAxMCkgKyAoYzIgLSAweGRjMDApO1xuICAgICAgICAgICAgICAgIG1fcG9zKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnVmX2xlbiArPSBjIDwgMHg4MCA/IDEgOiBjIDwgMHg4MDAgPyAyIDogYyA8IDB4MTAwMDAgPyAzIDogNDtcbiAgICB9XG5cbiAgICAvLyBhbGxvY2F0ZSBidWZmZXJcbiAgICBpZiAoc3VwcG9ydC51aW50OGFycmF5KSB7XG4gICAgICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGJ1Zl9sZW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1ZiA9IG5ldyBBcnJheShidWZfbGVuKTtcbiAgICB9XG5cbiAgICAvLyBjb252ZXJ0XG4gICAgZm9yIChpPTAsIG1fcG9zID0gMDsgaSA8IGJ1Zl9sZW47IG1fcG9zKyspIHtcbiAgICAgICAgYyA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zKTtcbiAgICAgICAgaWYgKChjICYgMHhmYzAwKSA9PT0gMHhkODAwICYmIChtX3BvcysxIDwgc3RyX2xlbikpIHtcbiAgICAgICAgICAgIGMyID0gc3RyLmNoYXJDb2RlQXQobV9wb3MrMSk7XG4gICAgICAgICAgICBpZiAoKGMyICYgMHhmYzAwKSA9PT0gMHhkYzAwKSB7XG4gICAgICAgICAgICAgICAgYyA9IDB4MTAwMDAgKyAoKGMgLSAweGQ4MDApIDw8IDEwKSArIChjMiAtIDB4ZGMwMCk7XG4gICAgICAgICAgICAgICAgbV9wb3MrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgICAgICAgIC8qIG9uZSBieXRlICovXG4gICAgICAgICAgICBidWZbaSsrXSA9IGM7XG4gICAgICAgIH0gZWxzZSBpZiAoYyA8IDB4ODAwKSB7XG4gICAgICAgICAgICAvKiB0d28gYnl0ZXMgKi9cbiAgICAgICAgICAgIGJ1ZltpKytdID0gMHhDMCB8IChjID4+PiA2KTtcbiAgICAgICAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjICYgMHgzZik7XG4gICAgICAgIH0gZWxzZSBpZiAoYyA8IDB4MTAwMDApIHtcbiAgICAgICAgICAgIC8qIHRocmVlIGJ5dGVzICovXG4gICAgICAgICAgICBidWZbaSsrXSA9IDB4RTAgfCAoYyA+Pj4gMTIpO1xuICAgICAgICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgPj4+IDYgJiAweDNmKTtcbiAgICAgICAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjICYgMHgzZik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvKiBmb3VyIGJ5dGVzICovXG4gICAgICAgICAgICBidWZbaSsrXSA9IDB4ZjAgfCAoYyA+Pj4gMTgpO1xuICAgICAgICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgPj4+IDEyICYgMHgzZik7XG4gICAgICAgICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gNiAmIDB4M2YpO1xuICAgICAgICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgJiAweDNmKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBidWY7XG59O1xuXG4vLyBDYWxjdWxhdGUgbWF4IHBvc3NpYmxlIHBvc2l0aW9uIGluIHV0ZjggYnVmZmVyLFxuLy8gdGhhdCB3aWxsIG5vdCBicmVhayBzZXF1ZW5jZS4gSWYgdGhhdCdzIG5vdCBwb3NzaWJsZVxuLy8gLSAodmVyeSBzbWFsbCBsaW1pdHMpIHJldHVybiBtYXggc2l6ZSBhcyBpcy5cbi8vXG4vLyBidWZbXSAtIHV0ZjggYnl0ZXMgYXJyYXlcbi8vIG1heCAgIC0gbGVuZ3RoIGxpbWl0IChtYW5kYXRvcnkpO1xudmFyIHV0Zjhib3JkZXIgPSBmdW5jdGlvbihidWYsIG1heCkge1xuICAgIHZhciBwb3M7XG5cbiAgICBtYXggPSBtYXggfHwgYnVmLmxlbmd0aDtcbiAgICBpZiAobWF4ID4gYnVmLmxlbmd0aCkgeyBtYXggPSBidWYubGVuZ3RoOyB9XG5cbiAgICAvLyBnbyBiYWNrIGZyb20gbGFzdCBwb3NpdGlvbiwgdW50aWwgc3RhcnQgb2Ygc2VxdWVuY2UgZm91bmRcbiAgICBwb3MgPSBtYXgtMTtcbiAgICB3aGlsZSAocG9zID49IDAgJiYgKGJ1Zltwb3NdICYgMHhDMCkgPT09IDB4ODApIHsgcG9zLS07IH1cblxuICAgIC8vIEZ1Y2t1cCAtIHZlcnkgc21hbGwgYW5kIGJyb2tlbiBzZXF1ZW5jZSxcbiAgICAvLyByZXR1cm4gbWF4LCBiZWNhdXNlIHdlIHNob3VsZCByZXR1cm4gc29tZXRoaW5nIGFueXdheS5cbiAgICBpZiAocG9zIDwgMCkgeyByZXR1cm4gbWF4OyB9XG5cbiAgICAvLyBJZiB3ZSBjYW1lIHRvIHN0YXJ0IG9mIGJ1ZmZlciAtIHRoYXQgbWVhbnMgdnVmZmVyIGlzIHRvbyBzbWFsbCxcbiAgICAvLyByZXR1cm4gbWF4IHRvby5cbiAgICBpZiAocG9zID09PSAwKSB7IHJldHVybiBtYXg7IH1cblxuICAgIHJldHVybiAocG9zICsgX3V0ZjhsZW5bYnVmW3Bvc11dID4gbWF4KSA/IHBvcyA6IG1heDtcbn07XG5cbi8vIGNvbnZlcnQgYXJyYXkgdG8gc3RyaW5nXG52YXIgYnVmMnN0cmluZyA9IGZ1bmN0aW9uIChidWYpIHtcbiAgICB2YXIgc3RyLCBpLCBvdXQsIGMsIGNfbGVuO1xuICAgIHZhciBsZW4gPSBidWYubGVuZ3RoO1xuXG4gICAgLy8gUmVzZXJ2ZSBtYXggcG9zc2libGUgbGVuZ3RoICgyIHdvcmRzIHBlciBjaGFyKVxuICAgIC8vIE5COiBieSB1bmtub3duIHJlYXNvbnMsIEFycmF5IGlzIHNpZ25pZmljYW50bHkgZmFzdGVyIGZvclxuICAgIC8vICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5IHRoYW4gVWludDE2QXJyYXkuXG4gICAgdmFyIHV0ZjE2YnVmID0gbmV3IEFycmF5KGxlbioyKTtcblxuICAgIGZvciAob3V0PTAsIGk9MDsgaTxsZW47KSB7XG4gICAgICAgIGMgPSBidWZbaSsrXTtcbiAgICAgICAgLy8gcXVpY2sgcHJvY2VzcyBhc2NpaVxuICAgICAgICBpZiAoYyA8IDB4ODApIHsgdXRmMTZidWZbb3V0KytdID0gYzsgY29udGludWU7IH1cblxuICAgICAgICBjX2xlbiA9IF91dGY4bGVuW2NdO1xuICAgICAgICAvLyBza2lwIDUgJiA2IGJ5dGUgY29kZXNcbiAgICAgICAgaWYgKGNfbGVuID4gNCkgeyB1dGYxNmJ1ZltvdXQrK10gPSAweGZmZmQ7IGkgKz0gY19sZW4tMTsgY29udGludWU7IH1cblxuICAgICAgICAvLyBhcHBseSBtYXNrIG9uIGZpcnN0IGJ5dGVcbiAgICAgICAgYyAmPSBjX2xlbiA9PT0gMiA/IDB4MWYgOiBjX2xlbiA9PT0gMyA/IDB4MGYgOiAweDA3O1xuICAgICAgICAvLyBqb2luIHRoZSByZXN0XG4gICAgICAgIHdoaWxlIChjX2xlbiA+IDEgJiYgaSA8IGxlbikge1xuICAgICAgICAgICAgYyA9IChjIDw8IDYpIHwgKGJ1ZltpKytdICYgMHgzZik7XG4gICAgICAgICAgICBjX2xlbi0tO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGVybWluYXRlZCBieSBlbmQgb2Ygc3RyaW5nP1xuICAgICAgICBpZiAoY19sZW4gPiAxKSB7IHV0ZjE2YnVmW291dCsrXSA9IDB4ZmZmZDsgY29udGludWU7IH1cblxuICAgICAgICBpZiAoYyA8IDB4MTAwMDApIHtcbiAgICAgICAgICAgIHV0ZjE2YnVmW291dCsrXSA9IGM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjIC09IDB4MTAwMDA7XG4gICAgICAgICAgICB1dGYxNmJ1ZltvdXQrK10gPSAweGQ4MDAgfCAoKGMgPj4gMTApICYgMHgzZmYpO1xuICAgICAgICAgICAgdXRmMTZidWZbb3V0KytdID0gMHhkYzAwIHwgKGMgJiAweDNmZik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzaHJpbmtCdWYodXRmMTZidWYsIG91dClcbiAgICBpZiAodXRmMTZidWYubGVuZ3RoICE9PSBvdXQpIHtcbiAgICAgICAgaWYodXRmMTZidWYuc3ViYXJyYXkpIHtcbiAgICAgICAgICAgIHV0ZjE2YnVmID0gdXRmMTZidWYuc3ViYXJyYXkoMCwgb3V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHV0ZjE2YnVmLmxlbmd0aCA9IG91dDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIHV0ZjE2YnVmKTtcbiAgICByZXR1cm4gdXRpbHMuYXBwbHlGcm9tQ2hhckNvZGUodXRmMTZidWYpO1xufTtcblxuXG4vLyBUaGF0J3MgYWxsIGZvciB0aGUgcGFrbyBmdW5jdGlvbnMuXG5cblxuLyoqXG4gKiBUcmFuc2Zvcm0gYSBqYXZhc2NyaXB0IHN0cmluZyBpbnRvIGFuIGFycmF5ICh0eXBlZCBpZiBwb3NzaWJsZSkgb2YgYnl0ZXMsXG4gKiBVVEYtOCBlbmNvZGVkLlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciB0aGUgc3RyaW5nIHRvIGVuY29kZVxuICogQHJldHVybiB7QXJyYXl8VWludDhBcnJheXxCdWZmZXJ9IHRoZSBVVEYtOCBlbmNvZGVkIHN0cmluZy5cbiAqL1xuZXhwb3J0cy51dGY4ZW5jb2RlID0gZnVuY3Rpb24gdXRmOGVuY29kZShzdHIpIHtcbiAgICBpZiAoc3VwcG9ydC5ub2RlYnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBub2RlQnVmZmVyKHN0ciwgXCJ1dGYtOFwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyaW5nMmJ1ZihzdHIpO1xufTtcblxuXG4vKipcbiAqIFRyYW5zZm9ybSBhIGJ5dGVzIGFycmF5IChvciBhIHJlcHJlc2VudGF0aW9uKSByZXByZXNlbnRpbmcgYW4gVVRGLTggZW5jb2RlZFxuICogc3RyaW5nIGludG8gYSBqYXZhc2NyaXB0IHN0cmluZy5cbiAqIEBwYXJhbSB7QXJyYXl8VWludDhBcnJheXxCdWZmZXJ9IGJ1ZiB0aGUgZGF0YSBkZSBkZWNvZGVcbiAqIEByZXR1cm4ge1N0cmluZ30gdGhlIGRlY29kZWQgc3RyaW5nLlxuICovXG5leHBvcnRzLnV0ZjhkZWNvZGUgPSBmdW5jdGlvbiB1dGY4ZGVjb2RlKGJ1Zikge1xuICAgIGlmIChzdXBwb3J0Lm5vZGVidWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIHV0aWxzLnRyYW5zZm9ybVRvKFwibm9kZWJ1ZmZlclwiLCBidWYpLnRvU3RyaW5nKFwidXRmLThcIik7XG4gICAgfVxuXG4gICAgYnVmID0gdXRpbHMudHJhbnNmb3JtVG8oc3VwcG9ydC51aW50OGFycmF5ID8gXCJ1aW50OGFycmF5XCIgOiBcImFycmF5XCIsIGJ1Zik7XG5cbiAgICAvLyByZXR1cm4gYnVmMnN0cmluZyhidWYpO1xuICAgIC8vIENocm9tZSBwcmVmZXJzIHRvIHdvcmsgd2l0aCBcInNtYWxsXCIgY2h1bmtzIG9mIGRhdGFcbiAgICAvLyBmb3IgdGhlIG1ldGhvZCBidWYyc3RyaW5nLlxuICAgIC8vIEZpcmVmb3ggYW5kIENocm9tZSBoYXMgdGhlaXIgb3duIHNob3J0Y3V0LCBJRSBkb2Vzbid0IHNlZW0gdG8gcmVhbGx5IGNhcmUuXG4gICAgdmFyIHJlc3VsdCA9IFtdLCBrID0gMCwgbGVuID0gYnVmLmxlbmd0aCwgY2h1bmsgPSA2NTUzNjtcbiAgICB3aGlsZSAoayA8IGxlbikge1xuICAgICAgICB2YXIgbmV4dEJvdW5kYXJ5ID0gdXRmOGJvcmRlcihidWYsIE1hdGgubWluKGsgKyBjaHVuaywgbGVuKSk7XG4gICAgICAgIGlmIChzdXBwb3J0LnVpbnQ4YXJyYXkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJ1ZjJzdHJpbmcoYnVmLnN1YmFycmF5KGssIG5leHRCb3VuZGFyeSkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJ1ZjJzdHJpbmcoYnVmLnNsaWNlKGssIG5leHRCb3VuZGFyeSkpKTtcbiAgICAgICAgfVxuICAgICAgICBrID0gbmV4dEJvdW5kYXJ5O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LmpvaW4oXCJcIik7XG5cbn07XG4vLyB2aW06IHNldCBzaGlmdHdpZHRoPTQgc29mdHRhYnN0b3A9NDpcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9qc3ppcC9saWIvdXRmOC5qc1xuLy8gbW9kdWxlIGlkID0gNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports,__webpack_require__){"use strict";eval("// String encode/decode helpers\n\n\n\nvar utils = __webpack_require__(3);\n\n\n// Quick check if we can use fast array to bin string conversion\n//\n// - apply(Array) can fail on Android 2.2\n// - apply(Uint8Array) can fail on iOS 5.1 Safary\n//\nvar STR_APPLY_OK = true;\nvar STR_APPLY_UIA_OK = true;\n\ntry { String.fromCharCode.apply(null, [ 0 ]); } catch (__) { STR_APPLY_OK = false; }\ntry { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }\n\n\n// Table with utf8 lengths (calculated by first byte of sequence)\n// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n// because max possible codepoint is 0x10ffff\nvar _utf8len = new utils.Buf8(256);\nfor (var q = 0; q < 256; q++) {\n  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);\n}\n_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start\n\n\n// convert string to array (typed, when possible)\nexports.string2buf = function (str) {\n  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n\n  // count binary size\n  for (m_pos = 0; m_pos < str_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n  }\n\n  // allocate buffer\n  buf = new utils.Buf8(buf_len);\n\n  // convert\n  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    if (c < 0x80) {\n      /* one byte */\n      buf[i++] = c;\n    } else if (c < 0x800) {\n      /* two bytes */\n      buf[i++] = 0xC0 | (c >>> 6);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else if (c < 0x10000) {\n      /* three bytes */\n      buf[i++] = 0xE0 | (c >>> 12);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else {\n      /* four bytes */\n      buf[i++] = 0xf0 | (c >>> 18);\n      buf[i++] = 0x80 | (c >>> 12 & 0x3f);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    }\n  }\n\n  return buf;\n};\n\n// Helper (used in 2 places)\nfunction buf2binstring(buf, len) {\n  // use fallback for big arrays to avoid stack overflow\n  if (len < 65537) {\n    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {\n      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));\n    }\n  }\n\n  var result = '';\n  for (var i = 0; i < len; i++) {\n    result += String.fromCharCode(buf[i]);\n  }\n  return result;\n}\n\n\n// Convert byte array to binary string\nexports.buf2binstring = function (buf) {\n  return buf2binstring(buf, buf.length);\n};\n\n\n// Convert binary string (typed, when possible)\nexports.binstring2buf = function (str) {\n  var buf = new utils.Buf8(str.length);\n  for (var i = 0, len = buf.length; i < len; i++) {\n    buf[i] = str.charCodeAt(i);\n  }\n  return buf;\n};\n\n\n// convert array to string\nexports.buf2string = function (buf, max) {\n  var i, out, c, c_len;\n  var len = max || buf.length;\n\n  // Reserve max possible length (2 words per char)\n  // NB: by unknown reasons, Array is significantly faster for\n  //     String.fromCharCode.apply than Uint16Array.\n  var utf16buf = new Array(len * 2);\n\n  for (out = 0, i = 0; i < len;) {\n    c = buf[i++];\n    // quick process ascii\n    if (c < 0x80) { utf16buf[out++] = c; continue; }\n\n    c_len = _utf8len[c];\n    // skip 5 & 6 byte codes\n    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }\n\n    // apply mask on first byte\n    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n    // join the rest\n    while (c_len > 1 && i < len) {\n      c = (c << 6) | (buf[i++] & 0x3f);\n      c_len--;\n    }\n\n    // terminated by end of string?\n    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }\n\n    if (c < 0x10000) {\n      utf16buf[out++] = c;\n    } else {\n      c -= 0x10000;\n      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);\n      utf16buf[out++] = 0xdc00 | (c & 0x3ff);\n    }\n  }\n\n  return buf2binstring(utf16buf, out);\n};\n\n\n// Calculate max possible position in utf8 buffer,\n// that will not break sequence. If that's not possible\n// - (very small limits) return max size as is.\n//\n// buf[] - utf8 bytes array\n// max   - length limit (mandatory);\nexports.utf8border = function (buf, max) {\n  var pos;\n\n  max = max || buf.length;\n  if (max > buf.length) { max = buf.length; }\n\n  // go back from last position, until start of sequence found\n  pos = max - 1;\n  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }\n\n  // Fuckup - very small and broken sequence,\n  // return max, because we should return something anyway.\n  if (pos < 0) { return max; }\n\n  // If we came to start of buffer - that means vuffer is too small,\n  // return max too.\n  if (pos === 0) { return max; }\n\n  return (pos + _utf8len[buf[pos]] > max) ? pos : max;\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2pzemlwL34vcGFrby9saWIvdXRpbHMvc3RyaW5ncy5qcz84MWMzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7OztBQUdBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLLHdDQUF3QyxFQUFFLGFBQWEsc0JBQXNCO0FBQ2xGLEtBQUssb0RBQW9ELEVBQUUsYUFBYSwwQkFBMEI7OztBQUdsRztBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0Esa0NBQWtDOzs7QUFHbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLGFBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsU0FBUztBQUM1QztBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBLG1CQUFtQixxQkFBcUIsVUFBVTs7QUFFbEQ7QUFDQTtBQUNBLG9CQUFvQiwwQkFBMEIsZ0JBQWdCLFVBQVU7O0FBRXhFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLDBCQUEwQixVQUFVOztBQUV4RDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QixrQkFBa0I7O0FBRTNDO0FBQ0E7QUFDQSxrREFBa0QsT0FBTzs7QUFFekQ7QUFDQTtBQUNBLGdCQUFnQixZQUFZOztBQUU1QjtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7O0FBRTlCO0FBQ0EiLCJmaWxlIjoiNDkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTdHJpbmcgZW5jb2RlL2RlY29kZSBoZWxwZXJzXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi9jb21tb24nKTtcblxuXG4vLyBRdWljayBjaGVjayBpZiB3ZSBjYW4gdXNlIGZhc3QgYXJyYXkgdG8gYmluIHN0cmluZyBjb252ZXJzaW9uXG4vL1xuLy8gLSBhcHBseShBcnJheSkgY2FuIGZhaWwgb24gQW5kcm9pZCAyLjJcbi8vIC0gYXBwbHkoVWludDhBcnJheSkgY2FuIGZhaWwgb24gaU9TIDUuMSBTYWZhcnlcbi8vXG52YXIgU1RSX0FQUExZX09LID0gdHJ1ZTtcbnZhciBTVFJfQVBQTFlfVUlBX09LID0gdHJ1ZTtcblxudHJ5IHsgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBbIDAgXSk7IH0gY2F0Y2ggKF9fKSB7IFNUUl9BUFBMWV9PSyA9IGZhbHNlOyB9XG50cnkgeyBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KDEpKTsgfSBjYXRjaCAoX18pIHsgU1RSX0FQUExZX1VJQV9PSyA9IGZhbHNlOyB9XG5cblxuLy8gVGFibGUgd2l0aCB1dGY4IGxlbmd0aHMgKGNhbGN1bGF0ZWQgYnkgZmlyc3QgYnl0ZSBvZiBzZXF1ZW5jZSlcbi8vIE5vdGUsIHRoYXQgNSAmIDYtYnl0ZSB2YWx1ZXMgYW5kIHNvbWUgNC1ieXRlIHZhbHVlcyBjYW4gbm90IGJlIHJlcHJlc2VudGVkIGluIEpTLFxuLy8gYmVjYXVzZSBtYXggcG9zc2libGUgY29kZXBvaW50IGlzIDB4MTBmZmZmXG52YXIgX3V0ZjhsZW4gPSBuZXcgdXRpbHMuQnVmOCgyNTYpO1xuZm9yICh2YXIgcSA9IDA7IHEgPCAyNTY7IHErKykge1xuICBfdXRmOGxlbltxXSA9IChxID49IDI1MiA/IDYgOiBxID49IDI0OCA/IDUgOiBxID49IDI0MCA/IDQgOiBxID49IDIyNCA/IDMgOiBxID49IDE5MiA/IDIgOiAxKTtcbn1cbl91dGY4bGVuWzI1NF0gPSBfdXRmOGxlblsyNTRdID0gMTsgLy8gSW52YWxpZCBzZXF1ZW5jZSBzdGFydFxuXG5cbi8vIGNvbnZlcnQgc3RyaW5nIHRvIGFycmF5ICh0eXBlZCwgd2hlbiBwb3NzaWJsZSlcbmV4cG9ydHMuc3RyaW5nMmJ1ZiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgdmFyIGJ1ZiwgYywgYzIsIG1fcG9zLCBpLCBzdHJfbGVuID0gc3RyLmxlbmd0aCwgYnVmX2xlbiA9IDA7XG5cbiAgLy8gY291bnQgYmluYXJ5IHNpemVcbiAgZm9yIChtX3BvcyA9IDA7IG1fcG9zIDwgc3RyX2xlbjsgbV9wb3MrKykge1xuICAgIGMgPSBzdHIuY2hhckNvZGVBdChtX3Bvcyk7XG4gICAgaWYgKChjICYgMHhmYzAwKSA9PT0gMHhkODAwICYmIChtX3BvcyArIDEgPCBzdHJfbGVuKSkge1xuICAgICAgYzIgPSBzdHIuY2hhckNvZGVBdChtX3BvcyArIDEpO1xuICAgICAgaWYgKChjMiAmIDB4ZmMwMCkgPT09IDB4ZGMwMCkge1xuICAgICAgICBjID0gMHgxMDAwMCArICgoYyAtIDB4ZDgwMCkgPDwgMTApICsgKGMyIC0gMHhkYzAwKTtcbiAgICAgICAgbV9wb3MrKztcbiAgICAgIH1cbiAgICB9XG4gICAgYnVmX2xlbiArPSBjIDwgMHg4MCA/IDEgOiBjIDwgMHg4MDAgPyAyIDogYyA8IDB4MTAwMDAgPyAzIDogNDtcbiAgfVxuXG4gIC8vIGFsbG9jYXRlIGJ1ZmZlclxuICBidWYgPSBuZXcgdXRpbHMuQnVmOChidWZfbGVuKTtcblxuICAvLyBjb252ZXJ0XG4gIGZvciAoaSA9IDAsIG1fcG9zID0gMDsgaSA8IGJ1Zl9sZW47IG1fcG9zKyspIHtcbiAgICBjID0gc3RyLmNoYXJDb2RlQXQobV9wb3MpO1xuICAgIGlmICgoYyAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJiAobV9wb3MgKyAxIDwgc3RyX2xlbikpIHtcbiAgICAgIGMyID0gc3RyLmNoYXJDb2RlQXQobV9wb3MgKyAxKTtcbiAgICAgIGlmICgoYzIgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgYyA9IDB4MTAwMDAgKyAoKGMgLSAweGQ4MDApIDw8IDEwKSArIChjMiAtIDB4ZGMwMCk7XG4gICAgICAgIG1fcG9zKys7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgLyogb25lIGJ5dGUgKi9cbiAgICAgIGJ1ZltpKytdID0gYztcbiAgICB9IGVsc2UgaWYgKGMgPCAweDgwMCkge1xuICAgICAgLyogdHdvIGJ5dGVzICovXG4gICAgICBidWZbaSsrXSA9IDB4QzAgfCAoYyA+Pj4gNik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgIH0gZWxzZSBpZiAoYyA8IDB4MTAwMDApIHtcbiAgICAgIC8qIHRocmVlIGJ5dGVzICovXG4gICAgICBidWZbaSsrXSA9IDB4RTAgfCAoYyA+Pj4gMTIpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgPj4+IDYgJiAweDNmKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjICYgMHgzZik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIGZvdXIgYnl0ZXMgKi9cbiAgICAgIGJ1ZltpKytdID0gMHhmMCB8IChjID4+PiAxOCk7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gMTIgJiAweDNmKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiA2ICYgMHgzZik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWY7XG59O1xuXG4vLyBIZWxwZXIgKHVzZWQgaW4gMiBwbGFjZXMpXG5mdW5jdGlvbiBidWYyYmluc3RyaW5nKGJ1ZiwgbGVuKSB7XG4gIC8vIHVzZSBmYWxsYmFjayBmb3IgYmlnIGFycmF5cyB0byBhdm9pZCBzdGFjayBvdmVyZmxvd1xuICBpZiAobGVuIDwgNjU1MzcpIHtcbiAgICBpZiAoKGJ1Zi5zdWJhcnJheSAmJiBTVFJfQVBQTFlfVUlBX09LKSB8fCAoIWJ1Zi5zdWJhcnJheSAmJiBTVFJfQVBQTFlfT0spKSB7XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCB1dGlscy5zaHJpbmtCdWYoYnVmLCBsZW4pKTtcbiAgICB9XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cblxuLy8gQ29udmVydCBieXRlIGFycmF5IHRvIGJpbmFyeSBzdHJpbmdcbmV4cG9ydHMuYnVmMmJpbnN0cmluZyA9IGZ1bmN0aW9uIChidWYpIHtcbiAgcmV0dXJuIGJ1ZjJiaW5zdHJpbmcoYnVmLCBidWYubGVuZ3RoKTtcbn07XG5cblxuLy8gQ29udmVydCBiaW5hcnkgc3RyaW5nICh0eXBlZCwgd2hlbiBwb3NzaWJsZSlcbmV4cG9ydHMuYmluc3RyaW5nMmJ1ZiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgdmFyIGJ1ZiA9IG5ldyB1dGlscy5CdWY4KHN0ci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gYnVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYnVmW2ldID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gIH1cbiAgcmV0dXJuIGJ1Zjtcbn07XG5cblxuLy8gY29udmVydCBhcnJheSB0byBzdHJpbmdcbmV4cG9ydHMuYnVmMnN0cmluZyA9IGZ1bmN0aW9uIChidWYsIG1heCkge1xuICB2YXIgaSwgb3V0LCBjLCBjX2xlbjtcbiAgdmFyIGxlbiA9IG1heCB8fCBidWYubGVuZ3RoO1xuXG4gIC8vIFJlc2VydmUgbWF4IHBvc3NpYmxlIGxlbmd0aCAoMiB3b3JkcyBwZXIgY2hhcilcbiAgLy8gTkI6IGJ5IHVua25vd24gcmVhc29ucywgQXJyYXkgaXMgc2lnbmlmaWNhbnRseSBmYXN0ZXIgZm9yXG4gIC8vICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5IHRoYW4gVWludDE2QXJyYXkuXG4gIHZhciB1dGYxNmJ1ZiA9IG5ldyBBcnJheShsZW4gKiAyKTtcblxuICBmb3IgKG91dCA9IDAsIGkgPSAwOyBpIDwgbGVuOykge1xuICAgIGMgPSBidWZbaSsrXTtcbiAgICAvLyBxdWljayBwcm9jZXNzIGFzY2lpXG4gICAgaWYgKGMgPCAweDgwKSB7IHV0ZjE2YnVmW291dCsrXSA9IGM7IGNvbnRpbnVlOyB9XG5cbiAgICBjX2xlbiA9IF91dGY4bGVuW2NdO1xuICAgIC8vIHNraXAgNSAmIDYgYnl0ZSBjb2Rlc1xuICAgIGlmIChjX2xlbiA+IDQpIHsgdXRmMTZidWZbb3V0KytdID0gMHhmZmZkOyBpICs9IGNfbGVuIC0gMTsgY29udGludWU7IH1cblxuICAgIC8vIGFwcGx5IG1hc2sgb24gZmlyc3QgYnl0ZVxuICAgIGMgJj0gY19sZW4gPT09IDIgPyAweDFmIDogY19sZW4gPT09IDMgPyAweDBmIDogMHgwNztcbiAgICAvLyBqb2luIHRoZSByZXN0XG4gICAgd2hpbGUgKGNfbGVuID4gMSAmJiBpIDwgbGVuKSB7XG4gICAgICBjID0gKGMgPDwgNikgfCAoYnVmW2krK10gJiAweDNmKTtcbiAgICAgIGNfbGVuLS07XG4gICAgfVxuXG4gICAgLy8gdGVybWluYXRlZCBieSBlbmQgb2Ygc3RyaW5nP1xuICAgIGlmIChjX2xlbiA+IDEpIHsgdXRmMTZidWZbb3V0KytdID0gMHhmZmZkOyBjb250aW51ZTsgfVxuXG4gICAgaWYgKGMgPCAweDEwMDAwKSB7XG4gICAgICB1dGYxNmJ1ZltvdXQrK10gPSBjO1xuICAgIH0gZWxzZSB7XG4gICAgICBjIC09IDB4MTAwMDA7XG4gICAgICB1dGYxNmJ1ZltvdXQrK10gPSAweGQ4MDAgfCAoKGMgPj4gMTApICYgMHgzZmYpO1xuICAgICAgdXRmMTZidWZbb3V0KytdID0gMHhkYzAwIHwgKGMgJiAweDNmZik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1ZjJiaW5zdHJpbmcodXRmMTZidWYsIG91dCk7XG59O1xuXG5cbi8vIENhbGN1bGF0ZSBtYXggcG9zc2libGUgcG9zaXRpb24gaW4gdXRmOCBidWZmZXIsXG4vLyB0aGF0IHdpbGwgbm90IGJyZWFrIHNlcXVlbmNlLiBJZiB0aGF0J3Mgbm90IHBvc3NpYmxlXG4vLyAtICh2ZXJ5IHNtYWxsIGxpbWl0cykgcmV0dXJuIG1heCBzaXplIGFzIGlzLlxuLy9cbi8vIGJ1ZltdIC0gdXRmOCBieXRlcyBhcnJheVxuLy8gbWF4ICAgLSBsZW5ndGggbGltaXQgKG1hbmRhdG9yeSk7XG5leHBvcnRzLnV0Zjhib3JkZXIgPSBmdW5jdGlvbiAoYnVmLCBtYXgpIHtcbiAgdmFyIHBvcztcblxuICBtYXggPSBtYXggfHwgYnVmLmxlbmd0aDtcbiAgaWYgKG1heCA+IGJ1Zi5sZW5ndGgpIHsgbWF4ID0gYnVmLmxlbmd0aDsgfVxuXG4gIC8vIGdvIGJhY2sgZnJvbSBsYXN0IHBvc2l0aW9uLCB1bnRpbCBzdGFydCBvZiBzZXF1ZW5jZSBmb3VuZFxuICBwb3MgPSBtYXggLSAxO1xuICB3aGlsZSAocG9zID49IDAgJiYgKGJ1Zltwb3NdICYgMHhDMCkgPT09IDB4ODApIHsgcG9zLS07IH1cblxuICAvLyBGdWNrdXAgLSB2ZXJ5IHNtYWxsIGFuZCBicm9rZW4gc2VxdWVuY2UsXG4gIC8vIHJldHVybiBtYXgsIGJlY2F1c2Ugd2Ugc2hvdWxkIHJldHVybiBzb21ldGhpbmcgYW55d2F5LlxuICBpZiAocG9zIDwgMCkgeyByZXR1cm4gbWF4OyB9XG5cbiAgLy8gSWYgd2UgY2FtZSB0byBzdGFydCBvZiBidWZmZXIgLSB0aGF0IG1lYW5zIHZ1ZmZlciBpcyB0b28gc21hbGwsXG4gIC8vIHJldHVybiBtYXggdG9vLlxuICBpZiAocG9zID09PSAwKSB7IHJldHVybiBtYXg7IH1cblxuICByZXR1cm4gKHBvcyArIF91dGY4bGVuW2J1Zltwb3NdXSA+IG1heCkgPyBwb3MgOiBtYXg7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2pzemlwL34vcGFrby9saWIvdXRpbHMvc3RyaW5ncy5qc1xuLy8gbW9kdWxlIGlkID0gNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){"use strict";eval("\n\n// Note: adler32 takes 12% for level 0 and 2% for level 6.\n// It doesn't worth to make additional optimizationa as in original.\n// Small size is preferable.\n\nfunction adler32(adler, buf, len, pos) {\n  var s1 = (adler & 0xffff) |0,\n      s2 = ((adler >>> 16) & 0xffff) |0,\n      n = 0;\n\n  while (len !== 0) {\n    // Set limit ~ twice less than 5552, to keep\n    // s2 in 31-bits, because we force signed ints.\n    // in other case %= will fail.\n    n = len > 2000 ? 2000 : len;\n    len -= n;\n\n    do {\n      s1 = (s1 + buf[pos++]) |0;\n      s2 = (s2 + s1) |0;\n    } while (--n);\n\n    s1 %= 65521;\n    s2 %= 65521;\n  }\n\n  return (s1 | (s2 << 16)) |0;\n}\n\n\nmodule.exports = adler32;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2pzemlwL34vcGFrby9saWIvemxpYi9hZGxlcjMyLmpzP2RjYTEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQSIsImZpbGUiOiI1MC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLy8gTm90ZTogYWRsZXIzMiB0YWtlcyAxMiUgZm9yIGxldmVsIDAgYW5kIDIlIGZvciBsZXZlbCA2LlxuLy8gSXQgZG9lc24ndCB3b3J0aCB0byBtYWtlIGFkZGl0aW9uYWwgb3B0aW1pemF0aW9uYSBhcyBpbiBvcmlnaW5hbC5cbi8vIFNtYWxsIHNpemUgaXMgcHJlZmVyYWJsZS5cblxuZnVuY3Rpb24gYWRsZXIzMihhZGxlciwgYnVmLCBsZW4sIHBvcykge1xuICB2YXIgczEgPSAoYWRsZXIgJiAweGZmZmYpIHwwLFxuICAgICAgczIgPSAoKGFkbGVyID4+PiAxNikgJiAweGZmZmYpIHwwLFxuICAgICAgbiA9IDA7XG5cbiAgd2hpbGUgKGxlbiAhPT0gMCkge1xuICAgIC8vIFNldCBsaW1pdCB+IHR3aWNlIGxlc3MgdGhhbiA1NTUyLCB0byBrZWVwXG4gICAgLy8gczIgaW4gMzEtYml0cywgYmVjYXVzZSB3ZSBmb3JjZSBzaWduZWQgaW50cy5cbiAgICAvLyBpbiBvdGhlciBjYXNlICU9IHdpbGwgZmFpbC5cbiAgICBuID0gbGVuID4gMjAwMCA/IDIwMDAgOiBsZW47XG4gICAgbGVuIC09IG47XG5cbiAgICBkbyB7XG4gICAgICBzMSA9IChzMSArIGJ1Zltwb3MrK10pIHwwO1xuICAgICAgczIgPSAoczIgKyBzMSkgfDA7XG4gICAgfSB3aGlsZSAoLS1uKTtcblxuICAgIHMxICU9IDY1NTIxO1xuICAgIHMyICU9IDY1NTIxO1xuICB9XG5cbiAgcmV0dXJuIChzMSB8IChzMiA8PCAxNikpIHwwO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gYWRsZXIzMjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9qc3ppcC9+L3Bha28vbGliL3psaWIvYWRsZXIzMi5qc1xuLy8gbW9kdWxlIGlkID0gNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){"use strict";eval("\n\n\nmodule.exports = {\n\n  /* Allowed flush values; see deflate() and inflate() below for details */\n  Z_NO_FLUSH:         0,\n  Z_PARTIAL_FLUSH:    1,\n  Z_SYNC_FLUSH:       2,\n  Z_FULL_FLUSH:       3,\n  Z_FINISH:           4,\n  Z_BLOCK:            5,\n  Z_TREES:            6,\n\n  /* Return codes for the compression/decompression functions. Negative values\n  * are errors, positive values are used for special but normal events.\n  */\n  Z_OK:               0,\n  Z_STREAM_END:       1,\n  Z_NEED_DICT:        2,\n  Z_ERRNO:           -1,\n  Z_STREAM_ERROR:    -2,\n  Z_DATA_ERROR:      -3,\n  //Z_MEM_ERROR:     -4,\n  Z_BUF_ERROR:       -5,\n  //Z_VERSION_ERROR: -6,\n\n  /* compression levels */\n  Z_NO_COMPRESSION:         0,\n  Z_BEST_SPEED:             1,\n  Z_BEST_COMPRESSION:       9,\n  Z_DEFAULT_COMPRESSION:   -1,\n\n\n  Z_FILTERED:               1,\n  Z_HUFFMAN_ONLY:           2,\n  Z_RLE:                    3,\n  Z_FIXED:                  4,\n  Z_DEFAULT_STRATEGY:       0,\n\n  /* Possible values of the data_type field (though see inflate()) */\n  Z_BINARY:                 0,\n  Z_TEXT:                   1,\n  //Z_ASCII:                1, // = Z_TEXT (deprecated)\n  Z_UNKNOWN:                2,\n\n  /* The deflate compression method */\n  Z_DEFLATED:               8\n  //Z_NULL:                 null // Use -1 or null inline, depending on var type\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2pzemlwL34vcGFrby9saWIvemxpYi9jb25zdGFudHMuanM/Y2FhOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7O0FBR0E7O0FBRUEsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNTEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgLyogQWxsb3dlZCBmbHVzaCB2YWx1ZXM7IHNlZSBkZWZsYXRlKCkgYW5kIGluZmxhdGUoKSBiZWxvdyBmb3IgZGV0YWlscyAqL1xuICBaX05PX0ZMVVNIOiAgICAgICAgIDAsXG4gIFpfUEFSVElBTF9GTFVTSDogICAgMSxcbiAgWl9TWU5DX0ZMVVNIOiAgICAgICAyLFxuICBaX0ZVTExfRkxVU0g6ICAgICAgIDMsXG4gIFpfRklOSVNIOiAgICAgICAgICAgNCxcbiAgWl9CTE9DSzogICAgICAgICAgICA1LFxuICBaX1RSRUVTOiAgICAgICAgICAgIDYsXG5cbiAgLyogUmV0dXJuIGNvZGVzIGZvciB0aGUgY29tcHJlc3Npb24vZGVjb21wcmVzc2lvbiBmdW5jdGlvbnMuIE5lZ2F0aXZlIHZhbHVlc1xuICAqIGFyZSBlcnJvcnMsIHBvc2l0aXZlIHZhbHVlcyBhcmUgdXNlZCBmb3Igc3BlY2lhbCBidXQgbm9ybWFsIGV2ZW50cy5cbiAgKi9cbiAgWl9PSzogICAgICAgICAgICAgICAwLFxuICBaX1NUUkVBTV9FTkQ6ICAgICAgIDEsXG4gIFpfTkVFRF9ESUNUOiAgICAgICAgMixcbiAgWl9FUlJOTzogICAgICAgICAgIC0xLFxuICBaX1NUUkVBTV9FUlJPUjogICAgLTIsXG4gIFpfREFUQV9FUlJPUjogICAgICAtMyxcbiAgLy9aX01FTV9FUlJPUjogICAgIC00LFxuICBaX0JVRl9FUlJPUjogICAgICAgLTUsXG4gIC8vWl9WRVJTSU9OX0VSUk9SOiAtNixcblxuICAvKiBjb21wcmVzc2lvbiBsZXZlbHMgKi9cbiAgWl9OT19DT01QUkVTU0lPTjogICAgICAgICAwLFxuICBaX0JFU1RfU1BFRUQ6ICAgICAgICAgICAgIDEsXG4gIFpfQkVTVF9DT01QUkVTU0lPTjogICAgICAgOSxcbiAgWl9ERUZBVUxUX0NPTVBSRVNTSU9OOiAgIC0xLFxuXG5cbiAgWl9GSUxURVJFRDogICAgICAgICAgICAgICAxLFxuICBaX0hVRkZNQU5fT05MWTogICAgICAgICAgIDIsXG4gIFpfUkxFOiAgICAgICAgICAgICAgICAgICAgMyxcbiAgWl9GSVhFRDogICAgICAgICAgICAgICAgICA0LFxuICBaX0RFRkFVTFRfU1RSQVRFR1k6ICAgICAgIDAsXG5cbiAgLyogUG9zc2libGUgdmFsdWVzIG9mIHRoZSBkYXRhX3R5cGUgZmllbGQgKHRob3VnaCBzZWUgaW5mbGF0ZSgpKSAqL1xuICBaX0JJTkFSWTogICAgICAgICAgICAgICAgIDAsXG4gIFpfVEVYVDogICAgICAgICAgICAgICAgICAgMSxcbiAgLy9aX0FTQ0lJOiAgICAgICAgICAgICAgICAxLCAvLyA9IFpfVEVYVCAoZGVwcmVjYXRlZClcbiAgWl9VTktOT1dOOiAgICAgICAgICAgICAgICAyLFxuXG4gIC8qIFRoZSBkZWZsYXRlIGNvbXByZXNzaW9uIG1ldGhvZCAqL1xuICBaX0RFRkxBVEVEOiAgICAgICAgICAgICAgIDhcbiAgLy9aX05VTEw6ICAgICAgICAgICAgICAgICBudWxsIC8vIFVzZSAtMSBvciBudWxsIGlubGluZSwgZGVwZW5kaW5nIG9uIHZhciB0eXBlXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2pzemlwL34vcGFrby9saWIvemxpYi9jb25zdGFudHMuanNcbi8vIG1vZHVsZSBpZCA9IDUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){"use strict";eval("\n\n// Note: we can't get significant speed boost here.\n// So write code to minimize size - no pregenerated tables\n// and array tools dependencies.\n\n\n// Use ordinary array, since untyped makes no boost here\nfunction makeTable() {\n  var c, table = [];\n\n  for (var n = 0; n < 256; n++) {\n    c = n;\n    for (var k = 0; k < 8; k++) {\n      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));\n    }\n    table[n] = c;\n  }\n\n  return table;\n}\n\n// Create table on load. Just 255 signed longs. Not a problem.\nvar crcTable = makeTable();\n\n\nfunction crc32(crc, buf, len, pos) {\n  var t = crcTable,\n      end = pos + len;\n\n  crc ^= -1;\n\n  for (var i = pos; i < end; i++) {\n    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];\n  }\n\n  return (crc ^ (-1)); // >>> 0;\n}\n\n\nmodule.exports = crc32;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2pzemlwL34vcGFrby9saWIvemxpYi9jcmMzMi5qcz9mZWUwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTs7QUFFQSxzQkFBc0I7QUFDdEI7OztBQUdBIiwiZmlsZSI6IjUyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vLyBOb3RlOiB3ZSBjYW4ndCBnZXQgc2lnbmlmaWNhbnQgc3BlZWQgYm9vc3QgaGVyZS5cbi8vIFNvIHdyaXRlIGNvZGUgdG8gbWluaW1pemUgc2l6ZSAtIG5vIHByZWdlbmVyYXRlZCB0YWJsZXNcbi8vIGFuZCBhcnJheSB0b29scyBkZXBlbmRlbmNpZXMuXG5cblxuLy8gVXNlIG9yZGluYXJ5IGFycmF5LCBzaW5jZSB1bnR5cGVkIG1ha2VzIG5vIGJvb3N0IGhlcmVcbmZ1bmN0aW9uIG1ha2VUYWJsZSgpIHtcbiAgdmFyIGMsIHRhYmxlID0gW107XG5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCAyNTY7IG4rKykge1xuICAgIGMgPSBuO1xuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgODsgaysrKSB7XG4gICAgICBjID0gKChjICYgMSkgPyAoMHhFREI4ODMyMCBeIChjID4+PiAxKSkgOiAoYyA+Pj4gMSkpO1xuICAgIH1cbiAgICB0YWJsZVtuXSA9IGM7XG4gIH1cblxuICByZXR1cm4gdGFibGU7XG59XG5cbi8vIENyZWF0ZSB0YWJsZSBvbiBsb2FkLiBKdXN0IDI1NSBzaWduZWQgbG9uZ3MuIE5vdCBhIHByb2JsZW0uXG52YXIgY3JjVGFibGUgPSBtYWtlVGFibGUoKTtcblxuXG5mdW5jdGlvbiBjcmMzMihjcmMsIGJ1ZiwgbGVuLCBwb3MpIHtcbiAgdmFyIHQgPSBjcmNUYWJsZSxcbiAgICAgIGVuZCA9IHBvcyArIGxlbjtcblxuICBjcmMgXj0gLTE7XG5cbiAgZm9yICh2YXIgaSA9IHBvczsgaSA8IGVuZDsgaSsrKSB7XG4gICAgY3JjID0gKGNyYyA+Pj4gOCkgXiB0WyhjcmMgXiBidWZbaV0pICYgMHhGRl07XG4gIH1cblxuICByZXR1cm4gKGNyYyBeICgtMSkpOyAvLyA+Pj4gMDtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyYzMyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2pzemlwL34vcGFrby9saWIvemxpYi9jcmMzMi5qc1xuLy8gbW9kdWxlIGlkID0gNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){"use strict";eval("\n\n\nfunction ZStream() {\n  /* next input byte */\n  this.input = null; // JS specific, because we have no pointers\n  this.next_in = 0;\n  /* number of bytes available at input */\n  this.avail_in = 0;\n  /* total number of input bytes read so far */\n  this.total_in = 0;\n  /* next output byte should be put there */\n  this.output = null; // JS specific, because we have no pointers\n  this.next_out = 0;\n  /* remaining free space at output */\n  this.avail_out = 0;\n  /* total number of bytes output so far */\n  this.total_out = 0;\n  /* last error message, NULL if no error */\n  this.msg = ''/*Z_NULL*/;\n  /* not visible by applications */\n  this.state = null;\n  /* best guess about the data type: binary or text */\n  this.data_type = 2/*Z_UNKNOWN*/;\n  /* adler32 value of the uncompressed data */\n  this.adler = 0;\n}\n\nmodule.exports = ZStream;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2pzemlwL34vcGFrby9saWIvemxpYi96c3RyZWFtLmpzPzJiNDciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztBQUdBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiNTMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cblxuZnVuY3Rpb24gWlN0cmVhbSgpIHtcbiAgLyogbmV4dCBpbnB1dCBieXRlICovXG4gIHRoaXMuaW5wdXQgPSBudWxsOyAvLyBKUyBzcGVjaWZpYywgYmVjYXVzZSB3ZSBoYXZlIG5vIHBvaW50ZXJzXG4gIHRoaXMubmV4dF9pbiA9IDA7XG4gIC8qIG51bWJlciBvZiBieXRlcyBhdmFpbGFibGUgYXQgaW5wdXQgKi9cbiAgdGhpcy5hdmFpbF9pbiA9IDA7XG4gIC8qIHRvdGFsIG51bWJlciBvZiBpbnB1dCBieXRlcyByZWFkIHNvIGZhciAqL1xuICB0aGlzLnRvdGFsX2luID0gMDtcbiAgLyogbmV4dCBvdXRwdXQgYnl0ZSBzaG91bGQgYmUgcHV0IHRoZXJlICovXG4gIHRoaXMub3V0cHV0ID0gbnVsbDsgLy8gSlMgc3BlY2lmaWMsIGJlY2F1c2Ugd2UgaGF2ZSBubyBwb2ludGVyc1xuICB0aGlzLm5leHRfb3V0ID0gMDtcbiAgLyogcmVtYWluaW5nIGZyZWUgc3BhY2UgYXQgb3V0cHV0ICovXG4gIHRoaXMuYXZhaWxfb3V0ID0gMDtcbiAgLyogdG90YWwgbnVtYmVyIG9mIGJ5dGVzIG91dHB1dCBzbyBmYXIgKi9cbiAgdGhpcy50b3RhbF9vdXQgPSAwO1xuICAvKiBsYXN0IGVycm9yIG1lc3NhZ2UsIE5VTEwgaWYgbm8gZXJyb3IgKi9cbiAgdGhpcy5tc2cgPSAnJy8qWl9OVUxMKi87XG4gIC8qIG5vdCB2aXNpYmxlIGJ5IGFwcGxpY2F0aW9ucyAqL1xuICB0aGlzLnN0YXRlID0gbnVsbDtcbiAgLyogYmVzdCBndWVzcyBhYm91dCB0aGUgZGF0YSB0eXBlOiBiaW5hcnkgb3IgdGV4dCAqL1xuICB0aGlzLmRhdGFfdHlwZSA9IDIvKlpfVU5LTk9XTiovO1xuICAvKiBhZGxlcjMyIHZhbHVlIG9mIHRoZSB1bmNvbXByZXNzZWQgZGF0YSAqL1xuICB0aGlzLmFkbGVyID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBaU3RyZWFtO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2pzemlwL34vcGFrby9saWIvemxpYi96c3RyZWFtLmpzXG4vLyBtb2R1bGUgaWQgPSA1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("module.exports = exports = __webpack_require__(10);\n\nexports.resolve = __webpack_require__(31);\nexports.reject = __webpack_require__(30);\nexports.all = __webpack_require__(115);\nexports.race = __webpack_require__(117);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2xpZS9saWIvaW5kZXguanM/ZWI3NSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI1NC5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IHJlcXVpcmUoJy4vcHJvbWlzZScpO1xuXG5leHBvcnRzLnJlc29sdmUgPSByZXF1aXJlKCcuL3Jlc29sdmUnKTtcbmV4cG9ydHMucmVqZWN0ID0gcmVxdWlyZSgnLi9yZWplY3QnKTtcbmV4cG9ydHMuYWxsID0gcmVxdWlyZSgnLi9hbGwnKTtcbmV4cG9ydHMucmFjZSA9IHJlcXVpcmUoJy4vcmFjZScpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xpZS9saWIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){"use strict";eval("\nvar handlers = __webpack_require__(4);\nvar tryCatch = __webpack_require__(57);\nfunction safelyResolveThenable(self, thenable) {\n  // Either fulfill, reject or reject with error\n  var called = false;\n  function onError(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.reject(self, value);\n  }\n\n  function onSuccess(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.resolve(self, value);\n  }\n\n  function tryToUnwrap() {\n    thenable(onSuccess, onError);\n  }\n  \n  var result = tryCatch(tryToUnwrap);\n  if (result.status === 'error') {\n    onError(result.value);\n  }\n}\nexports.safely = safelyResolveThenable;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2xpZS9saWIvcmVzb2x2ZVRoZW5hYmxlLmpzPzRjOGEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI1NS5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciBoYW5kbGVycyA9IHJlcXVpcmUoJy4vaGFuZGxlcnMnKTtcbnZhciB0cnlDYXRjaCA9IHJlcXVpcmUoJy4vdHJ5Q2F0Y2gnKTtcbmZ1bmN0aW9uIHNhZmVseVJlc29sdmVUaGVuYWJsZShzZWxmLCB0aGVuYWJsZSkge1xuICAvLyBFaXRoZXIgZnVsZmlsbCwgcmVqZWN0IG9yIHJlamVjdCB3aXRoIGVycm9yXG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gb25FcnJvcih2YWx1ZSkge1xuICAgIGlmIChjYWxsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGVkID0gdHJ1ZTtcbiAgICBoYW5kbGVycy5yZWplY3Qoc2VsZiwgdmFsdWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25TdWNjZXNzKHZhbHVlKSB7XG4gICAgaWYgKGNhbGxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsZWQgPSB0cnVlO1xuICAgIGhhbmRsZXJzLnJlc29sdmUoc2VsZiwgdmFsdWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJ5VG9VbndyYXAoKSB7XG4gICAgdGhlbmFibGUob25TdWNjZXNzLCBvbkVycm9yKTtcbiAgfVxuICBcbiAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoKHRyeVRvVW53cmFwKTtcbiAgaWYgKHJlc3VsdC5zdGF0dXMgPT09ICdlcnJvcicpIHtcbiAgICBvbkVycm9yKHJlc3VsdC52YWx1ZSk7XG4gIH1cbn1cbmV4cG9ydHMuc2FmZWx5ID0gc2FmZWx5UmVzb2x2ZVRoZW5hYmxlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9saWUvbGliL3Jlc29sdmVUaGVuYWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports){eval("// Lazy man's symbols for states\n\nexports.REJECTED = ['REJECTED'];\nexports.FULFILLED = ['FULFILLED'];\nexports.PENDING = ['PENDING'];\n\n/* istanbul ignore else */\nif (!process.browser) {\n  exports.UNHANDLED = ['UNHANDLED'];\n  exports.HANDLED = ['HANDLED'];\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2xpZS9saWIvc3RhdGVzLmpzPzM1NGMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNTYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBMYXp5IG1hbidzIHN5bWJvbHMgZm9yIHN0YXRlc1xuXG5leHBvcnRzLlJFSkVDVEVEID0gWydSRUpFQ1RFRCddO1xuZXhwb3J0cy5GVUxGSUxMRUQgPSBbJ0ZVTEZJTExFRCddO1xuZXhwb3J0cy5QRU5ESU5HID0gWydQRU5ESU5HJ107XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG5pZiAoIXByb2Nlc3MuYnJvd3Nlcikge1xuICBleHBvcnRzLlVOSEFORExFRCA9IFsnVU5IQU5ETEVEJ107XG4gIGV4cG9ydHMuSEFORExFRCA9IFsnSEFORExFRCddO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xpZS9saWIvc3RhdGVzLmpzXG4vLyBtb2R1bGUgaWQgPSA1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = tryCatch;\n\nfunction tryCatch(func, value) {\n  var out = {};\n  try {\n    out.value = func(value);\n    out.status = 'success';\n  } catch (e) {\n    out.status = 'error';\n    out.value = e;\n  }\n  return out;\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2xpZS9saWIvdHJ5Q2F0Y2guanM/NGM5NiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNTcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gdHJ5Q2F0Y2g7XG5cbmZ1bmN0aW9uIHRyeUNhdGNoKGZ1bmMsIHZhbHVlKSB7XG4gIHZhciBvdXQgPSB7fTtcbiAgdHJ5IHtcbiAgICBvdXQudmFsdWUgPSBmdW5jKHZhbHVlKTtcbiAgICBvdXQuc3RhdHVzID0gJ3N1Y2Nlc3MnO1xuICB9IGNhdGNoIChlKSB7XG4gICAgb3V0LnN0YXR1cyA9ICdlcnJvcic7XG4gICAgb3V0LnZhbHVlID0gZTtcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9saWUvbGliL3RyeUNhdGNoLmpzXG4vLyBtb2R1bGUgaWQgPSA1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar immediate = __webpack_require__(40);\nvar handlers = __webpack_require__(4);\nmodule.exports = unwrap;\n\nfunction unwrap(promise, func, value) {\n  immediate(function () {\n    var returnValue;\n    try {\n      returnValue = func(value);\n    } catch (e) {\n      return handlers.reject(promise, e);\n    }\n    if (returnValue === promise) {\n      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));\n    } else {\n      handlers.resolve(promise, returnValue);\n    }\n  });\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2xpZS9saWIvdW53cmFwLmpzPzY4MmUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSCIsImZpbGUiOiI1OC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGltbWVkaWF0ZSA9IHJlcXVpcmUoJ2ltbWVkaWF0ZScpO1xudmFyIGhhbmRsZXJzID0gcmVxdWlyZSgnLi9oYW5kbGVycycpO1xubW9kdWxlLmV4cG9ydHMgPSB1bndyYXA7XG5cbmZ1bmN0aW9uIHVud3JhcChwcm9taXNlLCBmdW5jLCB2YWx1ZSkge1xuICBpbW1lZGlhdGUoZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXR1cm5WYWx1ZTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuVmFsdWUgPSBmdW5jKHZhbHVlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gaGFuZGxlcnMucmVqZWN0KHByb21pc2UsIGUpO1xuICAgIH1cbiAgICBpZiAocmV0dXJuVmFsdWUgPT09IHByb21pc2UpIHtcbiAgICAgIGhhbmRsZXJzLnJlamVjdChwcm9taXNlLCBuZXcgVHlwZUVycm9yKCdDYW5ub3QgcmVzb2x2ZSBwcm9taXNlIHdpdGggaXRzZWxmJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoYW5kbGVycy5yZXNvbHZlKHByb21pc2UsIHJldHVyblZhbHVlKTtcbiAgICB9XG4gIH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9saWUvbGliL3Vud3JhcC5qc1xuLy8gbW9kdWxlIGlkID0gNThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports){eval("\n\n\n/**\n * UTM zones are grouped, and assigned to one of a group of 6\n * sets.\n *\n * {int} @private\n */\nvar NUM_100K_SETS = 6;\n\n/**\n * The column letters (for easting) of the lower left value, per\n * set.\n *\n * {string} @private\n */\nvar SET_ORIGIN_COLUMN_LETTERS = 'AJSAJS';\n\n/**\n * The row letters (for northing) of the lower left value, per\n * set.\n *\n * {string} @private\n */\nvar SET_ORIGIN_ROW_LETTERS = 'AFAFAF';\n\nvar A = 65; // A\nvar I = 73; // I\nvar O = 79; // O\nvar V = 86; // V\nvar Z = 90; // Z\n\n/**\n * Conversion of lat/lon to MGRS.\n *\n * @param {object} ll Object literal with lat and lon properties on a\n *     WGS84 ellipsoid.\n * @param {int} accuracy Accuracy in digits (5 for 1 m, 4 for 10 m, 3 for\n *      100 m, 2 for 1000 m or 1 for 10000 m). Optional, default is 5.\n * @return {string} the MGRS string for the given location and accuracy.\n */\nexports.forward = function(ll, accuracy) {\n  accuracy = accuracy || 5; // default accuracy 1m\n  return encode(LLtoUTM({\n    lat: ll[1],\n    lon: ll[0]\n  }), accuracy);\n};\n\n/**\n * Conversion of MGRS to lat/lon.\n *\n * @param {string} mgrs MGRS string.\n * @return {array} An array with left (longitude), bottom (latitude), right\n *     (longitude) and top (latitude) values in WGS84, representing the\n *     bounding box for the provided MGRS reference.\n */\nexports.inverse = function(mgrs) {\n  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));\n  if (bbox.lat && bbox.lon) {\n    return [bbox.lon, bbox.lat, bbox.lon, bbox.lat];\n  }\n  return [bbox.left, bbox.bottom, bbox.right, bbox.top];\n};\n\nexports.toPoint = function(mgrs) {\n  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));\n  if (bbox.lat && bbox.lon) {\n    return [bbox.lon, bbox.lat];\n  }\n  return [(bbox.left + bbox.right) / 2, (bbox.top + bbox.bottom) / 2];\n};\n/**\n * Conversion from degrees to radians.\n *\n * @private\n * @param {number} deg the angle in degrees.\n * @return {number} the angle in radians.\n */\nfunction degToRad(deg) {\n  return (deg * (Math.PI / 180.0));\n}\n\n/**\n * Conversion from radians to degrees.\n *\n * @private\n * @param {number} rad the angle in radians.\n * @return {number} the angle in degrees.\n */\nfunction radToDeg(rad) {\n  return (180.0 * (rad / Math.PI));\n}\n\n/**\n * Converts a set of Longitude and Latitude co-ordinates to UTM\n * using the WGS84 ellipsoid.\n *\n * @private\n * @param {object} ll Object literal with lat and lon properties\n *     representing the WGS84 coordinate to be converted.\n * @return {object} Object literal containing the UTM value with easting,\n *     northing, zoneNumber and zoneLetter properties, and an optional\n *     accuracy property in digits. Returns null if the conversion failed.\n */\nfunction LLtoUTM(ll) {\n  var Lat = ll.lat;\n  var Long = ll.lon;\n  var a = 6378137.0; //ellip.radius;\n  var eccSquared = 0.00669438; //ellip.eccsq;\n  var k0 = 0.9996;\n  var LongOrigin;\n  var eccPrimeSquared;\n  var N, T, C, A, M;\n  var LatRad = degToRad(Lat);\n  var LongRad = degToRad(Long);\n  var LongOriginRad;\n  var ZoneNumber;\n  // (int)\n  ZoneNumber = Math.floor((Long + 180) / 6) + 1;\n\n  //Make sure the longitude 180.00 is in Zone 60\n  if (Long === 180) {\n    ZoneNumber = 60;\n  }\n\n  // Special zone for Norway\n  if (Lat >= 56.0 && Lat < 64.0 && Long >= 3.0 && Long < 12.0) {\n    ZoneNumber = 32;\n  }\n\n  // Special zones for Svalbard\n  if (Lat >= 72.0 && Lat < 84.0) {\n    if (Long >= 0.0 && Long < 9.0) {\n      ZoneNumber = 31;\n    }\n    else if (Long >= 9.0 && Long < 21.0) {\n      ZoneNumber = 33;\n    }\n    else if (Long >= 21.0 && Long < 33.0) {\n      ZoneNumber = 35;\n    }\n    else if (Long >= 33.0 && Long < 42.0) {\n      ZoneNumber = 37;\n    }\n  }\n\n  LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3; //+3 puts origin\n  // in middle of\n  // zone\n  LongOriginRad = degToRad(LongOrigin);\n\n  eccPrimeSquared = (eccSquared) / (1 - eccSquared);\n\n  N = a / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));\n  T = Math.tan(LatRad) * Math.tan(LatRad);\n  C = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);\n  A = Math.cos(LatRad) * (LongRad - LongOriginRad);\n\n  M = a * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - (35 * eccSquared * eccSquared * eccSquared / 3072) * Math.sin(6 * LatRad));\n\n  var UTMEasting = (k0 * N * (A + (1 - T + C) * A * A * A / 6.0 + (5 - 18 * T + T * T + 72 * C - 58 * eccPrimeSquared) * A * A * A * A * A / 120.0) + 500000.0);\n\n  var UTMNorthing = (k0 * (M + N * Math.tan(LatRad) * (A * A / 2 + (5 - T + 9 * C + 4 * C * C) * A * A * A * A / 24.0 + (61 - 58 * T + T * T + 600 * C - 330 * eccPrimeSquared) * A * A * A * A * A * A / 720.0)));\n  if (Lat < 0.0) {\n    UTMNorthing += 10000000.0; //10000000 meter offset for\n    // southern hemisphere\n  }\n\n  return {\n    northing: Math.round(UTMNorthing),\n    easting: Math.round(UTMEasting),\n    zoneNumber: ZoneNumber,\n    zoneLetter: getLetterDesignator(Lat)\n  };\n}\n\n/**\n * Converts UTM coords to lat/long, using the WGS84 ellipsoid. This is a convenience\n * class where the Zone can be specified as a single string eg.\"60N\" which\n * is then broken down into the ZoneNumber and ZoneLetter.\n *\n * @private\n * @param {object} utm An object literal with northing, easting, zoneNumber\n *     and zoneLetter properties. If an optional accuracy property is\n *     provided (in meters), a bounding box will be returned instead of\n *     latitude and longitude.\n * @return {object} An object literal containing either lat and lon values\n *     (if no accuracy was provided), or top, right, bottom and left values\n *     for the bounding box calculated according to the provided accuracy.\n *     Returns null if the conversion failed.\n */\nfunction UTMtoLL(utm) {\n\n  var UTMNorthing = utm.northing;\n  var UTMEasting = utm.easting;\n  var zoneLetter = utm.zoneLetter;\n  var zoneNumber = utm.zoneNumber;\n  // check the ZoneNummber is valid\n  if (zoneNumber < 0 || zoneNumber > 60) {\n    return null;\n  }\n\n  var k0 = 0.9996;\n  var a = 6378137.0; //ellip.radius;\n  var eccSquared = 0.00669438; //ellip.eccsq;\n  var eccPrimeSquared;\n  var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));\n  var N1, T1, C1, R1, D, M;\n  var LongOrigin;\n  var mu, phi1Rad;\n\n  // remove 500,000 meter offset for longitude\n  var x = UTMEasting - 500000.0;\n  var y = UTMNorthing;\n\n  // We must know somehow if we are in the Northern or Southern\n  // hemisphere, this is the only time we use the letter So even\n  // if the Zone letter isn't exactly correct it should indicate\n  // the hemisphere correctly\n  if (zoneLetter < 'N') {\n    y -= 10000000.0; // remove 10,000,000 meter offset used\n    // for southern hemisphere\n  }\n\n  // There are 60 zones with zone 1 being at West -180 to -174\n  LongOrigin = (zoneNumber - 1) * 6 - 180 + 3; // +3 puts origin\n  // in middle of\n  // zone\n\n  eccPrimeSquared = (eccSquared) / (1 - eccSquared);\n\n  M = y / k0;\n  mu = M / (a * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256));\n\n  phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + (151 * e1 * e1 * e1 / 96) * Math.sin(6 * mu);\n  // double phi1 = ProjMath.radToDeg(phi1Rad);\n\n  N1 = a / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));\n  T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);\n  C1 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);\n  R1 = a * (1 - eccSquared) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);\n  D = x / (N1 * k0);\n\n  var lat = phi1Rad - (N1 * Math.tan(phi1Rad) / R1) * (D * D / 2 - (5 + 3 * T1 + 10 * C1 - 4 * C1 * C1 - 9 * eccPrimeSquared) * D * D * D * D / 24 + (61 + 90 * T1 + 298 * C1 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C1 * C1) * D * D * D * D * D * D / 720);\n  lat = radToDeg(lat);\n\n  var lon = (D - (1 + 2 * T1 + C1) * D * D * D / 6 + (5 - 2 * C1 + 28 * T1 - 3 * C1 * C1 + 8 * eccPrimeSquared + 24 * T1 * T1) * D * D * D * D * D / 120) / Math.cos(phi1Rad);\n  lon = LongOrigin + radToDeg(lon);\n\n  var result;\n  if (utm.accuracy) {\n    var topRight = UTMtoLL({\n      northing: utm.northing + utm.accuracy,\n      easting: utm.easting + utm.accuracy,\n      zoneLetter: utm.zoneLetter,\n      zoneNumber: utm.zoneNumber\n    });\n    result = {\n      top: topRight.lat,\n      right: topRight.lon,\n      bottom: lat,\n      left: lon\n    };\n  }\n  else {\n    result = {\n      lat: lat,\n      lon: lon\n    };\n  }\n  return result;\n}\n\n/**\n * Calculates the MGRS letter designator for the given latitude.\n *\n * @private\n * @param {number} lat The latitude in WGS84 to get the letter designator\n *     for.\n * @return {char} The letter designator.\n */\nfunction getLetterDesignator(lat) {\n  //This is here as an error flag to show that the Latitude is\n  //outside MGRS limits\n  var LetterDesignator = 'Z';\n\n  if ((84 >= lat) && (lat >= 72)) {\n    LetterDesignator = 'X';\n  }\n  else if ((72 > lat) && (lat >= 64)) {\n    LetterDesignator = 'W';\n  }\n  else if ((64 > lat) && (lat >= 56)) {\n    LetterDesignator = 'V';\n  }\n  else if ((56 > lat) && (lat >= 48)) {\n    LetterDesignator = 'U';\n  }\n  else if ((48 > lat) && (lat >= 40)) {\n    LetterDesignator = 'T';\n  }\n  else if ((40 > lat) && (lat >= 32)) {\n    LetterDesignator = 'S';\n  }\n  else if ((32 > lat) && (lat >= 24)) {\n    LetterDesignator = 'R';\n  }\n  else if ((24 > lat) && (lat >= 16)) {\n    LetterDesignator = 'Q';\n  }\n  else if ((16 > lat) && (lat >= 8)) {\n    LetterDesignator = 'P';\n  }\n  else if ((8 > lat) && (lat >= 0)) {\n    LetterDesignator = 'N';\n  }\n  else if ((0 > lat) && (lat >= -8)) {\n    LetterDesignator = 'M';\n  }\n  else if ((-8 > lat) && (lat >= -16)) {\n    LetterDesignator = 'L';\n  }\n  else if ((-16 > lat) && (lat >= -24)) {\n    LetterDesignator = 'K';\n  }\n  else if ((-24 > lat) && (lat >= -32)) {\n    LetterDesignator = 'J';\n  }\n  else if ((-32 > lat) && (lat >= -40)) {\n    LetterDesignator = 'H';\n  }\n  else if ((-40 > lat) && (lat >= -48)) {\n    LetterDesignator = 'G';\n  }\n  else if ((-48 > lat) && (lat >= -56)) {\n    LetterDesignator = 'F';\n  }\n  else if ((-56 > lat) && (lat >= -64)) {\n    LetterDesignator = 'E';\n  }\n  else if ((-64 > lat) && (lat >= -72)) {\n    LetterDesignator = 'D';\n  }\n  else if ((-72 > lat) && (lat >= -80)) {\n    LetterDesignator = 'C';\n  }\n  return LetterDesignator;\n}\n\n/**\n * Encodes a UTM location as MGRS string.\n *\n * @private\n * @param {object} utm An object literal with easting, northing,\n *     zoneLetter, zoneNumber\n * @param {number} accuracy Accuracy in digits (1-5).\n * @return {string} MGRS string for the given UTM location.\n */\nfunction encode(utm, accuracy) {\n  // prepend with leading zeroes\n  var seasting = \"00000\" + utm.easting,\n    snorthing = \"00000\" + utm.northing;\n\n  return utm.zoneNumber + utm.zoneLetter + get100kID(utm.easting, utm.northing, utm.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);\n}\n\n/**\n * Get the two letter 100k designator for a given UTM easting,\n * northing and zone number value.\n *\n * @private\n * @param {number} easting\n * @param {number} northing\n * @param {number} zoneNumber\n * @return the two letter 100k designator for the given UTM location.\n */\nfunction get100kID(easting, northing, zoneNumber) {\n  var setParm = get100kSetForZone(zoneNumber);\n  var setColumn = Math.floor(easting / 100000);\n  var setRow = Math.floor(northing / 100000) % 20;\n  return getLetter100kID(setColumn, setRow, setParm);\n}\n\n/**\n * Given a UTM zone number, figure out the MGRS 100K set it is in.\n *\n * @private\n * @param {number} i An UTM zone number.\n * @return {number} the 100k set the UTM zone is in.\n */\nfunction get100kSetForZone(i) {\n  var setParm = i % NUM_100K_SETS;\n  if (setParm === 0) {\n    setParm = NUM_100K_SETS;\n  }\n\n  return setParm;\n}\n\n/**\n * Get the two-letter MGRS 100k designator given information\n * translated from the UTM northing, easting and zone number.\n *\n * @private\n * @param {number} column the column index as it relates to the MGRS\n *        100k set spreadsheet, created from the UTM easting.\n *        Values are 1-8.\n * @param {number} row the row index as it relates to the MGRS 100k set\n *        spreadsheet, created from the UTM northing value. Values\n *        are from 0-19.\n * @param {number} parm the set block, as it relates to the MGRS 100k set\n *        spreadsheet, created from the UTM zone. Values are from\n *        1-60.\n * @return two letter MGRS 100k code.\n */\nfunction getLetter100kID(column, row, parm) {\n  // colOrigin and rowOrigin are the letters at the origin of the set\n  var index = parm - 1;\n  var colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index);\n  var rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index);\n\n  // colInt and rowInt are the letters to build to return\n  var colInt = colOrigin + column - 1;\n  var rowInt = rowOrigin + row;\n  var rollover = false;\n\n  if (colInt > Z) {\n    colInt = colInt - Z + A - 1;\n    rollover = true;\n  }\n\n  if (colInt === I || (colOrigin < I && colInt > I) || ((colInt > I || colOrigin < I) && rollover)) {\n    colInt++;\n  }\n\n  if (colInt === O || (colOrigin < O && colInt > O) || ((colInt > O || colOrigin < O) && rollover)) {\n    colInt++;\n\n    if (colInt === I) {\n      colInt++;\n    }\n  }\n\n  if (colInt > Z) {\n    colInt = colInt - Z + A - 1;\n  }\n\n  if (rowInt > V) {\n    rowInt = rowInt - V + A - 1;\n    rollover = true;\n  }\n  else {\n    rollover = false;\n  }\n\n  if (((rowInt === I) || ((rowOrigin < I) && (rowInt > I))) || (((rowInt > I) || (rowOrigin < I)) && rollover)) {\n    rowInt++;\n  }\n\n  if (((rowInt === O) || ((rowOrigin < O) && (rowInt > O))) || (((rowInt > O) || (rowOrigin < O)) && rollover)) {\n    rowInt++;\n\n    if (rowInt === I) {\n      rowInt++;\n    }\n  }\n\n  if (rowInt > V) {\n    rowInt = rowInt - V + A - 1;\n  }\n\n  var twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);\n  return twoLetter;\n}\n\n/**\n * Decode the UTM parameters from a MGRS string.\n *\n * @private\n * @param {string} mgrsString an UPPERCASE coordinate string is expected.\n * @return {object} An object literal with easting, northing, zoneLetter,\n *     zoneNumber and accuracy (in meters) properties.\n */\nfunction decode(mgrsString) {\n\n  if (mgrsString && mgrsString.length === 0) {\n    throw (\"MGRSPoint coverting from nothing\");\n  }\n\n  var length = mgrsString.length;\n\n  var hunK = null;\n  var sb = \"\";\n  var testChar;\n  var i = 0;\n\n  // get Zone number\n  while (!(/[A-Z]/).test(testChar = mgrsString.charAt(i))) {\n    if (i >= 2) {\n      throw (\"MGRSPoint bad conversion from: \" + mgrsString);\n    }\n    sb += testChar;\n    i++;\n  }\n\n  var zoneNumber = parseInt(sb, 10);\n\n  if (i === 0 || i + 3 > length) {\n    // A good MGRS string has to be 4-5 digits long,\n    // ##AAA/#AAA at least.\n    throw (\"MGRSPoint bad conversion from: \" + mgrsString);\n  }\n\n  var zoneLetter = mgrsString.charAt(i++);\n\n  // Should we check the zone letter here? Why not.\n  if (zoneLetter <= 'A' || zoneLetter === 'B' || zoneLetter === 'Y' || zoneLetter >= 'Z' || zoneLetter === 'I' || zoneLetter === 'O') {\n    throw (\"MGRSPoint zone letter \" + zoneLetter + \" not handled: \" + mgrsString);\n  }\n\n  hunK = mgrsString.substring(i, i += 2);\n\n  var set = get100kSetForZone(zoneNumber);\n\n  var east100k = getEastingFromChar(hunK.charAt(0), set);\n  var north100k = getNorthingFromChar(hunK.charAt(1), set);\n\n  // We have a bug where the northing may be 2000000 too low.\n  // How\n  // do we know when to roll over?\n\n  while (north100k < getMinNorthing(zoneLetter)) {\n    north100k += 2000000;\n  }\n\n  // calculate the char index for easting/northing separator\n  var remainder = length - i;\n\n  if (remainder % 2 !== 0) {\n    throw (\"MGRSPoint has to have an even number \\nof digits after the zone letter and two 100km letters - front \\nhalf for easting meters, second half for \\nnorthing meters\" + mgrsString);\n  }\n\n  var sep = remainder / 2;\n\n  var sepEasting = 0.0;\n  var sepNorthing = 0.0;\n  var accuracyBonus, sepEastingString, sepNorthingString, easting, northing;\n  if (sep > 0) {\n    accuracyBonus = 100000.0 / Math.pow(10, sep);\n    sepEastingString = mgrsString.substring(i, i + sep);\n    sepEasting = parseFloat(sepEastingString) * accuracyBonus;\n    sepNorthingString = mgrsString.substring(i + sep);\n    sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;\n  }\n\n  easting = sepEasting + east100k;\n  northing = sepNorthing + north100k;\n\n  return {\n    easting: easting,\n    northing: northing,\n    zoneLetter: zoneLetter,\n    zoneNumber: zoneNumber,\n    accuracy: accuracyBonus\n  };\n}\n\n/**\n * Given the first letter from a two-letter MGRS 100k zone, and given the\n * MGRS table set for the zone number, figure out the easting value that\n * should be added to the other, secondary easting value.\n *\n * @private\n * @param {char} e The first letter from a two-letter MGRS 100k zone.\n * @param {number} set The MGRS table set for the zone number.\n * @return {number} The easting value for the given letter and set.\n */\nfunction getEastingFromChar(e, set) {\n  // colOrigin is the letter at the origin of the set for the\n  // column\n  var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set - 1);\n  var eastingValue = 100000.0;\n  var rewindMarker = false;\n\n  while (curCol !== e.charCodeAt(0)) {\n    curCol++;\n    if (curCol === I) {\n      curCol++;\n    }\n    if (curCol === O) {\n      curCol++;\n    }\n    if (curCol > Z) {\n      if (rewindMarker) {\n        throw (\"Bad character: \" + e);\n      }\n      curCol = A;\n      rewindMarker = true;\n    }\n    eastingValue += 100000.0;\n  }\n\n  return eastingValue;\n}\n\n/**\n * Given the second letter from a two-letter MGRS 100k zone, and given the\n * MGRS table set for the zone number, figure out the northing value that\n * should be added to the other, secondary northing value. You have to\n * remember that Northings are determined from the equator, and the vertical\n * cycle of letters mean a 2000000 additional northing meters. This happens\n * approx. every 18 degrees of latitude. This method does *NOT* count any\n * additional northings. You have to figure out how many 2000000 meters need\n * to be added for the zone letter of the MGRS coordinate.\n *\n * @private\n * @param {char} n Second letter of the MGRS 100k zone\n * @param {number} set The MGRS table set number, which is dependent on the\n *     UTM zone number.\n * @return {number} The northing value for the given letter and set.\n */\nfunction getNorthingFromChar(n, set) {\n\n  if (n > 'V') {\n    throw (\"MGRSPoint given invalid Northing \" + n);\n  }\n\n  // rowOrigin is the letter at the origin of the set for the\n  // column\n  var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set - 1);\n  var northingValue = 0.0;\n  var rewindMarker = false;\n\n  while (curRow !== n.charCodeAt(0)) {\n    curRow++;\n    if (curRow === I) {\n      curRow++;\n    }\n    if (curRow === O) {\n      curRow++;\n    }\n    // fixing a bug making whole application hang in this loop\n    // when 'n' is a wrong character\n    if (curRow > V) {\n      if (rewindMarker) { // making sure that this loop ends\n        throw (\"Bad character: \" + n);\n      }\n      curRow = A;\n      rewindMarker = true;\n    }\n    northingValue += 100000.0;\n  }\n\n  return northingValue;\n}\n\n/**\n * The function getMinNorthing returns the minimum northing value of a MGRS\n * zone.\n *\n * Ported from Geotrans' c Lattitude_Band_Value structure table.\n *\n * @private\n * @param {char} zoneLetter The MGRS zone to get the min northing for.\n * @return {number}\n */\nfunction getMinNorthing(zoneLetter) {\n  var northing;\n  switch (zoneLetter) {\n  case 'C':\n    northing = 1100000.0;\n    break;\n  case 'D':\n    northing = 2000000.0;\n    break;\n  case 'E':\n    northing = 2800000.0;\n    break;\n  case 'F':\n    northing = 3700000.0;\n    break;\n  case 'G':\n    northing = 4600000.0;\n    break;\n  case 'H':\n    northing = 5500000.0;\n    break;\n  case 'J':\n    northing = 6400000.0;\n    break;\n  case 'K':\n    northing = 7300000.0;\n    break;\n  case 'L':\n    northing = 8200000.0;\n    break;\n  case 'M':\n    northing = 9100000.0;\n    break;\n  case 'N':\n    northing = 0.0;\n    break;\n  case 'P':\n    northing = 800000.0;\n    break;\n  case 'Q':\n    northing = 1700000.0;\n    break;\n  case 'R':\n    northing = 2600000.0;\n    break;\n  case 'S':\n    northing = 3500000.0;\n    break;\n  case 'T':\n    northing = 4400000.0;\n    break;\n  case 'U':\n    northing = 5300000.0;\n    break;\n  case 'V':\n    northing = 6200000.0;\n    break;\n  case 'W':\n    northing = 7000000.0;\n    break;\n  case 'X':\n    northing = 7900000.0;\n    break;\n  default:\n    northing = -1.0;\n  }\n  if (northing >= 0.0) {\n    return northing;\n  }\n  else {\n    throw (\"Invalid zone letter: \" + zoneLetter);\n  }\n\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L21ncnMvbWdycy5qcz80NjdjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksT0FBTztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLE9BQU87QUFDWDtBQUNBOztBQUVBLFdBQVc7QUFDWCxXQUFXO0FBQ1gsV0FBVztBQUNYLFdBQVc7QUFDWCxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLFdBQVcsSUFBSTtBQUNmO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0I7QUFDcEIsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQSxZQUFZLEtBQUs7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEI7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjU5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5cblxuLyoqXG4gKiBVVE0gem9uZXMgYXJlIGdyb3VwZWQsIGFuZCBhc3NpZ25lZCB0byBvbmUgb2YgYSBncm91cCBvZiA2XG4gKiBzZXRzLlxuICpcbiAqIHtpbnR9IEBwcml2YXRlXG4gKi9cbnZhciBOVU1fMTAwS19TRVRTID0gNjtcblxuLyoqXG4gKiBUaGUgY29sdW1uIGxldHRlcnMgKGZvciBlYXN0aW5nKSBvZiB0aGUgbG93ZXIgbGVmdCB2YWx1ZSwgcGVyXG4gKiBzZXQuXG4gKlxuICoge3N0cmluZ30gQHByaXZhdGVcbiAqL1xudmFyIFNFVF9PUklHSU5fQ09MVU1OX0xFVFRFUlMgPSAnQUpTQUpTJztcblxuLyoqXG4gKiBUaGUgcm93IGxldHRlcnMgKGZvciBub3J0aGluZykgb2YgdGhlIGxvd2VyIGxlZnQgdmFsdWUsIHBlclxuICogc2V0LlxuICpcbiAqIHtzdHJpbmd9IEBwcml2YXRlXG4gKi9cbnZhciBTRVRfT1JJR0lOX1JPV19MRVRURVJTID0gJ0FGQUZBRic7XG5cbnZhciBBID0gNjU7IC8vIEFcbnZhciBJID0gNzM7IC8vIElcbnZhciBPID0gNzk7IC8vIE9cbnZhciBWID0gODY7IC8vIFZcbnZhciBaID0gOTA7IC8vIFpcblxuLyoqXG4gKiBDb252ZXJzaW9uIG9mIGxhdC9sb24gdG8gTUdSUy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbGwgT2JqZWN0IGxpdGVyYWwgd2l0aCBsYXQgYW5kIGxvbiBwcm9wZXJ0aWVzIG9uIGFcbiAqICAgICBXR1M4NCBlbGxpcHNvaWQuXG4gKiBAcGFyYW0ge2ludH0gYWNjdXJhY3kgQWNjdXJhY3kgaW4gZGlnaXRzICg1IGZvciAxIG0sIDQgZm9yIDEwIG0sIDMgZm9yXG4gKiAgICAgIDEwMCBtLCAyIGZvciAxMDAwIG0gb3IgMSBmb3IgMTAwMDAgbSkuIE9wdGlvbmFsLCBkZWZhdWx0IGlzIDUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBNR1JTIHN0cmluZyBmb3IgdGhlIGdpdmVuIGxvY2F0aW9uIGFuZCBhY2N1cmFjeS5cbiAqL1xuZXhwb3J0cy5mb3J3YXJkID0gZnVuY3Rpb24obGwsIGFjY3VyYWN5KSB7XG4gIGFjY3VyYWN5ID0gYWNjdXJhY3kgfHwgNTsgLy8gZGVmYXVsdCBhY2N1cmFjeSAxbVxuICByZXR1cm4gZW5jb2RlKExMdG9VVE0oe1xuICAgIGxhdDogbGxbMV0sXG4gICAgbG9uOiBsbFswXVxuICB9KSwgYWNjdXJhY3kpO1xufTtcblxuLyoqXG4gKiBDb252ZXJzaW9uIG9mIE1HUlMgdG8gbGF0L2xvbi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWdycyBNR1JTIHN0cmluZy5cbiAqIEByZXR1cm4ge2FycmF5fSBBbiBhcnJheSB3aXRoIGxlZnQgKGxvbmdpdHVkZSksIGJvdHRvbSAobGF0aXR1ZGUpLCByaWdodFxuICogICAgIChsb25naXR1ZGUpIGFuZCB0b3AgKGxhdGl0dWRlKSB2YWx1ZXMgaW4gV0dTODQsIHJlcHJlc2VudGluZyB0aGVcbiAqICAgICBib3VuZGluZyBib3ggZm9yIHRoZSBwcm92aWRlZCBNR1JTIHJlZmVyZW5jZS5cbiAqL1xuZXhwb3J0cy5pbnZlcnNlID0gZnVuY3Rpb24obWdycykge1xuICB2YXIgYmJveCA9IFVUTXRvTEwoZGVjb2RlKG1ncnMudG9VcHBlckNhc2UoKSkpO1xuICBpZiAoYmJveC5sYXQgJiYgYmJveC5sb24pIHtcbiAgICByZXR1cm4gW2Jib3gubG9uLCBiYm94LmxhdCwgYmJveC5sb24sIGJib3gubGF0XTtcbiAgfVxuICByZXR1cm4gW2Jib3gubGVmdCwgYmJveC5ib3R0b20sIGJib3gucmlnaHQsIGJib3gudG9wXTtcbn07XG5cbmV4cG9ydHMudG9Qb2ludCA9IGZ1bmN0aW9uKG1ncnMpIHtcbiAgdmFyIGJib3ggPSBVVE10b0xMKGRlY29kZShtZ3JzLnRvVXBwZXJDYXNlKCkpKTtcbiAgaWYgKGJib3gubGF0ICYmIGJib3gubG9uKSB7XG4gICAgcmV0dXJuIFtiYm94LmxvbiwgYmJveC5sYXRdO1xuICB9XG4gIHJldHVybiBbKGJib3gubGVmdCArIGJib3gucmlnaHQpIC8gMiwgKGJib3gudG9wICsgYmJveC5ib3R0b20pIC8gMl07XG59O1xuLyoqXG4gKiBDb252ZXJzaW9uIGZyb20gZGVncmVlcyB0byByYWRpYW5zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gZGVnIHRoZSBhbmdsZSBpbiBkZWdyZWVzLlxuICogQHJldHVybiB7bnVtYmVyfSB0aGUgYW5nbGUgaW4gcmFkaWFucy5cbiAqL1xuZnVuY3Rpb24gZGVnVG9SYWQoZGVnKSB7XG4gIHJldHVybiAoZGVnICogKE1hdGguUEkgLyAxODAuMCkpO1xufVxuXG4vKipcbiAqIENvbnZlcnNpb24gZnJvbSByYWRpYW5zIHRvIGRlZ3JlZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWQgdGhlIGFuZ2xlIGluIHJhZGlhbnMuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBhbmdsZSBpbiBkZWdyZWVzLlxuICovXG5mdW5jdGlvbiByYWRUb0RlZyhyYWQpIHtcbiAgcmV0dXJuICgxODAuMCAqIChyYWQgLyBNYXRoLlBJKSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBzZXQgb2YgTG9uZ2l0dWRlIGFuZCBMYXRpdHVkZSBjby1vcmRpbmF0ZXMgdG8gVVRNXG4gKiB1c2luZyB0aGUgV0dTODQgZWxsaXBzb2lkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge29iamVjdH0gbGwgT2JqZWN0IGxpdGVyYWwgd2l0aCBsYXQgYW5kIGxvbiBwcm9wZXJ0aWVzXG4gKiAgICAgcmVwcmVzZW50aW5nIHRoZSBXR1M4NCBjb29yZGluYXRlIHRvIGJlIGNvbnZlcnRlZC5cbiAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IGxpdGVyYWwgY29udGFpbmluZyB0aGUgVVRNIHZhbHVlIHdpdGggZWFzdGluZyxcbiAqICAgICBub3J0aGluZywgem9uZU51bWJlciBhbmQgem9uZUxldHRlciBwcm9wZXJ0aWVzLCBhbmQgYW4gb3B0aW9uYWxcbiAqICAgICBhY2N1cmFjeSBwcm9wZXJ0eSBpbiBkaWdpdHMuIFJldHVybnMgbnVsbCBpZiB0aGUgY29udmVyc2lvbiBmYWlsZWQuXG4gKi9cbmZ1bmN0aW9uIExMdG9VVE0obGwpIHtcbiAgdmFyIExhdCA9IGxsLmxhdDtcbiAgdmFyIExvbmcgPSBsbC5sb247XG4gIHZhciBhID0gNjM3ODEzNy4wOyAvL2VsbGlwLnJhZGl1cztcbiAgdmFyIGVjY1NxdWFyZWQgPSAwLjAwNjY5NDM4OyAvL2VsbGlwLmVjY3NxO1xuICB2YXIgazAgPSAwLjk5OTY7XG4gIHZhciBMb25nT3JpZ2luO1xuICB2YXIgZWNjUHJpbWVTcXVhcmVkO1xuICB2YXIgTiwgVCwgQywgQSwgTTtcbiAgdmFyIExhdFJhZCA9IGRlZ1RvUmFkKExhdCk7XG4gIHZhciBMb25nUmFkID0gZGVnVG9SYWQoTG9uZyk7XG4gIHZhciBMb25nT3JpZ2luUmFkO1xuICB2YXIgWm9uZU51bWJlcjtcbiAgLy8gKGludClcbiAgWm9uZU51bWJlciA9IE1hdGguZmxvb3IoKExvbmcgKyAxODApIC8gNikgKyAxO1xuXG4gIC8vTWFrZSBzdXJlIHRoZSBsb25naXR1ZGUgMTgwLjAwIGlzIGluIFpvbmUgNjBcbiAgaWYgKExvbmcgPT09IDE4MCkge1xuICAgIFpvbmVOdW1iZXIgPSA2MDtcbiAgfVxuXG4gIC8vIFNwZWNpYWwgem9uZSBmb3IgTm9yd2F5XG4gIGlmIChMYXQgPj0gNTYuMCAmJiBMYXQgPCA2NC4wICYmIExvbmcgPj0gMy4wICYmIExvbmcgPCAxMi4wKSB7XG4gICAgWm9uZU51bWJlciA9IDMyO1xuICB9XG5cbiAgLy8gU3BlY2lhbCB6b25lcyBmb3IgU3ZhbGJhcmRcbiAgaWYgKExhdCA+PSA3Mi4wICYmIExhdCA8IDg0LjApIHtcbiAgICBpZiAoTG9uZyA+PSAwLjAgJiYgTG9uZyA8IDkuMCkge1xuICAgICAgWm9uZU51bWJlciA9IDMxO1xuICAgIH1cbiAgICBlbHNlIGlmIChMb25nID49IDkuMCAmJiBMb25nIDwgMjEuMCkge1xuICAgICAgWm9uZU51bWJlciA9IDMzO1xuICAgIH1cbiAgICBlbHNlIGlmIChMb25nID49IDIxLjAgJiYgTG9uZyA8IDMzLjApIHtcbiAgICAgIFpvbmVOdW1iZXIgPSAzNTtcbiAgICB9XG4gICAgZWxzZSBpZiAoTG9uZyA+PSAzMy4wICYmIExvbmcgPCA0Mi4wKSB7XG4gICAgICBab25lTnVtYmVyID0gMzc7XG4gICAgfVxuICB9XG5cbiAgTG9uZ09yaWdpbiA9IChab25lTnVtYmVyIC0gMSkgKiA2IC0gMTgwICsgMzsgLy8rMyBwdXRzIG9yaWdpblxuICAvLyBpbiBtaWRkbGUgb2ZcbiAgLy8gem9uZVxuICBMb25nT3JpZ2luUmFkID0gZGVnVG9SYWQoTG9uZ09yaWdpbik7XG5cbiAgZWNjUHJpbWVTcXVhcmVkID0gKGVjY1NxdWFyZWQpIC8gKDEgLSBlY2NTcXVhcmVkKTtcblxuICBOID0gYSAvIE1hdGguc3FydCgxIC0gZWNjU3F1YXJlZCAqIE1hdGguc2luKExhdFJhZCkgKiBNYXRoLnNpbihMYXRSYWQpKTtcbiAgVCA9IE1hdGgudGFuKExhdFJhZCkgKiBNYXRoLnRhbihMYXRSYWQpO1xuICBDID0gZWNjUHJpbWVTcXVhcmVkICogTWF0aC5jb3MoTGF0UmFkKSAqIE1hdGguY29zKExhdFJhZCk7XG4gIEEgPSBNYXRoLmNvcyhMYXRSYWQpICogKExvbmdSYWQgLSBMb25nT3JpZ2luUmFkKTtcblxuICBNID0gYSAqICgoMSAtIGVjY1NxdWFyZWQgLyA0IC0gMyAqIGVjY1NxdWFyZWQgKiBlY2NTcXVhcmVkIC8gNjQgLSA1ICogZWNjU3F1YXJlZCAqIGVjY1NxdWFyZWQgKiBlY2NTcXVhcmVkIC8gMjU2KSAqIExhdFJhZCAtICgzICogZWNjU3F1YXJlZCAvIDggKyAzICogZWNjU3F1YXJlZCAqIGVjY1NxdWFyZWQgLyAzMiArIDQ1ICogZWNjU3F1YXJlZCAqIGVjY1NxdWFyZWQgKiBlY2NTcXVhcmVkIC8gMTAyNCkgKiBNYXRoLnNpbigyICogTGF0UmFkKSArICgxNSAqIGVjY1NxdWFyZWQgKiBlY2NTcXVhcmVkIC8gMjU2ICsgNDUgKiBlY2NTcXVhcmVkICogZWNjU3F1YXJlZCAqIGVjY1NxdWFyZWQgLyAxMDI0KSAqIE1hdGguc2luKDQgKiBMYXRSYWQpIC0gKDM1ICogZWNjU3F1YXJlZCAqIGVjY1NxdWFyZWQgKiBlY2NTcXVhcmVkIC8gMzA3MikgKiBNYXRoLnNpbig2ICogTGF0UmFkKSk7XG5cbiAgdmFyIFVUTUVhc3RpbmcgPSAoazAgKiBOICogKEEgKyAoMSAtIFQgKyBDKSAqIEEgKiBBICogQSAvIDYuMCArICg1IC0gMTggKiBUICsgVCAqIFQgKyA3MiAqIEMgLSA1OCAqIGVjY1ByaW1lU3F1YXJlZCkgKiBBICogQSAqIEEgKiBBICogQSAvIDEyMC4wKSArIDUwMDAwMC4wKTtcblxuICB2YXIgVVRNTm9ydGhpbmcgPSAoazAgKiAoTSArIE4gKiBNYXRoLnRhbihMYXRSYWQpICogKEEgKiBBIC8gMiArICg1IC0gVCArIDkgKiBDICsgNCAqIEMgKiBDKSAqIEEgKiBBICogQSAqIEEgLyAyNC4wICsgKDYxIC0gNTggKiBUICsgVCAqIFQgKyA2MDAgKiBDIC0gMzMwICogZWNjUHJpbWVTcXVhcmVkKSAqIEEgKiBBICogQSAqIEEgKiBBICogQSAvIDcyMC4wKSkpO1xuICBpZiAoTGF0IDwgMC4wKSB7XG4gICAgVVRNTm9ydGhpbmcgKz0gMTAwMDAwMDAuMDsgLy8xMDAwMDAwMCBtZXRlciBvZmZzZXQgZm9yXG4gICAgLy8gc291dGhlcm4gaGVtaXNwaGVyZVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBub3J0aGluZzogTWF0aC5yb3VuZChVVE1Ob3J0aGluZyksXG4gICAgZWFzdGluZzogTWF0aC5yb3VuZChVVE1FYXN0aW5nKSxcbiAgICB6b25lTnVtYmVyOiBab25lTnVtYmVyLFxuICAgIHpvbmVMZXR0ZXI6IGdldExldHRlckRlc2lnbmF0b3IoTGF0KVxuICB9O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIFVUTSBjb29yZHMgdG8gbGF0L2xvbmcsIHVzaW5nIHRoZSBXR1M4NCBlbGxpcHNvaWQuIFRoaXMgaXMgYSBjb252ZW5pZW5jZVxuICogY2xhc3Mgd2hlcmUgdGhlIFpvbmUgY2FuIGJlIHNwZWNpZmllZCBhcyBhIHNpbmdsZSBzdHJpbmcgZWcuXCI2ME5cIiB3aGljaFxuICogaXMgdGhlbiBicm9rZW4gZG93biBpbnRvIHRoZSBab25lTnVtYmVyIGFuZCBab25lTGV0dGVyLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge29iamVjdH0gdXRtIEFuIG9iamVjdCBsaXRlcmFsIHdpdGggbm9ydGhpbmcsIGVhc3RpbmcsIHpvbmVOdW1iZXJcbiAqICAgICBhbmQgem9uZUxldHRlciBwcm9wZXJ0aWVzLiBJZiBhbiBvcHRpb25hbCBhY2N1cmFjeSBwcm9wZXJ0eSBpc1xuICogICAgIHByb3ZpZGVkIChpbiBtZXRlcnMpLCBhIGJvdW5kaW5nIGJveCB3aWxsIGJlIHJldHVybmVkIGluc3RlYWQgb2ZcbiAqICAgICBsYXRpdHVkZSBhbmQgbG9uZ2l0dWRlLlxuICogQHJldHVybiB7b2JqZWN0fSBBbiBvYmplY3QgbGl0ZXJhbCBjb250YWluaW5nIGVpdGhlciBsYXQgYW5kIGxvbiB2YWx1ZXNcbiAqICAgICAoaWYgbm8gYWNjdXJhY3kgd2FzIHByb3ZpZGVkKSwgb3IgdG9wLCByaWdodCwgYm90dG9tIGFuZCBsZWZ0IHZhbHVlc1xuICogICAgIGZvciB0aGUgYm91bmRpbmcgYm94IGNhbGN1bGF0ZWQgYWNjb3JkaW5nIHRvIHRoZSBwcm92aWRlZCBhY2N1cmFjeS5cbiAqICAgICBSZXR1cm5zIG51bGwgaWYgdGhlIGNvbnZlcnNpb24gZmFpbGVkLlxuICovXG5mdW5jdGlvbiBVVE10b0xMKHV0bSkge1xuXG4gIHZhciBVVE1Ob3J0aGluZyA9IHV0bS5ub3J0aGluZztcbiAgdmFyIFVUTUVhc3RpbmcgPSB1dG0uZWFzdGluZztcbiAgdmFyIHpvbmVMZXR0ZXIgPSB1dG0uem9uZUxldHRlcjtcbiAgdmFyIHpvbmVOdW1iZXIgPSB1dG0uem9uZU51bWJlcjtcbiAgLy8gY2hlY2sgdGhlIFpvbmVOdW1tYmVyIGlzIHZhbGlkXG4gIGlmICh6b25lTnVtYmVyIDwgMCB8fCB6b25lTnVtYmVyID4gNjApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBrMCA9IDAuOTk5NjtcbiAgdmFyIGEgPSA2Mzc4MTM3LjA7IC8vZWxsaXAucmFkaXVzO1xuICB2YXIgZWNjU3F1YXJlZCA9IDAuMDA2Njk0Mzg7IC8vZWxsaXAuZWNjc3E7XG4gIHZhciBlY2NQcmltZVNxdWFyZWQ7XG4gIHZhciBlMSA9ICgxIC0gTWF0aC5zcXJ0KDEgLSBlY2NTcXVhcmVkKSkgLyAoMSArIE1hdGguc3FydCgxIC0gZWNjU3F1YXJlZCkpO1xuICB2YXIgTjEsIFQxLCBDMSwgUjEsIEQsIE07XG4gIHZhciBMb25nT3JpZ2luO1xuICB2YXIgbXUsIHBoaTFSYWQ7XG5cbiAgLy8gcmVtb3ZlIDUwMCwwMDAgbWV0ZXIgb2Zmc2V0IGZvciBsb25naXR1ZGVcbiAgdmFyIHggPSBVVE1FYXN0aW5nIC0gNTAwMDAwLjA7XG4gIHZhciB5ID0gVVRNTm9ydGhpbmc7XG5cbiAgLy8gV2UgbXVzdCBrbm93IHNvbWVob3cgaWYgd2UgYXJlIGluIHRoZSBOb3J0aGVybiBvciBTb3V0aGVyblxuICAvLyBoZW1pc3BoZXJlLCB0aGlzIGlzIHRoZSBvbmx5IHRpbWUgd2UgdXNlIHRoZSBsZXR0ZXIgU28gZXZlblxuICAvLyBpZiB0aGUgWm9uZSBsZXR0ZXIgaXNuJ3QgZXhhY3RseSBjb3JyZWN0IGl0IHNob3VsZCBpbmRpY2F0ZVxuICAvLyB0aGUgaGVtaXNwaGVyZSBjb3JyZWN0bHlcbiAgaWYgKHpvbmVMZXR0ZXIgPCAnTicpIHtcbiAgICB5IC09IDEwMDAwMDAwLjA7IC8vIHJlbW92ZSAxMCwwMDAsMDAwIG1ldGVyIG9mZnNldCB1c2VkXG4gICAgLy8gZm9yIHNvdXRoZXJuIGhlbWlzcGhlcmVcbiAgfVxuXG4gIC8vIFRoZXJlIGFyZSA2MCB6b25lcyB3aXRoIHpvbmUgMSBiZWluZyBhdCBXZXN0IC0xODAgdG8gLTE3NFxuICBMb25nT3JpZ2luID0gKHpvbmVOdW1iZXIgLSAxKSAqIDYgLSAxODAgKyAzOyAvLyArMyBwdXRzIG9yaWdpblxuICAvLyBpbiBtaWRkbGUgb2ZcbiAgLy8gem9uZVxuXG4gIGVjY1ByaW1lU3F1YXJlZCA9IChlY2NTcXVhcmVkKSAvICgxIC0gZWNjU3F1YXJlZCk7XG5cbiAgTSA9IHkgLyBrMDtcbiAgbXUgPSBNIC8gKGEgKiAoMSAtIGVjY1NxdWFyZWQgLyA0IC0gMyAqIGVjY1NxdWFyZWQgKiBlY2NTcXVhcmVkIC8gNjQgLSA1ICogZWNjU3F1YXJlZCAqIGVjY1NxdWFyZWQgKiBlY2NTcXVhcmVkIC8gMjU2KSk7XG5cbiAgcGhpMVJhZCA9IG11ICsgKDMgKiBlMSAvIDIgLSAyNyAqIGUxICogZTEgKiBlMSAvIDMyKSAqIE1hdGguc2luKDIgKiBtdSkgKyAoMjEgKiBlMSAqIGUxIC8gMTYgLSA1NSAqIGUxICogZTEgKiBlMSAqIGUxIC8gMzIpICogTWF0aC5zaW4oNCAqIG11KSArICgxNTEgKiBlMSAqIGUxICogZTEgLyA5NikgKiBNYXRoLnNpbig2ICogbXUpO1xuICAvLyBkb3VibGUgcGhpMSA9IFByb2pNYXRoLnJhZFRvRGVnKHBoaTFSYWQpO1xuXG4gIE4xID0gYSAvIE1hdGguc3FydCgxIC0gZWNjU3F1YXJlZCAqIE1hdGguc2luKHBoaTFSYWQpICogTWF0aC5zaW4ocGhpMVJhZCkpO1xuICBUMSA9IE1hdGgudGFuKHBoaTFSYWQpICogTWF0aC50YW4ocGhpMVJhZCk7XG4gIEMxID0gZWNjUHJpbWVTcXVhcmVkICogTWF0aC5jb3MocGhpMVJhZCkgKiBNYXRoLmNvcyhwaGkxUmFkKTtcbiAgUjEgPSBhICogKDEgLSBlY2NTcXVhcmVkKSAvIE1hdGgucG93KDEgLSBlY2NTcXVhcmVkICogTWF0aC5zaW4ocGhpMVJhZCkgKiBNYXRoLnNpbihwaGkxUmFkKSwgMS41KTtcbiAgRCA9IHggLyAoTjEgKiBrMCk7XG5cbiAgdmFyIGxhdCA9IHBoaTFSYWQgLSAoTjEgKiBNYXRoLnRhbihwaGkxUmFkKSAvIFIxKSAqIChEICogRCAvIDIgLSAoNSArIDMgKiBUMSArIDEwICogQzEgLSA0ICogQzEgKiBDMSAtIDkgKiBlY2NQcmltZVNxdWFyZWQpICogRCAqIEQgKiBEICogRCAvIDI0ICsgKDYxICsgOTAgKiBUMSArIDI5OCAqIEMxICsgNDUgKiBUMSAqIFQxIC0gMjUyICogZWNjUHJpbWVTcXVhcmVkIC0gMyAqIEMxICogQzEpICogRCAqIEQgKiBEICogRCAqIEQgKiBEIC8gNzIwKTtcbiAgbGF0ID0gcmFkVG9EZWcobGF0KTtcblxuICB2YXIgbG9uID0gKEQgLSAoMSArIDIgKiBUMSArIEMxKSAqIEQgKiBEICogRCAvIDYgKyAoNSAtIDIgKiBDMSArIDI4ICogVDEgLSAzICogQzEgKiBDMSArIDggKiBlY2NQcmltZVNxdWFyZWQgKyAyNCAqIFQxICogVDEpICogRCAqIEQgKiBEICogRCAqIEQgLyAxMjApIC8gTWF0aC5jb3MocGhpMVJhZCk7XG4gIGxvbiA9IExvbmdPcmlnaW4gKyByYWRUb0RlZyhsb24pO1xuXG4gIHZhciByZXN1bHQ7XG4gIGlmICh1dG0uYWNjdXJhY3kpIHtcbiAgICB2YXIgdG9wUmlnaHQgPSBVVE10b0xMKHtcbiAgICAgIG5vcnRoaW5nOiB1dG0ubm9ydGhpbmcgKyB1dG0uYWNjdXJhY3ksXG4gICAgICBlYXN0aW5nOiB1dG0uZWFzdGluZyArIHV0bS5hY2N1cmFjeSxcbiAgICAgIHpvbmVMZXR0ZXI6IHV0bS56b25lTGV0dGVyLFxuICAgICAgem9uZU51bWJlcjogdXRtLnpvbmVOdW1iZXJcbiAgICB9KTtcbiAgICByZXN1bHQgPSB7XG4gICAgICB0b3A6IHRvcFJpZ2h0LmxhdCxcbiAgICAgIHJpZ2h0OiB0b3BSaWdodC5sb24sXG4gICAgICBib3R0b206IGxhdCxcbiAgICAgIGxlZnQ6IGxvblxuICAgIH07XG4gIH1cbiAgZWxzZSB7XG4gICAgcmVzdWx0ID0ge1xuICAgICAgbGF0OiBsYXQsXG4gICAgICBsb246IGxvblxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBNR1JTIGxldHRlciBkZXNpZ25hdG9yIGZvciB0aGUgZ2l2ZW4gbGF0aXR1ZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBsYXQgVGhlIGxhdGl0dWRlIGluIFdHUzg0IHRvIGdldCB0aGUgbGV0dGVyIGRlc2lnbmF0b3JcbiAqICAgICBmb3IuXG4gKiBAcmV0dXJuIHtjaGFyfSBUaGUgbGV0dGVyIGRlc2lnbmF0b3IuXG4gKi9cbmZ1bmN0aW9uIGdldExldHRlckRlc2lnbmF0b3IobGF0KSB7XG4gIC8vVGhpcyBpcyBoZXJlIGFzIGFuIGVycm9yIGZsYWcgdG8gc2hvdyB0aGF0IHRoZSBMYXRpdHVkZSBpc1xuICAvL291dHNpZGUgTUdSUyBsaW1pdHNcbiAgdmFyIExldHRlckRlc2lnbmF0b3IgPSAnWic7XG5cbiAgaWYgKCg4NCA+PSBsYXQpICYmIChsYXQgPj0gNzIpKSB7XG4gICAgTGV0dGVyRGVzaWduYXRvciA9ICdYJztcbiAgfVxuICBlbHNlIGlmICgoNzIgPiBsYXQpICYmIChsYXQgPj0gNjQpKSB7XG4gICAgTGV0dGVyRGVzaWduYXRvciA9ICdXJztcbiAgfVxuICBlbHNlIGlmICgoNjQgPiBsYXQpICYmIChsYXQgPj0gNTYpKSB7XG4gICAgTGV0dGVyRGVzaWduYXRvciA9ICdWJztcbiAgfVxuICBlbHNlIGlmICgoNTYgPiBsYXQpICYmIChsYXQgPj0gNDgpKSB7XG4gICAgTGV0dGVyRGVzaWduYXRvciA9ICdVJztcbiAgfVxuICBlbHNlIGlmICgoNDggPiBsYXQpICYmIChsYXQgPj0gNDApKSB7XG4gICAgTGV0dGVyRGVzaWduYXRvciA9ICdUJztcbiAgfVxuICBlbHNlIGlmICgoNDAgPiBsYXQpICYmIChsYXQgPj0gMzIpKSB7XG4gICAgTGV0dGVyRGVzaWduYXRvciA9ICdTJztcbiAgfVxuICBlbHNlIGlmICgoMzIgPiBsYXQpICYmIChsYXQgPj0gMjQpKSB7XG4gICAgTGV0dGVyRGVzaWduYXRvciA9ICdSJztcbiAgfVxuICBlbHNlIGlmICgoMjQgPiBsYXQpICYmIChsYXQgPj0gMTYpKSB7XG4gICAgTGV0dGVyRGVzaWduYXRvciA9ICdRJztcbiAgfVxuICBlbHNlIGlmICgoMTYgPiBsYXQpICYmIChsYXQgPj0gOCkpIHtcbiAgICBMZXR0ZXJEZXNpZ25hdG9yID0gJ1AnO1xuICB9XG4gIGVsc2UgaWYgKCg4ID4gbGF0KSAmJiAobGF0ID49IDApKSB7XG4gICAgTGV0dGVyRGVzaWduYXRvciA9ICdOJztcbiAgfVxuICBlbHNlIGlmICgoMCA+IGxhdCkgJiYgKGxhdCA+PSAtOCkpIHtcbiAgICBMZXR0ZXJEZXNpZ25hdG9yID0gJ00nO1xuICB9XG4gIGVsc2UgaWYgKCgtOCA+IGxhdCkgJiYgKGxhdCA+PSAtMTYpKSB7XG4gICAgTGV0dGVyRGVzaWduYXRvciA9ICdMJztcbiAgfVxuICBlbHNlIGlmICgoLTE2ID4gbGF0KSAmJiAobGF0ID49IC0yNCkpIHtcbiAgICBMZXR0ZXJEZXNpZ25hdG9yID0gJ0snO1xuICB9XG4gIGVsc2UgaWYgKCgtMjQgPiBsYXQpICYmIChsYXQgPj0gLTMyKSkge1xuICAgIExldHRlckRlc2lnbmF0b3IgPSAnSic7XG4gIH1cbiAgZWxzZSBpZiAoKC0zMiA+IGxhdCkgJiYgKGxhdCA+PSAtNDApKSB7XG4gICAgTGV0dGVyRGVzaWduYXRvciA9ICdIJztcbiAgfVxuICBlbHNlIGlmICgoLTQwID4gbGF0KSAmJiAobGF0ID49IC00OCkpIHtcbiAgICBMZXR0ZXJEZXNpZ25hdG9yID0gJ0cnO1xuICB9XG4gIGVsc2UgaWYgKCgtNDggPiBsYXQpICYmIChsYXQgPj0gLTU2KSkge1xuICAgIExldHRlckRlc2lnbmF0b3IgPSAnRic7XG4gIH1cbiAgZWxzZSBpZiAoKC01NiA+IGxhdCkgJiYgKGxhdCA+PSAtNjQpKSB7XG4gICAgTGV0dGVyRGVzaWduYXRvciA9ICdFJztcbiAgfVxuICBlbHNlIGlmICgoLTY0ID4gbGF0KSAmJiAobGF0ID49IC03MikpIHtcbiAgICBMZXR0ZXJEZXNpZ25hdG9yID0gJ0QnO1xuICB9XG4gIGVsc2UgaWYgKCgtNzIgPiBsYXQpICYmIChsYXQgPj0gLTgwKSkge1xuICAgIExldHRlckRlc2lnbmF0b3IgPSAnQyc7XG4gIH1cbiAgcmV0dXJuIExldHRlckRlc2lnbmF0b3I7XG59XG5cbi8qKlxuICogRW5jb2RlcyBhIFVUTSBsb2NhdGlvbiBhcyBNR1JTIHN0cmluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtvYmplY3R9IHV0bSBBbiBvYmplY3QgbGl0ZXJhbCB3aXRoIGVhc3RpbmcsIG5vcnRoaW5nLFxuICogICAgIHpvbmVMZXR0ZXIsIHpvbmVOdW1iZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBhY2N1cmFjeSBBY2N1cmFjeSBpbiBkaWdpdHMgKDEtNSkuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IE1HUlMgc3RyaW5nIGZvciB0aGUgZ2l2ZW4gVVRNIGxvY2F0aW9uLlxuICovXG5mdW5jdGlvbiBlbmNvZGUodXRtLCBhY2N1cmFjeSkge1xuICAvLyBwcmVwZW5kIHdpdGggbGVhZGluZyB6ZXJvZXNcbiAgdmFyIHNlYXN0aW5nID0gXCIwMDAwMFwiICsgdXRtLmVhc3RpbmcsXG4gICAgc25vcnRoaW5nID0gXCIwMDAwMFwiICsgdXRtLm5vcnRoaW5nO1xuXG4gIHJldHVybiB1dG0uem9uZU51bWJlciArIHV0bS56b25lTGV0dGVyICsgZ2V0MTAwa0lEKHV0bS5lYXN0aW5nLCB1dG0ubm9ydGhpbmcsIHV0bS56b25lTnVtYmVyKSArIHNlYXN0aW5nLnN1YnN0cihzZWFzdGluZy5sZW5ndGggLSA1LCBhY2N1cmFjeSkgKyBzbm9ydGhpbmcuc3Vic3RyKHNub3J0aGluZy5sZW5ndGggLSA1LCBhY2N1cmFjeSk7XG59XG5cbi8qKlxuICogR2V0IHRoZSB0d28gbGV0dGVyIDEwMGsgZGVzaWduYXRvciBmb3IgYSBnaXZlbiBVVE0gZWFzdGluZyxcbiAqIG5vcnRoaW5nIGFuZCB6b25lIG51bWJlciB2YWx1ZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IGVhc3RpbmdcbiAqIEBwYXJhbSB7bnVtYmVyfSBub3J0aGluZ1xuICogQHBhcmFtIHtudW1iZXJ9IHpvbmVOdW1iZXJcbiAqIEByZXR1cm4gdGhlIHR3byBsZXR0ZXIgMTAwayBkZXNpZ25hdG9yIGZvciB0aGUgZ2l2ZW4gVVRNIGxvY2F0aW9uLlxuICovXG5mdW5jdGlvbiBnZXQxMDBrSUQoZWFzdGluZywgbm9ydGhpbmcsIHpvbmVOdW1iZXIpIHtcbiAgdmFyIHNldFBhcm0gPSBnZXQxMDBrU2V0Rm9yWm9uZSh6b25lTnVtYmVyKTtcbiAgdmFyIHNldENvbHVtbiA9IE1hdGguZmxvb3IoZWFzdGluZyAvIDEwMDAwMCk7XG4gIHZhciBzZXRSb3cgPSBNYXRoLmZsb29yKG5vcnRoaW5nIC8gMTAwMDAwKSAlIDIwO1xuICByZXR1cm4gZ2V0TGV0dGVyMTAwa0lEKHNldENvbHVtbiwgc2V0Um93LCBzZXRQYXJtKTtcbn1cblxuLyoqXG4gKiBHaXZlbiBhIFVUTSB6b25lIG51bWJlciwgZmlndXJlIG91dCB0aGUgTUdSUyAxMDBLIHNldCBpdCBpcyBpbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IGkgQW4gVVRNIHpvbmUgbnVtYmVyLlxuICogQHJldHVybiB7bnVtYmVyfSB0aGUgMTAwayBzZXQgdGhlIFVUTSB6b25lIGlzIGluLlxuICovXG5mdW5jdGlvbiBnZXQxMDBrU2V0Rm9yWm9uZShpKSB7XG4gIHZhciBzZXRQYXJtID0gaSAlIE5VTV8xMDBLX1NFVFM7XG4gIGlmIChzZXRQYXJtID09PSAwKSB7XG4gICAgc2V0UGFybSA9IE5VTV8xMDBLX1NFVFM7XG4gIH1cblxuICByZXR1cm4gc2V0UGFybTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHR3by1sZXR0ZXIgTUdSUyAxMDBrIGRlc2lnbmF0b3IgZ2l2ZW4gaW5mb3JtYXRpb25cbiAqIHRyYW5zbGF0ZWQgZnJvbSB0aGUgVVRNIG5vcnRoaW5nLCBlYXN0aW5nIGFuZCB6b25lIG51bWJlci5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbiB0aGUgY29sdW1uIGluZGV4IGFzIGl0IHJlbGF0ZXMgdG8gdGhlIE1HUlNcbiAqICAgICAgICAxMDBrIHNldCBzcHJlYWRzaGVldCwgY3JlYXRlZCBmcm9tIHRoZSBVVE0gZWFzdGluZy5cbiAqICAgICAgICBWYWx1ZXMgYXJlIDEtOC5cbiAqIEBwYXJhbSB7bnVtYmVyfSByb3cgdGhlIHJvdyBpbmRleCBhcyBpdCByZWxhdGVzIHRvIHRoZSBNR1JTIDEwMGsgc2V0XG4gKiAgICAgICAgc3ByZWFkc2hlZXQsIGNyZWF0ZWQgZnJvbSB0aGUgVVRNIG5vcnRoaW5nIHZhbHVlLiBWYWx1ZXNcbiAqICAgICAgICBhcmUgZnJvbSAwLTE5LlxuICogQHBhcmFtIHtudW1iZXJ9IHBhcm0gdGhlIHNldCBibG9jaywgYXMgaXQgcmVsYXRlcyB0byB0aGUgTUdSUyAxMDBrIHNldFxuICogICAgICAgIHNwcmVhZHNoZWV0LCBjcmVhdGVkIGZyb20gdGhlIFVUTSB6b25lLiBWYWx1ZXMgYXJlIGZyb21cbiAqICAgICAgICAxLTYwLlxuICogQHJldHVybiB0d28gbGV0dGVyIE1HUlMgMTAwayBjb2RlLlxuICovXG5mdW5jdGlvbiBnZXRMZXR0ZXIxMDBrSUQoY29sdW1uLCByb3csIHBhcm0pIHtcbiAgLy8gY29sT3JpZ2luIGFuZCByb3dPcmlnaW4gYXJlIHRoZSBsZXR0ZXJzIGF0IHRoZSBvcmlnaW4gb2YgdGhlIHNldFxuICB2YXIgaW5kZXggPSBwYXJtIC0gMTtcbiAgdmFyIGNvbE9yaWdpbiA9IFNFVF9PUklHSU5fQ09MVU1OX0xFVFRFUlMuY2hhckNvZGVBdChpbmRleCk7XG4gIHZhciByb3dPcmlnaW4gPSBTRVRfT1JJR0lOX1JPV19MRVRURVJTLmNoYXJDb2RlQXQoaW5kZXgpO1xuXG4gIC8vIGNvbEludCBhbmQgcm93SW50IGFyZSB0aGUgbGV0dGVycyB0byBidWlsZCB0byByZXR1cm5cbiAgdmFyIGNvbEludCA9IGNvbE9yaWdpbiArIGNvbHVtbiAtIDE7XG4gIHZhciByb3dJbnQgPSByb3dPcmlnaW4gKyByb3c7XG4gIHZhciByb2xsb3ZlciA9IGZhbHNlO1xuXG4gIGlmIChjb2xJbnQgPiBaKSB7XG4gICAgY29sSW50ID0gY29sSW50IC0gWiArIEEgLSAxO1xuICAgIHJvbGxvdmVyID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChjb2xJbnQgPT09IEkgfHwgKGNvbE9yaWdpbiA8IEkgJiYgY29sSW50ID4gSSkgfHwgKChjb2xJbnQgPiBJIHx8IGNvbE9yaWdpbiA8IEkpICYmIHJvbGxvdmVyKSkge1xuICAgIGNvbEludCsrO1xuICB9XG5cbiAgaWYgKGNvbEludCA9PT0gTyB8fCAoY29sT3JpZ2luIDwgTyAmJiBjb2xJbnQgPiBPKSB8fCAoKGNvbEludCA+IE8gfHwgY29sT3JpZ2luIDwgTykgJiYgcm9sbG92ZXIpKSB7XG4gICAgY29sSW50Kys7XG5cbiAgICBpZiAoY29sSW50ID09PSBJKSB7XG4gICAgICBjb2xJbnQrKztcbiAgICB9XG4gIH1cblxuICBpZiAoY29sSW50ID4gWikge1xuICAgIGNvbEludCA9IGNvbEludCAtIFogKyBBIC0gMTtcbiAgfVxuXG4gIGlmIChyb3dJbnQgPiBWKSB7XG4gICAgcm93SW50ID0gcm93SW50IC0gViArIEEgLSAxO1xuICAgIHJvbGxvdmVyID0gdHJ1ZTtcbiAgfVxuICBlbHNlIHtcbiAgICByb2xsb3ZlciA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKCgocm93SW50ID09PSBJKSB8fCAoKHJvd09yaWdpbiA8IEkpICYmIChyb3dJbnQgPiBJKSkpIHx8ICgoKHJvd0ludCA+IEkpIHx8IChyb3dPcmlnaW4gPCBJKSkgJiYgcm9sbG92ZXIpKSB7XG4gICAgcm93SW50Kys7XG4gIH1cblxuICBpZiAoKChyb3dJbnQgPT09IE8pIHx8ICgocm93T3JpZ2luIDwgTykgJiYgKHJvd0ludCA+IE8pKSkgfHwgKCgocm93SW50ID4gTykgfHwgKHJvd09yaWdpbiA8IE8pKSAmJiByb2xsb3ZlcikpIHtcbiAgICByb3dJbnQrKztcblxuICAgIGlmIChyb3dJbnQgPT09IEkpIHtcbiAgICAgIHJvd0ludCsrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChyb3dJbnQgPiBWKSB7XG4gICAgcm93SW50ID0gcm93SW50IC0gViArIEEgLSAxO1xuICB9XG5cbiAgdmFyIHR3b0xldHRlciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29sSW50KSArIFN0cmluZy5mcm9tQ2hhckNvZGUocm93SW50KTtcbiAgcmV0dXJuIHR3b0xldHRlcjtcbn1cblxuLyoqXG4gKiBEZWNvZGUgdGhlIFVUTSBwYXJhbWV0ZXJzIGZyb20gYSBNR1JTIHN0cmluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IG1ncnNTdHJpbmcgYW4gVVBQRVJDQVNFIGNvb3JkaW5hdGUgc3RyaW5nIGlzIGV4cGVjdGVkLlxuICogQHJldHVybiB7b2JqZWN0fSBBbiBvYmplY3QgbGl0ZXJhbCB3aXRoIGVhc3RpbmcsIG5vcnRoaW5nLCB6b25lTGV0dGVyLFxuICogICAgIHpvbmVOdW1iZXIgYW5kIGFjY3VyYWN5IChpbiBtZXRlcnMpIHByb3BlcnRpZXMuXG4gKi9cbmZ1bmN0aW9uIGRlY29kZShtZ3JzU3RyaW5nKSB7XG5cbiAgaWYgKG1ncnNTdHJpbmcgJiYgbWdyc1N0cmluZy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyAoXCJNR1JTUG9pbnQgY292ZXJ0aW5nIGZyb20gbm90aGluZ1wiKTtcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBtZ3JzU3RyaW5nLmxlbmd0aDtcblxuICB2YXIgaHVuSyA9IG51bGw7XG4gIHZhciBzYiA9IFwiXCI7XG4gIHZhciB0ZXN0Q2hhcjtcbiAgdmFyIGkgPSAwO1xuXG4gIC8vIGdldCBab25lIG51bWJlclxuICB3aGlsZSAoISgvW0EtWl0vKS50ZXN0KHRlc3RDaGFyID0gbWdyc1N0cmluZy5jaGFyQXQoaSkpKSB7XG4gICAgaWYgKGkgPj0gMikge1xuICAgICAgdGhyb3cgKFwiTUdSU1BvaW50IGJhZCBjb252ZXJzaW9uIGZyb206IFwiICsgbWdyc1N0cmluZyk7XG4gICAgfVxuICAgIHNiICs9IHRlc3RDaGFyO1xuICAgIGkrKztcbiAgfVxuXG4gIHZhciB6b25lTnVtYmVyID0gcGFyc2VJbnQoc2IsIDEwKTtcblxuICBpZiAoaSA9PT0gMCB8fCBpICsgMyA+IGxlbmd0aCkge1xuICAgIC8vIEEgZ29vZCBNR1JTIHN0cmluZyBoYXMgdG8gYmUgNC01IGRpZ2l0cyBsb25nLFxuICAgIC8vICMjQUFBLyNBQUEgYXQgbGVhc3QuXG4gICAgdGhyb3cgKFwiTUdSU1BvaW50IGJhZCBjb252ZXJzaW9uIGZyb206IFwiICsgbWdyc1N0cmluZyk7XG4gIH1cblxuICB2YXIgem9uZUxldHRlciA9IG1ncnNTdHJpbmcuY2hhckF0KGkrKyk7XG5cbiAgLy8gU2hvdWxkIHdlIGNoZWNrIHRoZSB6b25lIGxldHRlciBoZXJlPyBXaHkgbm90LlxuICBpZiAoem9uZUxldHRlciA8PSAnQScgfHwgem9uZUxldHRlciA9PT0gJ0InIHx8IHpvbmVMZXR0ZXIgPT09ICdZJyB8fCB6b25lTGV0dGVyID49ICdaJyB8fCB6b25lTGV0dGVyID09PSAnSScgfHwgem9uZUxldHRlciA9PT0gJ08nKSB7XG4gICAgdGhyb3cgKFwiTUdSU1BvaW50IHpvbmUgbGV0dGVyIFwiICsgem9uZUxldHRlciArIFwiIG5vdCBoYW5kbGVkOiBcIiArIG1ncnNTdHJpbmcpO1xuICB9XG5cbiAgaHVuSyA9IG1ncnNTdHJpbmcuc3Vic3RyaW5nKGksIGkgKz0gMik7XG5cbiAgdmFyIHNldCA9IGdldDEwMGtTZXRGb3Jab25lKHpvbmVOdW1iZXIpO1xuXG4gIHZhciBlYXN0MTAwayA9IGdldEVhc3RpbmdGcm9tQ2hhcihodW5LLmNoYXJBdCgwKSwgc2V0KTtcbiAgdmFyIG5vcnRoMTAwayA9IGdldE5vcnRoaW5nRnJvbUNoYXIoaHVuSy5jaGFyQXQoMSksIHNldCk7XG5cbiAgLy8gV2UgaGF2ZSBhIGJ1ZyB3aGVyZSB0aGUgbm9ydGhpbmcgbWF5IGJlIDIwMDAwMDAgdG9vIGxvdy5cbiAgLy8gSG93XG4gIC8vIGRvIHdlIGtub3cgd2hlbiB0byByb2xsIG92ZXI/XG5cbiAgd2hpbGUgKG5vcnRoMTAwayA8IGdldE1pbk5vcnRoaW5nKHpvbmVMZXR0ZXIpKSB7XG4gICAgbm9ydGgxMDBrICs9IDIwMDAwMDA7XG4gIH1cblxuICAvLyBjYWxjdWxhdGUgdGhlIGNoYXIgaW5kZXggZm9yIGVhc3Rpbmcvbm9ydGhpbmcgc2VwYXJhdG9yXG4gIHZhciByZW1haW5kZXIgPSBsZW5ndGggLSBpO1xuXG4gIGlmIChyZW1haW5kZXIgJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgKFwiTUdSU1BvaW50IGhhcyB0byBoYXZlIGFuIGV2ZW4gbnVtYmVyIFxcbm9mIGRpZ2l0cyBhZnRlciB0aGUgem9uZSBsZXR0ZXIgYW5kIHR3byAxMDBrbSBsZXR0ZXJzIC0gZnJvbnQgXFxuaGFsZiBmb3IgZWFzdGluZyBtZXRlcnMsIHNlY29uZCBoYWxmIGZvciBcXG5ub3J0aGluZyBtZXRlcnNcIiArIG1ncnNTdHJpbmcpO1xuICB9XG5cbiAgdmFyIHNlcCA9IHJlbWFpbmRlciAvIDI7XG5cbiAgdmFyIHNlcEVhc3RpbmcgPSAwLjA7XG4gIHZhciBzZXBOb3J0aGluZyA9IDAuMDtcbiAgdmFyIGFjY3VyYWN5Qm9udXMsIHNlcEVhc3RpbmdTdHJpbmcsIHNlcE5vcnRoaW5nU3RyaW5nLCBlYXN0aW5nLCBub3J0aGluZztcbiAgaWYgKHNlcCA+IDApIHtcbiAgICBhY2N1cmFjeUJvbnVzID0gMTAwMDAwLjAgLyBNYXRoLnBvdygxMCwgc2VwKTtcbiAgICBzZXBFYXN0aW5nU3RyaW5nID0gbWdyc1N0cmluZy5zdWJzdHJpbmcoaSwgaSArIHNlcCk7XG4gICAgc2VwRWFzdGluZyA9IHBhcnNlRmxvYXQoc2VwRWFzdGluZ1N0cmluZykgKiBhY2N1cmFjeUJvbnVzO1xuICAgIHNlcE5vcnRoaW5nU3RyaW5nID0gbWdyc1N0cmluZy5zdWJzdHJpbmcoaSArIHNlcCk7XG4gICAgc2VwTm9ydGhpbmcgPSBwYXJzZUZsb2F0KHNlcE5vcnRoaW5nU3RyaW5nKSAqIGFjY3VyYWN5Qm9udXM7XG4gIH1cblxuICBlYXN0aW5nID0gc2VwRWFzdGluZyArIGVhc3QxMDBrO1xuICBub3J0aGluZyA9IHNlcE5vcnRoaW5nICsgbm9ydGgxMDBrO1xuXG4gIHJldHVybiB7XG4gICAgZWFzdGluZzogZWFzdGluZyxcbiAgICBub3J0aGluZzogbm9ydGhpbmcsXG4gICAgem9uZUxldHRlcjogem9uZUxldHRlcixcbiAgICB6b25lTnVtYmVyOiB6b25lTnVtYmVyLFxuICAgIGFjY3VyYWN5OiBhY2N1cmFjeUJvbnVzXG4gIH07XG59XG5cbi8qKlxuICogR2l2ZW4gdGhlIGZpcnN0IGxldHRlciBmcm9tIGEgdHdvLWxldHRlciBNR1JTIDEwMGsgem9uZSwgYW5kIGdpdmVuIHRoZVxuICogTUdSUyB0YWJsZSBzZXQgZm9yIHRoZSB6b25lIG51bWJlciwgZmlndXJlIG91dCB0aGUgZWFzdGluZyB2YWx1ZSB0aGF0XG4gKiBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIG90aGVyLCBzZWNvbmRhcnkgZWFzdGluZyB2YWx1ZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtjaGFyfSBlIFRoZSBmaXJzdCBsZXR0ZXIgZnJvbSBhIHR3by1sZXR0ZXIgTUdSUyAxMDDCtGsgem9uZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzZXQgVGhlIE1HUlMgdGFibGUgc2V0IGZvciB0aGUgem9uZSBudW1iZXIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBlYXN0aW5nIHZhbHVlIGZvciB0aGUgZ2l2ZW4gbGV0dGVyIGFuZCBzZXQuXG4gKi9cbmZ1bmN0aW9uIGdldEVhc3RpbmdGcm9tQ2hhcihlLCBzZXQpIHtcbiAgLy8gY29sT3JpZ2luIGlzIHRoZSBsZXR0ZXIgYXQgdGhlIG9yaWdpbiBvZiB0aGUgc2V0IGZvciB0aGVcbiAgLy8gY29sdW1uXG4gIHZhciBjdXJDb2wgPSBTRVRfT1JJR0lOX0NPTFVNTl9MRVRURVJTLmNoYXJDb2RlQXQoc2V0IC0gMSk7XG4gIHZhciBlYXN0aW5nVmFsdWUgPSAxMDAwMDAuMDtcbiAgdmFyIHJld2luZE1hcmtlciA9IGZhbHNlO1xuXG4gIHdoaWxlIChjdXJDb2wgIT09IGUuY2hhckNvZGVBdCgwKSkge1xuICAgIGN1ckNvbCsrO1xuICAgIGlmIChjdXJDb2wgPT09IEkpIHtcbiAgICAgIGN1ckNvbCsrO1xuICAgIH1cbiAgICBpZiAoY3VyQ29sID09PSBPKSB7XG4gICAgICBjdXJDb2wrKztcbiAgICB9XG4gICAgaWYgKGN1ckNvbCA+IFopIHtcbiAgICAgIGlmIChyZXdpbmRNYXJrZXIpIHtcbiAgICAgICAgdGhyb3cgKFwiQmFkIGNoYXJhY3RlcjogXCIgKyBlKTtcbiAgICAgIH1cbiAgICAgIGN1ckNvbCA9IEE7XG4gICAgICByZXdpbmRNYXJrZXIgPSB0cnVlO1xuICAgIH1cbiAgICBlYXN0aW5nVmFsdWUgKz0gMTAwMDAwLjA7XG4gIH1cblxuICByZXR1cm4gZWFzdGluZ1ZhbHVlO1xufVxuXG4vKipcbiAqIEdpdmVuIHRoZSBzZWNvbmQgbGV0dGVyIGZyb20gYSB0d28tbGV0dGVyIE1HUlMgMTAwayB6b25lLCBhbmQgZ2l2ZW4gdGhlXG4gKiBNR1JTIHRhYmxlIHNldCBmb3IgdGhlIHpvbmUgbnVtYmVyLCBmaWd1cmUgb3V0IHRoZSBub3J0aGluZyB2YWx1ZSB0aGF0XG4gKiBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIG90aGVyLCBzZWNvbmRhcnkgbm9ydGhpbmcgdmFsdWUuIFlvdSBoYXZlIHRvXG4gKiByZW1lbWJlciB0aGF0IE5vcnRoaW5ncyBhcmUgZGV0ZXJtaW5lZCBmcm9tIHRoZSBlcXVhdG9yLCBhbmQgdGhlIHZlcnRpY2FsXG4gKiBjeWNsZSBvZiBsZXR0ZXJzIG1lYW4gYSAyMDAwMDAwIGFkZGl0aW9uYWwgbm9ydGhpbmcgbWV0ZXJzLiBUaGlzIGhhcHBlbnNcbiAqIGFwcHJveC4gZXZlcnkgMTggZGVncmVlcyBvZiBsYXRpdHVkZS4gVGhpcyBtZXRob2QgZG9lcyAqTk9UKiBjb3VudCBhbnlcbiAqIGFkZGl0aW9uYWwgbm9ydGhpbmdzLiBZb3UgaGF2ZSB0byBmaWd1cmUgb3V0IGhvdyBtYW55IDIwMDAwMDAgbWV0ZXJzIG5lZWRcbiAqIHRvIGJlIGFkZGVkIGZvciB0aGUgem9uZSBsZXR0ZXIgb2YgdGhlIE1HUlMgY29vcmRpbmF0ZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtjaGFyfSBuIFNlY29uZCBsZXR0ZXIgb2YgdGhlIE1HUlMgMTAwayB6b25lXG4gKiBAcGFyYW0ge251bWJlcn0gc2V0IFRoZSBNR1JTIHRhYmxlIHNldCBudW1iZXIsIHdoaWNoIGlzIGRlcGVuZGVudCBvbiB0aGVcbiAqICAgICBVVE0gem9uZSBudW1iZXIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBub3J0aGluZyB2YWx1ZSBmb3IgdGhlIGdpdmVuIGxldHRlciBhbmQgc2V0LlxuICovXG5mdW5jdGlvbiBnZXROb3J0aGluZ0Zyb21DaGFyKG4sIHNldCkge1xuXG4gIGlmIChuID4gJ1YnKSB7XG4gICAgdGhyb3cgKFwiTUdSU1BvaW50IGdpdmVuIGludmFsaWQgTm9ydGhpbmcgXCIgKyBuKTtcbiAgfVxuXG4gIC8vIHJvd09yaWdpbiBpcyB0aGUgbGV0dGVyIGF0IHRoZSBvcmlnaW4gb2YgdGhlIHNldCBmb3IgdGhlXG4gIC8vIGNvbHVtblxuICB2YXIgY3VyUm93ID0gU0VUX09SSUdJTl9ST1dfTEVUVEVSUy5jaGFyQ29kZUF0KHNldCAtIDEpO1xuICB2YXIgbm9ydGhpbmdWYWx1ZSA9IDAuMDtcbiAgdmFyIHJld2luZE1hcmtlciA9IGZhbHNlO1xuXG4gIHdoaWxlIChjdXJSb3cgIT09IG4uY2hhckNvZGVBdCgwKSkge1xuICAgIGN1clJvdysrO1xuICAgIGlmIChjdXJSb3cgPT09IEkpIHtcbiAgICAgIGN1clJvdysrO1xuICAgIH1cbiAgICBpZiAoY3VyUm93ID09PSBPKSB7XG4gICAgICBjdXJSb3crKztcbiAgICB9XG4gICAgLy8gZml4aW5nIGEgYnVnIG1ha2luZyB3aG9sZSBhcHBsaWNhdGlvbiBoYW5nIGluIHRoaXMgbG9vcFxuICAgIC8vIHdoZW4gJ24nIGlzIGEgd3JvbmcgY2hhcmFjdGVyXG4gICAgaWYgKGN1clJvdyA+IFYpIHtcbiAgICAgIGlmIChyZXdpbmRNYXJrZXIpIHsgLy8gbWFraW5nIHN1cmUgdGhhdCB0aGlzIGxvb3AgZW5kc1xuICAgICAgICB0aHJvdyAoXCJCYWQgY2hhcmFjdGVyOiBcIiArIG4pO1xuICAgICAgfVxuICAgICAgY3VyUm93ID0gQTtcbiAgICAgIHJld2luZE1hcmtlciA9IHRydWU7XG4gICAgfVxuICAgIG5vcnRoaW5nVmFsdWUgKz0gMTAwMDAwLjA7XG4gIH1cblxuICByZXR1cm4gbm9ydGhpbmdWYWx1ZTtcbn1cblxuLyoqXG4gKiBUaGUgZnVuY3Rpb24gZ2V0TWluTm9ydGhpbmcgcmV0dXJucyB0aGUgbWluaW11bSBub3J0aGluZyB2YWx1ZSBvZiBhIE1HUlNcbiAqIHpvbmUuXG4gKlxuICogUG9ydGVkIGZyb20gR2VvdHJhbnMnIGMgTGF0dGl0dWRlX0JhbmRfVmFsdWUgc3RydWN0dXJlIHRhYmxlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2NoYXJ9IHpvbmVMZXR0ZXIgVGhlIE1HUlMgem9uZSB0byBnZXQgdGhlIG1pbiBub3J0aGluZyBmb3IuXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGdldE1pbk5vcnRoaW5nKHpvbmVMZXR0ZXIpIHtcbiAgdmFyIG5vcnRoaW5nO1xuICBzd2l0Y2ggKHpvbmVMZXR0ZXIpIHtcbiAgY2FzZSAnQyc6XG4gICAgbm9ydGhpbmcgPSAxMTAwMDAwLjA7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ0QnOlxuICAgIG5vcnRoaW5nID0gMjAwMDAwMC4wO1xuICAgIGJyZWFrO1xuICBjYXNlICdFJzpcbiAgICBub3J0aGluZyA9IDI4MDAwMDAuMDtcbiAgICBicmVhaztcbiAgY2FzZSAnRic6XG4gICAgbm9ydGhpbmcgPSAzNzAwMDAwLjA7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ0cnOlxuICAgIG5vcnRoaW5nID0gNDYwMDAwMC4wO1xuICAgIGJyZWFrO1xuICBjYXNlICdIJzpcbiAgICBub3J0aGluZyA9IDU1MDAwMDAuMDtcbiAgICBicmVhaztcbiAgY2FzZSAnSic6XG4gICAgbm9ydGhpbmcgPSA2NDAwMDAwLjA7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ0snOlxuICAgIG5vcnRoaW5nID0gNzMwMDAwMC4wO1xuICAgIGJyZWFrO1xuICBjYXNlICdMJzpcbiAgICBub3J0aGluZyA9IDgyMDAwMDAuMDtcbiAgICBicmVhaztcbiAgY2FzZSAnTSc6XG4gICAgbm9ydGhpbmcgPSA5MTAwMDAwLjA7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ04nOlxuICAgIG5vcnRoaW5nID0gMC4wO1xuICAgIGJyZWFrO1xuICBjYXNlICdQJzpcbiAgICBub3J0aGluZyA9IDgwMDAwMC4wO1xuICAgIGJyZWFrO1xuICBjYXNlICdRJzpcbiAgICBub3J0aGluZyA9IDE3MDAwMDAuMDtcbiAgICBicmVhaztcbiAgY2FzZSAnUic6XG4gICAgbm9ydGhpbmcgPSAyNjAwMDAwLjA7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ1MnOlxuICAgIG5vcnRoaW5nID0gMzUwMDAwMC4wO1xuICAgIGJyZWFrO1xuICBjYXNlICdUJzpcbiAgICBub3J0aGluZyA9IDQ0MDAwMDAuMDtcbiAgICBicmVhaztcbiAgY2FzZSAnVSc6XG4gICAgbm9ydGhpbmcgPSA1MzAwMDAwLjA7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ1YnOlxuICAgIG5vcnRoaW5nID0gNjIwMDAwMC4wO1xuICAgIGJyZWFrO1xuICBjYXNlICdXJzpcbiAgICBub3J0aGluZyA9IDcwMDAwMDAuMDtcbiAgICBicmVhaztcbiAgY2FzZSAnWCc6XG4gICAgbm9ydGhpbmcgPSA3OTAwMDAwLjA7XG4gICAgYnJlYWs7XG4gIGRlZmF1bHQ6XG4gICAgbm9ydGhpbmcgPSAtMS4wO1xuICB9XG4gIGlmIChub3J0aGluZyA+PSAwLjApIHtcbiAgICByZXR1cm4gbm9ydGhpbmc7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhyb3cgKFwiSW52YWxpZCB6b25lIGxldHRlcjogXCIgKyB6b25lTGV0dGVyKTtcbiAgfVxuXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbWdycy9tZ3JzLmpzXG4vLyBtb2R1bGUgaWQgPSA1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports){eval("module.exports = function(phi, sphi, cphi, en) {\n  cphi *= sphi;\n  sphi *= sphi;\n  return (en[0] * phi - cphi * (en[1] + sphi * (en[2] + sphi * (en[3] + sphi * en[4]))));\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9jb21tb24vcGpfbWxmbi5qcz9hMWYwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHBoaSwgc3BoaSwgY3BoaSwgZW4pIHtcbiAgY3BoaSAqPSBzcGhpO1xuICBzcGhpICo9IHNwaGk7XG4gIHJldHVybiAoZW5bMF0gKiBwaGkgLSBjcGhpICogKGVuWzFdICsgc3BoaSAqIChlblsyXSArIHNwaGkgKiAoZW5bM10gKyBzcGhpICogZW5bNF0pKSkpO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHJvajQvbGliL2NvbW1vbi9wal9tbGZuLmpzXG4vLyBtb2R1bGUgaWQgPSA2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports){eval("module.exports = function (array){\n  var out = {\n    x: array[0],\n    y: array[1]\n  };\n  if (array.length>2) {\n    out.z = array[2];\n  }\n  if (array.length>3) {\n    out.m = array[3];\n  }\n  return out;\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9jb21tb24vdG9Qb2ludC5qcz83N2MzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjYxLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJyYXkpe1xuICB2YXIgb3V0ID0ge1xuICAgIHg6IGFycmF5WzBdLFxuICAgIHk6IGFycmF5WzFdXG4gIH07XG4gIGlmIChhcnJheS5sZW5ndGg+Mikge1xuICAgIG91dC56ID0gYXJyYXlbMl07XG4gIH1cbiAgaWYgKGFycmF5Lmxlbmd0aD4zKSB7XG4gICAgb3V0Lm0gPSBhcnJheVszXTtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHJvajQvbGliL2NvbW1vbi90b1BvaW50LmpzXG4vLyBtb2R1bGUgaWQgPSA2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("var globals = __webpack_require__(134);\nvar parseProj = __webpack_require__(64);\nvar wkt = __webpack_require__(67);\n\nfunction defs(name) {\n  /*global console*/\n  var that = this;\n  if (arguments.length === 2) {\n    var def = arguments[1];\n    if (typeof def === 'string') {\n      if (def.charAt(0) === '+') {\n        defs[name] = parseProj(arguments[1]);\n      }\n      else {\n        defs[name] = wkt(arguments[1]);\n      }\n    } else {\n      defs[name] = def;\n    }\n  }\n  else if (arguments.length === 1) {\n    if (Array.isArray(name)) {\n      return name.map(function(v) {\n        if (Array.isArray(v)) {\n          defs.apply(that, v);\n        }\n        else {\n          defs(v);\n        }\n      });\n    }\n    else if (typeof name === 'string') {\n      if (name in defs) {\n        return defs[name];\n      }\n    }\n    else if ('EPSG' in name) {\n      defs['EPSG:' + name.EPSG] = name;\n    }\n    else if ('ESRI' in name) {\n      defs['ESRI:' + name.ESRI] = name;\n    }\n    else if ('IAU2000' in name) {\n      defs['IAU2000:' + name.IAU2000] = name;\n    }\n    else {\n      console.log(name);\n    }\n    return;\n  }\n\n\n}\nglobals(defs);\nmodule.exports = defs;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9kZWZzLmpzP2Q1NmIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBIiwiZmlsZSI6IjYyLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGdsb2JhbHMgPSByZXF1aXJlKCcuL2dsb2JhbCcpO1xudmFyIHBhcnNlUHJvaiA9IHJlcXVpcmUoJy4vcHJvalN0cmluZycpO1xudmFyIHdrdCA9IHJlcXVpcmUoJy4vd2t0Jyk7XG5cbmZ1bmN0aW9uIGRlZnMobmFtZSkge1xuICAvKmdsb2JhbCBjb25zb2xlKi9cbiAgdmFyIHRoYXQgPSB0aGlzO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBkZWYgPSBhcmd1bWVudHNbMV07XG4gICAgaWYgKHR5cGVvZiBkZWYgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoZGVmLmNoYXJBdCgwKSA9PT0gJysnKSB7XG4gICAgICAgIGRlZnNbbmFtZV0gPSBwYXJzZVByb2ooYXJndW1lbnRzWzFdKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBkZWZzW25hbWVdID0gd2t0KGFyZ3VtZW50c1sxXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZnNbbmFtZV0gPSBkZWY7XG4gICAgfVxuICB9XG4gIGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShuYW1lKSkge1xuICAgICAgcmV0dXJuIG5hbWUubWFwKGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgICAgICBkZWZzLmFwcGx5KHRoYXQsIHYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlZnModik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChuYW1lIGluIGRlZnMpIHtcbiAgICAgICAgcmV0dXJuIGRlZnNbbmFtZV07XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKCdFUFNHJyBpbiBuYW1lKSB7XG4gICAgICBkZWZzWydFUFNHOicgKyBuYW1lLkVQU0ddID0gbmFtZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ0VTUkknIGluIG5hbWUpIHtcbiAgICAgIGRlZnNbJ0VTUkk6JyArIG5hbWUuRVNSSV0gPSBuYW1lO1xuICAgIH1cbiAgICBlbHNlIGlmICgnSUFVMjAwMCcgaW4gbmFtZSkge1xuICAgICAgZGVmc1snSUFVMjAwMDonICsgbmFtZS5JQVUyMDAwXSA9IG5hbWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY29uc29sZS5sb2cobmFtZSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG5cbn1cbmdsb2JhbHMoZGVmcyk7XG5tb2R1bGUuZXhwb3J0cyA9IGRlZnM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHJvajQvbGliL2RlZnMuanNcbi8vIG1vZHVsZSBpZCA9IDYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("var proj4 = __webpack_require__(130);\nproj4.defaultDatum = 'WGS84'; //default datum\nproj4.Proj = __webpack_require__(32);\nproj4.WGS84 = new proj4.Proj('WGS84');\nproj4.Point = __webpack_require__(120);\nproj4.toPoint = __webpack_require__(61);\nproj4.defs = __webpack_require__(62);\nproj4.transform = __webpack_require__(66);\nproj4.mgrs = __webpack_require__(59);\nproj4.version = __webpack_require__(162).version;\n__webpack_require__(135)(proj4);\nmodule.exports = proj4;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9pbmRleC5qcz8xZDAxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjYzLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIHByb2o0ID0gcmVxdWlyZSgnLi9jb3JlJyk7XG5wcm9qNC5kZWZhdWx0RGF0dW0gPSAnV0dTODQnOyAvL2RlZmF1bHQgZGF0dW1cbnByb2o0LlByb2ogPSByZXF1aXJlKCcuL1Byb2onKTtcbnByb2o0LldHUzg0ID0gbmV3IHByb2o0LlByb2ooJ1dHUzg0Jyk7XG5wcm9qNC5Qb2ludCA9IHJlcXVpcmUoJy4vUG9pbnQnKTtcbnByb2o0LnRvUG9pbnQgPSByZXF1aXJlKFwiLi9jb21tb24vdG9Qb2ludFwiKTtcbnByb2o0LmRlZnMgPSByZXF1aXJlKCcuL2RlZnMnKTtcbnByb2o0LnRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vdHJhbnNmb3JtJyk7XG5wcm9qNC5tZ3JzID0gcmVxdWlyZSgnbWdycycpO1xucHJvajQudmVyc2lvbiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb247XG5yZXF1aXJlKCcuL2luY2x1ZGVkUHJvamVjdGlvbnMnKShwcm9qNCk7XG5tb2R1bGUuZXhwb3J0cyA9IHByb2o0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcm9qNC9saWIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("var D2R = 0.01745329251994329577;\nvar PrimeMeridian = __webpack_require__(128);\nvar units = __webpack_require__(129);\n\nmodule.exports = function(defData) {\n  var self = {};\n  var paramObj = {};\n  defData.split(\"+\").map(function(v) {\n    return v.trim();\n  }).filter(function(a) {\n    return a;\n  }).forEach(function(a) {\n    var split = a.split(\"=\");\n    split.push(true);\n    paramObj[split[0].toLowerCase()] = split[1];\n  });\n  var paramName, paramVal, paramOutname;\n  var params = {\n    proj: 'projName',\n    datum: 'datumCode',\n    rf: function(v) {\n      self.rf = parseFloat(v);\n    },\n    lat_0: function(v) {\n      self.lat0 = v * D2R;\n    },\n    lat_1: function(v) {\n      self.lat1 = v * D2R;\n    },\n    lat_2: function(v) {\n      self.lat2 = v * D2R;\n    },\n    lat_ts: function(v) {\n      self.lat_ts = v * D2R;\n    },\n    lon_0: function(v) {\n      self.long0 = v * D2R;\n    },\n    lon_1: function(v) {\n      self.long1 = v * D2R;\n    },\n    lon_2: function(v) {\n      self.long2 = v * D2R;\n    },\n    alpha: function(v) {\n      self.alpha = parseFloat(v) * D2R;\n    },\n    lonc: function(v) {\n      self.longc = v * D2R;\n    },\n    x_0: function(v) {\n      self.x0 = parseFloat(v);\n    },\n    y_0: function(v) {\n      self.y0 = parseFloat(v);\n    },\n    k_0: function(v) {\n      self.k0 = parseFloat(v);\n    },\n    k: function(v) {\n      self.k0 = parseFloat(v);\n    },\n    a: function(v) {\n      self.a = parseFloat(v);\n    },\n    b: function(v) {\n      self.b = parseFloat(v);\n    },\n    r_a: function() {\n      self.R_A = true;\n    },\n    zone: function(v) {\n      self.zone = parseInt(v, 10);\n    },\n    south: function() {\n      self.utmSouth = true;\n    },\n    towgs84: function(v) {\n      self.datum_params = v.split(\",\").map(function(a) {\n        return parseFloat(a);\n      });\n    },\n    to_meter: function(v) {\n      self.to_meter = parseFloat(v);\n    },\n    units: function(v) {\n      self.units = v;\n      if (units[v]) {\n        self.to_meter = units[v].to_meter;\n      }\n    },\n    from_greenwich: function(v) {\n      self.from_greenwich = v * D2R;\n    },\n    pm: function(v) {\n      self.from_greenwich = (PrimeMeridian[v] ? PrimeMeridian[v] : parseFloat(v)) * D2R;\n    },\n    nadgrids: function(v) {\n      if (v === '@null') {\n        self.datumCode = 'none';\n      }\n      else {\n        self.nadgrids = v;\n      }\n    },\n    axis: function(v) {\n      var legalAxis = \"ewnsud\";\n      if (v.length === 3 && legalAxis.indexOf(v.substr(0, 1)) !== -1 && legalAxis.indexOf(v.substr(1, 1)) !== -1 && legalAxis.indexOf(v.substr(2, 1)) !== -1) {\n        self.axis = v;\n      }\n    }\n  };\n  for (paramName in paramObj) {\n    paramVal = paramObj[paramName];\n    if (paramName in params) {\n      paramOutname = params[paramName];\n      if (typeof paramOutname === 'function') {\n        paramOutname(paramVal);\n      }\n      else {\n        self[paramOutname] = paramVal;\n      }\n    }\n    else {\n      self[paramName] = paramVal;\n    }\n  }\n  if(typeof self.datumCode === 'string' && self.datumCode !== \"WGS84\"){\n    self.datumCode = self.datumCode.toLowerCase();\n  }\n  return self;\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9wcm9qU3RyaW5nLmpzP2E1NjUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjY0LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIEQyUiA9IDAuMDE3NDUzMjkyNTE5OTQzMjk1Nzc7XG52YXIgUHJpbWVNZXJpZGlhbiA9IHJlcXVpcmUoJy4vY29uc3RhbnRzL1ByaW1lTWVyaWRpYW4nKTtcbnZhciB1bml0cyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzL3VuaXRzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZGVmRGF0YSkge1xuICB2YXIgc2VsZiA9IHt9O1xuICB2YXIgcGFyYW1PYmogPSB7fTtcbiAgZGVmRGF0YS5zcGxpdChcIitcIikubWFwKGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gdi50cmltKCk7XG4gIH0pLmZpbHRlcihmdW5jdGlvbihhKSB7XG4gICAgcmV0dXJuIGE7XG4gIH0pLmZvckVhY2goZnVuY3Rpb24oYSkge1xuICAgIHZhciBzcGxpdCA9IGEuc3BsaXQoXCI9XCIpO1xuICAgIHNwbGl0LnB1c2godHJ1ZSk7XG4gICAgcGFyYW1PYmpbc3BsaXRbMF0udG9Mb3dlckNhc2UoKV0gPSBzcGxpdFsxXTtcbiAgfSk7XG4gIHZhciBwYXJhbU5hbWUsIHBhcmFtVmFsLCBwYXJhbU91dG5hbWU7XG4gIHZhciBwYXJhbXMgPSB7XG4gICAgcHJvajogJ3Byb2pOYW1lJyxcbiAgICBkYXR1bTogJ2RhdHVtQ29kZScsXG4gICAgcmY6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHNlbGYucmYgPSBwYXJzZUZsb2F0KHYpO1xuICAgIH0sXG4gICAgbGF0XzA6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHNlbGYubGF0MCA9IHYgKiBEMlI7XG4gICAgfSxcbiAgICBsYXRfMTogZnVuY3Rpb24odikge1xuICAgICAgc2VsZi5sYXQxID0gdiAqIEQyUjtcbiAgICB9LFxuICAgIGxhdF8yOiBmdW5jdGlvbih2KSB7XG4gICAgICBzZWxmLmxhdDIgPSB2ICogRDJSO1xuICAgIH0sXG4gICAgbGF0X3RzOiBmdW5jdGlvbih2KSB7XG4gICAgICBzZWxmLmxhdF90cyA9IHYgKiBEMlI7XG4gICAgfSxcbiAgICBsb25fMDogZnVuY3Rpb24odikge1xuICAgICAgc2VsZi5sb25nMCA9IHYgKiBEMlI7XG4gICAgfSxcbiAgICBsb25fMTogZnVuY3Rpb24odikge1xuICAgICAgc2VsZi5sb25nMSA9IHYgKiBEMlI7XG4gICAgfSxcbiAgICBsb25fMjogZnVuY3Rpb24odikge1xuICAgICAgc2VsZi5sb25nMiA9IHYgKiBEMlI7XG4gICAgfSxcbiAgICBhbHBoYTogZnVuY3Rpb24odikge1xuICAgICAgc2VsZi5hbHBoYSA9IHBhcnNlRmxvYXQodikgKiBEMlI7XG4gICAgfSxcbiAgICBsb25jOiBmdW5jdGlvbih2KSB7XG4gICAgICBzZWxmLmxvbmdjID0gdiAqIEQyUjtcbiAgICB9LFxuICAgIHhfMDogZnVuY3Rpb24odikge1xuICAgICAgc2VsZi54MCA9IHBhcnNlRmxvYXQodik7XG4gICAgfSxcbiAgICB5XzA6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHNlbGYueTAgPSBwYXJzZUZsb2F0KHYpO1xuICAgIH0sXG4gICAga18wOiBmdW5jdGlvbih2KSB7XG4gICAgICBzZWxmLmswID0gcGFyc2VGbG9hdCh2KTtcbiAgICB9LFxuICAgIGs6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHNlbGYuazAgPSBwYXJzZUZsb2F0KHYpO1xuICAgIH0sXG4gICAgYTogZnVuY3Rpb24odikge1xuICAgICAgc2VsZi5hID0gcGFyc2VGbG9hdCh2KTtcbiAgICB9LFxuICAgIGI6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHNlbGYuYiA9IHBhcnNlRmxvYXQodik7XG4gICAgfSxcbiAgICByX2E6IGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5SX0EgPSB0cnVlO1xuICAgIH0sXG4gICAgem9uZTogZnVuY3Rpb24odikge1xuICAgICAgc2VsZi56b25lID0gcGFyc2VJbnQodiwgMTApO1xuICAgIH0sXG4gICAgc291dGg6IGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi51dG1Tb3V0aCA9IHRydWU7XG4gICAgfSxcbiAgICB0b3dnczg0OiBmdW5jdGlvbih2KSB7XG4gICAgICBzZWxmLmRhdHVtX3BhcmFtcyA9IHYuc3BsaXQoXCIsXCIpLm1hcChmdW5jdGlvbihhKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KGEpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICB0b19tZXRlcjogZnVuY3Rpb24odikge1xuICAgICAgc2VsZi50b19tZXRlciA9IHBhcnNlRmxvYXQodik7XG4gICAgfSxcbiAgICB1bml0czogZnVuY3Rpb24odikge1xuICAgICAgc2VsZi51bml0cyA9IHY7XG4gICAgICBpZiAodW5pdHNbdl0pIHtcbiAgICAgICAgc2VsZi50b19tZXRlciA9IHVuaXRzW3ZdLnRvX21ldGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgZnJvbV9ncmVlbndpY2g6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHNlbGYuZnJvbV9ncmVlbndpY2ggPSB2ICogRDJSO1xuICAgIH0sXG4gICAgcG06IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHNlbGYuZnJvbV9ncmVlbndpY2ggPSAoUHJpbWVNZXJpZGlhblt2XSA/IFByaW1lTWVyaWRpYW5bdl0gOiBwYXJzZUZsb2F0KHYpKSAqIEQyUjtcbiAgICB9LFxuICAgIG5hZGdyaWRzOiBmdW5jdGlvbih2KSB7XG4gICAgICBpZiAodiA9PT0gJ0BudWxsJykge1xuICAgICAgICBzZWxmLmRhdHVtQ29kZSA9ICdub25lJztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzZWxmLm5hZGdyaWRzID0gdjtcbiAgICAgIH1cbiAgICB9LFxuICAgIGF4aXM6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHZhciBsZWdhbEF4aXMgPSBcImV3bnN1ZFwiO1xuICAgICAgaWYgKHYubGVuZ3RoID09PSAzICYmIGxlZ2FsQXhpcy5pbmRleE9mKHYuc3Vic3RyKDAsIDEpKSAhPT0gLTEgJiYgbGVnYWxBeGlzLmluZGV4T2Yodi5zdWJzdHIoMSwgMSkpICE9PSAtMSAmJiBsZWdhbEF4aXMuaW5kZXhPZih2LnN1YnN0cigyLCAxKSkgIT09IC0xKSB7XG4gICAgICAgIHNlbGYuYXhpcyA9IHY7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBmb3IgKHBhcmFtTmFtZSBpbiBwYXJhbU9iaikge1xuICAgIHBhcmFtVmFsID0gcGFyYW1PYmpbcGFyYW1OYW1lXTtcbiAgICBpZiAocGFyYW1OYW1lIGluIHBhcmFtcykge1xuICAgICAgcGFyYW1PdXRuYW1lID0gcGFyYW1zW3BhcmFtTmFtZV07XG4gICAgICBpZiAodHlwZW9mIHBhcmFtT3V0bmFtZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwYXJhbU91dG5hbWUocGFyYW1WYWwpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHNlbGZbcGFyYW1PdXRuYW1lXSA9IHBhcmFtVmFsO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHNlbGZbcGFyYW1OYW1lXSA9IHBhcmFtVmFsO1xuICAgIH1cbiAgfVxuICBpZih0eXBlb2Ygc2VsZi5kYXR1bUNvZGUgPT09ICdzdHJpbmcnICYmIHNlbGYuZGF0dW1Db2RlICE9PSBcIldHUzg0XCIpe1xuICAgIHNlbGYuZGF0dW1Db2RlID0gc2VsZi5kYXR1bUNvZGUudG9Mb3dlckNhc2UoKTtcbiAgfVxuICByZXR1cm4gc2VsZjtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHJvajQvbGliL3Byb2pTdHJpbmcuanNcbi8vIG1vZHVsZSBpZCA9IDY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval('var e0fn = __webpack_require__(12);\nvar e1fn = __webpack_require__(13);\nvar e2fn = __webpack_require__(14);\nvar e3fn = __webpack_require__(15);\nvar mlfn = __webpack_require__(16);\nvar adjust_lon = __webpack_require__(0);\nvar HALF_PI = Math.PI/2;\nvar EPSLN = 1.0e-10;\nvar sign = __webpack_require__(17);\nvar asinz = __webpack_require__(7);\n\nexports.init = function() {\n  this.e0 = e0fn(this.es);\n  this.e1 = e1fn(this.es);\n  this.e2 = e2fn(this.es);\n  this.e3 = e3fn(this.es);\n  this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);\n};\n\n/**\n    Transverse Mercator Forward  - long/lat to x/y\n    long/lat in radians\n  */\nexports.forward = function(p) {\n  var lon = p.x;\n  var lat = p.y;\n\n  var delta_lon = adjust_lon(lon - this.long0);\n  var con;\n  var x, y;\n  var sin_phi = Math.sin(lat);\n  var cos_phi = Math.cos(lat);\n\n  if (this.sphere) {\n    var b = cos_phi * Math.sin(delta_lon);\n    if ((Math.abs(Math.abs(b) - 1)) < 0.0000000001) {\n      return (93);\n    }\n    else {\n      x = 0.5 * this.a * this.k0 * Math.log((1 + b) / (1 - b));\n      con = Math.acos(cos_phi * Math.cos(delta_lon) / Math.sqrt(1 - b * b));\n      if (lat < 0) {\n        con = -con;\n      }\n      y = this.a * this.k0 * (con - this.lat0);\n    }\n  }\n  else {\n    var al = cos_phi * delta_lon;\n    var als = Math.pow(al, 2);\n    var c = this.ep2 * Math.pow(cos_phi, 2);\n    var tq = Math.tan(lat);\n    var t = Math.pow(tq, 2);\n    con = 1 - this.es * Math.pow(sin_phi, 2);\n    var n = this.a / Math.sqrt(con);\n    var ml = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, lat);\n\n    x = this.k0 * n * al * (1 + als / 6 * (1 - t + c + als / 20 * (5 - 18 * t + Math.pow(t, 2) + 72 * c - 58 * this.ep2))) + this.x0;\n    y = this.k0 * (ml - this.ml0 + n * tq * (als * (0.5 + als / 24 * (5 - t + 9 * c + 4 * Math.pow(c, 2) + als / 30 * (61 - 58 * t + Math.pow(t, 2) + 600 * c - 330 * this.ep2))))) + this.y0;\n\n  }\n  p.x = x;\n  p.y = y;\n  return p;\n};\n\n/**\n    Transverse Mercator Inverse  -  x/y to long/lat\n  */\nexports.inverse = function(p) {\n  var con, phi;\n  var delta_phi;\n  var i;\n  var max_iter = 6;\n  var lat, lon;\n\n  if (this.sphere) {\n    var f = Math.exp(p.x / (this.a * this.k0));\n    var g = 0.5 * (f - 1 / f);\n    var temp = this.lat0 + p.y / (this.a * this.k0);\n    var h = Math.cos(temp);\n    con = Math.sqrt((1 - h * h) / (1 + g * g));\n    lat = asinz(con);\n    if (temp < 0) {\n      lat = -lat;\n    }\n    if ((g === 0) && (h === 0)) {\n      lon = this.long0;\n    }\n    else {\n      lon = adjust_lon(Math.atan2(g, h) + this.long0);\n    }\n  }\n  else { // ellipsoidal form\n    var x = p.x - this.x0;\n    var y = p.y - this.y0;\n\n    con = (this.ml0 + y / this.k0) / this.a;\n    phi = con;\n    for (i = 0; true; i++) {\n      delta_phi = ((con + this.e1 * Math.sin(2 * phi) - this.e2 * Math.sin(4 * phi) + this.e3 * Math.sin(6 * phi)) / this.e0) - phi;\n      phi += delta_phi;\n      if (Math.abs(delta_phi) <= EPSLN) {\n        break;\n      }\n      if (i >= max_iter) {\n        return (95);\n      }\n    } // for()\n    if (Math.abs(phi) < HALF_PI) {\n      var sin_phi = Math.sin(phi);\n      var cos_phi = Math.cos(phi);\n      var tan_phi = Math.tan(phi);\n      var c = this.ep2 * Math.pow(cos_phi, 2);\n      var cs = Math.pow(c, 2);\n      var t = Math.pow(tan_phi, 2);\n      var ts = Math.pow(t, 2);\n      con = 1 - this.es * Math.pow(sin_phi, 2);\n      var n = this.a / Math.sqrt(con);\n      var r = n * (1 - this.es) / con;\n      var d = x / (n * this.k0);\n      var ds = Math.pow(d, 2);\n      lat = phi - (n * tan_phi * ds / r) * (0.5 - ds / 24 * (5 + 3 * t + 10 * c - 4 * cs - 9 * this.ep2 - ds / 30 * (61 + 90 * t + 298 * c + 45 * ts - 252 * this.ep2 - 3 * cs)));\n      lon = adjust_lon(this.long0 + (d * (1 - ds / 6 * (1 + 2 * t + c - ds / 20 * (5 - 2 * c + 28 * t - 3 * cs + 8 * this.ep2 + 24 * ts))) / cos_phi));\n    }\n    else {\n      lat = HALF_PI * sign(y);\n      lon = this.long0;\n    }\n  }\n  p.x = lon;\n  p.y = lat;\n  return p;\n};\nexports.names = ["Transverse_Mercator", "Transverse Mercator", "tmerc"];\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9wcm9qZWN0aW9ucy90bWVyYy5qcz8wMGJkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI2NS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBlMGZuID0gcmVxdWlyZSgnLi4vY29tbW9uL2UwZm4nKTtcbnZhciBlMWZuID0gcmVxdWlyZSgnLi4vY29tbW9uL2UxZm4nKTtcbnZhciBlMmZuID0gcmVxdWlyZSgnLi4vY29tbW9uL2UyZm4nKTtcbnZhciBlM2ZuID0gcmVxdWlyZSgnLi4vY29tbW9uL2UzZm4nKTtcbnZhciBtbGZuID0gcmVxdWlyZSgnLi4vY29tbW9uL21sZm4nKTtcbnZhciBhZGp1c3RfbG9uID0gcmVxdWlyZSgnLi4vY29tbW9uL2FkanVzdF9sb24nKTtcbnZhciBIQUxGX1BJID0gTWF0aC5QSS8yO1xudmFyIEVQU0xOID0gMS4wZS0xMDtcbnZhciBzaWduID0gcmVxdWlyZSgnLi4vY29tbW9uL3NpZ24nKTtcbnZhciBhc2lueiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9hc2lueicpO1xuXG5leHBvcnRzLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lMCA9IGUwZm4odGhpcy5lcyk7XG4gIHRoaXMuZTEgPSBlMWZuKHRoaXMuZXMpO1xuICB0aGlzLmUyID0gZTJmbih0aGlzLmVzKTtcbiAgdGhpcy5lMyA9IGUzZm4odGhpcy5lcyk7XG4gIHRoaXMubWwwID0gdGhpcy5hICogbWxmbih0aGlzLmUwLCB0aGlzLmUxLCB0aGlzLmUyLCB0aGlzLmUzLCB0aGlzLmxhdDApO1xufTtcblxuLyoqXG4gICAgVHJhbnN2ZXJzZSBNZXJjYXRvciBGb3J3YXJkICAtIGxvbmcvbGF0IHRvIHgveVxuICAgIGxvbmcvbGF0IGluIHJhZGlhbnNcbiAgKi9cbmV4cG9ydHMuZm9yd2FyZCA9IGZ1bmN0aW9uKHApIHtcbiAgdmFyIGxvbiA9IHAueDtcbiAgdmFyIGxhdCA9IHAueTtcblxuICB2YXIgZGVsdGFfbG9uID0gYWRqdXN0X2xvbihsb24gLSB0aGlzLmxvbmcwKTtcbiAgdmFyIGNvbjtcbiAgdmFyIHgsIHk7XG4gIHZhciBzaW5fcGhpID0gTWF0aC5zaW4obGF0KTtcbiAgdmFyIGNvc19waGkgPSBNYXRoLmNvcyhsYXQpO1xuXG4gIGlmICh0aGlzLnNwaGVyZSkge1xuICAgIHZhciBiID0gY29zX3BoaSAqIE1hdGguc2luKGRlbHRhX2xvbik7XG4gICAgaWYgKChNYXRoLmFicyhNYXRoLmFicyhiKSAtIDEpKSA8IDAuMDAwMDAwMDAwMSkge1xuICAgICAgcmV0dXJuICg5Myk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgeCA9IDAuNSAqIHRoaXMuYSAqIHRoaXMuazAgKiBNYXRoLmxvZygoMSArIGIpIC8gKDEgLSBiKSk7XG4gICAgICBjb24gPSBNYXRoLmFjb3MoY29zX3BoaSAqIE1hdGguY29zKGRlbHRhX2xvbikgLyBNYXRoLnNxcnQoMSAtIGIgKiBiKSk7XG4gICAgICBpZiAobGF0IDwgMCkge1xuICAgICAgICBjb24gPSAtY29uO1xuICAgICAgfVxuICAgICAgeSA9IHRoaXMuYSAqIHRoaXMuazAgKiAoY29uIC0gdGhpcy5sYXQwKTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgdmFyIGFsID0gY29zX3BoaSAqIGRlbHRhX2xvbjtcbiAgICB2YXIgYWxzID0gTWF0aC5wb3coYWwsIDIpO1xuICAgIHZhciBjID0gdGhpcy5lcDIgKiBNYXRoLnBvdyhjb3NfcGhpLCAyKTtcbiAgICB2YXIgdHEgPSBNYXRoLnRhbihsYXQpO1xuICAgIHZhciB0ID0gTWF0aC5wb3codHEsIDIpO1xuICAgIGNvbiA9IDEgLSB0aGlzLmVzICogTWF0aC5wb3coc2luX3BoaSwgMik7XG4gICAgdmFyIG4gPSB0aGlzLmEgLyBNYXRoLnNxcnQoY29uKTtcbiAgICB2YXIgbWwgPSB0aGlzLmEgKiBtbGZuKHRoaXMuZTAsIHRoaXMuZTEsIHRoaXMuZTIsIHRoaXMuZTMsIGxhdCk7XG5cbiAgICB4ID0gdGhpcy5rMCAqIG4gKiBhbCAqICgxICsgYWxzIC8gNiAqICgxIC0gdCArIGMgKyBhbHMgLyAyMCAqICg1IC0gMTggKiB0ICsgTWF0aC5wb3codCwgMikgKyA3MiAqIGMgLSA1OCAqIHRoaXMuZXAyKSkpICsgdGhpcy54MDtcbiAgICB5ID0gdGhpcy5rMCAqIChtbCAtIHRoaXMubWwwICsgbiAqIHRxICogKGFscyAqICgwLjUgKyBhbHMgLyAyNCAqICg1IC0gdCArIDkgKiBjICsgNCAqIE1hdGgucG93KGMsIDIpICsgYWxzIC8gMzAgKiAoNjEgLSA1OCAqIHQgKyBNYXRoLnBvdyh0LCAyKSArIDYwMCAqIGMgLSAzMzAgKiB0aGlzLmVwMikpKSkpICsgdGhpcy55MDtcblxuICB9XG4gIHAueCA9IHg7XG4gIHAueSA9IHk7XG4gIHJldHVybiBwO1xufTtcblxuLyoqXG4gICAgVHJhbnN2ZXJzZSBNZXJjYXRvciBJbnZlcnNlICAtICB4L3kgdG8gbG9uZy9sYXRcbiAgKi9cbmV4cG9ydHMuaW52ZXJzZSA9IGZ1bmN0aW9uKHApIHtcbiAgdmFyIGNvbiwgcGhpO1xuICB2YXIgZGVsdGFfcGhpO1xuICB2YXIgaTtcbiAgdmFyIG1heF9pdGVyID0gNjtcbiAgdmFyIGxhdCwgbG9uO1xuXG4gIGlmICh0aGlzLnNwaGVyZSkge1xuICAgIHZhciBmID0gTWF0aC5leHAocC54IC8gKHRoaXMuYSAqIHRoaXMuazApKTtcbiAgICB2YXIgZyA9IDAuNSAqIChmIC0gMSAvIGYpO1xuICAgIHZhciB0ZW1wID0gdGhpcy5sYXQwICsgcC55IC8gKHRoaXMuYSAqIHRoaXMuazApO1xuICAgIHZhciBoID0gTWF0aC5jb3ModGVtcCk7XG4gICAgY29uID0gTWF0aC5zcXJ0KCgxIC0gaCAqIGgpIC8gKDEgKyBnICogZykpO1xuICAgIGxhdCA9IGFzaW56KGNvbik7XG4gICAgaWYgKHRlbXAgPCAwKSB7XG4gICAgICBsYXQgPSAtbGF0O1xuICAgIH1cbiAgICBpZiAoKGcgPT09IDApICYmIChoID09PSAwKSkge1xuICAgICAgbG9uID0gdGhpcy5sb25nMDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBsb24gPSBhZGp1c3RfbG9uKE1hdGguYXRhbjIoZywgaCkgKyB0aGlzLmxvbmcwKTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7IC8vIGVsbGlwc29pZGFsIGZvcm1cbiAgICB2YXIgeCA9IHAueCAtIHRoaXMueDA7XG4gICAgdmFyIHkgPSBwLnkgLSB0aGlzLnkwO1xuXG4gICAgY29uID0gKHRoaXMubWwwICsgeSAvIHRoaXMuazApIC8gdGhpcy5hO1xuICAgIHBoaSA9IGNvbjtcbiAgICBmb3IgKGkgPSAwOyB0cnVlOyBpKyspIHtcbiAgICAgIGRlbHRhX3BoaSA9ICgoY29uICsgdGhpcy5lMSAqIE1hdGguc2luKDIgKiBwaGkpIC0gdGhpcy5lMiAqIE1hdGguc2luKDQgKiBwaGkpICsgdGhpcy5lMyAqIE1hdGguc2luKDYgKiBwaGkpKSAvIHRoaXMuZTApIC0gcGhpO1xuICAgICAgcGhpICs9IGRlbHRhX3BoaTtcbiAgICAgIGlmIChNYXRoLmFicyhkZWx0YV9waGkpIDw9IEVQU0xOKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGkgPj0gbWF4X2l0ZXIpIHtcbiAgICAgICAgcmV0dXJuICg5NSk7XG4gICAgICB9XG4gICAgfSAvLyBmb3IoKVxuICAgIGlmIChNYXRoLmFicyhwaGkpIDwgSEFMRl9QSSkge1xuICAgICAgdmFyIHNpbl9waGkgPSBNYXRoLnNpbihwaGkpO1xuICAgICAgdmFyIGNvc19waGkgPSBNYXRoLmNvcyhwaGkpO1xuICAgICAgdmFyIHRhbl9waGkgPSBNYXRoLnRhbihwaGkpO1xuICAgICAgdmFyIGMgPSB0aGlzLmVwMiAqIE1hdGgucG93KGNvc19waGksIDIpO1xuICAgICAgdmFyIGNzID0gTWF0aC5wb3coYywgMik7XG4gICAgICB2YXIgdCA9IE1hdGgucG93KHRhbl9waGksIDIpO1xuICAgICAgdmFyIHRzID0gTWF0aC5wb3codCwgMik7XG4gICAgICBjb24gPSAxIC0gdGhpcy5lcyAqIE1hdGgucG93KHNpbl9waGksIDIpO1xuICAgICAgdmFyIG4gPSB0aGlzLmEgLyBNYXRoLnNxcnQoY29uKTtcbiAgICAgIHZhciByID0gbiAqICgxIC0gdGhpcy5lcykgLyBjb247XG4gICAgICB2YXIgZCA9IHggLyAobiAqIHRoaXMuazApO1xuICAgICAgdmFyIGRzID0gTWF0aC5wb3coZCwgMik7XG4gICAgICBsYXQgPSBwaGkgLSAobiAqIHRhbl9waGkgKiBkcyAvIHIpICogKDAuNSAtIGRzIC8gMjQgKiAoNSArIDMgKiB0ICsgMTAgKiBjIC0gNCAqIGNzIC0gOSAqIHRoaXMuZXAyIC0gZHMgLyAzMCAqICg2MSArIDkwICogdCArIDI5OCAqIGMgKyA0NSAqIHRzIC0gMjUyICogdGhpcy5lcDIgLSAzICogY3MpKSk7XG4gICAgICBsb24gPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgKyAoZCAqICgxIC0gZHMgLyA2ICogKDEgKyAyICogdCArIGMgLSBkcyAvIDIwICogKDUgLSAyICogYyArIDI4ICogdCAtIDMgKiBjcyArIDggKiB0aGlzLmVwMiArIDI0ICogdHMpKSkgLyBjb3NfcGhpKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgbGF0ID0gSEFMRl9QSSAqIHNpZ24oeSk7XG4gICAgICBsb24gPSB0aGlzLmxvbmcwO1xuICAgIH1cbiAgfVxuICBwLnggPSBsb247XG4gIHAueSA9IGxhdDtcbiAgcmV0dXJuIHA7XG59O1xuZXhwb3J0cy5uYW1lcyA9IFtcIlRyYW5zdmVyc2VfTWVyY2F0b3JcIiwgXCJUcmFuc3ZlcnNlIE1lcmNhdG9yXCIsIFwidG1lcmNcIl07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHJvajQvbGliL3Byb2plY3Rpb25zL3RtZXJjLmpzXG4vLyBtb2R1bGUgaWQgPSA2NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9')},function(module,exports,__webpack_require__){eval('var D2R = 0.01745329251994329577;\nvar R2D = 57.29577951308232088;\nvar PJD_3PARAM = 1;\nvar PJD_7PARAM = 2;\nvar datum_transform = __webpack_require__(132);\nvar adjust_axis = __webpack_require__(121);\nvar proj = __webpack_require__(32);\nvar toPoint = __webpack_require__(61);\nmodule.exports = function transform(source, dest, point) {\n  var wgs84;\n  if (Array.isArray(point)) {\n    point = toPoint(point);\n  }\n  function checkNotWGS(source, dest) {\n    return ((source.datum.datum_type === PJD_3PARAM || source.datum.datum_type === PJD_7PARAM) && dest.datumCode !== "WGS84");\n  }\n\n  // Workaround for datum shifts towgs84, if either source or destination projection is not wgs84\n  if (source.datum && dest.datum && (checkNotWGS(source, dest) || checkNotWGS(dest, source))) {\n    wgs84 = new proj(\'WGS84\');\n    transform(source, wgs84, point);\n    source = wgs84;\n  }\n  // DGR, 2010/11/12\n  if (source.axis !== "enu") {\n    adjust_axis(source, false, point);\n  }\n  // Transform source points to long/lat, if they aren\'t already.\n  if (source.projName === "longlat") {\n    point.x *= D2R; // convert degrees to radians\n    point.y *= D2R;\n  }\n  else {\n    if (source.to_meter) {\n      point.x *= source.to_meter;\n      point.y *= source.to_meter;\n    }\n    source.inverse(point); // Convert Cartesian to longlat\n  }\n  // Adjust for the prime meridian if necessary\n  if (source.from_greenwich) {\n    point.x += source.from_greenwich;\n  }\n\n  // Convert datums if needed, and if possible.\n  point = datum_transform(source.datum, dest.datum, point);\n\n  // Adjust for the prime meridian if necessary\n  if (dest.from_greenwich) {\n    point.x -= dest.from_greenwich;\n  }\n\n  if (dest.projName === "longlat") {\n    // convert radians to decimal degrees\n    point.x *= R2D;\n    point.y *= R2D;\n  }\n  else { // else project\n    dest.forward(point);\n    if (dest.to_meter) {\n      point.x /= dest.to_meter;\n      point.y /= dest.to_meter;\n    }\n  }\n\n  // DGR, 2010/11/12\n  if (dest.axis !== "enu") {\n    adjust_axis(dest, true, point);\n  }\n\n  return point;\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi90cmFuc2Zvcm0uanM/NDBlYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJmaWxlIjoiNjYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgRDJSID0gMC4wMTc0NTMyOTI1MTk5NDMyOTU3NztcbnZhciBSMkQgPSA1Ny4yOTU3Nzk1MTMwODIzMjA4ODtcbnZhciBQSkRfM1BBUkFNID0gMTtcbnZhciBQSkRfN1BBUkFNID0gMjtcbnZhciBkYXR1bV90cmFuc2Zvcm0gPSByZXF1aXJlKCcuL2RhdHVtX3RyYW5zZm9ybScpO1xudmFyIGFkanVzdF9heGlzID0gcmVxdWlyZSgnLi9hZGp1c3RfYXhpcycpO1xudmFyIHByb2ogPSByZXF1aXJlKCcuL1Byb2onKTtcbnZhciB0b1BvaW50ID0gcmVxdWlyZSgnLi9jb21tb24vdG9Qb2ludCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0cmFuc2Zvcm0oc291cmNlLCBkZXN0LCBwb2ludCkge1xuICB2YXIgd2dzODQ7XG4gIGlmIChBcnJheS5pc0FycmF5KHBvaW50KSkge1xuICAgIHBvaW50ID0gdG9Qb2ludChwb2ludCk7XG4gIH1cbiAgZnVuY3Rpb24gY2hlY2tOb3RXR1Moc291cmNlLCBkZXN0KSB7XG4gICAgcmV0dXJuICgoc291cmNlLmRhdHVtLmRhdHVtX3R5cGUgPT09IFBKRF8zUEFSQU0gfHwgc291cmNlLmRhdHVtLmRhdHVtX3R5cGUgPT09IFBKRF83UEFSQU0pICYmIGRlc3QuZGF0dW1Db2RlICE9PSBcIldHUzg0XCIpO1xuICB9XG5cbiAgLy8gV29ya2Fyb3VuZCBmb3IgZGF0dW0gc2hpZnRzIHRvd2dzODQsIGlmIGVpdGhlciBzb3VyY2Ugb3IgZGVzdGluYXRpb24gcHJvamVjdGlvbiBpcyBub3Qgd2dzODRcbiAgaWYgKHNvdXJjZS5kYXR1bSAmJiBkZXN0LmRhdHVtICYmIChjaGVja05vdFdHUyhzb3VyY2UsIGRlc3QpIHx8IGNoZWNrTm90V0dTKGRlc3QsIHNvdXJjZSkpKSB7XG4gICAgd2dzODQgPSBuZXcgcHJvaignV0dTODQnKTtcbiAgICB0cmFuc2Zvcm0oc291cmNlLCB3Z3M4NCwgcG9pbnQpO1xuICAgIHNvdXJjZSA9IHdnczg0O1xuICB9XG4gIC8vIERHUiwgMjAxMC8xMS8xMlxuICBpZiAoc291cmNlLmF4aXMgIT09IFwiZW51XCIpIHtcbiAgICBhZGp1c3RfYXhpcyhzb3VyY2UsIGZhbHNlLCBwb2ludCk7XG4gIH1cbiAgLy8gVHJhbnNmb3JtIHNvdXJjZSBwb2ludHMgdG8gbG9uZy9sYXQsIGlmIHRoZXkgYXJlbid0IGFscmVhZHkuXG4gIGlmIChzb3VyY2UucHJvak5hbWUgPT09IFwibG9uZ2xhdFwiKSB7XG4gICAgcG9pbnQueCAqPSBEMlI7IC8vIGNvbnZlcnQgZGVncmVlcyB0byByYWRpYW5zXG4gICAgcG9pbnQueSAqPSBEMlI7XG4gIH1cbiAgZWxzZSB7XG4gICAgaWYgKHNvdXJjZS50b19tZXRlcikge1xuICAgICAgcG9pbnQueCAqPSBzb3VyY2UudG9fbWV0ZXI7XG4gICAgICBwb2ludC55ICo9IHNvdXJjZS50b19tZXRlcjtcbiAgICB9XG4gICAgc291cmNlLmludmVyc2UocG9pbnQpOyAvLyBDb252ZXJ0IENhcnRlc2lhbiB0byBsb25nbGF0XG4gIH1cbiAgLy8gQWRqdXN0IGZvciB0aGUgcHJpbWUgbWVyaWRpYW4gaWYgbmVjZXNzYXJ5XG4gIGlmIChzb3VyY2UuZnJvbV9ncmVlbndpY2gpIHtcbiAgICBwb2ludC54ICs9IHNvdXJjZS5mcm9tX2dyZWVud2ljaDtcbiAgfVxuXG4gIC8vIENvbnZlcnQgZGF0dW1zIGlmIG5lZWRlZCwgYW5kIGlmIHBvc3NpYmxlLlxuICBwb2ludCA9IGRhdHVtX3RyYW5zZm9ybShzb3VyY2UuZGF0dW0sIGRlc3QuZGF0dW0sIHBvaW50KTtcblxuICAvLyBBZGp1c3QgZm9yIHRoZSBwcmltZSBtZXJpZGlhbiBpZiBuZWNlc3NhcnlcbiAgaWYgKGRlc3QuZnJvbV9ncmVlbndpY2gpIHtcbiAgICBwb2ludC54IC09IGRlc3QuZnJvbV9ncmVlbndpY2g7XG4gIH1cblxuICBpZiAoZGVzdC5wcm9qTmFtZSA9PT0gXCJsb25nbGF0XCIpIHtcbiAgICAvLyBjb252ZXJ0IHJhZGlhbnMgdG8gZGVjaW1hbCBkZWdyZWVzXG4gICAgcG9pbnQueCAqPSBSMkQ7XG4gICAgcG9pbnQueSAqPSBSMkQ7XG4gIH1cbiAgZWxzZSB7IC8vIGVsc2UgcHJvamVjdFxuICAgIGRlc3QuZm9yd2FyZChwb2ludCk7XG4gICAgaWYgKGRlc3QudG9fbWV0ZXIpIHtcbiAgICAgIHBvaW50LnggLz0gZGVzdC50b19tZXRlcjtcbiAgICAgIHBvaW50LnkgLz0gZGVzdC50b19tZXRlcjtcbiAgICB9XG4gIH1cblxuICAvLyBER1IsIDIwMTAvMTEvMTJcbiAgaWYgKGRlc3QuYXhpcyAhPT0gXCJlbnVcIikge1xuICAgIGFkanVzdF9heGlzKGRlc3QsIHRydWUsIHBvaW50KTtcbiAgfVxuXG4gIHJldHVybiBwb2ludDtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Byb2o0L2xpYi90cmFuc2Zvcm0uanNcbi8vIG1vZHVsZSBpZCA9IDY2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,exports,__webpack_require__){eval("var D2R = 0.01745329251994329577;\nvar extend = __webpack_require__(36);\n\nfunction mapit(obj, key, v) {\n  obj[key] = v.map(function(aa) {\n    var o = {};\n    sExpr(aa, o);\n    return o;\n  }).reduce(function(a, b) {\n    return extend(a, b);\n  }, {});\n}\n\nfunction sExpr(v, obj) {\n  var key;\n  if (!Array.isArray(v)) {\n    obj[v] = true;\n    return;\n  }\n  else {\n    key = v.shift();\n    if (key === 'PARAMETER') {\n      key = v.shift();\n    }\n    if (v.length === 1) {\n      if (Array.isArray(v[0])) {\n        obj[key] = {};\n        sExpr(v[0], obj[key]);\n      }\n      else {\n        obj[key] = v[0];\n      }\n    }\n    else if (!v.length) {\n      obj[key] = true;\n    }\n    else if (key === 'TOWGS84') {\n      obj[key] = v;\n    }\n    else {\n      obj[key] = {};\n      if (['UNIT', 'PRIMEM', 'VERT_DATUM'].indexOf(key) > -1) {\n        obj[key] = {\n          name: v[0].toLowerCase(),\n          convert: v[1]\n        };\n        if (v.length === 3) {\n          obj[key].auth = v[2];\n        }\n      }\n      else if (key === 'SPHEROID') {\n        obj[key] = {\n          name: v[0],\n          a: v[1],\n          rf: v[2]\n        };\n        if (v.length === 4) {\n          obj[key].auth = v[3];\n        }\n      }\n      else if (['GEOGCS', 'GEOCCS', 'DATUM', 'VERT_CS', 'COMPD_CS', 'LOCAL_CS', 'FITTED_CS', 'LOCAL_DATUM'].indexOf(key) > -1) {\n        v[0] = ['name', v[0]];\n        mapit(obj, key, v);\n      }\n      else if (v.every(function(aa) {\n        return Array.isArray(aa);\n      })) {\n        mapit(obj, key, v);\n      }\n      else {\n        sExpr(v, obj[key]);\n      }\n    }\n  }\n}\n\nfunction rename(obj, params) {\n  var outName = params[0];\n  var inName = params[1];\n  if (!(outName in obj) && (inName in obj)) {\n    obj[outName] = obj[inName];\n    if (params.length === 3) {\n      obj[outName] = params[2](obj[outName]);\n    }\n  }\n}\n\nfunction d2r(input) {\n  return input * D2R;\n}\n\nfunction cleanWKT(wkt) {\n  if (wkt.type === 'GEOGCS') {\n    wkt.projName = 'longlat';\n  }\n  else if (wkt.type === 'LOCAL_CS') {\n    wkt.projName = 'identity';\n    wkt.local = true;\n  }\n  else {\n    if (typeof wkt.PROJECTION === \"object\") {\n      wkt.projName = Object.keys(wkt.PROJECTION)[0];\n    }\n    else {\n      wkt.projName = wkt.PROJECTION;\n    }\n  }\n  if (wkt.UNIT) {\n    wkt.units = wkt.UNIT.name.toLowerCase();\n    if (wkt.units === 'metre') {\n      wkt.units = 'meter';\n    }\n    if (wkt.UNIT.convert) {\n      if (wkt.type === 'GEOGCS') {\n        if (wkt.DATUM && wkt.DATUM.SPHEROID) {\n          wkt.to_meter = parseFloat(wkt.UNIT.convert, 10)*wkt.DATUM.SPHEROID.a;\n        }\n      } else {\n        wkt.to_meter = parseFloat(wkt.UNIT.convert, 10);\n      }\n    }\n  }\n\n  if (wkt.GEOGCS) {\n    //if(wkt.GEOGCS.PRIMEM&&wkt.GEOGCS.PRIMEM.convert){\n    //  wkt.from_greenwich=wkt.GEOGCS.PRIMEM.convert*D2R;\n    //}\n    if (wkt.GEOGCS.DATUM) {\n      wkt.datumCode = wkt.GEOGCS.DATUM.name.toLowerCase();\n    }\n    else {\n      wkt.datumCode = wkt.GEOGCS.name.toLowerCase();\n    }\n    if (wkt.datumCode.slice(0, 2) === 'd_') {\n      wkt.datumCode = wkt.datumCode.slice(2);\n    }\n    if (wkt.datumCode === 'new_zealand_geodetic_datum_1949' || wkt.datumCode === 'new_zealand_1949') {\n      wkt.datumCode = 'nzgd49';\n    }\n    if (wkt.datumCode === \"wgs_1984\") {\n      if (wkt.PROJECTION === 'Mercator_Auxiliary_Sphere') {\n        wkt.sphere = true;\n      }\n      wkt.datumCode = 'wgs84';\n    }\n    if (wkt.datumCode.slice(-6) === '_ferro') {\n      wkt.datumCode = wkt.datumCode.slice(0, - 6);\n    }\n    if (wkt.datumCode.slice(-8) === '_jakarta') {\n      wkt.datumCode = wkt.datumCode.slice(0, - 8);\n    }\n    if (~wkt.datumCode.indexOf('belge')) {\n      wkt.datumCode = \"rnb72\";\n    }\n    if (wkt.GEOGCS.DATUM && wkt.GEOGCS.DATUM.SPHEROID) {\n      wkt.ellps = wkt.GEOGCS.DATUM.SPHEROID.name.replace('_19', '').replace(/[Cc]larke\\_18/, 'clrk');\n      if (wkt.ellps.toLowerCase().slice(0, 13) === \"international\") {\n        wkt.ellps = 'intl';\n      }\n\n      wkt.a = wkt.GEOGCS.DATUM.SPHEROID.a;\n      wkt.rf = parseFloat(wkt.GEOGCS.DATUM.SPHEROID.rf, 10);\n    }\n    if (~wkt.datumCode.indexOf('osgb_1936')) {\n      wkt.datumCode = \"osgb36\";\n    }\n  }\n  if (wkt.b && !isFinite(wkt.b)) {\n    wkt.b = wkt.a;\n  }\n\n  function toMeter(input) {\n    var ratio = wkt.to_meter || 1;\n    return parseFloat(input, 10) * ratio;\n  }\n  var renamer = function(a) {\n    return rename(wkt, a);\n  };\n  var list = [\n    ['standard_parallel_1', 'Standard_Parallel_1'],\n    ['standard_parallel_2', 'Standard_Parallel_2'],\n    ['false_easting', 'False_Easting'],\n    ['false_northing', 'False_Northing'],\n    ['central_meridian', 'Central_Meridian'],\n    ['latitude_of_origin', 'Latitude_Of_Origin'],\n    ['latitude_of_origin', 'Central_Parallel'],\n    ['scale_factor', 'Scale_Factor'],\n    ['k0', 'scale_factor'],\n    ['latitude_of_center', 'Latitude_of_center'],\n    ['lat0', 'latitude_of_center', d2r],\n    ['longitude_of_center', 'Longitude_Of_Center'],\n    ['longc', 'longitude_of_center', d2r],\n    ['x0', 'false_easting', toMeter],\n    ['y0', 'false_northing', toMeter],\n    ['long0', 'central_meridian', d2r],\n    ['lat0', 'latitude_of_origin', d2r],\n    ['lat0', 'standard_parallel_1', d2r],\n    ['lat1', 'standard_parallel_1', d2r],\n    ['lat2', 'standard_parallel_2', d2r],\n    ['alpha', 'azimuth', d2r],\n    ['srsCode', 'name']\n  ];\n  list.forEach(renamer);\n  if (!wkt.long0 && wkt.longc && (wkt.projName === 'Albers_Conic_Equal_Area' || wkt.projName === \"Lambert_Azimuthal_Equal_Area\")) {\n    wkt.long0 = wkt.longc;\n  }\n  if (!wkt.lat_ts && wkt.lat1 && (wkt.projName === 'Stereographic_South_Pole' || wkt.projName === 'Polar Stereographic (variant B)')) {\n    wkt.lat0 = d2r(wkt.lat1 > 0 ? 90 : -90);\n    wkt.lat_ts = wkt.lat1;\n  }\n}\nmodule.exports = function(wkt, self) {\n  var lisp = JSON.parse((\",\" + wkt).replace(/\\s*\\,\\s*([A-Z_0-9]+?)(\\[)/g, ',[\"$1\",').slice(1).replace(/\\s*\\,\\s*([A-Z_0-9]+?)\\]/g, ',\"$1\"]').replace(/,\\[\"VERTCS\".+/,''));\n  var type = lisp.shift();\n  var name = lisp.shift();\n  lisp.unshift(['name', name]);\n  lisp.unshift(['type', type]);\n  lisp.unshift('output');\n  var obj = {};\n  sExpr(lisp, obj);\n  cleanWKT(obj.output);\n  return extend(self, obj.output);\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi93a3QuanM/MWE1NiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHLElBQUk7QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjY3LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIEQyUiA9IDAuMDE3NDUzMjkyNTE5OTQzMjk1Nzc7XG52YXIgZXh0ZW5kID0gcmVxdWlyZSgnLi9leHRlbmQnKTtcblxuZnVuY3Rpb24gbWFwaXQob2JqLCBrZXksIHYpIHtcbiAgb2JqW2tleV0gPSB2Lm1hcChmdW5jdGlvbihhYSkge1xuICAgIHZhciBvID0ge307XG4gICAgc0V4cHIoYWEsIG8pO1xuICAgIHJldHVybiBvO1xuICB9KS5yZWR1Y2UoZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBleHRlbmQoYSwgYik7XG4gIH0sIHt9KTtcbn1cblxuZnVuY3Rpb24gc0V4cHIodiwgb2JqKSB7XG4gIHZhciBrZXk7XG4gIGlmICghQXJyYXkuaXNBcnJheSh2KSkge1xuICAgIG9ialt2XSA9IHRydWU7XG4gICAgcmV0dXJuO1xuICB9XG4gIGVsc2Uge1xuICAgIGtleSA9IHYuc2hpZnQoKTtcbiAgICBpZiAoa2V5ID09PSAnUEFSQU1FVEVSJykge1xuICAgICAga2V5ID0gdi5zaGlmdCgpO1xuICAgIH1cbiAgICBpZiAodi5sZW5ndGggPT09IDEpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZbMF0pKSB7XG4gICAgICAgIG9ialtrZXldID0ge307XG4gICAgICAgIHNFeHByKHZbMF0sIG9ialtrZXldKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBvYmpba2V5XSA9IHZbMF07XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKCF2Lmxlbmd0aCkge1xuICAgICAgb2JqW2tleV0gPSB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChrZXkgPT09ICdUT1dHUzg0Jykge1xuICAgICAgb2JqW2tleV0gPSB2O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIG9ialtrZXldID0ge307XG4gICAgICBpZiAoWydVTklUJywgJ1BSSU1FTScsICdWRVJUX0RBVFVNJ10uaW5kZXhPZihrZXkpID4gLTEpIHtcbiAgICAgICAgb2JqW2tleV0gPSB7XG4gICAgICAgICAgbmFtZTogdlswXS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgIGNvbnZlcnQ6IHZbMV1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHYubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgb2JqW2tleV0uYXV0aCA9IHZbMl07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ1NQSEVST0lEJykge1xuICAgICAgICBvYmpba2V5XSA9IHtcbiAgICAgICAgICBuYW1lOiB2WzBdLFxuICAgICAgICAgIGE6IHZbMV0sXG4gICAgICAgICAgcmY6IHZbMl1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHYubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgb2JqW2tleV0uYXV0aCA9IHZbM107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKFsnR0VPR0NTJywgJ0dFT0NDUycsICdEQVRVTScsICdWRVJUX0NTJywgJ0NPTVBEX0NTJywgJ0xPQ0FMX0NTJywgJ0ZJVFRFRF9DUycsICdMT0NBTF9EQVRVTSddLmluZGV4T2Yoa2V5KSA+IC0xKSB7XG4gICAgICAgIHZbMF0gPSBbJ25hbWUnLCB2WzBdXTtcbiAgICAgICAgbWFwaXQob2JqLCBrZXksIHYpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodi5ldmVyeShmdW5jdGlvbihhYSkge1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhYSk7XG4gICAgICB9KSkge1xuICAgICAgICBtYXBpdChvYmosIGtleSwgdik7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc0V4cHIodiwgb2JqW2tleV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZW5hbWUob2JqLCBwYXJhbXMpIHtcbiAgdmFyIG91dE5hbWUgPSBwYXJhbXNbMF07XG4gIHZhciBpbk5hbWUgPSBwYXJhbXNbMV07XG4gIGlmICghKG91dE5hbWUgaW4gb2JqKSAmJiAoaW5OYW1lIGluIG9iaikpIHtcbiAgICBvYmpbb3V0TmFtZV0gPSBvYmpbaW5OYW1lXTtcbiAgICBpZiAocGFyYW1zLmxlbmd0aCA9PT0gMykge1xuICAgICAgb2JqW291dE5hbWVdID0gcGFyYW1zWzJdKG9ialtvdXROYW1lXSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGQycihpbnB1dCkge1xuICByZXR1cm4gaW5wdXQgKiBEMlI7XG59XG5cbmZ1bmN0aW9uIGNsZWFuV0tUKHdrdCkge1xuICBpZiAod2t0LnR5cGUgPT09ICdHRU9HQ1MnKSB7XG4gICAgd2t0LnByb2pOYW1lID0gJ2xvbmdsYXQnO1xuICB9XG4gIGVsc2UgaWYgKHdrdC50eXBlID09PSAnTE9DQUxfQ1MnKSB7XG4gICAgd2t0LnByb2pOYW1lID0gJ2lkZW50aXR5JztcbiAgICB3a3QubG9jYWwgPSB0cnVlO1xuICB9XG4gIGVsc2Uge1xuICAgIGlmICh0eXBlb2Ygd2t0LlBST0pFQ1RJT04gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHdrdC5wcm9qTmFtZSA9IE9iamVjdC5rZXlzKHdrdC5QUk9KRUNUSU9OKVswXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB3a3QucHJvak5hbWUgPSB3a3QuUFJPSkVDVElPTjtcbiAgICB9XG4gIH1cbiAgaWYgKHdrdC5VTklUKSB7XG4gICAgd2t0LnVuaXRzID0gd2t0LlVOSVQubmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmICh3a3QudW5pdHMgPT09ICdtZXRyZScpIHtcbiAgICAgIHdrdC51bml0cyA9ICdtZXRlcic7XG4gICAgfVxuICAgIGlmICh3a3QuVU5JVC5jb252ZXJ0KSB7XG4gICAgICBpZiAod2t0LnR5cGUgPT09ICdHRU9HQ1MnKSB7XG4gICAgICAgIGlmICh3a3QuREFUVU0gJiYgd2t0LkRBVFVNLlNQSEVST0lEKSB7XG4gICAgICAgICAgd2t0LnRvX21ldGVyID0gcGFyc2VGbG9hdCh3a3QuVU5JVC5jb252ZXJ0LCAxMCkqd2t0LkRBVFVNLlNQSEVST0lELmE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdrdC50b19tZXRlciA9IHBhcnNlRmxvYXQod2t0LlVOSVQuY29udmVydCwgMTApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh3a3QuR0VPR0NTKSB7XG4gICAgLy9pZih3a3QuR0VPR0NTLlBSSU1FTSYmd2t0LkdFT0dDUy5QUklNRU0uY29udmVydCl7XG4gICAgLy8gIHdrdC5mcm9tX2dyZWVud2ljaD13a3QuR0VPR0NTLlBSSU1FTS5jb252ZXJ0KkQyUjtcbiAgICAvL31cbiAgICBpZiAod2t0LkdFT0dDUy5EQVRVTSkge1xuICAgICAgd2t0LmRhdHVtQ29kZSA9IHdrdC5HRU9HQ1MuREFUVU0ubmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHdrdC5kYXR1bUNvZGUgPSB3a3QuR0VPR0NTLm5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgaWYgKHdrdC5kYXR1bUNvZGUuc2xpY2UoMCwgMikgPT09ICdkXycpIHtcbiAgICAgIHdrdC5kYXR1bUNvZGUgPSB3a3QuZGF0dW1Db2RlLnNsaWNlKDIpO1xuICAgIH1cbiAgICBpZiAod2t0LmRhdHVtQ29kZSA9PT0gJ25ld196ZWFsYW5kX2dlb2RldGljX2RhdHVtXzE5NDknIHx8IHdrdC5kYXR1bUNvZGUgPT09ICduZXdfemVhbGFuZF8xOTQ5Jykge1xuICAgICAgd2t0LmRhdHVtQ29kZSA9ICduemdkNDknO1xuICAgIH1cbiAgICBpZiAod2t0LmRhdHVtQ29kZSA9PT0gXCJ3Z3NfMTk4NFwiKSB7XG4gICAgICBpZiAod2t0LlBST0pFQ1RJT04gPT09ICdNZXJjYXRvcl9BdXhpbGlhcnlfU3BoZXJlJykge1xuICAgICAgICB3a3Quc3BoZXJlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHdrdC5kYXR1bUNvZGUgPSAnd2dzODQnO1xuICAgIH1cbiAgICBpZiAod2t0LmRhdHVtQ29kZS5zbGljZSgtNikgPT09ICdfZmVycm8nKSB7XG4gICAgICB3a3QuZGF0dW1Db2RlID0gd2t0LmRhdHVtQ29kZS5zbGljZSgwLCAtIDYpO1xuICAgIH1cbiAgICBpZiAod2t0LmRhdHVtQ29kZS5zbGljZSgtOCkgPT09ICdfamFrYXJ0YScpIHtcbiAgICAgIHdrdC5kYXR1bUNvZGUgPSB3a3QuZGF0dW1Db2RlLnNsaWNlKDAsIC0gOCk7XG4gICAgfVxuICAgIGlmICh+d2t0LmRhdHVtQ29kZS5pbmRleE9mKCdiZWxnZScpKSB7XG4gICAgICB3a3QuZGF0dW1Db2RlID0gXCJybmI3MlwiO1xuICAgIH1cbiAgICBpZiAod2t0LkdFT0dDUy5EQVRVTSAmJiB3a3QuR0VPR0NTLkRBVFVNLlNQSEVST0lEKSB7XG4gICAgICB3a3QuZWxscHMgPSB3a3QuR0VPR0NTLkRBVFVNLlNQSEVST0lELm5hbWUucmVwbGFjZSgnXzE5JywgJycpLnJlcGxhY2UoL1tDY11sYXJrZVxcXzE4LywgJ2NscmsnKTtcbiAgICAgIGlmICh3a3QuZWxscHMudG9Mb3dlckNhc2UoKS5zbGljZSgwLCAxMykgPT09IFwiaW50ZXJuYXRpb25hbFwiKSB7XG4gICAgICAgIHdrdC5lbGxwcyA9ICdpbnRsJztcbiAgICAgIH1cblxuICAgICAgd2t0LmEgPSB3a3QuR0VPR0NTLkRBVFVNLlNQSEVST0lELmE7XG4gICAgICB3a3QucmYgPSBwYXJzZUZsb2F0KHdrdC5HRU9HQ1MuREFUVU0uU1BIRVJPSUQucmYsIDEwKTtcbiAgICB9XG4gICAgaWYgKH53a3QuZGF0dW1Db2RlLmluZGV4T2YoJ29zZ2JfMTkzNicpKSB7XG4gICAgICB3a3QuZGF0dW1Db2RlID0gXCJvc2diMzZcIjtcbiAgICB9XG4gIH1cbiAgaWYgKHdrdC5iICYmICFpc0Zpbml0ZSh3a3QuYikpIHtcbiAgICB3a3QuYiA9IHdrdC5hO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9NZXRlcihpbnB1dCkge1xuICAgIHZhciByYXRpbyA9IHdrdC50b19tZXRlciB8fCAxO1xuICAgIHJldHVybiBwYXJzZUZsb2F0KGlucHV0LCAxMCkgKiByYXRpbztcbiAgfVxuICB2YXIgcmVuYW1lciA9IGZ1bmN0aW9uKGEpIHtcbiAgICByZXR1cm4gcmVuYW1lKHdrdCwgYSk7XG4gIH07XG4gIHZhciBsaXN0ID0gW1xuICAgIFsnc3RhbmRhcmRfcGFyYWxsZWxfMScsICdTdGFuZGFyZF9QYXJhbGxlbF8xJ10sXG4gICAgWydzdGFuZGFyZF9wYXJhbGxlbF8yJywgJ1N0YW5kYXJkX1BhcmFsbGVsXzInXSxcbiAgICBbJ2ZhbHNlX2Vhc3RpbmcnLCAnRmFsc2VfRWFzdGluZyddLFxuICAgIFsnZmFsc2Vfbm9ydGhpbmcnLCAnRmFsc2VfTm9ydGhpbmcnXSxcbiAgICBbJ2NlbnRyYWxfbWVyaWRpYW4nLCAnQ2VudHJhbF9NZXJpZGlhbiddLFxuICAgIFsnbGF0aXR1ZGVfb2Zfb3JpZ2luJywgJ0xhdGl0dWRlX09mX09yaWdpbiddLFxuICAgIFsnbGF0aXR1ZGVfb2Zfb3JpZ2luJywgJ0NlbnRyYWxfUGFyYWxsZWwnXSxcbiAgICBbJ3NjYWxlX2ZhY3RvcicsICdTY2FsZV9GYWN0b3InXSxcbiAgICBbJ2swJywgJ3NjYWxlX2ZhY3RvciddLFxuICAgIFsnbGF0aXR1ZGVfb2ZfY2VudGVyJywgJ0xhdGl0dWRlX29mX2NlbnRlciddLFxuICAgIFsnbGF0MCcsICdsYXRpdHVkZV9vZl9jZW50ZXInLCBkMnJdLFxuICAgIFsnbG9uZ2l0dWRlX29mX2NlbnRlcicsICdMb25naXR1ZGVfT2ZfQ2VudGVyJ10sXG4gICAgWydsb25nYycsICdsb25naXR1ZGVfb2ZfY2VudGVyJywgZDJyXSxcbiAgICBbJ3gwJywgJ2ZhbHNlX2Vhc3RpbmcnLCB0b01ldGVyXSxcbiAgICBbJ3kwJywgJ2ZhbHNlX25vcnRoaW5nJywgdG9NZXRlcl0sXG4gICAgWydsb25nMCcsICdjZW50cmFsX21lcmlkaWFuJywgZDJyXSxcbiAgICBbJ2xhdDAnLCAnbGF0aXR1ZGVfb2Zfb3JpZ2luJywgZDJyXSxcbiAgICBbJ2xhdDAnLCAnc3RhbmRhcmRfcGFyYWxsZWxfMScsIGQycl0sXG4gICAgWydsYXQxJywgJ3N0YW5kYXJkX3BhcmFsbGVsXzEnLCBkMnJdLFxuICAgIFsnbGF0MicsICdzdGFuZGFyZF9wYXJhbGxlbF8yJywgZDJyXSxcbiAgICBbJ2FscGhhJywgJ2F6aW11dGgnLCBkMnJdLFxuICAgIFsnc3JzQ29kZScsICduYW1lJ11cbiAgXTtcbiAgbGlzdC5mb3JFYWNoKHJlbmFtZXIpO1xuICBpZiAoIXdrdC5sb25nMCAmJiB3a3QubG9uZ2MgJiYgKHdrdC5wcm9qTmFtZSA9PT0gJ0FsYmVyc19Db25pY19FcXVhbF9BcmVhJyB8fCB3a3QucHJvak5hbWUgPT09IFwiTGFtYmVydF9BemltdXRoYWxfRXF1YWxfQXJlYVwiKSkge1xuICAgIHdrdC5sb25nMCA9IHdrdC5sb25nYztcbiAgfVxuICBpZiAoIXdrdC5sYXRfdHMgJiYgd2t0LmxhdDEgJiYgKHdrdC5wcm9qTmFtZSA9PT0gJ1N0ZXJlb2dyYXBoaWNfU291dGhfUG9sZScgfHwgd2t0LnByb2pOYW1lID09PSAnUG9sYXIgU3RlcmVvZ3JhcGhpYyAodmFyaWFudCBCKScpKSB7XG4gICAgd2t0LmxhdDAgPSBkMnIod2t0LmxhdDEgPiAwID8gOTAgOiAtOTApO1xuICAgIHdrdC5sYXRfdHMgPSB3a3QubGF0MTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih3a3QsIHNlbGYpIHtcbiAgdmFyIGxpc3AgPSBKU09OLnBhcnNlKChcIixcIiArIHdrdCkucmVwbGFjZSgvXFxzKlxcLFxccyooW0EtWl8wLTldKz8pKFxcWykvZywgJyxbXCIkMVwiLCcpLnNsaWNlKDEpLnJlcGxhY2UoL1xccypcXCxcXHMqKFtBLVpfMC05XSs/KVxcXS9nLCAnLFwiJDFcIl0nKS5yZXBsYWNlKC8sXFxbXCJWRVJUQ1NcIi4rLywnJykpO1xuICB2YXIgdHlwZSA9IGxpc3Auc2hpZnQoKTtcbiAgdmFyIG5hbWUgPSBsaXNwLnNoaWZ0KCk7XG4gIGxpc3AudW5zaGlmdChbJ25hbWUnLCBuYW1lXSk7XG4gIGxpc3AudW5zaGlmdChbJ3R5cGUnLCB0eXBlXSk7XG4gIGxpc3AudW5zaGlmdCgnb3V0cHV0Jyk7XG4gIHZhciBvYmogPSB7fTtcbiAgc0V4cHIobGlzcCwgb2JqKTtcbiAgY2xlYW5XS1Qob2JqLm91dHB1dCk7XG4gIHJldHVybiBleHRlbmQoc2VsZiwgb2JqLm91dHB1dCk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Byb2o0L2xpYi93a3QuanNcbi8vIG1vZHVsZSBpZCA9IDY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports){eval("/*\n\tBased on rgbcolor.js by Stoyan Stefanov <sstoo@gmail.com>\n\thttp://www.phpied.com/rgb-color-parser-in-javascript/\n*/\n\nmodule.exports = function(color_string) {\n    this.ok = false;\n    this.alpha = 1.0;\n\n    // strip any leading #\n    if (color_string.charAt(0) == '#') { // remove # if any\n        color_string = color_string.substr(1,6);\n    }\n\n    color_string = color_string.replace(/ /g,'');\n    color_string = color_string.toLowerCase();\n\n    // before getting into regexps, try simple matches\n    // and overwrite the input\n    var simple_colors = {\n        aliceblue: 'f0f8ff',\n        antiquewhite: 'faebd7',\n        aqua: '00ffff',\n        aquamarine: '7fffd4',\n        azure: 'f0ffff',\n        beige: 'f5f5dc',\n        bisque: 'ffe4c4',\n        black: '000000',\n        blanchedalmond: 'ffebcd',\n        blue: '0000ff',\n        blueviolet: '8a2be2',\n        brown: 'a52a2a',\n        burlywood: 'deb887',\n        cadetblue: '5f9ea0',\n        chartreuse: '7fff00',\n        chocolate: 'd2691e',\n        coral: 'ff7f50',\n        cornflowerblue: '6495ed',\n        cornsilk: 'fff8dc',\n        crimson: 'dc143c',\n        cyan: '00ffff',\n        darkblue: '00008b',\n        darkcyan: '008b8b',\n        darkgoldenrod: 'b8860b',\n        darkgray: 'a9a9a9',\n        darkgreen: '006400',\n        darkkhaki: 'bdb76b',\n        darkmagenta: '8b008b',\n        darkolivegreen: '556b2f',\n        darkorange: 'ff8c00',\n        darkorchid: '9932cc',\n        darkred: '8b0000',\n        darksalmon: 'e9967a',\n        darkseagreen: '8fbc8f',\n        darkslateblue: '483d8b',\n        darkslategray: '2f4f4f',\n        darkturquoise: '00ced1',\n        darkviolet: '9400d3',\n        deeppink: 'ff1493',\n        deepskyblue: '00bfff',\n        dimgray: '696969',\n        dodgerblue: '1e90ff',\n        feldspar: 'd19275',\n        firebrick: 'b22222',\n        floralwhite: 'fffaf0',\n        forestgreen: '228b22',\n        fuchsia: 'ff00ff',\n        gainsboro: 'dcdcdc',\n        ghostwhite: 'f8f8ff',\n        gold: 'ffd700',\n        goldenrod: 'daa520',\n        gray: '808080',\n        green: '008000',\n        greenyellow: 'adff2f',\n        honeydew: 'f0fff0',\n        hotpink: 'ff69b4',\n        indianred : 'cd5c5c',\n        indigo : '4b0082',\n        ivory: 'fffff0',\n        khaki: 'f0e68c',\n        lavender: 'e6e6fa',\n        lavenderblush: 'fff0f5',\n        lawngreen: '7cfc00',\n        lemonchiffon: 'fffacd',\n        lightblue: 'add8e6',\n        lightcoral: 'f08080',\n        lightcyan: 'e0ffff',\n        lightgoldenrodyellow: 'fafad2',\n        lightgrey: 'd3d3d3',\n        lightgreen: '90ee90',\n        lightpink: 'ffb6c1',\n        lightsalmon: 'ffa07a',\n        lightseagreen: '20b2aa',\n        lightskyblue: '87cefa',\n        lightslateblue: '8470ff',\n        lightslategray: '778899',\n        lightsteelblue: 'b0c4de',\n        lightyellow: 'ffffe0',\n        lime: '00ff00',\n        limegreen: '32cd32',\n        linen: 'faf0e6',\n        magenta: 'ff00ff',\n        maroon: '800000',\n        mediumaquamarine: '66cdaa',\n        mediumblue: '0000cd',\n        mediumorchid: 'ba55d3',\n        mediumpurple: '9370d8',\n        mediumseagreen: '3cb371',\n        mediumslateblue: '7b68ee',\n        mediumspringgreen: '00fa9a',\n        mediumturquoise: '48d1cc',\n        mediumvioletred: 'c71585',\n        midnightblue: '191970',\n        mintcream: 'f5fffa',\n        mistyrose: 'ffe4e1',\n        moccasin: 'ffe4b5',\n        navajowhite: 'ffdead',\n        navy: '000080',\n        oldlace: 'fdf5e6',\n        olive: '808000',\n        olivedrab: '6b8e23',\n        orange: 'ffa500',\n        orangered: 'ff4500',\n        orchid: 'da70d6',\n        palegoldenrod: 'eee8aa',\n        palegreen: '98fb98',\n        paleturquoise: 'afeeee',\n        palevioletred: 'd87093',\n        papayawhip: 'ffefd5',\n        peachpuff: 'ffdab9',\n        peru: 'cd853f',\n        pink: 'ffc0cb',\n        plum: 'dda0dd',\n        powderblue: 'b0e0e6',\n        purple: '800080',\n        red: 'ff0000',\n        rosybrown: 'bc8f8f',\n        royalblue: '4169e1',\n        saddlebrown: '8b4513',\n        salmon: 'fa8072',\n        sandybrown: 'f4a460',\n        seagreen: '2e8b57',\n        seashell: 'fff5ee',\n        sienna: 'a0522d',\n        silver: 'c0c0c0',\n        skyblue: '87ceeb',\n        slateblue: '6a5acd',\n        slategray: '708090',\n        snow: 'fffafa',\n        springgreen: '00ff7f',\n        steelblue: '4682b4',\n        tan: 'd2b48c',\n        teal: '008080',\n        thistle: 'd8bfd8',\n        tomato: 'ff6347',\n        turquoise: '40e0d0',\n        violet: 'ee82ee',\n        violetred: 'd02090',\n        wheat: 'f5deb3',\n        white: 'ffffff',\n        whitesmoke: 'f5f5f5',\n        yellow: 'ffff00',\n        yellowgreen: '9acd32'\n    };\n    color_string = simple_colors[color_string] || color_string;\n    // emd of simple type-in colors\n\n    // array of color definition objects\n    var color_defs = [\n        {\n            re: /^rgba\\((\\d{1,3}),\\s*(\\d{1,3}),\\s*(\\d{1,3}),\\s*((?:\\d?\\.)?\\d)\\)$/,\n            example: ['rgba(123, 234, 45, 0.8)', 'rgba(255,234,245,1.0)'],\n            process: function (bits){\n                return [\n                    parseInt(bits[1]),\n                    parseInt(bits[2]),\n                    parseInt(bits[3]),\n                    parseFloat(bits[4])\n                ];\n            }\n        },\n        {\n            re: /^rgb\\((\\d{1,3}),\\s*(\\d{1,3}),\\s*(\\d{1,3})\\)$/,\n            example: ['rgb(123, 234, 45)', 'rgb(255,234,245)'],\n            process: function (bits){\n                return [\n                    parseInt(bits[1]),\n                    parseInt(bits[2]),\n                    parseInt(bits[3])\n                ];\n            }\n        },\n        {\n            re: /^(\\w{2})(\\w{2})(\\w{2})$/,\n            example: ['#00ff00', '336699'],\n            process: function (bits){\n                return [\n                    parseInt(bits[1], 16),\n                    parseInt(bits[2], 16),\n                    parseInt(bits[3], 16)\n                ];\n            }\n        },\n        {\n            re: /^(\\w{1})(\\w{1})(\\w{1})$/,\n            example: ['#fb0', 'f0f'],\n            process: function (bits){\n                return [\n                    parseInt(bits[1] + bits[1], 16),\n                    parseInt(bits[2] + bits[2], 16),\n                    parseInt(bits[3] + bits[3], 16)\n                ];\n            }\n        }\n    ];\n\n    // search through the definitions to find a match\n    for (var i = 0; i < color_defs.length; i++) {\n        var re = color_defs[i].re;\n        var processor = color_defs[i].process;\n        var bits = re.exec(color_string);\n        if (bits) {\n            var channels = processor(bits);\n            this.r = channels[0];\n            this.g = channels[1];\n            this.b = channels[2];\n            if (channels.length > 3) {\n                this.alpha = channels[3];\n            }\n            this.ok = true;\n        }\n\n    }\n\n    // validate/cleanup values\n    this.r = (this.r < 0 || isNaN(this.r)) ? 0 : ((this.r > 255) ? 255 : this.r);\n    this.g = (this.g < 0 || isNaN(this.g)) ? 0 : ((this.g > 255) ? 255 : this.g);\n    this.b = (this.b < 0 || isNaN(this.b)) ? 0 : ((this.b > 255) ? 255 : this.b);\n    this.alpha = (this.alpha < 0) ? 0 : ((this.alpha > 1.0 || isNaN(this.alpha)) ? 1.0 : this.alpha);\n\n    // some getters\n    this.toRGB = function () {\n        return 'rgb(' + this.r + ', ' + this.g + ', ' + this.b + ')';\n    }\n    this.toRGBA = function () {\n        return 'rgba(' + this.r + ', ' + this.g + ', ' + this.b + ', ' + this.alpha + ')';\n    }\n    this.toHex = function () {\n        var r = this.r.toString(16);\n        var g = this.g.toString(16);\n        var b = this.b.toString(16);\n        if (r.length == 1) r = '0' + r;\n        if (g.length == 1) g = '0' + g;\n        if (b.length == 1) b = '0' + b;\n        return '#' + r + g + b;\n    }\n\n    // help\n    this.getHelpXML = function () {\n\n        var examples = new Array();\n        // add regexps\n        for (var i = 0; i < color_defs.length; i++) {\n            var example = color_defs[i].example;\n            for (var j = 0; j < example.length; j++) {\n                examples[examples.length] = example[j];\n            }\n        }\n        // add type-in colors\n        for (var sc in simple_colors) {\n            examples[examples.length] = sc;\n        }\n\n        var xml = document.createElement('ul');\n        xml.setAttribute('id', 'rgbcolor-examples');\n        for (var i = 0; i < examples.length; i++) {\n            try {\n                var list_item = document.createElement('li');\n                var list_color = new RGBColor(examples[i]);\n                var example_div = document.createElement('div');\n                example_div.style.cssText =\n                        'margin: 3px; '\n                        + 'border: 1px solid black; '\n                        + 'background:' + list_color.toHex() + '; '\n                        + 'color:' + list_color.toHex()\n                ;\n                example_div.appendChild(document.createTextNode('test'));\n                var list_item_value = document.createTextNode(\n                    ' ' + examples[i] + ' -> ' + list_color.toRGB() + ' -> ' + list_color.toHex()\n                );\n                list_item.appendChild(example_div);\n                list_item.appendChild(list_item_value);\n                xml.appendChild(list_item);\n\n            } catch(e){}\n        }\n        return xml;\n\n    }\n\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3JnYmNvbG9yL2luZGV4LmpzPzhjZmIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixJQUFJLFNBQVMsSUFBSSxTQUFTLElBQUk7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsMkJBQTJCLElBQUksU0FBUyxJQUFJLFNBQVMsSUFBSTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esc0JBQXNCLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esc0JBQXNCLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQix1QkFBdUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0EsMkJBQTJCLG9CQUFvQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLHFCQUFxQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLG1EQUFtRDtBQUNuRCxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWE7QUFDYjtBQUNBOztBQUVBOztBQUVBIiwiZmlsZSI6IjY4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcblx0QmFzZWQgb24gcmdiY29sb3IuanMgYnkgU3RveWFuIFN0ZWZhbm92IDxzc3Rvb0BnbWFpbC5jb20+XG5cdGh0dHA6Ly93d3cucGhwaWVkLmNvbS9yZ2ItY29sb3ItcGFyc2VyLWluLWphdmFzY3JpcHQvXG4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNvbG9yX3N0cmluZykge1xuICAgIHRoaXMub2sgPSBmYWxzZTtcbiAgICB0aGlzLmFscGhhID0gMS4wO1xuXG4gICAgLy8gc3RyaXAgYW55IGxlYWRpbmcgI1xuICAgIGlmIChjb2xvcl9zdHJpbmcuY2hhckF0KDApID09ICcjJykgeyAvLyByZW1vdmUgIyBpZiBhbnlcbiAgICAgICAgY29sb3Jfc3RyaW5nID0gY29sb3Jfc3RyaW5nLnN1YnN0cigxLDYpO1xuICAgIH1cblxuICAgIGNvbG9yX3N0cmluZyA9IGNvbG9yX3N0cmluZy5yZXBsYWNlKC8gL2csJycpO1xuICAgIGNvbG9yX3N0cmluZyA9IGNvbG9yX3N0cmluZy50b0xvd2VyQ2FzZSgpO1xuXG4gICAgLy8gYmVmb3JlIGdldHRpbmcgaW50byByZWdleHBzLCB0cnkgc2ltcGxlIG1hdGNoZXNcbiAgICAvLyBhbmQgb3ZlcndyaXRlIHRoZSBpbnB1dFxuICAgIHZhciBzaW1wbGVfY29sb3JzID0ge1xuICAgICAgICBhbGljZWJsdWU6ICdmMGY4ZmYnLFxuICAgICAgICBhbnRpcXVld2hpdGU6ICdmYWViZDcnLFxuICAgICAgICBhcXVhOiAnMDBmZmZmJyxcbiAgICAgICAgYXF1YW1hcmluZTogJzdmZmZkNCcsXG4gICAgICAgIGF6dXJlOiAnZjBmZmZmJyxcbiAgICAgICAgYmVpZ2U6ICdmNWY1ZGMnLFxuICAgICAgICBiaXNxdWU6ICdmZmU0YzQnLFxuICAgICAgICBibGFjazogJzAwMDAwMCcsXG4gICAgICAgIGJsYW5jaGVkYWxtb25kOiAnZmZlYmNkJyxcbiAgICAgICAgYmx1ZTogJzAwMDBmZicsXG4gICAgICAgIGJsdWV2aW9sZXQ6ICc4YTJiZTInLFxuICAgICAgICBicm93bjogJ2E1MmEyYScsXG4gICAgICAgIGJ1cmx5d29vZDogJ2RlYjg4NycsXG4gICAgICAgIGNhZGV0Ymx1ZTogJzVmOWVhMCcsXG4gICAgICAgIGNoYXJ0cmV1c2U6ICc3ZmZmMDAnLFxuICAgICAgICBjaG9jb2xhdGU6ICdkMjY5MWUnLFxuICAgICAgICBjb3JhbDogJ2ZmN2Y1MCcsXG4gICAgICAgIGNvcm5mbG93ZXJibHVlOiAnNjQ5NWVkJyxcbiAgICAgICAgY29ybnNpbGs6ICdmZmY4ZGMnLFxuICAgICAgICBjcmltc29uOiAnZGMxNDNjJyxcbiAgICAgICAgY3lhbjogJzAwZmZmZicsXG4gICAgICAgIGRhcmtibHVlOiAnMDAwMDhiJyxcbiAgICAgICAgZGFya2N5YW46ICcwMDhiOGInLFxuICAgICAgICBkYXJrZ29sZGVucm9kOiAnYjg4NjBiJyxcbiAgICAgICAgZGFya2dyYXk6ICdhOWE5YTknLFxuICAgICAgICBkYXJrZ3JlZW46ICcwMDY0MDAnLFxuICAgICAgICBkYXJra2hha2k6ICdiZGI3NmInLFxuICAgICAgICBkYXJrbWFnZW50YTogJzhiMDA4YicsXG4gICAgICAgIGRhcmtvbGl2ZWdyZWVuOiAnNTU2YjJmJyxcbiAgICAgICAgZGFya29yYW5nZTogJ2ZmOGMwMCcsXG4gICAgICAgIGRhcmtvcmNoaWQ6ICc5OTMyY2MnLFxuICAgICAgICBkYXJrcmVkOiAnOGIwMDAwJyxcbiAgICAgICAgZGFya3NhbG1vbjogJ2U5OTY3YScsXG4gICAgICAgIGRhcmtzZWFncmVlbjogJzhmYmM4ZicsXG4gICAgICAgIGRhcmtzbGF0ZWJsdWU6ICc0ODNkOGInLFxuICAgICAgICBkYXJrc2xhdGVncmF5OiAnMmY0ZjRmJyxcbiAgICAgICAgZGFya3R1cnF1b2lzZTogJzAwY2VkMScsXG4gICAgICAgIGRhcmt2aW9sZXQ6ICc5NDAwZDMnLFxuICAgICAgICBkZWVwcGluazogJ2ZmMTQ5MycsXG4gICAgICAgIGRlZXBza3libHVlOiAnMDBiZmZmJyxcbiAgICAgICAgZGltZ3JheTogJzY5Njk2OScsXG4gICAgICAgIGRvZGdlcmJsdWU6ICcxZTkwZmYnLFxuICAgICAgICBmZWxkc3BhcjogJ2QxOTI3NScsXG4gICAgICAgIGZpcmVicmljazogJ2IyMjIyMicsXG4gICAgICAgIGZsb3JhbHdoaXRlOiAnZmZmYWYwJyxcbiAgICAgICAgZm9yZXN0Z3JlZW46ICcyMjhiMjInLFxuICAgICAgICBmdWNoc2lhOiAnZmYwMGZmJyxcbiAgICAgICAgZ2FpbnNib3JvOiAnZGNkY2RjJyxcbiAgICAgICAgZ2hvc3R3aGl0ZTogJ2Y4ZjhmZicsXG4gICAgICAgIGdvbGQ6ICdmZmQ3MDAnLFxuICAgICAgICBnb2xkZW5yb2Q6ICdkYWE1MjAnLFxuICAgICAgICBncmF5OiAnODA4MDgwJyxcbiAgICAgICAgZ3JlZW46ICcwMDgwMDAnLFxuICAgICAgICBncmVlbnllbGxvdzogJ2FkZmYyZicsXG4gICAgICAgIGhvbmV5ZGV3OiAnZjBmZmYwJyxcbiAgICAgICAgaG90cGluazogJ2ZmNjliNCcsXG4gICAgICAgIGluZGlhbnJlZCA6ICdjZDVjNWMnLFxuICAgICAgICBpbmRpZ28gOiAnNGIwMDgyJyxcbiAgICAgICAgaXZvcnk6ICdmZmZmZjAnLFxuICAgICAgICBraGFraTogJ2YwZTY4YycsXG4gICAgICAgIGxhdmVuZGVyOiAnZTZlNmZhJyxcbiAgICAgICAgbGF2ZW5kZXJibHVzaDogJ2ZmZjBmNScsXG4gICAgICAgIGxhd25ncmVlbjogJzdjZmMwMCcsXG4gICAgICAgIGxlbW9uY2hpZmZvbjogJ2ZmZmFjZCcsXG4gICAgICAgIGxpZ2h0Ymx1ZTogJ2FkZDhlNicsXG4gICAgICAgIGxpZ2h0Y29yYWw6ICdmMDgwODAnLFxuICAgICAgICBsaWdodGN5YW46ICdlMGZmZmYnLFxuICAgICAgICBsaWdodGdvbGRlbnJvZHllbGxvdzogJ2ZhZmFkMicsXG4gICAgICAgIGxpZ2h0Z3JleTogJ2QzZDNkMycsXG4gICAgICAgIGxpZ2h0Z3JlZW46ICc5MGVlOTAnLFxuICAgICAgICBsaWdodHBpbms6ICdmZmI2YzEnLFxuICAgICAgICBsaWdodHNhbG1vbjogJ2ZmYTA3YScsXG4gICAgICAgIGxpZ2h0c2VhZ3JlZW46ICcyMGIyYWEnLFxuICAgICAgICBsaWdodHNreWJsdWU6ICc4N2NlZmEnLFxuICAgICAgICBsaWdodHNsYXRlYmx1ZTogJzg0NzBmZicsXG4gICAgICAgIGxpZ2h0c2xhdGVncmF5OiAnNzc4ODk5JyxcbiAgICAgICAgbGlnaHRzdGVlbGJsdWU6ICdiMGM0ZGUnLFxuICAgICAgICBsaWdodHllbGxvdzogJ2ZmZmZlMCcsXG4gICAgICAgIGxpbWU6ICcwMGZmMDAnLFxuICAgICAgICBsaW1lZ3JlZW46ICczMmNkMzInLFxuICAgICAgICBsaW5lbjogJ2ZhZjBlNicsXG4gICAgICAgIG1hZ2VudGE6ICdmZjAwZmYnLFxuICAgICAgICBtYXJvb246ICc4MDAwMDAnLFxuICAgICAgICBtZWRpdW1hcXVhbWFyaW5lOiAnNjZjZGFhJyxcbiAgICAgICAgbWVkaXVtYmx1ZTogJzAwMDBjZCcsXG4gICAgICAgIG1lZGl1bW9yY2hpZDogJ2JhNTVkMycsXG4gICAgICAgIG1lZGl1bXB1cnBsZTogJzkzNzBkOCcsXG4gICAgICAgIG1lZGl1bXNlYWdyZWVuOiAnM2NiMzcxJyxcbiAgICAgICAgbWVkaXVtc2xhdGVibHVlOiAnN2I2OGVlJyxcbiAgICAgICAgbWVkaXVtc3ByaW5nZ3JlZW46ICcwMGZhOWEnLFxuICAgICAgICBtZWRpdW10dXJxdW9pc2U6ICc0OGQxY2MnLFxuICAgICAgICBtZWRpdW12aW9sZXRyZWQ6ICdjNzE1ODUnLFxuICAgICAgICBtaWRuaWdodGJsdWU6ICcxOTE5NzAnLFxuICAgICAgICBtaW50Y3JlYW06ICdmNWZmZmEnLFxuICAgICAgICBtaXN0eXJvc2U6ICdmZmU0ZTEnLFxuICAgICAgICBtb2NjYXNpbjogJ2ZmZTRiNScsXG4gICAgICAgIG5hdmFqb3doaXRlOiAnZmZkZWFkJyxcbiAgICAgICAgbmF2eTogJzAwMDA4MCcsXG4gICAgICAgIG9sZGxhY2U6ICdmZGY1ZTYnLFxuICAgICAgICBvbGl2ZTogJzgwODAwMCcsXG4gICAgICAgIG9saXZlZHJhYjogJzZiOGUyMycsXG4gICAgICAgIG9yYW5nZTogJ2ZmYTUwMCcsXG4gICAgICAgIG9yYW5nZXJlZDogJ2ZmNDUwMCcsXG4gICAgICAgIG9yY2hpZDogJ2RhNzBkNicsXG4gICAgICAgIHBhbGVnb2xkZW5yb2Q6ICdlZWU4YWEnLFxuICAgICAgICBwYWxlZ3JlZW46ICc5OGZiOTgnLFxuICAgICAgICBwYWxldHVycXVvaXNlOiAnYWZlZWVlJyxcbiAgICAgICAgcGFsZXZpb2xldHJlZDogJ2Q4NzA5MycsXG4gICAgICAgIHBhcGF5YXdoaXA6ICdmZmVmZDUnLFxuICAgICAgICBwZWFjaHB1ZmY6ICdmZmRhYjknLFxuICAgICAgICBwZXJ1OiAnY2Q4NTNmJyxcbiAgICAgICAgcGluazogJ2ZmYzBjYicsXG4gICAgICAgIHBsdW06ICdkZGEwZGQnLFxuICAgICAgICBwb3dkZXJibHVlOiAnYjBlMGU2JyxcbiAgICAgICAgcHVycGxlOiAnODAwMDgwJyxcbiAgICAgICAgcmVkOiAnZmYwMDAwJyxcbiAgICAgICAgcm9zeWJyb3duOiAnYmM4ZjhmJyxcbiAgICAgICAgcm95YWxibHVlOiAnNDE2OWUxJyxcbiAgICAgICAgc2FkZGxlYnJvd246ICc4YjQ1MTMnLFxuICAgICAgICBzYWxtb246ICdmYTgwNzInLFxuICAgICAgICBzYW5keWJyb3duOiAnZjRhNDYwJyxcbiAgICAgICAgc2VhZ3JlZW46ICcyZThiNTcnLFxuICAgICAgICBzZWFzaGVsbDogJ2ZmZjVlZScsXG4gICAgICAgIHNpZW5uYTogJ2EwNTIyZCcsXG4gICAgICAgIHNpbHZlcjogJ2MwYzBjMCcsXG4gICAgICAgIHNreWJsdWU6ICc4N2NlZWInLFxuICAgICAgICBzbGF0ZWJsdWU6ICc2YTVhY2QnLFxuICAgICAgICBzbGF0ZWdyYXk6ICc3MDgwOTAnLFxuICAgICAgICBzbm93OiAnZmZmYWZhJyxcbiAgICAgICAgc3ByaW5nZ3JlZW46ICcwMGZmN2YnLFxuICAgICAgICBzdGVlbGJsdWU6ICc0NjgyYjQnLFxuICAgICAgICB0YW46ICdkMmI0OGMnLFxuICAgICAgICB0ZWFsOiAnMDA4MDgwJyxcbiAgICAgICAgdGhpc3RsZTogJ2Q4YmZkOCcsXG4gICAgICAgIHRvbWF0bzogJ2ZmNjM0NycsXG4gICAgICAgIHR1cnF1b2lzZTogJzQwZTBkMCcsXG4gICAgICAgIHZpb2xldDogJ2VlODJlZScsXG4gICAgICAgIHZpb2xldHJlZDogJ2QwMjA5MCcsXG4gICAgICAgIHdoZWF0OiAnZjVkZWIzJyxcbiAgICAgICAgd2hpdGU6ICdmZmZmZmYnLFxuICAgICAgICB3aGl0ZXNtb2tlOiAnZjVmNWY1JyxcbiAgICAgICAgeWVsbG93OiAnZmZmZjAwJyxcbiAgICAgICAgeWVsbG93Z3JlZW46ICc5YWNkMzInXG4gICAgfTtcbiAgICBjb2xvcl9zdHJpbmcgPSBzaW1wbGVfY29sb3JzW2NvbG9yX3N0cmluZ10gfHwgY29sb3Jfc3RyaW5nO1xuICAgIC8vIGVtZCBvZiBzaW1wbGUgdHlwZS1pbiBjb2xvcnNcblxuICAgIC8vIGFycmF5IG9mIGNvbG9yIGRlZmluaXRpb24gb2JqZWN0c1xuICAgIHZhciBjb2xvcl9kZWZzID0gW1xuICAgICAgICB7XG4gICAgICAgICAgICByZTogL15yZ2JhXFwoKFxcZHsxLDN9KSxcXHMqKFxcZHsxLDN9KSxcXHMqKFxcZHsxLDN9KSxcXHMqKCg/OlxcZD9cXC4pP1xcZClcXCkkLyxcbiAgICAgICAgICAgIGV4YW1wbGU6IFsncmdiYSgxMjMsIDIzNCwgNDUsIDAuOCknLCAncmdiYSgyNTUsMjM0LDI0NSwxLjApJ10sXG4gICAgICAgICAgICBwcm9jZXNzOiBmdW5jdGlvbiAoYml0cyl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQoYml0c1sxXSksXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KGJpdHNbMl0pLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUludChiaXRzWzNdKSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VGbG9hdChiaXRzWzRdKVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJlOiAvXnJnYlxcKChcXGR7MSwzfSksXFxzKihcXGR7MSwzfSksXFxzKihcXGR7MSwzfSlcXCkkLyxcbiAgICAgICAgICAgIGV4YW1wbGU6IFsncmdiKDEyMywgMjM0LCA0NSknLCAncmdiKDI1NSwyMzQsMjQ1KSddLFxuICAgICAgICAgICAgcHJvY2VzczogZnVuY3Rpb24gKGJpdHMpe1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KGJpdHNbMV0pLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUludChiaXRzWzJdKSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQoYml0c1szXSlcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICByZTogL14oXFx3ezJ9KShcXHd7Mn0pKFxcd3syfSkkLyxcbiAgICAgICAgICAgIGV4YW1wbGU6IFsnIzAwZmYwMCcsICczMzY2OTknXSxcbiAgICAgICAgICAgIHByb2Nlc3M6IGZ1bmN0aW9uIChiaXRzKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICBwYXJzZUludChiaXRzWzFdLCAxNiksXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KGJpdHNbMl0sIDE2KSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQoYml0c1szXSwgMTYpXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgcmU6IC9eKFxcd3sxfSkoXFx3ezF9KShcXHd7MX0pJC8sXG4gICAgICAgICAgICBleGFtcGxlOiBbJyNmYjAnLCAnZjBmJ10sXG4gICAgICAgICAgICBwcm9jZXNzOiBmdW5jdGlvbiAoYml0cyl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQoYml0c1sxXSArIGJpdHNbMV0sIDE2KSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQoYml0c1syXSArIGJpdHNbMl0sIDE2KSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQoYml0c1szXSArIGJpdHNbM10sIDE2KVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdO1xuXG4gICAgLy8gc2VhcmNoIHRocm91Z2ggdGhlIGRlZmluaXRpb25zIHRvIGZpbmQgYSBtYXRjaFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sb3JfZGVmcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcmUgPSBjb2xvcl9kZWZzW2ldLnJlO1xuICAgICAgICB2YXIgcHJvY2Vzc29yID0gY29sb3JfZGVmc1tpXS5wcm9jZXNzO1xuICAgICAgICB2YXIgYml0cyA9IHJlLmV4ZWMoY29sb3Jfc3RyaW5nKTtcbiAgICAgICAgaWYgKGJpdHMpIHtcbiAgICAgICAgICAgIHZhciBjaGFubmVscyA9IHByb2Nlc3NvcihiaXRzKTtcbiAgICAgICAgICAgIHRoaXMuciA9IGNoYW5uZWxzWzBdO1xuICAgICAgICAgICAgdGhpcy5nID0gY2hhbm5lbHNbMV07XG4gICAgICAgICAgICB0aGlzLmIgPSBjaGFubmVsc1syXTtcbiAgICAgICAgICAgIGlmIChjaGFubmVscy5sZW5ndGggPiAzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbHBoYSA9IGNoYW5uZWxzWzNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vayA9IHRydWU7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8vIHZhbGlkYXRlL2NsZWFudXAgdmFsdWVzXG4gICAgdGhpcy5yID0gKHRoaXMuciA8IDAgfHwgaXNOYU4odGhpcy5yKSkgPyAwIDogKCh0aGlzLnIgPiAyNTUpID8gMjU1IDogdGhpcy5yKTtcbiAgICB0aGlzLmcgPSAodGhpcy5nIDwgMCB8fCBpc05hTih0aGlzLmcpKSA/IDAgOiAoKHRoaXMuZyA+IDI1NSkgPyAyNTUgOiB0aGlzLmcpO1xuICAgIHRoaXMuYiA9ICh0aGlzLmIgPCAwIHx8IGlzTmFOKHRoaXMuYikpID8gMCA6ICgodGhpcy5iID4gMjU1KSA/IDI1NSA6IHRoaXMuYik7XG4gICAgdGhpcy5hbHBoYSA9ICh0aGlzLmFscGhhIDwgMCkgPyAwIDogKCh0aGlzLmFscGhhID4gMS4wIHx8IGlzTmFOKHRoaXMuYWxwaGEpKSA/IDEuMCA6IHRoaXMuYWxwaGEpO1xuXG4gICAgLy8gc29tZSBnZXR0ZXJzXG4gICAgdGhpcy50b1JHQiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdyZ2IoJyArIHRoaXMuciArICcsICcgKyB0aGlzLmcgKyAnLCAnICsgdGhpcy5iICsgJyknO1xuICAgIH1cbiAgICB0aGlzLnRvUkdCQSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdyZ2JhKCcgKyB0aGlzLnIgKyAnLCAnICsgdGhpcy5nICsgJywgJyArIHRoaXMuYiArICcsICcgKyB0aGlzLmFscGhhICsgJyknO1xuICAgIH1cbiAgICB0aGlzLnRvSGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgciA9IHRoaXMuci50b1N0cmluZygxNik7XG4gICAgICAgIHZhciBnID0gdGhpcy5nLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgdmFyIGIgPSB0aGlzLmIudG9TdHJpbmcoMTYpO1xuICAgICAgICBpZiAoci5sZW5ndGggPT0gMSkgciA9ICcwJyArIHI7XG4gICAgICAgIGlmIChnLmxlbmd0aCA9PSAxKSBnID0gJzAnICsgZztcbiAgICAgICAgaWYgKGIubGVuZ3RoID09IDEpIGIgPSAnMCcgKyBiO1xuICAgICAgICByZXR1cm4gJyMnICsgciArIGcgKyBiO1xuICAgIH1cblxuICAgIC8vIGhlbHBcbiAgICB0aGlzLmdldEhlbHBYTUwgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgdmFyIGV4YW1wbGVzID0gbmV3IEFycmF5KCk7XG4gICAgICAgIC8vIGFkZCByZWdleHBzXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sb3JfZGVmcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGV4YW1wbGUgPSBjb2xvcl9kZWZzW2ldLmV4YW1wbGU7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGV4YW1wbGUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBleGFtcGxlc1tleGFtcGxlcy5sZW5ndGhdID0gZXhhbXBsZVtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBhZGQgdHlwZS1pbiBjb2xvcnNcbiAgICAgICAgZm9yICh2YXIgc2MgaW4gc2ltcGxlX2NvbG9ycykge1xuICAgICAgICAgICAgZXhhbXBsZXNbZXhhbXBsZXMubGVuZ3RoXSA9IHNjO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHhtbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3VsJyk7XG4gICAgICAgIHhtbC5zZXRBdHRyaWJ1dGUoJ2lkJywgJ3JnYmNvbG9yLWV4YW1wbGVzJyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpc3RfaXRlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG4gICAgICAgICAgICAgICAgdmFyIGxpc3RfY29sb3IgPSBuZXcgUkdCQ29sb3IoZXhhbXBsZXNbaV0pO1xuICAgICAgICAgICAgICAgIHZhciBleGFtcGxlX2RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgIGV4YW1wbGVfZGl2LnN0eWxlLmNzc1RleHQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgJ21hcmdpbjogM3B4OyAnXG4gICAgICAgICAgICAgICAgICAgICAgICArICdib3JkZXI6IDFweCBzb2xpZCBibGFjazsgJ1xuICAgICAgICAgICAgICAgICAgICAgICAgKyAnYmFja2dyb3VuZDonICsgbGlzdF9jb2xvci50b0hleCgpICsgJzsgJ1xuICAgICAgICAgICAgICAgICAgICAgICAgKyAnY29sb3I6JyArIGxpc3RfY29sb3IudG9IZXgoKVxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBleGFtcGxlX2Rpdi5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgndGVzdCcpKTtcbiAgICAgICAgICAgICAgICB2YXIgbGlzdF9pdGVtX3ZhbHVlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXG4gICAgICAgICAgICAgICAgICAgICcgJyArIGV4YW1wbGVzW2ldICsgJyAtPiAnICsgbGlzdF9jb2xvci50b1JHQigpICsgJyAtPiAnICsgbGlzdF9jb2xvci50b0hleCgpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBsaXN0X2l0ZW0uYXBwZW5kQ2hpbGQoZXhhbXBsZV9kaXYpO1xuICAgICAgICAgICAgICAgIGxpc3RfaXRlbS5hcHBlbmRDaGlsZChsaXN0X2l0ZW1fdmFsdWUpO1xuICAgICAgICAgICAgICAgIHhtbC5hcHBlbmRDaGlsZChsaXN0X2l0ZW0pO1xuXG4gICAgICAgICAgICB9IGNhdGNoKGUpe31cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geG1sO1xuXG4gICAgfVxuXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmdiY29sb3IvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){"use strict";eval("\r\nmodule.exports = toArrayBuffer;\r\nfunction toArrayBuffer(buffer) {\r\n    var arrayBuffer = new ArrayBuffer(buffer.length);\r\n    var view = new Uint8Array(arrayBuffer);\r\n    var i = -1;\r\n    var len = buffer.length;\r\n    while (++i < len) {\r\n        view[i] = buffer[i];\r\n    }\r\n    return arrayBuffer;\r\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3NocGpzL2xpYi90b0FycmF5QnVmZmVyLmpzPzVmMDAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjY5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5tb2R1bGUuZXhwb3J0cyA9IHRvQXJyYXlCdWZmZXI7XHJcbmZ1bmN0aW9uIHRvQXJyYXlCdWZmZXIoYnVmZmVyKSB7XHJcbiAgICB2YXIgYXJyYXlCdWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYnVmZmVyLmxlbmd0aCk7XHJcbiAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKTtcclxuICAgIHZhciBpID0gLTE7XHJcbiAgICB2YXIgbGVuID0gYnVmZmVyLmxlbmd0aDtcclxuICAgIHdoaWxlICgrK2kgPCBsZW4pIHtcclxuICAgICAgICB2aWV3W2ldID0gYnVmZmVyW2ldO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFycmF5QnVmZmVyO1xyXG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NocGpzL2xpYi90b0FycmF5QnVmZmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports){eval('module.exports = {\n\t"circlePoint": {\n\t\t"geometryType": "esriGeometryPoint",\n\t\t"renderer": {\n\t\t\t"type": "simple",\n\t\t\t"symbol": {\n\t\t\t\t"type": "esriSMS",\n\t\t\t\t"style": "esriSMSCircle",\n\t\t\t\t"color": [\n\t\t\t\t\t67,\n\t\t\t\t\t100,\n\t\t\t\t\t255,\n\t\t\t\t\t200\n\t\t\t\t],\n\t\t\t\t"size": 7\n\t\t\t}\n\t\t}\n\t},\n\t"solidLine": {\n\t\t"geometryType": "esriGeometryPolyline",\n\t\t"renderer": {\n\t\t\t"type": "simple",\n\t\t\t"symbol": {\n\t\t\t\t"type": "esriSLS",\n\t\t\t\t"style": "esriSLSSolid",\n\t\t\t\t"color": [\n\t\t\t\t\t90,\n\t\t\t\t\t90,\n\t\t\t\t\t90,\n\t\t\t\t\t200\n\t\t\t\t],\n\t\t\t\t"width": 2\n\t\t\t}\n\t\t}\n\t},\n\t"outlinedPoly": {\n\t\t"geometryType": "esriGeometryPolygon",\n\t\t"renderer": {\n\t\t\t"type": "simple",\n\t\t\t"symbol": {\n\t\t\t\t"type": "esriSFS",\n\t\t\t\t"style": "esriSFSSolid",\n\t\t\t\t"color": [\n\t\t\t\t\t76,\n\t\t\t\t\t76,\n\t\t\t\t\t125,\n\t\t\t\t\t200\n\t\t\t\t],\n\t\t\t\t"outline": {\n\t\t\t\t\t"type": "esriSLS",\n\t\t\t\t\t"style": "esriSLSSolid",\n\t\t\t\t\t"color": [\n\t\t\t\t\t\t110,\n\t\t\t\t\t\t110,\n\t\t\t\t\t\t110,\n\t\t\t\t\t\t255\n\t\t\t\t\t],\n\t\t\t\t\t"width": 1\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\t"boundingBoxPoly": {\n\t\t"geometryType": "esriGeometryPolygon",\n\t\t"renderer": {\n\t\t\t"type": "simple",\n\t\t\t"symbol": {\n\t\t\t\t"type": "esriSFS",\n\t\t\t\t"style": "esriSFSSolid",\n\t\t\t\t"color": [\n\t\t\t\t\t255,\n\t\t\t\t\t0,\n\t\t\t\t\t0,\n\t\t\t\t\t64\n\t\t\t\t],\n\t\t\t\t"outline": {\n\t\t\t\t\t"type": "esriSLS",\n\t\t\t\t\t"style": "esriSLSSolid",\n\t\t\t\t\t"color": [\n\t\t\t\t\t\t240,\n\t\t\t\t\t\t128,\n\t\t\t\t\t\t128,\n\t\t\t\t\t\t255\n\t\t\t\t\t],\n\t\t\t\t\t"width": 1\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZGVmYXVsdFJlbmRlcmVycy5qc29uPzdhNzYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjcwLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSB7XG5cdFwiY2lyY2xlUG9pbnRcIjoge1xuXHRcdFwiZ2VvbWV0cnlUeXBlXCI6IFwiZXNyaUdlb21ldHJ5UG9pbnRcIixcblx0XHRcInJlbmRlcmVyXCI6IHtcblx0XHRcdFwidHlwZVwiOiBcInNpbXBsZVwiLFxuXHRcdFx0XCJzeW1ib2xcIjoge1xuXHRcdFx0XHRcInR5cGVcIjogXCJlc3JpU01TXCIsXG5cdFx0XHRcdFwic3R5bGVcIjogXCJlc3JpU01TQ2lyY2xlXCIsXG5cdFx0XHRcdFwiY29sb3JcIjogW1xuXHRcdFx0XHRcdDY3LFxuXHRcdFx0XHRcdDEwMCxcblx0XHRcdFx0XHQyNTUsXG5cdFx0XHRcdFx0MjAwXG5cdFx0XHRcdF0sXG5cdFx0XHRcdFwic2l6ZVwiOiA3XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRcInNvbGlkTGluZVwiOiB7XG5cdFx0XCJnZW9tZXRyeVR5cGVcIjogXCJlc3JpR2VvbWV0cnlQb2x5bGluZVwiLFxuXHRcdFwicmVuZGVyZXJcIjoge1xuXHRcdFx0XCJ0eXBlXCI6IFwic2ltcGxlXCIsXG5cdFx0XHRcInN5bWJvbFwiOiB7XG5cdFx0XHRcdFwidHlwZVwiOiBcImVzcmlTTFNcIixcblx0XHRcdFx0XCJzdHlsZVwiOiBcImVzcmlTTFNTb2xpZFwiLFxuXHRcdFx0XHRcImNvbG9yXCI6IFtcblx0XHRcdFx0XHQ5MCxcblx0XHRcdFx0XHQ5MCxcblx0XHRcdFx0XHQ5MCxcblx0XHRcdFx0XHQyMDBcblx0XHRcdFx0XSxcblx0XHRcdFx0XCJ3aWR0aFwiOiAyXG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRcIm91dGxpbmVkUG9seVwiOiB7XG5cdFx0XCJnZW9tZXRyeVR5cGVcIjogXCJlc3JpR2VvbWV0cnlQb2x5Z29uXCIsXG5cdFx0XCJyZW5kZXJlclwiOiB7XG5cdFx0XHRcInR5cGVcIjogXCJzaW1wbGVcIixcblx0XHRcdFwic3ltYm9sXCI6IHtcblx0XHRcdFx0XCJ0eXBlXCI6IFwiZXNyaVNGU1wiLFxuXHRcdFx0XHRcInN0eWxlXCI6IFwiZXNyaVNGU1NvbGlkXCIsXG5cdFx0XHRcdFwiY29sb3JcIjogW1xuXHRcdFx0XHRcdDc2LFxuXHRcdFx0XHRcdDc2LFxuXHRcdFx0XHRcdDEyNSxcblx0XHRcdFx0XHQyMDBcblx0XHRcdFx0XSxcblx0XHRcdFx0XCJvdXRsaW5lXCI6IHtcblx0XHRcdFx0XHRcInR5cGVcIjogXCJlc3JpU0xTXCIsXG5cdFx0XHRcdFx0XCJzdHlsZVwiOiBcImVzcmlTTFNTb2xpZFwiLFxuXHRcdFx0XHRcdFwiY29sb3JcIjogW1xuXHRcdFx0XHRcdFx0MTEwLFxuXHRcdFx0XHRcdFx0MTEwLFxuXHRcdFx0XHRcdFx0MTEwLFxuXHRcdFx0XHRcdFx0MjU1XG5cdFx0XHRcdFx0XSxcblx0XHRcdFx0XHRcIndpZHRoXCI6IDFcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0XCJib3VuZGluZ0JveFBvbHlcIjoge1xuXHRcdFwiZ2VvbWV0cnlUeXBlXCI6IFwiZXNyaUdlb21ldHJ5UG9seWdvblwiLFxuXHRcdFwicmVuZGVyZXJcIjoge1xuXHRcdFx0XCJ0eXBlXCI6IFwic2ltcGxlXCIsXG5cdFx0XHRcInN5bWJvbFwiOiB7XG5cdFx0XHRcdFwidHlwZVwiOiBcImVzcmlTRlNcIixcblx0XHRcdFx0XCJzdHlsZVwiOiBcImVzcmlTRlNTb2xpZFwiLFxuXHRcdFx0XHRcImNvbG9yXCI6IFtcblx0XHRcdFx0XHQyNTUsXG5cdFx0XHRcdFx0MCxcblx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdDY0XG5cdFx0XHRcdF0sXG5cdFx0XHRcdFwib3V0bGluZVwiOiB7XG5cdFx0XHRcdFx0XCJ0eXBlXCI6IFwiZXNyaVNMU1wiLFxuXHRcdFx0XHRcdFwic3R5bGVcIjogXCJlc3JpU0xTU29saWRcIixcblx0XHRcdFx0XHRcImNvbG9yXCI6IFtcblx0XHRcdFx0XHRcdDI0MCxcblx0XHRcdFx0XHRcdDEyOCxcblx0XHRcdFx0XHRcdDEyOCxcblx0XHRcdFx0XHRcdDI1NVxuXHRcdFx0XHRcdF0sXG5cdFx0XHRcdFx0XCJ3aWR0aFwiOiAxXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvZGVmYXVsdFJlbmRlcmVycy5qc29uXG4vLyBtb2R1bGUgaWQgPSA3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9')},function(module,exports,__webpack_require__){"use strict";eval('\n\n/*\r\nStructure and naming:\r\n\r\nthis is a layer Package.  it contains information about a single server-side layer.\r\nnote this is not always 1-to-1 with client side. a client side DynamicLayer can have\r\nmany server-side sublayers, each with their own attribute sets\r\n\r\nDO NOT access the ._attribData property directly, as it will not exist until the first\r\nrequest for attributes.  use the function .getAttribs(), as it will properly handle the\r\ninitial request, or return the previously loaded result (always as a promise)\r\n\r\n{\r\n    "layerId": "<layerid>",\r\n    "featureIdx": 3,\r\n    "getAttribs": getAttribs(),\r\n    "_attribData": Promise(\r\n        <instance of a attribute data object, see below>\r\n    ),\r\n    "layerData":  Promise(\r\n        <instance of a layer data object, see below>\r\n    )\r\n}\r\n\r\nthis is an attribute data object.  it resides in a promise (as the data needs to be downloaded)\r\nit contains the attribute data as an array, and an index mapping object id to array position\r\n{\r\n    "features": [\r\n        {\r\n            "attributes": {\r\n                "objectid": 23,\r\n                "name": "Bruce",\r\n                "age": 27\r\n            }\r\n        },\r\n        ...\r\n    ],\r\n        "oidIndex": {\r\n        "23": 0,\r\n        ...\r\n    }\r\n}\r\n\r\nthis is a layer data object.  it contains information describing the server-side layer\r\n{\r\n    "fields: [\r\n        {\r\n            "name": "objectid",\r\n            "type": "esriFieldTypeOID",\r\n            "alias": "OBJECTID"\r\n        },\r\n        ...\r\n    ],\r\n    "oidField": "objectid",\r\n    "renderer": {...},\r\n    "geometryType": "esriGeometryPoint",\r\n    "layerType": "Feature Layer",\r\n    "minScale": 0,\r\n    "maxScale": 0,\r\n    "extent": {...}\r\n}\r\n\r\n*/\n\n/**\r\n* Will generate an empty object structure to store attributes for a single layer of features\r\n* @private\r\n* @param  {String} featureIdx server index of the layer\r\n* @param  {Object} esriBundle bundle of API classes\r\n* @return {Object} empty layer package object\r\n*/\n\nfunction newLayerPackage(featureIdx, esriBundle) {\n    // only reason this is in a function is to tack on the lazy-load\n    // attribute function. all object properties are added elsewhere\n    var layerPackage = {\n        featureIdx: featureIdx,\n        getAttribs: getAttribs\n    };\n\n    /**\r\n    * Return promise of attribute data object. First request triggers load\r\n    * @private\r\n    * @return {Promise} promise of attribute data object\r\n    */\n    function getAttribs() {\n        if (layerPackage._attribData) {\n            // attributes have already been downloaded.\n            return layerPackage._attribData;\n        }\n\n        // first request for data. create the promise\n        layerPackage._attribData = new Promise(function (resolve, reject) {\n\n            // first wait for the layer specific data to finish loading\n            // NOTE: by the time the application has access to getAttribs(), the .layerData\n            //       property will have been created.\n            layerPackage.layerData.then(function (layerData) {\n                // FIXME switch to native Promise\n                var defFinished = new esriBundle.Deferred();\n                var params = {\n                    maxId: -1,\n                    batchSize: -1,\n                    layerUrl: layerData.load.layerUrl,\n                    oidField: layerData.oidField,\n                    attribs: layerData.load.attribs,\n                    supportsLimit: layerData.load.supportsLimit,\n                    esriBundle: esriBundle\n                };\n\n                // begin the loading process\n                loadDataBatch(params, defFinished);\n\n                // after all data has been loaded\n                defFinished.promise.then(function (features) {\n                    delete layerData.load; // no longer need this info\n\n                    // resolve the promise with the attribute set\n                    resolve(createAttribSet(layerData.oidField, features));\n                }, function (error) {\n                    console.warn(\'error getting attribute data for \' + layerData.load.layerUrl);\n\n                    // attrib data deleted so the first check for attribData doesn\'t return a rejected promise\n                    delete layerPackage._attribData;\n                    reject(error);\n                });\n            });\n        });\n\n        return layerPackage._attribData;\n    }\n\n    return layerPackage;\n}\n\n/**\r\n* Will generate attribute package with object id indexes\r\n* @private\r\n* @param  {String} oidField field containing object id\r\n* @param  {Array} featureData feature objects to index and return\r\n* @return {Object} object containing features and an index by object id\r\n*/\nfunction createAttribSet(oidField, featureData) {\n\n    // add new data to layer data\'s array\n    var res = {\n        features: featureData,\n        oidIndex: {}\n    };\n\n    // make index on object id\n    featureData.forEach(function (elem, idx) {\n        // map object id to index of object in feature array\n        // use toString, as objectid is integer and will act funny using array notation.\n        res.oidIndex[elem.attributes[oidField].toString()] = idx;\n    });\n\n    return res;\n}\n\n// skim the last number off the Url\n// TODO apply more edge case tests to this function\nfunction getLayerIndex(layerUrl) {\n    var re = /\\/(\\d+)\\/?$/;\n    var matches = layerUrl.match(re);\n    if (matches) {\n        return parseInt(matches[1]);\n    }\n    throw new Error(\'Cannot extract layer index from url \' + layerUrl);\n}\n\n/**\r\n* Recursive function to load a full set of attributes, regardless of the maximum output size of the service.\r\n* Passes result back on the provided Deferred object.\r\n*\r\n* @private\r\n* @param  {Object} opts options object that consists of these properties\r\n*         - maxId: integer, largest object id that has already been downloaded.\r\n*         - supportsLimit: boolean, indicates if server result will notify us if our request surpassed the record limit.\r\n*         - batchSize: integer, maximum number of results the service will return. if -1, means currently unknown. only required if supportsLimit is false.\r\n*         - layerUrl: string, URL to feature layer endpoint.\r\n*         - oidField: string, name of attribute containing the object id for the layer.\r\n*         - attribs: string, a comma separated list of attributes to download. \'*\' will download all.\r\n*         - esriBundle: object, standard set of ESRI API objects.\r\n* @param  {Object} callerDef deferred object that resolves when current data has been downloaded\r\n*/\nfunction loadDataBatch(opts, callerDef) {\n    //  fetch attributes from feature layer. where specifies records with id\'s higher than stuff already\n    //  downloaded. no geometry.\n    // FIXME replace esriRequest with a library that handles proxies better\n    var defData = opts.esriBundle.esriRequest({\n        url: opts.layerUrl + \'/query\',\n        content: {\n            where: opts.oidField + \'>\' + opts.maxId,\n            outFields: opts.attribs,\n            returnGeometry: \'false\',\n            f: \'json\'\n        },\n        callbackParamName: \'callback\',\n        handleAs: \'json\'\n    });\n\n    defData.then(function (dataResult) {\n        if (dataResult.features) {\n            var len = dataResult.features.length;\n            if (len > 0) {\n                // figure out if we hit the end of the data. different logic for newer vs older servers.\n                var moreData = void 0;\n                if (opts.supportsLimit) {\n                    moreData = dataResult.exceededTransferLimit;\n                } else {\n                    if (opts.batchSize === -1) {\n                        // this is our first batch. set the max batch size to this batch size\n                        opts.batchSize = len;\n                    }\n                    moreData = len >= opts.batchSize;\n                }\n\n                if (moreData) {\n                    // stash the result and call the service again for the next batch of data.\n                    // max id becomes last object id in the current batch\n                    var thisDef = new opts.esriBundle.Deferred();\n                    opts.maxId = dataResult.features[len - 1].attributes[opts.oidField];\n                    loadDataBatch(opts, thisDef);\n\n                    thisDef.then(function (dataArray) {\n                        // chain the next result to our current result, then pass back to caller\n                        callerDef.resolve(dataResult.features.concat(dataArray));\n                    }, function (error) {\n                        callerDef.reject(error);\n                    });\n                } else {\n                    // done thanks\n                    callerDef.resolve(dataResult.features);\n                }\n            } else {\n                // no more data.  we are done\n                callerDef.resolve([]);\n            }\n        } else {\n            // it is possible to have an error, but it comes back on the "success" channel.\n            callerDef.reject(dataResult.error);\n        }\n    }, function (error) {\n        callerDef.reject(error);\n    });\n}\n\nfunction loadServerAttribsBuilder(esriBundle, geoApi) {\n\n    /**\r\n    * fetch attributes from an ESRI ArcGIS Server Feature Layer Service endpoint\r\n    * @param {String} mapServiceUrl   an arcgis map server service endpoint (no integer index)\r\n    * @param {String} featureIdx      index of where the endpoint is.\r\n    * @param {String} attribs         an optional comma separated list of attributes to download. default \'*\' will download all\r\n    * @return {Object} attributes in a packaged format for asynch access\r\n    */\n    return function (mapServiceUrl, featureIdx) {\n        var attribs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \'*\';\n\n\n        var layerUrl = mapServiceUrl + \'/\' + featureIdx;\n        var layerPackage = newLayerPackage(featureIdx, esriBundle);\n\n        // get information about this layer, asynch\n        layerPackage.layerData = new Promise(function (resolve, reject) {\n            var layerData = {};\n\n            // extract info for this service\n            var defService = esriBundle.esriRequest({\n                url: layerUrl,\n                content: { f: \'json\' },\n                callbackParamName: \'callback\',\n                handleAs: \'json\'\n            });\n\n            defService.then(function (serviceResult) {\n                if (serviceResult && typeof serviceResult.error === \'undefined\') {\n\n                    // properties for all endpoints\n                    layerData.layerType = serviceResult.type;\n                    layerData.geometryType = serviceResult.geometryType || \'none\'; // TODO need to decide what propert default is. Raster Layer has null gt.\n                    layerData.minScale = serviceResult.minScale;\n                    layerData.maxScale = serviceResult.maxScale;\n                    layerData.supportsFeatures = false; // saves us from having to keep comparing type to \'Feature Layer\' on the client\n                    layerData.extent = serviceResult.extent;\n\n                    if (serviceResult.type === \'Feature Layer\') {\n                        layerData.supportsFeatures = true;\n                        layerData.fields = serviceResult.fields;\n                        layerData.nameField = serviceResult.displayField;\n\n                        // find object id field\n                        // NOTE cannot use arrow functions here due to bug\n                        serviceResult.fields.every(function (elem) {\n                            if (elem.type === \'esriFieldTypeOID\') {\n                                layerData.oidField = elem.name;\n                                return false; // break the loop\n                            }\n\n                            return true; // keep looping\n                        });\n\n                        // ensure our attribute list contains the object id\n                        if (attribs !== \'*\') {\n                            if (attribs.split(\',\').indexOf(layerData.oidField) === -1) {\n                                attribs += \',\' + layerData.oidField;\n                            }\n                        }\n\n                        // add renderer and legend\n                        layerData.renderer = serviceResult.drawingInfo.renderer;\n                        layerData.legend = geoApi.symbology.rendererToLegend(layerData.renderer, featureIdx);\n                        geoApi.symbology.enhanceRenderer(layerData.renderer, layerData.legend);\n\n                        // temporarily store things for delayed attributes\n                        layerData.load = {\n                            // version number is only provided on 10.0 SP1 servers and up.\n                            // servers 10.1 and higher support the query limit flag\n                            supportsLimit: (serviceResult.currentVersion || 1) >= 10.1,\n                            layerUrl: layerUrl,\n                            attribs: attribs\n                        };\n                    }\n\n                    // return the layer data promise result\n                    resolve(layerData);\n                } else {\n                    // case where error happened but service request was successful\n                    console.warn(\'Service metadata load error\');\n                    if (serviceResult && serviceResult.error) {\n                        // reject with error\n                        reject(serviceResult.error);\n                    } else {\n                        reject(new Error(\'Unknown error loading service metadata\'));\n                    }\n                }\n            }, function (error) {\n                // failed to load service info. reject with error\n                console.warn(\'Service metadata load error : \' + error);\n                reject(error);\n            });\n        });\n\n        return layerPackage;\n    };\n}\n\nfunction loadFileAttribsBuilder(esriBundle, geoApi) {\n\n    return function (layer) {\n        // feature layer was loaded from a file.\n        // this approach is inefficient (duplicates attributes in layer and in attribute store),\n        // but provides a consistent approach to attributes regardless of where the layer came from\n\n        var layerPackage = newLayerPackage(\'0\', esriBundle); // files have no index (no server), so we use value 0\n\n        // it\'s local, no need to lazy-load\n        layerPackage._attribData = Promise.resolve(createAttribSet(layer.objectIdField, layer.graphics.map(function (elem) {\n            return { attributes: elem.attributes };\n        })));\n\n        var renderer = layer.renderer.toJson();\n        var legend = geoApi.symbology.rendererToLegend(renderer, 0);\n        geoApi.symbology.enhanceRenderer(renderer, legend);\n\n        // TODO revisit the geometry type. ideally, fix our GeoJSON to Feature to populate the property\n        layerPackage.layerData = Promise.resolve({\n            oidField: layer.objectIdField,\n            fields: layer.fields,\n            geometryType: layer.geometryType || JSON.parse(layer._json).layerDefinition.drawingInfo.geometryType,\n            minScale: layer.minScale,\n            maxScale: layer.maxScale,\n            layerType: \'Feature Layer\',\n            renderer: renderer,\n            legend: legend\n        });\n\n        return layerPackage;\n    };\n}\n\n//  Attribute Loader related functions\n// TODO consider re-writing all the asynch stuff with the ECMA-7 style of asynch keywords\nmodule.exports = function (esriBundle, geoApi) {\n    return {\n        loadServerAttribs: loadServerAttribsBuilder(esriBundle, geoApi),\n        loadFileAttribs: loadFileAttribsBuilder(esriBundle, geoApi),\n        getLayerIndex: getLayerIndex\n    };\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXR0cmlidXRlLmpzP2U0NDYiXSwibmFtZXMiOlsibmV3TGF5ZXJQYWNrYWdlIiwiZmVhdHVyZUlkeCIsImVzcmlCdW5kbGUiLCJsYXllclBhY2thZ2UiLCJnZXRBdHRyaWJzIiwiX2F0dHJpYkRhdGEiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImxheWVyRGF0YSIsInRoZW4iLCJkZWZGaW5pc2hlZCIsIkRlZmVycmVkIiwicGFyYW1zIiwibWF4SWQiLCJiYXRjaFNpemUiLCJsYXllclVybCIsImxvYWQiLCJvaWRGaWVsZCIsImF0dHJpYnMiLCJzdXBwb3J0c0xpbWl0IiwibG9hZERhdGFCYXRjaCIsInByb21pc2UiLCJjcmVhdGVBdHRyaWJTZXQiLCJmZWF0dXJlcyIsImNvbnNvbGUiLCJ3YXJuIiwiZXJyb3IiLCJmZWF0dXJlRGF0YSIsInJlcyIsIm9pZEluZGV4IiwiZm9yRWFjaCIsImVsZW0iLCJpZHgiLCJhdHRyaWJ1dGVzIiwidG9TdHJpbmciLCJnZXRMYXllckluZGV4IiwicmUiLCJtYXRjaGVzIiwibWF0Y2giLCJwYXJzZUludCIsIkVycm9yIiwib3B0cyIsImNhbGxlckRlZiIsImRlZkRhdGEiLCJlc3JpUmVxdWVzdCIsInVybCIsImNvbnRlbnQiLCJ3aGVyZSIsIm91dEZpZWxkcyIsInJldHVybkdlb21ldHJ5IiwiZiIsImNhbGxiYWNrUGFyYW1OYW1lIiwiaGFuZGxlQXMiLCJkYXRhUmVzdWx0IiwibGVuIiwibGVuZ3RoIiwibW9yZURhdGEiLCJleGNlZWRlZFRyYW5zZmVyTGltaXQiLCJ0aGlzRGVmIiwiY29uY2F0IiwiZGF0YUFycmF5IiwibG9hZFNlcnZlckF0dHJpYnNCdWlsZGVyIiwiZ2VvQXBpIiwibWFwU2VydmljZVVybCIsImRlZlNlcnZpY2UiLCJzZXJ2aWNlUmVzdWx0IiwibGF5ZXJUeXBlIiwidHlwZSIsImdlb21ldHJ5VHlwZSIsIm1pblNjYWxlIiwibWF4U2NhbGUiLCJzdXBwb3J0c0ZlYXR1cmVzIiwiZXh0ZW50IiwiZmllbGRzIiwibmFtZUZpZWxkIiwiZGlzcGxheUZpZWxkIiwiZXZlcnkiLCJuYW1lIiwic3BsaXQiLCJpbmRleE9mIiwicmVuZGVyZXIiLCJkcmF3aW5nSW5mbyIsImxlZ2VuZCIsInN5bWJvbG9neSIsInJlbmRlcmVyVG9MZWdlbmQiLCJlbmhhbmNlUmVuZGVyZXIiLCJjdXJyZW50VmVyc2lvbiIsImxvYWRGaWxlQXR0cmlic0J1aWxkZXIiLCJsYXllciIsIm9iamVjdElkRmllbGQiLCJncmFwaGljcyIsIm1hcCIsInRvSnNvbiIsIkpTT04iLCJwYXJzZSIsIl9qc29uIiwibGF5ZXJEZWZpbml0aW9uIiwibW9kdWxlIiwiZXhwb3J0cyIsImxvYWRTZXJ2ZXJBdHRyaWJzIiwibG9hZEZpbGVBdHRyaWJzIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBK0RBOzs7Ozs7OztBQU9BLFNBQVNBLGVBQVQsQ0FBeUJDLFVBQXpCLEVBQXFDQyxVQUFyQyxFQUFpRDtBQUM3QztBQUNBO0FBQ0EsUUFBTUMsZUFBZTtBQUNqQkYsOEJBRGlCO0FBRWpCRztBQUZpQixLQUFyQjs7QUFLQTs7Ozs7QUFLQSxhQUFTQSxVQUFULEdBQXNCO0FBQ2xCLFlBQUlELGFBQWFFLFdBQWpCLEVBQThCO0FBQzFCO0FBQ0EsbUJBQU9GLGFBQWFFLFdBQXBCO0FBQ0g7O0FBRUQ7QUFDQUYscUJBQWFFLFdBQWIsR0FBMkIsSUFBSUMsT0FBSixDQUFZLFVBQUNDLE9BQUQsRUFBVUMsTUFBVixFQUFxQjs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0FMLHlCQUFhTSxTQUFiLENBQXVCQyxJQUF2QixDQUE0QixxQkFBYTtBQUNyQztBQUNBLG9CQUFNQyxjQUFjLElBQUlULFdBQVdVLFFBQWYsRUFBcEI7QUFDQSxvQkFBTUMsU0FBUztBQUNYQywyQkFBTyxDQUFDLENBREc7QUFFWEMsK0JBQVcsQ0FB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QkFQcUM7QUFRckNFO0FBUnFDLFNBQWhCLENBQXpCOztBQVdBLGVBQU9oRixZQUFQO0FBQ0gsS0E3QkQ7QUE4Qkg7O0FBRUQ7QUFDQTtBQUNBK0YsT0FBT0MsT0FBUCxHQUFpQixVQUFDakcsVUFBRCxFQUFhNkQsTUFBYixFQUF3QjtBQUNyQyxXQUFPO0FBQ0hxQywyQkFBbUJ0Qyx5QkFBeUI1RCxVQUF6QixFQUFxQzZELE1BQXJDLENBRGhCO0FBRUhzQyx5QkFBaUJiLHVCQUF1QnRGLFVBQXZCLEVBQW1DNkQsTUFBbkMsQ0FGZDtBQUdIM0I7QUFIRyxLQUFQO0FBS0gsQ0FORCIsImZpbGUiOiI3MS5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuXHJcbi8qXHJcblN0cnVjdHVyZSBhbmQgbmFtaW5nOlxyXG5cclxudGhpcyBpcyBhIGxheWVyIFBhY2thZ2UuICBpdCBjb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCBhIHNpbmdsZSBzZXJ2ZXItc2lkZSBsYXllci5cclxubm90ZSB0aGlzIGlzIG5vdCBhbHdheXMgMS10by0xIHdpdGggY2xpZW50IHNpZGUuIGEgY2xpZW50IHNpZGUgRHluYW1pY0xheWVyIGNhbiBoYXZlXHJcbm1hbnkgc2VydmVyLXNpZGUgc3VibGF5ZXJzLCBlYWNoIHdpdGggdGhlaXIgb3duIGF0dHJpYnV0ZSBzZXRzXHJcblxyXG5ETyBOT1QgYWNjZXNzIHRoZSAuX2F0dHJpYkRhdGEgcHJvcGVydHkgZGlyZWN0bHksIGFzIGl0IHdpbGwgbm90IGV4aXN0IHVudGlsIHRoZSBmaXJzdFxyXG5yZXF1ZXN0IGZvciBhdHRyaWJ1dGVzLiAgdXNlIHRoZSBmdW5jdGlvbiAuZ2V0QXR0cmlicygpLCBhcyBpdCB3aWxsIHByb3Blcmx5IGhhbmRsZSB0aGVcclxuaW5pdGlhbCByZXF1ZXN0LCBvciByZXR1cm4gdGhlIHByZXZpb3VzbHkgbG9hZGVkIHJlc3VsdCAoYWx3YXlzIGFzIGEgcHJvbWlzZSlcclxuXHJcbntcclxuICAgIFwibGF5ZXJJZFwiOiBcIjxsYXllcmlkPlwiLFxyXG4gICAgXCJmZWF0dXJlSWR4XCI6IDMsXHJcbiAgICBcImdldEF0dHJpYnNcIjogZ2V0QXR0cmlicygpLFxyXG4gICAgXCJfYXR0cmliRGF0YVwiOiBQcm9taXNlKFxyXG4gICAgICAgIDxpbnN0YW5jZSBvZiBhIGF0dHJpYnV0ZSBkYXRhIG9iamVjdCwgc2VlIGJlbG93PlxyXG4gICAgKSxcclxuICAgIFwibGF5ZXJEYXRhXCI6ICBQcm9taXNlKFxyXG4gICAgICAgIDxpbnN0YW5jZSBvZiBhIGxheWVyIGRhdGEgb2JqZWN0LCBzZWUgYmVsb3c+XHJcbiAgICApXHJcbn1cclxuXHJcbnRoaXMgaXMgYW4gYXR0cmlidXRlIGRhdGEgb2JqZWN0LiAgaXQgcmVzaWRlcyBpbiBhIHByb21pc2UgKGFzIHRoZSBkYXRhIG5lZWRzIHRvIGJlIGRvd25sb2FkZWQpXHJcbml0IGNvbnRhaW5zIHRoZSBhdHRyaWJ1dGUgZGF0YSBhcyBhbiBhcnJheSwgYW5kIGFuIGluZGV4IG1hcHBpbmcgb2JqZWN0IGlkIHRvIGFycmF5IHBvc2l0aW9uXHJcbntcclxuICAgIFwiZmVhdHVyZXNcIjogW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgXCJhdHRyaWJ1dGVzXCI6IHtcclxuICAgICAgICAgICAgICAgIFwib2JqZWN0aWRcIjogMjMsXHJcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJCcnVjZVwiLFxyXG4gICAgICAgICAgICAgICAgXCJhZ2VcIjogMjdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLi4uXHJcbiAgICBdLFxyXG4gICAgICAgIFwib2lkSW5kZXhcIjoge1xyXG4gICAgICAgIFwiMjNcIjogMCxcclxuICAgICAgICAuLi5cclxuICAgIH1cclxufVxyXG5cclxudGhpcyBpcyBhIGxheWVyIGRhdGEgb2JqZWN0LiAgaXQgY29udGFpbnMgaW5mb3JtYXRpb24gZGVzY3JpYmluZyB0aGUgc2VydmVyLXNpZGUgbGF5ZXJcclxue1xyXG4gICAgXCJmaWVsZHM6IFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIm9iamVjdGlkXCIsXHJcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImVzcmlGaWVsZFR5cGVPSURcIixcclxuICAgICAgICAgICAgXCJhbGlhc1wiOiBcIk9CSkVDVElEXCJcclxuICAgICAgICB9LFxyXG4gICAgICAgIC4uLlxyXG4gICAgXSxcclxuICAgIFwib2lkRmllbGRcIjogXCJvYmplY3RpZFwiLFxyXG4gICAgXCJyZW5kZXJlclwiOiB7Li4ufSxcclxuICAgIFwiZ2VvbWV0cnlUeXBlXCI6IFwiZXNyaUdlb21ldHJ5UG9pbnRcIixcclxuICAgIFwibGF5ZXJUeXBlXCI6IFwiRmVhdHVyZSBMYXllclwiLFxyXG4gICAgXCJtaW5TY2FsZVwiOiAwLFxyXG4gICAgXCJtYXhTY2FsZVwiOiAwLFxyXG4gICAgXCJleHRlbnRcIjogey4uLn1cclxufVxyXG5cclxuKi9cclxuXHJcbi8qKlxyXG4qIFdpbGwgZ2VuZXJhdGUgYW4gZW1wdHkgb2JqZWN0IHN0cnVjdHVyZSB0byBzdG9yZSBhdHRyaWJ1dGVzIGZvciBhIHNpbmdsZSBsYXllciBvZiBmZWF0dXJlc1xyXG4qIEBwcml2YXRlXHJcbiogQHBhcmFtICB7U3RyaW5nfSBmZWF0dXJlSWR4IHNlcnZlciBpbmRleCBvZiB0aGUgbGF5ZXJcclxuKiBAcGFyYW0gIHtPYmplY3R9IGVzcmlCdW5kbGUgYnVuZGxlIG9mIEFQSSBjbGFzc2VzXHJcbiogQHJldHVybiB7T2JqZWN0fSBlbXB0eSBsYXllciBwYWNrYWdlIG9iamVjdFxyXG4qL1xyXG5mdW5jdGlvbiBuZXdMYXllclBhY2thZ2UoZmVhdHVyZUlkeCwgZXNyaUJ1bmRsZSkge1xyXG4gICAgLy8gb25seSByZWFzb24gdGhpcyBpcyBpbiBhIGZ1bmN0aW9uIGlzIHRvIHRhY2sgb24gdGhlIGxhenktbG9hZFxyXG4gICAgLy8gYXR0cmlidXRlIGZ1bmN0aW9uLiBhbGwgb2JqZWN0IHByb3BlcnRpZXMgYXJlIGFkZGVkIGVsc2V3aGVyZVxyXG4gICAgY29uc3QgbGF5ZXJQYWNrYWdlID0ge1xyXG4gICAgICAgIGZlYXR1cmVJZHgsXHJcbiAgICAgICAgZ2V0QXR0cmlic1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICogUmV0dXJuIHByb21pc2Ugb2YgYXR0cmlidXRlIGRhdGEgb2JqZWN0LiBGaXJzdCByZXF1ZXN0IHRyaWdnZXJzIGxvYWRcclxuICAgICogQHByaXZhdGVcclxuICAgICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSBvZiBhdHRyaWJ1dGUgZGF0YSBvYmplY3RcclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRBdHRyaWJzKCkge1xyXG4gICAgICAgIGlmIChsYXllclBhY2thZ2UuX2F0dHJpYkRhdGEpIHtcclxuICAgICAgICAgICAgLy8gYXR0cmlidXRlcyBoYXZlIGFscmVhZHkgYmVlbiBkb3dubG9hZGVkLlxyXG4gICAgICAgICAgICByZXR1cm4gbGF5ZXJQYWNrYWdlLl9hdHRyaWJEYXRhO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gZmlyc3QgcmVxdWVzdCBmb3IgZGF0YS4gY3JlYXRlIHRoZSBwcm9taXNlXHJcbiAgICAgICAgbGF5ZXJQYWNrYWdlLl9hdHRyaWJEYXRhID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG5cclxuICAgICAgICAgICAgLy8gZmlyc3Qgd2FpdCBmb3IgdGhlIGxheWVyIHNwZWNpZmljIGRhdGEgdG8gZmluaXNoIGxvYWRpbmdcclxuICAgICAgICAgICAgLy8gTk9URTogYnkgdGhlIHRpbWUgdGhlIGFwcGxpY2F0aW9uIGhhcyBhY2Nlc3MgdG8gZ2V0QXR0cmlicygpLCB0aGUgLmxheWVyRGF0YVxyXG4gICAgICAgICAgICAvLyAgICAgICBwcm9wZXJ0eSB3aWxsIGhhdmUgYmVlbiBjcmVhdGVkLlxyXG4gICAgICAgICAgICBsYXllclBhY2thZ2UubGF5ZXJEYXRhLnRoZW4obGF5ZXJEYXRhID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIEZJWE1FIHN3aXRjaCB0byBuYXRpdmUgUHJvbWlzZVxyXG4gICAgICAgICAgICAgICAgY29uc3QgZGVmRmluaXNoZWQgPSBuZXcgZXNyaUJ1bmRsZS5EZWZlcnJlZCgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGFyYW1zID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIG1heElkOiAtMSxcclxuICAgICAgICAgICAgICAgICAgICBiYXRjaFNpemU6IC0xLFxyXG4gICAgICAgICAgICAgICAgICAgIGxheWVyVXJsOiBsYXllckRhdGEubG9hZC5sYXllclVybCxcclxuICAgICAgICAgICAgICAgICAgICBvaWRGaWVsZDogbGF5ZXJEYXRhLm9pZEZpZWxkLFxyXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnM6IGxheWVyRGF0YS5sb2FkLmF0dHJpYnMsXHJcbiAgICAgICAgICAgICAgICAgICAgc3VwcG9ydHNMaW1pdDogbGF5ZXJEYXRhLmxvYWQuc3VwcG9ydHNMaW1pdCxcclxuICAgICAgICAgICAgICAgICAgICBlc3JpQnVuZGxlXHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGJlZ2luIHRoZSBsb2FkaW5nIHByb2Nlc3NcclxuICAgICAgICAgICAgICAgIGxvYWREYXRhQmF0Y2gocGFyYW1zLCBkZWZGaW5pc2hlZCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gYWZ0ZXIgYWxsIGRhdGEgaGFzIGJlZW4gbG9hZGVkXHJcbiAgICAgICAgICAgICAgICBkZWZGaW5pc2hlZC5wcm9taXNlLnRoZW4oZmVhdHVyZXMgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBsYXllckRhdGEubG9hZDsgLy8gbm8gbG9uZ2VyIG5lZWQgdGhpcyBpbmZvXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlc29sdmUgdGhlIHByb21pc2Ugd2l0aCB0aGUgYXR0cmlidXRlIHNldFxyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoY3JlYXRlQXR0cmliU2V0KGxheWVyRGF0YS5vaWRGaWVsZCwgZmVhdHVyZXMpKTtcclxuICAgICAgICAgICAgICAgIH0sIGVycm9yID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ2Vycm9yIGdldHRpbmcgYXR0cmlidXRlIGRhdGEgZm9yICcgKyBsYXllckRhdGEubG9hZC5sYXllclVybCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGF0dHJpYiBkYXRhIGRlbGV0ZWQgc28gdGhlIGZpcnN0IGNoZWNrIGZvciBhdHRyaWJEYXRhIGRvZXNuJ3QgcmV0dXJuIGEgcmVqZWN0ZWQgcHJvbWlzZVxyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBsYXllclBhY2thZ2UuX2F0dHJpYkRhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGxheWVyUGFja2FnZS5fYXR0cmliRGF0YTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbGF5ZXJQYWNrYWdlO1xyXG59XHJcblxyXG4vKipcclxuKiBXaWxsIGdlbmVyYXRlIGF0dHJpYnV0ZSBwYWNrYWdlIHdpdGggb2JqZWN0IGlkIGluZGV4ZXNcclxuKiBAcHJpdmF0ZVxyXG4qIEBwYXJhbSAge1N0cmluZ30gb2lkRmllbGQgZmllbGQgY29udGFpbmluZyBvYmplY3QgaWRcclxuKiBAcGFyYW0gIHtBcnJheX0gZmVhdHVyZURhdGEgZmVhdHVyZSBvYmplY3RzIHRvIGluZGV4IGFuZCByZXR1cm5cclxuKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCBjb250YWluaW5nIGZlYXR1cmVzIGFuZCBhbiBpbmRleCBieSBvYmplY3QgaWRcclxuKi9cclxuZnVuY3Rpb24gY3JlYXRlQXR0cmliU2V0KG9pZEZpZWxkLCBmZWF0dXJlRGF0YSkge1xyXG5cclxuICAgIC8vIGFkZCBuZXcgZGF0YSB0byBsYXllciBkYXRhJ3MgYXJyYXlcclxuICAgIGNvbnN0IHJlcyA9IHtcclxuICAgICAgICBmZWF0dXJlczogZmVhdHVyZURhdGEsXHJcbiAgICAgICAgb2lkSW5kZXg6IHt9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIG1ha2UgaW5kZXggb24gb2JqZWN0IGlkXHJcbiAgICBmZWF0dXJlRGF0YS5mb3JFYWNoKChlbGVtLCBpZHgpID0+IHtcclxuICAgICAgICAvLyBtYXAgb2JqZWN0IGlkIHRvIGluZGV4IG9mIG9iamVjdCBpbiBmZWF0dXJlIGFycmF5XHJcbiAgICAgICAgLy8gdXNlIHRvU3RyaW5nLCBhcyBvYmplY3RpZCBpcyBpbnRlZ2VyIGFuZCB3aWxsIGFjdCBmdW5ueSB1c2luZyBhcnJheSBub3RhdGlvbi5cclxuICAgICAgICByZXMub2lkSW5kZXhbZWxlbS5hdHRyaWJ1dGVzW29pZEZpZWxkXS50b1N0cmluZygpXSA9IGlkeDtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuXHJcbi8vIHNraW0gdGhlIGxhc3QgbnVtYmVyIG9mZiB0aGUgVXJsXHJcbi8vIFRPRE8gYXBwbHkgbW9yZSBlZGdlIGNhc2UgdGVzdHMgdG8gdGhpcyBmdW5jdGlvblxyXG5mdW5jdGlvbiBnZXRMYXllckluZGV4KGxheWVyVXJsKSB7XHJcbiAgICBjb25zdCByZSA9IC9cXC8oXFxkKylcXC8/JC87XHJcbiAgICBjb25zdCBtYXRjaGVzID0gbGF5ZXJVcmwubWF0Y2gocmUpO1xyXG4gICAgaWYgKG1hdGNoZXMpIHtcclxuICAgICAgICByZXR1cm4gcGFyc2VJbnQobWF0Y2hlc1sxXSk7XHJcbiAgICB9XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBleHRyYWN0IGxheWVyIGluZGV4IGZyb20gdXJsICcgKyBsYXllclVybCk7XHJcbn1cclxuXHJcbi8qKlxyXG4qIFJlY3Vyc2l2ZSBmdW5jdGlvbiB0byBsb2FkIGEgZnVsbCBzZXQgb2YgYXR0cmlidXRlcywgcmVnYXJkbGVzcyBvZiB0aGUgbWF4aW11bSBvdXRwdXQgc2l6ZSBvZiB0aGUgc2VydmljZS5cclxuKiBQYXNzZXMgcmVzdWx0IGJhY2sgb24gdGhlIHByb3ZpZGVkIERlZmVycmVkIG9iamVjdC5cclxuKlxyXG4qIEBwcml2YXRlXHJcbiogQHBhcmFtICB7T2JqZWN0fSBvcHRzIG9wdGlvbnMgb2JqZWN0IHRoYXQgY29uc2lzdHMgb2YgdGhlc2UgcHJvcGVydGllc1xyXG4qICAgICAgICAgLSBtYXhJZDogaW50ZWdlciwgbGFyZ2VzdCBvYmplY3QgaWQgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIGRvd25sb2FkZWQuXHJcbiogICAgICAgICAtIHN1cHBvcnRzTGltaXQ6IGJvb2xlYW4sIGluZGljYXRlcyBpZiBzZXJ2ZXIgcmVzdWx0IHdpbGwgbm90aWZ5IHVzIGlmIG91ciByZXF1ZXN0IHN1cnBhc3NlZCB0aGUgcmVjb3JkIGxpbWl0LlxyXG4qICAgICAgICAgLSBiYXRjaFNpemU6IGludGVnZXIsIG1heGltdW0gbnVtYmVyIG9mIHJlc3VsdHMgdGhlIHNlcnZpY2Ugd2lsbCByZXR1cm4uIGlmIC0xLCBtZWFucyBjdXJyZW50bHkgdW5rbm93bi4gb25seSByZXF1aXJlZCBpZiBzdXBwb3J0c0xpbWl0IGlzIGZhbHNlLlxyXG4qICAgICAgICAgLSBsYXllclVybDogc3RyaW5nLCBVUkwgdG8gZmVhdHVyZSBsYXllciBlbmRwb2ludC5cclxuKiAgICAgICAgIC0gb2lkRmllbGQ6IHN0cmluZywgbmFtZSBvZiBhdHRyaWJ1dGUgY29udGFpbmluZyB0aGUgb2JqZWN0IGlkIGZvciB0aGUgbGF5ZXIuXHJcbiogICAgICAgICAtIGF0dHJpYnM6IHN0cmluZywgYSBjb21tYSBzZXBhcmF0ZWQgbGlzdCBvZiBhdHRyaWJ1dGVzIHRvIGRvd25sb2FkLiAnKicgd2lsbCBkb3dubG9hZCBhbGwuXHJcbiogICAgICAgICAtIGVzcmlCdW5kbGU6IG9iamVjdCwgc3RhbmRhcmQgc2V0IG9mIEVTUkkgQVBJIG9iamVjdHMuXHJcbiogQHBhcmFtICB7T2JqZWN0fSBjYWxsZXJEZWYgZGVmZXJyZWQgb2JqZWN0IHRoYXQgcmVzb2x2ZXMgd2hlbiBjdXJyZW50IGRhdGEgaGFzIGJlZW4gZG93bmxvYWRlZFxyXG4qL1xyXG5mdW5jdGlvbiBsb2FkRGF0YUJhdGNoKG9wdHMsIGNhbGxlckRlZikge1xyXG4gICAgLy8gIGZldGNoIGF0dHJpYnV0ZXMgZnJvbSBmZWF0dXJlIGxheWVyLiB3aGVyZSBzcGVjaWZpZXMgcmVjb3JkcyB3aXRoIGlkJ3MgaGlnaGVyIHRoYW4gc3R1ZmYgYWxyZWFkeVxyXG4gICAgLy8gIGRvd25sb2FkZWQuIG5vIGdlb21ldHJ5LlxyXG4gICAgLy8gRklYTUUgcmVwbGFjZSBlc3JpUmVxdWVzdCB3aXRoIGEgbGlicmFyeSB0aGF0IGhhbmRsZXMgcHJveGllcyBiZXR0ZXJcclxuICAgIGNvbnN0IGRlZkRhdGEgPSBvcHRzLmVzcmlCdW5kbGUuZXNyaVJlcXVlc3Qoe1xyXG4gICAgICAgIHVybDogb3B0cy5sYXllclVybCArICcvcXVlcnknLFxyXG4gICAgICAgIGNvbnRlbnQ6IHtcclxuICAgICAgICAgICAgd2hlcmU6IG9wdHMub2lkRmllbGQgKyAnPicgKyBvcHRzLm1heElkLFxyXG4gICAgICAgICAgICBvdXRGaWVsZHM6IG9wdHMuYXR0cmlicyxcclxuICAgICAgICAgICAgcmV0dXJuR2VvbWV0cnk6ICdmYWxzZScsXHJcbiAgICAgICAgICAgIGY6ICdqc29uJyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNhbGxiYWNrUGFyYW1OYW1lOiAnY2FsbGJhY2snLFxyXG4gICAgICAgIGhhbmRsZUFzOiAnanNvbidcclxuICAgIH0pO1xyXG5cclxuICAgIGRlZkRhdGEudGhlbihkYXRhUmVzdWx0ID0+IHtcclxuICAgICAgICBpZiAoZGF0YVJlc3VsdC5mZWF0dXJlcykge1xyXG4gICAgICAgICAgICBjb25zdCBsZW4gPSBkYXRhUmVzdWx0LmZlYXR1cmVzLmxlbmd0aDtcclxuICAgICAgICAgICAgaWYgKGxlbiA+IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIGZpZ3VyZSBvdXQgaWYgd2UgaGl0IHRoZSBlbmQgb2YgdGhlIGRhdGEuIGRpZmZlcmVudCBsb2dpYyBmb3IgbmV3ZXIgdnMgb2xkZXIgc2VydmVycy5cclxuICAgICAgICAgICAgICAgIGxldCBtb3JlRGF0YTtcclxuICAgICAgICAgICAgICAgIGlmIChvcHRzLnN1cHBvcnRzTGltaXQpIHtcclxuICAgICAgICAgICAgICAgICAgICBtb3JlRGF0YSA9IGRhdGFSZXN1bHQuZXhjZWVkZWRUcmFuc2ZlckxpbWl0O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0cy5iYXRjaFNpemUgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgb3VyIGZpcnN0IGJhdGNoLiBzZXQgdGhlIG1heCBiYXRjaCBzaXplIHRvIHRoaXMgYmF0Y2ggc2l6ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRzLmJhdGNoU2l6ZSA9IGxlbjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbW9yZURhdGEgPSAobGVuID49IG9wdHMuYmF0Y2hTaXplKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAobW9yZURhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBzdGFzaCB0aGUgcmVzdWx0IGFuZCBjYWxsIHRoZSBzZXJ2aWNlIGFnYWluIGZvciB0aGUgbmV4dCBiYXRjaCBvZiBkYXRhLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG1heCBpZCBiZWNvbWVzIGxhc3Qgb2JqZWN0IGlkIGluIHRoZSBjdXJyZW50IGJhdGNoXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGhpc0RlZiA9IG5ldyBvcHRzLmVzcmlCdW5kbGUuRGVmZXJyZWQoKTtcclxuICAgICAgICAgICAgICAgICAgICBvcHRzLm1heElkID0gZGF0YVJlc3VsdC5mZWF0dXJlc1tsZW4gLSAxXS5hdHRyaWJ1dGVzW29wdHMub2lkRmllbGRdO1xyXG4gICAgICAgICAgICAgICAgICAgIGxvYWREYXRhQmF0Y2gob3B0cywgdGhpc0RlZik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXNEZWYudGhlbihkYXRhQXJyYXkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGFpbiB0aGUgbmV4dCByZXN1bHQgdG8gb3VyIGN1cnJlbnQgcmVzdWx0LCB0aGVuIHBhc3MgYmFjayB0byBjYWxsZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGVyRGVmLnJlc29sdmUoZGF0YVJlc3VsdC5mZWF0dXJlcy5jb25jYXQoZGF0YUFycmF5KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsZXJEZWYucmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZG9uZSB0aGFua3NcclxuICAgICAgICAgICAgICAgICAgICBjYWxsZXJEZWYucmVzb2x2ZShkYXRhUmVzdWx0LmZlYXR1cmVzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIG5vIG1vcmUgZGF0YS4gIHdlIGFyZSBkb25lXHJcbiAgICAgICAgICAgICAgICBjYWxsZXJEZWYucmVzb2x2ZShbXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBpdCBpcyBwb3NzaWJsZSB0byBoYXZlIGFuIGVycm9yLCBidXQgaXQgY29tZXMgYmFjayBvbiB0aGUgXCJzdWNjZXNzXCIgY2hhbm5lbC5cclxuICAgICAgICAgICAgY2FsbGVyRGVmLnJlamVjdChkYXRhUmVzdWx0LmVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGVycm9yID0+IHtcclxuICAgICAgICBjYWxsZXJEZWYucmVqZWN0KGVycm9yKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBsb2FkU2VydmVyQXR0cmlic0J1aWxkZXIoZXNyaUJ1bmRsZSwgZ2VvQXBpKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIGZldGNoIGF0dHJpYnV0ZXMgZnJvbSBhbiBFU1JJIEFyY0dJUyBTZXJ2ZXIgRmVhdHVyZSBMYXllciBTZXJ2aWNlIGVuZHBvaW50XHJcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSBtYXBTZXJ2aWNlVXJsICAgYW4gYXJjZ2lzIG1hcCBzZXJ2ZXIgc2VydmljZSBlbmRwb2ludCAobm8gaW50ZWdlciBpbmRleClcclxuICAgICogQHBhcmFtIHtTdHJpbmd9IGZlYXR1cmVJZHggICAgICBpbmRleCBvZiB3aGVyZSB0aGUgZW5kcG9pbnQgaXMuXHJcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyaWJzICAgICAgICAgYW4gb3B0aW9uYWwgY29tbWEgc2VwYXJhdGVkIGxpc3Qgb2YgYXR0cmlidXRlcyB0byBkb3dubG9hZC4gZGVmYXVsdCAnKicgd2lsbCBkb3dubG9hZCBhbGxcclxuICAgICogQHJldHVybiB7T2JqZWN0fSBhdHRyaWJ1dGVzIGluIGEgcGFja2FnZWQgZm9ybWF0IGZvciBhc3luY2ggYWNjZXNzXHJcbiAgICAqL1xyXG4gICAgcmV0dXJuIChtYXBTZXJ2aWNlVXJsLCBmZWF0dXJlSWR4LCBhdHRyaWJzID0gJyonKSA9PiB7XHJcblxyXG4gICAgICAgIGNvbnN0IGxheWVyVXJsID0gbWFwU2VydmljZVVybCArICcvJyArIGZlYXR1cmVJZHg7XHJcbiAgICAgICAgY29uc3QgbGF5ZXJQYWNrYWdlID0gbmV3TGF5ZXJQYWNrYWdlKGZlYXR1cmVJZHgsIGVzcmlCdW5kbGUpO1xyXG5cclxuICAgICAgICAvLyBnZXQgaW5mb3JtYXRpb24gYWJvdXQgdGhpcyBsYXllciwgYXN5bmNoXHJcbiAgICAgICAgbGF5ZXJQYWNrYWdlLmxheWVyRGF0YSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbGF5ZXJEYXRhID0ge307XHJcblxyXG4gICAgICAgICAgICAvLyBleHRyYWN0IGluZm8gZm9yIHRoaXMgc2VydmljZVxyXG4gICAgICAgICAgICBjb25zdCBkZWZTZXJ2aWNlID0gZXNyaUJ1bmRsZS5lc3JpUmVxdWVzdCh7XHJcbiAgICAgICAgICAgICAgICB1cmw6IGxheWVyVXJsLFxyXG4gICAgICAgICAgICAgICAgY29udGVudDogeyBmOiAnanNvbicgfSxcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrUGFyYW1OYW1lOiAnY2FsbGJhY2snLFxyXG4gICAgICAgICAgICAgICAgaGFuZGxlQXM6ICdqc29uJyxcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBkZWZTZXJ2aWNlLnRoZW4oc2VydmljZVJlc3VsdCA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VydmljZVJlc3VsdCAmJiAodHlwZW9mIHNlcnZpY2VSZXN1bHQuZXJyb3IgPT09ICd1bmRlZmluZWQnKSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBwcm9wZXJ0aWVzIGZvciBhbGwgZW5kcG9pbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXJEYXRhLmxheWVyVHlwZSA9IHNlcnZpY2VSZXN1bHQudHlwZTtcclxuICAgICAgICAgICAgICAgICAgICBsYXllckRhdGEuZ2VvbWV0cnlUeXBlID0gc2VydmljZVJlc3VsdC5nZW9tZXRyeVR5cGUgfHwgJ25vbmUnOyAvLyBUT0RPIG5lZWQgdG8gZGVjaWRlIHdoYXQgcHJvcGVydCBkZWZhdWx0IGlzLiBSYXN0ZXIgTGF5ZXIgaGFzIG51bGwgZ3QuXHJcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXJEYXRhLm1pblNjYWxlID0gc2VydmljZVJlc3VsdC5taW5TY2FsZTtcclxuICAgICAgICAgICAgICAgICAgICBsYXllckRhdGEubWF4U2NhbGUgPSBzZXJ2aWNlUmVzdWx0Lm1heFNjYWxlO1xyXG4gICAgICAgICAgICAgICAgICAgIGxheWVyRGF0YS5zdXBwb3J0c0ZlYXR1cmVzID0gZmFsc2U7IC8vIHNhdmVzIHVzIGZyb20gaGF2aW5nIHRvIGtlZXAgY29tcGFyaW5nIHR5cGUgdG8gJ0ZlYXR1cmUgTGF5ZXInIG9uIHRoZSBjbGllbnRcclxuICAgICAgICAgICAgICAgICAgICBsYXllckRhdGEuZXh0ZW50ID0gc2VydmljZVJlc3VsdC5leHRlbnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXJ2aWNlUmVzdWx0LnR5cGUgPT09ICdGZWF0dXJlIExheWVyJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXllckRhdGEuc3VwcG9ydHNGZWF0dXJlcyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyRGF0YS5maWVsZHMgPSBzZXJ2aWNlUmVzdWx0LmZpZWxkcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJEYXRhLm5hbWVGaWVsZCA9IHNlcnZpY2VSZXN1bHQuZGlzcGxheUZpZWxkO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmluZCBvYmplY3QgaWQgZmllbGRcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTk9URSBjYW5ub3QgdXNlIGFycm93IGZ1bmN0aW9ucyBoZXJlIGR1ZSB0byBidWdcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VydmljZVJlc3VsdC5maWVsZHMuZXZlcnkoZnVuY3Rpb24gKGVsZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtLnR5cGUgPT09ICdlc3JpRmllbGRUeXBlT0lEJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyRGF0YS5vaWRGaWVsZCA9IGVsZW0ubmFtZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIGJyZWFrIHRoZSBsb29wXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIGtlZXAgbG9vcGluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVuc3VyZSBvdXIgYXR0cmlidXRlIGxpc3QgY29udGFpbnMgdGhlIG9iamVjdCBpZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXR0cmlicyAhPT0gJyonKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXR0cmlicy5zcGxpdCgnLCcpLmluZGV4T2YobGF5ZXJEYXRhLm9pZEZpZWxkKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJzICs9ICgnLCcgKyBsYXllckRhdGEub2lkRmllbGQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGQgcmVuZGVyZXIgYW5kIGxlZ2VuZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXllckRhdGEucmVuZGVyZXIgPSBzZXJ2aWNlUmVzdWx0LmRyYXdpbmdJbmZvLnJlbmRlcmVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXllckRhdGEubGVnZW5kID0gZ2VvQXBpLnN5bWJvbG9neS5yZW5kZXJlclRvTGVnZW5kKGxheWVyRGF0YS5yZW5kZXJlciwgZmVhdHVyZUlkeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb0FwaS5zeW1ib2xvZ3kuZW5oYW5jZVJlbmRlcmVyKGxheWVyRGF0YS5yZW5kZXJlciwgbGF5ZXJEYXRhLmxlZ2VuZCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0ZW1wb3JhcmlseSBzdG9yZSB0aGluZ3MgZm9yIGRlbGF5ZWQgYXR0cmlidXRlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXllckRhdGEubG9hZCA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZlcnNpb24gbnVtYmVyIGlzIG9ubHkgcHJvdmlkZWQgb24gMTAuMCBTUDEgc2VydmVycyBhbmQgdXAuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXJ2ZXJzIDEwLjEgYW5kIGhpZ2hlciBzdXBwb3J0IHRoZSBxdWVyeSBsaW1pdCBmbGFnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdXBwb3J0c0xpbWl0OiAoc2VydmljZVJlc3VsdC5jdXJyZW50VmVyc2lvbiB8fCAxKSA+PSAxMC4xLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJVcmwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm4gdGhlIGxheWVyIGRhdGEgcHJvbWlzZSByZXN1bHRcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGxheWVyRGF0YSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNhc2Ugd2hlcmUgZXJyb3IgaGFwcGVuZWQgYnV0IHNlcnZpY2UgcmVxdWVzdCB3YXMgc3VjY2Vzc2Z1bFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignU2VydmljZSBtZXRhZGF0YSBsb2FkIGVycm9yJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlcnZpY2VSZXN1bHQgJiYgc2VydmljZVJlc3VsdC5lcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZWplY3Qgd2l0aCBlcnJvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3Qoc2VydmljZVJlc3VsdC5lcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignVW5rbm93biBlcnJvciBsb2FkaW5nIHNlcnZpY2UgbWV0YWRhdGEnKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCBlcnJvciA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBmYWlsZWQgdG8gbG9hZCBzZXJ2aWNlIGluZm8uIHJlamVjdCB3aXRoIGVycm9yXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1NlcnZpY2UgbWV0YWRhdGEgbG9hZCBlcnJvciA6ICcgKyBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGxheWVyUGFja2FnZTtcclxuICAgIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGxvYWRGaWxlQXR0cmlic0J1aWxkZXIoZXNyaUJ1bmRsZSwgZ2VvQXBpKSB7XHJcblxyXG4gICAgcmV0dXJuIGxheWVyID0+IHtcclxuICAgICAgICAvLyBmZWF0dXJlIGxheWVyIHdhcyBsb2FkZWQgZnJvbSBhIGZpbGUuXHJcbiAgICAgICAgLy8gdGhpcyBhcHByb2FjaCBpcyBpbmVmZmljaWVudCAoZHVwbGljYXRlcyBhdHRyaWJ1dGVzIGluIGxheWVyIGFuZCBpbiBhdHRyaWJ1dGUgc3RvcmUpLFxyXG4gICAgICAgIC8vIGJ1dCBwcm92aWRlcyBhIGNvbnNpc3RlbnQgYXBwcm9hY2ggdG8gYXR0cmlidXRlcyByZWdhcmRsZXNzIG9mIHdoZXJlIHRoZSBsYXllciBjYW1lIGZyb21cclxuXHJcbiAgICAgICAgY29uc3QgbGF5ZXJQYWNrYWdlID0gbmV3TGF5ZXJQYWNrYWdlKCcwJywgZXNyaUJ1bmRsZSk7IC8vIGZpbGVzIGhhdmUgbm8gaW5kZXggKG5vIHNlcnZlciksIHNvIHdlIHVzZSB2YWx1ZSAwXHJcblxyXG4gICAgICAgIC8vIGl0J3MgbG9jYWwsIG5vIG5lZWQgdG8gbGF6eS1sb2FkXHJcbiAgICAgICAgbGF5ZXJQYWNrYWdlLl9hdHRyaWJEYXRhID0gUHJvbWlzZS5yZXNvbHZlKGNyZWF0ZUF0dHJpYlNldChsYXllci5vYmplY3RJZEZpZWxkLCBsYXllci5ncmFwaGljcy5tYXAoZWxlbSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IGF0dHJpYnV0ZXM6IGVsZW0uYXR0cmlidXRlcyB9O1xyXG4gICAgICAgIH0pKSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHJlbmRlcmVyID0gbGF5ZXIucmVuZGVyZXIudG9Kc29uKCk7XHJcbiAgICAgICAgY29uc3QgbGVnZW5kID0gZ2VvQXBpLnN5bWJvbG9neS5yZW5kZXJlclRvTGVnZW5kKHJlbmRlcmVyLCAwKTtcclxuICAgICAgICBnZW9BcGkuc3ltYm9sb2d5LmVuaGFuY2VSZW5kZXJlcihyZW5kZXJlciwgbGVnZW5kKTtcclxuXHJcbiAgICAgICAgLy8gVE9ETyByZXZpc2l0IHRoZSBnZW9tZXRyeSB0eXBlLiBpZGVhbGx5LCBmaXggb3VyIEdlb0pTT04gdG8gRmVhdHVyZSB0byBwb3B1bGF0ZSB0aGUgcHJvcGVydHlcclxuICAgICAgICBsYXllclBhY2thZ2UubGF5ZXJEYXRhID0gUHJvbWlzZS5yZXNvbHZlKHtcclxuICAgICAgICAgICAgb2lkRmllbGQ6IGxheWVyLm9iamVjdElkRmllbGQsXHJcbiAgICAgICAgICAgIGZpZWxkczogbGF5ZXIuZmllbGRzLFxyXG4gICAgICAgICAgICBnZW9tZXRyeVR5cGU6IGxheWVyLmdlb21ldHJ5VHlwZSB8fCBKU09OLnBhcnNlKGxheWVyLl9qc29uKS5sYXllckRlZmluaXRpb24uZHJhd2luZ0luZm8uZ2VvbWV0cnlUeXBlLFxyXG4gICAgICAgICAgICBtaW5TY2FsZTogbGF5ZXIubWluU2NhbGUsXHJcbiAgICAgICAgICAgIG1heFNjYWxlOiBsYXllci5tYXhTY2FsZSxcclxuICAgICAgICAgICAgbGF5ZXJUeXBlOiAnRmVhdHVyZSBMYXllcicsXHJcbiAgICAgICAgICAgIHJlbmRlcmVyLFxyXG4gICAgICAgICAgICBsZWdlbmRcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGxheWVyUGFja2FnZTtcclxuICAgIH07XHJcbn1cclxuXHJcbi8vICBBdHRyaWJ1dGUgTG9hZGVyIHJlbGF0ZWQgZnVuY3Rpb25zXHJcbi8vIFRPRE8gY29uc2lkZXIgcmUtd3JpdGluZyBhbGwgdGhlIGFzeW5jaCBzdHVmZiB3aXRoIHRoZSBFQ01BLTcgc3R5bGUgb2YgYXN5bmNoIGtleXdvcmRzXHJcbm1vZHVsZS5leHBvcnRzID0gKGVzcmlCdW5kbGUsIGdlb0FwaSkgPT4ge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBsb2FkU2VydmVyQXR0cmliczogbG9hZFNlcnZlckF0dHJpYnNCdWlsZGVyKGVzcmlCdW5kbGUsIGdlb0FwaSksXHJcbiAgICAgICAgbG9hZEZpbGVBdHRyaWJzOiBsb2FkRmlsZUF0dHJpYnNCdWlsZGVyKGVzcmlCdW5kbGUsIGdlb0FwaSksXHJcbiAgICAgICAgZ2V0TGF5ZXJJbmRleFxyXG4gICAgfTtcclxufTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2F0dHJpYnV0ZS5qcyJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,exports,__webpack_require__){"use strict";eval("\n\n/**\r\n * Wire up any supplied handlers to the corresponding dojo .on events on layer.\r\n * Purpose is to keep Dojo .on events contained in geoApi.\r\n *\r\n * @param {esriObject} esriObject which contains the dojo events to be wrapped\r\n * @param {handlers} handlers is an object which contains all handlers needed\r\n *\r\n * @return {object} evt contains the events created on the object, keyed by same properties as handlers input\r\n */\nfunction wrapEvents(esriObject, handlers) {\n    var evt = {};\n    Object.keys(handlers).forEach(function (ourEventName) {\n        // replace camelCase name to dojo event name format\n        var dojoName = ourEventName.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n\n        // TODO: Validity checking on inputs for dojoName\n        // make dojo call\n        evt[ourEventName] = esriObject.on(dojoName, function (e) {\n\n            // check if needs special handling to point at layer calling event\n            var layerEvents = ['update-start', 'update-end', 'error'];\n            if (layerEvents.indexOf(dojoName) >= 0) {\n                e.layer = e.target;\n            }\n            handlers[ourEventName](e);\n        });\n    });\n\n    return evt;\n}\n\nmodule.exports = function () {\n    return {\n        wrapEvents: wrapEvents\n    };\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZXZlbnRzLmpzPzlmZjYiXSwibmFtZXMiOlsid3JhcEV2ZW50cyIsImVzcmlPYmplY3QiLCJoYW5kbGVycyIsImV2dCIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwiZG9qb05hbWUiLCJvdXJFdmVudE5hbWUiLCJyZXBsYWNlIiwidG9Mb3dlckNhc2UiLCJvbiIsImUiLCJsYXllckV2ZW50cyIsImluZGV4T2YiLCJsYXllciIsInRhcmdldCIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7O0FBQUE7Ozs7Ozs7OztBQVNBLFNBQVNBLFVBQVQsQ0FBb0JDLFVBQXBCLEVBQWdDQyxRQUFoQyxFQUEwQztBQUN0QyxRQUFNQyxNQUFNLEVBQVo7QUFDQUMsV0FBT0MsSUFBUCxDQUFZSCxRQUFaLEVBQXNCSSxPQUF0QixDQUE4Qix3QkFBZ0I7QUFDMUM7QUFDQSxZQUFNQyxXQUFXQyxhQUFhQyxPQUFiLENBQXFCLGlCQUFyQixFQUF3QyxPQUF4QyxFQUFpREMsV0FBakQsRUFBakI7O0FBRUE7QUFDQTtBQUNBUCxZQUFJSyxZQUFKLElBQW9CUCxXQUFXVSxFQUFYLENBQWNKLFFBQWQsRUFBd0IsVUFBQ0ssQ0FBRCxFQUFPOztBQUUvQztBQUNBLGdCQUFNQyxjQUFjLENBQUMsY0FBRCxFQUFpQixZQUFqQixFQUErQixPQUEvQixDQUFwQjtBQUNBLGdCQUFJQSxZQUFZQyxPQUFaLENBQW9CUCxRQUFwQixLQUFpQyxDQUFyQyxFQUF3QztBQUNwQ0ssa0JBQUVHLEtBQUYsR0FBVUgsRUFBRUksTUFBWjtBQUNIO0FBQ0RkLHFCQUFTTSxZQUFULEVBQXVCSSxDQUF2QjtBQUNILFNBUm1CLENBQXBCO0FBU0gsS0FmRDs7QUFpQkEsV0FBT1QsR0FBUDtBQUNIOztBQUVEYyxPQUFPQyxPQUFQLEdBQWlCLFlBQU07QUFDbkIsV0FBTztBQUNIbEI7QUFERyxLQUFQO0FBR0gsQ0FKRCIsImZpbGUiOiI3Mi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBXaXJlIHVwIGFueSBzdXBwbGllZCBoYW5kbGVycyB0byB0aGUgY29ycmVzcG9uZGluZyBkb2pvIC5vbiBldmVudHMgb24gbGF5ZXIuXHJcbiAqIFB1cnBvc2UgaXMgdG8ga2VlcCBEb2pvIC5vbiBldmVudHMgY29udGFpbmVkIGluIGdlb0FwaS5cclxuICpcclxuICogQHBhcmFtIHtlc3JpT2JqZWN0fSBlc3JpT2JqZWN0IHdoaWNoIGNvbnRhaW5zIHRoZSBkb2pvIGV2ZW50cyB0byBiZSB3cmFwcGVkXHJcbiAqIEBwYXJhbSB7aGFuZGxlcnN9IGhhbmRsZXJzIGlzIGFuIG9iamVjdCB3aGljaCBjb250YWlucyBhbGwgaGFuZGxlcnMgbmVlZGVkXHJcbiAqXHJcbiAqIEByZXR1cm4ge29iamVjdH0gZXZ0IGNvbnRhaW5zIHRoZSBldmVudHMgY3JlYXRlZCBvbiB0aGUgb2JqZWN0LCBrZXllZCBieSBzYW1lIHByb3BlcnRpZXMgYXMgaGFuZGxlcnMgaW5wdXRcclxuICovXHJcbmZ1bmN0aW9uIHdyYXBFdmVudHMoZXNyaU9iamVjdCwgaGFuZGxlcnMpIHtcclxuICAgIGNvbnN0IGV2dCA9IHt9O1xyXG4gICAgT2JqZWN0LmtleXMoaGFuZGxlcnMpLmZvckVhY2gob3VyRXZlbnROYW1lID0+IHtcclxuICAgICAgICAvLyByZXBsYWNlIGNhbWVsQ2FzZSBuYW1lIHRvIGRvam8gZXZlbnQgbmFtZSBmb3JtYXRcclxuICAgICAgICBjb25zdCBkb2pvTmFtZSA9IG91ckV2ZW50TmFtZS5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCAnJDEtJDInKS50b0xvd2VyQ2FzZSgpO1xyXG5cclxuICAgICAgICAvLyBUT0RPOiBWYWxpZGl0eSBjaGVja2luZyBvbiBpbnB1dHMgZm9yIGRvam9OYW1lXHJcbiAgICAgICAgLy8gbWFrZSBkb2pvIGNhbGxcclxuICAgICAgICBldnRbb3VyRXZlbnROYW1lXSA9IGVzcmlPYmplY3Qub24oZG9qb05hbWUsIChlKSA9PiB7XHJcblxyXG4gICAgICAgICAgICAvLyBjaGVjayBpZiBuZWVkcyBzcGVjaWFsIGhhbmRsaW5nIHRvIHBvaW50IGF0IGxheWVyIGNhbGxpbmcgZXZlbnRcclxuICAgICAgICAgICAgY29uc3QgbGF5ZXJFdmVudHMgPSBbJ3VwZGF0ZS1zdGFydCcsICd1cGRhdGUtZW5kJywgJ2Vycm9yJ107XHJcbiAgICAgICAgICAgIGlmIChsYXllckV2ZW50cy5pbmRleE9mKGRvam9OYW1lKSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBlLmxheWVyID0gZS50YXJnZXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaGFuZGxlcnNbb3VyRXZlbnROYW1lXShlKTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBldnQ7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gKCkgPT4ge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB3cmFwRXZlbnRzXHJcbiAgICB9O1xyXG59O1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZXZlbnRzLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){"use strict";eval("\n\n// TODO hilight layer would be a good candidate for a custom class which internally proxies to ESRI's GraphicsLayer.\n\nvar defaultSymbols = __webpack_require__(173);\n\n// contains functions to support the hilight layer.\n\nfunction cloneBuilder(esriBundle) {\n    /**\r\n    * Clone a graphic from a map-bound layer.\r\n    * @method cloneLayerGraphic\r\n    * @param {Graphic} graphic an ESRI graphic that resides in a map layer.\r\n    * @return {Object} an unbound copy of the graphic\r\n    */\n    return function (graphic) {\n        var clone = new esriBundle.Graphic({\n            geometry: graphic.geometry\n        });\n        clone.symbol = graphic.getLayer().renderer.getSymbol(graphic);\n        return clone;\n    };\n}\n\nfunction graphicBuilder(esriBundle) {\n    /**\r\n    * Generating a graphic from server geometry.\r\n    * @method geomToGraphic\r\n    * @param {Object} geometry feature geometry conforming to ESRI Geometry standard\r\n    * @param {Object} symbol esri symbol in server format\r\n    * @return {Object} an ESRI GraphicsLayer\r\n    */\n    return function (geometry, symbol) {\n        var graphic = new esriBundle.Graphic({\n            geometry: geometry\n        });\n        graphic.symbol = esriBundle.symbolJsonUtils.fromJson(symbol);\n        return graphic;\n    };\n}\n\nfunction getGraphicsBuilder(esriBundle, geoApi) {\n    // TODO once document sites are up and running, figure out a way to hyperlink the graphicBundles parameter to the class documentation page in the viewer site\n    /**\r\n    * Generating a graphic from server geometry.\r\n    * @method getUnboundGraphics\r\n    * @param {Array} graphicBundles set of graphic bundles with properties .graphic, .source, .layerFC\r\n    * @param {Object} spatialReference the projection the unbound graphics should be in\r\n    * @return {Array} a set of promises that resolve with an unbound graphic, one for each graphic bundle provided\r\n    */\n    return function (graphicBundles, spatialReference) {\n\n        // generate detached graphics to give to the hilight layer.\n        // promises because server layers renderer is inside a promise\n        return graphicBundles.map(function (bundle) {\n            if (bundle.source === 'server') {\n                var geom = bundle.graphic.geometry;\n\n                // check projection\n                if (!geoApi.proj.isSpatialRefEqual(geom.spatialReference, spatialReference)) {\n                    geom = geoApi.proj.localProjectGeometry(spatialReference, geom);\n                }\n\n                // determine symbol for this server graphic\n                return bundle.layerFC.getLayerData().then(function (layerData) {\n                    var symb = geoApi.symbology.getGraphicSymbol(bundle.graphic.attributes, layerData.renderer);\n                    return geoApi.hilight.geomToGraphic(geom, symb);\n                });\n            } else {\n                // local graphic. clone and hilight\n                return Promise.resolve(geoApi.hilight.cloneLayerGraphic(bundle.graphic));\n            }\n        });\n    };\n}\n\nfunction hilightBuilder(esriBundle) {\n    /**\r\n    * Generate a graphic layer to handle feature hilighting.\r\n    * @method makeHilightLayer\r\n    * @param {Object} options optional settings for the hilight layer\r\n    *                         layerId - id to use for the hilight layer. defaults to rv_hilight\r\n    *                         markerSymbol - esri symbol in server json format to symbolize the click marker. defaults to a red pin\r\n    * @return {Object} an ESRI GraphicsLayer\r\n    */\n    return function (options) {\n        // set options\n        var id = 'rv_hilight';\n        var markerSymbol = defaultSymbols.markerSymbol;\n\n        if (options) {\n            if (options.layerId) {\n                id = options.layerId;\n            }\n            if (options.markerSymbol) {\n                markerSymbol = options.markerSymbol;\n            }\n        }\n\n        var hgl = new esriBundle.GraphicsLayer({ id: id, visible: true });\n\n        /**\r\n        * Add a graphic to indicate where user clicked.\r\n        * @method addPin\r\n        * @param {Point} point          an ESRI point object to use as the graphic location\r\n        * @param {Boolean} clearLayer   indicates any previous graphics in the hilight layer should be removed. defaults to false\r\n        */\n        hgl.addMarker = function (point) {\n            var clearLayer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n            if (clearLayer) {\n                hgl.clear();\n            }\n\n            var marker = new esriBundle.Graphic({ symbol: markerSymbol });\n            marker.setGeometry(point);\n            hgl.add(marker);\n        };\n\n        /**\r\n        * Add a graphic or array of graphics to the highlight layer. Remove any previous graphics.\r\n        * @method addHilight\r\n        * @param {Graphic|Array} graphic  an ESRI graphic, or array of ESRI graphics. Should be in map spatialReference, and not bound to a layer\r\n        * @param {Boolean} clearLayer   indicates any previous graphics in the hilight layer should be removed. defaults to false\r\n        */\n        hgl.addHilight = function (graphic) {\n            var clearLayer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n            if (clearLayer) {\n                hgl.clear();\n            }\n\n            var graphics = Array.isArray(graphic) ? graphic : [graphic];\n\n            // add new hilight graphics\n            graphics.forEach(function (g) {\n                return hgl.add(g);\n            });\n        };\n\n        /**\r\n        * Remove hilight from map\r\n        * @method clearHilight\r\n        */\n        hgl.clearHilight = function () {\n            hgl.clear();\n        };\n\n        return hgl;\n    };\n}\n\nmodule.exports = function (esriBundle, geoApi) {\n    return {\n        makeHilightLayer: hilightBuilder(esriBundle),\n        geomToGraphic: graphicBuilder(esriBundle),\n        cloneLayerGraphic: cloneBuilder(esriBundle),\n        getUnboundGraphics: getGraphicsBuilder(esriBundle, geoApi)\n    };\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaGlsaWdodC5qcz84Njg1Il0sIm5hbWVzIjpbImRlZmF1bHRTeW1ib2xzIiwicmVxdWlyZSIsImNsb25lQnVpbGRlciIsImVzcmlCdW5kbGUiLCJjbG9uZSIsIkdyYXBoaWMiLCJnZW9tZXRyeSIsImdyYXBoaWMiLCJzeW1ib2wiLCJnZXRMYXllciIsInJlbmRlcmVyIiwiZ2V0U3ltYm9sIiwiZ3JhcGhpY0J1aWxkZXIiLCJzeW1ib2xKc29uVXRpbHMiLCJmcm9tSnNvbiIsImdldEdyYXBoaWNzQnVpbGRlciIsImdlb0FwaSIsImdyYXBoaWNCdW5kbGVzIiwic3BhdGlhbFJlZmVyZW5jZSIsIm1hcCIsImJ1bmRsZSIsInNvdXJjZSIsImdlb20iLCJwcm9qIiwiaXNTcGF0aWFsUmVmRXF1YWwiLCJsb2NhbFByb2plY3RHZW9tZXRyeSIsImxheWVyRkMiLCJnZXRMYXllckRhdGEiLCJ0aGVuIiwic3ltYiIsInN5bWJvbG9neSIsImdldEdyYXBoaWNTeW1ib2wiLCJhdHRyaWJ1dGVzIiwibGF5ZXJEYXRhIiwiaGlsaWdodCIsImdlb21Ub0dyYXBoaWMiLCJQcm9taXNlIiwicmVzb2x2ZSIsImNsb25lTGF5ZXJHcmFwaGljIiwiaGlsaWdodEJ1aWxkZXIiLCJpZCIsIm1hcmtlclN5bWJvbCIsIm9wdGlvbnMiLCJsYXllcklkIiwiaGdsIiwiR3JhcGhpY3NMYXllciIsInZpc2libGUiLCJhZGRNYXJrZXIiLCJwb2ludCIsImNsZWFyTGF5ZXIiLCJjbGVhciIsIm1hcmtlciIsInNldEdlb21ldHJ5IiwiYWRkIiwiYWRkSGlsaWdodCIsImdyYXBoaWNzIiwiQXJyYXkiLCJpc0FycmF5IiwiZm9yRWFjaCIsImciLCJjbGVhckhpbGlnaHQiLCJtb2R1bGUiLCJleHBvcnRzIiwibWFrZUhpbGlnaHRMYXllciIsImdldFVuYm91bmRHcmFwaGljcyJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7O0FBRUEsSUFBTUEsaUJBQWlCLG1CQUFBQyxD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QkFBTUMsU0FBUyxJQUFJaEQsV0FBV0UsT0FBZixDQUF1QixFQUFFRyxRQUFRaUMsWUFBVixFQUF2QixDQUFmO0FBQ0FVLG1CQUFPQyxXQUFQLENBQW1CSixLQUFuQjtBQUNBSixnQkFBSVMsR0FBSixDQUFRRixNQUFSO0FBQ0gsU0FSRDs7QUFVQTs7Ozs7O0FBTUFQLFlBQUlVLFVBQUosR0FBaUIsVUFBQy9DLE9BQUQsRUFBaUM7QUFBQSxnQkFBdkIwQyxVQUF1Qix1RUFBVixLQUFVOztBQUM5QyxnQkFBSUEsVUFBSixFQUFnQjtBQUNaTCxvQkFBSU0sS0FBSjtBQUNIOztBQUVELGdCQUFNSyxXQUFXQyxNQUFNQyxPQUFOLENBQWNsRCxPQUFkLElBQXlCQSxPQUF6QixHQUFtQyxDQUFDQSxPQUFELENBQXBEOztBQUVBO0FBQ0FnRCxxQkFBU0csT0FBVCxDQUFpQjtBQUFBLHVCQUFLZCxJQUFJUyxHQUFKLENBQVFNLENBQVIsQ0FBTDtBQUFBLGFBQWpCO0FBQ0gsU0FURDs7QUFXQTs7OztBQUlBZixZQUFJZ0IsWUFBSixHQUFtQixZQUFNO0FBQ3JCaEIsZ0JBQUlNLEtBQUo7QUFDSCxTQUZEOztBQUlBLGVBQU9OLEdBQVA7QUFDSCxLQTNERDtBQTRESDs7QUFFRGlCLE9BQU9DLE9BQVAsR0FBaUIsVUFBQzNELFVBQUQsRUFBYWEsTUFBYjtBQUFBLFdBQXlCO0FBQ3RDK0MsMEJBQWtCeEIsZUFBZXBDLFVBQWYsQ0FEb0I7QUFFdENnQyx1QkFBZXZCLGVBQWVULFVBQWYsQ0FGdUI7QUFHdENtQywyQkFBbUJwQyxhQUFhQyxVQUFiLENBSG1CO0FBSXRDNkQsNEJBQW9CakQsbUJBQW1CWixVQUFuQixFQUErQmEsTUFBL0I7QUFKa0IsS0FBekI7QUFBQSxDQUFqQiIsImZpbGUiOiI3My5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuXHJcbi8vIFRPRE8gaGlsaWdodCBsYXllciB3b3VsZCBiZSBhIGdvb2QgY2FuZGlkYXRlIGZvciBhIGN1c3RvbSBjbGFzcyB3aGljaCBpbnRlcm5hbGx5IHByb3hpZXMgdG8gRVNSSSdzIEdyYXBoaWNzTGF5ZXIuXHJcblxyXG5jb25zdCBkZWZhdWx0U3ltYm9scyA9IHJlcXVpcmUoJy4vZGVmYXVsdEhpbGlnaHRTeW1ib2xzLmpzb24nKTtcclxuXHJcbi8vIGNvbnRhaW5zIGZ1bmN0aW9ucyB0byBzdXBwb3J0IHRoZSBoaWxpZ2h0IGxheWVyLlxyXG5cclxuZnVuY3Rpb24gY2xvbmVCdWlsZGVyKGVzcmlCdW5kbGUpIHtcclxuICAgIC8qKlxyXG4gICAgKiBDbG9uZSBhIGdyYXBoaWMgZnJvbSBhIG1hcC1ib3VuZCBsYXllci5cclxuICAgICogQG1ldGhvZCBjbG9uZUxheWVyR3JhcGhpY1xyXG4gICAgKiBAcGFyYW0ge0dyYXBoaWN9IGdyYXBoaWMgYW4gRVNSSSBncmFwaGljIHRoYXQgcmVzaWRlcyBpbiBhIG1hcCBsYXllci5cclxuICAgICogQHJldHVybiB7T2JqZWN0fSBhbiB1bmJvdW5kIGNvcHkgb2YgdGhlIGdyYXBoaWNcclxuICAgICovXHJcbiAgICByZXR1cm4gZ3JhcGhpYyA9PiB7XHJcbiAgICAgICAgY29uc3QgY2xvbmUgPSBuZXcgZXNyaUJ1bmRsZS5HcmFwaGljKHtcclxuICAgICAgICAgICAgICAgIGdlb21ldHJ5OiBncmFwaGljLmdlb21ldHJ5XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIGNsb25lLnN5bWJvbCA9IGdyYXBoaWMuZ2V0TGF5ZXIoKS5yZW5kZXJlci5nZXRTeW1ib2woZ3JhcGhpYyk7XHJcbiAgICAgICAgcmV0dXJuIGNsb25lO1xyXG4gICAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ3JhcGhpY0J1aWxkZXIoZXNyaUJ1bmRsZSkge1xyXG4gICAgLyoqXHJcbiAgICAqIEdlbmVyYXRpbmcgYSBncmFwaGljIGZyb20gc2VydmVyIGdlb21ldHJ5LlxyXG4gICAgKiBAbWV0aG9kIGdlb21Ub0dyYXBoaWNcclxuICAgICogQHBhcmFtIHtPYmplY3R9IGdlb21ldHJ5IGZlYXR1cmUgZ2VvbWV0cnkgY29uZm9ybWluZyB0byBFU1JJIEdlb21ldHJ5IHN0YW5kYXJkXHJcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBzeW1ib2wgZXNyaSBzeW1ib2wgaW4gc2VydmVyIGZvcm1hdFxyXG4gICAgKiBAcmV0dXJuIHtPYmplY3R9IGFuIEVTUkkgR3JhcGhpY3NMYXllclxyXG4gICAgKi9cclxuICAgIHJldHVybiAoZ2VvbWV0cnksIHN5bWJvbCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGdyYXBoaWMgPSBuZXcgZXNyaUJ1bmRsZS5HcmFwaGljKHtcclxuICAgICAgICAgICAgICAgIGdlb21ldHJ5XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIGdyYXBoaWMuc3ltYm9sID0gZXNyaUJ1bmRsZS5zeW1ib2xKc29uVXRpbHMuZnJvbUpzb24oc3ltYm9sKTtcclxuICAgICAgICByZXR1cm4gZ3JhcGhpYztcclxuICAgIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEdyYXBoaWNzQnVpbGRlcihlc3JpQnVuZGxlLCBnZW9BcGkpIHtcclxuICAgIC8vIFRPRE8gb25jZSBkb2N1bWVudCBzaXRlcyBhcmUgdXAgYW5kIHJ1bm5pbmcsIGZpZ3VyZSBvdXQgYSB3YXkgdG8gaHlwZXJsaW5rIHRoZSBncmFwaGljQnVuZGxlcyBwYXJhbWV0ZXIgdG8gdGhlIGNsYXNzIGRvY3VtZW50YXRpb24gcGFnZSBpbiB0aGUgdmlld2VyIHNpdGVcclxuICAgIC8qKlxyXG4gICAgKiBHZW5lcmF0aW5nIGEgZ3JhcGhpYyBmcm9tIHNlcnZlciBnZW9tZXRyeS5cclxuICAgICogQG1ldGhvZCBnZXRVbmJvdW5kR3JhcGhpY3NcclxuICAgICogQHBhcmFtIHtBcnJheX0gZ3JhcGhpY0J1bmRsZXMgc2V0IG9mIGdyYXBoaWMgYnVuZGxlcyB3aXRoIHByb3BlcnRpZXMgLmdyYXBoaWMsIC5zb3VyY2UsIC5sYXllckZDXHJcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBzcGF0aWFsUmVmZXJlbmNlIHRoZSBwcm9qZWN0aW9uIHRoZSB1bmJvdW5kIGdyYXBoaWNzIHNob3VsZCBiZSBpblxyXG4gICAgKiBAcmV0dXJuIHtBcnJheX0gYSBzZXQgb2YgcHJvbWlzZXMgdGhhdCByZXNvbHZlIHdpdGggYW4gdW5ib3VuZCBncmFwaGljLCBvbmUgZm9yIGVhY2ggZ3JhcGhpYyBidW5kbGUgcHJvdmlkZWRcclxuICAgICovXHJcbiAgICByZXR1cm4gKGdyYXBoaWNCdW5kbGVzLCBzcGF0aWFsUmVmZXJlbmNlKSA9PiB7XHJcblxyXG4gICAgICAgIC8vIGdlbmVyYXRlIGRldGFjaGVkIGdyYXBoaWNzIHRvIGdpdmUgdG8gdGhlIGhpbGlnaHQgbGF5ZXIuXHJcbiAgICAgICAgLy8gcHJvbWlzZXMgYmVjYXVzZSBzZXJ2ZXIgbGF5ZXJzIHJlbmRlcmVyIGlzIGluc2lkZSBhIHByb21pc2VcclxuICAgICAgICByZXR1cm4gZ3JhcGhpY0J1bmRsZXMubWFwKGJ1bmRsZSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChidW5kbGUuc291cmNlID09PSAnc2VydmVyJykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGdlb20gPSBidW5kbGUuZ3JhcGhpYy5nZW9tZXRyeTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBwcm9qZWN0aW9uXHJcbiAgICAgICAgICAgICAgICBpZiAoIWdlb0FwaS5wcm9qLmlzU3BhdGlhbFJlZkVxdWFsKGdlb20uc3BhdGlhbFJlZmVyZW5jZSwgc3BhdGlhbFJlZmVyZW5jZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBnZW9tID0gZ2VvQXBpLnByb2oubG9jYWxQcm9qZWN0R2VvbWV0cnkoc3BhdGlhbFJlZmVyZW5jZSwgZ2VvbSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIHN5bWJvbCBmb3IgdGhpcyBzZXJ2ZXIgZ3JhcGhpY1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ1bmRsZS5sYXllckZDLmdldExheWVyRGF0YSgpLnRoZW4obGF5ZXJEYXRhID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzeW1iID0gZ2VvQXBpLnN5bWJvbG9neS5nZXRHcmFwaGljU3ltYm9sKGJ1bmRsZS5ncmFwaGljLmF0dHJpYnV0ZXMsIGxheWVyRGF0YS5yZW5kZXJlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdlb0FwaS5oaWxpZ2h0Lmdlb21Ub0dyYXBoaWMoZ2VvbSwgc3ltYik7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBsb2NhbCBncmFwaGljLiBjbG9uZSBhbmQgaGlsaWdodFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShnZW9BcGkuaGlsaWdodC5jbG9uZUxheWVyR3JhcGhpYyhidW5kbGUuZ3JhcGhpYykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBoaWxpZ2h0QnVpbGRlcihlc3JpQnVuZGxlKSB7XHJcbiAgICAvKipcclxuICAgICogR2VuZXJhdGUgYSBncmFwaGljIGxheWVyIHRvIGhhbmRsZSBmZWF0dXJlIGhpbGlnaHRpbmcuXHJcbiAgICAqIEBtZXRob2QgbWFrZUhpbGlnaHRMYXllclxyXG4gICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBvcHRpb25hbCBzZXR0aW5ncyBmb3IgdGhlIGhpbGlnaHQgbGF5ZXJcclxuICAgICogICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJJZCAtIGlkIHRvIHVzZSBmb3IgdGhlIGhpbGlnaHQgbGF5ZXIuIGRlZmF1bHRzIHRvIHJ2X2hpbGlnaHRcclxuICAgICogICAgICAgICAgICAgICAgICAgICAgICAgbWFya2VyU3ltYm9sIC0gZXNyaSBzeW1ib2wgaW4gc2VydmVyIGpzb24gZm9ybWF0IHRvIHN5bWJvbGl6ZSB0aGUgY2xpY2sgbWFya2VyLiBkZWZhdWx0cyB0byBhIHJlZCBwaW5cclxuICAgICogQHJldHVybiB7T2JqZWN0fSBhbiBFU1JJIEdyYXBoaWNzTGF5ZXJcclxuICAgICovXHJcbiAgICByZXR1cm4gb3B0aW9ucyA9PiB7XHJcbiAgICAgICAgLy8gc2V0IG9wdGlvbnNcclxuICAgICAgICBsZXQgaWQgPSAncnZfaGlsaWdodCc7XHJcbiAgICAgICAgbGV0IG1hcmtlclN5bWJvbCA9IGRlZmF1bHRTeW1ib2xzLm1hcmtlclN5bWJvbDtcclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMubGF5ZXJJZCkge1xyXG4gICAgICAgICAgICAgICAgaWQgPSBvcHRpb25zLmxheWVySWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMubWFya2VyU3ltYm9sKSB7XHJcbiAgICAgICAgICAgICAgICBtYXJrZXJTeW1ib2wgPSBvcHRpb25zLm1hcmtlclN5bWJvbDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGhnbCA9IG5ldyBlc3JpQnVuZGxlLkdyYXBoaWNzTGF5ZXIoeyBpZCwgdmlzaWJsZTogdHJ1ZSB9KTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgKiBBZGQgYSBncmFwaGljIHRvIGluZGljYXRlIHdoZXJlIHVzZXIgY2xpY2tlZC5cclxuICAgICAgICAqIEBtZXRob2QgYWRkUGluXHJcbiAgICAgICAgKiBAcGFyYW0ge1BvaW50fSBwb2ludCAgICAgICAgICBhbiBFU1JJIHBvaW50IG9iamVjdCB0byB1c2UgYXMgdGhlIGdyYXBoaWMgbG9jYXRpb25cclxuICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY2xlYXJMYXllciAgIGluZGljYXRlcyBhbnkgcHJldmlvdXMgZ3JhcGhpY3MgaW4gdGhlIGhpbGlnaHQgbGF5ZXIgc2hvdWxkIGJlIHJlbW92ZWQuIGRlZmF1bHRzIHRvIGZhbHNlXHJcbiAgICAgICAgKi9cclxuICAgICAgICBoZ2wuYWRkTWFya2VyID0gKHBvaW50LCBjbGVhckxheWVyID0gZmFsc2UpID0+IHtcclxuICAgICAgICAgICAgaWYgKGNsZWFyTGF5ZXIpIHtcclxuICAgICAgICAgICAgICAgIGhnbC5jbGVhcigpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb25zdCBtYXJrZXIgPSBuZXcgZXNyaUJ1bmRsZS5HcmFwaGljKHsgc3ltYm9sOiBtYXJrZXJTeW1ib2wgfSk7XHJcbiAgICAgICAgICAgIG1hcmtlci5zZXRHZW9tZXRyeShwb2ludCk7XHJcbiAgICAgICAgICAgIGhnbC5hZGQobWFya2VyKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAqIEFkZCBhIGdyYXBoaWMgb3IgYXJyYXkgb2YgZ3JhcGhpY3MgdG8gdGhlIGhpZ2hsaWdodCBsYXllci4gUmVtb3ZlIGFueSBwcmV2aW91cyBncmFwaGljcy5cclxuICAgICAgICAqIEBtZXRob2QgYWRkSGlsaWdodFxyXG4gICAgICAgICogQHBhcmFtIHtHcmFwaGljfEFycmF5fSBncmFwaGljICBhbiBFU1JJIGdyYXBoaWMsIG9yIGFycmF5IG9mIEVTUkkgZ3JhcGhpY3MuIFNob3VsZCBiZSBpbiBtYXAgc3BhdGlhbFJlZmVyZW5jZSwgYW5kIG5vdCBib3VuZCB0byBhIGxheWVyXHJcbiAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNsZWFyTGF5ZXIgICBpbmRpY2F0ZXMgYW55IHByZXZpb3VzIGdyYXBoaWNzIGluIHRoZSBoaWxpZ2h0IGxheWVyIHNob3VsZCBiZSByZW1vdmVkLiBkZWZhdWx0cyB0byBmYWxzZVxyXG4gICAgICAgICovXHJcbiAgICAgICAgaGdsLmFkZEhpbGlnaHQgPSAoZ3JhcGhpYywgY2xlYXJMYXllciA9IGZhbHNlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChjbGVhckxheWVyKSB7XHJcbiAgICAgICAgICAgICAgICBoZ2wuY2xlYXIoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29uc3QgZ3JhcGhpY3MgPSBBcnJheS5pc0FycmF5KGdyYXBoaWMpID8gZ3JhcGhpYyA6IFtncmFwaGljXTtcclxuXHJcbiAgICAgICAgICAgIC8vIGFkZCBuZXcgaGlsaWdodCBncmFwaGljc1xyXG4gICAgICAgICAgICBncmFwaGljcy5mb3JFYWNoKGcgPT4gaGdsLmFkZChnKSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgKiBSZW1vdmUgaGlsaWdodCBmcm9tIG1hcFxyXG4gICAgICAgICogQG1ldGhvZCBjbGVhckhpbGlnaHRcclxuICAgICAgICAqL1xyXG4gICAgICAgIGhnbC5jbGVhckhpbGlnaHQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIGhnbC5jbGVhcigpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHJldHVybiBoZ2w7XHJcbiAgICB9O1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IChlc3JpQnVuZGxlLCBnZW9BcGkpID0+ICh7XHJcbiAgICBtYWtlSGlsaWdodExheWVyOiBoaWxpZ2h0QnVpbGRlcihlc3JpQnVuZGxlKSxcclxuICAgIGdlb21Ub0dyYXBoaWM6IGdyYXBoaWNCdWlsZGVyKGVzcmlCdW5kbGUpLFxyXG4gICAgY2xvbmVMYXllckdyYXBoaWM6IGNsb25lQnVpbGRlcihlc3JpQnVuZGxlKSxcclxuICAgIGdldFVuYm91bmRHcmFwaGljczogZ2V0R3JhcGhpY3NCdWlsZGVyKGVzcmlCdW5kbGUsIGdlb0FwaSlcclxufSk7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9oaWxpZ2h0LmpzIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){"use strict";eval("\n\n// TODO consider splitting this module into different modules.  in particular,\n//      file-based stuff vs server based stuff, and layer creation vs layer support\n\n// TODO convert internal function header comments to JSDoc, and use the @private tag\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar csv2geojson = __webpack_require__(94);\nvar Terraformer = __webpack_require__(37);\nvar shp = __webpack_require__(166);\nvar ogc = __webpack_require__(90);\nvar bbox = __webpack_require__(81);\nvar layerRecord = __webpack_require__(86);\nvar defaultRenderers = __webpack_require__(70);\nTerraformer.ArcGIS = __webpack_require__(171);\n\n/**\r\n* Maps GeoJSON geometry types to a set of default renders defined in GlobalStorage.DefaultRenders\r\n* @property featureTypeToRenderer {Object}\r\n* @private\r\n*/\nvar featureTypeToRenderer = {\n    Point: 'circlePoint',\n    MultiPoint: 'circlePoint',\n    LineString: 'solidLine',\n    MultiLineString: 'solidLine',\n    Polygon: 'outlinedPoly',\n    MultiPolygon: 'outlinedPoly'\n};\n\n/**\r\n* Different types of services that a URL could point to\r\n* @property serviceType {Object}\r\n*/\nvar serviceType = {\n    CSV: 'csv',\n    GeoJSON: 'geojson',\n    Shapefile: 'shapefile',\n    FeatureLayer: 'featurelayer',\n    RasterLayer: 'rasterlayer',\n    GroupLayer: 'grouplayer',\n    TileService: 'tileservice',\n    FeatureService: 'featureservice',\n    DynamicService: 'dynamicservice',\n    ImageService: 'imageservice',\n    WMS: 'wms',\n    Unknown: 'unknown',\n    Error: 'error'\n};\n\n// attempts to determine if a path points to a location on the internet,\n// or is a local file.  Returns true if internetish\nfunction isServerFile(url) {\n    // TODO possibly enhance to be better check, or support more cases\n\n    var lowUrl = url.toLowerCase();\n    var tests = [/^http:/, /^https:/, /^ftp:/, /^\\/\\//];\n    return tests.some(function (test) {\n        return lowUrl.match(test);\n    });\n}\n\n// will grab a file from a server address as binary.\n// returns a promise that resolves with the file data.\nfunction getServerFile(url, esriBundle) {\n    return new Promise(function (resolve, reject) {\n        // extract info for this service\n        var defService = esriBundle.esriRequest({\n            url: url,\n            handleAs: 'arraybuffer'\n        });\n\n        defService.then(function (srvResult) {\n            resolve(srvResult);\n        }, function (error) {\n            // something went wrong\n            reject(error);\n        });\n    });\n}\n\n// returns a standard information object with serviceType\n// supports predictLayerUrl\n// type is serviceType enum value\nfunction makeInfo(type) {\n    return {\n        serviceType: type,\n        index: -1,\n        tileSupport: false\n    };\n}\n\n/**\r\n * Returns a standard information object with info common for most ESRI endpoints\r\n * .serviceName\r\n * .serviceType\r\n * .tileSupport\r\n * .rootUrl\r\n *\r\n * @function makeLayerInfo\r\n * @private\r\n * @param {String} type    serviceType enum value for layer\r\n * @param {String} name    property in json parameter containing a service name\r\n * @param {String} url     url we are investigating\r\n * @param {Object} json    data result from service we interrogated\r\n * @returns {Object}\r\n */\nfunction makeLayerInfo(type, name, url, json) {\n    var info = makeInfo(type);\n    info.serviceName = json[name] || '';\n    info.rootUrl = url;\n    if (type === serviceType.TileService) {\n        info.tileSupport = true;\n        info.serviceType = serviceType.DynamicService;\n    }\n    return info;\n}\n\n// returns promise of standard information object with serviceType\n// and fileData if file is located online (not on disk).\nfunction makeFileInfo(type, url, esriBundle) {\n    return new Promise(function (resolve) {\n        var info = makeInfo(type);\n        if (url && isServerFile(url)) {\n            // be a pal and download the file content\n            getServerFile(url, esriBundle).then(function (data) {\n                info.fileData = data;\n                resolve(info);\n            }).catch(function () {\n                info.serviceType = serviceType.Error;\n                resolve(info);\n            });\n        } else {\n            resolve(info);\n        }\n    });\n}\n\n// inspects the JSON that was returned from a service.\n// if the JSON belongs to an ESRI endpoint, we do some terrible dog-logic to attempt\n// to derive what type of endpoint it is (mainly by looking for properties that are\n// unique to that type of service).\n// returns an enumeration value (string) from serviceType based on the match found.\n// non-esri services or unexpected esri services will return the .Unknown value\nfunction crawlEsriService(srvJson) {\n    if (srvJson.type) {\n        // a layer endpoint (i.e. url ends with integer index)\n        var mapper = {\n            'Feature Layer': serviceType.FeatureLayer,\n            'Raster Layer': serviceType.RasterLayer,\n            'Group Layer': serviceType.GroupLayer\n        };\n        return mapper[srvJson.type] || serviceType.Unknown;\n    } else if (srvJson.hasOwnProperty('singleFusedMapCache')) {\n        if (srvJson.singleFusedMapCache) {\n            // a tile server\n            return serviceType.TileService;\n        } else {\n            // a map server\n            return serviceType.DynamicService;\n        }\n    } else if (srvJson.hasOwnProperty('allowGeometryUpdates')) {\n        // a feature server\n        return serviceType.FeatureService;\n    } else if (srvJson.hasOwnProperty('allowedMosaicMethods')) {\n        // an image server\n        return serviceType.ImageService;\n    } else {\n        return serviceType.Unknown;\n    }\n}\n\n/**\r\n * handles the situation where our first poke revealed a child layer\r\n * (i.e. an indexed endpoint in an arcgis server). We need to extract\r\n * some extra information about the service it resides in (the root service)\r\n * and add it to our info package.\r\n *\r\n * @param {String} url          the url of the original endpoint (including the index)\r\n * @param {Object} esriBundle   has ESRI API objects\r\n * @param {Object} childInfo    the information we have gathered on the child layer from the first poke\r\n * @returns {Promise}           resolves with information object containing child and root information\r\n */\nfunction repokeEsriService(url, esriBundle, childInfo) {\n\n    // break url into root and index\n    var re = /\\/(\\d+)\\/?$/;\n    var matches = url.match(re);\n    if (!matches) {\n        // give up, dont crash with error.\n        console.warn('Cannot extract layer index from url ' + url);\n        return Promise.resolve(childInfo);\n    }\n\n    childInfo.index = parseInt(matches[1]);\n    childInfo.rootUrl = url.substr(0, url.length - matches[0].length); // will drop trailing slash\n\n    // inspect the server root\n    return pokeEsriService(childInfo.rootUrl, esriBundle).then(function (rootInfo) {\n        // take relevant info from root, mash it into our child package\n        childInfo.tileSupport = rootInfo.tileSupport;\n        childInfo.serviceType = rootInfo.serviceType;\n        childInfo.layers = rootInfo.layers;\n        return childInfo;\n    });\n}\n\n// given a URL, attempt to read it as an ESRI rest endpoint.\n// returns a promise that resovles with an information object.\n// at minimum, the object will have a .serviceType property with a value from the above enumeration.\n// if the type is .Unknown, then we were unable to determine the url was an ESRI rest endpoint.\n// otherwise, we were successful, and the information object will have other properties depending on the service type\n// - .name : scraped from service, but may be rubbish (depends on service publisher). used as UI suggestion only\n// - .fields : for feature layer service only. list of fields to allow user to pick name field\n// - .geometryType : for feature layer service only.  for help in defining the renderer, if required.\n// - .layers : for dynamic layer service only. lists the child layers\nfunction pokeEsriService(url, esriBundle, hint) {\n\n    // reaction functions to different esri services\n    var srvHandler = {};\n\n    srvHandler[serviceType.FeatureLayer] = function (srvJson) {\n        var info = makeLayerInfo(serviceType.FeatureLayer, 'name', url, srvJson);\n        info.fields = srvJson.fields;\n        info.geometryType = srvJson.geometryType;\n        info.smartDefaults = {\n            // TODO: try to find a name field if possible\n            primary: info.fields[0].name // pick the first field as primary and return its name for ui binding\n        };\n        info.indexType = serviceType.FeatureLayer;\n        return repokeEsriService(url, esriBundle, info);\n    };\n\n    srvHandler[serviceType.RasterLayer] = function (srvJson) {\n        var info = makeLayerInfo(serviceType.RasterLayer, 'name', url, srvJson);\n        info.indexType = serviceType.RasterLayer;\n        return repokeEsriService(url, esriBundle, info);\n    };\n\n    srvHandler[serviceType.GroupLayer] = function (srvJson) {\n        var info = makeLayerInfo(serviceType.GroupLayer, 'name', url, srvJson);\n        info.indexType = serviceType.GroupLayer;\n        return repokeEsriService(url, esriBundle, info);\n    };\n\n    srvHandler[serviceType.TileService] = function (srvJson) {\n        var info = makeLayerInfo(serviceType.TileService, 'mapName', url, srvJson);\n        info.layers = srvJson.layers;\n        return info;\n    };\n\n    srvHandler[serviceType.DynamicService] = function (srvJson) {\n        var info = makeLayerInfo(serviceType.DynamicService, 'mapName', url, srvJson);\n        info.layers = srvJson.layers;\n        return info;\n    };\n\n    srvHandler[serviceType.FeatureService] = function (srvJson) {\n        var info = makeLayerInfo(serviceType.FeatureService, 'description', url, srvJson);\n        info.layers = srvJson.layers;\n        return info;\n    };\n\n    srvHandler[serviceType.ImageService] = function (srvJson) {\n        var info = makeLayerInfo(serviceType.ImageService, 'name', url, srvJson);\n        info.fields = srvJson.fields;\n        return info;\n    };\n\n    // couldnt figure it out\n    srvHandler[serviceType.Unknown] = function () {\n        return makeInfo(serviceType.Unknown);\n    };\n\n    return new Promise(function (resolve) {\n        // extract info for this service\n        var defService = esriBundle.esriRequest({\n            url: url,\n            content: { f: 'json' },\n            callbackParamName: 'callback',\n            handleAs: 'json'\n        });\n\n        defService.then(function (srvResult) {\n            // request didnt fail, indicating it is likely an ArcGIS Server endpoint\n            var resultType = crawlEsriService(srvResult);\n\n            if (hint && resultType !== hint) {\n                // our hint doesn't match the service\n                resultType = serviceType.Unknown;\n            }\n            resolve(srvHandler[resultType](srvResult));\n        }, function () {\n            // something went wrong, but that doesnt mean our service is invalid yet\n            // it's likely not ESRI.  return Error and let main predictor keep investigating\n            resolve(makeInfo(serviceType.Error));\n        });\n    });\n}\n\n// tests a URL to see if the value is a file\n// providing the known type as a hint will cause the function to run the\n// specific logic for that file type, rather than guessing and trying everything\n// resolves with promise of information object\n// - serviceType : the type of file (CSV, Shape, GeoJSON, Unknown)\n// - fileData : if the file is located on a server, will xhr\nfunction pokeFile(url, esriBundle, hint) {\n\n    // reaction functions to different files\n    // overkill right now, as files just identify the type right now\n    // but structure will let us enhance for custom things if we need to\n    var fileHandler = {};\n\n    // csv\n    fileHandler[serviceType.CSV] = function () {\n        return makeFileInfo(serviceType.CSV, url, esriBundle);\n    };\n\n    // geojson\n    fileHandler[serviceType.GeoJSON] = function () {\n        return makeFileInfo(serviceType.GeoJSON, url, esriBundle);\n    };\n\n    // csv\n    fileHandler[serviceType.Shapefile] = function () {\n        return makeFileInfo(serviceType.Shapefile, url, esriBundle);\n    };\n\n    // couldnt figure it out\n    fileHandler[serviceType.Unknown] = function () {\n        // dont supply url, as we don't want to download random files\n        return makeFileInfo(serviceType.Unknown);\n    };\n\n    return new Promise(function (resolve) {\n        if (hint) {\n            // force the data extraction of the hinted format\n            resolve(fileHandler[hint]());\n        } else {\n            // inspect the url for file extensions\n            var guessType = serviceType.Unknown;\n            switch (url.substr(url.lastIndexOf('.') + 1).toLowerCase()) {\n\n                // check for file extensions\n                case 'csv':\n                    guessType = serviceType.CSV;\n                    break;\n                case 'zip':\n                    guessType = serviceType.Shapefile;\n                    break;\n\n                case 'json':\n                    guessType = serviceType.GeoJSON;\n                    break;\n            }\n            resolve(fileHandler[guessType]());\n        }\n    });\n}\n\n// tests a URL to see if the value is a wms\n// resolves with promise of information object\n// - serviceType : the type of service (WMS, Unknown)\nfunction pokeWms(url, esriBundle) {\n\n    // FIXME add some WMS detection logic.  that would be nice\n\n    console.log(url, esriBundle); // to stop jslint from quacking. remove when params are actually used\n\n    return Promise.resolve(makeInfo(serviceType.WMS));\n}\n\nfunction predictLayerUrlBuilder(esriBundle) {\n    /**\r\n    * Attempts to determine what kind of layer the URL most likely is, and\r\n    * if possible, return back some useful information about the layer\r\n    *\r\n    * - serviceType: the type of layer the function thinks the url is referring to. is a value of serviceType enumeration (string)\r\n    * - fileData: file contents in an array buffer. only present if the URL points to a file that exists on an internet server (i.e. not a local disk drive)\r\n    * - name: best attempt at guessing the name of the service (string). only present for ESRI service URLs\r\n    * - fields: array of field definitions for the layer. conforms to ESRI's REST field standard. only present for feature layer and image service URLs.\r\n    * - geometryType: describes the geometry of the layer (string). conforms to ESRI's REST geometry type enum values. only present for feature layer URLs.\r\n    * - groupIdx: property only available if a group layer is queried. it is the layer index of the group layer in the list under its parent dynamic layer\r\n    *\r\n    * @method predictLayerUrl\r\n    * @param {String} url a url to something that is hopefully a map service\r\n    * @param {String} hint optional. allows the caller to specify the url type, forcing the function to run the data logic for that type\r\n    * @returns {Promise} a promise resolving with an infomation object\r\n    */\n    return function (url, hint) {\n\n        // TODO this function has lots of room to improve.  there are many valid urls that it will\n        //      fail to identify correctly in it's current state\n\n        // TODO refactor how this function works.\n        //      wait for the web service request library to not be esri/request\n        //      use new library to make a head call on the url provided\n        //      examine the content type of the head call result\n        //        if xml, assume WMS\n        //        if json, assume esri  (may need extra logic to differentiate from json file?)\n        //        file case is explicit (e.g text/json)\n        //      then hit appropriate handler, do a second web request for content if required\n\n        if (hint) {\n            // go directly to appropriate logic block\n            var hintToFlavour = {}; // why? cuz cyclomatic complexity + OBEY RULES\n            var flavourToHandler = {};\n\n            // hint type to hint flavour\n            hintToFlavour[serviceType.CSV] = 'F_FILE';\n            hintToFlavour[serviceType.GeoJSON] = 'F_FILE';\n            hintToFlavour[serviceType.Shapefile] = 'F_FILE';\n            hintToFlavour[serviceType.FeatureLayer] = 'F_ESRI';\n            hintToFlavour[serviceType.RasterLayer] = 'F_ESRI';\n            hintToFlavour[serviceType.GroupLayer] = 'F_ESRI';\n            hintToFlavour[serviceType.TileService] = 'F_ESRI';\n            hintToFlavour[serviceType.DynamicService] = 'F_ESRI';\n            hintToFlavour[serviceType.ImageService] = 'F_ESRI';\n            hintToFlavour[serviceType.WMS] = 'F_WMS';\n\n            // hint flavour to flavour-handler\n            flavourToHandler.F_FILE = function () {\n                return pokeFile(url, esriBundle, hint);\n            };\n\n            flavourToHandler.F_ESRI = function () {\n                return pokeEsriService(url, esriBundle, hint);\n            };\n\n            flavourToHandler.F_WMS = function () {\n                // FIXME REAL LOGIC COMING SOON\n                return pokeWms(url, esriBundle);\n            };\n\n            // execute handler.  hint -> flavour -> handler -> run it -> promise\n            return flavourToHandler[hintToFlavour[hint]]();\n        } else {\n\n            // TODO restructure.  this approach cleans up the pyramid of doom.\n            //      Needs to add check for empty tests, resolve as unknown.\n            //      Still a potential to take advantage of the nice structure.  Will depend\n            //      what comes first:  WMS logic (adding a 3rd test), or changing the request\n            //      library, meaning we get the type early from the head request.\n            /*\r\n            tests = [pokeFile, pokeService];\r\n              function runTests() {\r\n                test = tests.pop();\r\n                test(url, esriBundle).then(info => {\r\n                    if (info.serviceType !== serviceType.Unknown) {\r\n                        resolve(info);\r\n                        return;\r\n                    }\r\n                    runTests();\r\n                });\r\n            }\r\n              runTests();\r\n            */\n\n            return new Promise(function (resolve) {\n                // no hint. run tests until we find a match.\n                // test for file\n                pokeFile(url, esriBundle).then(function (infoFile) {\n                    if (infoFile.serviceType === serviceType.Unknown || infoFile.serviceType === serviceType.Error) {\n\n                        // not a file, test for ESRI\n                        pokeEsriService(url, esriBundle).then(function (infoEsri) {\n                            if (infoEsri.serviceType === serviceType.Unknown || infoEsri.serviceType === serviceType.Error) {\n\n                                // FIXME REAL LOGIC COMING SOON\n                                // pokeWMS\n                                resolve(infoEsri);\n                            } else {\n                                // it was a esri service. rejoice.\n\n                                // shortlived rejoice because grouped layers lul\n                                if (infoEsri.serviceType === serviceType.GroupLayer) {\n                                    var lastSlash = url.lastIndexOf('/');\n                                    var layerIdx = parseInt(url.substring(lastSlash + 1));\n                                    url = url.substring(0, lastSlash);\n                                    pokeEsriService(url, esriBundle).then(function (infoDynamic) {\n                                        infoDynamic.groupIdx = layerIdx;\n                                        resolve(infoDynamic);\n                                    });\n                                } else {\n                                    resolve(infoEsri);\n                                }\n                            }\n                        });\n                    } else {\n                        // it was a file. rejoice.\n                        resolve(infoFile);\n                    }\n                });\n            });\n        }\n    };\n}\n\n/**\r\n* Converts an array buffer to a string\r\n*\r\n* @method arrayBufferToString\r\n* @private\r\n* @param {Arraybuffer} buffer an array buffer containing stuff (ideally string-friendly)\r\n* @returns {String} array buffer in string form\r\n*/\nfunction arrayBufferToString(buffer) {\n    // handles UTF8 encoding\n    return new TextDecoder('utf-8').decode(new Uint8Array(buffer));\n}\n\n/**\r\n* Performs validation on GeoJson object. Returns a promise resolving with the validation object.\r\n* Worker function for validateFile, see that file for return value specs\r\n*\r\n* @method validateGeoJson\r\n* @private\r\n* @param {Object} geoJson feature collection in geojson form\r\n* @returns {Promise} promise resolving with information on the geoJson object\r\n*/\nfunction validateGeoJson(geoJson) {\n    // GeoJSON geometry type to ESRI geometry type\n    var geomMap = {\n        Point: 'esriGeometryPoint',\n        MultiPoint: 'esriGeometryMultipoint',\n        LineString: 'esriGeometryPolyline',\n        MultiLineString: 'esriGeometryPolyline',\n        Polygon: 'esriGeometryPolygon',\n        MultiPolygon: 'esriGeometryPolygon'\n    };\n\n    var fields = extractFields(geoJson);\n\n    var res = {\n        fields: fields,\n        geometryType: geomMap[geoJson.features[0].geometry.type],\n        formattedData: geoJson,\n        smartDefaults: {\n            // TODO: try to find a name field if possible\n            primary: fields[0].name // pick the first field as primary and return its name for ui binding\n        }\n    };\n\n    if (!res.geometryType) {\n        return Promise.reject(new Error('Unexpected geometry type in GeoJSON'));\n    }\n\n    // TODO optional check: iterate through every feature, ensure geometry type and properties are all identical\n\n    return Promise.resolve(res);\n}\n\n/**\r\n* Performs validation on csv data. Returns a promise resolving with the validation object.\r\n* Worker function for validateFile, see that file for return value specs\r\n*\r\n* @method validateCSV\r\n* @private\r\n* @param {Object} data csv data as string\r\n* @returns {Promise} promise resolving with information on the csv data\r\n*/\nfunction validateCSV(data) {\n\n    var formattedData = arrayBufferToString(data); // convert from arraybuffer to string to parsed csv. store string format for later\n    var rows = csvPeek(formattedData, ','); // FIXME: this assumes delimiter is a `,`; need validation\n    var errorMessage = void 0; // error message if any to return\n\n    // validations\n    if (rows.length === 0) {\n        // fail, no rows\n        errorMessage = 'File has no rows';\n    } else {\n        // field count of first row.\n        var fc = rows[0].length;\n        if (fc < 2) {\n            // fail not enough columns\n            errorMessage = 'File has less than two columns';\n        } else {\n            // check field counts of each row\n            if (rows.every(function (rowArr) {\n                return rowArr.length === fc;\n            })) {\n\n                var res = {\n                    formattedData: formattedData,\n                    smartDefaults: guessCSVfields(rows), // calculate smart defaults\n\n                    // make field list esri-ish for consistancy\n                    fields: rows[0].map(function (field) {\n                        return {\n                            name: field,\n                            type: 'esriFieldTypeString'\n                        };\n                    }),\n                    geometryType: 'esriGeometryPoint' // always point for CSV\n                };\n\n                return Promise.resolve(res);\n            } else {\n                errorMessage = 'File has inconsistent column counts';\n            }\n        }\n    }\n\n    return Promise.reject(new Error(errorMessage));\n}\n\n/**\r\n* Validates file content.  Does some basic checking for errors. Attempts to get field list, and\r\n* if possible, provide the file in a more useful format. Promise rejection indicates failed validation\r\n*\r\n* - formattedData: file contents in a more useful format. JSON for GeoJSON and Shapefile. String for CSV\r\n* - fields: array of field definitions for the file. conforms to ESRI's REST field standard.\r\n* - geometryType: describes the geometry of the file (string). conforms to ESRI's REST geometry type enum values.\r\n*\r\n* @method validateFile\r\n* @param {String} type the format of file. aligns to serviceType enum (CSV, Shapefile, GeoJSON)\r\n* @param {Arraybuffer} data the file content in binary\r\n* @returns {Promise} a promise resolving with an infomation object\r\n*/\nfunction validateFile(type, data) {\n    var _fileHandler;\n\n    var fileHandler = (_fileHandler = {}, _defineProperty(_fileHandler, serviceType.CSV, function (data) {\n        return validateCSV(data);\n    }), _defineProperty(_fileHandler, serviceType.GeoJSON, function (data) {\n        var geoJson = JSON.parse(arrayBufferToString(data));\n        return validateGeoJson(geoJson);\n    }), _defineProperty(_fileHandler, serviceType.Shapefile, function (data) {\n        return shp(data).then(function (geoJson) {\n            return validateGeoJson(geoJson);\n        });\n    }), _fileHandler);\n\n    // trigger off the appropriate handler, return promise\n    return fileHandler[type](data);\n}\n\n/**\r\n * From provided CSV data, guesses which columns are long and lat. If guessing is no successful, returns null for one or both fields.\r\n *\r\n * @method guessCSVfields\r\n * @private\r\n * @param  {Array} rows csv data\r\n * @return {Object}      an object with lat and long string properties indicating corresponding field names\r\n */\nfunction guessCSVfields(rows) {\n    // magic regexes\n    // TODO: in case of performance issues with running regexes on large csv files, limit to, say, the first hundred rows\n    // TODO: explain regexes\n    var latValueRegex = new RegExp(/^[-+]?([1-8]?\\d(\\.\\d+)?|90(\\.0+)?)$/); // filters by field value\n    var longValueRegex = new RegExp(/^[-+]?(180(\\.0+)?|((1[0-7]\\d)|([1-9]?\\d))(\\.\\d+)?)$/);\n    var latNameRegex = new RegExp(/^.*(y|la).*$/i); // filters by field name\n    var longNameRegex = new RegExp(/^.*(x|lo).*$/i);\n\n    var latCandidates = findCandidates(rows, latValueRegex, latNameRegex); // filter out all columns that are not lat based on row values\n    var longCandidates = findCandidates(rows, longValueRegex, longNameRegex); // filter out all columns that are not long based on row values\n\n    // console.log(latCandidates);\n    // console.log(longCandidates);\n\n    // pick the first lat guess or null\n    var lat = latCandidates[0] || null;\n\n    // pick the first long guess or null\n    var long = longCandidates.find(function (field) {\n        return field !== lat;\n    }) || null;\n\n    // for primary field, pick the first on that is not lat or long field or null\n    var primary = rows[0].find(function (field) {\n        return field !== lat && field !== long;\n    }) || null;\n\n    return {\n        lat: lat,\n        long: long,\n        primary: primary\n    };\n\n    function findCandidates(rows, valueRegex, nameRegex) {\n        var fields = rows[0]; // first row must be headers\n\n        var candidates = fields.filter(function (field, index) {\n            return rows.every(function (row, rowIndex) {\n                return rowIndex === 0 || valueRegex.test(row[index]);\n            });\n        }) // skip first row as its just headers\n        .filter(function (field) {\n            return nameRegex.test(field);\n        });\n\n        return candidates;\n    }\n}\n\nfunction serverLayerIdentifyBuilder(esriBundle) {\n    // TODO we are using layerIds option property as it aligns with what the ESRI identify parameter\n    //      object uses.  However, in r2 terminology, a layerId is specific to a full map layer, not\n    //      indexes of a single dynamic layer.  for clarity, could consider renaming to .visibleLayers\n    //      and then map the value to the .layerIds property inside this function.\n\n    /**\r\n    * Perform a server-side identify on a layer (usually an ESRI dynamic layer)\r\n    * Accepts the following options:\r\n    *   - geometry: Required. geometry in map co-ordinates for the area to identify.\r\n    *     will usually be an ESRI Point, though a polygon would work.\r\n    *   - mapExtent: Required. ESRI Extent of the current map view\r\n    *   - width: Required. Width of the map in pixels\r\n    *   - height: Required. Height of the map in pixels\r\n    *   - layerIds: an array of integers specifying the layer indexes to be examined. Will override the current\r\n    *     visible indexes in the layer parameter\r\n    *   - returnGeometry: a boolean indicating if result geometery should be returned with results.  Defaults to false\r\n    *   - tolerance: an integer indicating how many screen pixels away from the mouse is valid for a hit.  Defaults to 5\r\n    *\r\n    * @method serverLayerIdentify\r\n    * @param {Object} layer an ESRI dynamic layer object\r\n    * @param {Object} opts An object for supplying additional parameters\r\n    * @returns {Promise} a promise resolving with an array of identify results (empty array if no hits)\r\n    */\n    return function (layer, opts) {\n\n        var identParams = new esriBundle.IdentifyParameters();\n\n        // pluck treats from options parameter\n        if (opts) {\n\n            var reqOpts = ['geometry', 'mapExtent', 'height', 'width'];\n            reqOpts.forEach(function (optProp) {\n                if (opts[optProp]) {\n                    identParams[optProp] = opts[optProp];\n                } else {\n                    throw new Error('serverLayerIdentify - missing opts.' + optProp + ' arguement');\n                }\n            });\n\n            identParams.layerIds = opts.layerIds || layer.visibleLayers;\n            identParams.returnGeometry = opts.returnGeometry || false;\n            identParams.layerOption = esriBundle.IdentifyParameters.LAYER_OPTION_ALL;\n            identParams.spatialReference = opts.geometry.spatialReference;\n            identParams.tolerance = opts.tolerance || 5;\n\n            // TODO add support for identParams.layerDefinitions once attribute filtering is implemented\n        } else {\n            throw new Error('serverLayerIdentify - missing opts arguement');\n        }\n\n        // asynch an identify task\n        return new Promise(function (resolve, reject) {\n            var identify = new esriBundle.IdentifyTask(layer.url);\n\n            // TODO possibly tack on the layer.id to the resolved thing so we know which parent layer returned?\n            //      would only be required if the caller is mashing promises together and using Promise.all()\n\n            identify.on('complete', function (result) {\n                resolve(result.results);\n            });\n            identify.on('error', function (err) {\n                reject(err.error);\n            });\n\n            identify.execute(identParams);\n        });\n    };\n}\n\n/**\r\n* Performs in place assignment of integer ids for a GeoJSON FeatureCollection.\r\n* If at least one feature has an existing id outside the geoJson properties section,\r\n* the original id value is copied in a newly created property ID_FILE of the properties object\r\n* and the existing id value is replaced by an autogenerated number.\r\n* Features without existing id from that same dataset will get a new properties ID_FILE\r\n* with an empty string as value.\r\n**************************************\r\n* If at least one feature has an existing OBJECTID inside the geoJson properties section,\r\n* the original OBJECTID value is copied in a newly created property OBJECTID_FILE of the properties object\r\n* and the existing OBJECTID value is replaced by an autogenerated number.\r\n* Features without existing OBJECTID from that same dataset will get a new properties OBJECTID_FILE\r\n* with an empty string as value.\r\n*/\nfunction assignIds(geoJson) {\n    if (geoJson.type !== 'FeatureCollection') {\n        throw new Error('Assignment can only be performed on FeatureCollections');\n    }\n\n    var emptyID = true;\n    var emptyObjID = true;\n\n    // for every feature, if it does not have an id property, add it.\n    // 0 is not a valid object id\n    geoJson.features.forEach(function (val, idx) {\n        Object.assign(val.properties, { ID_FILE: '', OBJECTID_FILE: '' });\n\n        // to avoid double ID columns outside properties\n        if ('id' in val && typeof val.id !== 'undefined') {\n            val.properties.ID_FILE = val.id;\n            emptyID = false;\n        }\n\n        // to avoid double OBJECTID columns. Useful for both geojson and CSV file.\n        if ('OBJECTID' in val.properties) {\n            val.properties.OBJECTID_FILE = val.properties.OBJECTID;\n            delete val.properties.OBJECTID;\n            emptyObjID = false;\n        }\n\n        val.id = idx + 1;\n    });\n\n    // remove ID_FILE if all empty\n    if (emptyID) {\n        geoJson.features.forEach(function (val) {\n            delete val.properties.ID_FILE;\n        });\n    }\n\n    // remove OBJECTID_FILE if all empty\n    if (emptyObjID) {\n        geoJson.features.forEach(function (val) {\n            delete val.properties.OBJECTID_FILE;\n        });\n    }\n}\n\n/**\r\n * Extracts fields from the first feature in the feature collection, does no\r\n * guesswork on property types and calls everything a string.\r\n */\nfunction extractFields(geoJson) {\n    if (geoJson.features.length < 1) {\n        throw new Error('Field extraction requires at least one feature');\n    }\n\n    return Object.keys(geoJson.features[0].properties).map(function (prop) {\n        return { name: prop, type: 'esriFieldTypeString' };\n    });\n}\n\n/**\r\n * Makes an attempt to load and register a projection definition.\r\n * Returns promise resolving when process is complete\r\n * projModule - proj module from geoApi\r\n * projCode - the string or int epsg code we want to lookup\r\n * epsgLookup - function that will do the epsg lookup, taking code and returning promise of result or null\r\n */\nfunction projectionLookup(projModule, projCode, epsgLookup) {\n    // look up projection definitions if it's not already loaded and we have enough info\n    if (!projModule.getProjection(projCode) && epsgLookup && projCode) {\n        return epsgLookup(projCode).then(function (projDef) {\n            if (projDef) {\n                // register projection\n                projModule.addProjection(projCode, projDef);\n            }\n            return projDef;\n        });\n    } else {\n        return Promise.resolve(null);\n    }\n}\n\nfunction makeGeoJsonLayerBuilder(esriBundle, geoApi) {\n\n    /**\r\n    * Converts a GeoJSON object into a FeatureLayer.  Expects GeoJSON to be formed as a FeatureCollection\r\n    * containing a uniform feature type (FeatureLayer type will be set according to the type of the first\r\n    * feature entry).  Accepts the following options:\r\n    *   - targetWkid: Required. an integer for an ESRI wkid to project geometries to\r\n    *   - renderer: a string identifying one of the properties in defaultRenders\r\n    *   - sourceProjection: a string matching a proj4.defs projection to be used for the source data (overrides\r\n    *     geoJson.crs)\r\n    *   - fields: an array of fields to be appended to the FeatureLayer layerDefinition (OBJECTID is set by default)\r\n    *   - epsgLookup: a function that takes an EPSG code (string or number) and returns a promise of a proj4 style\r\n    *     definition or null if not found\r\n    *   - layerId: a string to use as the layerId\r\n    *   - colour: a hex string to define the symbol colour. e.g. '#33DD6A'\r\n    *\r\n    * @method makeGeoJsonLayer\r\n    * @param {Object} geoJson An object following the GeoJSON specification, should be a FeatureCollection with\r\n    * Features of only one type\r\n    * @param {Object} opts An object for supplying additional parameters\r\n    * @returns {Promise} a promise resolving with a {FeatureLayer}\r\n    */\n    return function (geoJson, opts) {\n\n        // TODO add documentation on why we only support layers with WKID (and not WKT).\n        var targetWkid = void 0;\n        var srcProj = 'EPSG:4326'; // 4326 is the default for GeoJSON with no projection defined\n        var layerId = void 0;\n        var layerDefinition = {\n            objectIdField: 'OBJECTID',\n            fields: [{\n                name: 'OBJECTID',\n                type: 'esriFieldTypeOID'\n            }]\n        };\n\n        // ensure our features have ids\n        assignIds(geoJson);\n        layerDefinition.drawingInfo = defaultRenderers[featureTypeToRenderer[geoJson.features[0].geometry.type]];\n\n        // attempt to get spatial reference from geoJson\n        if (geoJson.crs && geoJson.crs.type === 'name') {\n            srcProj = geoJson.crs.properties.name;\n        }\n\n        // pluck treats from options parameter\n        if (opts) {\n            if (opts.sourceProjection) {\n                srcProj = opts.sourceProjection;\n            }\n\n            if (opts.targetWkid) {\n                targetWkid = opts.targetWkid;\n            } else {\n                throw new Error('makeGeoJsonLayer - missing opts.targetWkid arguement');\n            }\n\n            if (opts.fields) {\n                layerDefinition.fields = layerDefinition.fields.concat(opts.fields);\n            }\n\n            if (opts.layerId) {\n                layerId = opts.layerId;\n            } else {\n                layerId = geoApi.shared.generateUUID();\n            }\n\n            // TODO add support for renderer option, or drop the option\n        } else {\n            throw new Error('makeGeoJsonLayer - missing opts arguement');\n        }\n\n        if (layerDefinition.fields.length === 1) {\n            // caller has not supplied custom field list. so take them all.\n            layerDefinition.fields = layerDefinition.fields.concat(extractFields(geoJson));\n        }\n\n        var destProj = 'EPSG:' + targetWkid;\n\n        // look up projection definitions if they don't already exist and we have enough info\n        var srcLookup = projectionLookup(geoApi.proj, srcProj, opts.epsgLookup);\n        var destLookup = projectionLookup(geoApi.proj, destProj, opts.epsgLookup);\n\n        // make the layer\n        var buildLayer = new Promise(function (resolve) {\n\n            // project data and convert to esri json format\n            // console.log('reprojecting ' + srcProj + ' -> EPSG:' + targetWkid);\n            geoApi.proj.projectGeojson(geoJson, destProj, srcProj);\n            var esriJson = Terraformer.ArcGIS.convert(geoJson, { sr: targetWkid });\n            var geometryType = layerDefinition.drawingInfo.geometryType;\n\n            var fs = {\n                features: esriJson,\n                geometryType: geometryType\n            };\n            var layer = new esriBundle.FeatureLayer({\n                layerDefinition: layerDefinition,\n                featureSet: fs\n            }, {\n                mode: esriBundle.FeatureLayer.MODE_SNAPSHOT,\n                id: layerId\n            });\n\n            // (O) manually setting SR because it will come out as 4326\n            layer.spatialReference = new esriBundle.SpatialReference({ wkid: targetWkid });\n\n            if (opts.colour) {\n                layer.renderer.symbol.color = new esriBundle.Color(opts.colour);\n            }\n\n            // initializing layer using JSON does not set this property. do it manually.\n            layer.geometryType = geometryType;\n\n            resolve(layer);\n        });\n\n        // call promises in order\n        return srcLookup.then(function () {\n            return destLookup;\n        }).then(function () {\n            return buildLayer;\n        });\n    };\n}\n\nfunction makeCsvLayerBuilder(esriBundle, geoApi) {\n\n    /**\r\n    * Constructs a FeatureLayer from CSV data. Accepts the following options:\r\n    *   - targetWkid: Required. an integer for an ESRI wkid the spatial reference the returned layer should be in\r\n    *   - renderer: a string identifying one of the properties in defaultRenders\r\n    *   - fields: an array of fields to be appended to the FeatureLayer layerDefinition (OBJECTID is set by default)\r\n    *   - latfield: a string identifying the field containing latitude values ('Lat' by default)\r\n    *   - lonfield: a string identifying the field containing longitude values ('Long' by default)\r\n    *   - delimiter: a string defining the delimiter character of the file (',' by default)\r\n    *   - epsgLookup: a function that takes an EPSG code (string or number) and returns a promise of a proj4 style\r\n    *     definition or null if not found\r\n    *   - layerId: a string to use as the layerId\r\n    *   - colour: a hex string to define the symbol colour. e.g. '#33DD6A'\r\n    * @param {string} csvData the CSV data to be processed\r\n    * @param {object} opts options to be set for the parser\r\n    * @returns {Promise} a promise resolving with a {FeatureLayer}\r\n    */\n    return function (csvData, opts) {\n        var csvOpts = { // default values\n            latfield: 'Lat',\n            lonfield: 'Long',\n            delimiter: ','\n        };\n\n        // user options if\n        if (opts) {\n            if (opts.latfield) {\n                csvOpts.latfield = opts.latfield;\n            }\n\n            if (opts.lonfield) {\n                csvOpts.lonfield = opts.lonfield;\n            }\n\n            if (opts.delimiter) {\n                csvOpts.delimiter = opts.delimiter;\n            }\n        }\n\n        return new Promise(function (resolve, reject) {\n            csv2geojson.csv2geojson(csvData, csvOpts, function (err, data) {\n                if (err) {\n                    console.warn('csv conversion error');\n                    console.log(err);\n                    reject(err);\n                } else {\n                    // csv2geojson will not include the lat and long in the feature\n                    data.features.map(function (feature) {\n                        // add new property Long and Lat before layer is generated\n                        feature.properties[csvOpts.lonfield] = feature.geometry.coordinates[0];\n                        feature.properties[csvOpts.latfield] = feature.geometry.coordinates[1];\n                    });\n\n                    // TODO are we at risk adding params to the var that was passed in? should we make a copy and modify the copy?\n                    opts.sourceProjection = 'EPSG:4326'; // csv is always latlong\n                    opts.renderer = 'circlePoint'; // csv is always latlong\n\n                    // NOTE: since makeGeoJsonLayer is a \"built\" function, grab the built version from our link to api object\n                    geoApi.layer.makeGeoJsonLayer(data, opts).then(function (jsonLayer) {\n                        resolve(jsonLayer);\n                    });\n                }\n            });\n        });\n    };\n}\n\n/**\r\n* Peek at the CSV output (useful for checking headers)\r\n* @param {string} csvData the CSV data to be processed\r\n* @param {string} delimiter the delimiter used by the data\r\n* @returns {Array} an array of arrays containing the parsed CSV\r\n*/\nfunction csvPeek(csvData, delimiter) {\n    return csv2geojson.dsv(delimiter).parseRows(csvData);\n}\n\nfunction makeShapeLayerBuilder(esriBundle, geoApi) {\n\n    /**\r\n    * Constructs a FeatureLayer from Shapefile data. Accepts the following options:\r\n    *   - targetWkid: Required. an integer for an ESRI wkid the spatial reference the returned layer should be in\r\n    *   - renderer: a string identifying one of the properties in defaultRenders\r\n    *   - sourceProjection: a string matching a proj4.defs projection to be used for the source data (overrides\r\n    *     geoJson.crs)\r\n    *   - fields: an array of fields to be appended to the FeatureLayer layerDefinition (OBJECTID is set by default)\r\n    *   - epsgLookup: a function that takes an EPSG code (string or number) and returns a promise of a proj4 style\r\n    *     definition or null if not found\r\n    *   - layerId: a string to use as the layerId\r\n    *   - colour: a hex string to define the symbol colour. e.g. '#33DD6A'\r\n    * @param {ArrayBuffer} shapeData an ArrayBuffer of the Shapefile in zip format\r\n    * @param {object} opts options to be set for the parser\r\n    * @returns {Promise} a promise resolving with a {FeatureLayer}\r\n    */\n    return function (shapeData, opts) {\n        return new Promise(function (resolve, reject) {\n            // turn shape into geojson\n            shp(shapeData).then(function (geoJson) {\n                // turn geojson into feature layer\n                // NOTE: since makeGeoJsonLayer is a \"built\" function, grab the built version from our link to api object\n                geoApi.layer.makeGeoJsonLayer(geoJson, opts).then(function (jsonLayer) {\n                    resolve(jsonLayer);\n                });\n            }).catch(function (err) {\n                reject(err);\n            });\n        });\n    };\n}\n\nfunction createImageRecordBuilder(esriBundle, geoApi, classBundle) {\n    /**\r\n    * Creates an Image Layer Record class\r\n    * @param {Object} config         layer config values\r\n    * @param {Object} esriLayer      an optional pre-constructed layer\r\n    * @param {Function} epsgLookup   an optional lookup function for EPSG codes (see geoService for signature)\r\n    * @returns {Object}              instantited ImageRecord class\r\n    */\n    return function (config, esriLayer, epsgLookup) {\n        return new classBundle.ImageRecord(esriBundle.ArcGISImageServiceLayer, geoApi, config, esriLayer, epsgLookup);\n    };\n}\n\nfunction createFeatureRecordBuilder(esriBundle, geoApi, classBundle) {\n    /**\r\n    * Creates an Feature Layer Record class\r\n    * @param {Object} config         layer config values\r\n    * @param {Object} esriLayer      an optional pre-constructed layer\r\n    * @param {Function} epsgLookup   an optional lookup function for EPSG codes (see geoService for signature)\r\n    * @returns {Object}              instantited FeatureRecord class\r\n    */\n    return function (config, esriLayer, epsgLookup) {\n        return new classBundle.FeatureRecord(esriBundle.FeatureLayer, esriBundle.esriRequest, geoApi, config, esriLayer, epsgLookup);\n    };\n}\n\nfunction createDynamicRecordBuilder(esriBundle, geoApi, classBundle) {\n    /**\r\n     * Creates an Dynamic Layer Record class\r\n     * See DynamicRecord constructor for more detailed info on configIsComplete.\r\n     *\r\n     * @param {Object} config              layer config values\r\n     * @param {Object} esriLayer           an optional pre-constructed layer\r\n     * @param {Function} epsgLookup        an optional lookup function for EPSG codes (see geoService for signature)\r\n     * @param {Boolean} configIsComplete   an optional flag to indicate all child state values are provided in the config and should be used.\r\n     * @returns {Object}                   instantited DynamicRecord class\r\n     */\n    return function (config, esriLayer, epsgLookup) {\n        var configIsComplete = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n        return new classBundle.DynamicRecord(esriBundle.ArcGISDynamicMapServiceLayer, esriBundle.esriRequest, geoApi, config, esriLayer, epsgLookup, configIsComplete);\n    };\n}\n\nfunction createTileRecordBuilder(esriBundle, geoApi, classBundle) {\n    /**\r\n    * Creates an Tile Layer Record class\r\n    * @param {Object} config         layer config values\r\n    * @param {Object} esriLayer      an optional pre-constructed layer\r\n    * @param {Function} epsgLookup   an optional lookup function for EPSG codes (see geoService for signature)\r\n    * @returns {Object}              instantited TileRecord class\r\n    */\n    return function (config, esriLayer, epsgLookup) {\n        return new classBundle.TileRecord(esriBundle.ArcGISTiledMapServiceLayer, geoApi, config, esriLayer, epsgLookup);\n    };\n}\n\nfunction createWmsRecordBuilder(esriBundle, geoApi, classBundle) {\n    /**\r\n    * Creates an WMS Layer Record class\r\n    * @param {Object} config         layer config values\r\n    * @param {Object} esriLayer      an optional pre-constructed layer\r\n    * @param {Function} epsgLookup   an optional lookup function for EPSG codes (see geoService for signature)\r\n    * @returns {Object}              instantited WmsRecord class\r\n    */\n    return function (config, esriLayer, epsgLookup) {\n        return new classBundle.WmsRecord(esriBundle.WmsLayer, geoApi, config, esriLayer, epsgLookup);\n    };\n}\n\n/**\r\n* Given 2D array in column x row format, check if all entries in the two given columns are numeric.\r\n*\r\n* @param {Array} arr is a 2D array based on the CSV file that contains row information for all of the rows\r\n* @param {Integer} ind1 is a user specified index when uploading the CSV that specifies lat or long column (whichever isn't specified by ind2)\r\n* @param {Integer} ind2 is a user specified index when uploading the CSV that specifies lat or long column (whichever isn't specified by ind1)\r\n* @return {Boolean} returns true or false based on whether or not all all columns at ind1 and ind2 are numbers\r\n*/\nfunction validateLatLong(arr, ind1, ind2) {\n    return arr.every(function (row) {\n        return !(isNaN(row[ind1]) || isNaN(row[ind2]));\n    });\n}\n\n// CAREFUL NOW!\n// we are passing in a reference to geoApi.  it is a pointer to the object that contains this module,\n// along with other modules. it lets us access other modules without re-instantiating them in here.\nmodule.exports = function (esriBundle, geoApi) {\n\n    var layerClassBundle = layerRecord(esriBundle, geoApi);\n\n    return {\n        ArcGISDynamicMapServiceLayer: esriBundle.ArcGISDynamicMapServiceLayer,\n        ArcGISImageServiceLayer: esriBundle.ArcGISImageServiceLayer,\n        GraphicsLayer: esriBundle.GraphicsLayer,\n        FeatureLayer: esriBundle.FeatureLayer,\n        ScreenPoint: esriBundle.ScreenPoint,\n        Query: esriBundle.Query,\n        TileLayer: esriBundle.ArcGISTiledMapServiceLayer,\n        ogc: ogc(esriBundle),\n        bbox: bbox(esriBundle, geoApi),\n        createImageRecord: createImageRecordBuilder(esriBundle, geoApi, layerClassBundle),\n        createWmsRecord: createWmsRecordBuilder(esriBundle, geoApi, layerClassBundle),\n        createTileRecord: createTileRecordBuilder(esriBundle, geoApi, layerClassBundle),\n        createDynamicRecord: createDynamicRecordBuilder(esriBundle, geoApi, layerClassBundle),\n        createFeatureRecord: createFeatureRecordBuilder(esriBundle, geoApi, layerClassBundle),\n        LayerDrawingOptions: esriBundle.LayerDrawingOptions,\n        makeGeoJsonLayer: makeGeoJsonLayerBuilder(esriBundle, geoApi),\n        makeCsvLayer: makeCsvLayerBuilder(esriBundle, geoApi),\n        makeShapeLayer: makeShapeLayerBuilder(esriBundle, geoApi),\n        serverLayerIdentify: serverLayerIdentifyBuilder(esriBundle),\n        predictLayerUrl: predictLayerUrlBuilder(esriBundle),\n        validateFile: validateFile,\n        csvPeek: csvPeek,\n        serviceType: serviceType,\n        validateLatLong: validateLatLong\n    };\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXIuanM/OGJhZCJdLCJuYW1lcyI6WyJjc3YyZ2VvanNvbiIsInJlcXVpcmUiLCJUZXJyYWZvcm1lciIsInNocCIsIm9nYyIsImJib3giLCJsYXllclJlY29yZCIsImRlZmF1bHRSZW5kZXJlcnMiLCJBcmNHSVMiLCJmZWF0dXJlVHlwZVRvUmVuZGVyZXIiLCJQb2ludCIsIk11bHRpUG9pbnQiLCJMaW5lU3RyaW5nIiwiTXVsdGlMaW5lU3RyaW5nIiwiUG9seWdvbiIsIk11bHRpUG9seWdvbiIsInNlcnZpY2VUeXBlIiwiQ1NWIiwiR2VvSlNPTiIsIlNoYXBlZmlsZSIsIkZlYXR1cmVMYXllciIsIlJhc3RlckxheWVyIiwiR3JvdXBMYXllciIsIlRpbGVTZXJ2aWNlIiwiRmVhdHVyZVNlcnZpY2UiLCJEeW5hbWljU2VydmljZSIsIkltYWdlU2VydmljZSIsIldNUyIsIlVua25vd24iLCJFcnJvciIsImlzU2VydmVyRmlsZSIsInVybCIsImxvd1VybCIsInRvTG93ZXJDYXNlIiwidGVzdHMiLCJzb21lIiwibWF0Y2giLCJ0ZXN0IiwiZ2V0U2VydmVyRmlsZSIsImVzcmlCdW5kbGUiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImRlZlNlcnZpY2UiLCJlc3JpUmVxdWVzdCIsImhhbmRsZUFzIiwidGhlbiIsInNydlJlc3VsdCIsImVycm9yIiwibWFrZUluZm8iLCJ0eXBlIiwiaW5kZXgiLCJ0aWxlU3VwcG9ydCIsIm1ha2VMYXllckluZm8iLCJuYW1lIiwianNvbiIsImluZm8iLCJzZXJ2aWNlTmFtZSIsInJvb3RVcmwiLCJtYWtlRmlsZUluZm8iLCJmaWxlRGF0YSIsImRhdGEiLCJjYXRjaCIsImNyYXdsRXNyaVNlcnZpY2UiLCJzcnZKc29uIiwibWFwcGVyIiwiaGFzT3duUHJvcGVydHkiLCJzaW5nbGVGdXNlZE1hcENhY2hlIiwicmVwb2tlRXNyaVNlcnZpY2UiLCJjaGlsZEluZm8iLCJyZSIsIm1hdGNoZXMiLCJjb25zb2xlIiwid2FybiIsInBhcnNlSW50Iiwic3Vic3RyIiwibGVuZ3RoIiwicG9rZUVzcmlTZXJ2aWNlIiwicm9vdEluZm8iLCJsYXllcnMiLCJoaW50Iiwic3J2SGFuZGxlciIsImZpZWxkcyIsImdlb21ldHJ5VHlwZSIsInNtYXJ0RGVmYXVsdHMiLCJwcmltYXJ5IiwiaW5kZXhUeXBlIiwiY29udGVudCIsImYiLCJjYWxsYmFja1BhcmFtTmFtZSIsInJlc3VsdFR5cGUiLCJwb2tlRmlsZSIsImZpbGVIYW5kbGVyIiwiZ3Vlc3NUeXBlIiwibGFzdEluZGV4T2YiLCJwb2tlV21zIiwibG9nIiwicHJlZGljdExheWVyVXJsQnVpbGRlciIsImhpbnRUb0ZsYXZvdXIiLCJmbGF2b3VyVG9IYW5kbGVyIiwiRl9GSUxFIiwiRl9FU1JJIiwiRl9XTVMiLCJpbmZvRmlsZSIsImluZm9Fc3JpIiwibGFzdFNsYXNoIiwibGF5ZXJJZHgiLCJzdWJzdHJpbmciLCJpbmZvRHluYW1pYyIsImdyb3VwSWR4IiwiYXJyYXlCdWZmZXJUb1N0cmluZyIsImJ1ZmZlciIsIlRleHREZWNvZGVyIiwiZGVjb2RlIiwiVWludDhBcnJheSIsInZhbGlkYXRlR2VvSnNvbiIsImdlb0pzb24iLCJnZW9tTWFwIiwiZXh0cmFjdEZpZWxkcyIsInJlcyIsImZlYXR1cmVzIiwiZ2VvbWV0cnkiLCJmb3JtYXR0ZWREYXRhIiwidmFsaWRhdGVDU1YiLCJyb3dzIiwiY3N2UGVlayIsImVycm9yTWVzc2FnZSIsImZjIiwiZXZlcnkiLCJyb3dBcnIiLCJndWVzc0NTVmZpZWxkcyIsIm1hcCIsImZpZWxkIiwidmFsaWRhdGVGaWxlIiwiSlNPTiIsInBhcnNlIiwibGF0VmFsdWVSZWdleCIsIlJlZ0V4cCIsImxvbmdWYWx1ZVJlZ2V4IiwibGF0TmFtZVJlZ2V4IiwibG9uZ05hbWVSZWdleCIsImxhdENhbmRpZGF0ZXMiLCJmaW5kQ2FuZGlkYXRlcyIsImxvbmdDYW5kaWRhdGVzIiwibGF0IiwibG9uZyIsImZpbmQiLCJ2YWx1ZVJlZ2V4IiwibmFtZVJlZ2V4IiwiY2FuZGlkYXRlcyIsImZpbHRlciIsInJvdyIsInJvd0luZGV4Iiwic2VydmVyTGF5ZXJJZGVudGlmeUJ1aWxkZXIiLCJsYXllciIsIm9wdHMiLCJpZGVudFBhcmFtcyIsIklkZW50aWZ5UGFyYW1ldGVycyIsInJlcU9wdHMiLCJmb3JFYWNoIiwib3B0UHJvcCIsImxheWVySWRzIiwidmlzaWJsZUxheWVycyIsInJldHVybkdlb21ldHJ5IiwibGF5ZXJPcHRpb24iLCJMQVlFUl9PUFRJT05fQUxMIiwic3BhdGlhbFJlZmVyZW5jZSIsInRvbGVyYW5jZSIsImlkZW50aWZ5IiwiSWRlbnRpZnlUYXNrIiwib24iLCJyZXN1bHQiLCJyZXN1bHRzIiwiZXJyIiwiZXhlY3V0ZSIsImFzc2lnbklkcyIsImVtcHR5SUQiLCJlbXB0eU9iaklEIiwidmFsIiwiaWR4IiwiT2JqZWN0IiwiYXNzaWduIiwicHJvcGVydGllcyIsIklEX0ZJTEUiLCJPQkpFQ1RJRF9GSUxFIiwiaWQiLCJPQkpFQ1RJRCIsImtleXMiLCJwcm9wIiwicHJvamVjdGlvbkxvb2t1cCIsInByb2pNb2R1bGUiLCJwcm9qQ29kZSIsImVwc2dMb29rdXAiLCJnZXRQcm9qZWN0aW9uIiwicHJvakRlZiIsImFkZFByb2plY3Rpb24iLCJtYWtlR2VvSnNvbkxheWVyQnVpbGRlciIsImdlb0FwaSIsInRhcmdldFdraWQiLCJzcmNQcm9qIiwibGF5ZXJJZCIsImxheWVyRGVmaW5pdGlvbiIsIm9iamVjdElkRmllbGQiLCJkcmF3aW5nSW5mbyIsImNycyIsInNvdXJjZVByb2plY3Rpb24iLCJjb25jYXQiLCJzaGFyZWQiLCJnZW5lcmF0ZVVVSUQiLCJkZXN0UHJvaiIsInNyY0xvb2t1cCIsInByb2oiLCJkZXN0TG9va3VwIiwiYnVpbGRMYXllciIsInByb2plY3RHZW9qc29uIiwiZXNyaUpzb24iLCJjb252ZXJ0Iiwic3IiLCJmcyIsImZlYXR1cmVTZXQiLCJtb2RlIiwiTU9ERV9TTkFQU0hPVCIsIlNwYXRpYWxSZWZlcmVuY2UiLCJ3a2lkIiwiY29sb3VyIiwicmVuZGVyZXIiLCJzeW1ib2wiLCJjb2xvciIsIkNvbG9yIiwibWFrZUNzdkxheWVyQnVpbGRlciIsImNzdkRhdGEiLCJjc3ZPcHRzIiwibGF0ZmllbGQiLCJsb25maWVsZCIsImRlbGltaXRlciIsImZlYXR1cmUiLCJjb29yZGluYXRlcyIsIm1ha2VHZW9Kc29uTGF5ZXIiLCJqc29uTGF5ZXIiLCJkc3YiLCJwYXJzZVJvd3MiLCJtYWtlU2hhcGVMYXllckJ1aWxkZXIiLCJzaGFwZURhdGEiLCJjcmVhdGVJbWFnZVJlY29yZEJ1aWxkZXIiLCJjbGFzc0J1bmRsZSIsImNvbmZpZyIsImVzcmlMYXllciIsIkltYWdlUmVjb3JkIiwiQXJjR0lTSW1hZ2VTZXJ2aWNlTGF5ZXIiLCJjcmVhdGVGZWF0dXJlUmVjb3JkQnVpbGRlciIsIkZlYXR1cmVSZWNvcmQiLCJjcmVhdGVEeW5hbWljUmVjb3JkQnVpbGRlciIsImNvbmZpZ0lzQ29tcGxldGUiLCJEeW5hbWljUmVjb3JkIiwiQXJjR0lTRHluYW1pY01hcFNlcnZpY2VMYXllciIsImNyZWF0ZVRpbGVSZWNvcmRCdWlsZGVyIiwiVGlsZVJlY29yZCIsIkFyY0dJU1RpbGVkTWFwU2VydmljZUxheWVyIiwiY3JlYXRlV21zUmVjb3JkQnVpbGRlciIsIldtc1JlY29yZCIsIldtc0xheWVyIiwidmFsaWRhdGVMYXRMb25nIiwiYXJyIiwiaW5kMSIsImluZDIiLCJpc05hTiIsIm1vZHVsZSIsImV4cG9ydHMiLCJsYXllckNsYXNzQnVuZGxlIiwiR3JhcGhpY3NMYXllciIsIlNjcmVlblBvaW50IiwiUXVlcnkiLCJUaWxlTGF5ZXIiLCJjcmVhdGVJbWFnZVJlY29yZCIsImNyZWF0ZVdtc1JlY29yZCIsImNyZWF0ZVRpbGVSZWNvcmQiLCJjcmVhdGVEeW5hbWljUmVjb3JkIiwiY3JlYXRlRmVhdHVyZVJlY29yZCIsIkxheWVyRHJhd2luZ09wdGlvbnMiLCJtYWtlQ3N2TGF5ZXIiLCJtYWtlU2hhcGVMYXllciIsInNlcnZlckxheWVySWRlbnRp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LFVBQXhCLEVBQW9DOEosTUFBcEMsQ0FoQmY7QUFpQkhrRixzQkFBY2xELG9CQUFvQjlMLFVBQXBCLEVBQWdDOEosTUFBaEMsQ0FqQlg7QUFrQkhtRix3QkFBZ0J2QyxzQkFBc0IxTSxVQUF0QixFQUFrQzhKLE1BQWxDLENBbEJiO0FBbUJIb0YsNkJBQXFCaEksMkJBQTJCbEgsVUFBM0IsQ0FuQmxCO0FBb0JIbVAseUJBQWlCekwsdUJBQXVCMUQsVUFBdkIsQ0FwQmQ7QUFxQkg4RixrQ0FyQkc7QUFzQkhSLHdCQXRCRztBQXVCSDdHLGdDQXZCRztBQXdCSHFQO0FBeEJHLEtBQVA7QUEwQkgsQ0E5QkQiLCJmaWxlIjoiNzQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG4vLyBUT0RPIGNvbnNpZGVyIHNwbGl0dGluZyB0aGlzIG1vZHVsZSBpbnRvIGRpZmZlcmVudCBtb2R1bGVzLiAgaW4gcGFydGljdWxhcixcclxuLy8gICAgICBmaWxlLWJhc2VkIHN0dWZmIHZzIHNlcnZlciBiYXNlZCBzdHVmZiwgYW5kIGxheWVyIGNyZWF0aW9uIHZzIGxheWVyIHN1cHBvcnRcclxuXHJcbi8vIFRPRE8gY29udmVydCBpbnRlcm5hbCBmdW5jdGlvbiBoZWFkZXIgY29tbWVudHMgdG8gSlNEb2MsIGFuZCB1c2UgdGhlIEBwcml2YXRlIHRhZ1xyXG5cclxuY29uc3QgY3N2Mmdlb2pzb24gPSByZXF1aXJlKCdjc3YyZ2VvanNvbicpO1xyXG5jb25zdCBUZXJyYWZvcm1lciA9IHJlcXVpcmUoJ3RlcnJhZm9ybWVyJyk7XHJcbmNvbnN0IHNocCA9IHJlcXVpcmUoJ3NocGpzJyk7XHJcbmNvbnN0IG9nYyA9IHJlcXVpcmUoJy4vbGF5ZXIvb2djLmpzJyk7XHJcbmNvbnN0IGJib3ggPSByZXF1aXJlKCcuL2xheWVyL2Jib3guanMnKTtcclxuY29uc3QgbGF5ZXJSZWNvcmQgPSByZXF1aXJlKCcuL2xheWVyL2xheWVyUmVjL21haW4uanMnKTtcclxuY29uc3QgZGVmYXVsdFJlbmRlcmVycyA9IHJlcXVpcmUoJy4vZGVmYXVsdFJlbmRlcmVycy5qc29uJyk7XHJcblRlcnJhZm9ybWVyLkFyY0dJUyA9IHJlcXVpcmUoJ3RlcnJhZm9ybWVyLWFyY2dpcy1wYXJzZXInKTtcclxuXHJcbi8qKlxyXG4qIE1hcHMgR2VvSlNPTiBnZW9tZXRyeSB0eXBlcyB0byBhIHNldCBvZiBkZWZhdWx0IHJlbmRlcnMgZGVmaW5lZCBpbiBHbG9iYWxTdG9yYWdlLkRlZmF1bHRSZW5kZXJzXHJcbiogQHByb3BlcnR5IGZlYXR1cmVUeXBlVG9SZW5kZXJlciB7T2JqZWN0fVxyXG4qIEBwcml2YXRlXHJcbiovXHJcbmNvbnN0IGZlYXR1cmVUeXBlVG9SZW5kZXJlciA9IHtcclxuICAgIFBvaW50OiAnY2lyY2xlUG9pbnQnLFxyXG4gICAgTXVsdGlQb2ludDogJ2NpcmNsZVBvaW50JyxcclxuICAgIExpbmVTdHJpbmc6ICdzb2xpZExpbmUnLFxyXG4gICAgTXVsdGlMaW5lU3RyaW5nOiAnc29saWRMaW5lJyxcclxuICAgIFBvbHlnb246ICdvdXRsaW5lZFBvbHknLFxyXG4gICAgTXVsdGlQb2x5Z29uOiAnb3V0bGluZWRQb2x5J1xyXG59O1xyXG5cclxuLyoqXHJcbiogRGlmZmVyZW50IHR5cGVzIG9mIHNlcnZpY2VzIHRoYXQgYSBVUkwgY291bGQgcG9pbnQgdG9cclxuKiBAcHJvcGVydHkgc2VydmljZVR5cGUge09iamVjdH1cclxuKi9cclxuY29uc3Qgc2VydmljZVR5cGUgPSB7XHJcbiAgICBDU1Y6ICdjc3YnLFxyXG4gICAgR2VvSlNPTjogJ2dlb2pzb24nLFxyXG4gICAgU2hhcGVmaWxlOiAnc2hhcGVmaWxlJyxcclxuICAgIEZlYXR1cmVMYXllcjogJ2ZlYXR1cmVsYXllcicsXHJcbiAgICBSYXN0ZXJMYXllcjogJ3Jhc3RlcmxheWVyJyxcclxuICAgIEdyb3VwTGF5ZXI6ICdncm91cGxheWVyJyxcclxuICAgIFRpbGVTZXJ2aWNlOiAndGlsZXNlcnZpY2UnLFxyXG4gICAgRmVhdHVyZVNlcnZpY2U6ICdmZWF0dXJlc2VydmljZScsXHJcbiAgICBEeW5hbWljU2VydmljZTogJ2R5bmFtaWNzZXJ2aWNlJyxcclxuICAgIEltYWdlU2VydmljZTogJ2ltYWdlc2VydmljZScsXHJcbiAgICBXTVM6ICd3bXMnLFxyXG4gICAgVW5rbm93bjogJ3Vua25vd24nLFxyXG4gICAgRXJyb3I6ICdlcnJvcidcclxufTtcclxuXHJcbi8vIGF0dGVtcHRzIHRvIGRldGVybWluZSBpZiBhIHBhdGggcG9pbnRzIHRvIGEgbG9jYXRpb24gb24gdGhlIGludGVybmV0LFxyXG4vLyBvciBpcyBhIGxvY2FsIGZpbGUuICBSZXR1cm5zIHRydWUgaWYgaW50ZXJuZXRpc2hcclxuZnVuY3Rpb24gaXNTZXJ2ZXJGaWxlKHVybCkge1xyXG4gICAgLy8gVE9ETyBwb3NzaWJseSBlbmhhbmNlIHRvIGJlIGJldHRlciBjaGVjaywgb3Igc3VwcG9ydCBtb3JlIGNhc2VzXHJcblxyXG4gICAgY29uc3QgbG93VXJsID0gdXJsLnRvTG93ZXJDYXNlKCk7XHJcbiAgICBjb25zdCB0ZXN0cyA9IFsvXmh0dHA6LywgL15odHRwczovLCAvXmZ0cDovLCAvXlxcL1xcLy9dO1xyXG4gICAgcmV0dXJuIHRlc3RzLnNvbWUodGVzdCA9PiBsb3dVcmwubWF0Y2godGVzdCkpO1xyXG5cclxufVxyXG5cclxuLy8gd2lsbCBncmFiIGEgZmlsZSBmcm9tIGEgc2VydmVyIGFkZHJlc3MgYXMgYmluYXJ5LlxyXG4vLyByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGZpbGUgZGF0YS5cclxuZnVuY3Rpb24gZ2V0U2VydmVyRmlsZSh1cmwsIGVzcmlCdW5kbGUpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgLy8gZXh0cmFjdCBpbmZvIGZvciB0aGlzIHNlcnZpY2VcclxuICAgICAgICBjb25zdCBkZWZTZXJ2aWNlID0gZXNyaUJ1bmRsZS5lc3JpUmVxdWVzdCh7XHJcbiAgICAgICAgICAgIHVybDogdXJsLFxyXG4gICAgICAgICAgICBoYW5kbGVBczogJ2FycmF5YnVmZmVyJ1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBkZWZTZXJ2aWNlLnRoZW4oc3J2UmVzdWx0ID0+IHtcclxuICAgICAgICAgICAgcmVzb2x2ZShzcnZSZXN1bHQpO1xyXG4gICAgICAgIH0sIGVycm9yID0+IHtcclxuICAgICAgICAgICAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcclxuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcblxyXG4vLyByZXR1cm5zIGEgc3RhbmRhcmQgaW5mb3JtYXRpb24gb2JqZWN0IHdpdGggc2VydmljZVR5cGVcclxuLy8gc3VwcG9ydHMgcHJlZGljdExheWVyVXJsXHJcbi8vIHR5cGUgaXMgc2VydmljZVR5cGUgZW51bSB2YWx1ZVxyXG5mdW5jdGlvbiBtYWtlSW5mbyh0eXBlKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHNlcnZpY2VUeXBlOiB0eXBlLFxyXG4gICAgICAgIGluZGV4OiAtMSxcclxuICAgICAgICB0aWxlU3VwcG9ydDogZmFsc2VcclxuICAgIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgc3RhbmRhcmQgaW5mb3JtYXRpb24gb2JqZWN0IHdpdGggaW5mbyBjb21tb24gZm9yIG1vc3QgRVNSSSBlbmRwb2ludHNcclxuICogLnNlcnZpY2VOYW1lXHJcbiAqIC5zZXJ2aWNlVHlwZVxyXG4gKiAudGlsZVN1cHBvcnRcclxuICogLnJvb3RVcmxcclxuICpcclxuICogQGZ1bmN0aW9uIG1ha2VMYXllckluZm9cclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgICAgc2VydmljZVR5cGUgZW51bSB2YWx1ZSBmb3IgbGF5ZXJcclxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgICAgcHJvcGVydHkgaW4ganNvbiBwYXJhbWV0ZXIgY29udGFpbmluZyBhIHNlcnZpY2UgbmFtZVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsICAgICB1cmwgd2UgYXJlIGludmVzdGlnYXRpbmdcclxuICogQHBhcmFtIHtPYmplY3R9IGpzb24gICAgZGF0YSByZXN1bHQgZnJvbSBzZXJ2aWNlIHdlIGludGVycm9nYXRlZFxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxyXG4gKi9cclxuZnVuY3Rpb24gbWFrZUxheWVySW5mbyh0eXBlLCBuYW1lLCB1cmwsIGpzb24pIHtcclxuICAgIGNvbnN0IGluZm8gPSBtYWtlSW5mbyh0eXBlKTtcclxuICAgIGluZm8uc2VydmljZU5hbWUgPSBqc29uW25hbWVdIHx8ICcnO1xyXG4gICAgaW5mby5yb290VXJsID0gdXJsO1xyXG4gICAgaWYgKHR5cGUgPT09IHNlcnZpY2VUeXBlLlRpbGVTZXJ2aWNlKSB7XHJcbiAgICAgICAgaW5mby50aWxlU3VwcG9ydCA9IHRydWU7XHJcbiAgICAgICAgaW5mby5zZXJ2aWNlVHlwZSA9IHNlcnZpY2VUeXBlLkR5bmFtaWNTZXJ2aWNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGluZm87XHJcbn1cclxuXHJcbi8vIHJldHVybnMgcHJvbWlzZSBvZiBzdGFuZGFyZCBpbmZvcm1hdGlvbiBvYmplY3Qgd2l0aCBzZXJ2aWNlVHlwZVxyXG4vLyBhbmQgZmlsZURhdGEgaWYgZmlsZSBpcyBsb2NhdGVkIG9ubGluZSAobm90IG9uIGRpc2spLlxyXG5mdW5jdGlvbiBtYWtlRmlsZUluZm8odHlwZSwgdXJsLCBlc3JpQnVuZGxlKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XHJcbiAgICAgICAgY29uc3QgaW5mbyA9IG1ha2VJbmZvKHR5cGUpO1xyXG4gICAgICAgIGlmICh1cmwgJiYgaXNTZXJ2ZXJGaWxlKHVybCkpIHtcclxuICAgICAgICAgICAgLy8gYmUgYSBwYWwgYW5kIGRvd25sb2FkIHRoZSBmaWxlIGNvbnRlbnRcclxuICAgICAgICAgICAgZ2V0U2VydmVyRmlsZSh1cmwsIGVzcmlCdW5kbGUpLnRoZW4oZGF0YSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpbmZvLmZpbGVEYXRhID0gZGF0YTtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoaW5mbyk7XHJcbiAgICAgICAgICAgIH0pLmNhdGNoKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGluZm8uc2VydmljZVR5cGUgPSBzZXJ2aWNlVHlwZS5FcnJvcjtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoaW5mbyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJlc29sdmUoaW5mbyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuXHJcbi8vIGluc3BlY3RzIHRoZSBKU09OIHRoYXQgd2FzIHJldHVybmVkIGZyb20gYSBzZXJ2aWNlLlxyXG4vLyBpZiB0aGUgSlNPTiBiZWxvbmdzIHRvIGFuIEVTUkkgZW5kcG9pbnQsIHdlIGRvIHNvbWUgdGVycmlibGUgZG9nLWxvZ2ljIHRvIGF0dGVtcHRcclxuLy8gdG8gZGVyaXZlIHdoYXQgdHlwZSBvZiBlbmRwb2ludCBpdCBpcyAobWFpbmx5IGJ5IGxvb2tpbmcgZm9yIHByb3BlcnRpZXMgdGhhdCBhcmVcclxuLy8gdW5pcXVlIHRvIHRoYXQgdHlwZSBvZiBzZXJ2aWNlKS5cclxuLy8gcmV0dXJucyBhbiBlbnVtZXJhdGlvbiB2YWx1ZSAoc3RyaW5nKSBmcm9tIHNlcnZpY2VUeXBlIGJhc2VkIG9uIHRoZSBtYXRjaCBmb3VuZC5cclxuLy8gbm9uLWVzcmkgc2VydmljZXMgb3IgdW5leHBlY3RlZCBlc3JpIHNlcnZpY2VzIHdpbGwgcmV0dXJuIHRoZSAuVW5rbm93biB2YWx1ZVxyXG5mdW5jdGlvbiBjcmF3bEVzcmlTZXJ2aWNlKHNydkpzb24pIHtcclxuICAgIGlmIChzcnZKc29uLnR5cGUpIHtcclxuICAgICAgICAvLyBhIGxheWVyIGVuZHBvaW50IChpLmUuIHVybCBlbmRzIHdpdGggaW50ZWdlciBpbmRleClcclxuICAgICAgICBjb25zdCBtYXBwZXIgPSB7XHJcbiAgICAgICAgICAgICdGZWF0dXJlIExheWVyJzogc2VydmljZVR5cGUuRmVhdHVyZUxheWVyLFxyXG4gICAgICAgICAgICAnUmFzdGVyIExheWVyJzogc2VydmljZVR5cGUuUmFzdGVyTGF5ZXIsXHJcbiAgICAgICAgICAgICdHcm91cCBMYXllcic6IHNlcnZpY2VUeXBlLkdyb3VwTGF5ZXJcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBtYXBwZXJbc3J2SnNvbi50eXBlXSB8fCBzZXJ2aWNlVHlwZS5Vbmtub3duO1xyXG5cclxuICAgIH0gZWxzZSBpZiAoc3J2SnNvbi5oYXNPd25Qcm9wZXJ0eSgnc2luZ2xlRnVzZWRNYXBDYWNoZScpKSB7XHJcbiAgICAgICAgaWYgKHNydkpzb24uc2luZ2xlRnVzZWRNYXBDYWNoZSkge1xyXG4gICAgICAgICAgICAvLyBhIHRpbGUgc2VydmVyXHJcbiAgICAgICAgICAgIHJldHVybiBzZXJ2aWNlVHlwZS5UaWxlU2VydmljZTtcclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gYSBtYXAgc2VydmVyXHJcbiAgICAgICAgICAgIHJldHVybiBzZXJ2aWNlVHlwZS5EeW5hbWljU2VydmljZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSBlbHNlIGlmIChzcnZKc29uLmhhc093blByb3BlcnR5KCdhbGxvd0dlb21ldHJ5VXBkYXRlcycpKSB7XHJcbiAgICAgICAgLy8gYSBmZWF0dXJlIHNlcnZlclxyXG4gICAgICAgIHJldHVybiBzZXJ2aWNlVHlwZS5GZWF0dXJlU2VydmljZTtcclxuXHJcbiAgICB9IGVsc2UgaWYgKHNydkpzb24uaGFzT3duUHJvcGVydHkoJ2FsbG93ZWRNb3NhaWNNZXRob2RzJykpIHtcclxuICAgICAgICAvLyBhbiBpbWFnZSBzZXJ2ZXJcclxuICAgICAgICByZXR1cm4gc2VydmljZVR5cGUuSW1hZ2VTZXJ2aWNlO1xyXG5cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHNlcnZpY2VUeXBlLlVua25vd247XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBoYW5kbGVzIHRoZSBzaXR1YXRpb24gd2hlcmUgb3VyIGZpcnN0IHBva2UgcmV2ZWFsZWQgYSBjaGlsZCBsYXllclxyXG4gKiAoaS5lLiBhbiBpbmRleGVkIGVuZHBvaW50IGluIGFuIGFyY2dpcyBzZXJ2ZXIpLiBXZSBuZWVkIHRvIGV4dHJhY3RcclxuICogc29tZSBleHRyYSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgc2VydmljZSBpdCByZXNpZGVzIGluICh0aGUgcm9vdCBzZXJ2aWNlKVxyXG4gKiBhbmQgYWRkIGl0IHRvIG91ciBpbmZvIHBhY2thZ2UuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgICAgICAgICAgdGhlIHVybCBvZiB0aGUgb3JpZ2luYWwgZW5kcG9pbnQgKGluY2x1ZGluZyB0aGUgaW5kZXgpXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBlc3JpQnVuZGxlICAgaGFzIEVTUkkgQVBJIG9iamVjdHNcclxuICogQHBhcmFtIHtPYmplY3R9IGNoaWxkSW5mbyAgICB0aGUgaW5mb3JtYXRpb24gd2UgaGF2ZSBnYXRoZXJlZCBvbiB0aGUgY2hpbGQgbGF5ZXIgZnJvbSB0aGUgZmlyc3QgcG9rZVxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gICAgICAgICAgIHJlc29sdmVzIHdpdGggaW5mb3JtYXRpb24gb2JqZWN0IGNvbnRhaW5pbmcgY2hpbGQgYW5kIHJvb3QgaW5mb3JtYXRpb25cclxuICovXHJcbmZ1bmN0aW9uIHJlcG9rZUVzcmlTZXJ2aWNlKHVybCwgZXNyaUJ1bmRsZSwgY2hpbGRJbmZvKSB7XHJcblxyXG4gICAgLy8gYnJlYWsgdXJsIGludG8gcm9vdCBhbmQgaW5kZXhcclxuICAgIGNvbnN0IHJlID0gL1xcLyhcXGQrKVxcLz8kLztcclxuICAgIGNvbnN0IG1hdGNoZXMgPSB1cmwubWF0Y2gocmUpO1xyXG4gICAgaWYgKCFtYXRjaGVzKSB7XHJcbiAgICAgICAgLy8gZ2l2ZSB1cCwgZG9udCBjcmFzaCB3aXRoIGVycm9yLlxyXG4gICAgICAgIGNvbnNvbGUud2FybignQ2Fubm90IGV4dHJhY3QgbGF5ZXIgaW5kZXggZnJvbSB1cmwgJyArIHVybCk7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjaGlsZEluZm8pO1xyXG4gICAgfVxyXG5cclxuICAgIGNoaWxkSW5mby5pbmRleCA9IHBhcnNlSW50KG1hdGNoZXNbMV0pO1xyXG4gICAgY2hpbGRJbmZvLnJvb3RVcmwgPSB1cmwuc3Vic3RyKDAsIHVybC5sZW5ndGggLSBtYXRjaGVzWzBdLmxlbmd0aCk7IC8vIHdpbGwgZHJvcCB0cmFpbGluZyBzbGFzaFxyXG5cclxuICAgIC8vIGluc3BlY3QgdGhlIHNlcnZlciByb290XHJcbiAgICByZXR1cm4gcG9rZUVzcmlTZXJ2aWNlKGNoaWxkSW5mby5yb290VXJsLCBlc3JpQnVuZGxlKS50aGVuKHJvb3RJbmZvID0+IHtcclxuICAgICAgICAvLyB0YWtlIHJlbGV2YW50IGluZm8gZnJvbSByb290LCBtYXNoIGl0IGludG8gb3VyIGNoaWxkIHBhY2thZ2VcclxuICAgICAgICBjaGlsZEluZm8udGlsZVN1cHBvcnQgPSByb290SW5mby50aWxlU3VwcG9ydDtcclxuICAgICAgICBjaGlsZEluZm8uc2VydmljZVR5cGUgPSByb290SW5mby5zZXJ2aWNlVHlwZTtcclxuICAgICAgICBjaGlsZEluZm8ubGF5ZXJzID0gcm9vdEluZm8ubGF5ZXJzO1xyXG4gICAgICAgIHJldHVybiBjaGlsZEluZm87XHJcbiAgICB9KTtcclxufVxyXG5cclxuLy8gZ2l2ZW4gYSBVUkwsIGF0dGVtcHQgdG8gcmVhZCBpdCBhcyBhbiBFU1JJIHJlc3QgZW5kcG9pbnQuXHJcbi8vIHJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb3ZsZXMgd2l0aCBhbiBpbmZvcm1hdGlvbiBvYmplY3QuXHJcbi8vIGF0IG1pbmltdW0sIHRoZSBvYmplY3Qgd2lsbCBoYXZlIGEgLnNlcnZpY2VUeXBlIHByb3BlcnR5IHdpdGggYSB2YWx1ZSBmcm9tIHRoZSBhYm92ZSBlbnVtZXJhdGlvbi5cclxuLy8gaWYgdGhlIHR5cGUgaXMgLlVua25vd24sIHRoZW4gd2Ugd2VyZSB1bmFibGUgdG8gZGV0ZXJtaW5lIHRoZSB1cmwgd2FzIGFuIEVTUkkgcmVzdCBlbmRwb2ludC5cclxuLy8gb3RoZXJ3aXNlLCB3ZSB3ZXJlIHN1Y2Nlc3NmdWwsIGFuZCB0aGUgaW5mb3JtYXRpb24gb2JqZWN0IHdpbGwgaGF2ZSBvdGhlciBwcm9wZXJ0aWVzIGRlcGVuZGluZyBvbiB0aGUgc2VydmljZSB0eXBlXHJcbi8vIC0gLm5hbWUgOiBzY3JhcGVkIGZyb20gc2VydmljZSwgYnV0IG1heSBiZSBydWJiaXNoIChkZXBlbmRzIG9uIHNlcnZpY2UgcHVibGlzaGVyKS4gdXNlZCBhcyBVSSBzdWdnZXN0aW9uIG9ubHlcclxuLy8gLSAuZmllbGRzIDogZm9yIGZlYXR1cmUgbGF5ZXIgc2VydmljZSBvbmx5LiBsaXN0IG9mIGZpZWxkcyB0byBhbGxvdyB1c2VyIHRvIHBpY2sgbmFtZSBmaWVsZFxyXG4vLyAtIC5nZW9tZXRyeVR5cGUgOiBmb3IgZmVhdHVyZSBsYXllciBzZXJ2aWNlIG9ubHkuICBmb3IgaGVscCBpbiBkZWZpbmluZyB0aGUgcmVuZGVyZXIsIGlmIHJlcXVpcmVkLlxyXG4vLyAtIC5sYXllcnMgOiBmb3IgZHluYW1pYyBsYXllciBzZXJ2aWNlIG9ubHkuIGxpc3RzIHRoZSBjaGlsZCBsYXllcnNcclxuZnVuY3Rpb24gcG9rZUVzcmlTZXJ2aWNlKHVybCwgZXNyaUJ1bmRsZSwgaGludCkge1xyXG5cclxuICAgIC8vIHJlYWN0aW9uIGZ1bmN0aW9ucyB0byBkaWZmZXJlbnQgZXNyaSBzZXJ2aWNlc1xyXG4gICAgY29uc3Qgc3J2SGFuZGxlciA9IHt9O1xyXG5cclxuICAgIHNydkhhbmRsZXJbc2VydmljZVR5cGUuRmVhdHVyZUxheWVyXSA9IHNydkpzb24gPT4ge1xyXG4gICAgICAgIGNvbnN0IGluZm8gPSBtYWtlTGF5ZXJJbmZvKHNlcnZpY2VUeXBlLkZlYXR1cmVMYXllciwgJ25hbWUnLCB1cmwsIHNydkpzb24pO1xyXG4gICAgICAgIGluZm8uZmllbGRzID0gc3J2SnNvbi5maWVsZHM7XHJcbiAgICAgICAgaW5mby5nZW9tZXRyeVR5cGUgPSBzcnZKc29uLmdlb21ldHJ5VHlwZTtcclxuICAgICAgICBpbmZvLnNtYXJ0RGVmYXVsdHMgPSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IHRyeSB0byBmaW5kIGEgbmFtZSBmaWVsZCBpZiBwb3NzaWJsZVxyXG4gICAgICAgICAgICBwcmltYXJ5OiBpbmZvLmZpZWxkc1swXS5uYW1lIC8vIHBpY2sgdGhlIGZpcnN0IGZpZWxkIGFzIHByaW1hcnkgYW5kIHJldHVybiBpdHMgbmFtZSBmb3IgdWkgYmluZGluZ1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgaW5mby5pbmRleFR5cGUgPSBzZXJ2aWNlVHlwZS5GZWF0dXJlTGF5ZXI7XHJcbiAgICAgICAgcmV0dXJuIHJlcG9rZUVzcmlTZXJ2aWNlKHVybCwgZXNyaUJ1bmRsZSwgaW5mbyk7XHJcbiAgICB9O1xyXG5cclxuICAgIHNydkhhbmRsZXJbc2VydmljZVR5cGUuUmFzdGVyTGF5ZXJdID0gc3J2SnNvbiA9PiB7XHJcbiAgICAgICAgY29uc3QgaW5mbyA9IG1ha2VMYXllckluZm8oc2VydmljZVR5cGUuUmFzdGVyTGF5ZXIsICduYW1lJywgdXJsLCBzcnZKc29uKTtcclxuICAgICAgICBpbmZvLmluZGV4VHlwZSA9IHNlcnZpY2VUeXBlLlJhc3RlckxheWVyO1xyXG4gICAgICAgIHJldHVybiByZXBva2VFc3JpU2VydmljZSh1cmwsIGVzcmlCdW5kbGUsIGluZm8pO1xyXG4gICAgfTtcclxuXHJcbiAgICBzcnZIYW5kbGVyW3NlcnZpY2VUeXBlLkdyb3VwTGF5ZXJdID0gc3J2SnNvbiA9PiB7XHJcbiAgICAgICAgY29uc3QgaW5mbyA9IG1ha2VMYXllckluZm8oc2VydmljZVR5cGUuR3JvdXBMYXllciwgJ25hbWUnLCB1cmwsIHNydkpzb24pO1xyXG4gICAgICAgIGluZm8uaW5kZXhUeXBlID0gc2VydmljZVR5cGUuR3JvdXBMYXllcjtcclxuICAgICAgICByZXR1cm4gcmVwb2tlRXNyaVNlcnZpY2UodXJsLCBlc3JpQnVuZGxlLCBpbmZvKTtcclxuICAgIH07XHJcblxyXG4gICAgc3J2SGFuZGxlcltzZXJ2aWNlVHlwZS5UaWxlU2VydmljZV0gPSBzcnZKc29uID0+IHtcclxuICAgICAgICBjb25zdCBpbmZvID0gbWFrZUxheWVySW5mbyhzZXJ2aWNlVHlwZS5UaWxlU2VydmljZSwgJ21hcE5hbWUnLCB1cmwsIHNydkpzb24pO1xyXG4gICAgICAgIGluZm8ubGF5ZXJzID0gc3J2SnNvbi5sYXllcnM7XHJcbiAgICAgICAgcmV0dXJuIGluZm87XHJcbiAgICB9O1xyXG5cclxuICAgIHNydkhhbmRsZXJbc2VydmljZVR5cGUuRHluYW1pY1NlcnZpY2VdID0gc3J2SnNvbiA9PiB7XHJcbiAgICAgICAgY29uc3QgaW5mbyA9IG1ha2VMYXllckluZm8oc2VydmljZVR5cGUuRHluYW1pY1NlcnZpY2UsICdtYXBOYW1lJywgdXJsLCBzcnZKc29uKTtcclxuICAgICAgICBpbmZvLmxheWVycyA9IHNydkpzb24ubGF5ZXJzO1xyXG4gICAgICAgIHJldHVybiBpbmZvO1xyXG4gICAgfTtcclxuXHJcbiAgICBzcnZIYW5kbGVyW3NlcnZpY2VUeXBlLkZlYXR1cmVTZXJ2aWNlXSA9IHNydkpzb24gPT4ge1xyXG4gICAgICAgIGNvbnN0IGluZm8gPSBtYWtlTGF5ZXJJbmZvKHNlcnZpY2VUeXBlLkZlYXR1cmVTZXJ2aWNlLCAnZGVzY3JpcHRpb24nLCB1cmwsIHNydkpzb24pO1xyXG4gICAgICAgIGluZm8ubGF5ZXJzID0gc3J2SnNvbi5sYXllcnM7XHJcbiAgICAgICAgcmV0dXJuIGluZm87XHJcbiAgICB9O1xyXG5cclxuICAgIHNydkhhbmRsZXJbc2VydmljZVR5cGUuSW1hZ2VTZXJ2aWNlXSA9IHNydkpzb24gPT4ge1xyXG4gICAgICAgIGNvbnN0IGluZm8gPSBtYWtlTGF5ZXJJbmZvKHNlcnZpY2VUeXBlLkltYWdlU2VydmljZSwgJ25hbWUnLCB1cmwsIHNydkpzb24pO1xyXG4gICAgICAgIGluZm8uZmllbGRzID0gc3J2SnNvbi5maWVsZHM7XHJcbiAgICAgICAgcmV0dXJuIGluZm87XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIGNvdWxkbnQgZmlndXJlIGl0IG91dFxyXG4gICAgc3J2SGFuZGxlcltzZXJ2aWNlVHlwZS5Vbmtub3duXSA9ICgpID0+IHtcclxuICAgICAgICByZXR1cm4gbWFrZUluZm8oc2VydmljZVR5cGUuVW5rbm93bik7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcclxuICAgICAgICAvLyBleHRyYWN0IGluZm8gZm9yIHRoaXMgc2VydmljZVxyXG4gICAgICAgIGNvbnN0IGRlZlNlcnZpY2UgPSBlc3JpQnVuZGxlLmVzcmlSZXF1ZXN0KHtcclxuICAgICAgICAgICAgdXJsOiB1cmwsXHJcbiAgICAgICAgICAgIGNvbnRlbnQ6IHsgZjogJ2pzb24nIH0sXHJcbiAgICAgICAgICAgIGNhbGxiYWNrUGFyYW1OYW1lOiAnY2FsbGJhY2snLFxyXG4gICAgICAgICAgICBoYW5kbGVBczogJ2pzb24nLFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBkZWZTZXJ2aWNlLnRoZW4oc3J2UmVzdWx0ID0+IHtcclxuICAgICAgICAgICAgLy8gcmVxdWVzdCBkaWRudCBmYWlsLCBpbmRpY2F0aW5nIGl0IGlzIGxpa2VseSBhbiBBcmNHSVMgU2VydmVyIGVuZHBvaW50XHJcbiAgICAgICAgICAgIGxldCByZXN1bHRUeXBlID0gY3Jhd2xFc3JpU2VydmljZShzcnZSZXN1bHQpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGhpbnQgJiYgcmVzdWx0VHlwZSAhPT0gaGludCkge1xyXG4gICAgICAgICAgICAgICAgLy8gb3VyIGhpbnQgZG9lc24ndCBtYXRjaCB0aGUgc2VydmljZVxyXG4gICAgICAgICAgICAgICAgcmVzdWx0VHlwZSA9IHNlcnZpY2VUeXBlLlVua25vd247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzb2x2ZShzcnZIYW5kbGVyW3Jlc3VsdFR5cGVdKHNydlJlc3VsdCkpO1xyXG5cclxuICAgICAgICB9LCAoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nLCBidXQgdGhhdCBkb2VzbnQgbWVhbiBvdXIgc2VydmljZSBpcyBpbnZhbGlkIHlldFxyXG4gICAgICAgICAgICAvLyBpdCdzIGxpa2VseSBub3QgRVNSSS4gIHJldHVybiBFcnJvciBhbmQgbGV0IG1haW4gcHJlZGljdG9yIGtlZXAgaW52ZXN0aWdhdGluZ1xyXG4gICAgICAgICAgICByZXNvbHZlKG1ha2VJbmZvKHNlcnZpY2VUeXBlLkVycm9yKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuLy8gdGVzdHMgYSBVUkwgdG8gc2VlIGlmIHRoZSB2YWx1ZSBpcyBhIGZpbGVcclxuLy8gcHJvdmlkaW5nIHRoZSBrbm93biB0eXBlIGFzIGEgaGludCB3aWxsIGNhdXNlIHRoZSBmdW5jdGlvbiB0byBydW4gdGhlXHJcbi8vIHNwZWNpZmljIGxvZ2ljIGZvciB0aGF0IGZpbGUgdHlwZSwgcmF0aGVyIHRoYW4gZ3Vlc3NpbmcgYW5kIHRyeWluZyBldmVyeXRoaW5nXHJcbi8vIHJlc29sdmVzIHdpdGggcHJvbWlzZSBvZiBpbmZvcm1hdGlvbiBvYmplY3RcclxuLy8gLSBzZXJ2aWNlVHlwZSA6IHRoZSB0eXBlIG9mIGZpbGUgKENTViwgU2hhcGUsIEdlb0pTT04sIFVua25vd24pXHJcbi8vIC0gZmlsZURhdGEgOiBpZiB0aGUgZmlsZSBpcyBsb2NhdGVkIG9uIGEgc2VydmVyLCB3aWxsIHhoclxyXG5mdW5jdGlvbiBwb2tlRmlsZSh1cmwsIGVzcmlCdW5kbGUsIGhpbnQpIHtcclxuXHJcbiAgICAvLyByZWFjdGlvbiBmdW5jdGlvbnMgdG8gZGlmZmVyZW50IGZpbGVzXHJcbiAgICAvLyBvdmVya2lsbCByaWdodCBub3csIGFzIGZpbGVzIGp1c3QgaWRlbnRpZnkgdGhlIHR5cGUgcmlnaHQgbm93XHJcbiAgICAvLyBidXQgc3RydWN0dXJlIHdpbGwgbGV0IHVzIGVuaGFuY2UgZm9yIGN1c3RvbSB0aGluZ3MgaWYgd2UgbmVlZCB0b1xyXG4gICAgY29uc3QgZmlsZUhhbmRsZXIgPSB7fTtcclxuXHJcbiAgICAvLyBjc3ZcclxuICAgIGZpbGVIYW5kbGVyW3NlcnZpY2VUeXBlLkNTVl0gPSAoKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIG1ha2VGaWxlSW5mbyhzZXJ2aWNlVHlwZS5DU1YsIHVybCwgZXNyaUJ1bmRsZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIGdlb2pzb25cclxuICAgIGZpbGVIYW5kbGVyW3NlcnZpY2VUeXBlLkdlb0pTT05dID0gKCkgPT4ge1xyXG4gICAgICAgIHJldHVybiBtYWtlRmlsZUluZm8oc2VydmljZVR5cGUuR2VvSlNPTiwgdXJsLCBlc3JpQnVuZGxlKTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gY3N2XHJcbiAgICBmaWxlSGFuZGxlcltzZXJ2aWNlVHlwZS5TaGFwZWZpbGVdID0gKCkgPT4ge1xyXG4gICAgICAgIHJldHVybiBtYWtlRmlsZUluZm8oc2VydmljZVR5cGUuU2hhcGVmaWxlLCB1cmwsIGVzcmlCdW5kbGUpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBjb3VsZG50IGZpZ3VyZSBpdCBvdXRcclxuICAgIGZpbGVIYW5kbGVyW3NlcnZpY2VUeXBlLlVua25vd25dID0gKCkgPT4ge1xyXG4gICAgICAgIC8vIGRvbnQgc3VwcGx5IHVybCwgYXMgd2UgZG9uJ3Qgd2FudCB0byBkb3dubG9hZCByYW5kb20gZmlsZXNcclxuICAgICAgICByZXR1cm4gbWFrZUZpbGVJbmZvKHNlcnZpY2VUeXBlLlVua25vd24pO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XHJcbiAgICAgICAgaWYgKGhpbnQpIHtcclxuICAgICAgICAgICAgLy8gZm9yY2UgdGhlIGRhdGEgZXh0cmFjdGlvbiBvZiB0aGUgaGludGVkIGZvcm1hdFxyXG4gICAgICAgICAgICByZXNvbHZlKGZpbGVIYW5kbGVyW2hpbnRdKCkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGluc3BlY3QgdGhlIHVybCBmb3IgZmlsZSBleHRlbnNpb25zXHJcbiAgICAgICAgICAgIGxldCBndWVzc1R5cGUgPSBzZXJ2aWNlVHlwZS5Vbmtub3duO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHVybC5zdWJzdHIodXJsLmxhc3RJbmRleE9mKCcuJykgKyAxKS50b0xvd2VyQ2FzZSgpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGZpbGUgZXh0ZW5zaW9uc1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnY3N2JzpcclxuICAgICAgICAgICAgICAgICAgICBndWVzc1R5cGUgPSBzZXJ2aWNlVHlwZS5DU1Y7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICd6aXAnOlxyXG4gICAgICAgICAgICAgICAgICAgIGd1ZXNzVHlwZSA9IHNlcnZpY2VUeXBlLlNoYXBlZmlsZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICdqc29uJzpcclxuICAgICAgICAgICAgICAgICAgICBndWVzc1R5cGUgPSBzZXJ2aWNlVHlwZS5HZW9KU09OO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc29sdmUoZmlsZUhhbmRsZXJbZ3Vlc3NUeXBlXSgpKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG5cclxuLy8gdGVzdHMgYSBVUkwgdG8gc2VlIGlmIHRoZSB2YWx1ZSBpcyBhIHdtc1xyXG4vLyByZXNvbHZlcyB3aXRoIHByb21pc2Ugb2YgaW5mb3JtYXRpb24gb2JqZWN0XHJcbi8vIC0gc2VydmljZVR5cGUgOiB0aGUgdHlwZSBvZiBzZXJ2aWNlIChXTVMsIFVua25vd24pXHJcbmZ1bmN0aW9uIHBva2VXbXModXJsLCBlc3JpQnVuZGxlKSB7XHJcblxyXG4gICAgLy8gRklYTUUgYWRkIHNvbWUgV01TIGRldGVjdGlvbiBsb2dpYy4gIHRoYXQgd291bGQgYmUgbmljZVxyXG5cclxuICAgIGNvbnNvbGUubG9nKHVybCwgZXNyaUJ1bmRsZSk7IC8vIHRvIHN0b3AganNsaW50IGZyb20gcXVhY2tpbmcuIHJlbW92ZSB3aGVuIHBhcmFtcyBhcmUgYWN0dWFsbHkgdXNlZFxyXG5cclxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWFrZUluZm8oc2VydmljZVR5cGUuV01TKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHByZWRpY3RMYXllclVybEJ1aWxkZXIoZXNyaUJ1bmRsZSkge1xyXG4gICAgLyoqXHJcbiAgICAqIEF0dGVtcHRzIHRvIGRldGVybWluZSB3aGF0IGtpbmQgb2YgbGF5ZXIgdGhlIFVSTCBtb3N0IGxpa2VseSBpcywgYW5kXHJcbiAgICAqIGlmIHBvc3NpYmxlLCByZXR1cm4gYmFjayBzb21lIHVzZWZ1bCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgbGF5ZXJcclxuICAgICpcclxuICAgICogLSBzZXJ2aWNlVHlwZTogdGhlIHR5cGUgb2YgbGF5ZXIgdGhlIGZ1bmN0aW9uIHRoaW5rcyB0aGUgdXJsIGlzIHJlZmVycmluZyB0by4gaXMgYSB2YWx1ZSBvZiBzZXJ2aWNlVHlwZSBlbnVtZXJhdGlvbiAoc3RyaW5nKVxyXG4gICAgKiAtIGZpbGVEYXRhOiBmaWxlIGNvbnRlbnRzIGluIGFuIGFycmF5IGJ1ZmZlci4gb25seSBwcmVzZW50IGlmIHRoZSBVUkwgcG9pbnRzIHRvIGEgZmlsZSB0aGF0IGV4aXN0cyBvbiBhbiBpbnRlcm5ldCBzZXJ2ZXIgKGkuZS4gbm90IGEgbG9jYWwgZGlzayBkcml2ZSlcclxuICAgICogLSBuYW1lOiBiZXN0IGF0dGVtcHQgYXQgZ3Vlc3NpbmcgdGhlIG5hbWUgb2YgdGhlIHNlcnZpY2UgKHN0cmluZykuIG9ubHkgcHJlc2VudCBmb3IgRVNSSSBzZXJ2aWNlIFVSTHNcclxuICAgICogLSBmaWVsZHM6IGFycmF5IG9mIGZpZWxkIGRlZmluaXRpb25zIGZvciB0aGUgbGF5ZXIuIGNvbmZvcm1zIHRvIEVTUkkncyBSRVNUIGZpZWxkIHN0YW5kYXJkLiBvbmx5IHByZXNlbnQgZm9yIGZlYXR1cmUgbGF5ZXIgYW5kIGltYWdlIHNlcnZpY2UgVVJMcy5cclxuICAgICogLSBnZW9tZXRyeVR5cGU6IGRlc2NyaWJlcyB0aGUgZ2VvbWV0cnkgb2YgdGhlIGxheWVyIChzdHJpbmcpLiBjb25mb3JtcyB0byBFU1JJJ3MgUkVTVCBnZW9tZXRyeSB0eXBlIGVudW0gdmFsdWVzLiBvbmx5IHByZXNlbnQgZm9yIGZlYXR1cmUgbGF5ZXIgVVJMcy5cclxuICAgICogLSBncm91cElkeDogcHJvcGVydHkgb25seSBhdmFpbGFibGUgaWYgYSBncm91cCBsYXllciBpcyBxdWVyaWVkLiBpdCBpcyB0aGUgbGF5ZXIgaW5kZXggb2YgdGhlIGdyb3VwIGxheWVyIGluIHRoZSBsaXN0IHVuZGVyIGl0cyBwYXJlbnQgZHluYW1pYyBsYXllclxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIHByZWRpY3RMYXllclVybFxyXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIGEgdXJsIHRvIHNvbWV0aGluZyB0aGF0IGlzIGhvcGVmdWxseSBhIG1hcCBzZXJ2aWNlXHJcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSBoaW50IG9wdGlvbmFsLiBhbGxvd3MgdGhlIGNhbGxlciB0byBzcGVjaWZ5IHRoZSB1cmwgdHlwZSwgZm9yY2luZyB0aGUgZnVuY3Rpb24gdG8gcnVuIHRoZSBkYXRhIGxvZ2ljIGZvciB0aGF0IHR5cGVcclxuICAgICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSByZXNvbHZpbmcgd2l0aCBhbiBpbmZvbWF0aW9uIG9iamVjdFxyXG4gICAgKi9cclxuICAgIHJldHVybiAodXJsLCBoaW50KSA9PiB7XHJcblxyXG4gICAgICAgIC8vIFRPRE8gdGhpcyBmdW5jdGlvbiBoYXMgbG90cyBvZiByb29tIHRvIGltcHJvdmUuICB0aGVyZSBhcmUgbWFueSB2YWxpZCB1cmxzIHRoYXQgaXQgd2lsbFxyXG4gICAgICAgIC8vICAgICAgZmFpbCB0byBpZGVudGlmeSBjb3JyZWN0bHkgaW4gaXQncyBjdXJyZW50IHN0YXRlXHJcblxyXG4gICAgICAgIC8vIFRPRE8gcmVmYWN0b3IgaG93IHRoaXMgZnVuY3Rpb24gd29ya3MuXHJcbiAgICAgICAgLy8gICAgICB3YWl0IGZvciB0aGUgd2ViIHNlcnZpY2UgcmVxdWVzdCBsaWJyYXJ5IHRvIG5vdCBiZSBlc3JpL3JlcXVlc3RcclxuICAgICAgICAvLyAgICAgIHVzZSBuZXcgbGlicmFyeSB0byBtYWtlIGEgaGVhZCBjYWxsIG9uIHRoZSB1cmwgcHJvdmlkZWRcclxuICAgICAgICAvLyAgICAgIGV4YW1pbmUgdGhlIGNvbnRlbnQgdHlwZSBvZiB0aGUgaGVhZCBjYWxsIHJlc3VsdFxyXG4gICAgICAgIC8vICAgICAgICBpZiB4bWwsIGFzc3VtZSBXTVNcclxuICAgICAgICAvLyAgICAgICAgaWYganNvbiwgYXNzdW1lIGVzcmkgIChtYXkgbmVlZCBleHRyYSBsb2dpYyB0byBkaWZmZXJlbnRpYXRlIGZyb20ganNvbiBmaWxlPylcclxuICAgICAgICAvLyAgICAgICAgZmlsZSBjYXNlIGlzIGV4cGxpY2l0IChlLmcgdGV4dC9qc29uKVxyXG4gICAgICAgIC8vICAgICAgdGhlbiBoaXQgYXBwcm9wcmlhdGUgaGFuZGxlciwgZG8gYSBzZWNvbmQgd2ViIHJlcXVlc3QgZm9yIGNvbnRlbnQgaWYgcmVxdWlyZWRcclxuXHJcbiAgICAgICAgaWYgKGhpbnQpIHtcclxuICAgICAgICAgICAgLy8gZ28gZGlyZWN0bHkgdG8gYXBwcm9wcmlhdGUgbG9naWMgYmxvY2tcclxuICAgICAgICAgICAgY29uc3QgaGludFRvRmxhdm91ciA9IHt9OyAvLyB3aHk/IGN1eiBjeWNsb21hdGljIGNvbXBsZXhpdHkgKyBPQkVZIFJVTEVTXHJcbiAgICAgICAgICAgIGNvbnN0IGZsYXZvdXJUb0hhbmRsZXIgPSB7fTtcclxuXHJcbiAgICAgICAgICAgIC8vIGhpbnQgdHlwZSB0byBoaW50IGZsYXZvdXJcclxuICAgICAgICAgICAgaGludFRvRmxhdm91cltzZXJ2aWNlVHlwZS5DU1ZdID0gJ0ZfRklMRSc7XHJcbiAgICAgICAgICAgIGhpbnRUb0ZsYXZvdXJbc2VydmljZVR5cGUuR2VvSlNPTl0gPSAnRl9GSUxFJztcclxuICAgICAgICAgICAgaGludFRvRmxhdm91cltzZXJ2aWNlVHlwZS5TaGFwZWZpbGVdID0gJ0ZfRklMRSc7XHJcbiAgICAgICAgICAgIGhpbnRUb0ZsYXZvdXJbc2VydmljZVR5cGUuRmVhdHVyZUxheWVyXSA9ICdGX0VTUkknO1xyXG4gICAgICAgICAgICBoaW50VG9GbGF2b3VyW3NlcnZpY2VUeXBlLlJhc3RlckxheWVyXSA9ICdGX0VTUkknO1xyXG4gICAgICAgICAgICBoaW50VG9GbGF2b3VyW3NlcnZpY2VUeXBlLkdyb3VwTGF5ZXJdID0gJ0ZfRVNSSSc7XHJcbiAgICAgICAgICAgIGhpbnRUb0ZsYXZvdXJbc2VydmljZVR5cGUuVGlsZVNlcnZpY2VdID0gJ0ZfRVNSSSc7XHJcbiAgICAgICAgICAgIGhpbnRUb0ZsYXZvdXJbc2VydmljZVR5cGUuRHluYW1pY1NlcnZpY2VdID0gJ0ZfRVNSSSc7XHJcbiAgICAgICAgICAgIGhpbnRUb0ZsYXZvdXJbc2VydmljZVR5cGUuSW1hZ2VTZXJ2aWNlXSA9ICdGX0VTUkknO1xyXG4gICAgICAgICAgICBoaW50VG9GbGF2b3VyW3NlcnZpY2VUeXBlLldNU10gPSAnRl9XTVMnO1xyXG5cclxuICAgICAgICAgICAgLy8gaGludCBmbGF2b3VyIHRvIGZsYXZvdXItaGFuZGxlclxyXG4gICAgICAgICAgICBmbGF2b3VyVG9IYW5kbGVyLkZfRklMRSA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwb2tlRmlsZSh1cmwsIGVzcmlCdW5kbGUsIGhpbnQpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgZmxhdm91clRvSGFuZGxlci5GX0VTUkkgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9rZUVzcmlTZXJ2aWNlKHVybCwgZXNyaUJ1bmRsZSwgaGludCk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBmbGF2b3VyVG9IYW5kbGVyLkZfV01TID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gRklYTUUgUkVBTCBMT0dJQyBDT01JTkcgU09PTlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBva2VXbXModXJsLCBlc3JpQnVuZGxlKTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8vIGV4ZWN1dGUgaGFuZGxlci4gIGhpbnQgLT4gZmxhdm91ciAtPiBoYW5kbGVyIC0+IHJ1biBpdCAtPiBwcm9taXNlXHJcbiAgICAgICAgICAgIHJldHVybiBmbGF2b3VyVG9IYW5kbGVyW2hpbnRUb0ZsYXZvdXJbaGludF1dKCk7XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAvLyBUT0RPIHJlc3RydWN0dXJlLiAgdGhpcyBhcHByb2FjaCBjbGVhbnMgdXAgdGhlIHB5cmFtaWQgb2YgZG9vbS5cclxuICAgICAgICAgICAgLy8gICAgICBOZWVkcyB0byBhZGQgY2hlY2sgZm9yIGVtcHR5IHRlc3RzLCByZXNvbHZlIGFzIHVua25vd24uXHJcbiAgICAgICAgICAgIC8vICAgICAgU3RpbGwgYSBwb3RlbnRpYWwgdG8gdGFrZSBhZHZhbnRhZ2Ugb2YgdGhlIG5pY2Ugc3RydWN0dXJlLiAgV2lsbCBkZXBlbmRcclxuICAgICAgICAgICAgLy8gICAgICB3aGF0IGNvbWVzIGZpcnN0OiAgV01TIGxvZ2ljIChhZGRpbmcgYSAzcmQgdGVzdCksIG9yIGNoYW5naW5nIHRoZSByZXF1ZXN0XHJcbiAgICAgICAgICAgIC8vICAgICAgbGlicmFyeSwgbWVhbmluZyB3ZSBnZXQgdGhlIHR5cGUgZWFybHkgZnJvbSB0aGUgaGVhZCByZXF1ZXN0LlxyXG4gICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICB0ZXN0cyA9IFtwb2tlRmlsZSwgcG9rZVNlcnZpY2VdO1xyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gcnVuVGVzdHMoKSB7XHJcbiAgICAgICAgICAgICAgICB0ZXN0ID0gdGVzdHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICB0ZXN0KHVybCwgZXNyaUJ1bmRsZSkudGhlbihpbmZvID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5mby5zZXJ2aWNlVHlwZSAhPT0gc2VydmljZVR5cGUuVW5rbm93bikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGluZm8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJ1blRlc3RzKCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcnVuVGVzdHMoKTtcclxuICAgICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIG5vIGhpbnQuIHJ1biB0ZXN0cyB1bnRpbCB3ZSBmaW5kIGEgbWF0Y2guXHJcbiAgICAgICAgICAgICAgICAvLyB0ZXN0IGZvciBmaWxlXHJcbiAgICAgICAgICAgICAgICBwb2tlRmlsZSh1cmwsIGVzcmlCdW5kbGUpLnRoZW4oaW5mb0ZpbGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmZvRmlsZS5zZXJ2aWNlVHlwZSA9PT0gc2VydmljZVR5cGUuVW5rbm93biB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmZvRmlsZS5zZXJ2aWNlVHlwZSA9PT0gc2VydmljZVR5cGUuRXJyb3IpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdCBhIGZpbGUsIHRlc3QgZm9yIEVTUklcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9rZUVzcmlTZXJ2aWNlKHVybCwgZXNyaUJ1bmRsZSkudGhlbihpbmZvRXNyaSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5mb0Vzcmkuc2VydmljZVR5cGUgPT09IHNlcnZpY2VUeXBlLlVua25vd24gfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZvRXNyaS5zZXJ2aWNlVHlwZSA9PT0gc2VydmljZVR5cGUuRXJyb3IpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRklYTUUgUkVBTCBMT0dJQyBDT01JTkcgU09PTlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBva2VXTVNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGluZm9Fc3JpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQgd2FzIGEgZXNyaSBzZXJ2aWNlLiByZWpvaWNlLlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzaG9ydGxpdmVkIHJlam9pY2UgYmVjYXVzZSBncm91cGVkIGxheWVycyBsdWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5mb0Vzcmkuc2VydmljZVR5cGUgPT09IHNlcnZpY2VUeXBlLkdyb3VwTGF5ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFzdFNsYXNoID0gdXJsLmxhc3RJbmRleE9mKCcvJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxheWVySWR4ID0gcGFyc2VJbnQodXJsLnN1YnN0cmluZyhsYXN0U2xhc2ggKyAxKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IHVybC5zdWJzdHJpbmcoMCwgbGFzdFNsYXNoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9rZUVzcmlTZXJ2aWNlKHVybCwgZXNyaUJ1bmRsZSkudGhlbihpbmZvRHluYW1pYyA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZvRHluYW1pYy5ncm91cElkeCA9IGxheWVySWR4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShpbmZvRHluYW1pYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoaW5mb0VzcmkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQgd2FzIGEgZmlsZS4gcmVqb2ljZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShpbmZvRmlsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuXHJcbi8qKlxyXG4qIENvbnZlcnRzIGFuIGFycmF5IGJ1ZmZlciB0byBhIHN0cmluZ1xyXG4qXHJcbiogQG1ldGhvZCBhcnJheUJ1ZmZlclRvU3RyaW5nXHJcbiogQHByaXZhdGVcclxuKiBAcGFyYW0ge0FycmF5YnVmZmVyfSBidWZmZXIgYW4gYXJyYXkgYnVmZmVyIGNvbnRhaW5pbmcgc3R1ZmYgKGlkZWFsbHkgc3RyaW5nLWZyaWVuZGx5KVxyXG4qIEByZXR1cm5zIHtTdHJpbmd9IGFycmF5IGJ1ZmZlciBpbiBzdHJpbmcgZm9ybVxyXG4qL1xyXG5mdW5jdGlvbiBhcnJheUJ1ZmZlclRvU3RyaW5nKGJ1ZmZlcikge1xyXG4gICAgLy8gaGFuZGxlcyBVVEY4IGVuY29kaW5nXHJcbiAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCd1dGYtOCcpLmRlY29kZShuZXcgVWludDhBcnJheShidWZmZXIpKTtcclxufVxyXG5cclxuLyoqXHJcbiogUGVyZm9ybXMgdmFsaWRhdGlvbiBvbiBHZW9Kc29uIG9iamVjdC4gUmV0dXJucyBhIHByb21pc2UgcmVzb2x2aW5nIHdpdGggdGhlIHZhbGlkYXRpb24gb2JqZWN0LlxyXG4qIFdvcmtlciBmdW5jdGlvbiBmb3IgdmFsaWRhdGVGaWxlLCBzZWUgdGhhdCBmaWxlIGZvciByZXR1cm4gdmFsdWUgc3BlY3NcclxuKlxyXG4qIEBtZXRob2QgdmFsaWRhdGVHZW9Kc29uXHJcbiogQHByaXZhdGVcclxuKiBAcGFyYW0ge09iamVjdH0gZ2VvSnNvbiBmZWF0dXJlIGNvbGxlY3Rpb24gaW4gZ2VvanNvbiBmb3JtXHJcbiogQHJldHVybnMge1Byb21pc2V9IHByb21pc2UgcmVzb2x2aW5nIHdpdGggaW5mb3JtYXRpb24gb24gdGhlIGdlb0pzb24gb2JqZWN0XHJcbiovXHJcbmZ1bmN0aW9uIHZhbGlkYXRlR2VvSnNvbihnZW9Kc29uKSB7XHJcbiAgICAvLyBHZW9KU09OIGdlb21ldHJ5IHR5cGUgdG8gRVNSSSBnZW9tZXRyeSB0eXBlXHJcbiAgICBjb25zdCBnZW9tTWFwID0ge1xyXG4gICAgICAgIFBvaW50OiAnZXNyaUdlb21ldHJ5UG9pbnQnLFxyXG4gICAgICAgIE11bHRpUG9pbnQ6ICdlc3JpR2VvbWV0cnlNdWx0aXBvaW50JyxcclxuICAgICAgICBMaW5lU3RyaW5nOiAnZXNyaUdlb21ldHJ5UG9seWxpbmUnLFxyXG4gICAgICAgIE11bHRpTGluZVN0cmluZzogJ2VzcmlHZW9tZXRyeVBvbHlsaW5lJyxcclxuICAgICAgICBQb2x5Z29uOiAnZXNyaUdlb21ldHJ5UG9seWdvbicsXHJcbiAgICAgICAgTXVsdGlQb2x5Z29uOiAnZXNyaUdlb21ldHJ5UG9seWdvbidcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgZmllbGRzID0gZXh0cmFjdEZpZWxkcyhnZW9Kc29uKTtcclxuXHJcbiAgICBjb25zdCByZXMgPSB7XHJcbiAgICAgICAgZmllbGRzOiBmaWVsZHMsXHJcbiAgICAgICAgZ2VvbWV0cnlUeXBlOiBnZW9tTWFwW2dlb0pzb24uZmVhdHVyZXNbMF0uZ2VvbWV0cnkudHlwZV0sXHJcbiAgICAgICAgZm9ybWF0dGVkRGF0YTogZ2VvSnNvbixcclxuICAgICAgICBzbWFydERlZmF1bHRzOiB7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IHRyeSB0byBmaW5kIGEgbmFtZSBmaWVsZCBpZiBwb3NzaWJsZVxyXG4gICAgICAgICAgICBwcmltYXJ5OiBmaWVsZHNbMF0ubmFtZSAvLyBwaWNrIHRoZSBmaXJzdCBmaWVsZCBhcyBwcmltYXJ5IGFuZCByZXR1cm4gaXRzIG5hbWUgZm9yIHVpIGJpbmRpbmdcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGlmICghcmVzLmdlb21ldHJ5VHlwZSkge1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgZ2VvbWV0cnkgdHlwZSBpbiBHZW9KU09OJykpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRPRE8gb3B0aW9uYWwgY2hlY2s6IGl0ZXJhdGUgdGhyb3VnaCBldmVyeSBmZWF0dXJlLCBlbnN1cmUgZ2VvbWV0cnkgdHlwZSBhbmQgcHJvcGVydGllcyBhcmUgYWxsIGlkZW50aWNhbFxyXG5cclxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzKTtcclxufVxyXG5cclxuLyoqXHJcbiogUGVyZm9ybXMgdmFsaWRhdGlvbiBvbiBjc3YgZGF0YS4gUmV0dXJucyBhIHByb21pc2UgcmVzb2x2aW5nIHdpdGggdGhlIHZhbGlkYXRpb24gb2JqZWN0LlxyXG4qIFdvcmtlciBmdW5jdGlvbiBmb3IgdmFsaWRhdGVGaWxlLCBzZWUgdGhhdCBmaWxlIGZvciByZXR1cm4gdmFsdWUgc3BlY3NcclxuKlxyXG4qIEBtZXRob2QgdmFsaWRhdGVDU1ZcclxuKiBAcHJpdmF0ZVxyXG4qIEBwYXJhbSB7T2JqZWN0fSBkYXRhIGNzdiBkYXRhIGFzIHN0cmluZ1xyXG4qIEByZXR1cm5zIHtQcm9taXNlfSBwcm9taXNlIHJlc29sdmluZyB3aXRoIGluZm9ybWF0aW9uIG9uIHRoZSBjc3YgZGF0YVxyXG4qL1xyXG5mdW5jdGlvbiB2YWxpZGF0ZUNTVihkYXRhKSB7XHJcblxyXG4gICAgY29uc3QgZm9ybWF0dGVkRGF0YSA9IGFycmF5QnVmZmVyVG9TdHJpbmcoZGF0YSk7IC8vIGNvbnZlcnQgZnJvbSBhcnJheWJ1ZmZlciB0byBzdHJpbmcgdG8gcGFyc2VkIGNzdi4gc3RvcmUgc3RyaW5nIGZvcm1hdCBmb3IgbGF0ZXJcclxuICAgIGNvbnN0IHJvd3MgPSBjc3ZQZWVrKGZvcm1hdHRlZERhdGEsICcsJyk7IC8vIEZJWE1FOiB0aGlzIGFzc3VtZXMgZGVsaW1pdGVyIGlzIGEgYCxgOyBuZWVkIHZhbGlkYXRpb25cclxuICAgIGxldCBlcnJvck1lc3NhZ2U7IC8vIGVycm9yIG1lc3NhZ2UgaWYgYW55IHRvIHJldHVyblxyXG5cclxuICAgIC8vIHZhbGlkYXRpb25zXHJcbiAgICBpZiAocm93cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAvLyBmYWlsLCBubyByb3dzXHJcbiAgICAgICAgZXJyb3JNZXNzYWdlID0gJ0ZpbGUgaGFzIG5vIHJvd3MnO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBmaWVsZCBjb3VudCBvZiBmaXJzdCByb3cuXHJcbiAgICAgICAgY29uc3QgZmMgPSByb3dzWzBdLmxlbmd0aDtcclxuICAgICAgICBpZiAoZmMgPCAyKSB7XHJcbiAgICAgICAgICAgIC8vIGZhaWwgbm90IGVub3VnaCBjb2x1bW5zXHJcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9ICdGaWxlIGhhcyBsZXNzIHRoYW4gdHdvIGNvbHVtbnMnO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGNoZWNrIGZpZWxkIGNvdW50cyBvZiBlYWNoIHJvd1xyXG4gICAgICAgICAgICBpZiAocm93cy5ldmVyeShyb3dBcnIgPT4gcm93QXJyLmxlbmd0aCA9PT0gZmMpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlZERhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgc21hcnREZWZhdWx0czogZ3Vlc3NDU1ZmaWVsZHMocm93cyksIC8vIGNhbGN1bGF0ZSBzbWFydCBkZWZhdWx0c1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIGZpZWxkIGxpc3QgZXNyaS1pc2ggZm9yIGNvbnNpc3RhbmN5XHJcbiAgICAgICAgICAgICAgICAgICAgZmllbGRzOiByb3dzWzBdLm1hcChmaWVsZCA9PiAoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBmaWVsZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2VzcmlGaWVsZFR5cGVTdHJpbmcnXHJcbiAgICAgICAgICAgICAgICAgICAgfSkpLFxyXG4gICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5VHlwZTogJ2VzcmlHZW9tZXRyeVBvaW50JyAvLyBhbHdheXMgcG9pbnQgZm9yIENTVlxyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlcyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSAnRmlsZSBoYXMgaW5jb25zaXN0ZW50IGNvbHVtbiBjb3VudHMnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKSk7XHJcbn1cclxuXHJcbi8qKlxyXG4qIFZhbGlkYXRlcyBmaWxlIGNvbnRlbnQuICBEb2VzIHNvbWUgYmFzaWMgY2hlY2tpbmcgZm9yIGVycm9ycy4gQXR0ZW1wdHMgdG8gZ2V0IGZpZWxkIGxpc3QsIGFuZFxyXG4qIGlmIHBvc3NpYmxlLCBwcm92aWRlIHRoZSBmaWxlIGluIGEgbW9yZSB1c2VmdWwgZm9ybWF0LiBQcm9taXNlIHJlamVjdGlvbiBpbmRpY2F0ZXMgZmFpbGVkIHZhbGlkYXRpb25cclxuKlxyXG4qIC0gZm9ybWF0dGVkRGF0YTogZmlsZSBjb250ZW50cyBpbiBhIG1vcmUgdXNlZnVsIGZvcm1hdC4gSlNPTiBmb3IgR2VvSlNPTiBhbmQgU2hhcGVmaWxlLiBTdHJpbmcgZm9yIENTVlxyXG4qIC0gZmllbGRzOiBhcnJheSBvZiBmaWVsZCBkZWZpbml0aW9ucyBmb3IgdGhlIGZpbGUuIGNvbmZvcm1zIHRvIEVTUkkncyBSRVNUIGZpZWxkIHN0YW5kYXJkLlxyXG4qIC0gZ2VvbWV0cnlUeXBlOiBkZXNjcmliZXMgdGhlIGdlb21ldHJ5IG9mIHRoZSBmaWxlIChzdHJpbmcpLiBjb25mb3JtcyB0byBFU1JJJ3MgUkVTVCBnZW9tZXRyeSB0eXBlIGVudW0gdmFsdWVzLlxyXG4qXHJcbiogQG1ldGhvZCB2YWxpZGF0ZUZpbGVcclxuKiBAcGFyYW0ge1N0cmluZ30gdHlwZSB0aGUgZm9ybWF0IG9mIGZpbGUuIGFsaWducyB0byBzZXJ2aWNlVHlwZSBlbnVtIChDU1YsIFNoYXBlZmlsZSwgR2VvSlNPTilcclxuKiBAcGFyYW0ge0FycmF5YnVmZmVyfSBkYXRhIHRoZSBmaWxlIGNvbnRlbnQgaW4gYmluYXJ5XHJcbiogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSByZXNvbHZpbmcgd2l0aCBhbiBpbmZvbWF0aW9uIG9iamVjdFxyXG4qL1xyXG5mdW5jdGlvbiB2YWxpZGF0ZUZpbGUodHlwZSwgZGF0YSkge1xyXG5cclxuICAgIGNvbnN0IGZpbGVIYW5kbGVyID0geyAvLyBtYXBzIGhhbmRsZXJzIGZvciBkaWZmZXJlbnQgZmlsZSB0eXBlc1xyXG4gICAgICAgIFtzZXJ2aWNlVHlwZS5DU1ZdOiBkYXRhID0+IHZhbGlkYXRlQ1NWKGRhdGEpLFxyXG5cclxuICAgICAgICBbc2VydmljZVR5cGUuR2VvSlNPTl06IGRhdGEgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBnZW9Kc29uID0gSlNPTi5wYXJzZShhcnJheUJ1ZmZlclRvU3RyaW5nKGRhdGEpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlR2VvSnNvbihnZW9Kc29uKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvLyBjb252ZXJ0IGZyb20gYXJyYXlidWZmZXIgKGNvbnRhaW5pbmcgemlwcGVkIHNoYXBlZmlsZSkgdG8ganNvbiAodXNpbmcgc2hwIGxpYnJhcnkpXHJcbiAgICAgICAgW3NlcnZpY2VUeXBlLlNoYXBlZmlsZV06IGRhdGEgPT5cclxuICAgICAgICAgICAgc2hwKGRhdGEpLnRoZW4oZ2VvSnNvbiA9PlxyXG4gICAgICAgICAgICAgICAgdmFsaWRhdGVHZW9Kc29uKGdlb0pzb24pKVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyB0cmlnZ2VyIG9mZiB0aGUgYXBwcm9wcmlhdGUgaGFuZGxlciwgcmV0dXJuIHByb21pc2VcclxuICAgIHJldHVybiBmaWxlSGFuZGxlclt0eXBlXShkYXRhKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEZyb20gcHJvdmlkZWQgQ1NWIGRhdGEsIGd1ZXNzZXMgd2hpY2ggY29sdW1ucyBhcmUgbG9uZyBhbmQgbGF0LiBJZiBndWVzc2luZyBpcyBubyBzdWNjZXNzZnVsLCByZXR1cm5zIG51bGwgZm9yIG9uZSBvciBib3RoIGZpZWxkcy5cclxuICpcclxuICogQG1ldGhvZCBndWVzc0NTVmZpZWxkc1xyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0gIHtBcnJheX0gcm93cyBjc3YgZGF0YVxyXG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgYW4gb2JqZWN0IHdpdGggbGF0IGFuZCBsb25nIHN0cmluZyBwcm9wZXJ0aWVzIGluZGljYXRpbmcgY29ycmVzcG9uZGluZyBmaWVsZCBuYW1lc1xyXG4gKi9cclxuZnVuY3Rpb24gZ3Vlc3NDU1ZmaWVsZHMocm93cykge1xyXG4gICAgLy8gbWFnaWMgcmVnZXhlc1xyXG4gICAgLy8gVE9ETzogaW4gY2FzZSBvZiBwZXJmb3JtYW5jZSBpc3N1ZXMgd2l0aCBydW5uaW5nIHJlZ2V4ZXMgb24gbGFyZ2UgY3N2IGZpbGVzLCBsaW1pdCB0bywgc2F5LCB0aGUgZmlyc3QgaHVuZHJlZCByb3dzXHJcbiAgICAvLyBUT0RPOiBleHBsYWluIHJlZ2V4ZXNcclxuICAgIGNvbnN0IGxhdFZhbHVlUmVnZXggPSBuZXcgUmVnRXhwKC9eWy0rXT8oWzEtOF0/XFxkKFxcLlxcZCspP3w5MChcXC4wKyk/KSQvKTsgLy8gZmlsdGVycyBieSBmaWVsZCB2YWx1ZVxyXG4gICAgY29uc3QgbG9uZ1ZhbHVlUmVnZXggPSBuZXcgUmVnRXhwKC9eWy0rXT8oMTgwKFxcLjArKT98KCgxWzAtN11cXGQpfChbMS05XT9cXGQpKShcXC5cXGQrKT8pJC8pO1xyXG4gICAgY29uc3QgbGF0TmFtZVJlZ2V4ID0gbmV3IFJlZ0V4cCgvXi4qKHl8bGEpLiokL2kpOyAvLyBmaWx0ZXJzIGJ5IGZpZWxkIG5hbWVcclxuICAgIGNvbnN0IGxvbmdOYW1lUmVnZXggPSBuZXcgUmVnRXhwKC9eLiooeHxsbykuKiQvaSk7XHJcblxyXG4gICAgY29uc3QgbGF0Q2FuZGlkYXRlcyA9IGZpbmRDYW5kaWRhdGVzKHJvd3MsIGxhdFZhbHVlUmVnZXgsIGxhdE5hbWVSZWdleCk7IC8vIGZpbHRlciBvdXQgYWxsIGNvbHVtbnMgdGhhdCBhcmUgbm90IGxhdCBiYXNlZCBvbiByb3cgdmFsdWVzXHJcbiAgICBjb25zdCBsb25nQ2FuZGlkYXRlcyA9IGZpbmRDYW5kaWRhdGVzKHJvd3MsIGxvbmdWYWx1ZVJlZ2V4LCBsb25nTmFtZVJlZ2V4KTsgLy8gZmlsdGVyIG91dCBhbGwgY29sdW1ucyB0aGF0IGFyZSBub3QgbG9uZyBiYXNlZCBvbiByb3cgdmFsdWVzXHJcblxyXG4gICAgLy8gY29uc29sZS5sb2cobGF0Q2FuZGlkYXRlcyk7XHJcbiAgICAvLyBjb25zb2xlLmxvZyhsb25nQ2FuZGlkYXRlcyk7XHJcblxyXG4gICAgLy8gcGljayB0aGUgZmlyc3QgbGF0IGd1ZXNzIG9yIG51bGxcclxuICAgIGNvbnN0IGxhdCA9IGxhdENhbmRpZGF0ZXNbMF0gfHwgbnVsbDtcclxuXHJcbiAgICAvLyBwaWNrIHRoZSBmaXJzdCBsb25nIGd1ZXNzIG9yIG51bGxcclxuICAgIGNvbnN0IGxvbmcgPSBsb25nQ2FuZGlkYXRlcy5maW5kKGZpZWxkID0+IGZpZWxkICE9PSBsYXQpIHx8IG51bGw7XHJcblxyXG4gICAgLy8gZm9yIHByaW1hcnkgZmllbGQsIHBpY2sgdGhlIGZpcnN0IG9uIHRoYXQgaXMgbm90IGxhdCBvciBsb25nIGZpZWxkIG9yIG51bGxcclxuICAgIGNvbnN0IHByaW1hcnkgPSByb3dzWzBdLmZpbmQoZmllbGQgPT4gZmllbGQgIT09IGxhdCAmJiBmaWVsZCAhPT0gbG9uZykgfHwgbnVsbDtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGxhdCxcclxuICAgICAgICBsb25nLFxyXG4gICAgICAgIHByaW1hcnlcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gZmluZENhbmRpZGF0ZXMocm93cywgdmFsdWVSZWdleCwgbmFtZVJlZ2V4KSB7XHJcbiAgICAgICAgY29uc3QgZmllbGRzID0gcm93c1swXTsgLy8gZmlyc3Qgcm93IG11c3QgYmUgaGVhZGVyc1xyXG5cclxuICAgICAgICBjb25zdCBjYW5kaWRhdGVzID1cclxuICAgICAgICAgICAgZmllbGRzLmZpbHRlcigoZmllbGQsIGluZGV4KSA9PlxyXG4gICAgICAgICAgICAgICAgcm93cy5ldmVyeSgocm93LCByb3dJbmRleCkgPT5cclxuICAgICAgICAgICAgICAgICAgICByb3dJbmRleCA9PT0gMCB8fCB2YWx1ZVJlZ2V4LnRlc3Qocm93W2luZGV4XSkpKSAvLyBza2lwIGZpcnN0IHJvdyBhcyBpdHMganVzdCBoZWFkZXJzXHJcbiAgICAgICAgICAgIC5maWx0ZXIoZmllbGQgPT4gbmFtZVJlZ2V4LnRlc3QoZmllbGQpKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZXM7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNlcnZlckxheWVySWRlbnRpZnlCdWlsZGVyKGVzcmlCdW5kbGUpIHtcclxuICAgIC8vIFRPRE8gd2UgYXJlIHVzaW5nIGxheWVySWRzIG9wdGlvbiBwcm9wZXJ0eSBhcyBpdCBhbGlnbnMgd2l0aCB3aGF0IHRoZSBFU1JJIGlkZW50aWZ5IHBhcmFtZXRlclxyXG4gICAgLy8gICAgICBvYmplY3QgdXNlcy4gIEhvd2V2ZXIsIGluIHIyIHRlcm1pbm9sb2d5LCBhIGxheWVySWQgaXMgc3BlY2lmaWMgdG8gYSBmdWxsIG1hcCBsYXllciwgbm90XHJcbiAgICAvLyAgICAgIGluZGV4ZXMgb2YgYSBzaW5nbGUgZHluYW1pYyBsYXllci4gIGZvciBjbGFyaXR5LCBjb3VsZCBjb25zaWRlciByZW5hbWluZyB0byAudmlzaWJsZUxheWVyc1xyXG4gICAgLy8gICAgICBhbmQgdGhlbiBtYXAgdGhlIHZhbHVlIHRvIHRoZSAubGF5ZXJJZHMgcHJvcGVydHkgaW5zaWRlIHRoaXMgZnVuY3Rpb24uXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFBlcmZvcm0gYSBzZXJ2ZXItc2lkZSBpZGVudGlmeSBvbiBhIGxheWVyICh1c3VhbGx5IGFuIEVTUkkgZHluYW1pYyBsYXllcilcclxuICAgICogQWNjZXB0cyB0aGUgZm9sbG93aW5nIG9wdGlvbnM6XHJcbiAgICAqICAgLSBnZW9tZXRyeTogUmVxdWlyZWQuIGdlb21ldHJ5IGluIG1hcCBjby1vcmRpbmF0ZXMgZm9yIHRoZSBhcmVhIHRvIGlkZW50aWZ5LlxyXG4gICAgKiAgICAgd2lsbCB1c3VhbGx5IGJlIGFuIEVTUkkgUG9pbnQsIHRob3VnaCBhIHBvbHlnb24gd291bGQgd29yay5cclxuICAgICogICAtIG1hcEV4dGVudDogUmVxdWlyZWQuIEVTUkkgRXh0ZW50IG9mIHRoZSBjdXJyZW50IG1hcCB2aWV3XHJcbiAgICAqICAgLSB3aWR0aDogUmVxdWlyZWQuIFdpZHRoIG9mIHRoZSBtYXAgaW4gcGl4ZWxzXHJcbiAgICAqICAgLSBoZWlnaHQ6IFJlcXVpcmVkLiBIZWlnaHQgb2YgdGhlIG1hcCBpbiBwaXhlbHNcclxuICAgICogICAtIGxheWVySWRzOiBhbiBhcnJheSBvZiBpbnRlZ2VycyBzcGVjaWZ5aW5nIHRoZSBsYXllciBpbmRleGVzIHRvIGJlIGV4YW1pbmVkLiBXaWxsIG92ZXJyaWRlIHRoZSBjdXJyZW50XHJcbiAgICAqICAgICB2aXNpYmxlIGluZGV4ZXMgaW4gdGhlIGxheWVyIHBhcmFtZXRlclxyXG4gICAgKiAgIC0gcmV0dXJuR2VvbWV0cnk6IGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIHJlc3VsdCBnZW9tZXRlcnkgc2hvdWxkIGJlIHJldHVybmVkIHdpdGggcmVzdWx0cy4gIERlZmF1bHRzIHRvIGZhbHNlXHJcbiAgICAqICAgLSB0b2xlcmFuY2U6IGFuIGludGVnZXIgaW5kaWNhdGluZyBob3cgbWFueSBzY3JlZW4gcGl4ZWxzIGF3YXkgZnJvbSB0aGUgbW91c2UgaXMgdmFsaWQgZm9yIGEgaGl0LiAgRGVmYXVsdHMgdG8gNVxyXG4gICAgKlxyXG4gICAgKiBAbWV0aG9kIHNlcnZlckxheWVySWRlbnRpZnlcclxuICAgICogQHBhcmFtIHtPYmplY3R9IGxheWVyIGFuIEVTUkkgZHluYW1pYyBsYXllciBvYmplY3RcclxuICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgQW4gb2JqZWN0IGZvciBzdXBwbHlpbmcgYWRkaXRpb25hbCBwYXJhbWV0ZXJzXHJcbiAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UgcmVzb2x2aW5nIHdpdGggYW4gYXJyYXkgb2YgaWRlbnRpZnkgcmVzdWx0cyAoZW1wdHkgYXJyYXkgaWYgbm8gaGl0cylcclxuICAgICovXHJcbiAgICByZXR1cm4gKGxheWVyLCBvcHRzKSA9PiB7XHJcblxyXG4gICAgICAgIGNvbnN0IGlkZW50UGFyYW1zID0gbmV3IGVzcmlCdW5kbGUuSWRlbnRpZnlQYXJhbWV0ZXJzKCk7XHJcblxyXG4gICAgICAgIC8vIHBsdWNrIHRyZWF0cyBmcm9tIG9wdGlvbnMgcGFyYW1ldGVyXHJcbiAgICAgICAgaWYgKG9wdHMpIHtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHJlcU9wdHMgPSBbJ2dlb21ldHJ5JywgJ21hcEV4dGVudCcsICdoZWlnaHQnLCAnd2lkdGgnXTtcclxuICAgICAgICAgICAgcmVxT3B0cy5mb3JFYWNoKG9wdFByb3AgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wdHNbb3B0UHJvcF0pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZGVudFBhcmFtc1tvcHRQcm9wXSA9IG9wdHNbb3B0UHJvcF07XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgc2VydmVyTGF5ZXJJZGVudGlmeSAtIG1pc3Npbmcgb3B0cy4keyBvcHRQcm9wIH0gYXJndWVtZW50YCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgaWRlbnRQYXJhbXMubGF5ZXJJZHMgPSBvcHRzLmxheWVySWRzIHx8IGxheWVyLnZpc2libGVMYXllcnM7XHJcbiAgICAgICAgICAgIGlkZW50UGFyYW1zLnJldHVybkdlb21ldHJ5ID0gb3B0cy5yZXR1cm5HZW9tZXRyeSB8fCBmYWxzZTtcclxuICAgICAgICAgICAgaWRlbnRQYXJhbXMubGF5ZXJPcHRpb24gPSBlc3JpQnVuZGxlLklkZW50aWZ5UGFyYW1ldGVycy5MQVlFUl9PUFRJT05fQUxMO1xyXG4gICAgICAgICAgICBpZGVudFBhcmFtcy5zcGF0aWFsUmVmZXJlbmNlID0gb3B0cy5nZW9tZXRyeS5zcGF0aWFsUmVmZXJlbmNlO1xyXG4gICAgICAgICAgICBpZGVudFBhcmFtcy50b2xlcmFuY2UgPSBvcHRzLnRvbGVyYW5jZSB8fCA1O1xyXG5cclxuICAgICAgICAgICAgLy8gVE9ETyBhZGQgc3VwcG9ydCBmb3IgaWRlbnRQYXJhbXMubGF5ZXJEZWZpbml0aW9ucyBvbmNlIGF0dHJpYnV0ZSBmaWx0ZXJpbmcgaXMgaW1wbGVtZW50ZWRcclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZXJ2ZXJMYXllcklkZW50aWZ5IC0gbWlzc2luZyBvcHRzIGFyZ3VlbWVudCcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gYXN5bmNoIGFuIGlkZW50aWZ5IHRhc2tcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBpZGVudGlmeSA9IG5ldyBlc3JpQnVuZGxlLklkZW50aWZ5VGFzayhsYXllci51cmwpO1xyXG5cclxuICAgICAgICAgICAgLy8gVE9ETyBwb3NzaWJseSB0YWNrIG9uIHRoZSBsYXllci5pZCB0byB0aGUgcmVzb2x2ZWQgdGhpbmcgc28gd2Uga25vdyB3aGljaCBwYXJlbnQgbGF5ZXIgcmV0dXJuZWQ/XHJcbiAgICAgICAgICAgIC8vICAgICAgd291bGQgb25seSBiZSByZXF1aXJlZCBpZiB0aGUgY2FsbGVyIGlzIG1hc2hpbmcgcHJvbWlzZXMgdG9nZXRoZXIgYW5kIHVzaW5nIFByb21pc2UuYWxsKClcclxuXHJcbiAgICAgICAgICAgIGlkZW50aWZ5Lm9uKCdjb21wbGV0ZScsIHJlc3VsdCA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdC5yZXN1bHRzKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlkZW50aWZ5Lm9uKCdlcnJvcicsIGVyciA9PiB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyLmVycm9yKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpZGVudGlmeS5leGVjdXRlKGlkZW50UGFyYW1zKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbn1cclxuXHJcbi8qKlxyXG4qIFBlcmZvcm1zIGluIHBsYWNlIGFzc2lnbm1lbnQgb2YgaW50ZWdlciBpZHMgZm9yIGEgR2VvSlNPTiBGZWF0dXJlQ29sbGVjdGlvbi5cclxuKiBJZiBhdCBsZWFzdCBvbmUgZmVhdHVyZSBoYXMgYW4gZXhpc3RpbmcgaWQgb3V0c2lkZSB0aGUgZ2VvSnNvbiBwcm9wZXJ0aWVzIHNlY3Rpb24sXHJcbiogdGhlIG9yaWdpbmFsIGlkIHZhbHVlIGlzIGNvcGllZCBpbiBhIG5ld2x5IGNyZWF0ZWQgcHJvcGVydHkgSURfRklMRSBvZiB0aGUgcHJvcGVydGllcyBvYmplY3RcclxuKiBhbmQgdGhlIGV4aXN0aW5nIGlkIHZhbHVlIGlzIHJlcGxhY2VkIGJ5IGFuIGF1dG9nZW5lcmF0ZWQgbnVtYmVyLlxyXG4qIEZlYXR1cmVzIHdpdGhvdXQgZXhpc3RpbmcgaWQgZnJvbSB0aGF0IHNhbWUgZGF0YXNldCB3aWxsIGdldCBhIG5ldyBwcm9wZXJ0aWVzIElEX0ZJTEVcclxuKiB3aXRoIGFuIGVtcHR5IHN0cmluZyBhcyB2YWx1ZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuKiBJZiBhdCBsZWFzdCBvbmUgZmVhdHVyZSBoYXMgYW4gZXhpc3RpbmcgT0JKRUNUSUQgaW5zaWRlIHRoZSBnZW9Kc29uIHByb3BlcnRpZXMgc2VjdGlvbixcclxuKiB0aGUgb3JpZ2luYWwgT0JKRUNUSUQgdmFsdWUgaXMgY29waWVkIGluIGEgbmV3bHkgY3JlYXRlZCBwcm9wZXJ0eSBPQkpFQ1RJRF9GSUxFIG9mIHRoZSBwcm9wZXJ0aWVzIG9iamVjdFxyXG4qIGFuZCB0aGUgZXhpc3RpbmcgT0JKRUNUSUQgdmFsdWUgaXMgcmVwbGFjZWQgYnkgYW4gYXV0b2dlbmVyYXRlZCBudW1iZXIuXHJcbiogRmVhdHVyZXMgd2l0aG91dCBleGlzdGluZyBPQkpFQ1RJRCBmcm9tIHRoYXQgc2FtZSBkYXRhc2V0IHdpbGwgZ2V0IGEgbmV3IHByb3BlcnRpZXMgT0JKRUNUSURfRklMRVxyXG4qIHdpdGggYW4gZW1wdHkgc3RyaW5nIGFzIHZhbHVlLlxyXG4qL1xyXG5mdW5jdGlvbiBhc3NpZ25JZHMoZ2VvSnNvbikge1xyXG4gICAgaWYgKGdlb0pzb24udHlwZSAhPT0gJ0ZlYXR1cmVDb2xsZWN0aW9uJykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQXNzaWdubWVudCBjYW4gb25seSBiZSBwZXJmb3JtZWQgb24gRmVhdHVyZUNvbGxlY3Rpb25zJyk7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGVtcHR5SUQgPSB0cnVlO1xyXG4gICAgbGV0IGVtcHR5T2JqSUQgPSB0cnVlO1xyXG5cclxuICAgIC8vIGZvciBldmVyeSBmZWF0dXJlLCBpZiBpdCBkb2VzIG5vdCBoYXZlIGFuIGlkIHByb3BlcnR5LCBhZGQgaXQuXHJcbiAgICAvLyAwIGlzIG5vdCBhIHZhbGlkIG9iamVjdCBpZFxyXG4gICAgZ2VvSnNvbi5mZWF0dXJlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWwsIGlkeCkge1xyXG4gICAgICAgIE9iamVjdC5hc3NpZ24odmFsLnByb3BlcnRpZXMsIHsgSURfRklMRTogJycsIE9CSkVDVElEX0ZJTEU6ICcnIH0pO1xyXG5cclxuICAgICAgICAvLyB0byBhdm9pZCBkb3VibGUgSUQgY29sdW1ucyBvdXRzaWRlIHByb3BlcnRpZXNcclxuICAgICAgICBpZiAoJ2lkJyBpbiB2YWwgJiYgdHlwZW9mIHZhbC5pZCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgdmFsLnByb3BlcnRpZXMuSURfRklMRSA9IHZhbC5pZDtcclxuICAgICAgICAgICAgZW1wdHlJRCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gdG8gYXZvaWQgZG91YmxlIE9CSkVDVElEIGNvbHVtbnMuIFVzZWZ1bCBmb3IgYm90aCBnZW9qc29uIGFuZCBDU1YgZmlsZS5cclxuICAgICAgICBpZiAoJ09CSkVDVElEJyBpbiB2YWwucHJvcGVydGllcykge1xyXG4gICAgICAgICAgICB2YWwucHJvcGVydGllcy5PQkpFQ1RJRF9GSUxFID0gdmFsLnByb3BlcnRpZXMuT0JKRUNUSUQ7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB2YWwucHJvcGVydGllcy5PQkpFQ1RJRDtcclxuICAgICAgICAgICAgZW1wdHlPYmpJRCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFsLmlkID0gaWR4ICsgMTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIHJlbW92ZSBJRF9GSUxFIGlmIGFsbCBlbXB0eVxyXG4gICAgaWYgKGVtcHR5SUQpIHtcclxuICAgICAgICBnZW9Kc29uLmZlYXR1cmVzLmZvckVhY2goZnVuY3Rpb24gKHZhbCkge1xyXG4gICAgICAgICAgICBkZWxldGUgdmFsLnByb3BlcnRpZXMuSURfRklMRTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyByZW1vdmUgT0JKRUNUSURfRklMRSBpZiBhbGwgZW1wdHlcclxuICAgIGlmIChlbXB0eU9iaklEKSB7XHJcbiAgICAgICAgZ2VvSnNvbi5mZWF0dXJlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWwpIHtcclxuICAgICAgICAgICAgZGVsZXRlIHZhbC5wcm9wZXJ0aWVzLk9CSkVDVElEX0ZJTEU7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFeHRyYWN0cyBmaWVsZHMgZnJvbSB0aGUgZmlyc3QgZmVhdHVyZSBpbiB0aGUgZmVhdHVyZSBjb2xsZWN0aW9uLCBkb2VzIG5vXHJcbiAqIGd1ZXNzd29yayBvbiBwcm9wZXJ0eSB0eXBlcyBhbmQgY2FsbHMgZXZlcnl0aGluZyBhIHN0cmluZy5cclxuICovXHJcbmZ1bmN0aW9uIGV4dHJhY3RGaWVsZHMoZ2VvSnNvbikge1xyXG4gICAgaWYgKGdlb0pzb24uZmVhdHVyZXMubGVuZ3RoIDwgMSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmllbGQgZXh0cmFjdGlvbiByZXF1aXJlcyBhdCBsZWFzdCBvbmUgZmVhdHVyZScpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBPYmplY3Qua2V5cyhnZW9Kc29uLmZlYXR1cmVzWzBdLnByb3BlcnRpZXMpLm1hcChmdW5jdGlvbiAocHJvcCkge1xyXG4gICAgICAgIHJldHVybiB7IG5hbWU6IHByb3AsIHR5cGU6ICdlc3JpRmllbGRUeXBlU3RyaW5nJyB9O1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBNYWtlcyBhbiBhdHRlbXB0IHRvIGxvYWQgYW5kIHJlZ2lzdGVyIGEgcHJvamVjdGlvbiBkZWZpbml0aW9uLlxyXG4gKiBSZXR1cm5zIHByb21pc2UgcmVzb2x2aW5nIHdoZW4gcHJvY2VzcyBpcyBjb21wbGV0ZVxyXG4gKiBwcm9qTW9kdWxlIC0gcHJvaiBtb2R1bGUgZnJvbSBnZW9BcGlcclxuICogcHJvakNvZGUgLSB0aGUgc3RyaW5nIG9yIGludCBlcHNnIGNvZGUgd2Ugd2FudCB0byBsb29rdXBcclxuICogZXBzZ0xvb2t1cCAtIGZ1bmN0aW9uIHRoYXQgd2lsbCBkbyB0aGUgZXBzZyBsb29rdXAsIHRha2luZyBjb2RlIGFuZCByZXR1cm5pbmcgcHJvbWlzZSBvZiByZXN1bHQgb3IgbnVsbFxyXG4gKi9cclxuZnVuY3Rpb24gcHJvamVjdGlvbkxvb2t1cChwcm9qTW9kdWxlLCBwcm9qQ29kZSwgZXBzZ0xvb2t1cCkge1xyXG4gICAgLy8gbG9vayB1cCBwcm9qZWN0aW9uIGRlZmluaXRpb25zIGlmIGl0J3Mgbm90IGFscmVhZHkgbG9hZGVkIGFuZCB3ZSBoYXZlIGVub3VnaCBpbmZvXHJcbiAgICBpZiAoIXByb2pNb2R1bGUuZ2V0UHJvamVjdGlvbihwcm9qQ29kZSkgJiYgZXBzZ0xvb2t1cCAmJiBwcm9qQ29kZSkge1xyXG4gICAgICAgIHJldHVybiBlcHNnTG9va3VwKHByb2pDb2RlKS50aGVuKHByb2pEZWYgPT4ge1xyXG4gICAgICAgICAgICBpZiAocHJvakRlZikge1xyXG4gICAgICAgICAgICAgICAgLy8gcmVnaXN0ZXIgcHJvamVjdGlvblxyXG4gICAgICAgICAgICAgICAgcHJvak1vZHVsZS5hZGRQcm9qZWN0aW9uKHByb2pDb2RlLCBwcm9qRGVmKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcHJvakRlZjtcclxuICAgICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gbWFrZUdlb0pzb25MYXllckJ1aWxkZXIoZXNyaUJ1bmRsZSwgZ2VvQXBpKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIENvbnZlcnRzIGEgR2VvSlNPTiBvYmplY3QgaW50byBhIEZlYXR1cmVMYXllci4gIEV4cGVjdHMgR2VvSlNPTiB0byBiZSBmb3JtZWQgYXMgYSBGZWF0dXJlQ29sbGVjdGlvblxyXG4gICAgKiBjb250YWluaW5nIGEgdW5pZm9ybSBmZWF0dXJlIHR5cGUgKEZlYXR1cmVMYXllciB0eXBlIHdpbGwgYmUgc2V0IGFjY29yZGluZyB0byB0aGUgdHlwZSBvZiB0aGUgZmlyc3RcclxuICAgICogZmVhdHVyZSBlbnRyeSkuICBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgb3B0aW9uczpcclxuICAgICogICAtIHRhcmdldFdraWQ6IFJlcXVpcmVkLiBhbiBpbnRlZ2VyIGZvciBhbiBFU1JJIHdraWQgdG8gcHJvamVjdCBnZW9tZXRyaWVzIHRvXHJcbiAgICAqICAgLSByZW5kZXJlcjogYSBzdHJpbmcgaWRlbnRpZnlpbmcgb25lIG9mIHRoZSBwcm9wZXJ0aWVzIGluIGRlZmF1bHRSZW5kZXJzXHJcbiAgICAqICAgLSBzb3VyY2VQcm9qZWN0aW9uOiBhIHN0cmluZyBtYXRjaGluZyBhIHByb2o0LmRlZnMgcHJvamVjdGlvbiB0byBiZSB1c2VkIGZvciB0aGUgc291cmNlIGRhdGEgKG92ZXJyaWRlc1xyXG4gICAgKiAgICAgZ2VvSnNvbi5jcnMpXHJcbiAgICAqICAgLSBmaWVsZHM6IGFuIGFycmF5IG9mIGZpZWxkcyB0byBiZSBhcHBlbmRlZCB0byB0aGUgRmVhdHVyZUxheWVyIGxheWVyRGVmaW5pdGlvbiAoT0JKRUNUSUQgaXMgc2V0IGJ5IGRlZmF1bHQpXHJcbiAgICAqICAgLSBlcHNnTG9va3VwOiBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYW4gRVBTRyBjb2RlIChzdHJpbmcgb3IgbnVtYmVyKSBhbmQgcmV0dXJucyBhIHByb21pc2Ugb2YgYSBwcm9qNCBzdHlsZVxyXG4gICAgKiAgICAgZGVmaW5pdGlvbiBvciBudWxsIGlmIG5vdCBmb3VuZFxyXG4gICAgKiAgIC0gbGF5ZXJJZDogYSBzdHJpbmcgdG8gdXNlIGFzIHRoZSBsYXllcklkXHJcbiAgICAqICAgLSBjb2xvdXI6IGEgaGV4IHN0cmluZyB0byBkZWZpbmUgdGhlIHN5bWJvbCBjb2xvdXIuIGUuZy4gJyMzM0RENkEnXHJcbiAgICAqXHJcbiAgICAqIEBtZXRob2QgbWFrZUdlb0pzb25MYXllclxyXG4gICAgKiBAcGFyYW0ge09iamVjdH0gZ2VvSnNvbiBBbiBvYmplY3QgZm9sbG93aW5nIHRoZSBHZW9KU09OIHNwZWNpZmljYXRpb24sIHNob3VsZCBiZSBhIEZlYXR1cmVDb2xsZWN0aW9uIHdpdGhcclxuICAgICogRmVhdHVyZXMgb2Ygb25seSBvbmUgdHlwZVxyXG4gICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBBbiBvYmplY3QgZm9yIHN1cHBseWluZyBhZGRpdGlvbmFsIHBhcmFtZXRlcnNcclxuICAgICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSByZXNvbHZpbmcgd2l0aCBhIHtGZWF0dXJlTGF5ZXJ9XHJcbiAgICAqL1xyXG4gICAgcmV0dXJuIChnZW9Kc29uLCBvcHRzKSA9PiB7XHJcblxyXG4gICAgICAgIC8vIFRPRE8gYWRkIGRvY3VtZW50YXRpb24gb24gd2h5IHdlIG9ubHkgc3VwcG9ydCBsYXllcnMgd2l0aCBXS0lEIChhbmQgbm90IFdLVCkuXHJcbiAgICAgICAgbGV0IHRhcmdldFdraWQ7XHJcbiAgICAgICAgbGV0IHNyY1Byb2ogPSAnRVBTRzo0MzI2JzsgLy8gNDMyNiBpcyB0aGUgZGVmYXVsdCBmb3IgR2VvSlNPTiB3aXRoIG5vIHByb2plY3Rpb24gZGVmaW5lZFxyXG4gICAgICAgIGxldCBsYXllcklkO1xyXG4gICAgICAgIGNvbnN0IGxheWVyRGVmaW5pdGlvbiA9IHtcclxuICAgICAgICAgICAgb2JqZWN0SWRGaWVsZDogJ09CSkVDVElEJyxcclxuICAgICAgICAgICAgZmllbGRzOiBbXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ09CSkVDVElEJyxcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZXNyaUZpZWxkVHlwZU9JRCcsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIGVuc3VyZSBvdXIgZmVhdHVyZXMgaGF2ZSBpZHNcclxuICAgICAgICBhc3NpZ25JZHMoZ2VvSnNvbik7XHJcbiAgICAgICAgbGF5ZXJEZWZpbml0aW9uLmRyYXdpbmdJbmZvID1cclxuICAgICAgICAgICAgZGVmYXVsdFJlbmRlcmVyc1tmZWF0dXJlVHlwZVRvUmVuZGVyZXJbZ2VvSnNvbi5mZWF0dXJlc1swXS5nZW9tZXRyeS50eXBlXV07XHJcblxyXG4gICAgICAgIC8vIGF0dGVtcHQgdG8gZ2V0IHNwYXRpYWwgcmVmZXJlbmNlIGZyb20gZ2VvSnNvblxyXG4gICAgICAgIGlmIChnZW9Kc29uLmNycyAmJiBnZW9Kc29uLmNycy50eXBlID09PSAnbmFtZScpIHtcclxuICAgICAgICAgICAgc3JjUHJvaiA9IGdlb0pzb24uY3JzLnByb3BlcnRpZXMubmFtZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHBsdWNrIHRyZWF0cyBmcm9tIG9wdGlvbnMgcGFyYW1ldGVyXHJcbiAgICAgICAgaWYgKG9wdHMpIHtcclxuICAgICAgICAgICAgaWYgKG9wdHMuc291cmNlUHJvamVjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgc3JjUHJvaiA9IG9wdHMuc291cmNlUHJvamVjdGlvbjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKG9wdHMudGFyZ2V0V2tpZCkge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0V2tpZCA9IG9wdHMudGFyZ2V0V2tpZDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWFrZUdlb0pzb25MYXllciAtIG1pc3Npbmcgb3B0cy50YXJnZXRXa2lkIGFyZ3VlbWVudCcpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAob3B0cy5maWVsZHMpIHtcclxuICAgICAgICAgICAgICAgIGxheWVyRGVmaW5pdGlvbi5maWVsZHMgPSBsYXllckRlZmluaXRpb24uZmllbGRzLmNvbmNhdChvcHRzLmZpZWxkcyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChvcHRzLmxheWVySWQpIHtcclxuICAgICAgICAgICAgICAgIGxheWVySWQgPSBvcHRzLmxheWVySWQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsYXllcklkID0gZ2VvQXBpLnNoYXJlZC5nZW5lcmF0ZVVVSUQoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gVE9ETyBhZGQgc3VwcG9ydCBmb3IgcmVuZGVyZXIgb3B0aW9uLCBvciBkcm9wIHRoZSBvcHRpb25cclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYWtlR2VvSnNvbkxheWVyIC0gbWlzc2luZyBvcHRzIGFyZ3VlbWVudCcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGxheWVyRGVmaW5pdGlvbi5maWVsZHMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgIC8vIGNhbGxlciBoYXMgbm90IHN1cHBsaWVkIGN1c3RvbSBmaWVsZCBsaXN0LiBzbyB0YWtlIHRoZW0gYWxsLlxyXG4gICAgICAgICAgICBsYXllckRlZmluaXRpb24uZmllbGRzID0gbGF5ZXJEZWZpbml0aW9uLmZpZWxkcy5jb25jYXQoZXh0cmFjdEZpZWxkcyhnZW9Kc29uKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBkZXN0UHJvaiA9ICdFUFNHOicgKyB0YXJnZXRXa2lkO1xyXG5cclxuICAgICAgICAvLyBsb29rIHVwIHByb2plY3Rpb24gZGVmaW5pdGlvbnMgaWYgdGhleSBkb24ndCBhbHJlYWR5IGV4aXN0IGFuZCB3ZSBoYXZlIGVub3VnaCBpbmZvXHJcbiAgICAgICAgY29uc3Qgc3JjTG9va3VwID0gcHJvamVjdGlvbkxvb2t1cChnZW9BcGkucHJvaiwgc3JjUHJvaiwgb3B0cy5lcHNnTG9va3VwKTtcclxuICAgICAgICBjb25zdCBkZXN0TG9va3VwID0gcHJvamVjdGlvbkxvb2t1cChnZW9BcGkucHJvaiwgZGVzdFByb2osIG9wdHMuZXBzZ0xvb2t1cCk7XHJcblxyXG4gICAgICAgIC8vIG1ha2UgdGhlIGxheWVyXHJcbiAgICAgICAgY29uc3QgYnVpbGRMYXllciA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xyXG5cclxuICAgICAgICAgICAgLy8gcHJvamVjdCBkYXRhIGFuZCBjb252ZXJ0IHRvIGVzcmkganNvbiBmb3JtYXRcclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ3JlcHJvamVjdGluZyAnICsgc3JjUHJvaiArICcgLT4gRVBTRzonICsgdGFyZ2V0V2tpZCk7XHJcbiAgICAgICAgICAgIGdlb0FwaS5wcm9qLnByb2plY3RHZW9qc29uKGdlb0pzb24sIGRlc3RQcm9qLCBzcmNQcm9qKTtcclxuICAgICAgICAgICAgY29uc3QgZXNyaUpzb24gPSBUZXJyYWZvcm1lci5BcmNHSVMuY29udmVydChnZW9Kc29uLCB7IHNyOiB0YXJnZXRXa2lkIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBnZW9tZXRyeVR5cGUgPSBsYXllckRlZmluaXRpb24uZHJhd2luZ0luZm8uZ2VvbWV0cnlUeXBlO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgZnMgPSB7XHJcbiAgICAgICAgICAgICAgICBmZWF0dXJlczogZXNyaUpzb24sXHJcbiAgICAgICAgICAgICAgICBnZW9tZXRyeVR5cGVcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uc3QgbGF5ZXIgPSBuZXcgZXNyaUJ1bmRsZS5GZWF0dXJlTGF5ZXIoXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXJEZWZpbml0aW9uOiBsYXllckRlZmluaXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZVNldDogZnNcclxuICAgICAgICAgICAgICAgIH0sIHtcclxuICAgICAgICAgICAgICAgICAgICBtb2RlOiBlc3JpQnVuZGxlLkZlYXR1cmVMYXllci5NT0RFX1NOQVBTSE9ULFxyXG4gICAgICAgICAgICAgICAgICAgIGlkOiBsYXllcklkXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vIO+8vCjvvYBPwrQp77yPIG1hbnVhbGx5IHNldHRpbmcgU1IgYmVjYXVzZSBpdCB3aWxsIGNvbWUgb3V0IGFzIDQzMjZcclxuICAgICAgICAgICAgbGF5ZXIuc3BhdGlhbFJlZmVyZW5jZSA9IG5ldyBlc3JpQnVuZGxlLlNwYXRpYWxSZWZlcmVuY2UoeyB3a2lkOiB0YXJnZXRXa2lkIH0pO1xyXG5cclxuICAgICAgICAgICAgaWYgKG9wdHMuY29sb3VyKSB7XHJcbiAgICAgICAgICAgICAgICBsYXllci5yZW5kZXJlci5zeW1ib2wuY29sb3IgPSBuZXcgZXNyaUJ1bmRsZS5Db2xvcihvcHRzLmNvbG91cik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGluaXRpYWxpemluZyBsYXllciB1c2luZyBKU09OIGRvZXMgbm90IHNldCB0aGlzIHByb3BlcnR5LiBkbyBpdCBtYW51YWxseS5cclxuICAgICAgICAgICAgbGF5ZXIuZ2VvbWV0cnlUeXBlID0gZ2VvbWV0cnlUeXBlO1xyXG5cclxuICAgICAgICAgICAgcmVzb2x2ZShsYXllcik7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIGNhbGwgcHJvbWlzZXMgaW4gb3JkZXJcclxuICAgICAgICByZXR1cm4gc3JjTG9va3VwXHJcbiAgICAgICAgICAgIC50aGVuKCgpID0+IGRlc3RMb29rdXApXHJcbiAgICAgICAgICAgIC50aGVuKCgpID0+IGJ1aWxkTGF5ZXIpO1xyXG5cclxuICAgIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1ha2VDc3ZMYXllckJ1aWxkZXIoZXNyaUJ1bmRsZSwgZ2VvQXBpKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIENvbnN0cnVjdHMgYSBGZWF0dXJlTGF5ZXIgZnJvbSBDU1YgZGF0YS4gQWNjZXB0cyB0aGUgZm9sbG93aW5nIG9wdGlvbnM6XHJcbiAgICAqICAgLSB0YXJnZXRXa2lkOiBSZXF1aXJlZC4gYW4gaW50ZWdlciBmb3IgYW4gRVNSSSB3a2lkIHRoZSBzcGF0aWFsIHJlZmVyZW5jZSB0aGUgcmV0dXJuZWQgbGF5ZXIgc2hvdWxkIGJlIGluXHJcbiAgICAqICAgLSByZW5kZXJlcjogYSBzdHJpbmcgaWRlbnRpZnlpbmcgb25lIG9mIHRoZSBwcm9wZXJ0aWVzIGluIGRlZmF1bHRSZW5kZXJzXHJcbiAgICAqICAgLSBmaWVsZHM6IGFuIGFycmF5IG9mIGZpZWxkcyB0byBiZSBhcHBlbmRlZCB0byB0aGUgRmVhdHVyZUxheWVyIGxheWVyRGVmaW5pdGlvbiAoT0JKRUNUSUQgaXMgc2V0IGJ5IGRlZmF1bHQpXHJcbiAgICAqICAgLSBsYXRmaWVsZDogYSBzdHJpbmcgaWRlbnRpZnlpbmcgdGhlIGZpZWxkIGNvbnRhaW5pbmcgbGF0aXR1ZGUgdmFsdWVzICgnTGF0JyBieSBkZWZhdWx0KVxyXG4gICAgKiAgIC0gbG9uZmllbGQ6IGEgc3RyaW5nIGlkZW50aWZ5aW5nIHRoZSBmaWVsZCBjb250YWluaW5nIGxvbmdpdHVkZSB2YWx1ZXMgKCdMb25nJyBieSBkZWZhdWx0KVxyXG4gICAgKiAgIC0gZGVsaW1pdGVyOiBhIHN0cmluZyBkZWZpbmluZyB0aGUgZGVsaW1pdGVyIGNoYXJhY3RlciBvZiB0aGUgZmlsZSAoJywnIGJ5IGRlZmF1bHQpXHJcbiAgICAqICAgLSBlcHNnTG9va3VwOiBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYW4gRVBTRyBjb2RlIChzdHJpbmcgb3IgbnVtYmVyKSBhbmQgcmV0dXJucyBhIHByb21pc2Ugb2YgYSBwcm9qNCBzdHlsZVxyXG4gICAgKiAgICAgZGVmaW5pdGlvbiBvciBudWxsIGlmIG5vdCBmb3VuZFxyXG4gICAgKiAgIC0gbGF5ZXJJZDogYSBzdHJpbmcgdG8gdXNlIGFzIHRoZSBsYXllcklkXHJcbiAgICAqICAgLSBjb2xvdXI6IGEgaGV4IHN0cmluZyB0byBkZWZpbmUgdGhlIHN5bWJvbCBjb2xvdXIuIGUuZy4gJyMzM0RENkEnXHJcbiAgICAqIEBwYXJhbSB7c3RyaW5nfSBjc3ZEYXRhIHRoZSBDU1YgZGF0YSB0byBiZSBwcm9jZXNzZWRcclxuICAgICogQHBhcmFtIHtvYmplY3R9IG9wdHMgb3B0aW9ucyB0byBiZSBzZXQgZm9yIHRoZSBwYXJzZXJcclxuICAgICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSByZXNvbHZpbmcgd2l0aCBhIHtGZWF0dXJlTGF5ZXJ9XHJcbiAgICAqL1xyXG4gICAgcmV0dXJuIChjc3ZEYXRhLCBvcHRzKSA9PiB7XHJcbiAgICAgICAgY29uc3QgY3N2T3B0cyA9IHsgLy8gZGVmYXVsdCB2YWx1ZXNcclxuICAgICAgICAgICAgbGF0ZmllbGQ6ICdMYXQnLFxyXG4gICAgICAgICAgICBsb25maWVsZDogJ0xvbmcnLFxyXG4gICAgICAgICAgICBkZWxpbWl0ZXI6ICcsJ1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIHVzZXIgb3B0aW9ucyBpZlxyXG4gICAgICAgIGlmIChvcHRzKSB7XHJcbiAgICAgICAgICAgIGlmIChvcHRzLmxhdGZpZWxkKSB7XHJcbiAgICAgICAgICAgICAgICBjc3ZPcHRzLmxhdGZpZWxkID0gb3B0cy5sYXRmaWVsZDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKG9wdHMubG9uZmllbGQpIHtcclxuICAgICAgICAgICAgICAgIGNzdk9wdHMubG9uZmllbGQgPSBvcHRzLmxvbmZpZWxkO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAob3B0cy5kZWxpbWl0ZXIpIHtcclxuICAgICAgICAgICAgICAgIGNzdk9wdHMuZGVsaW1pdGVyID0gb3B0cy5kZWxpbWl0ZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIGNzdjJnZW9qc29uLmNzdjJnZW9qc29uKGNzdkRhdGEsIGNzdk9wdHMsIChlcnIsIGRhdGEpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ2NzdiBjb252ZXJzaW9uIGVycm9yJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY3N2Mmdlb2pzb24gd2lsbCBub3QgaW5jbHVkZSB0aGUgbGF0IGFuZCBsb25nIGluIHRoZSBmZWF0dXJlXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5mZWF0dXJlcy5tYXAoZmVhdHVyZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZCBuZXcgcHJvcGVydHkgTG9uZyBhbmQgTGF0IGJlZm9yZSBsYXllciBpcyBnZW5lcmF0ZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZS5wcm9wZXJ0aWVzW2Nzdk9wdHMubG9uZmllbGRdID0gZmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlc1swXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZS5wcm9wZXJ0aWVzW2Nzdk9wdHMubGF0ZmllbGRdID0gZmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlc1sxXTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBhcmUgd2UgYXQgcmlzayBhZGRpbmcgcGFyYW1zIHRvIHRoZSB2YXIgdGhhdCB3YXMgcGFzc2VkIGluPyBzaG91bGQgd2UgbWFrZSBhIGNvcHkgYW5kIG1vZGlmeSB0aGUgY29weT9cclxuICAgICAgICAgICAgICAgICAgICBvcHRzLnNvdXJjZVByb2plY3Rpb24gPSAnRVBTRzo0MzI2JzsgLy8gY3N2IGlzIGFsd2F5cyBsYXRsb25nXHJcbiAgICAgICAgICAgICAgICAgICAgb3B0cy5yZW5kZXJlciA9ICdjaXJjbGVQb2ludCc7IC8vIGNzdiBpcyBhbHdheXMgbGF0bG9uZ1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiBzaW5jZSBtYWtlR2VvSnNvbkxheWVyIGlzIGEgXCJidWlsdFwiIGZ1bmN0aW9uLCBncmFiIHRoZSBidWlsdCB2ZXJzaW9uIGZyb20gb3VyIGxpbmsgdG8gYXBpIG9iamVjdFxyXG4gICAgICAgICAgICAgICAgICAgIGdlb0FwaS5sYXllci5tYWtlR2VvSnNvbkxheWVyKGRhdGEsIG9wdHMpLnRoZW4oanNvbkxheWVyID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShqc29uTGF5ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgfTtcclxufVxyXG5cclxuLyoqXHJcbiogUGVlayBhdCB0aGUgQ1NWIG91dHB1dCAodXNlZnVsIGZvciBjaGVja2luZyBoZWFkZXJzKVxyXG4qIEBwYXJhbSB7c3RyaW5nfSBjc3ZEYXRhIHRoZSBDU1YgZGF0YSB0byBiZSBwcm9jZXNzZWRcclxuKiBAcGFyYW0ge3N0cmluZ30gZGVsaW1pdGVyIHRoZSBkZWxpbWl0ZXIgdXNlZCBieSB0aGUgZGF0YVxyXG4qIEByZXR1cm5zIHtBcnJheX0gYW4gYXJyYXkgb2YgYXJyYXlzIGNvbnRhaW5pbmcgdGhlIHBhcnNlZCBDU1ZcclxuKi9cclxuZnVuY3Rpb24gY3N2UGVlayhjc3ZEYXRhLCBkZWxpbWl0ZXIpIHtcclxuICAgIHJldHVybiBjc3YyZ2VvanNvbi5kc3YoZGVsaW1pdGVyKS5wYXJzZVJvd3MoY3N2RGF0YSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1ha2VTaGFwZUxheWVyQnVpbGRlcihlc3JpQnVuZGxlLCBnZW9BcGkpIHtcclxuXHJcbiAgICAvKipcclxuICAgICogQ29uc3RydWN0cyBhIEZlYXR1cmVMYXllciBmcm9tIFNoYXBlZmlsZSBkYXRhLiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgb3B0aW9uczpcclxuICAgICogICAtIHRhcmdldFdraWQ6IFJlcXVpcmVkLiBhbiBpbnRlZ2VyIGZvciBhbiBFU1JJIHdraWQgdGhlIHNwYXRpYWwgcmVmZXJlbmNlIHRoZSByZXR1cm5lZCBsYXllciBzaG91bGQgYmUgaW5cclxuICAgICogICAtIHJlbmRlcmVyOiBhIHN0cmluZyBpZGVudGlmeWluZyBvbmUgb2YgdGhlIHByb3BlcnRpZXMgaW4gZGVmYXVsdFJlbmRlcnNcclxuICAgICogICAtIHNvdXJjZVByb2plY3Rpb246IGEgc3RyaW5nIG1hdGNoaW5nIGEgcHJvajQuZGVmcyBwcm9qZWN0aW9uIHRvIGJlIHVzZWQgZm9yIHRoZSBzb3VyY2UgZGF0YSAob3ZlcnJpZGVzXHJcbiAgICAqICAgICBnZW9Kc29uLmNycylcclxuICAgICogICAtIGZpZWxkczogYW4gYXJyYXkgb2YgZmllbGRzIHRvIGJlIGFwcGVuZGVkIHRvIHRoZSBGZWF0dXJlTGF5ZXIgbGF5ZXJEZWZpbml0aW9uIChPQkpFQ1RJRCBpcyBzZXQgYnkgZGVmYXVsdClcclxuICAgICogICAtIGVwc2dMb29rdXA6IGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhbiBFUFNHIGNvZGUgKHN0cmluZyBvciBudW1iZXIpIGFuZCByZXR1cm5zIGEgcHJvbWlzZSBvZiBhIHByb2o0IHN0eWxlXHJcbiAgICAqICAgICBkZWZpbml0aW9uIG9yIG51bGwgaWYgbm90IGZvdW5kXHJcbiAgICAqICAgLSBsYXllcklkOiBhIHN0cmluZyB0byB1c2UgYXMgdGhlIGxheWVySWRcclxuICAgICogICAtIGNvbG91cjogYSBoZXggc3RyaW5nIHRvIGRlZmluZSB0aGUgc3ltYm9sIGNvbG91ci4gZS5nLiAnIzMzREQ2QSdcclxuICAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gc2hhcGVEYXRhIGFuIEFycmF5QnVmZmVyIG9mIHRoZSBTaGFwZWZpbGUgaW4gemlwIGZvcm1hdFxyXG4gICAgKiBAcGFyYW0ge29iamVjdH0gb3B0cyBvcHRpb25zIHRvIGJlIHNldCBmb3IgdGhlIHBhcnNlclxyXG4gICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlIHJlc29sdmluZyB3aXRoIGEge0ZlYXR1cmVMYXllcn1cclxuICAgICovXHJcbiAgICByZXR1cm4gKHNoYXBlRGF0YSwgb3B0cykgPT4ge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIC8vIHR1cm4gc2hhcGUgaW50byBnZW9qc29uXHJcbiAgICAgICAgICAgIHNocChzaGFwZURhdGEpLnRoZW4oZ2VvSnNvbiA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyB0dXJuIGdlb2pzb24gaW50byBmZWF0dXJlIGxheWVyXHJcbiAgICAgICAgICAgICAgICAvLyBOT1RFOiBzaW5jZSBtYWtlR2VvSnNvbkxheWVyIGlzIGEgXCJidWlsdFwiIGZ1bmN0aW9uLCBncmFiIHRoZSBidWlsdCB2ZXJzaW9uIGZyb20gb3VyIGxpbmsgdG8gYXBpIG9iamVjdFxyXG4gICAgICAgICAgICAgICAgZ2VvQXBpLmxheWVyLm1ha2VHZW9Kc29uTGF5ZXIoZ2VvSnNvbiwgb3B0cykudGhlbihqc29uTGF5ZXIgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoanNvbkxheWVyKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KS5jYXRjaChlcnIgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlSW1hZ2VSZWNvcmRCdWlsZGVyKGVzcmlCdW5kbGUsIGdlb0FwaSwgY2xhc3NCdW5kbGUpIHtcclxuICAgIC8qKlxyXG4gICAgKiBDcmVhdGVzIGFuIEltYWdlIExheWVyIFJlY29yZCBjbGFzc1xyXG4gICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnICAgICAgICAgbGF5ZXIgY29uZmlnIHZhbHVlc1xyXG4gICAgKiBAcGFyYW0ge09iamVjdH0gZXNyaUxheWVyICAgICAgYW4gb3B0aW9uYWwgcHJlLWNvbnN0cnVjdGVkIGxheWVyXHJcbiAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVwc2dMb29rdXAgICBhbiBvcHRpb25hbCBsb29rdXAgZnVuY3Rpb24gZm9yIEVQU0cgY29kZXMgKHNlZSBnZW9TZXJ2aWNlIGZvciBzaWduYXR1cmUpXHJcbiAgICAqIEByZXR1cm5zIHtPYmplY3R9ICAgICAgICAgICAgICBpbnN0YW50aXRlZCBJbWFnZVJlY29yZCBjbGFzc1xyXG4gICAgKi9cclxuICAgIHJldHVybiAoY29uZmlnLCBlc3JpTGF5ZXIsIGVwc2dMb29rdXApID0+IHtcclxuICAgICAgICByZXR1cm4gbmV3IGNsYXNzQnVuZGxlLkltYWdlUmVjb3JkKGVzcmlCdW5kbGUuQXJjR0lTSW1hZ2VTZXJ2aWNlTGF5ZXIsIGdlb0FwaSwgY29uZmlnLCBlc3JpTGF5ZXIsIGVwc2dMb29rdXApO1xyXG4gICAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlRmVhdHVyZVJlY29yZEJ1aWxkZXIoZXNyaUJ1bmRsZSwgZ2VvQXBpLCBjbGFzc0J1bmRsZSkge1xyXG4gICAgLyoqXHJcbiAgICAqIENyZWF0ZXMgYW4gRmVhdHVyZSBMYXllciBSZWNvcmQgY2xhc3NcclxuICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyAgICAgICAgIGxheWVyIGNvbmZpZyB2YWx1ZXNcclxuICAgICogQHBhcmFtIHtPYmplY3R9IGVzcmlMYXllciAgICAgIGFuIG9wdGlvbmFsIHByZS1jb25zdHJ1Y3RlZCBsYXllclxyXG4gICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcHNnTG9va3VwICAgYW4gb3B0aW9uYWwgbG9va3VwIGZ1bmN0aW9uIGZvciBFUFNHIGNvZGVzIChzZWUgZ2VvU2VydmljZSBmb3Igc2lnbmF0dXJlKVxyXG4gICAgKiBAcmV0dXJucyB7T2JqZWN0fSAgICAgICAgICAgICAgaW5zdGFudGl0ZWQgRmVhdHVyZVJlY29yZCBjbGFzc1xyXG4gICAgKi9cclxuICAgIHJldHVybiAoY29uZmlnLCBlc3JpTGF5ZXIsIGVwc2dMb29rdXApID0+IHtcclxuICAgICAgICByZXR1cm4gbmV3IGNsYXNzQnVuZGxlLkZlYXR1cmVSZWNvcmQoZXNyaUJ1bmRsZS5GZWF0dXJlTGF5ZXIsIGVzcmlCdW5kbGUuZXNyaVJlcXVlc3QsXHJcbiAgICAgICAgICAgIGdlb0FwaSwgY29uZmlnLCBlc3JpTGF5ZXIsIGVwc2dMb29rdXApO1xyXG4gICAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlRHluYW1pY1JlY29yZEJ1aWxkZXIoZXNyaUJ1bmRsZSwgZ2VvQXBpLCBjbGFzc0J1bmRsZSkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIER5bmFtaWMgTGF5ZXIgUmVjb3JkIGNsYXNzXHJcbiAgICAgKiBTZWUgRHluYW1pY1JlY29yZCBjb25zdHJ1Y3RvciBmb3IgbW9yZSBkZXRhaWxlZCBpbmZvIG9uIGNvbmZpZ0lzQ29tcGxldGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyAgICAgICAgICAgICAgbGF5ZXIgY29uZmlnIHZhbHVlc1xyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVzcmlMYXllciAgICAgICAgICAgYW4gb3B0aW9uYWwgcHJlLWNvbnN0cnVjdGVkIGxheWVyXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcHNnTG9va3VwICAgICAgICBhbiBvcHRpb25hbCBsb29rdXAgZnVuY3Rpb24gZm9yIEVQU0cgY29kZXMgKHNlZSBnZW9TZXJ2aWNlIGZvciBzaWduYXR1cmUpXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNvbmZpZ0lzQ29tcGxldGUgICBhbiBvcHRpb25hbCBmbGFnIHRvIGluZGljYXRlIGFsbCBjaGlsZCBzdGF0ZSB2YWx1ZXMgYXJlIHByb3ZpZGVkIGluIHRoZSBjb25maWcgYW5kIHNob3VsZCBiZSB1c2VkLlxyXG4gICAgICogQHJldHVybnMge09iamVjdH0gICAgICAgICAgICAgICAgICAgaW5zdGFudGl0ZWQgRHluYW1pY1JlY29yZCBjbGFzc1xyXG4gICAgICovXHJcbiAgICByZXR1cm4gKGNvbmZpZywgZXNyaUxheWVyLCBlcHNnTG9va3VwLCBjb25maWdJc0NvbXBsZXRlID0gZmFsc2UpID0+IHtcclxuICAgICAgICByZXR1cm4gbmV3IGNsYXNzQnVuZGxlLkR5bmFtaWNSZWNvcmQoZXNyaUJ1bmRsZS5BcmNHSVNEeW5hbWljTWFwU2VydmljZUxheWVyLCBlc3JpQnVuZGxlLmVzcmlSZXF1ZXN0LFxyXG4gICAgICAgICAgICBnZW9BcGksIGNvbmZpZywgZXNyaUxheWVyLCBlcHNnTG9va3VwLCBjb25maWdJc0NvbXBsZXRlKTtcclxuICAgIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVRpbGVSZWNvcmRCdWlsZGVyKGVzcmlCdW5kbGUsIGdlb0FwaSwgY2xhc3NCdW5kbGUpIHtcclxuICAgIC8qKlxyXG4gICAgKiBDcmVhdGVzIGFuIFRpbGUgTGF5ZXIgUmVjb3JkIGNsYXNzXHJcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgICAgICAgICBsYXllciBjb25maWcgdmFsdWVzXHJcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBlc3JpTGF5ZXIgICAgICBhbiBvcHRpb25hbCBwcmUtY29uc3RydWN0ZWQgbGF5ZXJcclxuICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXBzZ0xvb2t1cCAgIGFuIG9wdGlvbmFsIGxvb2t1cCBmdW5jdGlvbiBmb3IgRVBTRyBjb2RlcyAoc2VlIGdlb1NlcnZpY2UgZm9yIHNpZ25hdHVyZSlcclxuICAgICogQHJldHVybnMge09iamVjdH0gICAgICAgICAgICAgIGluc3RhbnRpdGVkIFRpbGVSZWNvcmQgY2xhc3NcclxuICAgICovXHJcbiAgICByZXR1cm4gKGNvbmZpZywgZXNyaUxheWVyLCBlcHNnTG9va3VwKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBjbGFzc0J1bmRsZS5UaWxlUmVjb3JkKGVzcmlCdW5kbGUuQXJjR0lTVGlsZWRNYXBTZXJ2aWNlTGF5ZXIsIGdlb0FwaSwgY29uZmlnLFxyXG4gICAgICAgICAgICBlc3JpTGF5ZXIsIGVwc2dMb29rdXApO1xyXG4gICAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlV21zUmVjb3JkQnVpbGRlcihlc3JpQnVuZGxlLCBnZW9BcGksIGNsYXNzQnVuZGxlKSB7XHJcbiAgICAvKipcclxuICAgICogQ3JlYXRlcyBhbiBXTVMgTGF5ZXIgUmVjb3JkIGNsYXNzXHJcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgICAgICAgICBsYXllciBjb25maWcgdmFsdWVzXHJcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBlc3JpTGF5ZXIgICAgICBhbiBvcHRpb25hbCBwcmUtY29uc3RydWN0ZWQgbGF5ZXJcclxuICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXBzZ0xvb2t1cCAgIGFuIG9wdGlvbmFsIGxvb2t1cCBmdW5jdGlvbiBmb3IgRVBTRyBjb2RlcyAoc2VlIGdlb1NlcnZpY2UgZm9yIHNpZ25hdHVyZSlcclxuICAgICogQHJldHVybnMge09iamVjdH0gICAgICAgICAgICAgIGluc3RhbnRpdGVkIFdtc1JlY29yZCBjbGFzc1xyXG4gICAgKi9cclxuICAgIHJldHVybiAoY29uZmlnLCBlc3JpTGF5ZXIsIGVwc2dMb29rdXApID0+IHtcclxuICAgICAgICByZXR1cm4gbmV3IGNsYXNzQnVuZGxlLldtc1JlY29yZChlc3JpQnVuZGxlLldtc0xheWVyLCBnZW9BcGksIGNvbmZpZywgZXNyaUxheWVyLCBlcHNnTG9va3VwKTtcclxuICAgIH07XHJcbn1cclxuXHJcbi8qKlxyXG4qIEdpdmVuIDJEIGFycmF5IGluIGNvbHVtbiB4IHJvdyBmb3JtYXQsIGNoZWNrIGlmIGFsbCBlbnRyaWVzIGluIHRoZSB0d28gZ2l2ZW4gY29sdW1ucyBhcmUgbnVtZXJpYy5cclxuKlxyXG4qIEBwYXJhbSB7QXJyYXl9IGFyciBpcyBhIDJEIGFycmF5IGJhc2VkIG9uIHRoZSBDU1YgZmlsZSB0aGF0IGNvbnRhaW5zIHJvdyBpbmZvcm1hdGlvbiBmb3IgYWxsIG9mIHRoZSByb3dzXHJcbiogQHBhcmFtIHtJbnRlZ2VyfSBpbmQxIGlzIGEgdXNlciBzcGVjaWZpZWQgaW5kZXggd2hlbiB1cGxvYWRpbmcgdGhlIENTViB0aGF0IHNwZWNpZmllcyBsYXQgb3IgbG9uZyBjb2x1bW4gKHdoaWNoZXZlciBpc24ndCBzcGVjaWZpZWQgYnkgaW5kMilcclxuKiBAcGFyYW0ge0ludGVnZXJ9IGluZDIgaXMgYSB1c2VyIHNwZWNpZmllZCBpbmRleCB3aGVuIHVwbG9hZGluZyB0aGUgQ1NWIHRoYXQgc3BlY2lmaWVzIGxhdCBvciBsb25nIGNvbHVtbiAod2hpY2hldmVyIGlzbid0IHNwZWNpZmllZCBieSBpbmQxKVxyXG4qIEByZXR1cm4ge0Jvb2xlYW59IHJldHVybnMgdHJ1ZSBvciBmYWxzZSBiYXNlZCBvbiB3aGV0aGVyIG9yIG5vdCBhbGwgYWxsIGNvbHVtbnMgYXQgaW5kMSBhbmQgaW5kMiBhcmUgbnVtYmVyc1xyXG4qL1xyXG5mdW5jdGlvbiB2YWxpZGF0ZUxhdExvbmcoYXJyLCBpbmQxLCBpbmQyKSB7XHJcbiAgICByZXR1cm4gYXJyLmV2ZXJ5KHJvdyA9PiB7XHJcbiAgICAgICAgcmV0dXJuICEoaXNOYU4ocm93W2luZDFdKSB8fCBpc05hTihyb3dbaW5kMl0pKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG4vLyBDQVJFRlVMIE5PVyFcclxuLy8gd2UgYXJlIHBhc3NpbmcgaW4gYSByZWZlcmVuY2UgdG8gZ2VvQXBpLiAgaXQgaXMgYSBwb2ludGVyIHRvIHRoZSBvYmplY3QgdGhhdCBjb250YWlucyB0aGlzIG1vZHVsZSxcclxuLy8gYWxvbmcgd2l0aCBvdGhlciBtb2R1bGVzLiBpdCBsZXRzIHVzIGFjY2VzcyBvdGhlciBtb2R1bGVzIHdpdGhvdXQgcmUtaW5zdGFudGlhdGluZyB0aGVtIGluIGhlcmUuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGVzcmlCdW5kbGUsIGdlb0FwaSkge1xyXG5cclxuICAgIGNvbnN0IGxheWVyQ2xhc3NCdW5kbGUgPSBsYXllclJlY29yZChlc3JpQnVuZGxlLCBnZW9BcGkpO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgQXJjR0lTRHluYW1pY01hcFNlcnZpY2VMYXllcjogZXNyaUJ1bmRsZS5BcmNHSVNEeW5hbWljTWFwU2VydmljZUxheWVyLFxyXG4gICAgICAgIEFyY0dJU0ltYWdlU2VydmljZUxheWVyOiBlc3JpQnVuZGxlLkFyY0dJU0ltYWdlU2VydmljZUxheWVyLFxyXG4gICAgICAgIEdyYXBoaWNzTGF5ZXI6IGVzcmlCdW5kbGUuR3JhcGhpY3NMYXllcixcclxuICAgICAgICBGZWF0dXJlTGF5ZXI6IGVzcmlCdW5kbGUuRmVhdHVyZUxheWVyLFxyXG4gICAgICAgIFNjcmVlblBvaW50OiBlc3JpQnVuZGxlLlNjcmVlblBvaW50LFxyXG4gICAgICAgIFF1ZXJ5OiBlc3JpQnVuZGxlLlF1ZXJ5LFxyXG4gICAgICAgIFRpbGVMYXllcjogZXNyaUJ1bmRsZS5BcmNHSVNUaWxlZE1hcFNlcnZpY2VMYXllcixcclxuICAgICAgICBvZ2M6IG9nYyhlc3JpQnVuZGxlKSxcclxuICAgICAgICBiYm94OiBiYm94KGVzcmlCdW5kbGUsIGdlb0FwaSksXHJcbiAgICAgICAgY3JlYXRlSW1hZ2VSZWNvcmQ6IGNyZWF0ZUltYWdlUmVjb3JkQnVpbGRlcihlc3JpQnVuZGxlLCBnZW9BcGksIGxheWVyQ2xhc3NCdW5kbGUpLFxyXG4gICAgICAgIGNyZWF0ZVdtc1JlY29yZDogY3JlYXRlV21zUmVjb3JkQnVpbGRlcihlc3JpQnVuZGxlLCBnZW9BcGksIGxheWVyQ2xhc3NCdW5kbGUpLFxyXG4gICAgICAgIGNyZWF0ZVRpbGVSZWNvcmQ6IGNyZWF0ZVRpbGVSZWNvcmRCdWlsZGVyKGVzcmlCdW5kbGUsIGdlb0FwaSwgbGF5ZXJDbGFzc0J1bmRsZSksXHJcbiAgICAgICAgY3JlYXRlRHluYW1pY1JlY29yZDogY3JlYXRlRHluYW1pY1JlY29yZEJ1aWxkZXIoZXNyaUJ1bmRsZSwgZ2VvQXBpLCBsYXllckNsYXNzQnVuZGxlKSxcclxuICAgICAgICBjcmVhdGVGZWF0dXJlUmVjb3JkOiBjcmVhdGVGZWF0dXJlUmVjb3JkQnVpbGRlcihlc3JpQnVuZGxlLCBnZW9BcGksIGxheWVyQ2xhc3NCdW5kbGUpLFxyXG4gICAgICAgIExheWVyRHJhd2luZ09wdGlvbnM6IGVzcmlCdW5kbGUuTGF5ZXJEcmF3aW5nT3B0aW9ucyxcclxuICAgICAgICBtYWtlR2VvSnNvbkxheWVyOiBtYWtlR2VvSnNvbkxheWVyQnVpbGRlcihlc3JpQnVuZGxlLCBnZW9BcGkpLFxyXG4gICAgICAgIG1ha2VDc3ZMYXllcjogbWFrZUNzdkxheWVyQnVpbGRlcihlc3JpQnVuZGxlLCBnZW9BcGkpLFxyXG4gICAgICAgIG1ha2VTaGFwZUxheWVyOiBtYWtlU2hhcGVMYXllckJ1aWxkZXIoZXNyaUJ1bmRsZSwgZ2VvQXBpKSxcclxuICAgICAgICBzZXJ2ZXJMYXllcklkZW50aWZ5OiBzZXJ2ZXJMYXllcklkZW50aWZ5QnVpbGRlcihlc3JpQnVuZGxlKSxcclxuICAgICAgICBwcmVkaWN0TGF5ZXJVcmw6IHByZWRpY3RMYXllclVybEJ1aWxkZXIoZXNyaUJ1bmRsZSksXHJcbiAgICAgICAgdmFsaWRhdGVGaWxlLFxyXG4gICAgICAgIGNzdlBlZWssXHJcbiAgICAgICAgc2VydmljZVR5cGUsXHJcbiAgICAgICAgdmFsaWRhdGVMYXRMb25nXHJcbiAgICB9O1xyXG59O1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbGF5ZXIuanMiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){"use strict";eval("\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar TOO_MANY_LAYERS = 15;\n\n// This file relates to legends on an exported map, not legends in the layer selector\n\n/**\r\n * Generate all permutations of length M, with exactly N `true` values.\r\n *\r\n * @function\r\n * @param {int} M the size of the array (must be greater than 0)\r\n * @param {int} N the number of entries which should be true (must not be greater than M)\r\n * @return an array containing all possible size M arrays of boolean values with N true entries\r\n */\nfunction allComb(M, N) {\n    var maxTrue = N;\n    var maxFalse = M - N;\n    var C = [[[[]]]]; // C[m][n] is the solution to all_comb(m,n), C[0][0] starts with an empty array\n    for (var m = 1; m <= M; ++m) {\n        C[m] = [];\n        for (var n = 0; n <= m; ++n) {\n            // if this would place more than the max number of true or false values we don't need this part of the array\n            if (n > maxTrue || m - n > maxFalse) {\n                continue;\n            }\n\n            var a = n > 0 ? C[m - 1][n - 1].map(function (x) {\n                return x.concat(true);\n            }) : [];\n            var b = m > n ? C[m - 1][n].map(function (x) {\n                return x.concat(false);\n            }) : [];\n\n            C[m][n] = a.concat(b);\n        }\n    }\n    return C[M][N];\n}\n\n/**\r\n * Convenience function for assigning the `splitBefore` property on layers at specified points.\r\n * NOTE: this function modifies data in place\r\n * @function\r\n * @private\r\n * @param {Array} layers a list of layers to be updated (modified in place)\r\n * @param {Array} splitPoints an array of boolean values indicating if the layer list should be split at that point (must be layers.length-1 in size)\r\n * @return layers the same array as passed in\r\n */\nfunction assignLayerSplits(layers, splitPoints) {\n    layers[0].splitBefore = false;\n    splitPoints.forEach(function (split, i) {\n        return layers[i + 1].splitBefore = split;\n    });\n    return layers;\n}\n\n/**\r\n * Groups multiple layers into each section while attempting to minimize the legend height.\r\n * Allocates to the exact number specified in the `sections` argument.\r\n * NOTE: don't call this with too many layers as it tests all possible groupings and can be\r\n * computationally expensive (< 15 layers should be fine)\r\n * @function\r\n * @private\r\n * @param {Array} layers a list of layers to be fitted\r\n * @param {int} sections the number of sections to use\r\n * @return {Object} an object in the form { layers, sectionsUsed, bestPerm, bestHeight }\r\n */\nfunction packLayersIntoExactSections(layers, sections) {\n    var potentialSplits = layers.length - 1;\n    var requiredSplits = sections - 1;\n\n    var permutations = allComb(potentialSplits, requiredSplits);\n    var bestHeight = Number.MAX_VALUE;\n    var bestPerm = null;\n    var heights = Array(sections);\n\n    permutations.forEach(function (perm) {\n        heights.fill(0);\n        var curSec = 0;\n        layers.forEach(function (l, i) {\n            heights[curSec] += l.height;\n            if (perm[i]) {\n                ++curSec;\n            }\n        });\n        var h = Math.max.apply(Math, _toConsumableArray(heights));\n        if (h <= bestHeight) {\n            bestHeight = h;\n            bestPerm = perm;\n        }\n    });\n    return { layers: layers, sectionsUsed: sections, bestPerm: bestPerm, bestHeight: bestHeight };\n}\n\n/**\r\n * Groups multiple layers into each section while attempting to minimize the legend height.\r\n * Repeats as necessary to use the least number of sections while still keeping the resulting\r\n * legend height within 20% of optimal.\r\n * NOTE: don't call this with too many layers as it tests all possible groupings and can be\r\n * computationally expensive (< 15 layers should be fine)\r\n * @function\r\n * @private\r\n * @param {Array} layers a list of layers to be updated (modified in place)\r\n * @param {int} sections the number of sections to use\r\n * @return {Object} an object in the form { layers, sectionsUsed }\r\n */\nfunction packLayersIntoOptimalSections(layers, sections) {\n    var bestHeight = Number.MAX_VALUE;\n    var bestPerm = null;\n    var sectionsUsed = -1;\n    for (var n = sections; n > 1; --n) {\n        var _packLayersIntoExactS = packLayersIntoExactSections(layers, n),\n            perm = _packLayersIntoExactS.bestPerm,\n            height = _packLayersIntoExactS.bestHeight;\n\n        if (height * 0.8 > bestHeight) {\n            break;\n        } else if (height <= bestHeight) {\n            bestHeight = height;\n            bestPerm = perm;\n            sectionsUsed = n;\n        }\n    }\n    assignLayerSplits(layers, bestPerm);\n    return { layers: layers, sectionsUsed: sectionsUsed };\n}\n\n/**\r\n * Split a layer into `splitCount` parts of roughly equal size.\r\n * @function\r\n * @private\r\n * @param {Object} layer a layer object to be split into `splitCount` parts\r\n * @param {int} chunkSize the maximum height in pixels of the legend sections\r\n * @param {int} splitCount the number of pieces which the layer should be broken into\r\n * @return an object with properties whiteSpace: <int>, splits: [ <layerItems> ]\r\n */\nfunction splitLayer(layer, chunkSize, splitCount) {\n    var itemYOffset = layer.y;\n    var itemYMax = 0;\n    var splits = [];\n    var splitSizes = Array(splitCount).fill(0);\n\n    function traverse(items) {\n        items.forEach(function (item) {\n\n            if (splitCount === 1) {\n                return;\n            }\n\n            splitSizes[splitCount - 1] = itemYMax - itemYOffset; // bottom of current item - offset at current section start\n\n            // this is the y coordinate of the item's bottom boundary\n            itemYMax = item.y + (item.type === 'group' ? item.headerHeight : item.height);\n\n            if (itemYMax - itemYOffset >= chunkSize) {\n                splitCount--;\n\n                // whitespace is created when an item sitting on the boundary pulled into the next chunk, the space\n                // it would have occupied is wasted; the waste doubles as the entire item is moved to the next legend chunk\n                itemYOffset = item.y;\n                splits.push(item);\n            }\n\n            if (item.type === 'group') {\n                traverse(item.items);\n            }\n        });\n    }\n\n    traverse(layer.items);\n    splitSizes[splitCount - 1] = layer.height - (itemYOffset - layer.y); // bottom of layer - start of last section; start of last section = total offset of last section - offset at start of layer\n\n    // with whiteSpace we want to find the difference between the chunkSize and used space\n    // for each section used (whiteSpace may be negative indicating that a section is\n    // spilling past the target size); the total amount of whiteSpace is a measure of how\n    // bad the layer allocation was\n    return { whiteSpace: splitSizes.reduce(function (a, b) {\n            return a + Math.abs(chunkSize - b);\n        }, 0), splits: splits };\n}\n\n/**\r\n * Find the optimal split points for the given layer.\r\n * @function\r\n * @private\r\n * @param {Object} layer a layer object to be split into `splitCount` parts\r\n * @param {int} splitCount the number of pieces which the layer should be broken into\r\n * @return a reference to the layer passed in\r\n */\nfunction findOptimalSplit(layer, splitCount) {\n    if (splitCount === 1) {\n        return layer;\n    }\n\n    var chunkSize = layer.height / splitCount; // get initial chunk size for starters\n\n    // get initial splits and whitespace with initial chunk size; this will serve to determine the steps at which the chunk size will be increased\n\n    var _splitLayer = splitLayer(layer, chunkSize, splitCount),\n        minSplits = _splitLayer.splits,\n        minWhiteSpace = _splitLayer.whiteSpace;\n\n    var stepCount = 8; // number of attempts\n    var step = minWhiteSpace / stepCount;\n\n    // calculate splits while increasing the chunk size\n    for (var i = 1; i <= stepCount; i++) {\n        chunkSize += step;\n\n        var _splitLayer2 = splitLayer(layer, chunkSize, splitCount),\n            splits = _splitLayer2.splits,\n            whiteSpace = _splitLayer2.whiteSpace;\n\n        // store splits corresponding to the minimum whitespace\n\n\n        if (whiteSpace < minWhiteSpace) {\n            minWhiteSpace = whiteSpace;\n            minSplits = splits;\n        }\n    }\n\n    // apply split to the splits that result in the minimum of whitespace\n    minSplits.forEach(function (split) {\n        return split.splitBefore = true;\n    });\n    return layer;\n}\n\n/**\r\n * @function\r\n * @private\r\n * @param {Array} layers a list of layers to be updated (modified in place)\r\n * @param {int} sectionsAvailable the maximum number of sections to use\r\n * @param {int} mapHeight the rendered height of the map image\r\n * @return the same layers array as passed in\r\n */\nfunction allocateLayersToSections(layers, sectionsAvailable, mapHeight) {\n    assignLayerSplits(layers, Array(layers.length - 1).fill(true));\n    var bestSectionUsage = {}; // maps number of sections used to best height achieved\n    bestSectionUsage[layers.length] = {\n        height: Math.max.apply(Math, _toConsumableArray(layers.map(function (l) {\n            return l.height;\n        }))),\n        segments: Array(layers.length)\n    };\n    bestSectionUsage[layers.length].segments.fill(1);\n\n    var curSectionsUsed = layers.length;\n\n    var _loop = function _loop() {\n        var oldSegments = bestSectionUsage[curSectionsUsed].segments;\n        var normalizedLayers = oldSegments.map(function (seg, i) {\n            return layers[i].height / seg;\n        });\n        var worstLayerIndex = normalizedLayers.indexOf(Math.max.apply(Math, _toConsumableArray(normalizedLayers)));\n        var newSegments = oldSegments.map(function (seg, i) {\n            return i === worstLayerIndex ? seg + 1 : seg;\n        });\n        ++curSectionsUsed;\n        bestSectionUsage[curSectionsUsed] = {\n            height: Math.max.apply(Math, _toConsumableArray(newSegments.map(function (seg, i) {\n                return layers[i].height / seg;\n            }))),\n            segments: newSegments\n        };\n    };\n\n    while (curSectionsUsed < sectionsAvailable && bestSectionUsage[curSectionsUsed].height > mapHeight * 2) {\n        _loop();\n    }\n    while (curSectionsUsed > layers.length) {\n        if (bestSectionUsage[curSectionsUsed].height < 0.9 * bestSectionUsage[curSectionsUsed - 1].height) {\n            break;\n        }\n        --curSectionsUsed;\n    }\n    layers.forEach(function (l, i) {\n        return findOptimalSplit(l, bestSectionUsage[curSectionsUsed].segments[i]);\n    });\n    return { layers: layers, sectionsUsed: curSectionsUsed };\n}\n\n/**\r\n * Generate the structure for a legend given a set of layers.\r\n * @function\r\n * @param {Array} layerList a list of layers to be updated (modified in place)\r\n * @param {int} sectionsAvailable the maximum number of sections to use\r\n * @param {int} mapHeight the rendered height of the map image\r\n * @return an object with properties layers, sectionsUsed. (layerList is modified in place)\r\n */\nfunction makeLegend(layerList, sectionsAvailable, mapHeight) {\n    if (layerList.length > TOO_MANY_LAYERS) {\n        var layersPerSection = Math.ceil(layerList.length / sectionsAvailable);\n        var splitPoints = Array(layerList.length - 1).fill(0).map(function (v, i) {\n            return (i + 1) % layersPerSection === 0;\n        }); // I don't know why the useless fill is necessary\n        assignLayerSplits(layerList, splitPoints);\n        return { layers: layerList, sectionsUsed: sectionsAvailable };\n    }\n    if (layerList.length <= sectionsAvailable) {\n        return allocateLayersToSections(layerList, sectionsAvailable, mapHeight);\n    } else {\n        return packLayersIntoOptimalSections(layerList, sectionsAvailable);\n    }\n}\n\nmodule.exports = function () {\n    return { makeLegend: makeLegend, allComb: allComb, splitLayer: splitLayer, findOptimalSplit: findOptimalSplit };\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGVnZW5kLmpzP2I5NzYiXSwibmFtZXMiOlsiVE9PX01BTllfTEFZRVJTIiwiYWxsQ29tYiIsIk0iLCJOIiwibWF4VHJ1ZSIsIm1heEZhbHNlIiwiQyIsIm0iLCJuIiwiYSIsIm1hcCIsIngiLCJjb25jYXQiLCJiIiwiYXNzaWduTGF5ZXJTcGxpdHMiLCJsYXllcnMiLCJzcGxpdFBvaW50cyIsInNwbGl0QmVmb3JlIiwiZm9yRWFjaCIsInNwbGl0IiwiaSIsInBhY2tMYXllcnNJbnRvRXhhY3RTZWN0aW9ucyIsInNlY3Rpb25zIiwicG90ZW50aWFsU3BsaXRzIiwibGVuZ3RoIiwicmVxdWlyZWRTcGxpdHMiLCJwZXJtdXRhdGlvbnMiLCJiZXN0SGVpZ2h0IiwiTnVtYmVyIiwiTUFYX1ZBTFVFIiwiYmVzdFBlcm0iLCJoZWlnaHRzIiwiQXJyYXkiLCJmaWxsIiwiY3VyU2VjIiwibCIsImhlaWdodCIsInBlcm0iLCJoIiwiTWF0aCIsIm1heCIsInNlY3Rpb25zVXNlZCIsInBhY2tMYXllcnNJbnRvT3B0aW1hbFNlY3Rpb25zIiwic3BsaXRMYXllciIsImxheWVyIiwiY2h1bmtTaXplIiwic3BsaXRDb3VudCIsIml0ZW1ZT2Zmc2V0IiwieSIsIml0ZW1ZTWF4Iiwic3BsaXRzIiwic3BsaXRTaXplcyIsInRyYXZlcnNlIiwiaXRlbXMiLCJpdGVtIiwidHlwZSIsImhlYWRlckhlaWdodCIsInB1c2giLCJ3aGl0ZVNwYWNlIiwicmVkdWNlIiwiYWJzIiwiZmluZE9wdGltYWxTcGxpdCIsIm1pblNwbGl0cyIsIm1pbldoaXRlU3BhY2UiLCJzdGVwQ291bnQiLCJzdGVwIiwiYWxsb2NhdGVMYXllcnNUb1NlY3Rpb25zIiwic2VjdGlvbnNBdmFpbGFibGUiLCJtYXBIZWlnaHQiLCJiZXN0U2VjdGlvblVzYWdlIiwic2VnbWVudHMiLCJjdXJTZWN0aW9uc1VzZWQiLCJvbGRTZWdtZW50cyIsIm5vcm1hbGl6ZWRMYXllcnMiLCJzZWciLCJ3b3JzdExheWVySW5kZXgiLCJpbmRleE9mIiwibmV3U2VnbWVudHMiLCJtYWtlTGVnZW5kIiwibGF5ZXJMaXN0IiwibGF5ZXJzUGVyU2VjdGlvbiIsImNlaWwiLCJ2IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7QUFDQSxJQUFNQSxrQkFBa0IsRUFBeEI7O0FBRUE7O0FBRUE7Ozs7Ozs7O0FBUUEsU0FBU0MsT0FBVCxDQUFpQkMsQ0FBakIsRUFBb0JDLENBQXBCLEVBQXVCO0FBQ25CLFFBQU1DLFVBQVVELENBQWhCO0FBQ0EsUUFBTUUsV0FBV0gsSUFBSUMsQ0FBckI7QUFDQSxRQUFNRyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUQsQ0FBRCxDQUFELENBQVYsQ0FIbUIsQ0FHQztBQUNwQixTQUFLLElBQUlDLElBQUksQ0FBYixFQUFnQkEsS0FBS0wsQ0FBckIsRUFBd0IsRUFBRUssQ0FBMUIsRUFBNkI7QUFDekJELFVBQUVDLENBQUYsSUFBTyxFQUFQO0FBQ0EsYUFBSyxJQUFJQyxJQUFJLENBQWIsRUFBZ0JBLEtBQUtELENBQXJCLEVBQXdCLEVBQUVDLENBQTFCLEVBQTZCO0FBQ3pCO0FBQ0EsZ0JBQUlBLElBQUlKLE9BQUosSUFBZ0JHLElBQUlDLENBQUwsR0FBVUgsUUFBN0IsRUFBdUM7QUFBRTtBQUFXOztBQUVwRCxnQkFBTUksSUFBSUQsSUFBSSxDQUFKLEdBQVFGLEVBQUVDLElBQUksQ0FBTixFQUFTQyxJQUFJLENBQWIsRUFBZ0JFLEdBQWhCLENBQW9CO0FBQUEsdUJBQUtDLEVBQUVDLE1BQUYsQ0FBUyxJQUFULENBQUw7QUFBQSxhQUFwQixDQUFSLEdBQW1ELEVBQTdEO0FBQ0EsZ0JBQU1DLElBQUlOLElBQUlDLENBQUosR0FBUUYsRUFBRUMsSUFBSSxDQUFOLEVBQVNDLENBQVQsRUFBWUUsR0FBWixDQUFnQjtBQUFBLHVCQUFLQyxFQUFFQyxNQUFGLENBQVMsS0FBVCxDQUFMO0FBQUEsYUFBaEIsQ0FBUixHQUFnRCxFQUExRDs7QUFFQU4sY0FBRUMsQ0FBRixF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UUFBSVksVUFBVXZELE1BQVYsSUFBb0IyQyxpQkFBeEIsRUFBMkM7QUFDdkMsZUFBT0QseUJBQXlCYSxTQUF6QixFQUFvQ1osaUJBQXBDLEVBQXVEQyxTQUF2RCxDQUFQO0FBQ0gsS0FGRCxNQUVPO0FBQ0gsZUFBTzFCLDhCQUE4QnFDLFNBQTlCLEVBQXlDWixpQkFBekMsQ0FBUDtBQUNIO0FBQ0o7O0FBRURnQixPQUFPQyxPQUFQLEdBQWlCO0FBQUEsV0FBTyxFQUFFTixzQkFBRixFQUFjN0UsZ0JBQWQsRUFBdUIwQyxzQkFBdkIsRUFBbUNrQixrQ0FBbkMsRUFBUDtBQUFBLENBQWpCIiwiZmlsZSI6Ijc1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5jb25zdCBUT09fTUFOWV9MQVlFUlMgPSAxNTtcclxuXHJcbi8vIFRoaXMgZmlsZSByZWxhdGVzIHRvIGxlZ2VuZHMgb24gYW4gZXhwb3J0ZWQgbWFwLCBub3QgbGVnZW5kcyBpbiB0aGUgbGF5ZXIgc2VsZWN0b3JcclxuXHJcbi8qKlxyXG4gKiBHZW5lcmF0ZSBhbGwgcGVybXV0YXRpb25zIG9mIGxlbmd0aCBNLCB3aXRoIGV4YWN0bHkgTiBgdHJ1ZWAgdmFsdWVzLlxyXG4gKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtpbnR9IE0gdGhlIHNpemUgb2YgdGhlIGFycmF5IChtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwKVxyXG4gKiBAcGFyYW0ge2ludH0gTiB0aGUgbnVtYmVyIG9mIGVudHJpZXMgd2hpY2ggc2hvdWxkIGJlIHRydWUgKG11c3Qgbm90IGJlIGdyZWF0ZXIgdGhhbiBNKVxyXG4gKiBAcmV0dXJuIGFuIGFycmF5IGNvbnRhaW5pbmcgYWxsIHBvc3NpYmxlIHNpemUgTSBhcnJheXMgb2YgYm9vbGVhbiB2YWx1ZXMgd2l0aCBOIHRydWUgZW50cmllc1xyXG4gKi9cclxuZnVuY3Rpb24gYWxsQ29tYihNLCBOKSB7XHJcbiAgICBjb25zdCBtYXhUcnVlID0gTjtcclxuICAgIGNvbnN0IG1heEZhbHNlID0gTSAtIE47XHJcbiAgICBjb25zdCBDID0gW1tbW11dXV07IC8vIENbbV1bbl0gaXMgdGhlIHNvbHV0aW9uIHRvIGFsbF9jb21iKG0sbiksIENbMF1bMF0gc3RhcnRzIHdpdGggYW4gZW1wdHkgYXJyYXlcclxuICAgIGZvciAobGV0IG0gPSAxOyBtIDw9IE07ICsrbSkge1xyXG4gICAgICAgIENbbV0gPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBuID0gMDsgbiA8PSBtOyArK24pIHtcclxuICAgICAgICAgICAgLy8gaWYgdGhpcyB3b3VsZCBwbGFjZSBtb3JlIHRoYW4gdGhlIG1heCBudW1iZXIgb2YgdHJ1ZSBvciBmYWxzZSB2YWx1ZXMgd2UgZG9uJ3QgbmVlZCB0aGlzIHBhcnQgb2YgdGhlIGFycmF5XHJcbiAgICAgICAgICAgIGlmIChuID4gbWF4VHJ1ZSB8fCAobSAtIG4pID4gbWF4RmFsc2UpIHsgY29udGludWU7IH1cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGEgPSBuID4gMCA/IENbbSAtIDFdW24gLSAxXS5tYXAoeCA9PiB4LmNvbmNhdCh0cnVlKSkgOiBbXTtcclxuICAgICAgICAgICAgY29uc3QgYiA9IG0gPiBuID8gQ1ttIC0gMV1bbl0ubWFwKHggPT4geC5jb25jYXQoZmFsc2UpKSA6IFtdO1xyXG5cclxuICAgICAgICAgICAgQ1ttXVtuXSA9IGEuY29uY2F0KGIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBDW01dW05dO1xyXG59XHJcblxyXG4vKipcclxuICogQ29udmVuaWVuY2UgZnVuY3Rpb24gZm9yIGFzc2lnbmluZyB0aGUgYHNwbGl0QmVmb3JlYCBwcm9wZXJ0eSBvbiBsYXllcnMgYXQgc3BlY2lmaWVkIHBvaW50cy5cclxuICogTk9URTogdGhpcyBmdW5jdGlvbiBtb2RpZmllcyBkYXRhIGluIHBsYWNlXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge0FycmF5fSBsYXllcnMgYSBsaXN0IG9mIGxheWVycyB0byBiZSB1cGRhdGVkIChtb2RpZmllZCBpbiBwbGFjZSlcclxuICogQHBhcmFtIHtBcnJheX0gc3BsaXRQb2ludHMgYW4gYXJyYXkgb2YgYm9vbGVhbiB2YWx1ZXMgaW5kaWNhdGluZyBpZiB0aGUgbGF5ZXIgbGlzdCBzaG91bGQgYmUgc3BsaXQgYXQgdGhhdCBwb2ludCAobXVzdCBiZSBsYXllcnMubGVuZ3RoLTEgaW4gc2l6ZSlcclxuICogQHJldHVybiBsYXllcnMgdGhlIHNhbWUgYXJyYXkgYXMgcGFzc2VkIGluXHJcbiAqL1xyXG5mdW5jdGlvbiBhc3NpZ25MYXllclNwbGl0cyhsYXllcnMsIHNwbGl0UG9pbnRzKSB7XHJcbiAgICBsYXllcnNbMF0uc3BsaXRCZWZvcmUgPSBmYWxzZTtcclxuICAgIHNwbGl0UG9pbnRzLmZvckVhY2goKHNwbGl0LCBpKSA9PiBsYXllcnNbaSArIDFdLnNwbGl0QmVmb3JlID0gc3BsaXQpO1xyXG4gICAgcmV0dXJuIGxheWVycztcclxufVxyXG5cclxuLyoqXHJcbiAqIEdyb3VwcyBtdWx0aXBsZSBsYXllcnMgaW50byBlYWNoIHNlY3Rpb24gd2hpbGUgYXR0ZW1wdGluZyB0byBtaW5pbWl6ZSB0aGUgbGVnZW5kIGhlaWdodC5cclxuICogQWxsb2NhdGVzIHRvIHRoZSBleGFjdCBudW1iZXIgc3BlY2lmaWVkIGluIHRoZSBgc2VjdGlvbnNgIGFyZ3VtZW50LlxyXG4gKiBOT1RFOiBkb24ndCBjYWxsIHRoaXMgd2l0aCB0b28gbWFueSBsYXllcnMgYXMgaXQgdGVzdHMgYWxsIHBvc3NpYmxlIGdyb3VwaW5ncyBhbmQgY2FuIGJlXHJcbiAqIGNvbXB1dGF0aW9uYWxseSBleHBlbnNpdmUgKDwgMTUgbGF5ZXJzIHNob3VsZCBiZSBmaW5lKVxyXG4gKiBAZnVuY3Rpb25cclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtBcnJheX0gbGF5ZXJzIGEgbGlzdCBvZiBsYXllcnMgdG8gYmUgZml0dGVkXHJcbiAqIEBwYXJhbSB7aW50fSBzZWN0aW9ucyB0aGUgbnVtYmVyIG9mIHNlY3Rpb25zIHRvIHVzZVxyXG4gKiBAcmV0dXJuIHtPYmplY3R9IGFuIG9iamVjdCBpbiB0aGUgZm9ybSB7IGxheWVycywgc2VjdGlvbnNVc2VkLCBiZXN0UGVybSwgYmVzdEhlaWdodCB9XHJcbiAqL1xyXG5mdW5jdGlvbiBwYWNrTGF5ZXJzSW50b0V4YWN0U2VjdGlvbnMobGF5ZXJzLCBzZWN0aW9ucykge1xyXG4gICAgY29uc3QgcG90ZW50aWFsU3BsaXRzID0gbGF5ZXJzLmxlbmd0aCAtIDE7XHJcbiAgICBjb25zdCByZXF1aXJlZFNwbGl0cyA9IHNlY3Rpb25zIC0gMTtcclxuXHJcbiAgICBjb25zdCBwZXJtdXRhdGlvbnMgPSBhbGxDb21iKHBvdGVudGlhbFNwbGl0cywgcmVxdWlyZWRTcGxpdHMpO1xyXG4gICAgbGV0IGJlc3RIZWlnaHQgPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgbGV0IGJlc3RQZXJtID0gbnVsbDtcclxuICAgIGNvbnN0IGhlaWdodHMgPSBBcnJheShzZWN0aW9ucyk7XHJcblxyXG4gICAgcGVybXV0YXRpb25zLmZvckVhY2gocGVybSA9PiB7XHJcbiAgICAgICAgaGVpZ2h0cy5maWxsKDApO1xyXG4gICAgICAgIGxldCBjdXJTZWMgPSAwO1xyXG4gICAgICAgIGxheWVycy5mb3JFYWNoKChsLCBpKSA9PiB7XHJcbiAgICAgICAgICAgIGhlaWdodHNbY3VyU2VjXSArPSBsLmhlaWdodDtcclxuICAgICAgICAgICAgaWYgKHBlcm1baV0pIHtcclxuICAgICAgICAgICAgICAgICsrY3VyU2VjO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgaCA9IE1hdGgubWF4KC4uLmhlaWdodHMpO1xyXG4gICAgICAgIGlmIChoIDw9IGJlc3RIZWlnaHQpIHtcclxuICAgICAgICAgICAgYmVzdEhlaWdodCA9IGg7XHJcbiAgICAgICAgICAgIGJlc3RQZXJtID0gcGVybTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiB7IGxheWVycywgc2VjdGlvbnNVc2VkOiBzZWN0aW9ucywgYmVzdFBlcm0sIGJlc3RIZWlnaHQgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdyb3VwcyBtdWx0aXBsZSBsYXllcnMgaW50byBlYWNoIHNlY3Rpb24gd2hpbGUgYXR0ZW1wdGluZyB0byBtaW5pbWl6ZSB0aGUgbGVnZW5kIGhlaWdodC5cclxuICogUmVwZWF0cyBhcyBuZWNlc3NhcnkgdG8gdXNlIHRoZSBsZWFzdCBudW1iZXIgb2Ygc2VjdGlvbnMgd2hpbGUgc3RpbGwga2VlcGluZyB0aGUgcmVzdWx0aW5nXHJcbiAqIGxlZ2VuZCBoZWlnaHQgd2l0aGluIDIwJSBvZiBvcHRpbWFsLlxyXG4gKiBOT1RFOiBkb24ndCBjYWxsIHRoaXMgd2l0aCB0b28gbWFueSBsYXllcnMgYXMgaXQgdGVzdHMgYWxsIHBvc3NpYmxlIGdyb3VwaW5ncyBhbmQgY2FuIGJlXHJcbiAqIGNvbXB1dGF0aW9uYWxseSBleHBlbnNpdmUgKDwgMTUgbGF5ZXJzIHNob3VsZCBiZSBmaW5lKVxyXG4gKiBAZnVuY3Rpb25cclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtBcnJheX0gbGF5ZXJzIGEgbGlzdCBvZiBsYXllcnMgdG8gYmUgdXBkYXRlZCAobW9kaWZpZWQgaW4gcGxhY2UpXHJcbiAqIEBwYXJhbSB7aW50fSBzZWN0aW9ucyB0aGUgbnVtYmVyIG9mIHNlY3Rpb25zIHRvIHVzZVxyXG4gKiBAcmV0dXJuIHtPYmplY3R9IGFuIG9iamVjdCBpbiB0aGUgZm9ybSB7IGxheWVycywgc2VjdGlvbnNVc2VkIH1cclxuICovXHJcbmZ1bmN0aW9uIHBhY2tMYXllcnNJbnRvT3B0aW1hbFNlY3Rpb25zKGxheWVycywgc2VjdGlvbnMpIHtcclxuICAgIGxldCBiZXN0SGVpZ2h0ID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgIGxldCBiZXN0UGVybSA9IG51bGw7XHJcbiAgICBsZXQgc2VjdGlvbnNVc2VkID0gLTE7XHJcbiAgICBmb3IgKGxldCBuID0gc2VjdGlvbnM7IG4gPiAxOyAtLW4pIHtcclxuICAgICAgICBjb25zdCB7IGJlc3RQZXJtOiBwZXJtLCBiZXN0SGVpZ2h0OiBoZWlnaHQgfSA9IHBhY2tMYXllcnNJbnRvRXhhY3RTZWN0aW9ucyhsYXllcnMsIG4pO1xyXG4gICAgICAgIGlmIChoZWlnaHQgKiAwLjggPiBiZXN0SGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaGVpZ2h0IDw9IGJlc3RIZWlnaHQpIHtcclxuICAgICAgICAgICAgW2Jlc3RIZWlnaHQsIGJlc3RQZXJtLCBzZWN0aW9uc1VzZWRdID0gW2hlaWdodCwgcGVybSwgbl07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYXNzaWduTGF5ZXJTcGxpdHMobGF5ZXJzLCBiZXN0UGVybSk7XHJcbiAgICByZXR1cm4geyBsYXllcnMsIHNlY3Rpb25zVXNlZCB9O1xyXG59XHJcblxyXG4vKipcclxuICogU3BsaXQgYSBsYXllciBpbnRvIGBzcGxpdENvdW50YCBwYXJ0cyBvZiByb3VnaGx5IGVxdWFsIHNpemUuXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge09iamVjdH0gbGF5ZXIgYSBsYXllciBvYmplY3QgdG8gYmUgc3BsaXQgaW50byBgc3BsaXRDb3VudGAgcGFydHNcclxuICogQHBhcmFtIHtpbnR9IGNodW5rU2l6ZSB0aGUgbWF4aW11bSBoZWlnaHQgaW4gcGl4ZWxzIG9mIHRoZSBsZWdlbmQgc2VjdGlvbnNcclxuICogQHBhcmFtIHtpbnR9IHNwbGl0Q291bnQgdGhlIG51bWJlciBvZiBwaWVjZXMgd2hpY2ggdGhlIGxheWVyIHNob3VsZCBiZSBicm9rZW4gaW50b1xyXG4gKiBAcmV0dXJuIGFuIG9iamVjdCB3aXRoIHByb3BlcnRpZXMgd2hpdGVTcGFjZTogPGludD4sIHNwbGl0czogWyA8bGF5ZXJJdGVtcz4gXVxyXG4gKi9cclxuZnVuY3Rpb24gc3BsaXRMYXllcihsYXllciwgY2h1bmtTaXplLCBzcGxpdENvdW50KSB7XHJcbiAgICBsZXQgaXRlbVlPZmZzZXQgPSBsYXllci55O1xyXG4gICAgbGV0IGl0ZW1ZTWF4ID0gMDtcclxuICAgIGNvbnN0IHNwbGl0cyA9IFtdO1xyXG4gICAgY29uc3Qgc3BsaXRTaXplcyA9IEFycmF5KHNwbGl0Q291bnQpLmZpbGwoMCk7XHJcblxyXG4gICAgZnVuY3Rpb24gdHJhdmVyc2UoaXRlbXMpIHtcclxuICAgICAgICBpdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xyXG5cclxuICAgICAgICAgICAgaWYgKHNwbGl0Q291bnQgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgc3BsaXRTaXplc1tzcGxpdENvdW50IC0gMV0gPSBpdGVtWU1heCAtIGl0ZW1ZT2Zmc2V0OyAvLyBib3R0b20gb2YgY3VycmVudCBpdGVtIC0gb2Zmc2V0IGF0IGN1cnJlbnQgc2VjdGlvbiBzdGFydFxyXG5cclxuICAgICAgICAgICAgLy8gdGhpcyBpcyB0aGUgeSBjb29yZGluYXRlIG9mIHRoZSBpdGVtJ3MgYm90dG9tIGJvdW5kYXJ5XHJcbiAgICAgICAgICAgIGl0ZW1ZTWF4ID0gaXRlbS55ICsgKGl0ZW0udHlwZSA9PT0gJ2dyb3VwJyA/IGl0ZW0uaGVhZGVySGVpZ2h0IDogaXRlbS5oZWlnaHQpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGl0ZW1ZTWF4IC0gaXRlbVlPZmZzZXQgPj0gY2h1bmtTaXplKSB7XHJcbiAgICAgICAgICAgICAgICBzcGxpdENvdW50LS07XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gd2hpdGVzcGFjZSBpcyBjcmVhdGVkIHdoZW4gYW4gaXRlbSBzaXR0aW5nIG9uIHRoZSBib3VuZGFyeSBwdWxsZWQgaW50byB0aGUgbmV4dCBjaHVuaywgdGhlIHNwYWNlXHJcbiAgICAgICAgICAgICAgICAvLyBpdCB3b3VsZCBoYXZlIG9jY3VwaWVkIGlzIHdhc3RlZDsgdGhlIHdhc3RlIGRvdWJsZXMgYXMgdGhlIGVudGlyZSBpdGVtIGlzIG1vdmVkIHRvIHRoZSBuZXh0IGxlZ2VuZCBjaHVua1xyXG4gICAgICAgICAgICAgICAgaXRlbVlPZmZzZXQgPSBpdGVtLnk7XHJcbiAgICAgICAgICAgICAgICBzcGxpdHMucHVzaChpdGVtKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gJ2dyb3VwJykge1xyXG4gICAgICAgICAgICAgICAgdHJhdmVyc2UoaXRlbS5pdGVtcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICB0cmF2ZXJzZShsYXllci5pdGVtcyk7XHJcbiAgICBzcGxpdFNpemVzW3NwbGl0Q291bnQgLSAxXSA9IGxheWVyLmhlaWdodCAtIChpdGVtWU9mZnNldCAtIGxheWVyLnkpOyAvLyBib3R0b20gb2YgbGF5ZXIgLSBzdGFydCBvZiBsYXN0IHNlY3Rpb247IHN0YXJ0IG9mIGxhc3Qgc2VjdGlvbiA9IHRvdGFsIG9mZnNldCBvZiBsYXN0IHNlY3Rpb24gLSBvZmZzZXQgYXQgc3RhcnQgb2YgbGF5ZXJcclxuXHJcbiAgICAvLyB3aXRoIHdoaXRlU3BhY2Ugd2Ugd2FudCB0byBmaW5kIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIGNodW5rU2l6ZSBhbmQgdXNlZCBzcGFjZVxyXG4gICAgLy8gZm9yIGVhY2ggc2VjdGlvbiB1c2VkICh3aGl0ZVNwYWNlIG1heSBiZSBuZWdhdGl2ZSBpbmRpY2F0aW5nIHRoYXQgYSBzZWN0aW9uIGlzXHJcbiAgICAvLyBzcGlsbGluZyBwYXN0IHRoZSB0YXJnZXQgc2l6ZSk7IHRoZSB0b3RhbCBhbW91bnQgb2Ygd2hpdGVTcGFjZSBpcyBhIG1lYXN1cmUgb2YgaG93XHJcbiAgICAvLyBiYWQgdGhlIGxheWVyIGFsbG9jYXRpb24gd2FzXHJcbiAgICByZXR1cm4geyB3aGl0ZVNwYWNlOiBzcGxpdFNpemVzLnJlZHVjZSgoYSwgYikgPT4gYSArIE1hdGguYWJzKGNodW5rU2l6ZSAtIGIpLCAwKSwgc3BsaXRzIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBGaW5kIHRoZSBvcHRpbWFsIHNwbGl0IHBvaW50cyBmb3IgdGhlIGdpdmVuIGxheWVyLlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtPYmplY3R9IGxheWVyIGEgbGF5ZXIgb2JqZWN0IHRvIGJlIHNwbGl0IGludG8gYHNwbGl0Q291bnRgIHBhcnRzXHJcbiAqIEBwYXJhbSB7aW50fSBzcGxpdENvdW50IHRoZSBudW1iZXIgb2YgcGllY2VzIHdoaWNoIHRoZSBsYXllciBzaG91bGQgYmUgYnJva2VuIGludG9cclxuICogQHJldHVybiBhIHJlZmVyZW5jZSB0byB0aGUgbGF5ZXIgcGFzc2VkIGluXHJcbiAqL1xyXG5mdW5jdGlvbiBmaW5kT3B0aW1hbFNwbGl0KGxheWVyLCBzcGxpdENvdW50KSB7XHJcbiAgICBpZiAoc3BsaXRDb3VudCA9PT0gMSkge1xyXG4gICAgICAgIHJldHVybiBsYXllcjtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgY2h1bmtTaXplID0gbGF5ZXIuaGVpZ2h0IC8gc3BsaXRDb3VudDsgLy8gZ2V0IGluaXRpYWwgY2h1bmsgc2l6ZSBmb3Igc3RhcnRlcnNcclxuXHJcbiAgICAvLyBnZXQgaW5pdGlhbCBzcGxpdHMgYW5kIHdoaXRlc3BhY2Ugd2l0aCBpbml0aWFsIGNodW5rIHNpemU7IHRoaXMgd2lsbCBzZXJ2ZSB0byBkZXRlcm1pbmUgdGhlIHN0ZXBzIGF0IHdoaWNoIHRoZSBjaHVuayBzaXplIHdpbGwgYmUgaW5jcmVhc2VkXHJcbiAgICBsZXQgeyBzcGxpdHM6IG1pblNwbGl0cywgd2hpdGVTcGFjZTogbWluV2hpdGVTcGFjZSB9ID0gc3BsaXRMYXllcihsYXllciwgY2h1bmtTaXplLCBzcGxpdENvdW50KTtcclxuXHJcbiAgICBjb25zdCBzdGVwQ291bnQgPSA4OyAvLyBudW1iZXIgb2YgYXR0ZW1wdHNcclxuICAgIGNvbnN0IHN0ZXAgPSBtaW5XaGl0ZVNwYWNlIC8gc3RlcENvdW50O1xyXG5cclxuICAgIC8vIGNhbGN1bGF0ZSBzcGxpdHMgd2hpbGUgaW5jcmVhc2luZyB0aGUgY2h1bmsgc2l6ZVxyXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gc3RlcENvdW50OyBpKyspIHtcclxuICAgICAgICBjaHVua1NpemUgKz0gc3RlcDtcclxuXHJcbiAgICAgICAgbGV0IHsgc3BsaXRzLCB3aGl0ZVNwYWNlIH0gPSBzcGxpdExheWVyKGxheWVyLCBjaHVua1NpemUsIHNwbGl0Q291bnQpO1xyXG5cclxuICAgICAgICAvLyBzdG9yZSBzcGxpdHMgY29ycmVzcG9uZGluZyB0byB0aGUgbWluaW11bSB3aGl0ZXNwYWNlXHJcbiAgICAgICAgaWYgKHdoaXRlU3BhY2UgPCBtaW5XaGl0ZVNwYWNlKSB7XHJcbiAgICAgICAgICAgIG1pbldoaXRlU3BhY2UgPSB3aGl0ZVNwYWNlO1xyXG4gICAgICAgICAgICBtaW5TcGxpdHMgPSBzcGxpdHM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGFwcGx5IHNwbGl0IHRvIHRoZSBzcGxpdHMgdGhhdCByZXN1bHQgaW4gdGhlIG1pbmltdW0gb2Ygd2hpdGVzcGFjZVxyXG4gICAgbWluU3BsaXRzLmZvckVhY2goc3BsaXQgPT4gc3BsaXQuc3BsaXRCZWZvcmUgPSB0cnVlKTtcclxuICAgIHJldHVybiBsYXllcjtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge0FycmF5fSBsYXllcnMgYSBsaXN0IG9mIGxheWVycyB0byBiZSB1cGRhdGVkIChtb2RpZmllZCBpbiBwbGFjZSlcclxuICogQHBhcmFtIHtpbnR9IHNlY3Rpb25zQXZhaWxhYmxlIHRoZSBtYXhpbXVtIG51bWJlciBvZiBzZWN0aW9ucyB0byB1c2VcclxuICogQHBhcmFtIHtpbnR9IG1hcEhlaWdodCB0aGUgcmVuZGVyZWQgaGVpZ2h0IG9mIHRoZSBtYXAgaW1hZ2VcclxuICogQHJldHVybiB0aGUgc2FtZSBsYXllcnMgYXJyYXkgYXMgcGFzc2VkIGluXHJcbiAqL1xyXG5mdW5jdGlvbiBhbGxvY2F0ZUxheWVyc1RvU2VjdGlvbnMobGF5ZXJzLCBzZWN0aW9uc0F2YWlsYWJsZSwgbWFwSGVpZ2h0KSB7XHJcbiAgICBhc3NpZ25MYXllclNwbGl0cyhsYXllcnMsIEFycmF5KGxheWVycy5sZW5ndGggLSAxKS5maWxsKHRydWUpKTtcclxuICAgIGNvbnN0IGJlc3RTZWN0aW9uVXNhZ2UgPSB7fTsgLy8gbWFwcyBudW1iZXIgb2Ygc2VjdGlvbnMgdXNlZCB0byBiZXN0IGhlaWdodCBhY2hpZXZlZFxyXG4gICAgYmVzdFNlY3Rpb25Vc2FnZVtsYXllcnMubGVuZ3RoXSA9IHtcclxuICAgICAgICBoZWlnaHQ6IE1hdGgubWF4KC4uLmxheWVycy5tYXAobCA9PiBsLmhlaWdodCkpLFxyXG4gICAgICAgIHNlZ21lbnRzOiBBcnJheShsYXllcnMubGVuZ3RoKVxyXG4gICAgfTtcclxuICAgIGJlc3RTZWN0aW9uVXNhZ2VbbGF5ZXJzLmxlbmd0aF0uc2VnbWVudHMuZmlsbCgxKTtcclxuXHJcbiAgICBsZXQgY3VyU2VjdGlvbnNVc2VkID0gbGF5ZXJzLmxlbmd0aDtcclxuICAgIHdoaWxlIChjdXJTZWN0aW9uc1VzZWQgPCBzZWN0aW9uc0F2YWlsYWJsZSAmJiBiZXN0U2VjdGlvblVzYWdlW2N1clNlY3Rpb25zVXNlZF0uaGVpZ2h0ID4gbWFwSGVpZ2h0ICogMikge1xyXG4gICAgICAgIGNvbnN0IG9sZFNlZ21lbnRzID0gYmVzdFNlY3Rpb25Vc2FnZVtjdXJTZWN0aW9uc1VzZWRdLnNlZ21lbnRzO1xyXG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRMYXllcnMgPSBvbGRTZWdtZW50cy5tYXAoKHNlZywgaSkgPT4gbGF5ZXJzW2ldLmhlaWdodCAvIHNlZyk7XHJcbiAgICAgICAgY29uc3Qgd29yc3RMYXllckluZGV4ID0gbm9ybWFsaXplZExheWVycy5pbmRleE9mKE1hdGgubWF4KC4uLm5vcm1hbGl6ZWRMYXllcnMpKTtcclxuICAgICAgICBjb25zdCBuZXdTZWdtZW50cyA9IG9sZFNlZ21lbnRzLm1hcCgoc2VnLCBpKSA9PiBpID09PSB3b3JzdExheWVySW5kZXggPyBzZWcgKyAxIDogc2VnKTtcclxuICAgICAgICArK2N1clNlY3Rpb25zVXNlZDtcclxuICAgICAgICBiZXN0U2VjdGlvblVzYWdlW2N1clNlY3Rpb25zVXNlZF0gPSB7XHJcbiAgICAgICAgICAgIGhlaWdodDogTWF0aC5tYXgoLi4ubmV3U2VnbWVudHMubWFwKChzZWcsIGkpID0+IGxheWVyc1tpXS5oZWlnaHQgLyBzZWcpKSxcclxuICAgICAgICAgICAgc2VnbWVudHM6IG5ld1NlZ21lbnRzXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHdoaWxlIChjdXJTZWN0aW9uc1VzZWQgPiBsYXllcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgaWYgKGJlc3RTZWN0aW9uVXNhZ2VbY3VyU2VjdGlvbnNVc2VkXS5oZWlnaHQgPCAwLjkgKiBiZXN0U2VjdGlvblVzYWdlW2N1clNlY3Rpb25zVXNlZCAtIDFdLmhlaWdodCkge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgLS1jdXJTZWN0aW9uc1VzZWQ7XHJcbiAgICB9XHJcbiAgICBsYXllcnMuZm9yRWFjaCgobCwgaSkgPT4gZmluZE9wdGltYWxTcGxpdChsLCBiZXN0U2VjdGlvblVzYWdlW2N1clNlY3Rpb25zVXNlZF0uc2VnbWVudHNbaV0pKTtcclxuICAgIHJldHVybiB7IGxheWVycywgc2VjdGlvbnNVc2VkOiBjdXJTZWN0aW9uc1VzZWQgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdlbmVyYXRlIHRoZSBzdHJ1Y3R1cmUgZm9yIGEgbGVnZW5kIGdpdmVuIGEgc2V0IG9mIGxheWVycy5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7QXJyYXl9IGxheWVyTGlzdCBhIGxpc3Qgb2YgbGF5ZXJzIHRvIGJlIHVwZGF0ZWQgKG1vZGlmaWVkIGluIHBsYWNlKVxyXG4gKiBAcGFyYW0ge2ludH0gc2VjdGlvbnNBdmFpbGFibGUgdGhlIG1heGltdW0gbnVtYmVyIG9mIHNlY3Rpb25zIHRvIHVzZVxyXG4gKiBAcGFyYW0ge2ludH0gbWFwSGVpZ2h0IHRoZSByZW5kZXJlZCBoZWlnaHQgb2YgdGhlIG1hcCBpbWFnZVxyXG4gKiBAcmV0dXJuIGFuIG9iamVjdCB3aXRoIHByb3BlcnRpZXMgbGF5ZXJzLCBzZWN0aW9uc1VzZWQuIChsYXllckxpc3QgaXMgbW9kaWZpZWQgaW4gcGxhY2UpXHJcbiAqL1xyXG5mdW5jdGlvbiBtYWtlTGVnZW5kKGxheWVyTGlzdCwgc2VjdGlvbnNBdmFpbGFibGUsIG1hcEhlaWdodCkge1xyXG4gICAgaWYgKGxheWVyTGlzdC5sZW5ndGggPiBUT09fTUFOWV9MQVlFUlMpIHtcclxuICAgICAgICBjb25zdCBsYXllcnNQZXJTZWN0aW9uID0gTWF0aC5jZWlsKGxheWVyTGlzdC5sZW5ndGggLyBzZWN0aW9uc0F2YWlsYWJsZSk7XHJcbiAgICAgICAgY29uc3Qgc3BsaXRQb2ludHMgPSBBcnJheShsYXllckxpc3QubGVuZ3RoIC0gMSkuZmlsbCgwKS5tYXAoKHYsIGkpID0+IChpICsgMSkgJSBsYXllcnNQZXJTZWN0aW9uID09PSAwKTsgLy8gSSBkb24ndCBrbm93IHdoeSB0aGUgdXNlbGVzcyBmaWxsIGlzIG5lY2Vzc2FyeVxyXG4gICAgICAgIGFzc2lnbkxheWVyU3BsaXRzKGxheWVyTGlzdCwgc3BsaXRQb2ludHMpO1xyXG4gICAgICAgIHJldHVybiB7IGxheWVyczogbGF5ZXJMaXN0LCBzZWN0aW9uc1VzZWQ6IHNlY3Rpb25zQXZhaWxhYmxlIH07XHJcbiAgICB9XHJcbiAgICBpZiAobGF5ZXJMaXN0Lmxlbmd0aCA8PSBzZWN0aW9uc0F2YWlsYWJsZSkge1xyXG4gICAgICAgIHJldHVybiBhbGxvY2F0ZUxheWVyc1RvU2VjdGlvbnMobGF5ZXJMaXN0LCBzZWN0aW9uc0F2YWlsYWJsZSwgbWFwSGVpZ2h0KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHBhY2tMYXllcnNJbnRvT3B0aW1hbFNlY3Rpb25zKGxheWVyTGlzdCwgc2VjdGlvbnNBdmFpbGFibGUpO1xyXG4gICAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9ICgpID0+ICh7IG1ha2VMZWdlbmQsIGFsbENvbWIsIHNwbGl0TGF5ZXIsIGZpbmRPcHRpbWFsU3BsaXQgfSk7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9sZWdlbmQuanMiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar basemap = __webpack_require__(91);\nvar mapPrint = __webpack_require__(92);\n\nfunction esriMap(esriBundle, geoApi) {\n\n    var printModule = mapPrint(esriBundle);\n\n    var Map = function () {\n        _createClass(Map, [{\n            key: '_passthroughBindings',\n\n\n            // TODO when jshint parses instance fields properly we can change this from a property to a field\n            get: function get() {\n                return ['on', 'reorderLayer', 'addLayer', 'disableKeyboardNavigation', 'removeLayer', 'resize', 'reposition', 'centerAt', 'setZoom', 'centerAndZoom', 'toScreen', 'setExtent'];\n            }\n        }, {\n            key: '_passthroughProperties',\n            get: function get() {\n                return ['graphicsLayerIds', 'layerIds', 'spatialReference', 'extent'];\n            } // TODO when jshint parses instance fields properly we can change this from a property to a field\n\n        }], [{\n            key: 'Extent',\n            get: function get() {\n                return esriBundle.Extent;\n            }\n        }]);\n\n        function Map(domNode, opts) {\n            var _this = this;\n\n            _classCallCheck(this, Map);\n\n            this._passthroughBindings.forEach(function (bindingName) {\n                return _this[bindingName] = function () {\n                    var _map;\n\n                    return (_map = _this._map)[bindingName].apply(_map, arguments);\n                };\n            });\n            this._passthroughProperties.forEach(function (propName) {\n                var descriptor = {\n                    enumerable: true,\n                    get: function get() {\n                        return _this._map[propName];\n                    }\n                };\n                Object.defineProperty(_this, propName, descriptor);\n            });\n\n            this._map = new esriBundle.Map(domNode, { extent: Map.getExtentFromJson(opts.extent), lods: opts.lods });\n            if (opts.proxyUrl) {\n                this.proxy = opts.proxyUrl;\n            }\n\n            if (opts.basemaps) {\n                this.basemapGallery = basemap.initBasemaps(esriBundle, opts.basemaps, this._map);\n                this.basemapGallery.on('selection-change', function () {\n                    return _this.resetOverviewMap();\n                });\n            } else {\n                throw new Error('The basemaps option is required to and at least one basemap must be defined');\n            }\n\n            if (opts.scalebar) {\n                this.scalebar = new esriBundle.Scalebar({\n                    map: this._map,\n                    attachTo: opts.scalebar.attachTo,\n                    scalebarUnit: opts.scalebar.scalebarUnit\n                });\n                this.scalebar.show();\n            }\n\n            if (opts.overviewMap) {\n                this.initOverviewMap();\n            }\n\n            this.zoomPromise = Promise.resolve();\n            this.zoomCounter = 0;\n        }\n\n        _createClass(Map, [{\n            key: 'printLocal',\n            value: function printLocal(options) {\n                return printModule.printLocal(this._map, options);\n            }\n        }, {\n            key: 'printServer',\n            value: function printServer(options) {\n                return printModule.printServer(this._map, options);\n            }\n\n            /**\r\n             * Select a basemap which has been loaded in the basemapGallery\r\n             *\r\n             * @param {Object|String} value either an object with an id field or a string\r\n             */\n\n        }, {\n            key: 'selectBasemap',\n            value: function selectBasemap(value) {\n                if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {\n                    value = value.id;\n                }\n                this.basemapGallery.select(value);\n            }\n\n            /**\r\n             * Create an ESRI Extent object from extent setting JSON object.\r\n             *\r\n             * @function getExtentFromJson\r\n             * @param {Object} extentJson that follows config spec\r\n             * @return {Object} an ESRI Extent object\r\n             */\n\n        }, {\n            key: 'enhanceConfigExtent',\n\n\n            /**\r\n             * Take a JSON object with extent properties and convert it to an ESRI Extent.\r\n             * Reprojects to map projection if required.\r\n             *\r\n             * @param {Object} extent the extent to enhance\r\n             * @returns {Extent} extent cast in Extent prototype, and in map spatial reference\r\n             */\n            value: function enhanceConfigExtent(extent) {\n                var realExtent = Map.getExtentFromJson(extent);\n\n                if (geoApi.proj.isSpatialRefEqual(this._map.spatialReference, extent.spatialReference)) {\n                    return realExtent;\n                } else {\n                    return geoApi.proj.projectEsriExtent(realExtent, this._map.spatialReference);\n                }\n            }\n\n            /**\r\n             * Takes a location object in lat/long, converts to current map spatialReference using\r\n             * reprojection method in geoApi, and zooms to the point.\r\n             *\r\n             * @function zoomToLatLong\r\n             * @param {Object} location is a location object, containing geometries in the form of { longitude: <Number>, latitude: <Number> }\r\n             */\n\n        }, {\n            key: 'zoomToPoint',\n            value: function zoomToPoint(_ref) {\n                var longitude = _ref.longitude,\n                    latitude = _ref.latitude;\n\n\n                // get reprojected point and zoom to it\n                var geoPt = geoApi.proj.localProjectPoint(4326, this._map.spatialReference.wkid, [parseFloat(longitude), parseFloat(latitude)]);\n                var zoomPt = geoApi.proj.Point(geoPt[0], geoPt[1], this._map.spatialReference);\n\n                // give preference to the layer closest to a 50k scale ratio which is ideal for zoom\n                var sweetLod = Map.findClosestLOD(this._map.__tileInfo.lods, 50000);\n                this._map.centerAndZoom(zoomPt, Math.max(sweetLod.level, 0));\n            }\n\n            /**\r\n             * Finds the level of detail closest to the provided scale.\r\n             *\r\n             * @function findClosestLOD\r\n             * @param  {Array} lods     list of levels of detail objects\r\n             * @param  {Number} scale   scale value to search for in the levels of detail\r\n             * @return {Object}         the level of detail object closest to the scale\r\n             */\n\n        }, {\n            key: 'getNorthArrowAngle',\n\n\n            /**\r\n             * Calculate north arrow bearing. Angle returned is to to rotate north arrow image.\r\n             * http://www.movable-type.co.uk/scripts/latlong.html\r\n             * @function getNorthArrowAngle\r\n             * @returns {Number} map rotation angle (in degree)\r\n             */\n            value: function getNorthArrowAngle() {\n                // get center point in longitude and use bottom value for latitude\n                var pointB = geoApi.proj.localProjectPoint(this._map.extent.spatialReference, 'EPSG:4326', { x: (this._map.extent.xmin + this._map.extent.xmax) / 2, y: this._map.extent.ymin });\n\n                // north value (set longitude to be half of Canada extent (141 W, 52 W))\n                var pointA = { x: -96, y: 90 };\n\n                // set info on longitude and latitude\n                var dLon = (pointB.x - pointA.x) * Math.PI / 180;\n                var lat1 = pointA.y * Math.PI / 180;\n                var lat2 = pointB.y * Math.PI / 180;\n\n                // calculate bearing\n                var y = Math.sin(dLon) * Math.cos(lat2);\n                var x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);\n                var bearing = Math.atan2(y, x) * 180 / Math.PI;\n\n                // return angle (180 is pointiong north)\n                return ((bearing + 360) % 360).toFixed(1);\n            }\n\n            /**\r\n             * Calculate distance between min and max extent to know the pixel ratio between\r\n             * screen size and earth distance.\r\n             * http://www.movable-type.co.uk/scripts/latlong.html\r\n             * @function getScaleRatio\r\n             * @param {Number} mapWidth optional the map width to use to calculate ratio\r\n             * @returns {Object} contain information about the scale\r\n             *                               - distance: distance between min and max extentId\r\n             *                               - ratio: measure for 1 pixel in earth distance\r\n             *                               - units: array of units [metric, imperial]\r\n             */\n\n        }, {\n            key: 'getScaleRatio',\n            value: function getScaleRatio() {\n                var mapWidth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n                var map = this._map;\n\n                // get left and right maximum value point to calculate distance from\n                var pointA = geoApi.proj.localProjectPoint(map.spatialReference, 'EPSG:4326', { x: map.extent.xmin, y: (map.extent.ymin + map.extent.ymax) / 2 });\n                var pointB = geoApi.proj.localProjectPoint(map.spatialReference, 'EPSG:4326', { x: map.extent.xmax, y: (map.extent.ymin + map.extent.ymax) / 2 });\n\n                // Haversine formula to calculate distance\n                var R = 6371e3; // earth radius in meters\n                var rad = Math.PI / 180;\n                var phy1 = pointA.y * rad; // radiant\n                var phy2 = pointB.y * rad; // radiant\n                var deltaPhy = (pointB.y - pointA.y) * rad; // radiant\n                var deltaLambda = (pointB.x - pointA.x) * rad; // radiant\n\n                var a = Math.sin(deltaPhy / 2) * Math.sin(deltaPhy / 2) + Math.cos(phy1) * Math.cos(phy2) * Math.sin(deltaLambda / 2) * Math.sin(deltaLambda / 2);\n                var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n                var d = R * c;\n\n                // set map / image width (if mapWidth = 0, use map.width)\n                var width = mapWidth ? mapWidth : map.width;\n\n                // get unit from distance, set distance and ratio (earth size for 1 pixel)\n                var units = [d > 1000 ? 'km' : 'm', d > 1600 ? 'mi' : 'ft'];\n                var distance = d > 1000 ? d / 1000 : d;\n                var ratio = distance / width;\n\n                return { distance: distance, ratio: ratio, units: units };\n            }\n\n            /**\r\n             * Compares to sets of co-ordinates for extents (valid for both x and y). If center of input co-ordinates falls outside\r\n             * map co-ordiantes, function will adjust them so the center is inside the map co-ordinates.\r\n             *\r\n             * @function clipExtentCoords\r\n             * @private\r\n             * @param {Numeric} mid      middle of the the range to test\r\n             * @param {Numeric} max      maximum value of the range to test\r\n             * @param {Numeric} min      minimum value of the range to test\r\n             * @param {Numeric} mapMax   maximum value of the map range\r\n             * @param {Numeric} mapMin   minimum value of the map range\r\n             * @param {Numeric} len      length of the adjusted range, if adjusted\r\n             * @return {Array}           two element array of Numeric, containing result max and min values\r\n             */\n\n        }, {\n            key: 'initOverviewMap',\n            value: function initOverviewMap() {\n                this.overviewMap = new esriBundle.OverviewMap({ map: this._map, expandFactor: 1, visible: true });\n                this.overviewMap.startup();\n            }\n        }, {\n            key: 'resetOverviewMap',\n            value: function resetOverviewMap() {\n                this.overviewMap.destroy();\n                this.initOverviewMap();\n            }\n\n            /**\r\n             * Changes the zoom level by the specified value relative to the current level; can be negative.\r\n             * To avoid multiple chained zoom animations when rapidly pressing the zoom in/out icons, we\r\n             * update the zoom level only when the one before it resolves with the net zoom change.\r\n             *\r\n             * @function shiftZoom\r\n             * @param  {number} byValue a number of zoom levels to shift by\r\n             */\n\n        }, {\n            key: 'shiftZoom',\n            value: function shiftZoom(byValue) {\n                var _this2 = this;\n\n                this.zoomCounter += byValue;\n                this.zoomPromise.then(function () {\n                    if (_this2.zoomCounter !== 0) {\n                        var zoomValue = _this2._map.getZoom() + _this2.zoomCounter;\n                        var zoomPromise = Promise.resolve(_this2.setZoom(zoomValue));\n                        _this2.zoomCounter = 0;\n\n                        // undefined signals we've zoomed in/out as far as we can\n                        if (typeof zoomPromise !== 'undefined') {\n                            _this2.zoomPromise = zoomPromise;\n                        }\n                    }\n                });\n            }\n\n            /**\r\n             * Sets or gets map default config values.\r\n             *\r\n             * @function mapDefault\r\n             * @param {String} key  name of the default property\r\n             * @param {Any} [value] optional value to set for the specified default property\r\n             */\n\n        }, {\n            key: 'mapDefault',\n            value: function mapDefault(key, value) {\n                if (typeof value === 'undefined') {\n                    return esriBundle.esriConfig.defaults.map[key];\n                } else {\n                    esriBundle.esriConfig.defaults.map[key] = value;\n                }\n            }\n\n            /**\r\n             * Set proxy service URL to avoid same origin issues.\r\n             */\n\n        }, {\n            key: 'proxy',\n            set: function set(proxyUrl) {\n                esriBundle.esriConfig.defaults.io.proxyUrl = proxyUrl;\n            },\n            get: function get() {\n                return esriBundle.esriConfig.defaults.io.proxyUrl;\n            }\n        }, {\n            key: 'basemapGallery',\n            set: function set(val) {\n                this._basemapGallery = val;\n            },\n            get: function get() {\n                return this._basemapGallery;\n            }\n        }, {\n            key: 'scalebar',\n            set: function set(val) {\n                this._scalebar = val;\n            },\n            get: function get() {\n                return this._scalebar;\n            }\n        }, {\n            key: 'overviewMap',\n            set: function set(val) {\n                this._overviewMap = val;\n            },\n            get: function get() {\n                return this._overviewMap;\n            }\n        }], [{\n            key: 'getExtentFromJson',\n            value: function getExtentFromJson(extentJson) {\n\n                return esriBundle.Extent({ xmin: extentJson.xmin, ymin: extentJson.ymin,\n                    xmax: extentJson.xmax, ymax: extentJson.ymax,\n                    spatialReference: { wkid: extentJson.spatialReference.wkid } });\n            }\n        }, {\n            key: 'findClosestLOD',\n            value: function findClosestLOD(lods, scale) {\n                var diffs = lods.map(function (lod) {\n                    return Math.abs(lod.scale - scale);\n                });\n                var lodIdx = diffs.indexOf(Math.min.apply(Math, _toConsumableArray(diffs)));\n                return lods[lodIdx];\n            }\n        }, {\n            key: 'clipExtentCoords',\n            value: function clipExtentCoords(mid, max, min, mapMax, mapMin, len) {\n\n                if (mid > mapMax) {\n                    max = mapMax;\n                    min = mapMax - len;\n                } else if (mid < mapMin) {\n                    max = mapMin + len;\n                    min = mapMin;\n                }\n                return [max, min];\n            }\n\n            /**\r\n             * Checks if the center of the given extent is outside of the maximum extent. If it is,\r\n             * will determine an adjusted extent with a center inside the maximum extent.  Returns both\r\n             * an indicator flag if an adjustment happened, and the adjusted extent.\r\n             *\r\n             * @function enforceBoundary\r\n             * @param {Object} extent      an ESRI extent to test\r\n             * @param {Object} maxExtent   an ESRI extent indicating the boundary of the map\r\n             * @return {Object}            an object with two properties. adjusted - boolean, true if extent was adjusted. newExtent - object, adjusted ESRI extent\r\n             */\n\n        }, {\n            key: 'enforceBoundary',\n            value: function enforceBoundary(extent, maxExtent) {\n                // clone extent\n                var newExtent = esriBundle.Extent(extent.toJson());\n\n                // determine dimensions of adjusted extent.\n                // same as input, unless input is so large it consumes max.\n                // in that case, we shrink to the max. This avoids the \"washing machine\"\n                // bug where we over-correct past the valid range,\n                // and achieve infinite oscillating pans\n                var height = Math.min(extent.getHeight(), maxExtent.getHeight());\n                var width = Math.min(extent.getWidth(), maxExtent.getWidth());\n                var center = extent.getCenter();\n\n                var _clipExtentCoords = this.clipExtentCoords(center.x, newExtent.xmax, newExtent.xmin, maxExtent.xmax, maxExtent.xmin, width);\n\n                var _clipExtentCoords2 = _slicedToArray(_clipExtentCoords, 2);\n\n                newExtent.xmax = _clipExtentCoords2[0];\n                newExtent.xmin = _clipExtentCoords2[1];\n\n                var _clipExtentCoords3 = this.clipExtentCoords(center.y, newExtent.ymax, newExtent.ymin, maxExtent.ymax, maxExtent.ymin, height);\n\n                var _clipExtentCoords4 = _slicedToArray(_clipExtentCoords3, 2);\n\n                newExtent.ymax = _clipExtentCoords4[0];\n                newExtent.ymin = _clipExtentCoords4[1];\n\n\n                return {\n                    newExtent: newExtent,\n                    adjusted: !extent.contains(newExtent) // true if we adjusted the extent\n                };\n            }\n        }]);\n\n        return Map;\n    }();\n\n    return Map;\n}\n\n/**\r\n  * The `MapManager` module exports an object with the following properties:\r\n  * - `Extent` esri/geometry type\r\n  * - `Map` esri/map type\r\n  * - `OverviewMap` esri/dijit/OverviewMap type\r\n  * - `Scalebar` sri/dijit/Scalebar type\r\n  * - `getExtentFromSetting function to create an ESRI Extent object from extent setting JSON object.\r\n  * - `setupMap` function that interates over config settings and apply logic for any items present.\r\n  * - `setProxy` function to set proxy service URL to avoid same origin issues\r\n  */\n\n// mapManager module, provides function to setup a map\nmodule.exports = function (esriBundle, geoApi) {\n    return esriMap(esriBundle, geoApi);\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbWFwL2VzcmlNYXAuanM/Mjk0MiJdLCJuYW1lcyI6WyJiYXNlbWFwIiwicmVxdWlyZSIsIm1hcFByaW50IiwiZXNyaU1hcCIsImVzcmlCdW5kbGUiLCJnZW9BcGkiLCJwcmludE1vZHVsZSIsIk1hcCIsIkV4dGVudCIsImRvbU5vZGUiLCJvcHRzIiwiX3Bhc3N0aHJvdWdoQmluZGluZ3MiLCJmb3JFYWNoIiwiYmluZGluZ05hbWUiLCJfbWFwIiwiX3Bhc3N0aHJvdWdoUHJvcGVydGllcyIsImRlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiZ2V0IiwicHJvcE5hbWUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4dGVudCIsImdldEV4dGVudEZyb21Kc29uIiwibG9kcyIsInByb3h5VXJsIiwicHJveHkiLCJiYXNlbWFwcyIsImJhc2VtYXBHYWxsZXJ5IiwiaW5pdEJhc2VtYXBzIiwib24iLCJyZXNldE92ZXJ2aWV3TWFwIiwiRXJyb3IiLCJzY2FsZWJhciIsIlNjYWxlYmFyIiwibWFwIiwiYXR0YWNoVG8iLCJzY2FsZWJhclVuaXQiLCJzaG93Iiwib3ZlcnZpZXdNYXAiLCJpbml0T3ZlcnZpZXdNYXAiLCJ6b29tUHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwiem9vbUNvdW50ZXIiLCJvcHRpb25zIiwicHJpbnRMb2NhbCIsInByaW50U2VydmVyIiwidmFsdWUiLCJpZCIsInNlbGVjdCIsInJlYWxFeHRlbnQiLCJwcm9qIiwiaXNTcGF0aWFsUmVmRXF1YWwiLCJzcGF0aWFsUmVmZXJlbmNlIiwicHJvamVjdEVzcmlFeHRlbnQiLCJsb25naXR1ZGUiLCJsYXRpdHVkZSIsImdlb1B0IiwibG9jYWxQcm9qZWN0UG9pbnQiLCJ3a2lkIiwicGFyc2VGbG9hdCIsInpvb21QdCIsIlBvaW50Iiwic3dlZXRMb2QiLCJmaW5kQ2xvc2VzdExPRCIsIl9fdGlsZUluZm8iLCJjZW50ZXJBbmRab29tIiwiTWF0aCIsIm1heCIsImxldmVsIiwicG9pbnRCIiwieCIsInhtaW4iLCJ4bWF4IiwieSIsInltaW4iLCJwb2ludEEiLCJkTG9uIiwiUEkiLCJsYXQxIiwibGF0MiIsInNpbiIsImNvcyIsImJlYXJpbmciLCJhdGFuMiIsInRvRml4ZWQiLCJtYXBXaWR0aCIsInltYXgiLCJSIiwicmFkIiwicGh5MSIsInBoeTIiLCJkZWx0YVBoeSIsImRlbHRhTGFtYmRhIiwiYSIsImMiLCJzcXJ0IiwiZCIsIndpZHRoIiwidW5pdHMiLCJkaXN0YW5jZSIsInJhdGlvIiwiT3ZlcnZpZXdNYXAiLCJleHBhbmRGYWN0b3IiLCJ2aXNpYmxlIiwic3RhcnR1cCIsImRlc3Ryb3kiLCJieVZhbHVlIiwidGhlbiIsInpvb21WYWx1ZSIsImdldFpvb20iLCJzZXRab29tIiwia2V5IiwiZXNyaUNvbmZpZyIsImRlZmF1bHRzIiwiaW8iLCJ2YWwiLCJfYmFzZW1hcEdhbGxlcnkiLCJfc2NhbGViYXIiLCJfb3ZlcnZpZXdNYXAiLCJleHRlbnRKc29uIiwic2NhbGUiLCJkaWZmcyIsImFicyIsImxvZCIsImxvZElkeCIsImluZGV4T2YiLCJtaW4iLCJtaWQiLCJtYXBNYXgiLCJtYXBNaW4iLCJsZW4iLCJtYXhFeHRlbnQiLCJuZXdFeHRlbnQiLCJ0b0pzb24iLCJoZWlnaHQiLCJnZXRIZWlnaHQiLCJnZXRXaWR0aCIsImNlbnRlciIsImdldENlbnRlciIsImNsaXBFeHRlbnRDb29yZHMiLCJhZGp1c3RlZCIsImNvbnRhaW5zIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7OztBQUNBLElBQU1BLFVBQVUsbUJBQUFDLENBQVEsRUFBUixDQUFoQjtBQUNBLElBQU1DLFdBQVcsbUJBQUFELENBQVEsRUFBUixDQUFqQjs7QUFFQSxTQUFTRSxPQUFULENBQWlCQyxVQUFqQixFQUE2QkMsTUFBN0IsRUFBcUM7O0FBRWpDLFFBQU1DLGNBQWNKLFNBQVNFLFVBQVQsQ0FBcEI7O0FBRmlDLFFBSTNCRyxHQUoyQjtBQUFBO0FBQUE7OztB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ZmlsZSI6Ijc2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5jb25zdCBiYXNlbWFwID0gcmVxdWlyZSgnLi9iYXNlbWFwLmpzJyk7XHJcbmNvbnN0IG1hcFByaW50ID0gcmVxdWlyZSgnLi9wcmludC5qcycpO1xyXG5cclxuZnVuY3Rpb24gZXNyaU1hcChlc3JpQnVuZGxlLCBnZW9BcGkpIHtcclxuXHJcbiAgICBjb25zdCBwcmludE1vZHVsZSA9IG1hcFByaW50KGVzcmlCdW5kbGUpO1xyXG5cclxuICAgIGNsYXNzIE1hcCB7XHJcblxyXG4gICAgICAgIHN0YXRpYyBnZXQgRXh0ZW50ICgpIHsgcmV0dXJuIGVzcmlCdW5kbGUuRXh0ZW50OyB9XHJcblxyXG4gICAgICAgIC8vIFRPRE8gd2hlbiBqc2hpbnQgcGFyc2VzIGluc3RhbmNlIGZpZWxkcyBwcm9wZXJseSB3ZSBjYW4gY2hhbmdlIHRoaXMgZnJvbSBhIHByb3BlcnR5IHRvIGEgZmllbGRcclxuICAgICAgICBnZXQgX3Bhc3N0aHJvdWdoQmluZGluZ3MgKCkgeyByZXR1cm4gW1xyXG4gICAgICAgICAgICAnb24nLCAncmVvcmRlckxheWVyJywgJ2FkZExheWVyJywgJ2Rpc2FibGVLZXlib2FyZE5hdmlnYXRpb24nLCAncmVtb3ZlTGF5ZXInLCAncmVzaXplJywgJ3JlcG9zaXRpb24nLFxyXG4gICAgICAgICAgICAnY2VudGVyQXQnLCAnc2V0Wm9vbScsICdjZW50ZXJBbmRab29tJywgJ3RvU2NyZWVuJywgJ3NldEV4dGVudCdcclxuICAgICAgICBdOyB9XHJcbiAgICAgICAgZ2V0IF9wYXNzdGhyb3VnaFByb3BlcnRpZXMgKCkgeyByZXR1cm4gWydncmFwaGljc0xheWVySWRzJywgJ2xheWVySWRzJywgJ3NwYXRpYWxSZWZlcmVuY2UnLCAnZXh0ZW50J107IH0gLy8gVE9ETyB3aGVuIGpzaGludCBwYXJzZXMgaW5zdGFuY2UgZmllbGRzIHByb3Blcmx5IHdlIGNhbiBjaGFuZ2UgdGhpcyBmcm9tIGEgcHJvcGVydHkgdG8gYSBmaWVsZFxyXG5cclxuICAgICAgICBjb25zdHJ1Y3RvciAoZG9tTm9kZSwgb3B0cykge1xyXG5cclxuICAgICAgICAgICAgdGhpcy5fcGFzc3Rocm91Z2hCaW5kaW5ncy5mb3JFYWNoKGJpbmRpbmdOYW1lID0+XHJcbiAgICAgICAgICAgICAgICB0aGlzW2JpbmRpbmdOYW1lXSA9ICguLi5hcmdzKSA9PiB0aGlzLl9tYXBbYmluZGluZ05hbWVdKC4uLmFyZ3MpKTtcclxuICAgICAgICAgICAgdGhpcy5fcGFzc3Rocm91Z2hQcm9wZXJ0aWVzLmZvckVhY2gocHJvcE5hbWUgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IHtcclxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGdldDogKCkgPT4gdGhpcy5fbWFwW3Byb3BOYW1lXVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBwcm9wTmFtZSwgZGVzY3JpcHRvcik7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5fbWFwID0gbmV3IGVzcmlCdW5kbGUuTWFwKGRvbU5vZGUsIHsgZXh0ZW50OiBNYXAuZ2V0RXh0ZW50RnJvbUpzb24ob3B0cy5leHRlbnQpLCBsb2RzOiBvcHRzLmxvZHMgfSk7XHJcbiAgICAgICAgICAgIGlmIChvcHRzLnByb3h5VXJsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb3h5ID0gb3B0cy5wcm94eVVybDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKG9wdHMuYmFzZW1hcHMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYmFzZW1hcEdhbGxlcnkgPSBiYXNlbWFwLmluaXRCYXNlbWFwcyhlc3JpQnVuZGxlLCBvcHRzLmJhc2VtYXBzLCB0aGlzLl9tYXApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5iYXNlbWFwR2FsbGVyeS5vbignc2VsZWN0aW9uLWNoYW5nZScsICgpID0+IHRoaXMucmVzZXRPdmVydmlld01hcCgpKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGJhc2VtYXBzIG9wdGlvbiBpcyByZXF1aXJlZCB0byBhbmQgYXQgbGVhc3Qgb25lIGJhc2VtYXAgbXVzdCBiZSBkZWZpbmVkJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChvcHRzLnNjYWxlYmFyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjYWxlYmFyID0gbmV3IGVzcmlCdW5kbGUuU2NhbGViYXIoe1xyXG4gICAgICAgICAgICAgICAgICAgIG1hcDogdGhpcy5fbWFwLFxyXG4gICAgICAgICAgICAgICAgICAgIGF0dGFjaFRvOiBvcHRzLnNjYWxlYmFyLmF0dGFjaFRvLFxyXG4gICAgICAgICAgICAgICAgICAgIHNjYWxlYmFyVW5pdDogb3B0cy5zY2FsZWJhci5zY2FsZWJhclVuaXRcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zY2FsZWJhci5zaG93KCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChvcHRzLm92ZXJ2aWV3TWFwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRPdmVydmlld01hcCgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLnpvb21Qcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuem9vbUNvdW50ZXIgPSAwO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHByaW50TG9jYWwgKG9wdGlvbnMpIHsgcmV0dXJuIHByaW50TW9kdWxlLnByaW50TG9jYWwodGhpcy5fbWFwLCBvcHRpb25zKTsgfVxyXG4gICAgICAgIHByaW50U2VydmVyIChvcHRpb25zKSB7IHJldHVybiBwcmludE1vZHVsZS5wcmludFNlcnZlcih0aGlzLl9tYXAsIG9wdGlvbnMpOyB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNlbGVjdCBhIGJhc2VtYXAgd2hpY2ggaGFzIGJlZW4gbG9hZGVkIGluIHRoZSBiYXNlbWFwR2FsbGVyeVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSB2YWx1ZSBlaXRoZXIgYW4gb2JqZWN0IHdpdGggYW4gaWQgZmllbGQgb3IgYSBzdHJpbmdcclxuICAgICAgICAgKi9cclxuICAgICAgICBzZWxlY3RCYXNlbWFwICh2YWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5pZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmJhc2VtYXBHYWxsZXJ5LnNlbGVjdCh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGUgYW4gRVNSSSBFeHRlbnQgb2JqZWN0IGZyb20gZXh0ZW50IHNldHRpbmcgSlNPTiBvYmplY3QuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZnVuY3Rpb24gZ2V0RXh0ZW50RnJvbUpzb25cclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXh0ZW50SnNvbiB0aGF0IGZvbGxvd3MgY29uZmlnIHNwZWNcclxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGFuIEVTUkkgRXh0ZW50IG9iamVjdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHN0YXRpYyBnZXRFeHRlbnRGcm9tSnNvbiAoZXh0ZW50SnNvbikge1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGVzcmlCdW5kbGUuRXh0ZW50KHsgeG1pbjogZXh0ZW50SnNvbi54bWluLCB5bWluOiBleHRlbnRKc29uLnltaW4sXHJcbiAgICAgICAgICAgICAgICB4bWF4OiBleHRlbnRKc29uLnhtYXgsIHltYXg6IGV4dGVudEpzb24ueW1heCxcclxuICAgICAgICAgICAgICAgIHNwYXRpYWxSZWZlcmVuY2U6IHsgd2tpZDogZXh0ZW50SnNvbi5zcGF0aWFsUmVmZXJlbmNlLndraWQgfSB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRha2UgYSBKU09OIG9iamVjdCB3aXRoIGV4dGVudCBwcm9wZXJ0aWVzIGFuZCBjb252ZXJ0IGl0IHRvIGFuIEVTUkkgRXh0ZW50LlxyXG4gICAgICAgICAqIFJlcHJvamVjdHMgdG8gbWFwIHByb2plY3Rpb24gaWYgcmVxdWlyZWQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXh0ZW50IHRoZSBleHRlbnQgdG8gZW5oYW5jZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtFeHRlbnR9IGV4dGVudCBjYXN0IGluIEV4dGVudCBwcm90b3R5cGUsIGFuZCBpbiBtYXAgc3BhdGlhbCByZWZlcmVuY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBlbmhhbmNlQ29uZmlnRXh0ZW50IChleHRlbnQpIHtcclxuICAgICAgICAgICAgY29uc3QgcmVhbEV4dGVudCA9IE1hcC5nZXRFeHRlbnRGcm9tSnNvbihleHRlbnQpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGdlb0FwaS5wcm9qLmlzU3BhdGlhbFJlZkVxdWFsKHRoaXMuX21hcC5zcGF0aWFsUmVmZXJlbmNlLCBleHRlbnQuc3BhdGlhbFJlZmVyZW5jZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZWFsRXh0ZW50O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdlb0FwaS5wcm9qLnByb2plY3RFc3JpRXh0ZW50KHJlYWxFeHRlbnQsIHRoaXMuX21hcC5zcGF0aWFsUmVmZXJlbmNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGFrZXMgYSBsb2NhdGlvbiBvYmplY3QgaW4gbGF0L2xvbmcsIGNvbnZlcnRzIHRvIGN1cnJlbnQgbWFwIHNwYXRpYWxSZWZlcmVuY2UgdXNpbmdcclxuICAgICAgICAgKiByZXByb2plY3Rpb24gbWV0aG9kIGluIGdlb0FwaSwgYW5kIHpvb21zIHRvIHRoZSBwb2ludC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBmdW5jdGlvbiB6b29tVG9MYXRMb25nXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGxvY2F0aW9uIGlzIGEgbG9jYXRpb24gb2JqZWN0LCBjb250YWluaW5nIGdlb21ldHJpZXMgaW4gdGhlIGZvcm0gb2YgeyBsb25naXR1ZGU6IDxOdW1iZXI+LCBsYXRpdHVkZTogPE51bWJlcj4gfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHpvb21Ub1BvaW50ICh7IGxvbmdpdHVkZSwgbGF0aXR1ZGUgfSkge1xyXG5cclxuICAgICAgICAgICAgLy8gZ2V0IHJlcHJvamVjdGVkIHBvaW50IGFuZCB6b29tIHRvIGl0XHJcbiAgICAgICAgICAgIGNvbnN0IGdlb1B0ID0gZ2VvQXBpLnByb2oubG9jYWxQcm9qZWN0UG9pbnQoNDMyNiwgdGhpcy5fbWFwLnNwYXRpYWxSZWZlcmVuY2Uud2tpZCxcclxuICAgICAgICAgICAgICAgIFtwYXJzZUZsb2F0KGxvbmdpdHVkZSksIHBhcnNlRmxvYXQobGF0aXR1ZGUpXSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHpvb21QdCA9IGdlb0FwaS5wcm9qLlBvaW50KGdlb1B0WzBdLCBnZW9QdFsxXSwgdGhpcy5fbWFwLnNwYXRpYWxSZWZlcmVuY2UpO1xyXG5cclxuICAgICAgICAgICAgLy8gZ2l2ZSBwcmVmZXJlbmNlIHRvIHRoZSBsYXllciBjbG9zZXN0IHRvIGEgNTBrIHNjYWxlIHJhdGlvIHdoaWNoIGlzIGlkZWFsIGZvciB6b29tXHJcbiAgICAgICAgICAgIGNvbnN0IHN3ZWV0TG9kID0gTWFwLmZpbmRDbG9zZXN0TE9EKHRoaXMuX21hcC5fX3RpbGVJbmZvLmxvZHMsIDUwMDAwKTtcclxuICAgICAgICAgICAgdGhpcy5fbWFwLmNlbnRlckFuZFpvb20oem9vbVB0LCBNYXRoLm1heChzd2VldExvZC5sZXZlbCwgMCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRmluZHMgdGhlIGxldmVsIG9mIGRldGFpbCBjbG9zZXN0IHRvIHRoZSBwcm92aWRlZCBzY2FsZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBmdW5jdGlvbiBmaW5kQ2xvc2VzdExPRFxyXG4gICAgICAgICAqIEBwYXJhbSAge0FycmF5fSBsb2RzICAgICBsaXN0IG9mIGxldmVscyBvZiBkZXRhaWwgb2JqZWN0c1xyXG4gICAgICAgICAqIEBwYXJhbSAge051bWJlcn0gc2NhbGUgICBzY2FsZSB2YWx1ZSB0byBzZWFyY2ggZm9yIGluIHRoZSBsZXZlbHMgb2YgZGV0YWlsXHJcbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgIHRoZSBsZXZlbCBvZiBkZXRhaWwgb2JqZWN0IGNsb3Nlc3QgdG8gdGhlIHNjYWxlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc3RhdGljIGZpbmRDbG9zZXN0TE9EIChsb2RzLCBzY2FsZSkge1xyXG4gICAgICAgICAgICBjb25zdCBkaWZmcyA9IGxvZHMubWFwKGxvZCA9PiBNYXRoLmFicyhsb2Quc2NhbGUgLSBzY2FsZSkpO1xyXG4gICAgICAgICAgICBjb25zdCBsb2RJZHggPSBkaWZmcy5pbmRleE9mKE1hdGgubWluKC4uLmRpZmZzKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBsb2RzW2xvZElkeF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYWxjdWxhdGUgbm9ydGggYXJyb3cgYmVhcmluZy4gQW5nbGUgcmV0dXJuZWQgaXMgdG8gdG8gcm90YXRlIG5vcnRoIGFycm93IGltYWdlLlxyXG4gICAgICAgICAqIGh0dHA6Ly93d3cubW92YWJsZS10eXBlLmNvLnVrL3NjcmlwdHMvbGF0bG9uZy5odG1sXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIGdldE5vcnRoQXJyb3dBbmdsZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IG1hcCByb3RhdGlvbiBhbmdsZSAoaW4gZGVncmVlKVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldE5vcnRoQXJyb3dBbmdsZSAoKSB7XHJcbiAgICAgICAgICAgIC8vIGdldCBjZW50ZXIgcG9pbnQgaW4gbG9uZ2l0dWRlIGFuZCB1c2UgYm90dG9tIHZhbHVlIGZvciBsYXRpdHVkZVxyXG4gICAgICAgICAgICBjb25zdCBwb2ludEIgPSBnZW9BcGkucHJvai5sb2NhbFByb2plY3RQb2ludCh0aGlzLl9tYXAuZXh0ZW50LnNwYXRpYWxSZWZlcmVuY2UsICdFUFNHOjQzMjYnLFxyXG4gICAgICAgICAgICAgICAgICAgIHsgeDogKHRoaXMuX21hcC5leHRlbnQueG1pbiArIHRoaXMuX21hcC5leHRlbnQueG1heCkgLyAyLCB5OiB0aGlzLl9tYXAuZXh0ZW50LnltaW4gfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBub3J0aCB2YWx1ZSAoc2V0IGxvbmdpdHVkZSB0byBiZSBoYWxmIG9mIENhbmFkYSBleHRlbnQgKDE0McKwIFcsIDUywrAgVykpXHJcbiAgICAgICAgICAgIGNvbnN0IHBvaW50QSA9IHsgeDogLTk2LCB5OiA5MCB9O1xyXG5cclxuICAgICAgICAgICAgLy8gc2V0IGluZm8gb24gbG9uZ2l0dWRlIGFuZCBsYXRpdHVkZVxyXG4gICAgICAgICAgICBjb25zdCBkTG9uID0gKHBvaW50Qi54IC0gcG9pbnRBLngpICogTWF0aC5QSSAvIDE4MDtcclxuICAgICAgICAgICAgY29uc3QgbGF0MSA9IHBvaW50QS55ICogTWF0aC5QSSAvIDE4MDtcclxuICAgICAgICAgICAgY29uc3QgbGF0MiA9IHBvaW50Qi55ICogTWF0aC5QSSAvIDE4MDtcclxuXHJcbiAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSBiZWFyaW5nXHJcbiAgICAgICAgICAgIGNvbnN0IHkgPSBNYXRoLnNpbihkTG9uKSAqIE1hdGguY29zKGxhdDIpO1xyXG4gICAgICAgICAgICBjb25zdCB4ID0gTWF0aC5jb3MobGF0MSkgKiBNYXRoLnNpbihsYXQyKSAtIE1hdGguc2luKGxhdDEpICogTWF0aC5jb3MobGF0MikgKiBNYXRoLmNvcyhkTG9uKTtcclxuICAgICAgICAgICAgY29uc3QgYmVhcmluZyA9IE1hdGguYXRhbjIoeSwgeCkgKiAxODAgLyBNYXRoLlBJO1xyXG5cclxuICAgICAgICAgICAgLy8gcmV0dXJuIGFuZ2xlICgxODAgaXMgcG9pbnRpb25nIG5vcnRoKVxyXG4gICAgICAgICAgICByZXR1cm4gKChiZWFyaW5nICsgMzYwKSAlIDM2MCkudG9GaXhlZCgxKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhbGN1bGF0ZSBkaXN0YW5jZSBiZXR3ZWVuIG1pbiBhbmQgbWF4IGV4dGVudCB0byBrbm93IHRoZSBwaXhlbCByYXRpbyBiZXR3ZWVuXHJcbiAgICAgICAgICogc2NyZWVuIHNpemUgYW5kIGVhcnRoIGRpc3RhbmNlLlxyXG4gICAgICAgICAqIGh0dHA6Ly93d3cubW92YWJsZS10eXBlLmNvLnVrL3NjcmlwdHMvbGF0bG9uZy5odG1sXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIGdldFNjYWxlUmF0aW9cclxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gbWFwV2lkdGggb3B0aW9uYWwgdGhlIG1hcCB3aWR0aCB0byB1c2UgdG8gY2FsY3VsYXRlIHJhdGlvXHJcbiAgICAgICAgICogQHJldHVybnMge09iamVjdH0gY29udGFpbiBpbmZvcm1hdGlvbiBhYm91dCB0aGUgc2NhbGVcclxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIGRpc3RhbmNlOiBkaXN0YW5jZSBiZXR3ZWVuIG1pbiBhbmQgbWF4IGV4dGVudElkXHJcbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSByYXRpbzogbWVhc3VyZSBmb3IgMSBwaXhlbCBpbiBlYXJ0aCBkaXN0YW5jZVxyXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gdW5pdHM6IGFycmF5IG9mIHVuaXRzIFttZXRyaWMsIGltcGVyaWFsXVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldFNjYWxlUmF0aW8gKG1hcFdpZHRoID0gMCkge1xyXG4gICAgICAgICAgICBjb25zdCBtYXAgPSB0aGlzLl9tYXA7XHJcblxyXG4gICAgICAgICAgICAvLyBnZXQgbGVmdCBhbmQgcmlnaHQgbWF4aW11bSB2YWx1ZSBwb2ludCB0byBjYWxjdWxhdGUgZGlzdGFuY2UgZnJvbVxyXG4gICAgICAgICAgICBjb25zdCBwb2ludEEgPSBnZW9BcGkucHJvai5sb2NhbFByb2plY3RQb2ludChtYXAuc3BhdGlhbFJlZmVyZW5jZSwgJ0VQU0c6NDMyNicsXHJcbiAgICAgICAgICAgICAgICAgICAgeyB4OiBtYXAuZXh0ZW50LnhtaW4sIHk6IChtYXAuZXh0ZW50LnltaW4gKyBtYXAuZXh0ZW50LnltYXgpIC8gMiB9KTtcclxuICAgICAgICAgICAgY29uc3QgcG9pbnRCID0gZ2VvQXBpLnByb2oubG9jYWxQcm9qZWN0UG9pbnQobWFwLnNwYXRpYWxSZWZlcmVuY2UsICdFUFNHOjQzMjYnLFxyXG4gICAgICAgICAgICAgICAgICAgIHsgeDogbWFwLmV4dGVudC54bWF4LCB5OiAobWFwLmV4dGVudC55bWluICsgbWFwLmV4dGVudC55bWF4KSAvIDIgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBIYXZlcnNpbmUgZm9ybXVsYSB0byBjYWxjdWxhdGUgZGlzdGFuY2VcclxuICAgICAgICAgICAgY29uc3QgUiA9IDYzNzFlMzsgLy8gZWFydGggcmFkaXVzIGluIG1ldGVyc1xyXG4gICAgICAgICAgICBjb25zdCByYWQgPSBNYXRoLlBJIC8gMTgwO1xyXG4gICAgICAgICAgICBjb25zdCBwaHkxID0gcG9pbnRBLnkgKiByYWQ7IC8vIHJhZGlhbnRcclxuICAgICAgICAgICAgY29uc3QgcGh5MiA9IHBvaW50Qi55ICogcmFkOyAvLyByYWRpYW50XHJcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhUGh5ID0gKHBvaW50Qi55IC0gcG9pbnRBLnkpICogcmFkOyAvLyByYWRpYW50XHJcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhTGFtYmRhID0gKHBvaW50Qi54IC0gcG9pbnRBLngpICogcmFkOyAvLyByYWRpYW50XHJcblxyXG4gICAgICAgICAgICBjb25zdCBhID0gTWF0aC5zaW4oZGVsdGFQaHkgLyAyKSAqIE1hdGguc2luKGRlbHRhUGh5IC8gMikgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmNvcyhwaHkxKSAqIE1hdGguY29zKHBoeTIpICpcclxuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5zaW4oZGVsdGFMYW1iZGEgLyAyKSAqIE1hdGguc2luKGRlbHRhTGFtYmRhIC8gMik7XHJcbiAgICAgICAgICAgIGNvbnN0IGMgPSAyICogTWF0aC5hdGFuMihNYXRoLnNxcnQoYSksIE1hdGguc3FydCgxIC0gYSkpO1xyXG4gICAgICAgICAgICBjb25zdCBkID0gKFIgKiBjKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHNldCBtYXAgLyBpbWFnZSB3aWR0aCAoaWYgbWFwV2lkdGggPSAwLCB1c2UgbWFwLndpZHRoKVxyXG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IG1hcFdpZHRoID8gbWFwV2lkdGggOiBtYXAud2lkdGg7XHJcblxyXG4gICAgICAgICAgICAvLyBnZXQgdW5pdCBmcm9tIGRpc3RhbmNlLCBzZXQgZGlzdGFuY2UgYW5kIHJhdGlvIChlYXJ0aCBzaXplIGZvciAxIHBpeGVsKVxyXG4gICAgICAgICAgICBjb25zdCB1bml0cyA9IFsoZCA+IDEwMDApID8gJ2ttJyA6ICdtJywgKGQgPiAxNjAwKSA/ICdtaScgOiAnZnQnXTtcclxuICAgICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSAoZCA+IDEwMDApID8gZCAvIDEwMDAgOiBkO1xyXG4gICAgICAgICAgICBjb25zdCByYXRpbyA9IGRpc3RhbmNlIC8gd2lkdGg7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4geyBkaXN0YW5jZSwgcmF0aW8sIHVuaXRzIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb21wYXJlcyB0byBzZXRzIG9mIGNvLW9yZGluYXRlcyBmb3IgZXh0ZW50cyAodmFsaWQgZm9yIGJvdGggeCBhbmQgeSkuIElmIGNlbnRlciBvZiBpbnB1dCBjby1vcmRpbmF0ZXMgZmFsbHMgb3V0c2lkZVxyXG4gICAgICAgICAqIG1hcCBjby1vcmRpYW50ZXMsIGZ1bmN0aW9uIHdpbGwgYWRqdXN0IHRoZW0gc28gdGhlIGNlbnRlciBpcyBpbnNpZGUgdGhlIG1hcCBjby1vcmRpbmF0ZXMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZnVuY3Rpb24gY2xpcEV4dGVudENvb3Jkc1xyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICogQHBhcmFtIHtOdW1lcmljfSBtaWQgICAgICBtaWRkbGUgb2YgdGhlIHRoZSByYW5nZSB0byB0ZXN0XHJcbiAgICAgICAgICogQHBhcmFtIHtOdW1lcmljfSBtYXggICAgICBtYXhpbXVtIHZhbHVlIG9mIHRoZSByYW5nZSB0byB0ZXN0XHJcbiAgICAgICAgICogQHBhcmFtIHtOdW1lcmljfSBtaW4gICAgICBtaW5pbXVtIHZhbHVlIG9mIHRoZSByYW5nZSB0byB0ZXN0XHJcbiAgICAgICAgICogQHBhcmFtIHtOdW1lcmljfSBtYXBNYXggICBtYXhpbXVtIHZhbHVlIG9mIHRoZSBtYXAgcmFuZ2VcclxuICAgICAgICAgKiBAcGFyYW0ge051bWVyaWN9IG1hcE1pbiAgIG1pbmltdW0gdmFsdWUgb2YgdGhlIG1hcCByYW5nZVxyXG4gICAgICAgICAqIEBwYXJhbSB7TnVtZXJpY30gbGVuICAgICAgbGVuZ3RoIG9mIHRoZSBhZGp1c3RlZCByYW5nZSwgaWYgYWRqdXN0ZWRcclxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheX0gICAgICAgICAgIHR3byBlbGVtZW50IGFycmF5IG9mIE51bWVyaWMsIGNvbnRhaW5pbmcgcmVzdWx0IG1heCBhbmQgbWluIHZhbHVlc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHN0YXRpYyBjbGlwRXh0ZW50Q29vcmRzIChtaWQsIG1heCwgbWluLCBtYXBNYXgsIG1hcE1pbiwgbGVuKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAobWlkID4gbWFwTWF4KSB7XHJcbiAgICAgICAgICAgICAgICBbbWF4LCBtaW5dID0gW21hcE1heCwgbWFwTWF4IC0gbGVuXTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChtaWQgPCBtYXBNaW4pIHtcclxuICAgICAgICAgICAgICAgIFttYXgsIG1pbl0gPSBbbWFwTWluICsgbGVuLCBtYXBNaW5dO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBbbWF4LCBtaW5dO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2hlY2tzIGlmIHRoZSBjZW50ZXIgb2YgdGhlIGdpdmVuIGV4dGVudCBpcyBvdXRzaWRlIG9mIHRoZSBtYXhpbXVtIGV4dGVudC4gSWYgaXQgaXMsXHJcbiAgICAgICAgICogd2lsbCBkZXRlcm1pbmUgYW4gYWRqdXN0ZWQgZXh0ZW50IHdpdGggYSBjZW50ZXIgaW5zaWRlIHRoZSBtYXhpbXVtIGV4dGVudC4gIFJldHVybnMgYm90aFxyXG4gICAgICAgICAqIGFuIGluZGljYXRvciBmbGFnIGlmIGFuIGFkanVzdG1lbnQgaGFwcGVuZWQsIGFuZCB0aGUgYWRqdXN0ZWQgZXh0ZW50LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIGVuZm9yY2VCb3VuZGFyeVxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBleHRlbnQgICAgICBhbiBFU1JJIGV4dGVudCB0byB0ZXN0XHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG1heEV4dGVudCAgIGFuIEVTUkkgZXh0ZW50IGluZGljYXRpbmcgdGhlIGJvdW5kYXJ5IG9mIHRoZSBtYXBcclxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgICAgYW4gb2JqZWN0IHdpdGggdHdvIHByb3BlcnRpZXMuIGFkanVzdGVkIC0gYm9vbGVhbiwgdHJ1ZSBpZiBleHRlbnQgd2FzIGFkanVzdGVkLiBuZXdFeHRlbnQgLSBvYmplY3QsIGFkanVzdGVkIEVTUkkgZXh0ZW50XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc3RhdGljIGVuZm9yY2VCb3VuZGFyeSAoZXh0ZW50LCBtYXhFeHRlbnQpIHtcclxuICAgICAgICAgICAgLy8gY2xvbmUgZXh0ZW50XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0V4dGVudCA9IGVzcmlCdW5kbGUuRXh0ZW50KGV4dGVudC50b0pzb24oKSk7XHJcblxyXG4gICAgICAgICAgICAvLyBkZXRlcm1pbmUgZGltZW5zaW9ucyBvZiBhZGp1c3RlZCBleHRlbnQuXHJcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgaW5wdXQsIHVubGVzcyBpbnB1dCBpcyBzbyBsYXJnZSBpdCBjb25zdW1lcyBtYXguXHJcbiAgICAgICAgICAgIC8vIGluIHRoYXQgY2FzZSwgd2Ugc2hyaW5rIHRvIHRoZSBtYXguIFRoaXMgYXZvaWRzIHRoZSBcIndhc2hpbmcgbWFjaGluZVwiXHJcbiAgICAgICAgICAgIC8vIGJ1ZyB3aGVyZSB3ZSBvdmVyLWNvcnJlY3QgcGFzdCB0aGUgdmFsaWQgcmFuZ2UsXHJcbiAgICAgICAgICAgIC8vIGFuZCBhY2hpZXZlIGluZmluaXRlIG9zY2lsbGF0aW5nIHBhbnNcclxuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5taW4oZXh0ZW50LmdldEhlaWdodCgpLCBtYXhFeHRlbnQuZ2V0SGVpZ2h0KCkpO1xyXG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IE1hdGgubWluKGV4dGVudC5nZXRXaWR0aCgpLCBtYXhFeHRlbnQuZ2V0V2lkdGgoKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNlbnRlciA9IGV4dGVudC5nZXRDZW50ZXIoKTtcclxuXHJcbiAgICAgICAgICAgIFtuZXdFeHRlbnQueG1heCwgbmV3RXh0ZW50LnhtaW5dID1cclxuICAgICAgICAgICAgICAgIHRoaXMuY2xpcEV4dGVudENvb3JkcyhjZW50ZXIueCwgbmV3RXh0ZW50LnhtYXgsIG5ld0V4dGVudC54bWluLCBtYXhFeHRlbnQueG1heCwgbWF4RXh0ZW50LnhtaW4sIHdpZHRoKTtcclxuICAgICAgICAgICAgW25ld0V4dGVudC55bWF4LCBuZXdFeHRlbnQueW1pbl0gPVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGlwRXh0ZW50Q29vcmRzKGNlbnRlci55LCBuZXdFeHRlbnQueW1heCwgbmV3RXh0ZW50LnltaW4sIG1heEV4dGVudC55bWF4LCBtYXhFeHRlbnQueW1pbiwgaGVpZ2h0KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBuZXdFeHRlbnQsXHJcbiAgICAgICAgICAgICAgICBhZGp1c3RlZDogIWV4dGVudC5jb250YWlucyhuZXdFeHRlbnQpIC8vIHRydWUgaWYgd2UgYWRqdXN0ZWQgdGhlIGV4dGVudFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW5pdE92ZXJ2aWV3TWFwICgpIHtcclxuICAgICAgICAgICAgdGhpcy5vdmVydmlld01hcCA9IG5ldyBlc3JpQnVuZGxlLk92ZXJ2aWV3TWFwKHsgbWFwOiB0aGlzLl9tYXAsIGV4cGFuZEZhY3RvcjogMSwgdmlzaWJsZTogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgdGhpcy5vdmVydmlld01hcC5zdGFydHVwKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc2V0T3ZlcnZpZXdNYXAgKCkge1xyXG4gICAgICAgICAgICB0aGlzLm92ZXJ2aWV3TWFwLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgdGhpcy5pbml0T3ZlcnZpZXdNYXAoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoYW5nZXMgdGhlIHpvb20gbGV2ZWwgYnkgdGhlIHNwZWNpZmllZCB2YWx1ZSByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBsZXZlbDsgY2FuIGJlIG5lZ2F0aXZlLlxyXG4gICAgICAgICAqIFRvIGF2b2lkIG11bHRpcGxlIGNoYWluZWQgem9vbSBhbmltYXRpb25zIHdoZW4gcmFwaWRseSBwcmVzc2luZyB0aGUgem9vbSBpbi9vdXQgaWNvbnMsIHdlXHJcbiAgICAgICAgICogdXBkYXRlIHRoZSB6b29tIGxldmVsIG9ubHkgd2hlbiB0aGUgb25lIGJlZm9yZSBpdCByZXNvbHZlcyB3aXRoIHRoZSBuZXQgem9vbSBjaGFuZ2UuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZnVuY3Rpb24gc2hpZnRab29tXHJcbiAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBieVZhbHVlIGEgbnVtYmVyIG9mIHpvb20gbGV2ZWxzIHRvIHNoaWZ0IGJ5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2hpZnRab29tIChieVZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuem9vbUNvdW50ZXIgKz0gYnlWYWx1ZTtcclxuICAgICAgICAgICAgdGhpcy56b29tUHJvbWlzZS50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnpvb21Db3VudGVyICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgem9vbVZhbHVlID0gdGhpcy5fbWFwLmdldFpvb20oKSArIHRoaXMuem9vbUNvdW50ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgem9vbVByb21pc2UgPSBQcm9taXNlLnJlc29sdmUodGhpcy5zZXRab29tKHpvb21WYWx1ZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuem9vbUNvdW50ZXIgPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyB1bmRlZmluZWQgc2lnbmFscyB3ZSd2ZSB6b29tZWQgaW4vb3V0IGFzIGZhciBhcyB3ZSBjYW5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHpvb21Qcm9taXNlICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnpvb21Qcm9taXNlID0gem9vbVByb21pc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgb3IgZ2V0cyBtYXAgZGVmYXVsdCBjb25maWcgdmFsdWVzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIG1hcERlZmF1bHRcclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5ICBuYW1lIG9mIHRoZSBkZWZhdWx0IHByb3BlcnR5XHJcbiAgICAgICAgICogQHBhcmFtIHtBbnl9IFt2YWx1ZV0gb3B0aW9uYWwgdmFsdWUgdG8gc2V0IGZvciB0aGUgc3BlY2lmaWVkIGRlZmF1bHQgcHJvcGVydHlcclxuICAgICAgICAgKi9cclxuICAgICAgICBtYXBEZWZhdWx0IChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZXNyaUJ1bmRsZS5lc3JpQ29uZmlnLmRlZmF1bHRzLm1hcFtrZXldO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZXNyaUJ1bmRsZS5lc3JpQ29uZmlnLmRlZmF1bHRzLm1hcFtrZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldCBwcm94eSBzZXJ2aWNlIFVSTCB0byBhdm9pZCBzYW1lIG9yaWdpbiBpc3N1ZXMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2V0IHByb3h5IChwcm94eVVybCkgeyBlc3JpQnVuZGxlLmVzcmlDb25maWcuZGVmYXVsdHMuaW8ucHJveHlVcmwgPSBwcm94eVVybDsgfVxyXG4gICAgICAgIGdldCBwcm94eSAoKSB7IHJldHVybiBlc3JpQnVuZGxlLmVzcmlDb25maWcuZGVmYXVsdHMuaW8ucHJveHlVcmw7IH1cclxuXHJcbiAgICAgICAgc2V0IGJhc2VtYXBHYWxsZXJ5ICh2YWwpIHsgdGhpcy5fYmFzZW1hcEdhbGxlcnkgPSB2YWw7IH1cclxuICAgICAgICBnZXQgYmFzZW1hcEdhbGxlcnkgKCkgeyByZXR1cm4gdGhpcy5fYmFzZW1hcEdhbGxlcnk7IH1cclxuXHJcbiAgICAgICAgc2V0IHNjYWxlYmFyICh2YWwpIHsgdGhpcy5fc2NhbGViYXIgPSB2YWw7IH1cclxuICAgICAgICBnZXQgc2NhbGViYXIgKCkgeyByZXR1cm4gdGhpcy5fc2NhbGViYXI7IH1cclxuXHJcbiAgICAgICAgc2V0IG92ZXJ2aWV3TWFwICh2YWwpIHsgdGhpcy5fb3ZlcnZpZXdNYXAgPSB2YWw7IH1cclxuICAgICAgICBnZXQgb3ZlcnZpZXdNYXAgKCkgeyByZXR1cm4gdGhpcy5fb3ZlcnZpZXdNYXA7IH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIE1hcDtcclxufVxyXG5cclxuLyoqXHJcbiAgKiBUaGUgYE1hcE1hbmFnZXJgIG1vZHVsZSBleHBvcnRzIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcclxuICAqIC0gYEV4dGVudGAgZXNyaS9nZW9tZXRyeSB0eXBlXHJcbiAgKiAtIGBNYXBgIGVzcmkvbWFwIHR5cGVcclxuICAqIC0gYE92ZXJ2aWV3TWFwYCBlc3JpL2Rpaml0L092ZXJ2aWV3TWFwIHR5cGVcclxuICAqIC0gYFNjYWxlYmFyYCBzcmkvZGlqaXQvU2NhbGViYXIgdHlwZVxyXG4gICogLSBgZ2V0RXh0ZW50RnJvbVNldHRpbmcgZnVuY3Rpb24gdG8gY3JlYXRlIGFuIEVTUkkgRXh0ZW50IG9iamVjdCBmcm9tIGV4dGVudCBzZXR0aW5nIEpTT04gb2JqZWN0LlxyXG4gICogLSBgc2V0dXBNYXBgIGZ1bmN0aW9uIHRoYXQgaW50ZXJhdGVzIG92ZXIgY29uZmlnIHNldHRpbmdzIGFuZCBhcHBseSBsb2dpYyBmb3IgYW55IGl0ZW1zIHByZXNlbnQuXHJcbiAgKiAtIGBzZXRQcm94eWAgZnVuY3Rpb24gdG8gc2V0IHByb3h5IHNlcnZpY2UgVVJMIHRvIGF2b2lkIHNhbWUgb3JpZ2luIGlzc3Vlc1xyXG4gICovXHJcblxyXG4vLyBtYXBNYW5hZ2VyIG1vZHVsZSwgcHJvdmlkZXMgZnVuY3Rpb24gdG8gc2V0dXAgYSBtYXBcclxubW9kdWxlLmV4cG9ydHMgPSAoZXNyaUJ1bmRsZSwgZ2VvQXBpKSA9PiBlc3JpTWFwKGVzcmlCdW5kbGUsIGdlb0FwaSk7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9tYXAvZXNyaU1hcC5qcyJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar proj4 = __webpack_require__(63);\nvar terraformer = __webpack_require__(37);\nvar teraProj = __webpack_require__(172);\n\n/**\r\n * Reproject a GeoJSON object in place.  This is a wrapper around terraformer-proj4js.\r\n * @param {Object} geojson the GeoJSON to be reprojected, this will be modified in place\r\n * @param {String|Number} outputSpatialReference the target spatial reference,\r\n * 'EPSG:4326' is used by default; if a number is suppied it will be used as an EPSG code\r\n * @param {String|Number} inputSpatialReference same rules as outputSpatialReference if suppied\r\n * if missing it will attempt to find it encoded in the GeoJSON\r\n */\nfunction projectGeojson(geojson, outputSpatialReference, inputSpatialReference) {\n    var converter = teraProj(terraformer, proj4);\n    converter(geojson, outputSpatialReference, inputSpatialReference);\n}\n\n/**\r\n * Convert a projection to an string that is compatible with proj4.  If it is an ESRI SpatialReference or an integer it will be converted.\r\n * @param {Object|Integer|String} proj an ESRI SpatialReference, integer or string.  Strings will be unchanged and unchecked,\r\n * ints and SpatialReference objects will be converted.\r\n * @return {String} A string in the form EPSG:####\r\n * @private\r\n */\nfunction normalizeProj(proj) {\n    if ((typeof proj === 'undefined' ? 'undefined' : _typeof(proj)) === 'object') {\n        if (proj.wkid) {\n            return 'EPSG:' + proj.wkid;\n        } else if (proj.wkt) {\n            return proj.wkt;\n        }\n    } else if (typeof proj === 'number') {\n        return 'EPSG:' + proj;\n    } else if (typeof proj === 'string') {\n        return proj;\n    }\n    throw new Error('Bad argument type, please provide a string, integer or SpatialReference object.');\n}\n\n/**\r\n * Project a single point.\r\n * @param {Object|Integer|String} srcProj the spatial reference of the point (as ESRI SpatialReference, integer WKID or an EPSG string)\r\n * @param {Object|Integer|String} destProj the spatial reference of the result (as ESRI SpatialReference, integer WKID or an EPSG string)\r\n * @param {Array|Object} point a 2d array or object with {x,y} props containing the coordinates to Reproject\r\n * @return {Array|Object} a 2d array or object containing the projected point\r\n */\nfunction localProjectPoint(srcProj, destProj, point) {\n    return proj4(normalizeProj(srcProj), normalizeProj(destProj), point);\n}\n\n/**\r\n * Project a single point.\r\n * @param {Object|Integer|String} destProj the spatial reference of the result (as ESRI SpatialReference, integer WKID or an EPSG string)\r\n * @param {Object} geometry an object conforming to ESRI Geometry object standards containing the coordinates to Reproject\r\n * @return {Object} an object conforming to ESRI Geomtery object standards containing the input geometry in the destination projection\r\n */\nfunction localProjectGeometry(destProj, geometry) {\n    // FIXME we seem to be really dependant on wkid. ideally enhance to handle all SR types\n\n    // HACK >:'(\n    // terraformer has this undesired behavior where, if your input geometry is in WKID 102100, it will magically\n    // project all your co-ordinates to lat/long when converting between ESRI and GeoJSON formats.\n    // to stop it from ruining us, we temporarily set the spatial reference to nonsense so it will leave it alone\n    var realSR = geometry.spatialReference;\n    geometry.spatialReference = { wkid: 8888 }; // nonsense!\n    var grGeoJ = terraformer.ArcGIS.parse(geometry, { sr: 8888 });\n    geometry.spatialReference = realSR;\n\n    // project json\n    projectGeojson(grGeoJ, normalizeProj(destProj), normalizeProj(realSR));\n\n    // back to esri format\n    var grEsri = terraformer.ArcGIS.convert(grGeoJ);\n\n    // doing this because .convert likes to attach a lat/long spatial reference for fun.\n    grEsri.spatialReference = destProj;\n\n    return grEsri;\n}\n\n/**\r\n * Reproject an EsriExtent object on the client.  Does not require network\r\n * traffic, but may not handle conversion between projection types as well.\r\n * Internally it tests 8 points along each edge and takes the max extent\r\n * of the result.\r\n *\r\n * @param {EsriExtent} extent to reproject\r\n * @param {Object} sr is the target spatial reference (if a number it\r\n *                 will be treated as a WKID)\r\n * @returns {Object} an extent as an unstructured object\r\n */\nfunction localProjectExtent(extent, sr) {\n\n    // interpolates two points by splitting the line in half recursively\n    function interpolate(p0, p1, steps) {\n        if (steps === 0) {\n            return [p0, p1];\n        }\n\n        var mid = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];\n        if (steps === 1) {\n            return [p0, mid, p1];\n        }\n        if (steps > 1) {\n            var i0 = interpolate(p0, mid, steps - 1);\n            var i1 = interpolate(mid, p1, steps - 1);\n            return i0.concat(i1.slice(1));\n        }\n    }\n\n    var points = [[extent.xmin, extent.ymin], [extent.xmax, extent.ymin], [extent.xmax, extent.ymax], [extent.xmin, extent.ymax], [extent.xmin, extent.ymin]];\n    var interpolatedPoly = [];\n    var srcProj = void 0;\n\n    // interpolate each edge by splitting it in half 3 times (since lines are not guaranteed to project to lines we need to consider\n    // max / min points in the middle of line segments)\n    [0, 1, 2, 3].map(function (i) {\n        return interpolate(points[i], points[i + 1], 3).slice(1);\n    }).forEach(function (seg) {\n        return interpolatedPoly = interpolatedPoly.concat(seg);\n    });\n\n    // find the source extent (either from wkid or wkt)\n    if (extent.spatialReference.wkid) {\n        srcProj = 'EPSG:' + extent.spatialReference.wkid;\n    } else if (extent.spatialReference.wkt) {\n        srcProj = extent.spatialReference.wkt;\n    } else {\n        throw new Error('No WKT or WKID specified on extent.spatialReference');\n    }\n\n    // find the destination extent\n    var destProj = normalizeProj(sr);\n\n    if (extent.spatialReference.wkid && !proj4.defs(srcProj)) {\n        throw new Error('Source projection WKID not recognized by proj4 library');\n    }\n    var projConvert = proj4(srcProj, destProj);\n    var transformed = interpolatedPoly.map(function (x) {\n        return projConvert.forward(x);\n    });\n\n    var xvals = transformed.map(function (x) {\n        return x[0];\n    });\n    var yvals = transformed.map(function (x) {\n        return x[1];\n    });\n\n    var x0 = Math.min.apply(null, xvals);\n    var x1 = Math.max.apply(null, xvals);\n\n    var y0 = Math.min.apply(null, yvals);\n    var y1 = Math.max.apply(null, yvals);\n\n    return { x0: x0, y0: y0, x1: x1, y1: y1, sr: sr };\n}\n\n/**\r\n * Check whether or not a spatialReference is supported by proj4 library.\r\n *\r\n * @param {Object} spatialReference to be checked to see if it's supported by proj4\r\n * @param {Function} epsgLookup an optional lookup function for EPSG codes which are not loaded\r\n * in the proj4 definitions, the function should take a numeric EPSG code and return a Promise\r\n * resolving with a proj4 style definition string\r\n * @returns {Object} with the structure {\r\n *  foundProj: (bool) indicates if the projection was found,\r\n *  message: (string) provides a reason why the projection was not found,\r\n *  lookupPromise: (Promise) an optional promise resolving with true or false if a lookup function was provided and had to be invoked\r\n * }\r\n */\nfunction checkProj(spatialReference, epsgLookup) {\n    var srcProj = void 0;\n\n    // find the source extent (either from wkid or wkt)\n    if (spatialReference.wkid) {\n        srcProj = 'EPSG:' + spatialReference.wkid;\n    } else if (spatialReference.wkt) {\n        srcProj = spatialReference.wkt;\n    } else {\n        return {\n            foundProj: false,\n            message: 'No WKT or WKID specified on extent.spatialReference'\n        };\n    }\n\n    if (spatialReference.wkid && !proj4.defs(srcProj)) {\n        if (epsgLookup) {\n            return {\n                foundProj: false,\n                message: 'Attempting to lookup WKID',\n                lookupPromise: epsgLookup(spatialReference.wkid).then(function (def) {\n                    if (def === null) {\n                        return false;\n                    }\n                    proj4.defs(srcProj, def);\n                    return true;\n                })\n            };\n        }\n        return {\n            foundProj: false,\n            message: 'Source projection in WKID and not recognized by proj4 library'\n        };\n    }\n\n    return {\n        foundProj: true,\n        message: 'Source projection OK.'\n    };\n}\n\nfunction projectEsriExtentBuilder(esriBundle) {\n    return function (extent, sr) {\n        var p = localProjectExtent(extent, sr);\n        return new esriBundle.Extent(p.x0, p.y0, p.x1, p.y1, p.sr);\n    };\n}\n\nfunction esriServiceBuilder(esriBundle) {\n    /**\r\n     * Reproject an esri geometry object on the server. Requires network traffic\r\n     * to esri's Geometry Service, but may be slower than proj4 conversion.\r\n     * Internally it tests 1 point and reprojects it to another spatial reference.\r\n     *\r\n     * @param {url} url for the ESRI Geometry Service\r\n     * @param {geometries} geometries to be projected\r\n     * @param {sr} sr is the target spatial reference\r\n     * @returns {Promise} promise to return reprojected geometries\r\n     */\n    return function (url, geometries, sr) {\n        return new Promise(function (resolve, reject) {\n            var params = new esriBundle.ProjectParameters();\n\n            // connect to esri server\n            var gsvc = new esriBundle.GeometryService(url);\n\n            params.geometries = geometries;\n            params.outSR = sr;\n\n            // call project function from esri server to do conversion\n            gsvc.project(params, function (projectedExtents) {\n                resolve(projectedExtents);\n            }, function (error) {\n                reject(error);\n            });\n        });\n    };\n}\n\n/**\r\n* Checks if two spatial reference objects are equivalent.  Handles both wkid and wkt definitions.\r\n*\r\n* @method isSpatialRefEqual\r\n* @static\r\n* @param {type} sr1 Esri Spatial Reference First to compare\r\n* @param {type} sr2 Esri Spatial Reference Second to compare\r\n* @return {Boolean} true if the two spatial references are equivalent.  False otherwise.\r\n*/\nfunction isSpatialRefEqual(sr1, sr2) {\n    if (sr1.wkid && sr2.wkid) {\n        // both SRs have wkids\n        return sr1.wkid === sr2.wkid;\n    } else if (sr1.wkt && sr2.wkt) {\n        // both SRs have wkt's\n        return sr1.wkt === sr2.wkt;\n    } else {\n        // not enough info provided or mismatch between wkid and wkt.\n        return false;\n    }\n}\n\nmodule.exports = function (esriBundle) {\n    // TODO: Move Point and SpatialReference to its own (geometry) module\n\n    // TODO consider moving this elsewhere.  state is bad, but these are common, and we have no service for esri defs\n    proj4.defs('EPSG:3978', '+proj=lcc +lat_1=49 +lat_2=77 +lat_0=49 ' + '+lon_0=-95 +x_0=0 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs');\n    proj4.defs('EPSG:3979', '+proj=lcc +lat_1=49 +lat_2=77 +lat_0=49 +lon_0=-95 ' + '+x_0=0 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs');\n    proj4.defs('EPSG:54004', '+proj=merc +lon_0=0 +k=1 +x_0=0 +y_0=0 +ellps=WGS84 ' + '+datum=WGS84 +units=m +no_defs');\n    proj4.defs('EPSG:102100', proj4.defs('EPSG:3857'));\n\n    // add UTM projections\n    var utm = 1;\n    while (utm <= 60) {\n        var zone = utm < 10 ? '0' + utm : utm;\n        proj4.defs('EPSG:326' + zone, '+proj=utm +zone=' + utm + ' +ellps=WGS84 +datum=WGS84 +units=m +no_defs');\n        utm++;\n    }\n\n    return {\n        addProjection: proj4.defs, // straight passthrough at the moment, maybe add arg checking (two args)?\n        checkProj: checkProj,\n        getProjection: proj4.defs, // straight passthrough at the moment, maybe add arg checking (one arg)?\n        esriServerProject: esriServiceBuilder(esriBundle),\n        Graphic: esriBundle.Graphic,\n        graphicsUtils: esriBundle.graphicsUtils,\n        isSpatialRefEqual: isSpatialRefEqual,\n        localProjectExtent: localProjectExtent,\n        localProjectPoint: localProjectPoint,\n        localProjectGeometry: localProjectGeometry,\n        projectGeojson: projectGeojson,\n        Point: esriBundle.Point,\n        projectEsriExtent: projectEsriExtentBuilder(esriBundle),\n        SpatialReference: esriBundle.SpatialReference\n    };\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcHJvai5qcz9jYzQ3Il0sIm5hbWVzIjpbInByb2o0IiwicmVxdWlyZSIsInRlcnJhZm9ybWVyIiwidGVyYVByb2oiLCJwcm9qZWN0R2VvanNvbiIsImdlb2pzb24iLCJvdXRwdXRTcGF0aWFsUmVmZXJlbmNlIiwiaW5wdXRTcGF0aWFsUmVmZXJlbmNlIiwiY29udmVydGVyIiwibm9ybWFsaXplUHJvaiIsInByb2oiLCJ3a2lkIiwid2t0IiwiRXJyb3IiLCJsb2NhbFByb2plY3RQb2ludCIsInNyY1Byb2oiLCJkZXN0UHJvaiIsInBvaW50IiwibG9jYWxQcm9qZWN0R2VvbWV0cnkiLCJnZW9tZXRyeSIsInJlYWxTUiIsInNwYXRpYWxSZWZlcmVuY2UiLCJnckdlb0oiLCJBcmNHSVMiLCJwYXJzZSIsInNyIiwiZ3JFc3JpIiwiY29udmVydCIsImxvY2FsUHJvamVjdEV4dGVudCIsImV4dGVudCIsImludGVycG9sYXRlIiwicDAiLCJwMSIsInN0ZXBzIiwibWlkIiwiaTAiLCJpMSIsImNvbmNhdCIsInNsaWNlIiwicG9pbnRzIiwieG1pbiIsInltaW4iLCJ4bWF4IiwieW1heCIsImludGVycG9sYXRlZFBvbHkiLCJtYXAiLCJpIiwiZm9yRWFjaCIsInNlZyIsImRlZnMiLCJwcm9qQ29udmVydCIsInRyYW5zZm9ybWVkIiwiZm9yd2FyZCIsIngiLCJ4dmFscyIsInl2YWxzIiwieDAiLCJNYXRoIiwibWluIiwiYXBwbHkiLCJ4MSIsIm1heCIsInkwIiwieTEiLCJjaGVja1Byb2oiLCJlcHNnTG9va3VwIiwiZm91bmRQcm9qIiwibWVzc2FnZSIsImxvb2t1cFByb21pc2UiLCJ0aGVuIiwiZGVmIiwicHJvamVjdEVzcmlFeHRlbnRCdWlsZGVyIiwiZXNyaUJ1bmRsZSIsInAiLCJFeHRlbnQiLCJlc3JpU2VydmljZUJ1aWxkZXIiLCJ1cmwiLCJnZW9tZXRyaWVzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJwYXJhbXMiLCJQcm9qZWN0UGFyYW1ldGVycyIsImdzdmMiLCJHZW9tZXRyeVNlcnZpY2UiLCJvdXRTUiIsInByb2plY3QiLCJwcm9qZWN0ZWRFeHRlbnRzIiwiZXJyb3IiLCJpc1NwYXRpYWxSZWZFcXVhbCIsInNyMSIsInNyMiIsIm1vZHVsZSIsImV4cG9ydHMiLCJ1dG0iLCJ6b25lIiwiYWRkUHJvamVjdGlvbiIsImdldFByb2plY3Rpb24iLCJlc3JpU2VydmVyUHJvamVjdCIsIkdyYXBoaWMiLCJncmFwaGljc1V0aWxzIiwiUG9pbnQiLCJwcm9qZWN0RXNyaUV4dGVudCIsIlNwYXRpYWxSZWZlcmVuY2UiXSwibWFwcGluZ3MiOiJBQUFBOzs7O0FBQ0EsSUFBTUEsUUFBUSxtQkFBQUMsQ0FBUSxFQUFSLENBQWQ7QUFDQSxJQUFNQyxjQUFjLG1CQUFBRCxDQUFRLEVBQVIsQ0FBcEI7QUFDQSxJQUFNRSxXQUFXLG1CQUFBRixDQUFRLEdBQVIsQ0FBakI7O0FBRUE7Ozs7Ozs7O0FBUUEsU0FBU0csY0FBVCxDQUF3QkMsT0FBeEIsRUFBaUNDLHNCQUFqQyxFQUF5REMscUJBQXpELEVBQWdGO0FBQzVFLFFBQU1DLFlBQVlMLFNBQVNELFdBQVQsRUFBc0JGLEtBQXRCLENBQWxCO0FBQ0FRLGNBQVVILE9BQVYsRUFBbUJDLHNCQUFuQixFQUEyQ0MscUJBQTNDO0FBQ0g7O0FBRUQ7Ozs7Ozs7QUFPQSxTQUFTRSxhQUFULENBQXVCQyxJQUF2QixFQUE2QjtBQUN6QixRQUFJLFFBQU9BLElBQVAseUNBQU9BLElBQVAsT0FBZ0IsUUFBcEIsRUFBOEI7QUFDMUIsWUFBSUEsS0FBS0MsSUFBVCxFQUFlO0FBQ1gsbUJBQU8sVUFBVUQsS0FBS0MsSUFBdEI7QUFDSCxTQUZELE1BRU8sSUFBSUQsS0FBS0UsR0FBVCxFQUFjO0FBQ2pCLG1CQUFPRixLQUFLRSxHQUFaO0FBQ0g7QUFDSixLQU5ELE1BTU8sSUFBSSxPQUFPRixJQUFQLEtBQWdCLFFBQXBCLEVBQThCO0FBQ2pDLGVBQU8sVUFBVUEsSUFBakI7QUFDSCxLQUZNLE1BRUEsSUFB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O0FBTUhDLHVCQUFlNUIsV0FBVzRCLGFBTnZCO0FBT0hYLDRDQVBHO0FBUUg3RCw4Q0FSRztBQVNIZCw0Q0FURztBQVVISSxrREFWRztBQVdIZCxzQ0FYRztBQVlIaUcsZUFBTzdCLFdBQVc2QixLQVpmO0FBYUhDLDJCQUFtQi9CLHlCQUF5QkMsVUFBekIsQ0FiaEI7QUFjSCtCLDBCQUFrQi9CLFdBQVcrQjtBQWQxQixLQUFQO0FBZ0JILENBcENEIiwiZmlsZSI6Ijc3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5jb25zdCBwcm9qNCA9IHJlcXVpcmUoJ3Byb2o0Jyk7XHJcbmNvbnN0IHRlcnJhZm9ybWVyID0gcmVxdWlyZSgndGVycmFmb3JtZXInKTtcclxuY29uc3QgdGVyYVByb2ogPSByZXF1aXJlKCd0ZXJyYWZvcm1lci1wcm9qNGpzJyk7XHJcblxyXG4vKipcclxuICogUmVwcm9qZWN0IGEgR2VvSlNPTiBvYmplY3QgaW4gcGxhY2UuICBUaGlzIGlzIGEgd3JhcHBlciBhcm91bmQgdGVycmFmb3JtZXItcHJvajRqcy5cclxuICogQHBhcmFtIHtPYmplY3R9IGdlb2pzb24gdGhlIEdlb0pTT04gdG8gYmUgcmVwcm9qZWN0ZWQsIHRoaXMgd2lsbCBiZSBtb2RpZmllZCBpbiBwbGFjZVxyXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IG91dHB1dFNwYXRpYWxSZWZlcmVuY2UgdGhlIHRhcmdldCBzcGF0aWFsIHJlZmVyZW5jZSxcclxuICogJ0VQU0c6NDMyNicgaXMgdXNlZCBieSBkZWZhdWx0OyBpZiBhIG51bWJlciBpcyBzdXBwaWVkIGl0IHdpbGwgYmUgdXNlZCBhcyBhbiBFUFNHIGNvZGVcclxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBpbnB1dFNwYXRpYWxSZWZlcmVuY2Ugc2FtZSBydWxlcyBhcyBvdXRwdXRTcGF0aWFsUmVmZXJlbmNlIGlmIHN1cHBpZWRcclxuICogaWYgbWlzc2luZyBpdCB3aWxsIGF0dGVtcHQgdG8gZmluZCBpdCBlbmNvZGVkIGluIHRoZSBHZW9KU09OXHJcbiAqL1xyXG5mdW5jdGlvbiBwcm9qZWN0R2VvanNvbihnZW9qc29uLCBvdXRwdXRTcGF0aWFsUmVmZXJlbmNlLCBpbnB1dFNwYXRpYWxSZWZlcmVuY2UpIHtcclxuICAgIGNvbnN0IGNvbnZlcnRlciA9IHRlcmFQcm9qKHRlcnJhZm9ybWVyLCBwcm9qNCk7XHJcbiAgICBjb252ZXJ0ZXIoZ2VvanNvbiwgb3V0cHV0U3BhdGlhbFJlZmVyZW5jZSwgaW5wdXRTcGF0aWFsUmVmZXJlbmNlKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnQgYSBwcm9qZWN0aW9uIHRvIGFuIHN0cmluZyB0aGF0IGlzIGNvbXBhdGlibGUgd2l0aCBwcm9qNC4gIElmIGl0IGlzIGFuIEVTUkkgU3BhdGlhbFJlZmVyZW5jZSBvciBhbiBpbnRlZ2VyIGl0IHdpbGwgYmUgY29udmVydGVkLlxyXG4gKiBAcGFyYW0ge09iamVjdHxJbnRlZ2VyfFN0cmluZ30gcHJvaiBhbiBFU1JJIFNwYXRpYWxSZWZlcmVuY2UsIGludGVnZXIgb3Igc3RyaW5nLiAgU3RyaW5ncyB3aWxsIGJlIHVuY2hhbmdlZCBhbmQgdW5jaGVja2VkLFxyXG4gKiBpbnRzIGFuZCBTcGF0aWFsUmVmZXJlbmNlIG9iamVjdHMgd2lsbCBiZSBjb252ZXJ0ZWQuXHJcbiAqIEByZXR1cm4ge1N0cmluZ30gQSBzdHJpbmcgaW4gdGhlIGZvcm0gRVBTRzojIyMjXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBub3JtYWxpemVQcm9qKHByb2opIHtcclxuICAgIGlmICh0eXBlb2YgcHJvaiA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICBpZiAocHJvai53a2lkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnRVBTRzonICsgcHJvai53a2lkO1xyXG4gICAgICAgIH0gZWxzZSBpZiAocHJvai53a3QpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHByb2oud2t0O1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHByb2ogPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgcmV0dXJuICdFUFNHOicgKyBwcm9qO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcHJvaiA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICByZXR1cm4gcHJvajtcclxuICAgIH1cclxuICAgIHRocm93IG5ldyBFcnJvcignQmFkIGFyZ3VtZW50IHR5cGUsIHBsZWFzZSBwcm92aWRlIGEgc3RyaW5nLCBpbnRlZ2VyIG9yIFNwYXRpYWxSZWZlcmVuY2Ugb2JqZWN0LicpO1xyXG59XHJcblxyXG4vKipcclxuICogUHJvamVjdCBhIHNpbmdsZSBwb2ludC5cclxuICogQHBhcmFtIHtPYmplY3R8SW50ZWdlcnxTdHJpbmd9IHNyY1Byb2ogdGhlIHNwYXRpYWwgcmVmZXJlbmNlIG9mIHRoZSBwb2ludCAoYXMgRVNSSSBTcGF0aWFsUmVmZXJlbmNlLCBpbnRlZ2VyIFdLSUQgb3IgYW4gRVBTRyBzdHJpbmcpXHJcbiAqIEBwYXJhbSB7T2JqZWN0fEludGVnZXJ8U3RyaW5nfSBkZXN0UHJvaiB0aGUgc3BhdGlhbCByZWZlcmVuY2Ugb2YgdGhlIHJlc3VsdCAoYXMgRVNSSSBTcGF0aWFsUmVmZXJlbmNlLCBpbnRlZ2VyIFdLSUQgb3IgYW4gRVBTRyBzdHJpbmcpXHJcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBwb2ludCBhIDJkIGFycmF5IG9yIG9iamVjdCB3aXRoIHt4LHl9IHByb3BzIGNvbnRhaW5pbmcgdGhlIGNvb3JkaW5hdGVzIHRvIFJlcHJvamVjdFxyXG4gKiBAcmV0dXJuIHtBcnJheXxPYmplY3R9IGEgMmQgYXJyYXkgb3Igb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHByb2plY3RlZCBwb2ludFxyXG4gKi9cclxuZnVuY3Rpb24gbG9jYWxQcm9qZWN0UG9pbnQoc3JjUHJvaiwgZGVzdFByb2osIHBvaW50KSB7XHJcbiAgICByZXR1cm4gcHJvajQobm9ybWFsaXplUHJvaihzcmNQcm9qKSwgbm9ybWFsaXplUHJvaihkZXN0UHJvaiksIHBvaW50KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFByb2plY3QgYSBzaW5nbGUgcG9pbnQuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fEludGVnZXJ8U3RyaW5nfSBkZXN0UHJvaiB0aGUgc3BhdGlhbCByZWZlcmVuY2Ugb2YgdGhlIHJlc3VsdCAoYXMgRVNSSSBTcGF0aWFsUmVmZXJlbmNlLCBpbnRlZ2VyIFdLSUQgb3IgYW4gRVBTRyBzdHJpbmcpXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBnZW9tZXRyeSBhbiBvYmplY3QgY29uZm9ybWluZyB0byBFU1JJIEdlb21ldHJ5IG9iamVjdCBzdGFuZGFyZHMgY29udGFpbmluZyB0aGUgY29vcmRpbmF0ZXMgdG8gUmVwcm9qZWN0XHJcbiAqIEByZXR1cm4ge09iamVjdH0gYW4gb2JqZWN0IGNvbmZvcm1pbmcgdG8gRVNSSSBHZW9tdGVyeSBvYmplY3Qgc3RhbmRhcmRzIGNvbnRhaW5pbmcgdGhlIGlucHV0IGdlb21ldHJ5IGluIHRoZSBkZXN0aW5hdGlvbiBwcm9qZWN0aW9uXHJcbiAqL1xyXG5mdW5jdGlvbiBsb2NhbFByb2plY3RHZW9tZXRyeShkZXN0UHJvaiwgZ2VvbWV0cnkpIHtcclxuICAgIC8vIEZJWE1FIHdlIHNlZW0gdG8gYmUgcmVhbGx5IGRlcGVuZGFudCBvbiB3a2lkLiBpZGVhbGx5IGVuaGFuY2UgdG8gaGFuZGxlIGFsbCBTUiB0eXBlc1xyXG5cclxuICAgIC8vIEhBQ0sgPjonKFxyXG4gICAgLy8gdGVycmFmb3JtZXIgaGFzIHRoaXMgdW5kZXNpcmVkIGJlaGF2aW9yIHdoZXJlLCBpZiB5b3VyIGlucHV0IGdlb21ldHJ5IGlzIGluIFdLSUQgMTAyMTAwLCBpdCB3aWxsIG1hZ2ljYWxseVxyXG4gICAgLy8gcHJvamVjdCBhbGwgeW91ciBjby1vcmRpbmF0ZXMgdG8gbGF0L2xvbmcgd2hlbiBjb252ZXJ0aW5nIGJldHdlZW4gRVNSSSBhbmQgR2VvSlNPTiBmb3JtYXRzLlxyXG4gICAgLy8gdG8gc3RvcCBpdCBmcm9tIHJ1aW5pbmcgdXMsIHdlIHRlbXBvcmFyaWx5IHNldCB0aGUgc3BhdGlhbCByZWZlcmVuY2UgdG8gbm9uc2Vuc2Ugc28gaXQgd2lsbCBsZWF2ZSBpdCBhbG9uZVxyXG4gICAgY29uc3QgcmVhbFNSID0gZ2VvbWV0cnkuc3BhdGlhbFJlZmVyZW5jZTtcclxuICAgIGdlb21ldHJ5LnNwYXRpYWxSZWZlcmVuY2UgPSB7IHdraWQ6IDg4ODggfTsgLy8gbm9uc2Vuc2UhXHJcbiAgICBjb25zdCBnckdlb0ogPSB0ZXJyYWZvcm1lci5BcmNHSVMucGFyc2UoZ2VvbWV0cnksIHsgc3I6IDg4ODggfSk7XHJcbiAgICBnZW9tZXRyeS5zcGF0aWFsUmVmZXJlbmNlID0gcmVhbFNSO1xyXG5cclxuICAgIC8vIHByb2plY3QganNvblxyXG4gICAgcHJvamVjdEdlb2pzb24oZ3JHZW9KLCBub3JtYWxpemVQcm9qKGRlc3RQcm9qKSwgbm9ybWFsaXplUHJvaihyZWFsU1IpKTtcclxuXHJcbiAgICAvLyBiYWNrIHRvIGVzcmkgZm9ybWF0XHJcbiAgICBjb25zdCBnckVzcmkgPSB0ZXJyYWZvcm1lci5BcmNHSVMuY29udmVydChnckdlb0opO1xyXG5cclxuICAgIC8vIGRvaW5nIHRoaXMgYmVjYXVzZSAuY29udmVydCBsaWtlcyB0byBhdHRhY2ggYSBsYXQvbG9uZyBzcGF0aWFsIHJlZmVyZW5jZSBmb3IgZnVuLlxyXG4gICAgZ3JFc3JpLnNwYXRpYWxSZWZlcmVuY2UgPSBkZXN0UHJvajtcclxuXHJcbiAgICByZXR1cm4gZ3JFc3JpO1xyXG59XHJcblxyXG4vKipcclxuICogUmVwcm9qZWN0IGFuIEVzcmlFeHRlbnQgb2JqZWN0IG9uIHRoZSBjbGllbnQuICBEb2VzIG5vdCByZXF1aXJlIG5ldHdvcmtcclxuICogdHJhZmZpYywgYnV0IG1heSBub3QgaGFuZGxlIGNvbnZlcnNpb24gYmV0d2VlbiBwcm9qZWN0aW9uIHR5cGVzIGFzIHdlbGwuXHJcbiAqIEludGVybmFsbHkgaXQgdGVzdHMgOCBwb2ludHMgYWxvbmcgZWFjaCBlZGdlIGFuZCB0YWtlcyB0aGUgbWF4IGV4dGVudFxyXG4gKiBvZiB0aGUgcmVzdWx0LlxyXG4gKlxyXG4gKiBAcGFyYW0ge0VzcmlFeHRlbnR9IGV4dGVudCB0byByZXByb2plY3RcclxuICogQHBhcmFtIHtPYmplY3R9IHNyIGlzIHRoZSB0YXJnZXQgc3BhdGlhbCByZWZlcmVuY2UgKGlmIGEgbnVtYmVyIGl0XHJcbiAqICAgICAgICAgICAgICAgICB3aWxsIGJlIHRyZWF0ZWQgYXMgYSBXS0lEKVxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBhbiBleHRlbnQgYXMgYW4gdW5zdHJ1Y3R1cmVkIG9iamVjdFxyXG4gKi9cclxuZnVuY3Rpb24gbG9jYWxQcm9qZWN0RXh0ZW50KGV4dGVudCwgc3IpIHtcclxuXHJcbiAgICAvLyBpbnRlcnBvbGF0ZXMgdHdvIHBvaW50cyBieSBzcGxpdHRpbmcgdGhlIGxpbmUgaW4gaGFsZiByZWN1cnNpdmVseVxyXG4gICAgZnVuY3Rpb24gaW50ZXJwb2xhdGUocDAsIHAxLCBzdGVwcykge1xyXG4gICAgICAgIGlmIChzdGVwcyA9PT0gMCkgeyByZXR1cm4gW3AwLCBwMV07IH1cclxuXHJcbiAgICAgICAgbGV0IG1pZCA9IFsocDBbMF0gKyBwMVswXSkgLyAyLCAocDBbMV0gKyBwMVsxXSkgLyAyXTtcclxuICAgICAgICBpZiAoc3RlcHMgPT09IDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtwMCwgbWlkLCBwMV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdGVwcyA+IDEpIHtcclxuICAgICAgICAgICAgbGV0IGkwID0gaW50ZXJwb2xhdGUocDAsIG1pZCwgc3RlcHMgLSAxKTtcclxuICAgICAgICAgICAgbGV0IGkxID0gaW50ZXJwb2xhdGUobWlkLCBwMSwgc3RlcHMgLSAxKTtcclxuICAgICAgICAgICAgcmV0dXJuIGkwLmNvbmNhdChpMS5zbGljZSgxKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHBvaW50cyA9IFtbZXh0ZW50LnhtaW4sIGV4dGVudC55bWluXSwgW2V4dGVudC54bWF4LCBleHRlbnQueW1pbl0sXHJcbiAgICAgICAgICAgICAgICAgICAgW2V4dGVudC54bWF4LCBleHRlbnQueW1heF0sIFtleHRlbnQueG1pbiwgZXh0ZW50LnltYXhdLFxyXG4gICAgICAgICAgICAgICAgICAgIFtleHRlbnQueG1pbiwgZXh0ZW50LnltaW5dXTtcclxuICAgIGxldCBpbnRlcnBvbGF0ZWRQb2x5ID0gW107XHJcbiAgICBsZXQgc3JjUHJvajtcclxuXHJcbiAgICAvLyBpbnRlcnBvbGF0ZSBlYWNoIGVkZ2UgYnkgc3BsaXR0aW5nIGl0IGluIGhhbGYgMyB0aW1lcyAoc2luY2UgbGluZXMgYXJlIG5vdCBndWFyYW50ZWVkIHRvIHByb2plY3QgdG8gbGluZXMgd2UgbmVlZCB0byBjb25zaWRlclxyXG4gICAgLy8gbWF4IC8gbWluIHBvaW50cyBpbiB0aGUgbWlkZGxlIG9mIGxpbmUgc2VnbWVudHMpXHJcbiAgICBbMCwgMSwgMiwgM11cclxuICAgICAgICAubWFwKGkgPT4gaW50ZXJwb2xhdGUocG9pbnRzW2ldLCBwb2ludHNbaSArIDFdLCAzKS5zbGljZSgxKSlcclxuICAgICAgICAuZm9yRWFjaChzZWcgPT4gaW50ZXJwb2xhdGVkUG9seSA9IGludGVycG9sYXRlZFBvbHkuY29uY2F0KHNlZykpO1xyXG5cclxuICAgIC8vIGZpbmQgdGhlIHNvdXJjZSBleHRlbnQgKGVpdGhlciBmcm9tIHdraWQgb3Igd2t0KVxyXG4gICAgaWYgKGV4dGVudC5zcGF0aWFsUmVmZXJlbmNlLndraWQpIHtcclxuICAgICAgICBzcmNQcm9qID0gJ0VQU0c6JyArIGV4dGVudC5zcGF0aWFsUmVmZXJlbmNlLndraWQ7XHJcbiAgICB9IGVsc2UgaWYgKGV4dGVudC5zcGF0aWFsUmVmZXJlbmNlLndrdCkge1xyXG4gICAgICAgIHNyY1Byb2ogPSBleHRlbnQuc3BhdGlhbFJlZmVyZW5jZS53a3Q7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gV0tUIG9yIFdLSUQgc3BlY2lmaWVkIG9uIGV4dGVudC5zcGF0aWFsUmVmZXJlbmNlJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZmluZCB0aGUgZGVzdGluYXRpb24gZXh0ZW50XHJcbiAgICBsZXQgZGVzdFByb2ogPSBub3JtYWxpemVQcm9qKHNyKTtcclxuXHJcbiAgICBpZiAoZXh0ZW50LnNwYXRpYWxSZWZlcmVuY2Uud2tpZCAmJiAhcHJvajQuZGVmcyhzcmNQcm9qKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU291cmNlIHByb2plY3Rpb24gV0tJRCBub3QgcmVjb2duaXplZCBieSBwcm9qNCBsaWJyYXJ5Jyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBwcm9qQ29udmVydCA9IHByb2o0KHNyY1Byb2osIGRlc3RQcm9qKTtcclxuICAgIGNvbnN0IHRyYW5zZm9ybWVkID0gaW50ZXJwb2xhdGVkUG9seS5tYXAoeCA9PiBwcm9qQ29udmVydC5mb3J3YXJkKHgpKTtcclxuXHJcbiAgICBjb25zdCB4dmFscyA9IHRyYW5zZm9ybWVkLm1hcCh4ID0+IHhbMF0pO1xyXG4gICAgY29uc3QgeXZhbHMgPSB0cmFuc2Zvcm1lZC5tYXAoeCA9PiB4WzFdKTtcclxuXHJcbiAgICBjb25zdCB4MCA9IE1hdGgubWluLmFwcGx5KG51bGwsIHh2YWxzKTtcclxuICAgIGNvbnN0IHgxID0gTWF0aC5tYXguYXBwbHkobnVsbCwgeHZhbHMpO1xyXG5cclxuICAgIGNvbnN0IHkwID0gTWF0aC5taW4uYXBwbHkobnVsbCwgeXZhbHMpO1xyXG4gICAgY29uc3QgeTEgPSBNYXRoLm1heC5hcHBseShudWxsLCB5dmFscyk7XHJcblxyXG4gICAgcmV0dXJuIHsgeDAsIHkwLCB4MSwgeTEsIHNyIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVjayB3aGV0aGVyIG9yIG5vdCBhIHNwYXRpYWxSZWZlcmVuY2UgaXMgc3VwcG9ydGVkIGJ5IHByb2o0IGxpYnJhcnkuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBzcGF0aWFsUmVmZXJlbmNlIHRvIGJlIGNoZWNrZWQgdG8gc2VlIGlmIGl0J3Mgc3VwcG9ydGVkIGJ5IHByb2o0XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVwc2dMb29rdXAgYW4gb3B0aW9uYWwgbG9va3VwIGZ1bmN0aW9uIGZvciBFUFNHIGNvZGVzIHdoaWNoIGFyZSBub3QgbG9hZGVkXHJcbiAqIGluIHRoZSBwcm9qNCBkZWZpbml0aW9ucywgdGhlIGZ1bmN0aW9uIHNob3VsZCB0YWtlIGEgbnVtZXJpYyBFUFNHIGNvZGUgYW5kIHJldHVybiBhIFByb21pc2VcclxuICogcmVzb2x2aW5nIHdpdGggYSBwcm9qNCBzdHlsZSBkZWZpbml0aW9uIHN0cmluZ1xyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSB3aXRoIHRoZSBzdHJ1Y3R1cmUge1xyXG4gKiAgZm91bmRQcm9qOiAoYm9vbCkgaW5kaWNhdGVzIGlmIHRoZSBwcm9qZWN0aW9uIHdhcyBmb3VuZCxcclxuICogIG1lc3NhZ2U6IChzdHJpbmcpIHByb3ZpZGVzIGEgcmVhc29uIHdoeSB0aGUgcHJvamVjdGlvbiB3YXMgbm90IGZvdW5kLFxyXG4gKiAgbG9va3VwUHJvbWlzZTogKFByb21pc2UpIGFuIG9wdGlvbmFsIHByb21pc2UgcmVzb2x2aW5nIHdpdGggdHJ1ZSBvciBmYWxzZSBpZiBhIGxvb2t1cCBmdW5jdGlvbiB3YXMgcHJvdmlkZWQgYW5kIGhhZCB0byBiZSBpbnZva2VkXHJcbiAqIH1cclxuICovXHJcbmZ1bmN0aW9uIGNoZWNrUHJvaihzcGF0aWFsUmVmZXJlbmNlLCBlcHNnTG9va3VwKSB7XHJcbiAgICBsZXQgc3JjUHJvajtcclxuXHJcbiAgICAvLyBmaW5kIHRoZSBzb3VyY2UgZXh0ZW50IChlaXRoZXIgZnJvbSB3a2lkIG9yIHdrdClcclxuICAgIGlmIChzcGF0aWFsUmVmZXJlbmNlLndraWQpIHtcclxuICAgICAgICBzcmNQcm9qID0gJ0VQU0c6JyArIHNwYXRpYWxSZWZlcmVuY2Uud2tpZDtcclxuICAgIH0gZWxzZSBpZiAoc3BhdGlhbFJlZmVyZW5jZS53a3QpIHtcclxuICAgICAgICBzcmNQcm9qID0gc3BhdGlhbFJlZmVyZW5jZS53a3Q7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGZvdW5kUHJvajogZmFsc2UsXHJcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdObyBXS1Qgb3IgV0tJRCBzcGVjaWZpZWQgb24gZXh0ZW50LnNwYXRpYWxSZWZlcmVuY2UnXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoc3BhdGlhbFJlZmVyZW5jZS53a2lkICYmICFwcm9qNC5kZWZzKHNyY1Byb2opKSB7XHJcbiAgICAgICAgaWYgKGVwc2dMb29rdXApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGZvdW5kUHJvajogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnQXR0ZW1wdGluZyB0byBsb29rdXAgV0tJRCcsXHJcbiAgICAgICAgICAgICAgICBsb29rdXBQcm9taXNlOiBlcHNnTG9va3VwKHNwYXRpYWxSZWZlcmVuY2Uud2tpZCkudGhlbihkZWYgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWYgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBwcm9qNC5kZWZzKHNyY1Byb2osIGRlZik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBmb3VuZFByb2o6IGZhbHNlLFxyXG4gICAgICAgICAgICBtZXNzYWdlOiAnU291cmNlIHByb2plY3Rpb24gaW4gV0tJRCBhbmQgbm90IHJlY29nbml6ZWQgYnkgcHJvajQgbGlicmFyeSdcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZm91bmRQcm9qOiB0cnVlLFxyXG4gICAgICAgIG1lc3NhZ2U6ICdTb3VyY2UgcHJvamVjdGlvbiBPSy4nXHJcbiAgICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBwcm9qZWN0RXNyaUV4dGVudEJ1aWxkZXIoZXNyaUJ1bmRsZSkge1xyXG4gICAgcmV0dXJuIChleHRlbnQsIHNyKSA9PiB7XHJcbiAgICAgICAgY29uc3QgcCA9IGxvY2FsUHJvamVjdEV4dGVudChleHRlbnQsIHNyKTtcclxuICAgICAgICByZXR1cm4gbmV3IGVzcmlCdW5kbGUuRXh0ZW50KHAueDAsIHAueTAsIHAueDEsIHAueTEsIHAuc3IpO1xyXG4gICAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gZXNyaVNlcnZpY2VCdWlsZGVyKGVzcmlCdW5kbGUpIHtcclxuICAgIC8qKlxyXG4gICAgICogUmVwcm9qZWN0IGFuIGVzcmkgZ2VvbWV0cnkgb2JqZWN0IG9uIHRoZSBzZXJ2ZXIuIFJlcXVpcmVzIG5ldHdvcmsgdHJhZmZpY1xyXG4gICAgICogdG8gZXNyaSdzIEdlb21ldHJ5IFNlcnZpY2UsIGJ1dCBtYXkgYmUgc2xvd2VyIHRoYW4gcHJvajQgY29udmVyc2lvbi5cclxuICAgICAqIEludGVybmFsbHkgaXQgdGVzdHMgMSBwb2ludCBhbmQgcmVwcm9qZWN0cyBpdCB0byBhbm90aGVyIHNwYXRpYWwgcmVmZXJlbmNlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7dXJsfSB1cmwgZm9yIHRoZSBFU1JJIEdlb21ldHJ5IFNlcnZpY2VcclxuICAgICAqIEBwYXJhbSB7Z2VvbWV0cmllc30gZ2VvbWV0cmllcyB0byBiZSBwcm9qZWN0ZWRcclxuICAgICAqIEBwYXJhbSB7c3J9IHNyIGlzIHRoZSB0YXJnZXQgc3BhdGlhbCByZWZlcmVuY2VcclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBwcm9taXNlIHRvIHJldHVybiByZXByb2plY3RlZCBnZW9tZXRyaWVzXHJcbiAgICAgKi9cclxuICAgIHJldHVybiAodXJsLCBnZW9tZXRyaWVzLCBzcikgPT4ge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShcclxuICAgICAgICAgICAgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IGVzcmlCdW5kbGUuUHJvamVjdFBhcmFtZXRlcnMoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBjb25uZWN0IHRvIGVzcmkgc2VydmVyXHJcbiAgICAgICAgICAgICAgICBjb25zdCBnc3ZjID0gbmV3IGVzcmlCdW5kbGUuR2VvbWV0cnlTZXJ2aWNlKHVybCk7XHJcblxyXG4gICAgICAgICAgICAgICAgcGFyYW1zLmdlb21ldHJpZXMgPSBnZW9tZXRyaWVzO1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zLm91dFNSID0gc3I7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gY2FsbCBwcm9qZWN0IGZ1bmN0aW9uIGZyb20gZXNyaSBzZXJ2ZXIgdG8gZG8gY29udmVyc2lvblxyXG4gICAgICAgICAgICAgICAgZ3N2Yy5wcm9qZWN0KHBhcmFtcyxcclxuICAgICAgICAgICAgICAgICAgICBwcm9qZWN0ZWRFeHRlbnRzID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShwcm9qZWN0ZWRFeHRlbnRzKTtcclxuICAgICAgICAgICAgICAgICAgICB9LCBlcnJvciA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfTtcclxufVxyXG5cclxuLyoqXHJcbiogQ2hlY2tzIGlmIHR3byBzcGF0aWFsIHJlZmVyZW5jZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LiAgSGFuZGxlcyBib3RoIHdraWQgYW5kIHdrdCBkZWZpbml0aW9ucy5cclxuKlxyXG4qIEBtZXRob2QgaXNTcGF0aWFsUmVmRXF1YWxcclxuKiBAc3RhdGljXHJcbiogQHBhcmFtIHt0eXBlfSBzcjEgRXNyaSBTcGF0aWFsIFJlZmVyZW5jZSBGaXJzdCB0byBjb21wYXJlXHJcbiogQHBhcmFtIHt0eXBlfSBzcjIgRXNyaSBTcGF0aWFsIFJlZmVyZW5jZSBTZWNvbmQgdG8gY29tcGFyZVxyXG4qIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIHR3byBzcGF0aWFsIHJlZmVyZW5jZXMgYXJlIGVxdWl2YWxlbnQuICBGYWxzZSBvdGhlcndpc2UuXHJcbiovXHJcbmZ1bmN0aW9uIGlzU3BhdGlhbFJlZkVxdWFsKHNyMSwgc3IyKSB7XHJcbiAgICBpZiAoKHNyMS53a2lkKSAmJiAoc3IyLndraWQpKSB7XHJcbiAgICAgICAgLy8gYm90aCBTUnMgaGF2ZSB3a2lkc1xyXG4gICAgICAgIHJldHVybiBzcjEud2tpZCA9PT0gc3IyLndraWQ7XHJcbiAgICB9IGVsc2UgaWYgKChzcjEud2t0KSAmJiAoc3IyLndrdCkpIHtcclxuICAgICAgICAvLyBib3RoIFNScyBoYXZlIHdrdCdzXHJcbiAgICAgICAgcmV0dXJuIHNyMS53a3QgPT09IHNyMi53a3Q7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIG5vdCBlbm91Z2ggaW5mbyBwcm92aWRlZCBvciBtaXNtYXRjaCBiZXR3ZWVuIHdraWQgYW5kIHdrdC5cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGVzcmlCdW5kbGUpIHtcclxuICAgIC8vIFRPRE86IE1vdmUgUG9pbnQgYW5kIFNwYXRpYWxSZWZlcmVuY2UgdG8gaXRzIG93biAoZ2VvbWV0cnkpIG1vZHVsZVxyXG5cclxuICAgIC8vIFRPRE8gY29uc2lkZXIgbW92aW5nIHRoaXMgZWxzZXdoZXJlLiAgc3RhdGUgaXMgYmFkLCBidXQgdGhlc2UgYXJlIGNvbW1vbiwgYW5kIHdlIGhhdmUgbm8gc2VydmljZSBmb3IgZXNyaSBkZWZzXHJcbiAgICBwcm9qNC5kZWZzKCdFUFNHOjM5NzgnLCAnK3Byb2o9bGNjICtsYXRfMT00OSArbGF0XzI9NzcgK2xhdF8wPTQ5ICcgK1xyXG4gICAgICAgICcrbG9uXzA9LTk1ICt4XzA9MCAreV8wPTAgK2VsbHBzPUdSUzgwICt0b3dnczg0PTAsMCwwLDAsMCwwLDAgK3VuaXRzPW0gK25vX2RlZnMnKTtcclxuICAgIHByb2o0LmRlZnMoJ0VQU0c6Mzk3OScsICcrcHJvaj1sY2MgK2xhdF8xPTQ5ICtsYXRfMj03NyArbGF0XzA9NDkgK2xvbl8wPS05NSAnICtcclxuICAgICAgICAnK3hfMD0wICt5XzA9MCArZWxscHM9R1JTODAgK3Rvd2dzODQ9MCwwLDAsMCwwLDAsMCArdW5pdHM9bSArbm9fZGVmcycpO1xyXG4gICAgcHJvajQuZGVmcygnRVBTRzo1NDAwNCcsICcrcHJvaj1tZXJjICtsb25fMD0wICtrPTEgK3hfMD0wICt5XzA9MCArZWxscHM9V0dTODQgJyArXHJcbiAgICAgICAgJytkYXR1bT1XR1M4NCArdW5pdHM9bSArbm9fZGVmcycpO1xyXG4gICAgcHJvajQuZGVmcygnRVBTRzoxMDIxMDAnLCBwcm9qNC5kZWZzKCdFUFNHOjM4NTcnKSk7XHJcblxyXG4gICAgLy8gYWRkIFVUTSBwcm9qZWN0aW9uc1xyXG4gICAgbGV0IHV0bSA9IDE7XHJcbiAgICB3aGlsZSAodXRtIDw9IDYwKSB7XHJcbiAgICAgICAgbGV0IHpvbmUgPSB1dG0gPCAxMCA/IGAwJHt1dG19YCA6IHV0bTtcclxuICAgICAgICBwcm9qNC5kZWZzKGBFUFNHOjMyNiR7em9uZX1gLCBgK3Byb2o9dXRtICt6b25lPSR7dXRtfSArZWxscHM9V0dTODQgK2RhdHVtPVdHUzg0ICt1bml0cz1tICtub19kZWZzYCk7XHJcbiAgICAgICAgdXRtKys7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBhZGRQcm9qZWN0aW9uOiBwcm9qNC5kZWZzLCAvLyBzdHJhaWdodCBwYXNzdGhyb3VnaCBhdCB0aGUgbW9tZW50LCBtYXliZSBhZGQgYXJnIGNoZWNraW5nICh0d28gYXJncyk/XHJcbiAgICAgICAgY2hlY2tQcm9qLFxyXG4gICAgICAgIGdldFByb2plY3Rpb246IHByb2o0LmRlZnMsIC8vIHN0cmFpZ2h0IHBhc3N0aHJvdWdoIGF0IHRoZSBtb21lbnQsIG1heWJlIGFkZCBhcmcgY2hlY2tpbmcgKG9uZSBhcmcpP1xyXG4gICAgICAgIGVzcmlTZXJ2ZXJQcm9qZWN0OiBlc3JpU2VydmljZUJ1aWxkZXIoZXNyaUJ1bmRsZSksXHJcbiAgICAgICAgR3JhcGhpYzogZXNyaUJ1bmRsZS5HcmFwaGljLFxyXG4gICAgICAgIGdyYXBoaWNzVXRpbHM6IGVzcmlCdW5kbGUuZ3JhcGhpY3NVdGlscyxcclxuICAgICAgICBpc1NwYXRpYWxSZWZFcXVhbCxcclxuICAgICAgICBsb2NhbFByb2plY3RFeHRlbnQsXHJcbiAgICAgICAgbG9jYWxQcm9qZWN0UG9pbnQsXHJcbiAgICAgICAgbG9jYWxQcm9qZWN0R2VvbWV0cnksXHJcbiAgICAgICAgcHJvamVjdEdlb2pzb24sXHJcbiAgICAgICAgUG9pbnQ6IGVzcmlCdW5kbGUuUG9pbnQsXHJcbiAgICAgICAgcHJvamVjdEVzcmlFeHRlbnQ6IHByb2plY3RFc3JpRXh0ZW50QnVpbGRlcihlc3JpQnVuZGxlKSxcclxuICAgICAgICBTcGF0aWFsUmVmZXJlbmNlOiBlc3JpQnVuZGxlLlNwYXRpYWxSZWZlcmVuY2VcclxuICAgIH07XHJcbn07XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9wcm9qLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){"use strict";eval("\n\n// functions related to spatial querying\n\nfunction queryGeometryBuilder(esriBundle) {\n\n    /**\r\n    * Fetch attributes from a layer that intersects with the given geometry\r\n    * Accepts the following options:\r\n    *   - geometry: Required. geometry to intersect with the layer.\r\n    *   - url: Required if server based layer. Url to the map service layer to query against. Endpoint must support\r\n    *          ESRI REST query interface. E.g. A feature layer endpoint.\r\n    *   - featureLayer: Required if file based layer. Feature layer to query against\r\n    *   - outFields: Optional. Array of strings containing field names to include in the results. Defaults to all fields.\r\n    *   - where: Optional. A SQL where clause to filter results further. Useful when dealing with more results than the server can return.\r\n    *   - returnGeometry: Optional. A boolean indicating if result geometery should be returned with results.  Defaults to false\r\n    *   - outSpatialReference: Required if returnGeometry is true. The spatial reference the return geometry should be in.\r\n    * @param {Object} options settings to determine if sub layers or certain attributes should be skipped.\r\n    * @return {Promise} resolves with a feature set of features that satisfy the query\r\n    */\n    return function (options) {\n        // create and set the esri query parameters\n\n        var query = new esriBundle.Query();\n\n        query.returnGeometry = options.returnGeometry || false;\n        if (options.returnGeometry) {\n            query.outSpatialReference = options.outSpatialReference;\n        }\n        if (options.outFields) {\n            query.outFields = options.outFields;\n        } else {\n            query.outFields = ['*'];\n        }\n        if (options.where) {\n            query.where = options.where;\n        }\n        query.geometry = options.geometry;\n        query.spatialRelationship = esriBundle.Query.SPATIAL_REL_INTERSECTS; // esriSpatialRelIntersects\n\n        return new Promise(function (resolve, reject) {\n            // run the query. server based layers use a query task. file based layers use the layer's query function.\n            if (options.url) {\n                var queryTask = new esriBundle.QueryTask(options.url);\n\n                // issue the map server query request\n                queryTask.execute(query, function (featureSet) {\n                    resolve(featureSet);\n                }, function (error) {\n                    reject(error);\n                });\n            } else if (options.featureLayer) {\n                // run the query on the layers internal data\n                options.featureLayer.queryFeatures(query, function (featureSet) {\n                    resolve(featureSet);\n                }, function (error) {\n                    reject(error);\n                });\n            }\n        });\n    };\n}\n\nmodule.exports = function (esriBundle) {\n    return {\n        queryGeometry: queryGeometryBuilder(esriBundle)\n    };\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcXVlcnkuanM/Y2Y3MiJdLCJuYW1lcyI6WyJxdWVyeUdlb21ldHJ5QnVpbGRlciIsImVzcmlCdW5kbGUiLCJxdWVyeSIsIlF1ZXJ5IiwicmV0dXJuR2VvbWV0cnkiLCJvcHRpb25zIiwib3V0U3BhdGlhbFJlZmVyZW5jZSIsIm91dEZpZWxkcyIsIndoZXJlIiwiZ2VvbWV0cnkiLCJzcGF0aWFsUmVsYXRpb25zaGlwIiwiU1BBVElBTF9SRUxfSU5URVJTRUNUUyIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwidXJsIiwicXVlcnlUYXNrIiwiUXVlcnlUYXNrIiwiZXhlY3V0ZSIsImZlYXR1cmVTZXQiLCJlcnJvciIsImZlYXR1cmVMYXllciIsInF1ZXJ5RmVhdHVyZXMiLCJtb2R1bGUiLCJleHBvcnRzIiwicXVlcnlHZW9tZXRyeSJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7O0FBRUEsU0FBU0Esb0JBQVQsQ0FBOEJDLFVBQTlCLEVBQTBDOztBQUV0Qzs7Ozs7Ozs7Ozs7Ozs7QUFjQSxXQUFPLG1CQUFXO0FBQ2Q7O0FBRUEsWUFBTUMsUUFBUSxJQUFJRCxXQUFXRSxLQUFmLEVBQWQ7O0FBRUFELGNBQU1FLGNBQU4sR0FBdUJDLFFBQVFELGNBQVIsSUFBMEIsS0FBakQ7QUFDQSxZQUFJQyxRQUFRRCxjQUFaLEVBQTRCO0FBQ3hCRixrQkFBTUksbUJBQU4sR0FBNEJELFFBQVFDLG1CQUFwQztBQUNIO0FBQ0QsWUFBSUQsUUFBUUUsU0FBWixFQUF1QjtBQUNuQkwsa0JBQU1LLFNBQU4sR0FBa0JGLFFBQVFFLFNBQTFCO0FBQ0gsU0FGRCxNQUVPO0FBQ0hMLGtCQUFNSyxTQUFOLEdBQWtCLENBQUMsR0FBRCxDQUFsQjtBQUNIO0FBQ0QsWUFBSUYsUUFBUUcsS0FBWixFQUFtQjtBQUNmTixrQkFBTU0sS0FBTixHQUFjSCxRQUFRRyxLQUF0QjtBQUNIO0FBQ0ROLGNBQU1PLFFBQU4sR0FBaUJKLFFBQVFJLFFBQXpCO0FBQ0FQLGNBQU1RLG1CQUFOLEdBQTRCVCxXQUFXRSxLQUFYLENBQWlCUSxzQkFBN0MsQ0FsQmMsQ0FrQnVEOztBQUVyRSxlQUFPLElBQUlDLE9BQUosQ0FBWSxVQUFDQyxPQUFELEVBQVVDLE1BQVYsRUFBcUI7QUFDcEM7QUFDQSxnQkFBSVQsUUFBUVUsR0FBWixFQUFpQjtBQUNiLG9CQUFNQyxZQUFZLElBQUlmLFdBQVdnQixTQUFmLENBQXlCWixRQUFRVSxHQUFqQyxDQUFsQjs7QUFFQTtBQUNBQywwQkFBVUUsT0FBVixDQUFrQmhCLEtBQWxCLEVBQ0ksc0JBQWM7QUFDVlcsNEJBQVFNLFVBQVI7QUFDSCxpQkFITCxFQUlJLGlCQUFTO0FBQ0xMLDJCQUFPTSxLQUFQO0FBQ0gsaUJBTkw7QUFRSCxhQVpELE1BWU8sSUFBSWYsUUFBUWdCLFlBQVosRUFBMEI7QUFDN0I7QUFDQWhCLHdCQUFRZ0IsWUFBUixDQUFxQkMsYUFBckIsQ0FBbUNwQixLQUFuQyxFQUNJLHNCQUFjO0FBQ1ZXLDRCQUFRTSxVQUFSO0FBQ0gsaUJBSEwsRUFJSSxpQkFBUztBQUNMTCwyQkFBT00sS0FBUDtBQUNILGlCQU5MO0FBUUg7QUFDSixTQXpCTSxDQUFQO0FBMEJILEtBOUNEO0FBK0NIOztBQUVERyxPQUFPQyxPQUFQLEdBQWlCLHNCQUFjO0FBQzNCLFdBQU87QUFDSEMsdUJBQWV6QixxQkFBcUJDLFVBQXJCO0FBRFosS0FBUDtBQUdILENBSkQiLCJmaWxlIjoiNzguanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG4vLyBmdW5jdGlvbnMgcmVsYXRlZCB0byBzcGF0aWFsIHF1ZXJ5aW5nXHJcblxyXG5mdW5jdGlvbiBxdWVyeUdlb21ldHJ5QnVpbGRlcihlc3JpQnVuZGxlKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEZldGNoIGF0dHJpYnV0ZXMgZnJvbSBhIGxheWVyIHRoYXQgaW50ZXJzZWN0cyB3aXRoIHRoZSBnaXZlbiBnZW9tZXRyeVxyXG4gICAgKiBBY2NlcHRzIHRoZSBmb2xsb3dpbmcgb3B0aW9uczpcclxuICAgICogICAtIGdlb21ldHJ5OiBSZXF1aXJlZC4gZ2VvbWV0cnkgdG8gaW50ZXJzZWN0IHdpdGggdGhlIGxheWVyLlxyXG4gICAgKiAgIC0gdXJsOiBSZXF1aXJlZCBpZiBzZXJ2ZXIgYmFzZWQgbGF5ZXIuIFVybCB0byB0aGUgbWFwIHNlcnZpY2UgbGF5ZXIgdG8gcXVlcnkgYWdhaW5zdC4gRW5kcG9pbnQgbXVzdCBzdXBwb3J0XHJcbiAgICAqICAgICAgICAgIEVTUkkgUkVTVCBxdWVyeSBpbnRlcmZhY2UuIEUuZy4gQSBmZWF0dXJlIGxheWVyIGVuZHBvaW50LlxyXG4gICAgKiAgIC0gZmVhdHVyZUxheWVyOiBSZXF1aXJlZCBpZiBmaWxlIGJhc2VkIGxheWVyLiBGZWF0dXJlIGxheWVyIHRvIHF1ZXJ5IGFnYWluc3RcclxuICAgICogICAtIG91dEZpZWxkczogT3B0aW9uYWwuIEFycmF5IG9mIHN0cmluZ3MgY29udGFpbmluZyBmaWVsZCBuYW1lcyB0byBpbmNsdWRlIGluIHRoZSByZXN1bHRzLiBEZWZhdWx0cyB0byBhbGwgZmllbGRzLlxyXG4gICAgKiAgIC0gd2hlcmU6IE9wdGlvbmFsLiBBIFNRTCB3aGVyZSBjbGF1c2UgdG8gZmlsdGVyIHJlc3VsdHMgZnVydGhlci4gVXNlZnVsIHdoZW4gZGVhbGluZyB3aXRoIG1vcmUgcmVzdWx0cyB0aGFuIHRoZSBzZXJ2ZXIgY2FuIHJldHVybi5cclxuICAgICogICAtIHJldHVybkdlb21ldHJ5OiBPcHRpb25hbC4gQSBib29sZWFuIGluZGljYXRpbmcgaWYgcmVzdWx0IGdlb21ldGVyeSBzaG91bGQgYmUgcmV0dXJuZWQgd2l0aCByZXN1bHRzLiAgRGVmYXVsdHMgdG8gZmFsc2VcclxuICAgICogICAtIG91dFNwYXRpYWxSZWZlcmVuY2U6IFJlcXVpcmVkIGlmIHJldHVybkdlb21ldHJ5IGlzIHRydWUuIFRoZSBzcGF0aWFsIHJlZmVyZW5jZSB0aGUgcmV0dXJuIGdlb21ldHJ5IHNob3VsZCBiZSBpbi5cclxuICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgc2V0dGluZ3MgdG8gZGV0ZXJtaW5lIGlmIHN1YiBsYXllcnMgb3IgY2VydGFpbiBhdHRyaWJ1dGVzIHNob3VsZCBiZSBza2lwcGVkLlxyXG4gICAgKiBAcmV0dXJuIHtQcm9taXNlfSByZXNvbHZlcyB3aXRoIGEgZmVhdHVyZSBzZXQgb2YgZmVhdHVyZXMgdGhhdCBzYXRpc2Z5IHRoZSBxdWVyeVxyXG4gICAgKi9cclxuICAgIHJldHVybiBvcHRpb25zID0+IHtcclxuICAgICAgICAvLyBjcmVhdGUgYW5kIHNldCB0aGUgZXNyaSBxdWVyeSBwYXJhbWV0ZXJzXHJcblxyXG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gbmV3IGVzcmlCdW5kbGUuUXVlcnkoKTtcclxuXHJcbiAgICAgICAgcXVlcnkucmV0dXJuR2VvbWV0cnkgPSBvcHRpb25zLnJldHVybkdlb21ldHJ5IHx8IGZhbHNlO1xyXG4gICAgICAgIGlmIChvcHRpb25zLnJldHVybkdlb21ldHJ5KSB7XHJcbiAgICAgICAgICAgIHF1ZXJ5Lm91dFNwYXRpYWxSZWZlcmVuY2UgPSBvcHRpb25zLm91dFNwYXRpYWxSZWZlcmVuY2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcHRpb25zLm91dEZpZWxkcykge1xyXG4gICAgICAgICAgICBxdWVyeS5vdXRGaWVsZHMgPSBvcHRpb25zLm91dEZpZWxkcztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBxdWVyeS5vdXRGaWVsZHMgPSBbJyonXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9wdGlvbnMud2hlcmUpIHtcclxuICAgICAgICAgICAgcXVlcnkud2hlcmUgPSBvcHRpb25zLndoZXJlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBxdWVyeS5nZW9tZXRyeSA9IG9wdGlvbnMuZ2VvbWV0cnk7XHJcbiAgICAgICAgcXVlcnkuc3BhdGlhbFJlbGF0aW9uc2hpcCA9IGVzcmlCdW5kbGUuUXVlcnkuU1BBVElBTF9SRUxfSU5URVJTRUNUUzsgLy8gZXNyaVNwYXRpYWxSZWxJbnRlcnNlY3RzXHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIC8vIHJ1biB0aGUgcXVlcnkuIHNlcnZlciBiYXNlZCBsYXllcnMgdXNlIGEgcXVlcnkgdGFzay4gZmlsZSBiYXNlZCBsYXllcnMgdXNlIHRoZSBsYXllcidzIHF1ZXJ5IGZ1bmN0aW9uLlxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy51cmwpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHF1ZXJ5VGFzayA9IG5ldyBlc3JpQnVuZGxlLlF1ZXJ5VGFzayhvcHRpb25zLnVybCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gaXNzdWUgdGhlIG1hcCBzZXJ2ZXIgcXVlcnkgcmVxdWVzdFxyXG4gICAgICAgICAgICAgICAgcXVlcnlUYXNrLmV4ZWN1dGUocXVlcnksXHJcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZVNldCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZmVhdHVyZVNldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBlcnJvciA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmZlYXR1cmVMYXllcikge1xyXG4gICAgICAgICAgICAgICAgLy8gcnVuIHRoZSBxdWVyeSBvbiB0aGUgbGF5ZXJzIGludGVybmFsIGRhdGFcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMuZmVhdHVyZUxheWVyLnF1ZXJ5RmVhdHVyZXMocXVlcnksXHJcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZVNldCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZmVhdHVyZVNldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBlcnJvciA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBlc3JpQnVuZGxlID0+IHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcXVlcnlHZW9tZXRyeTogcXVlcnlHZW9tZXRyeUJ1aWxkZXIoZXNyaUJ1bmRsZSlcclxuICAgIH07XHJcbn07XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9xdWVyeS5qcyJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){"use strict";eval("/* jshint maxcomplexity: false */\n\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar svgjs = __webpack_require__(170);\nvar shared = __webpack_require__(23)();\n\n// Functions for turning ESRI Renderers into images\n// Specifically, converting ESRI \"Simple\" symbols into images,\n// and deriving the appropriate image for a feature based on\n// a renderer\n\n// layer symbology types\nvar SIMPLE = 'simple';\nvar UNIQUE_VALUE = 'uniqueValue';\nvar CLASS_BREAKS = 'classBreaks';\n\nvar CONTAINER_SIZE = 32; // size of the symbology item container\nvar CONTENT_SIZE = 24; // size of the symbology graphic\nvar CONTENT_IMAGE_SIZE = 28; // size of the symbology graphic if it's an image (images tend to already have a white boarder around them)\nvar CONTAINER_CENTER = CONTAINER_SIZE / 2;\nvar CONTENT_PADDING = (CONTAINER_SIZE - CONTENT_SIZE) / 2;\n\n/**\r\n* Will add extra properties to a renderer to support images.\r\n* New properties .svgcode and .defaultsvgcode contains image source\r\n* for app on each renderer item.\r\n*\r\n* @param {Object} renderer an ESRI renderer object in server JSON form. Param is modified in place\r\n* @param {Object} legend object for the layer that maps legend label to data url of legend image\r\n* @return {Promise} resolving when the renderer has been enhanced\r\n*/\nfunction enhanceRenderer(renderer, legend) {\n\n    // TODO note somewhere (user docs) that everything fails if someone publishes a legend with two identical labels\n\n    // quick lookup object of legend names to data URLs.\n    // our legend object is in ESRI format, but was generated by us and only has info for a single layer.\n    // so we just grab item 0, which is the only item.\n    var legendLookup = {};\n\n    // store svgcode in the lookup\n    var legendItemPromises = legend.layers[0].legend.map(function (legItem) {\n        return legItem.then(function (data) {\n            return legendLookup[data.label] = data.svgcode;\n        });\n    });\n\n    // wait until all legend items are resolved and legend lookup is updated\n    return Promise.all(legendItemPromises).then(function () {\n        switch (renderer.type) {\n            case SIMPLE:\n                renderer.svgcode = legendLookup[renderer.label];\n                break;\n\n            case UNIQUE_VALUE:\n                if (renderer.defaultLabel) {\n                    renderer.defaultsvgcode = legendLookup[renderer.defaultLabel];\n                }\n\n                renderer.uniqueValueInfos.forEach(function (uvi) {\n                    uvi.svgcode = legendLookup[uvi.label];\n                });\n\n                break;\n            case CLASS_BREAKS:\n                if (renderer.defaultLabel) {\n                    renderer.defaultsvgcode = legendLookup[renderer.defaultLabel];\n                }\n\n                renderer.classBreakInfos.forEach(function (cbi) {\n                    cbi.svgcode = legendLookup[cbi.label];\n                });\n\n                break;\n            default:\n\n                // Renderer we dont support\n                console.warn('encountered unsupported renderer type: ' + renderer.type);\n        }\n    });\n}\n\n/**\r\n* Given feature attributes, find the renderer node that would draw it\r\n*\r\n* @method searchRenderer\r\n* @param {Object} attributes object of feature attribute key value pairs\r\n* @param {Object} renderer an enhanced renderer (see function enhanceRenderer)\r\n* @return {Object} an Object with svgcode and symbol properties for the matched renderer item\r\n*/\nfunction searchRenderer(attributes, renderer) {\n\n    var svgcode = void 0;\n    var symbol = {};\n\n    switch (renderer.type) {\n        case SIMPLE:\n            svgcode = renderer.svgcode;\n            symbol = renderer.symbol;\n\n            break;\n\n        case UNIQUE_VALUE:\n\n            // make a key value for the graphic in question, using comma-space delimiter if multiple fields\n            // put an empty string when key value is null\n            var graphicKey = attributes[renderer.field1] === null ? '' : attributes[renderer.field1];\n\n            // all key values are stored as strings.  if the attribute is in a numeric column, we must convert it to a string to ensure the === operator still works.\n            if (typeof graphicKey !== 'string') {\n                graphicKey = graphicKey.toString();\n            }\n\n            if (renderer.field2) {\n                graphicKey = graphicKey + ', ' + attributes[renderer.field2];\n                if (renderer.field3) {\n                    graphicKey = graphicKey + ', ' + attributes[renderer.field3];\n                }\n            }\n\n            // search the value maps for a matching entry.  if no match found, use the default image\n            var uvi = renderer.uniqueValueInfos.find(function (uvi) {\n                return uvi.value === graphicKey;\n            });\n            if (uvi) {\n                svgcode = uvi.svgcode;\n                symbol = uvi.symbol;\n            } else {\n                svgcode = renderer.defaultsvgcode;\n                symbol = renderer.defaultSymbol;\n            }\n\n            break;\n\n        case CLASS_BREAKS:\n\n            var gVal = parseFloat(attributes[renderer.field]);\n            var lower = renderer.minValue;\n\n            svgcode = renderer.defaultsvgcode;\n            symbol = renderer.defaultSymbol;\n\n            // check for outside range on the low end\n            if (gVal < lower) {\n                break;\n            }\n\n            // array of minimum values of the ranges in the renderer\n            var minSplits = renderer.classBreakInfos.map(function (cbi) {\n                return cbi.classMaxValue;\n            });\n            minSplits.splice(0, 0, lower - 1); // put lower-1 at the start of the array and shift all other entries by 1\n\n            // attempt to find the range our gVal belongs in\n            var cbi = renderer.classBreakInfos.find(function (cbi, index) {\n                return gVal > minSplits[index] && gVal <= cbi.classMaxValue;\n            });\n            if (!cbi) {\n                // outside of range on the high end\n                break;\n            }\n            svgcode = cbi.svgcode;\n            symbol = cbi.symbol;\n\n            break;\n\n        default:\n\n            // TODO set svgcode to blank image?\n            console.warn('Unknown renderer type encountered - ' + renderer.type);\n\n    }\n\n    // make an empty svg graphic in case nothing is found to avoid undefined inside the filters\n    if (typeof svgcode === 'undefined') {\n        svgcode = svgjs(document.createElement('div')).size(CONTAINER_SIZE, CONTAINER_SIZE).svg();\n    }\n\n    return { svgcode: svgcode, symbol: symbol };\n}\n\n/**\r\n* Given feature attributes, return the image URL for that feature/graphic object.\r\n*\r\n* @method getGraphicIcon\r\n* @param {Object} attributes object of feature attribute key value pairs\r\n* @param {Object} renderer an enhanced renderer (see function enhanceRenderer)\r\n* @return {String} svgcode Url to the features symbology image\r\n*/\nfunction getGraphicIcon(attributes, renderer) {\n    var renderInfo = searchRenderer(attributes, renderer);\n    return renderInfo.svgcode;\n}\n\n/**\r\n* Given feature attributes, return the symbol for that feature/graphic object.\r\n*\r\n* @method getGraphicSymbol\r\n* @param {Object} attributes object of feature attribute key value pairs\r\n* @param {Object} renderer an enhanced renderer (see function enhanceRenderer)\r\n* @return {Object} an ESRI Symbol object in server format\r\n*/\nfunction getGraphicSymbol(attributes, renderer) {\n    var renderInfo = searchRenderer(attributes, renderer);\n    return renderInfo.symbol;\n}\n\n/**\r\n * Generates svg symbology for WMS layers.\r\n * @function generateWMSSymbology\r\n * @param {String} name label for the symbology item (it's not used right now, but is required to be consistent with other symbology generating functions)\r\n * @param {String} imageUri url or dataUrl of the legend image\r\n * @return {Promise} a promise resolving with symbology svg code and its label\r\n */\nfunction generateWMSSymbology(name, imageUri) {\n    var draw = svgjs(window.document.createElement('div')).size(CONTAINER_SIZE, CONTAINER_SIZE).viewbox(0, 0, 0, 0);\n\n    var symbologyItem = {\n        name: name,\n        svgcode: null\n    };\n\n    if (imageUri) {\n        var renderPromise = renderSymbologyImage(imageUri).then(function (svgcode) {\n            symbologyItem.svgcode = svgcode;\n\n            return symbologyItem;\n        });\n\n        return renderPromise;\n    } else {\n        symbologyItem.svgcode = draw.svg();\n\n        return Promise.resolve(symbologyItem);\n    }\n}\n\n/**\r\n * Converts a config-supplied list of symbology to the format used by layer records.\r\n *\r\n * @private\r\n * @function _listToSymbology\r\n * @param {Function} conversionFunction a conversion function to wrap the supplied image into an image or an icon style symbology container\r\n * @param {Array} list a list of config-supplied symbology items in the form of [ { text: <String>, image: <String> }, ... ] wher `image` can be dataURL or an actual url\r\n * @return {Array} an array of converted symbology symbols in the form of [ { name: <String>, svgcode: <String> }, ... ]; items will be populated async as conversions are done\r\n */\nfunction _listToSymbology(conversionFunction, list) {\n    var results = list.map(function (_ref) {\n        var text = _ref.text,\n            image = _ref.image;\n\n        var result = {\n            name: text,\n            svgcode: null\n        };\n\n        conversionFunction(image).then(function (svgcode) {\n            result.svgcode = svgcode;\n        });\n\n        return result;\n    });\n\n    return results;\n}\n\n/**\r\n * Renders a supplied image as an image-style symbology item (preserving the true image dimensions).\r\n *\r\n * @function renderSymbologyImage\r\n * @param {String} imageUri a image dataUrl or a regular url\r\n * @param {Object} draw [optional=null] an svg container to draw the image on; if not supplied, a new one is created\r\n */\nfunction renderSymbologyImage(imageUri) {\n    var draw = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    if (draw === null) {\n        draw = svgjs(window.document.createElement('div')).size(CONTAINER_SIZE, CONTAINER_SIZE).viewbox(0, 0, 0, 0);\n    }\n\n    var symbologyPromise = shared.convertImagetoDataURL(imageUri).then(function (imageUri) {\n        return svgDrawImage(draw, imageUri);\n    }).then(function (_ref2) {\n        var loader = _ref2.loader;\n\n        draw.viewbox(0, 0, loader.width, loader.height);\n        return draw.svg();\n    }).catch(function (err) {\n        console.error('Cannot draw symbology iamge; returning empty', err);\n        return draw.svg();\n    });\n\n    return symbologyPromise;\n}\n\n/**\r\n * Renders a supplied image as an icon-style symbology item (fitting an image inside an icon container, usually 32x32 pixels).\r\n *\r\n * @function renderSymbologyIcon\r\n * @param {String} imageUri a image dataUrl or a regular url\r\n * @param {Object} draw [optional=null] an svg container to draw the image on; if not supplied, a new one is created\r\n */\nfunction renderSymbologyIcon(imageUri) {\n    var draw = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    if (draw === null) {\n        // create a temporary svg element and add it to the page; if not added, the element's bounding box cannot be calculated correctly\n        var container = window.document.createElement('div');\n        container.setAttribute('style', 'opacity:0;position:fixed;left:100%;top:100%;overflow:hidden');\n        window.document.body.appendChild(container);\n\n        draw = svgjs(container).size(CONTAINER_SIZE, CONTAINER_SIZE).viewbox(0, 0, CONTAINER_SIZE, CONTAINER_SIZE);\n    }\n\n    // need to draw the image to get its size (technically not needed if we have a url, but this is simpler)\n    var picturePromise = shared.convertImagetoDataURL(imageUri).then(function (imageUri) {\n        return svgDrawImage(draw, imageUri);\n    }).then(function (_ref3) {\n        var image = _ref3.image;\n\n        image.center(CONTAINER_CENTER, CONTAINER_CENTER);\n\n        // scale image to fit into the symbology item container\n        fitInto(image, CONTENT_IMAGE_SIZE);\n\n        return draw.svg();\n    });\n\n    return picturePromise;\n}\n\n/**\r\n * Generates a placeholder symbology graphic. Returns a promise for consistency\r\n * @function generatePlaceholderSymbology\r\n * @private\r\n * @param  {String} name label symbology label\r\n * @param  {String} colour colour to use in the graphic\r\n * @return {Object} symbology svg code and its label\r\n */\nfunction generatePlaceholderSymbology(name) {\n    var colour = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '#000';\n\n    var draw = svgjs(window.document.createElement('div')).size(CONTAINER_SIZE, CONTAINER_SIZE).viewbox(0, 0, CONTAINER_SIZE, CONTAINER_SIZE);\n\n    draw.rect(CONTENT_IMAGE_SIZE, CONTENT_IMAGE_SIZE).center(CONTAINER_CENTER, CONTAINER_CENTER).fill(colour);\n\n    draw.text(name[0].toUpperCase()) // take the first letter\n    .size(23).fill('#fff').attr({\n        'font-weight': 'bold',\n        'font-family': 'Roboto'\n    }).center(CONTAINER_CENTER, CONTAINER_CENTER);\n\n    return {\n        name: name,\n        svgcode: draw.svg()\n    };\n}\n\n/**\r\n* Generate a legend item for an ESRI symbol.\r\n* @private\r\n* @param  {Object} symbol an ESRI symbol object in server format\r\n* @param  {String} label label of the legend item\r\n* @param  {Object} window reference to the browser window\r\n* @return {Object} a legend object populated with the symbol and label\r\n*/\nfunction symbolToLegend(symbol, label, window) {\n    // create a temporary svg element and add it to the page; if not added, the element's bounding box cannot be calculated correctly\n    var container = window.document.createElement('div');\n    container.setAttribute('style', 'opacity:0;position:fixed;left:100%;top:100%;overflow:hidden');\n    window.document.body.appendChild(container);\n\n    var draw = svgjs(container).size(CONTAINER_SIZE, CONTAINER_SIZE).viewbox(0, 0, CONTAINER_SIZE, CONTAINER_SIZE);\n\n    // functions to draw esri simple marker symbols\n    // jscs doesn't like enhanced object notation\n    // jscs:disable requireSpacesInAnonymousFunctionExpression\n    var esriSimpleMarkerSimbol = {\n        esriSMSPath: function esriSMSPath(_ref4) {\n            var size = _ref4.size,\n                path = _ref4.path;\n\n            return draw.path(path).size(size);\n        },\n        esriSMSCircle: function esriSMSCircle(_ref5) {\n            var size = _ref5.size;\n\n            return draw.circle(size);\n        },\n        esriSMSCross: function esriSMSCross(_ref6) {\n            var size = _ref6.size;\n\n            return draw.path('M 0,10 L 20,10 M 10,0 L 10,20').size(size);\n        },\n        esriSMSX: function esriSMSX(_ref7) {\n            var size = _ref7.size;\n\n            return draw.path('M 0,0 L 20,20 M 20,0 L 0,20').size(size);\n        },\n        esriSMSTriangle: function esriSMSTriangle(_ref8) {\n            var size = _ref8.size;\n\n            return draw.path('M 20,20 L 10,0 0,20 Z').size(size);\n        },\n        esriSMSDiamond: function esriSMSDiamond(_ref9) {\n            var size = _ref9.size;\n\n            return draw.path('M 20,10 L 10,0 0,10 10,20 Z').size(size);\n        },\n        esriSMSSquare: function esriSMSSquare(_ref10) {\n            var size = _ref10.size;\n\n            return draw.path('M 0,0 20,0 20,20 0,20 Z').size(size);\n        }\n    };\n\n    // jscs:enable requireSpacesInAnonymousFunctionExpression\n\n    // line dash styles\n    var ESRI_DASH_MAPS = {\n        esriSLSSolid: 'none',\n        esriSLSDash: '5.333,4',\n        esriSLSDashDot: '5.333,4,1.333,4',\n        esriSLSLongDashDotDot: '10.666,4,1.333,4,1.333,4',\n        esriSLSDot: '1.333,4',\n        esriSLSLongDash: '10.666,4',\n        esriSLSLongDashDot: '10.666,4,1.333,4',\n        esriSLSShortDash: '5.333,1.333',\n        esriSLSShortDashDot: '5.333,1.333,1.333,1.333',\n        esriSLSShortDashDotDot: '5.333,1.333,1.333,1.333,1.333,1.333',\n        esriSLSShortDot: '1.333,1.333',\n        esriSLSNull: 'none'\n    };\n\n    // default stroke style\n    var DEFAULT_STROKE = {\n        color: '#000',\n        opacity: 1,\n        width: 1,\n        linecap: 'square',\n        linejoin: 'miter',\n        miterlimit: 4\n    };\n\n    // this is a null outline in case a supplied symbol doesn't have one\n    var DEFAULT_OUTLINE = {\n        color: [0, 0, 0, 0],\n        width: 0,\n        style: ESRI_DASH_MAPS.esriSLSNull\n    };\n\n    // 5x5 px patter with coloured diagonal lines\n    var esriSFSFills = {\n        esriSFSSolid: function esriSFSSolid(symbolColour) {\n            return {\n                color: symbolColour.colour,\n                opacity: symbolColour.opacity\n            };\n        },\n        esriSFSNull: function esriSFSNull() {\n            return 'transparent';\n        },\n        esriSFSHorizontal: function esriSFSHorizontal(symbolColour, symbolStroke) {\n            var cellSize = 5;\n\n            // patter fill: horizonal line in a 5x5 px square\n            return draw.pattern(cellSize, cellSize, function (add) {\n                return add.line(0, cellSize / 2, cellSize, cellSize / 2);\n            }).stroke(symbolStroke);\n        },\n        esriSFSVertical: function esriSFSVertical(symbolColour, symbolStroke) {\n            var cellSize = 5;\n\n            // patter fill: vertical line in a 5x5 px square\n            return draw.pattern(cellSize, cellSize, function (add) {\n                return add.line(cellSize / 2, 0, cellSize / 2, cellSize);\n            }).stroke(symbolStroke);\n        },\n        esriSFSForwardDiagonal: function esriSFSForwardDiagonal(symbolColour, symbolStroke) {\n            var cellSize = 5;\n\n            // patter fill: forward diagonal line in a 5x5 px square; two more diagonal lines offset to cover the corners when the main line is cut off\n            return draw.pattern(cellSize, cellSize, function (add) {\n                add.line(0, 0, cellSize, cellSize).stroke(symbolStroke);\n                add.line(0, 0, cellSize, cellSize).move(0, cellSize).stroke(symbolStroke);\n                add.line(0, 0, cellSize, cellSize).move(cellSize, 0).stroke(symbolStroke);\n            });\n        },\n        esriSFSBackwardDiagonal: function esriSFSBackwardDiagonal(symbolColour, symbolStroke) {\n            var cellSize = 5;\n\n            // patter fill: backward diagonal line in a 5x5 px square; two more diagonal lines offset to cover the corners when the main line is cut off\n            return draw.pattern(cellSize, cellSize, function (add) {\n                add.line(cellSize, 0, 0, cellSize).stroke(symbolStroke);\n                add.line(cellSize, 0, 0, cellSize).move(cellSize / 2, cellSize / 2).stroke(symbolStroke);\n                add.line(cellSize, 0, 0, cellSize).move(-cellSize / 2, -cellSize / 2).stroke(symbolStroke);\n            });\n        },\n        esriSFSCross: function esriSFSCross(symbolColour, symbolStroke) {\n            var cellSize = 5;\n\n            // patter fill: horizonal and vertical lines in a 5x5 px square\n            return draw.pattern(cellSize, cellSize, function (add) {\n                add.line(cellSize / 2, 0, cellSize / 2, cellSize).stroke(symbolStroke);\n                add.line(0, cellSize / 2, cellSize, cellSize / 2).stroke(symbolStroke);\n            });\n        },\n        esriSFSDiagonalCross: function esriSFSDiagonalCross(symbolColour, symbolStroke) {\n            var cellSize = 7;\n\n            // patter fill: crossing diagonal lines in a 7x7 px square\n            return draw.pattern(cellSize, cellSize, function (add) {\n                add.line(0, 0, cellSize, cellSize).stroke(symbolStroke);\n                add.line(cellSize, 0, 0, cellSize).stroke(symbolStroke);\n            });\n        }\n    };\n\n    // jscs doesn't like enhanced object notation\n    // jscs:disable requireSpacesInAnonymousFunctionExpression\n    var symbolTypes = {\n        esriSMS: function esriSMS() {\n            // ESRI Simple Marker Symbol\n            var symbolColour = parseEsriColour(symbol.color);\n\n            symbol.outline = symbol.outline || DEFAULT_OUTLINE;\n            var outlineColour = parseEsriColour(symbol.outline.color);\n            var outlineStroke = makeStroke({\n                color: outlineColour.colour,\n                opacity: outlineColour.opacity,\n                width: symbol.outline.width,\n                dasharray: ESRI_DASH_MAPS[symbol.outline.style]\n            });\n\n            // make an ESRI simple symbol and apply fill and outline to it\n            var marker = esriSimpleMarkerSimbol[symbol.style](symbol).fill({\n                color: symbolColour.colour,\n                opacity: symbolColour.opacity\n            }).stroke(outlineStroke).center(CONTAINER_CENTER, CONTAINER_CENTER).rotate(symbol.angle || 0);\n\n            fitInto(marker, CONTENT_SIZE);\n        },\n        esriSLS: function esriSLS() {\n            // ESRI Simple Line Symbol\n            var lineColour = parseEsriColour(symbol.color);\n            var lineStroke = makeStroke({\n                color: lineColour.colour,\n                opacity: lineColour.opacity,\n                width: symbol.width,\n                linecap: 'butt',\n                dasharray: ESRI_DASH_MAPS[symbol.style]\n            });\n\n            var min = CONTENT_PADDING;\n            var max = CONTAINER_SIZE - CONTENT_PADDING;\n            draw.line(min, min, max, max).stroke(lineStroke);\n        },\n        esriCLS: function esriCLS() {\n            // ESRI Fancy Line Symbol\n            this.esriSLS();\n        },\n        esriSFS: function esriSFS() {\n            // ESRI Simple Fill Symbol\n            var symbolColour = parseEsriColour(symbol.color);\n            var symbolStroke = makeStroke({\n                color: symbolColour.colour,\n                opacity: symbolColour.opacity\n            });\n            var symbolFill = esriSFSFills[symbol.style](symbolColour, symbolStroke);\n\n            symbol.outline = symbol.outline || DEFAULT_OUTLINE;\n            var outlineColour = parseEsriColour(symbol.outline.color);\n            var outlineStroke = makeStroke({\n                color: outlineColour.colour,\n                opacity: outlineColour.opacity,\n                width: symbol.outline.width,\n                linecap: 'butt',\n                dasharray: ESRI_DASH_MAPS[symbol.outline.style]\n            });\n\n            draw.rect(CONTENT_SIZE, CONTENT_SIZE).center(CONTAINER_CENTER, CONTAINER_CENTER).fill(symbolFill).stroke(outlineStroke);\n        },\n        esriTS: function esriTS() {\n            console.error('no support for feature service legend of text symbols');\n        },\n        esriPFS: function esriPFS() {\n            // ESRI Picture Fill Symbol\n            // imageUri can be just an image url is specified or a dataUri string\n            var imageUri = symbol.imageData ? 'data:' + symbol.contentType + ';base64,' + symbol.imageData : symbol.url;\n\n            var imageWidth = symbol.width * symbol.xscale;\n            var imageHeight = symbol.height * symbol.yscale;\n\n            symbol.outline = symbol.outline || DEFAULT_OUTLINE;\n            var outlineColour = parseEsriColour(symbol.outline.color);\n            var outlineStroke = makeStroke({\n                color: outlineColour.colour,\n                opacity: outlineColour.opacity,\n                width: symbol.outline.width,\n                dasharray: ESRI_DASH_MAPS[symbol.outline.style]\n            });\n\n            var picturePromise = shared.convertImagetoDataURL(imageUri).then(function (imageUri) {\n                // make a fill from a tiled image\n                var symbolFill = draw.pattern(imageWidth, imageHeight, function (add) {\n                    return add.image(imageUri, imageWidth, imageHeight, true);\n                });\n\n                draw.rect(CONTENT_SIZE, CONTENT_SIZE).center(CONTAINER_CENTER, CONTAINER_CENTER).fill(symbolFill).stroke(outlineStroke);\n            });\n\n            return picturePromise;\n        },\n        esriPMS: function esriPMS() {\n            // ESRI PMS? Picture Marker Symbol\n            // imageUri can be just an image url is specified or a dataUri string\n            var imageUri = symbol.imageData ? 'data:' + symbol.contentType + ';base64,' + symbol.imageData : symbol.url;\n\n            // need to draw the image to get its size (technically not needed if we have a url, but this is simpler)\n            var picturePromise = shared.convertImagetoDataURL(imageUri).then(function (imageUri) {\n                return svgDrawImage(draw, imageUri);\n            }).then(function (_ref11) {\n                var image = _ref11.image;\n\n                image.center(CONTAINER_CENTER, CONTAINER_CENTER).rotate(symbol.angle || 0);\n\n                // scale image to fit into the symbology item container\n                fitInto(image, CONTENT_IMAGE_SIZE);\n            });\n\n            return picturePromise;\n        }\n    };\n\n    // jscs:enable requireSpacesInAnonymousFunctionExpression\n\n    // console.log(symbol.type, label, '--START--');\n    // console.log(symbol);\n\n    return Promise.resolve(symbolTypes[symbol.type]()).then(function () {\n        // console.log(symbol.type, label, '--DONE--');\n\n        // remove element from the page\n        window.document.body.removeChild(container);\n        return { label: label, svgcode: draw.svg() };\n    }).catch(function (error) {\n        return console.log(error);\n    });\n\n    /**\r\n     * Creates a stroke style by applying custom rules to the default stroke.\r\n     * @param {Object} overrides any custom rules to apply on top of the defaults\r\n     * @return {Object} a stroke object\r\n     * @private\r\n     */\n    function makeStroke(overrides) {\n        return Object.assign({}, DEFAULT_STROKE, overrides);\n    }\n\n    /**\r\n    * Convert an ESRI colour object to SVG rgb format.\r\n    * @private\r\n    * @param  {Array} c ESRI Colour array\r\n    * @return {Object} colour and opacity in SVG format\r\n    */\n    function parseEsriColour(c) {\n        if (c) {\n            return {\n                colour: 'rgb(' + c[0] + ',' + c[1] + ',' + c[2] + ')',\n                opacity: c[3] / 255\n            };\n        } else {\n            return {\n                colour: 'rgb(0, 0, 0)',\n                opacity: 0\n            };\n        }\n    }\n}\n\n/**\r\n * Renders a specified image on an svg element. This is a helper function that wraps around async `draw.image` call in the svg library.\r\n *\r\n * @function svgDrawImage\r\n * @private\r\n * @param {Object} draw svg element to render the image onto\r\n * @param {String} imageUri image url or dataURL of the image to render\r\n * @param {Number} width [optional = 0] width of the image\r\n * @param {Number} height [optional = 0] height of the image\r\n * @param {Boolean} crossOrigin [optional = true] specifies if the image should be loaded as crossOrigin\r\n * @return {Promise} promise resolving with the loaded image and its loader object (see svg.js http://documentup.com/wout/svg.js#image for details)\r\n */\nfunction svgDrawImage(draw, imageUri) {\n    var width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var height = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    var crossOrigin = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n\n    var promise = new Promise(function (resolve, reject) {\n        var image = draw.image(imageUri, width, height, crossOrigin).loaded(function (loader) {\n            return resolve({ image: image, loader: loader });\n        }).error(function (err) {\n            reject(err);\n            console.error(err);\n        });\n    });\n\n    return promise;\n}\n\n/**\r\n * Fits svg element in the size specified\r\n * @param {Ojbect} element svg element to fit\r\n * @param {Number} CONTAINER_SIZE width/height of a container to fit the element into\r\n */\nfunction fitInto(element, CONTAINER_SIZE) {\n    // const elementRbox = element.rbox();\n    // const elementRbox = element.screenBBox();\n\n    var elementRbox = element.node.getBoundingClientRect(); // marker.rbox(); //rbox doesn't work properly in Chrome for some reason\n    var scale = CONTAINER_SIZE / Math.max(elementRbox.width, elementRbox.height);\n    if (scale < 1) {\n        element.scale(scale);\n    }\n}\n\n/**\r\n* Generate an array of legend items for an ESRI unique value or class breaks renderer.\r\n* @private\r\n* @param  {Object} renderer an ESRI unique value or class breaks renderer\r\n* @param  {Array} childList array of children items of the renderer\r\n* @param  {Object} window reference to the browser window\r\n* @return {Array} a legend object populated with the symbol and label\r\n*/\nfunction scrapeListRenderer(renderer, childList, window) {\n    var legend = childList.map(function (child) {\n        return symbolToLegend(child.symbol, child.label, window);\n    });\n\n    if (renderer.defaultSymbol) {\n        // class breaks dont have default label\n        // TODO perhaps put in a default of \"Other\", would need to be in proper language\n        legend.push(symbolToLegend(renderer.defaultSymbol, renderer.defaultLabel || '', window));\n    }\n\n    return legend;\n}\n\nfunction buildRendererToLegend(window) {\n    /**\r\n    * Generate a legend object based on an ESRI renderer.\r\n    * @private\r\n    * @param  {Object} renderer an ESRI renderer object in server JSON form\r\n    * @param  {Integer} index the layer index of this renderer\r\n    * @return {Object} an object matching the form of an ESRI REST API legend\r\n    */\n    return function (renderer, index) {\n        // make basic shell object with .layers array\n        var legend = {\n            layers: [{\n                layerId: index,\n                legend: []\n            }]\n        };\n\n        switch (renderer.type) {\n            case SIMPLE:\n                legend.layers[0].legend.push(symbolToLegend(renderer.symbol, renderer.label, window));\n                break;\n\n            case UNIQUE_VALUE:\n                legend.layers[0].legend = scrapeListRenderer(renderer, renderer.uniqueValueInfos, window);\n                break;\n\n            case CLASS_BREAKS:\n                legend.layers[0].legend = scrapeListRenderer(renderer, renderer.classBreakInfos, window);\n                break;\n\n            default:\n\n                // FIXME make a basic blank entry (error msg as label?) to prevent things from breaking\n                // Renderer we dont support\n                console.error('encountered unsupported renderer legend type: ' + renderer.type);\n        }\n        return legend;\n    };\n}\n\n/**\r\n * Returns the legend information of an ESRI map service.\r\n *\r\n * @function getMapServerLegend\r\n * @private\r\n * @param  {String} layerUrl service url (root service, not indexed endpoint)\r\n * @param  {Object} esriBundle collection of ESRI API objects\r\n * @returns {Promise} resolves in an array of legend data\r\n *\r\n */\nfunction getMapServerLegend(layerUrl, esriBundle) {\n\n    // standard json request with error checking\n    var defService = esriBundle.esriRequest({\n        url: layerUrl + '/legend',\n        content: { f: 'json' },\n        callbackParamName: 'callback',\n        handleAs: 'json'\n    });\n\n    // wrap in promise to contain dojo deferred\n    return new Promise(function (resolve, reject) {\n        defService.then(function (srvResult) {\n\n            if (srvResult.error) {\n                reject(srvResult.error);\n            } else {\n                resolve(srvResult);\n            }\n        }, function (error) {\n            reject(error);\n        });\n    });\n}\n\n/**\r\n * Our symbology engine works off of renderers. When dealing with layers with no renderers,\r\n * we need to take server-side legend and convert it to a fake renderer, which lets us\r\n * leverage all the existing symbology code.\r\n *\r\n * @function mapServerLegendToRenderer\r\n * @private\r\n * @param {Object} serverLegend legend json from an esri map server\r\n * @param {Integer} layerIndex  the index of the layer in the legend we are interested in\r\n * @returns {Object} a fake unique value renderer based off the legend\r\n *\r\n */\nfunction mapServerLegendToRenderer(serverLegend, layerIndex) {\n    var layerLegend = serverLegend.layers.find(function (l) {\n        return l.layerId === layerIndex;\n    });\n\n    // make the mock renderer\n    return {\n        type: 'uniqueValue',\n        uniqueValueInfos: layerLegend.legend.map(function (ll) {\n            return {\n                label: ll.label,\n                symbol: {\n                    type: 'esriPMS',\n                    imageData: ll.imageData,\n                    contentType: ll.contentType\n                }\n            };\n        })\n    };\n}\n\n/**\r\n  * Our symbology engine works off of renderers. When dealing with layers with no renderers,\r\n  * we need to take server-side legend and convert it to a fake renderer, which lets us\r\n  * leverage all the existing symbology code.\r\n  *\r\n  * Same as mapServerLegendToRenderer function but combines all layer renderers.\r\n  *\r\n  * @function mapServerLegendToRendererAll\r\n  * @private\r\n  * @param {Object} serverLegend legend json from an esri map server\r\n  * @returns {Object} a fake unique value renderer based off the legend\r\n  */\n\nfunction mapServerLegendToRendererAll(serverLegend) {\n    var _ref12;\n\n    var layerRenders = serverLegend.layers.map(function (layer) {\n        return layer.legend.map(function (layerLegend) {\n            return {\n                label: layerLegend.label,\n                symbol: {\n                    type: 'esriPMS',\n                    imageData: layerLegend.imageData,\n                    contentType: layerLegend.contentType\n                }\n            };\n        });\n    });\n\n    return {\n        type: 'uniqueValue',\n        uniqueValueInfos: (_ref12 = []).concat.apply(_ref12, _toConsumableArray(layerRenders))\n    };\n}\n\nfunction buildMapServerToLocalLegend(esriBundle, geoApi) {\n    /**\r\n     * Orchestrator function that will:\r\n     * - Fetch a legend from an esri map server\r\n     * - Extract legend for a specific sub layer\r\n     * - Convert server legend to a temporary renderer\r\n     * - Convert temporary renderer to a viewer-formatted legend (return value)\r\n     *\r\n     * @function mapServerToLocalLegend\r\n     * @param {String}    mapServerUrl  service url (root service, not indexed endpoint)\r\n     * @param {Integer}   [layerIndex]  the index of the layer in the legend we are interested in. If not provided, all layers will be collapsed into a single legend\r\n     * @returns {Promise} resolves in a viewer-compatible legend for the given server and layer index\r\n     *\r\n     */\n    return function (mapServerUrl, layerIndex) {\n        // get esri legend from server\n\n        return getMapServerLegend(mapServerUrl, esriBundle).then(function (serverLegendData) {\n            // derive renderer for specified layer\n            var fakeRenderer = void 0;\n            var intIndex = void 0;\n            if (typeof layerIndex === 'undefined') {\n                intIndex = 0;\n                fakeRenderer = mapServerLegendToRendererAll(serverLegendData);\n            } else {\n                intIndex = parseInt(layerIndex); // sometimes a stringified value comes in. careful now.\n                fakeRenderer = mapServerLegendToRenderer(serverLegendData, intIndex);\n            }\n\n            // convert renderer to viewer specific legend\n            return geoApi.symbology.rendererToLegend(fakeRenderer, intIndex);\n        });\n    };\n}\n\n// TODO getZoomLevel should probably live in a file not named symbology\n/**\r\n* Takes the lod list and finds level as close to and above scale limit\r\n*\r\n* @param {Array} lods array of esri LODs https://developers.arcgis.com/javascript/jsapi/lod-amd.html\r\n* @param {Integer} maxScale object largest zoom level for said layer\r\n* @returns {Number} current LOD\r\n*/\nfunction getZoomLevel(lods, maxScale) {\n    // Find level as close to and above scaleLimit\n    var scaleLimit = maxScale; // maxScale obj in returned config\n    var found = false;\n    var currentLod = Math.ceil(lods.length / 2);\n    var lowLod = 0;\n    var highLod = lods.length - 1;\n\n    if (maxScale === 0) {\n        return lods.length - 1;\n    }\n\n    // Binary Search\n    while (!found) {\n        if (lods[currentLod].scale >= scaleLimit) {\n            lowLod = currentLod;\n        } else {\n            highLod = currentLod;\n        }\n        currentLod = Math.floor((highLod + lowLod) / 2);\n        if (highLod === lowLod + 1) {\n            found = true;\n        }\n    }\n    return currentLod;\n}\n\nmodule.exports = function (esriBundle, geoApi, window) {\n    return {\n        getGraphicIcon: getGraphicIcon,\n        getGraphicSymbol: getGraphicSymbol,\n        rendererToLegend: buildRendererToLegend(window),\n        generatePlaceholderSymbology: generatePlaceholderSymbology,\n        generateWMSSymbology: generateWMSSymbology,\n\n        listToIconSymbology: function listToIconSymbology(list) {\n            return _listToSymbology(renderSymbologyIcon, list);\n        },\n        listToImageSymbology: function listToImageSymbology(list) {\n            return _listToSymbology(renderSymbologyImage, list);\n        },\n\n        getZoomLevel: getZoomLevel,\n        enhanceRenderer: enhanceRenderer,\n        mapServerToLocalLegend: buildMapServerToLocalLegend(esriBundle, geoApi)\n    };\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc3ltYm9sb2d5LmpzPzk3YTAiXSwibmFtZXMiOlsic3ZnanMiLCJyZXF1aXJlIiwic2hhcmVkIiwiU0lNUExFIiwiVU5JUVVFX1ZBTFVFIiwiQ0xBU1NfQlJFQUtTIiwiQ09OVEFJTkVSX1NJWkUiLCJDT05URU5UX1NJWkUiLCJDT05URU5UX0lNQUdFX1NJWkUiLCJDT05UQUlORVJfQ0VOVEVSIiwiQ09OVEVOVF9QQURESU5HIiwiZW5oYW5jZVJlbmRlcmVyIiwicmVuZGVyZXIiLCJsZWdlbmQiLCJsZWdlbmRMb29rdXAiLCJsZWdlbmRJdGVtUHJvbWlzZXMiLCJsYXllcnMiLCJtYXAiLCJsZWdJdGVtIiwidGhlbiIsImRhdGEiLCJsYWJlbCIsInN2Z2NvZGUiLCJQcm9taXNlIiwiYWxsIiwidHlwZSIsImRlZmF1bHRMYWJlbCIsImRlZmF1bHRzdmdjb2RlIiwidW5pcXVlVmFsdWVJbmZvcyIsImZvckVhY2giLCJ1dmkiLCJjbGFzc0JyZWFrSW5mb3MiLCJjYmkiLCJjb25zb2xlIiwid2FybiIsInNlYXJjaFJlbmRlcmVyIiwiYXR0cmlidXRlcyIsInN5bWJvbCIsImdyYXBoaWNLZXkiLCJmaWVsZDEiLCJ0b1N0cmluZyIsImZpZWxkMiIsImZpZWxkMyIsImZpbmQiLCJ2YWx1ZSIsImRlZmF1bHRTeW1ib2wiLCJnVmFsIiwicGFyc2VGbG9hdCIsImZpZWxkIiwibG93ZXIiLCJtaW5WYWx1ZSIsIm1pblNwbGl0cyIsImNsYXNzTWF4VmFsdWUiLCJzcGxpY2UiLCJpbmRleCIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsInNpemUiLCJzdmciLCJnZXRHcmFwaGljSWNvbiIsInJlbmRlckluZm8iLCJnZXRHcmFwaGljU3ltYm9sIiwiZ2VuZXJhdGVXTVNTeW1ib2xvZ3kiLCJuYW1lIiwiaW1hZ2VVcmkiLCJkcmF3Iiwid2luZG93Iiwidmlld2JveCIsInN5bWJvbG9neUl0ZW0iLCJyZW5kZXJQcm9taXNlIiwicmVuZGVyU3ltYm9sb2d5SW1hZ2UiLCJyZXNvbHZlIiwiX2xpc3RUb1N5bWJvbG9neSIsImNvbnZlcnNpb25GdW5jdGlvbiIsImxpc3QiLCJyZXN1bHRzIiwidGV4dCIsImltYWdlIiwicmVzdWx0Iiwic3ltYm9sb2d5UHJvbWlzZSIsImNvbnZlcnRJbWFnZXRvRGF0YVVSTCIsInN2Z0RyYXdJbWFnZSIsImxvYWRlciIsIndpZHRoIiwiaGVpZ2h0IiwiY2F0Y2giLCJlcnJvciIsImVyciIsInJlbmRlclN5bWJvbG9neUljb24iLCJjb250YWluZXIiLCJzZXRBdHRyaWJ1dGUiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJwaWN0dXJlUHJvbWlzZSIsImNlbnRlciIsImZpdEludG8iLCJnZW5lcmF0ZVBsYWNlaG9sZGVyU3ltYm9sb2d5IiwiY29sb3VyIiwicmVjdCIsImZpbGwiLCJ0b1VwcGVyQ2FzZSIsImF0dHIiLCJzeW1ib2xUb0xlZ2VuZCIsImVzcmlTaW1wbGVNYXJrZXJTaW1ib2wiLCJlc3JpU01TUGF0aCIsInBhdGgiLCJlc3JpU01TQ2lyY2xlIiwiY2lyY2xlIiwiZXNyaVNNU0Nyb3NzIiwiZXNyaVNNU1giLCJlc3JpU01TVHJpYW5nbGUiLCJlc3JpU01TRGlhbW9uZCIsImVzcmlTTVNTcXVhcmUiLCJFU1JJX0RBU0hfTUFQUyIsImVzcmlTTFNTb2xpZCIsImVzcmlTTFNEYXNoIiwiZXNyaVNMU0Rhc2hEb3QiLCJlc3JpU0xTTG9uZ0Rhc2hEb3REb3QiLCJlc3JpU0xTRG90IiwiZXNyaVNMU0xvbmdEYXNoIiwiZXNyaVNMU0xvbmdEYXNoRG90IiwiZXNyaVNMU1Nob3J0RGFzaCIsImVzcmlTTFNTaG9ydERhc2hEb3QiLCJlc3JpU0xTU2hvcnREYXNoRG90RG90IiwiZXNyaVNMU1Nob3J0RG90IiwiZXNyaVNMU051bGwiLCJERUZBVUxUX1NUUk9LRSIsImNvbG9yIiwib3BhY2l0eSIsImxpbmVjYXAiLCJsaW5lam9pbiIsIm1pdGVybGltaXQiLCJERUZBVUxUX09VVExJTkUiLCJzdHlsZSIsImVzcmlTRlNGaWxscyIsImVzcmlTRlNTb2xpZCIsInN5bWJvbENvbG91ciIsImVzcmlTRlNOdWxsIiwiZXNyaVNGU0hvcml6b250YWwiLCJzeW1ib2xTdHJva2UiLCJjZWxsU2l6ZSIsInBhdHRlcm4iLCJhZGQiLCJsaW5lIiwic3Ryb2tlIiwiZXNyaVNGU1ZlcnRpY2FsIiwiZXNyaVNGU0ZvcndhcmREaWFnb25hbCIsIm1vdmUiLCJlc3JpU0ZTQmFja3dhcmREaWFnb25hbCIsImVzcmlTRlNDcm9zcyIsImVzcmlTRlNEaWFnb25hbENyb3NzIiwic3ltYm9sVHlwZXMiLCJlc3JpU01TIiwicGFyc2VFc3JpQ29sb3VyIiwib3V0bGluZSIsIm91dGxpbmVDb2xvdXIiLCJvdXRsaW5lU3Ryb2tlIiwibWFrZVN0cm9rZSIsImRhc2hhcnJheSIsIm1hcmtlciIsInJvdGF0ZSIsImFuZ2xlIiwiZXNyaVNMUyIsImxpbmVDb2xvdXIiLCJsaW5lU3Ryb2tlIiwibWluIiwibWF4IiwiZXNyaUNMUyIsImVzcmlTRlMiLCJzeW1ib2xGaWxsIiwiZXNyaVRTIiwiZXNyaVBGUyIsImltYWdlRGF0YSIsImNvbnRlbnRUeXBlIiwidXJsIiwiaW1hZ2VXaWR0aCIsInhzY2FsZSIsImltYWdlSGVpZ2h0IiwieXNjYWxlIiwiZXNyaVBNUyIsInJlbW92ZUNoaWxkIiwibG9nIiwib3ZlcnJpZGVzIiwiT2JqZWN0IiwiYXNzaWduIiwiYyIsImNyb3NzT3JpZ2luIiwicHJvbWlzZSIsInJlamVjdCIsImxvYWRlZCIsImVsZW1lbnQiLCJlbGVtZW50UmJveCIsIm5vZGUiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJzY2FsZSIsIk1hdGgiLCJzY3JhcGVMaXN0UmVuZGVyZXIiLCJjaGlsZExpc3QiLCJjaGlsZCIsInB1c2giLCJidWlsZFJlbmRlcmVyVG9MZWdlbmQiLCJsYXllcklkIiwiZ2V0TWFwU2VydmVyTGVnZW5kIiwibGF5ZXJVcmwiLCJlc3JpQnVuZGxlIiwiZGVmU2VydmljZSIsImVzcmlSZXF1ZXN0IiwiY29udGVudCIsImYiLCJjYWxsYmFja1BhcmFtTmFtZSIsImhhbmRsZUFzIiwic3J2UmVzdWx0IiwibWFwU2VydmVyTGVnZW5kVG9SZW5kZXJlciIsInNlcnZlckxlZ2VuZCIsImxheWVySW5kZXgiLCJsYXllckxlZ2VuZCIsImwiLCJsbCIsIm1hcFNlcnZlckxlZ2VuZFRvUmVuZGVyZXJBbGwiLCJsYXllclJlbmRlcnMiLCJsYXllciIsImNvbmNhdCIsImJ1aWxkTWFwU2VydmVyVG9Mb2NhbExlZ2VuZCIsImdlb0FwaSIsIm1hcFNlcnZlclVybCIsImZha2VSZW5kZXJlciIsImludEluZGV4Iiwic2VydmVyTGVnZW5kRGF0YSIsInBhcnNlSW50Iiwic3ltYm9sb2d5IiwicmVuZGVyZXJUb0xlZ2VuZCIsImdldFpvb21MZXZlbCIsImxvZHMiLCJtYXhTY2FsZSIsInNjYWxlTGltaXQiLCJmb3VuZCIsImN1cnJlbnRMb2QiLCJjZWlsIiwibGVuZ3RoIiwibG93TG9kIiwiaGlnaExvZCIsImZsb29yIiwibW9kdWxlIiwiZXhwb3J0cyIsImxpc3RUb0ljb25TeW1ib2xvZ3kiLCJsaXN0VG9JbWFnZVN5bWJvbG9neSIsIm1hcFNlcnZlclRvTG9jYWxMZWdlbmQiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7Ozs7QUFDQSxJQUFNQSxRQUFRLG1CQUFBQyxDQUFRLEdBQVIsQ0FBZDtBQUNBLElBQU1DLFNBQVMsbUJBQUFELENBQVEsRUFBUixHQUFmOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBTUUsU0FBUyxRQUFmO0FBQ0EsSUFBTUMsZUFBZSxhQUFyQjtBQUNBLElBQU1DLGVBQWUsYUFBckI7O0FBRUEsSUFBTUMsaUJBQWlCLEVBQXZCLEMsQ0FBMkI7QUFDM0IsSUFBTUMsZUFBZSxFQUFyQixDLENBQXlCO0FBQ3pCLElBQU1DLHFCQUFxQixFQUEzQixDLENBQStCO0FBQy9CLElBQU1DLG1CQUFtQkgsaUJBQWlCLENBQTFDO0FBQ0EsSUFBTUksa0JBQWtCLENBQUNKLGlCQUFpQkMsWUFBbEIsSUFBa0MsQ0FBMUQ7O0FBRUE7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QyxrREFMRzs7QUFPSHNMLDZCQUFxQjtBQUFBLG1CQUFRNUssaUJBQWlCZ0IsbUJBQWpCLEVBQXNDZCxJQUF0QyxDQUFSO0FBQUEsU0FQbEI7QUFRSDJLLDhCQUFzQjtBQUFBLG1CQUFRN0ssaUJBQWlCRixvQkFBakIsRUFBdUNJLElBQXZDLENBQVI7QUFBQSxTQVJuQjs7QUFVSDZKLGtDQVZHO0FBV0g1Tix3Q0FYRztBQVlIMk8sZ0NBQXdCeEIsNEJBQTRCbEIsVUFBNUIsRUFBd0NtQixNQUF4QztBQVpyQixLQUFQO0FBY0gsQ0FmRCIsImZpbGUiOiI3OS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGpzaGludCBtYXhjb21wbGV4aXR5OiBmYWxzZSAqL1xyXG4ndXNlIHN0cmljdCc7XHJcbmNvbnN0IHN2Z2pzID0gcmVxdWlyZSgnc3ZnLmpzJyk7XHJcbmNvbnN0IHNoYXJlZCA9IHJlcXVpcmUoJy4vc2hhcmVkLmpzJykoKTtcclxuXHJcbi8vIEZ1bmN0aW9ucyBmb3IgdHVybmluZyBFU1JJIFJlbmRlcmVycyBpbnRvIGltYWdlc1xyXG4vLyBTcGVjaWZpY2FsbHksIGNvbnZlcnRpbmcgRVNSSSBcIlNpbXBsZVwiIHN5bWJvbHMgaW50byBpbWFnZXMsXHJcbi8vIGFuZCBkZXJpdmluZyB0aGUgYXBwcm9wcmlhdGUgaW1hZ2UgZm9yIGEgZmVhdHVyZSBiYXNlZCBvblxyXG4vLyBhIHJlbmRlcmVyXHJcblxyXG4vLyBsYXllciBzeW1ib2xvZ3kgdHlwZXNcclxuY29uc3QgU0lNUExFID0gJ3NpbXBsZSc7XHJcbmNvbnN0IFVOSVFVRV9WQUxVRSA9ICd1bmlxdWVWYWx1ZSc7XHJcbmNvbnN0IENMQVNTX0JSRUFLUyA9ICdjbGFzc0JyZWFrcyc7XHJcblxyXG5jb25zdCBDT05UQUlORVJfU0laRSA9IDMyOyAvLyBzaXplIG9mIHRoZSBzeW1ib2xvZ3kgaXRlbSBjb250YWluZXJcclxuY29uc3QgQ09OVEVOVF9TSVpFID0gMjQ7IC8vIHNpemUgb2YgdGhlIHN5bWJvbG9neSBncmFwaGljXHJcbmNvbnN0IENPTlRFTlRfSU1BR0VfU0laRSA9IDI4OyAvLyBzaXplIG9mIHRoZSBzeW1ib2xvZ3kgZ3JhcGhpYyBpZiBpdCdzIGFuIGltYWdlIChpbWFnZXMgdGVuZCB0byBhbHJlYWR5IGhhdmUgYSB3aGl0ZSBib2FyZGVyIGFyb3VuZCB0aGVtKVxyXG5jb25zdCBDT05UQUlORVJfQ0VOVEVSID0gQ09OVEFJTkVSX1NJWkUgLyAyO1xyXG5jb25zdCBDT05URU5UX1BBRERJTkcgPSAoQ09OVEFJTkVSX1NJWkUgLSBDT05URU5UX1NJWkUpIC8gMjtcclxuXHJcbi8qKlxyXG4qIFdpbGwgYWRkIGV4dHJhIHByb3BlcnRpZXMgdG8gYSByZW5kZXJlciB0byBzdXBwb3J0IGltYWdlcy5cclxuKiBOZXcgcHJvcGVydGllcyAuc3ZnY29kZSBhbmQgLmRlZmF1bHRzdmdjb2RlIGNvbnRhaW5zIGltYWdlIHNvdXJjZVxyXG4qIGZvciBhcHAgb24gZWFjaCByZW5kZXJlciBpdGVtLlxyXG4qXHJcbiogQHBhcmFtIHtPYmplY3R9IHJlbmRlcmVyIGFuIEVTUkkgcmVuZGVyZXIgb2JqZWN0IGluIHNlcnZlciBKU09OIGZvcm0uIFBhcmFtIGlzIG1vZGlmaWVkIGluIHBsYWNlXHJcbiogQHBhcmFtIHtPYmplY3R9IGxlZ2VuZCBvYmplY3QgZm9yIHRoZSBsYXllciB0aGF0IG1hcHMgbGVnZW5kIGxhYmVsIHRvIGRhdGEgdXJsIG9mIGxlZ2VuZCBpbWFnZVxyXG4qIEByZXR1cm4ge1Byb21pc2V9IHJlc29sdmluZyB3aGVuIHRoZSByZW5kZXJlciBoYXMgYmVlbiBlbmhhbmNlZFxyXG4qL1xyXG5mdW5jdGlvbiBlbmhhbmNlUmVuZGVyZXIocmVuZGVyZXIsIGxlZ2VuZCkge1xyXG5cclxuICAgIC8vIFRPRE8gbm90ZSBzb21ld2hlcmUgKHVzZXIgZG9jcykgdGhhdCBldmVyeXRoaW5nIGZhaWxzIGlmIHNvbWVvbmUgcHVibGlzaGVzIGEgbGVnZW5kIHdpdGggdHdvIGlkZW50aWNhbCBsYWJlbHNcclxuXHJcbiAgICAvLyBxdWljayBsb29rdXAgb2JqZWN0IG9mIGxlZ2VuZCBuYW1lcyB0byBkYXRhIFVSTHMuXHJcbiAgICAvLyBvdXIgbGVnZW5kIG9iamVjdCBpcyBpbiBFU1JJIGZvcm1hdCwgYnV0IHdhcyBnZW5lcmF0ZWQgYnkgdXMgYW5kIG9ubHkgaGFzIGluZm8gZm9yIGEgc2luZ2xlIGxheWVyLlxyXG4gICAgLy8gc28gd2UganVzdCBncmFiIGl0ZW0gMCwgd2hpY2ggaXMgdGhlIG9ubHkgaXRlbS5cclxuICAgIGNvbnN0IGxlZ2VuZExvb2t1cCA9IHt9O1xyXG5cclxuICAgIC8vIHN0b3JlIHN2Z2NvZGUgaW4gdGhlIGxvb2t1cFxyXG4gICAgY29uc3QgbGVnZW5kSXRlbVByb21pc2VzID0gbGVnZW5kLmxheWVyc1swXS5sZWdlbmQubWFwKGxlZ0l0ZW0gPT5cclxuICAgICAgICBsZWdJdGVtLnRoZW4oZGF0YSA9PlxyXG4gICAgICAgICAgICBsZWdlbmRMb29rdXBbZGF0YS5sYWJlbF0gPSBkYXRhLnN2Z2NvZGVcclxuICAgICAgICApKTtcclxuXHJcbiAgICAvLyB3YWl0IHVudGlsIGFsbCBsZWdlbmQgaXRlbXMgYXJlIHJlc29sdmVkIGFuZCBsZWdlbmQgbG9va3VwIGlzIHVwZGF0ZWRcclxuICAgIHJldHVybiBQcm9taXNlLmFsbChsZWdlbmRJdGVtUHJvbWlzZXMpLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgIHN3aXRjaCAocmVuZGVyZXIudHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIFNJTVBMRTpcclxuICAgICAgICAgICAgICAgIHJlbmRlcmVyLnN2Z2NvZGUgPSBsZWdlbmRMb29rdXBbcmVuZGVyZXIubGFiZWxdO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlIFVOSVFVRV9WQUxVRTpcclxuICAgICAgICAgICAgICAgIGlmIChyZW5kZXJlci5kZWZhdWx0TGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZW5kZXJlci5kZWZhdWx0c3ZnY29kZSA9IGxlZ2VuZExvb2t1cFtyZW5kZXJlci5kZWZhdWx0TGFiZWxdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJlbmRlcmVyLnVuaXF1ZVZhbHVlSW5mb3MuZm9yRWFjaCh1dmkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHV2aS5zdmdjb2RlID0gbGVnZW5kTG9va3VwW3V2aS5sYWJlbF07XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBDTEFTU19CUkVBS1M6XHJcbiAgICAgICAgICAgICAgICBpZiAocmVuZGVyZXIuZGVmYXVsdExhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXIuZGVmYXVsdHN2Z2NvZGUgPSBsZWdlbmRMb29rdXBbcmVuZGVyZXIuZGVmYXVsdExhYmVsXTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZW5kZXJlci5jbGFzc0JyZWFrSW5mb3MuZm9yRWFjaChjYmkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNiaS5zdmdjb2RlID0gbGVnZW5kTG9va3VwW2NiaS5sYWJlbF07XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZW5kZXJlciB3ZSBkb250IHN1cHBvcnRcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignZW5jb3VudGVyZWQgdW5zdXBwb3J0ZWQgcmVuZGVyZXIgdHlwZTogJyArIHJlbmRlcmVyLnR5cGUpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcblxyXG4vKipcclxuKiBHaXZlbiBmZWF0dXJlIGF0dHJpYnV0ZXMsIGZpbmQgdGhlIHJlbmRlcmVyIG5vZGUgdGhhdCB3b3VsZCBkcmF3IGl0XHJcbipcclxuKiBAbWV0aG9kIHNlYXJjaFJlbmRlcmVyXHJcbiogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnV0ZXMgb2JqZWN0IG9mIGZlYXR1cmUgYXR0cmlidXRlIGtleSB2YWx1ZSBwYWlyc1xyXG4qIEBwYXJhbSB7T2JqZWN0fSByZW5kZXJlciBhbiBlbmhhbmNlZCByZW5kZXJlciAoc2VlIGZ1bmN0aW9uIGVuaGFuY2VSZW5kZXJlcilcclxuKiBAcmV0dXJuIHtPYmplY3R9IGFuIE9iamVjdCB3aXRoIHN2Z2NvZGUgYW5kIHN5bWJvbCBwcm9wZXJ0aWVzIGZvciB0aGUgbWF0Y2hlZCByZW5kZXJlciBpdGVtXHJcbiovXHJcbmZ1bmN0aW9uIHNlYXJjaFJlbmRlcmVyKGF0dHJpYnV0ZXMsIHJlbmRlcmVyKSB7XHJcblxyXG4gICAgbGV0IHN2Z2NvZGU7XHJcbiAgICBsZXQgc3ltYm9sID0ge307XHJcblxyXG4gICAgc3dpdGNoIChyZW5kZXJlci50eXBlKSB7XHJcbiAgICAgICAgY2FzZSBTSU1QTEU6XHJcbiAgICAgICAgICAgIHN2Z2NvZGUgPSByZW5kZXJlci5zdmdjb2RlO1xyXG4gICAgICAgICAgICBzeW1ib2wgPSByZW5kZXJlci5zeW1ib2w7XHJcblxyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgY2FzZSBVTklRVUVfVkFMVUU6XHJcblxyXG4gICAgICAgICAgICAvLyBtYWtlIGEga2V5IHZhbHVlIGZvciB0aGUgZ3JhcGhpYyBpbiBxdWVzdGlvbiwgdXNpbmcgY29tbWEtc3BhY2UgZGVsaW1pdGVyIGlmIG11bHRpcGxlIGZpZWxkc1xyXG4gICAgICAgICAgICAvLyBwdXQgYW4gZW1wdHkgc3RyaW5nIHdoZW4ga2V5IHZhbHVlIGlzIG51bGxcclxuICAgICAgICAgICAgbGV0IGdyYXBoaWNLZXkgPSBhdHRyaWJ1dGVzW3JlbmRlcmVyLmZpZWxkMV0gPT09IG51bGwgPyAnJyA6IGF0dHJpYnV0ZXNbcmVuZGVyZXIuZmllbGQxXTtcclxuXHJcbiAgICAgICAgICAgIC8vIGFsbCBrZXkgdmFsdWVzIGFyZSBzdG9yZWQgYXMgc3RyaW5ncy4gIGlmIHRoZSBhdHRyaWJ1dGUgaXMgaW4gYSBudW1lcmljIGNvbHVtbiwgd2UgbXVzdCBjb252ZXJ0IGl0IHRvIGEgc3RyaW5nIHRvIGVuc3VyZSB0aGUgPT09IG9wZXJhdG9yIHN0aWxsIHdvcmtzLlxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGdyYXBoaWNLZXkgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICBncmFwaGljS2V5ID0gZ3JhcGhpY0tleS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAocmVuZGVyZXIuZmllbGQyKSB7XHJcbiAgICAgICAgICAgICAgICBncmFwaGljS2V5ID0gZ3JhcGhpY0tleSArICcsICcgKyBhdHRyaWJ1dGVzW3JlbmRlcmVyLmZpZWxkMl07XHJcbiAgICAgICAgICAgICAgICBpZiAocmVuZGVyZXIuZmllbGQzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ3JhcGhpY0tleSA9IGdyYXBoaWNLZXkgKyAnLCAnICsgYXR0cmlidXRlc1tyZW5kZXJlci5maWVsZDNdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBzZWFyY2ggdGhlIHZhbHVlIG1hcHMgZm9yIGEgbWF0Y2hpbmcgZW50cnkuICBpZiBubyBtYXRjaCBmb3VuZCwgdXNlIHRoZSBkZWZhdWx0IGltYWdlXHJcbiAgICAgICAgICAgIGNvbnN0IHV2aSA9IHJlbmRlcmVyLnVuaXF1ZVZhbHVlSW5mb3MuZmluZCh1dmkgPT4gdXZpLnZhbHVlID09PSBncmFwaGljS2V5KTtcclxuICAgICAgICAgICAgaWYgKHV2aSkge1xyXG4gICAgICAgICAgICAgICAgc3ZnY29kZSA9IHV2aS5zdmdjb2RlO1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sID0gdXZpLnN5bWJvbDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHN2Z2NvZGUgPSByZW5kZXJlci5kZWZhdWx0c3ZnY29kZTtcclxuICAgICAgICAgICAgICAgIHN5bWJvbCA9IHJlbmRlcmVyLmRlZmF1bHRTeW1ib2w7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICBjYXNlIENMQVNTX0JSRUFLUzpcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGdWYWwgPSBwYXJzZUZsb2F0KGF0dHJpYnV0ZXNbcmVuZGVyZXIuZmllbGRdKTtcclxuICAgICAgICAgICAgY29uc3QgbG93ZXIgPSByZW5kZXJlci5taW5WYWx1ZTtcclxuXHJcbiAgICAgICAgICAgIHN2Z2NvZGUgPSByZW5kZXJlci5kZWZhdWx0c3ZnY29kZTtcclxuICAgICAgICAgICAgc3ltYm9sID0gcmVuZGVyZXIuZGVmYXVsdFN5bWJvbDtcclxuXHJcbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciBvdXRzaWRlIHJhbmdlIG9uIHRoZSBsb3cgZW5kXHJcbiAgICAgICAgICAgIGlmIChnVmFsIDwgbG93ZXIpIHsgYnJlYWs7IH1cclxuXHJcbiAgICAgICAgICAgIC8vIGFycmF5IG9mIG1pbmltdW0gdmFsdWVzIG9mIHRoZSByYW5nZXMgaW4gdGhlIHJlbmRlcmVyXHJcbiAgICAgICAgICAgIGxldCBtaW5TcGxpdHMgPSByZW5kZXJlci5jbGFzc0JyZWFrSW5mb3MubWFwKGNiaSA9PiBjYmkuY2xhc3NNYXhWYWx1ZSk7XHJcbiAgICAgICAgICAgIG1pblNwbGl0cy5zcGxpY2UoMCwgMCwgbG93ZXIgLSAxKTsgLy8gcHV0IGxvd2VyLTEgYXQgdGhlIHN0YXJ0IG9mIHRoZSBhcnJheSBhbmQgc2hpZnQgYWxsIG90aGVyIGVudHJpZXMgYnkgMVxyXG5cclxuICAgICAgICAgICAgLy8gYXR0ZW1wdCB0byBmaW5kIHRoZSByYW5nZSBvdXIgZ1ZhbCBiZWxvbmdzIGluXHJcbiAgICAgICAgICAgIGNvbnN0IGNiaSA9IHJlbmRlcmVyLmNsYXNzQnJlYWtJbmZvcy5maW5kKChjYmksIGluZGV4KSA9PiBnVmFsID4gbWluU3BsaXRzW2luZGV4XSAmJlxyXG4gICAgICAgICAgICAgICAgZ1ZhbCA8PSBjYmkuY2xhc3NNYXhWYWx1ZSk7XHJcbiAgICAgICAgICAgIGlmICghY2JpKSB7IC8vIG91dHNpZGUgb2YgcmFuZ2Ugb24gdGhlIGhpZ2ggZW5kXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzdmdjb2RlID0gY2JpLnN2Z2NvZGU7XHJcbiAgICAgICAgICAgIHN5bWJvbCA9IGNiaS5zeW1ib2w7XHJcblxyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgZGVmYXVsdDpcclxuXHJcbiAgICAgICAgICAgIC8vIFRPRE8gc2V0IHN2Z2NvZGUgdG8gYmxhbmsgaW1hZ2U/XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgVW5rbm93biByZW5kZXJlciB0eXBlIGVuY291bnRlcmVkIC0gJHtyZW5kZXJlci50eXBlfWApO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICAvLyBtYWtlIGFuIGVtcHR5IHN2ZyBncmFwaGljIGluIGNhc2Ugbm90aGluZyBpcyBmb3VuZCB0byBhdm9pZCB1bmRlZmluZWQgaW5zaWRlIHRoZSBmaWx0ZXJzXHJcbiAgICBpZiAodHlwZW9mIHN2Z2NvZGUgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgc3ZnY29kZSA9IHN2Z2pzKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKS5zaXplKENPTlRBSU5FUl9TSVpFLCBDT05UQUlORVJfU0laRSkuc3ZnKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHsgc3ZnY29kZSwgc3ltYm9sIH07XHJcblxyXG59XHJcblxyXG4vKipcclxuKiBHaXZlbiBmZWF0dXJlIGF0dHJpYnV0ZXMsIHJldHVybiB0aGUgaW1hZ2UgVVJMIGZvciB0aGF0IGZlYXR1cmUvZ3JhcGhpYyBvYmplY3QuXHJcbipcclxuKiBAbWV0aG9kIGdldEdyYXBoaWNJY29uXHJcbiogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnV0ZXMgb2JqZWN0IG9mIGZlYXR1cmUgYXR0cmlidXRlIGtleSB2YWx1ZSBwYWlyc1xyXG4qIEBwYXJhbSB7T2JqZWN0fSByZW5kZXJlciBhbiBlbmhhbmNlZCByZW5kZXJlciAoc2VlIGZ1bmN0aW9uIGVuaGFuY2VSZW5kZXJlcilcclxuKiBAcmV0dXJuIHtTdHJpbmd9IHN2Z2NvZGUgVXJsIHRvIHRoZSBmZWF0dXJlcyBzeW1ib2xvZ3kgaW1hZ2VcclxuKi9cclxuZnVuY3Rpb24gZ2V0R3JhcGhpY0ljb24oYXR0cmlidXRlcywgcmVuZGVyZXIpIHtcclxuICAgIGNvbnN0IHJlbmRlckluZm8gPSBzZWFyY2hSZW5kZXJlcihhdHRyaWJ1dGVzLCByZW5kZXJlcik7XHJcbiAgICByZXR1cm4gcmVuZGVySW5mby5zdmdjb2RlO1xyXG59XHJcblxyXG4vKipcclxuKiBHaXZlbiBmZWF0dXJlIGF0dHJpYnV0ZXMsIHJldHVybiB0aGUgc3ltYm9sIGZvciB0aGF0IGZlYXR1cmUvZ3JhcGhpYyBvYmplY3QuXHJcbipcclxuKiBAbWV0aG9kIGdldEdyYXBoaWNTeW1ib2xcclxuKiBAcGFyYW0ge09iamVjdH0gYXR0cmlidXRlcyBvYmplY3Qgb2YgZmVhdHVyZSBhdHRyaWJ1dGUga2V5IHZhbHVlIHBhaXJzXHJcbiogQHBhcmFtIHtPYmplY3R9IHJlbmRlcmVyIGFuIGVuaGFuY2VkIHJlbmRlcmVyIChzZWUgZnVuY3Rpb24gZW5oYW5jZVJlbmRlcmVyKVxyXG4qIEByZXR1cm4ge09iamVjdH0gYW4gRVNSSSBTeW1ib2wgb2JqZWN0IGluIHNlcnZlciBmb3JtYXRcclxuKi9cclxuZnVuY3Rpb24gZ2V0R3JhcGhpY1N5bWJvbChhdHRyaWJ1dGVzLCByZW5kZXJlcikge1xyXG4gICAgY29uc3QgcmVuZGVySW5mbyA9IHNlYXJjaFJlbmRlcmVyKGF0dHJpYnV0ZXMsIHJlbmRlcmVyKTtcclxuICAgIHJldHVybiByZW5kZXJJbmZvLnN5bWJvbDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdlbmVyYXRlcyBzdmcgc3ltYm9sb2d5IGZvciBXTVMgbGF5ZXJzLlxyXG4gKiBAZnVuY3Rpb24gZ2VuZXJhdGVXTVNTeW1ib2xvZ3lcclxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgbGFiZWwgZm9yIHRoZSBzeW1ib2xvZ3kgaXRlbSAoaXQncyBub3QgdXNlZCByaWdodCBub3csIGJ1dCBpcyByZXF1aXJlZCB0byBiZSBjb25zaXN0ZW50IHdpdGggb3RoZXIgc3ltYm9sb2d5IGdlbmVyYXRpbmcgZnVuY3Rpb25zKVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gaW1hZ2VVcmkgdXJsIG9yIGRhdGFVcmwgb2YgdGhlIGxlZ2VuZCBpbWFnZVxyXG4gKiBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2UgcmVzb2x2aW5nIHdpdGggc3ltYm9sb2d5IHN2ZyBjb2RlIGFuZCBpdHMgbGFiZWxcclxuICovXHJcbmZ1bmN0aW9uIGdlbmVyYXRlV01TU3ltYm9sb2d5KG5hbWUsIGltYWdlVXJpKSB7XHJcbiAgICBjb25zdCBkcmF3ID0gc3ZnanMod2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKVxyXG4gICAgICAgIC5zaXplKENPTlRBSU5FUl9TSVpFLCBDT05UQUlORVJfU0laRSlcclxuICAgICAgICAudmlld2JveCgwLCAwLCAwLCAwKTtcclxuXHJcbiAgICBjb25zdCBzeW1ib2xvZ3lJdGVtID0ge1xyXG4gICAgICAgIG5hbWUsXHJcbiAgICAgICAgc3ZnY29kZTogbnVsbFxyXG4gICAgfTtcclxuXHJcbiAgICBpZiAoaW1hZ2VVcmkpIHtcclxuICAgICAgICBjb25zdCByZW5kZXJQcm9taXNlID0gcmVuZGVyU3ltYm9sb2d5SW1hZ2UoaW1hZ2VVcmkpLnRoZW4oc3ZnY29kZSA9PiB7XHJcbiAgICAgICAgICAgIHN5bWJvbG9neUl0ZW0uc3ZnY29kZSA9IHN2Z2NvZGU7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gc3ltYm9sb2d5SXRlbTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJlbmRlclByb21pc2U7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHN5bWJvbG9neUl0ZW0uc3ZnY29kZSA9IGRyYXcuc3ZnKCk7XHJcblxyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc3ltYm9sb2d5SXRlbSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyBhIGNvbmZpZy1zdXBwbGllZCBsaXN0IG9mIHN5bWJvbG9neSB0byB0aGUgZm9ybWF0IHVzZWQgYnkgbGF5ZXIgcmVjb3Jkcy5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQGZ1bmN0aW9uIF9saXN0VG9TeW1ib2xvZ3lcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gY29udmVyc2lvbkZ1bmN0aW9uIGEgY29udmVyc2lvbiBmdW5jdGlvbiB0byB3cmFwIHRoZSBzdXBwbGllZCBpbWFnZSBpbnRvIGFuIGltYWdlIG9yIGFuIGljb24gc3R5bGUgc3ltYm9sb2d5IGNvbnRhaW5lclxyXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IGEgbGlzdCBvZiBjb25maWctc3VwcGxpZWQgc3ltYm9sb2d5IGl0ZW1zIGluIHRoZSBmb3JtIG9mIFsgeyB0ZXh0OiA8U3RyaW5nPiwgaW1hZ2U6IDxTdHJpbmc+IH0sIC4uLiBdIHdoZXIgYGltYWdlYCBjYW4gYmUgZGF0YVVSTCBvciBhbiBhY3R1YWwgdXJsXHJcbiAqIEByZXR1cm4ge0FycmF5fSBhbiBhcnJheSBvZiBjb252ZXJ0ZWQgc3ltYm9sb2d5IHN5bWJvbHMgaW4gdGhlIGZvcm0gb2YgWyB7IG5hbWU6IDxTdHJpbmc+LCBzdmdjb2RlOiA8U3RyaW5nPiB9LCAuLi4gXTsgaXRlbXMgd2lsbCBiZSBwb3B1bGF0ZWQgYXN5bmMgYXMgY29udmVyc2lvbnMgYXJlIGRvbmVcclxuICovXHJcbmZ1bmN0aW9uIF9saXN0VG9TeW1ib2xvZ3koY29udmVyc2lvbkZ1bmN0aW9uLCBsaXN0KSB7XHJcbiAgICBjb25zdCByZXN1bHRzID0gbGlzdC5tYXAoKHsgdGV4dCwgaW1hZ2UgfSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcclxuICAgICAgICAgICAgbmFtZTogdGV4dCxcclxuICAgICAgICAgICAgc3ZnY29kZTogbnVsbFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGNvbnZlcnNpb25GdW5jdGlvbihpbWFnZSkudGhlbihzdmdjb2RlID0+IHtcclxuICAgICAgICAgICAgcmVzdWx0LnN2Z2NvZGUgPSBzdmdjb2RlO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdHM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZW5kZXJzIGEgc3VwcGxpZWQgaW1hZ2UgYXMgYW4gaW1hZ2Utc3R5bGUgc3ltYm9sb2d5IGl0ZW0gKHByZXNlcnZpbmcgdGhlIHRydWUgaW1hZ2UgZGltZW5zaW9ucykuXHJcbiAqXHJcbiAqIEBmdW5jdGlvbiByZW5kZXJTeW1ib2xvZ3lJbWFnZVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gaW1hZ2VVcmkgYSBpbWFnZSBkYXRhVXJsIG9yIGEgcmVndWxhciB1cmxcclxuICogQHBhcmFtIHtPYmplY3R9IGRyYXcgW29wdGlvbmFsPW51bGxdIGFuIHN2ZyBjb250YWluZXIgdG8gZHJhdyB0aGUgaW1hZ2Ugb247IGlmIG5vdCBzdXBwbGllZCwgYSBuZXcgb25lIGlzIGNyZWF0ZWRcclxuICovXHJcbmZ1bmN0aW9uIHJlbmRlclN5bWJvbG9neUltYWdlKGltYWdlVXJpLCBkcmF3ID0gbnVsbCkge1xyXG4gICAgaWYgKGRyYXcgPT09IG51bGwpIHtcclxuICAgICAgICBkcmF3ID0gc3ZnanMod2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKVxyXG4gICAgICAgICAgICAuc2l6ZShDT05UQUlORVJfU0laRSwgQ09OVEFJTkVSX1NJWkUpXHJcbiAgICAgICAgICAgIC52aWV3Ym94KDAsIDAsIDAsIDApO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHN5bWJvbG9neVByb21pc2UgPSBzaGFyZWQuY29udmVydEltYWdldG9EYXRhVVJMKGltYWdlVXJpKVxyXG4gICAgICAgIC50aGVuKGltYWdlVXJpID0+XHJcbiAgICAgICAgICAgIHN2Z0RyYXdJbWFnZShkcmF3LCBpbWFnZVVyaSkpXHJcbiAgICAgICAgLnRoZW4oKHsgbG9hZGVyIH0pID0+IHtcclxuICAgICAgICAgICAgZHJhdy52aWV3Ym94KDAsIDAsIGxvYWRlci53aWR0aCwgbG9hZGVyLmhlaWdodCk7XHJcbiAgICAgICAgICAgIHJldHVybiBkcmF3LnN2ZygpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmNhdGNoKGVyciA9PiB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Nhbm5vdCBkcmF3IHN5bWJvbG9neSBpYW1nZTsgcmV0dXJuaW5nIGVtcHR5JywgZXJyKTtcclxuICAgICAgICAgICAgcmV0dXJuIGRyYXcuc3ZnKCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHN5bWJvbG9neVByb21pc2U7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZW5kZXJzIGEgc3VwcGxpZWQgaW1hZ2UgYXMgYW4gaWNvbi1zdHlsZSBzeW1ib2xvZ3kgaXRlbSAoZml0dGluZyBhbiBpbWFnZSBpbnNpZGUgYW4gaWNvbiBjb250YWluZXIsIHVzdWFsbHkgMzJ4MzIgcGl4ZWxzKS5cclxuICpcclxuICogQGZ1bmN0aW9uIHJlbmRlclN5bWJvbG9neUljb25cclxuICogQHBhcmFtIHtTdHJpbmd9IGltYWdlVXJpIGEgaW1hZ2UgZGF0YVVybCBvciBhIHJlZ3VsYXIgdXJsXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBkcmF3IFtvcHRpb25hbD1udWxsXSBhbiBzdmcgY29udGFpbmVyIHRvIGRyYXcgdGhlIGltYWdlIG9uOyBpZiBub3Qgc3VwcGxpZWQsIGEgbmV3IG9uZSBpcyBjcmVhdGVkXHJcbiAqL1xyXG5mdW5jdGlvbiByZW5kZXJTeW1ib2xvZ3lJY29uKGltYWdlVXJpLCBkcmF3ID0gbnVsbCkge1xyXG4gICAgaWYgKGRyYXcgPT09IG51bGwpIHtcclxuICAgICAgICAvLyBjcmVhdGUgYSB0ZW1wb3Jhcnkgc3ZnIGVsZW1lbnQgYW5kIGFkZCBpdCB0byB0aGUgcGFnZTsgaWYgbm90IGFkZGVkLCB0aGUgZWxlbWVudCdzIGJvdW5kaW5nIGJveCBjYW5ub3QgYmUgY2FsY3VsYXRlZCBjb3JyZWN0bHlcclxuICAgICAgICBjb25zdCBjb250YWluZXIgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgY29udGFpbmVyLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnb3BhY2l0eTowO3Bvc2l0aW9uOmZpeGVkO2xlZnQ6MTAwJTt0b3A6MTAwJTtvdmVyZmxvdzpoaWRkZW4nKTtcclxuICAgICAgICB3aW5kb3cuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjb250YWluZXIpO1xyXG5cclxuICAgICAgICBkcmF3ID0gc3ZnanMoY29udGFpbmVyKVxyXG4gICAgICAgICAgICAuc2l6ZShDT05UQUlORVJfU0laRSwgQ09OVEFJTkVSX1NJWkUpXHJcbiAgICAgICAgICAgIC52aWV3Ym94KDAsIDAsIENPTlRBSU5FUl9TSVpFLCBDT05UQUlORVJfU0laRSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gbmVlZCB0byBkcmF3IHRoZSBpbWFnZSB0byBnZXQgaXRzIHNpemUgKHRlY2huaWNhbGx5IG5vdCBuZWVkZWQgaWYgd2UgaGF2ZSBhIHVybCwgYnV0IHRoaXMgaXMgc2ltcGxlcilcclxuICAgIGNvbnN0IHBpY3R1cmVQcm9taXNlID0gc2hhcmVkLmNvbnZlcnRJbWFnZXRvRGF0YVVSTChpbWFnZVVyaSlcclxuICAgICAgICAudGhlbihpbWFnZVVyaSA9PlxyXG4gICAgICAgICAgICBzdmdEcmF3SW1hZ2UoZHJhdywgaW1hZ2VVcmkpKVxyXG4gICAgICAgIC50aGVuKCh7IGltYWdlIH0pID0+IHtcclxuICAgICAgICAgICAgaW1hZ2UuY2VudGVyKENPTlRBSU5FUl9DRU5URVIsIENPTlRBSU5FUl9DRU5URVIpO1xyXG5cclxuICAgICAgICAgICAgLy8gc2NhbGUgaW1hZ2UgdG8gZml0IGludG8gdGhlIHN5bWJvbG9neSBpdGVtIGNvbnRhaW5lclxyXG4gICAgICAgICAgICBmaXRJbnRvKGltYWdlLCBDT05URU5UX0lNQUdFX1NJWkUpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGRyYXcuc3ZnKCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHBpY3R1cmVQcm9taXNlO1xyXG59XHJcblxyXG4vKipcclxuICogR2VuZXJhdGVzIGEgcGxhY2Vob2xkZXIgc3ltYm9sb2d5IGdyYXBoaWMuIFJldHVybnMgYSBwcm9taXNlIGZvciBjb25zaXN0ZW5jeVxyXG4gKiBAZnVuY3Rpb24gZ2VuZXJhdGVQbGFjZWhvbGRlclN5bWJvbG9neVxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0gIHtTdHJpbmd9IG5hbWUgbGFiZWwgc3ltYm9sb2d5IGxhYmVsXHJcbiAqIEBwYXJhbSAge1N0cmluZ30gY29sb3VyIGNvbG91ciB0byB1c2UgaW4gdGhlIGdyYXBoaWNcclxuICogQHJldHVybiB7T2JqZWN0fSBzeW1ib2xvZ3kgc3ZnIGNvZGUgYW5kIGl0cyBsYWJlbFxyXG4gKi9cclxuZnVuY3Rpb24gZ2VuZXJhdGVQbGFjZWhvbGRlclN5bWJvbG9neShuYW1lLCBjb2xvdXIgPSAnIzAwMCcpIHtcclxuICAgIGNvbnN0IGRyYXcgPSBzdmdqcyh3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpXHJcbiAgICAgICAgLnNpemUoQ09OVEFJTkVSX1NJWkUsIENPTlRBSU5FUl9TSVpFKVxyXG4gICAgICAgIC52aWV3Ym94KDAsIDAsIENPTlRBSU5FUl9TSVpFLCBDT05UQUlORVJfU0laRSk7XHJcblxyXG4gICAgZHJhdy5yZWN0KENPTlRFTlRfSU1BR0VfU0laRSwgQ09OVEVOVF9JTUFHRV9TSVpFKVxyXG4gICAgICAgIC5jZW50ZXIoQ09OVEFJTkVSX0NFTlRFUiwgQ09OVEFJTkVSX0NFTlRFUilcclxuICAgICAgICAuZmlsbChjb2xvdXIpO1xyXG5cclxuICAgIGRyYXdcclxuICAgICAgICAudGV4dChuYW1lWzBdLnRvVXBwZXJDYXNlKCkpIC8vIHRha2UgdGhlIGZpcnN0IGxldHRlclxyXG4gICAgICAgIC5zaXplKDIzKVxyXG4gICAgICAgIC5maWxsKCcjZmZmJylcclxuICAgICAgICAuYXR0cih7XHJcbiAgICAgICAgICAgICdmb250LXdlaWdodCc6ICdib2xkJyxcclxuICAgICAgICAgICAgJ2ZvbnQtZmFtaWx5JzogJ1JvYm90bydcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5jZW50ZXIoQ09OVEFJTkVSX0NFTlRFUiwgQ09OVEFJTkVSX0NFTlRFUik7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBuYW1lLFxyXG4gICAgICAgIHN2Z2NvZGU6IGRyYXcuc3ZnKClcclxuICAgIH07XHJcbn1cclxuXHJcbi8qKlxyXG4qIEdlbmVyYXRlIGEgbGVnZW5kIGl0ZW0gZm9yIGFuIEVTUkkgc3ltYm9sLlxyXG4qIEBwcml2YXRlXHJcbiogQHBhcmFtICB7T2JqZWN0fSBzeW1ib2wgYW4gRVNSSSBzeW1ib2wgb2JqZWN0IGluIHNlcnZlciBmb3JtYXRcclxuKiBAcGFyYW0gIHtTdHJpbmd9IGxhYmVsIGxhYmVsIG9mIHRoZSBsZWdlbmQgaXRlbVxyXG4qIEBwYXJhbSAge09iamVjdH0gd2luZG93IHJlZmVyZW5jZSB0byB0aGUgYnJvd3NlciB3aW5kb3dcclxuKiBAcmV0dXJuIHtPYmplY3R9IGEgbGVnZW5kIG9iamVjdCBwb3B1bGF0ZWQgd2l0aCB0aGUgc3ltYm9sIGFuZCBsYWJlbFxyXG4qL1xyXG5mdW5jdGlvbiBzeW1ib2xUb0xlZ2VuZChzeW1ib2wsIGxhYmVsLCB3aW5kb3cpIHtcclxuICAgIC8vIGNyZWF0ZSBhIHRlbXBvcmFyeSBzdmcgZWxlbWVudCBhbmQgYWRkIGl0IHRvIHRoZSBwYWdlOyBpZiBub3QgYWRkZWQsIHRoZSBlbGVtZW50J3MgYm91bmRpbmcgYm94IGNhbm5vdCBiZSBjYWxjdWxhdGVkIGNvcnJlY3RseVxyXG4gICAgY29uc3QgY29udGFpbmVyID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgY29udGFpbmVyLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnb3BhY2l0eTowO3Bvc2l0aW9uOmZpeGVkO2xlZnQ6MTAwJTt0b3A6MTAwJTtvdmVyZmxvdzpoaWRkZW4nKTtcclxuICAgIHdpbmRvdy5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XHJcblxyXG4gICAgY29uc3QgZHJhdyA9IHN2Z2pzKGNvbnRhaW5lcilcclxuICAgICAgICAuc2l6ZShDT05UQUlORVJfU0laRSwgQ09OVEFJTkVSX1NJWkUpXHJcbiAgICAgICAgLnZpZXdib3goMCwgMCwgQ09OVEFJTkVSX1NJWkUsIENPTlRBSU5FUl9TSVpFKTtcclxuXHJcbiAgICAvLyBmdW5jdGlvbnMgdG8gZHJhdyBlc3JpIHNpbXBsZSBtYXJrZXIgc3ltYm9sc1xyXG4gICAgLy8ganNjcyBkb2Vzbid0IGxpa2UgZW5oYW5jZWQgb2JqZWN0IG5vdGF0aW9uXHJcbiAgICAvLyBqc2NzOmRpc2FibGUgcmVxdWlyZVNwYWNlc0luQW5vbnltb3VzRnVuY3Rpb25FeHByZXNzaW9uXHJcbiAgICBjb25zdCBlc3JpU2ltcGxlTWFya2VyU2ltYm9sID0ge1xyXG4gICAgICAgIGVzcmlTTVNQYXRoKHsgc2l6ZSwgcGF0aCB9KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkcmF3LnBhdGgocGF0aCkuc2l6ZShzaXplKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVzcmlTTVNDaXJjbGUoeyBzaXplIH0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRyYXcuY2lyY2xlKHNpemUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXNyaVNNU0Nyb3NzKHsgc2l6ZSB9KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkcmF3LnBhdGgoJ00gMCwxMCBMIDIwLDEwIE0gMTAsMCBMIDEwLDIwJykuc2l6ZShzaXplKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVzcmlTTVNYKHsgc2l6ZSB9KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkcmF3LnBhdGgoJ00gMCwwIEwgMjAsMjAgTSAyMCwwIEwgMCwyMCcpLnNpemUoc2l6ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlc3JpU01TVHJpYW5nbGUoeyBzaXplIH0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRyYXcucGF0aCgnTSAyMCwyMCBMIDEwLDAgMCwyMCBaJykuc2l6ZShzaXplKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVzcmlTTVNEaWFtb25kKHsgc2l6ZSB9KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkcmF3LnBhdGgoJ00gMjAsMTAgTCAxMCwwIDAsMTAgMTAsMjAgWicpLnNpemUoc2l6ZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlc3JpU01TU3F1YXJlKHsgc2l6ZSB9KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkcmF3LnBhdGgoJ00gMCwwIDIwLDAgMjAsMjAgMCwyMCBaJykuc2l6ZShzaXplKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIGpzY3M6ZW5hYmxlIHJlcXVpcmVTcGFjZXNJbkFub255bW91c0Z1bmN0aW9uRXhwcmVzc2lvblxyXG5cclxuICAgIC8vIGxpbmUgZGFzaCBzdHlsZXNcclxuICAgIGNvbnN0IEVTUklfREFTSF9NQVBTID0ge1xyXG4gICAgICAgIGVzcmlTTFNTb2xpZDogJ25vbmUnLFxyXG4gICAgICAgIGVzcmlTTFNEYXNoOiAnNS4zMzMsNCcsXHJcbiAgICAgICAgZXNyaVNMU0Rhc2hEb3Q6ICc1LjMzMyw0LDEuMzMzLDQnLFxyXG4gICAgICAgIGVzcmlTTFNMb25nRGFzaERvdERvdDogJzEwLjY2Niw0LDEuMzMzLDQsMS4zMzMsNCcsXHJcbiAgICAgICAgZXNyaVNMU0RvdDogJzEuMzMzLDQnLFxyXG4gICAgICAgIGVzcmlTTFNMb25nRGFzaDogJzEwLjY2Niw0JyxcclxuICAgICAgICBlc3JpU0xTTG9uZ0Rhc2hEb3Q6ICcxMC42NjYsNCwxLjMzMyw0JyxcclxuICAgICAgICBlc3JpU0xTU2hvcnREYXNoOiAnNS4zMzMsMS4zMzMnLFxyXG4gICAgICAgIGVzcmlTTFNTaG9ydERhc2hEb3Q6ICc1LjMzMywxLjMzMywxLjMzMywxLjMzMycsXHJcbiAgICAgICAgZXNyaVNMU1Nob3J0RGFzaERvdERvdDogJzUuMzMzLDEuMzMzLDEuMzMzLDEuMzMzLDEuMzMzLDEuMzMzJyxcclxuICAgICAgICBlc3JpU0xTU2hvcnREb3Q6ICcxLjMzMywxLjMzMycsXHJcbiAgICAgICAgZXNyaVNMU051bGw6ICdub25lJ1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBkZWZhdWx0IHN0cm9rZSBzdHlsZVxyXG4gICAgY29uc3QgREVGQVVMVF9TVFJPS0UgPSB7XHJcbiAgICAgICAgY29sb3I6ICcjMDAwJyxcclxuICAgICAgICBvcGFjaXR5OiAxLFxyXG4gICAgICAgIHdpZHRoOiAxLFxyXG4gICAgICAgIGxpbmVjYXA6ICdzcXVhcmUnLFxyXG4gICAgICAgIGxpbmVqb2luOiAnbWl0ZXInLFxyXG4gICAgICAgIG1pdGVybGltaXQ6IDRcclxuICAgIH07XHJcblxyXG4gICAgLy8gdGhpcyBpcyBhIG51bGwgb3V0bGluZSBpbiBjYXNlIGEgc3VwcGxpZWQgc3ltYm9sIGRvZXNuJ3QgaGF2ZSBvbmVcclxuICAgIGNvbnN0IERFRkFVTFRfT1VUTElORSA9IHtcclxuICAgICAgICBjb2xvcjogWzAsIDAsIDAsIDBdLFxyXG4gICAgICAgIHdpZHRoOiAwLFxyXG4gICAgICAgIHN0eWxlOiBFU1JJX0RBU0hfTUFQUy5lc3JpU0xTTnVsbFxyXG4gICAgfTtcclxuXHJcbiAgICAvLyA1eDUgcHggcGF0dGVyIHdpdGggY29sb3VyZWQgZGlhZ29uYWwgbGluZXNcclxuICAgIGNvbnN0IGVzcmlTRlNGaWxscyA9IHtcclxuICAgICAgICBlc3JpU0ZTU29saWQ6IHN5bWJvbENvbG91ciA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBjb2xvcjogc3ltYm9sQ29sb3VyLmNvbG91cixcclxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IHN5bWJvbENvbG91ci5vcGFjaXR5XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlc3JpU0ZTTnVsbDogKCkgPT4gJ3RyYW5zcGFyZW50JyxcclxuICAgICAgICBlc3JpU0ZTSG9yaXpvbnRhbDogKHN5bWJvbENvbG91ciwgc3ltYm9sU3Ryb2tlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNlbGxTaXplID0gNTtcclxuXHJcbiAgICAgICAgICAgIC8vIHBhdHRlciBmaWxsOiBob3Jpem9uYWwgbGluZSBpbiBhIDV4NSBweCBzcXVhcmVcclxuICAgICAgICAgICAgcmV0dXJuIGRyYXcucGF0dGVybihjZWxsU2l6ZSwgY2VsbFNpemUsIGFkZCA9PlxyXG4gICAgICAgICAgICAgICAgYWRkLmxpbmUoMCwgY2VsbFNpemUgLyAyLCBjZWxsU2l6ZSwgY2VsbFNpemUgLyAyKSkuc3Ryb2tlKHN5bWJvbFN0cm9rZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlc3JpU0ZTVmVydGljYWw6IChzeW1ib2xDb2xvdXIsIHN5bWJvbFN0cm9rZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjZWxsU2l6ZSA9IDU7XHJcblxyXG4gICAgICAgICAgICAvLyBwYXR0ZXIgZmlsbDogdmVydGljYWwgbGluZSBpbiBhIDV4NSBweCBzcXVhcmVcclxuICAgICAgICAgICAgcmV0dXJuIGRyYXcucGF0dGVybihjZWxsU2l6ZSwgY2VsbFNpemUsIGFkZCA9PlxyXG4gICAgICAgICAgICAgICAgYWRkLmxpbmUoY2VsbFNpemUgLyAyLCAwLCBjZWxsU2l6ZSAvIDIsIGNlbGxTaXplKSkuc3Ryb2tlKHN5bWJvbFN0cm9rZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlc3JpU0ZTRm9yd2FyZERpYWdvbmFsOiAoc3ltYm9sQ29sb3VyLCBzeW1ib2xTdHJva2UpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY2VsbFNpemUgPSA1O1xyXG5cclxuICAgICAgICAgICAgLy8gcGF0dGVyIGZpbGw6IGZvcndhcmQgZGlhZ29uYWwgbGluZSBpbiBhIDV4NSBweCBzcXVhcmU7IHR3byBtb3JlIGRpYWdvbmFsIGxpbmVzIG9mZnNldCB0byBjb3ZlciB0aGUgY29ybmVycyB3aGVuIHRoZSBtYWluIGxpbmUgaXMgY3V0IG9mZlxyXG4gICAgICAgICAgICByZXR1cm4gZHJhdy5wYXR0ZXJuKGNlbGxTaXplLCBjZWxsU2l6ZSwgYWRkID0+IHtcclxuICAgICAgICAgICAgICAgIGFkZC5saW5lKDAsIDAsIGNlbGxTaXplLCBjZWxsU2l6ZSkuc3Ryb2tlKHN5bWJvbFN0cm9rZSk7XHJcbiAgICAgICAgICAgICAgICBhZGQubGluZSgwLCAwLCBjZWxsU2l6ZSwgY2VsbFNpemUpLm1vdmUoMCwgY2VsbFNpemUpLnN0cm9rZShzeW1ib2xTdHJva2UpO1xyXG4gICAgICAgICAgICAgICAgYWRkLmxpbmUoMCwgMCwgY2VsbFNpemUsIGNlbGxTaXplKS5tb3ZlKGNlbGxTaXplLCAwKS5zdHJva2Uoc3ltYm9sU3Ryb2tlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlc3JpU0ZTQmFja3dhcmREaWFnb25hbDogKHN5bWJvbENvbG91ciwgc3ltYm9sU3Ryb2tlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNlbGxTaXplID0gNTtcclxuXHJcbiAgICAgICAgICAgIC8vIHBhdHRlciBmaWxsOiBiYWNrd2FyZCBkaWFnb25hbCBsaW5lIGluIGEgNXg1IHB4IHNxdWFyZTsgdHdvIG1vcmUgZGlhZ29uYWwgbGluZXMgb2Zmc2V0IHRvIGNvdmVyIHRoZSBjb3JuZXJzIHdoZW4gdGhlIG1haW4gbGluZSBpcyBjdXQgb2ZmXHJcbiAgICAgICAgICAgIHJldHVybiBkcmF3LnBhdHRlcm4oY2VsbFNpemUsIGNlbGxTaXplLCBhZGQgPT4ge1xyXG4gICAgICAgICAgICAgICAgYWRkLmxpbmUoY2VsbFNpemUsIDAsIDAsIGNlbGxTaXplKS5zdHJva2Uoc3ltYm9sU3Ryb2tlKTtcclxuICAgICAgICAgICAgICAgIGFkZC5saW5lKGNlbGxTaXplLCAwLCAwLCBjZWxsU2l6ZSkubW92ZShjZWxsU2l6ZSAvIDIsIGNlbGxTaXplIC8gMikuc3Ryb2tlKHN5bWJvbFN0cm9rZSk7XHJcbiAgICAgICAgICAgICAgICBhZGQubGluZShjZWxsU2l6ZSwgMCwgMCwgY2VsbFNpemUpLm1vdmUoLWNlbGxTaXplIC8gMiwgLWNlbGxTaXplIC8gMikuc3Ryb2tlKHN5bWJvbFN0cm9rZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXNyaVNGU0Nyb3NzOiAoc3ltYm9sQ29sb3VyLCBzeW1ib2xTdHJva2UpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY2VsbFNpemUgPSA1O1xyXG5cclxuICAgICAgICAgICAgLy8gcGF0dGVyIGZpbGw6IGhvcml6b25hbCBhbmQgdmVydGljYWwgbGluZXMgaW4gYSA1eDUgcHggc3F1YXJlXHJcbiAgICAgICAgICAgIHJldHVybiBkcmF3LnBhdHRlcm4oY2VsbFNpemUsIGNlbGxTaXplLCBhZGQgPT4ge1xyXG4gICAgICAgICAgICAgICAgYWRkLmxpbmUoY2VsbFNpemUgLyAyLCAwLCBjZWxsU2l6ZSAvIDIsIGNlbGxTaXplKS5zdHJva2Uoc3ltYm9sU3Ryb2tlKTtcclxuICAgICAgICAgICAgICAgIGFkZC5saW5lKDAsIGNlbGxTaXplIC8gMiwgY2VsbFNpemUsIGNlbGxTaXplIC8gMikuc3Ryb2tlKHN5bWJvbFN0cm9rZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXNyaVNGU0RpYWdvbmFsQ3Jvc3M6IChzeW1ib2xDb2xvdXIsIHN5bWJvbFN0cm9rZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjZWxsU2l6ZSA9IDc7XHJcblxyXG4gICAgICAgICAgICAvLyBwYXR0ZXIgZmlsbDogY3Jvc3NpbmcgZGlhZ29uYWwgbGluZXMgaW4gYSA3eDcgcHggc3F1YXJlXHJcbiAgICAgICAgICAgIHJldHVybiBkcmF3LnBhdHRlcm4oY2VsbFNpemUsIGNlbGxTaXplLCBhZGQgPT4ge1xyXG4gICAgICAgICAgICAgICAgYWRkLmxpbmUoMCwgMCwgY2VsbFNpemUsIGNlbGxTaXplKS5zdHJva2Uoc3ltYm9sU3Ryb2tlKTtcclxuICAgICAgICAgICAgICAgIGFkZC5saW5lKGNlbGxTaXplLCAwLCAwLCBjZWxsU2l6ZSkuc3Ryb2tlKHN5bWJvbFN0cm9rZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy8ganNjcyBkb2Vzbid0IGxpa2UgZW5oYW5jZWQgb2JqZWN0IG5vdGF0aW9uXHJcbiAgICAvLyBqc2NzOmRpc2FibGUgcmVxdWlyZVNwYWNlc0luQW5vbnltb3VzRnVuY3Rpb25FeHByZXNzaW9uXHJcbiAgICBjb25zdCBzeW1ib2xUeXBlcyA9IHtcclxuICAgICAgICBlc3JpU01TKCkgeyAvLyBFU1JJIFNpbXBsZSBNYXJrZXIgU3ltYm9sXHJcbiAgICAgICAgICAgIGNvbnN0IHN5bWJvbENvbG91ciA9IHBhcnNlRXNyaUNvbG91cihzeW1ib2wuY29sb3IpO1xyXG5cclxuICAgICAgICAgICAgc3ltYm9sLm91dGxpbmUgPSBzeW1ib2wub3V0bGluZSB8fCBERUZBVUxUX09VVExJTkU7XHJcbiAgICAgICAgICAgIGNvbnN0IG91dGxpbmVDb2xvdXIgPSBwYXJzZUVzcmlDb2xvdXIoc3ltYm9sLm91dGxpbmUuY29sb3IpO1xyXG4gICAgICAgICAgICBjb25zdCBvdXRsaW5lU3Ryb2tlID0gbWFrZVN0cm9rZSh7XHJcbiAgICAgICAgICAgICAgICBjb2xvcjogb3V0bGluZUNvbG91ci5jb2xvdXIsXHJcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiBvdXRsaW5lQ29sb3VyLm9wYWNpdHksXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogc3ltYm9sLm91dGxpbmUud2lkdGgsXHJcbiAgICAgICAgICAgICAgICBkYXNoYXJyYXk6IEVTUklfREFTSF9NQVBTW3N5bWJvbC5vdXRsaW5lLnN0eWxlXVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vIG1ha2UgYW4gRVNSSSBzaW1wbGUgc3ltYm9sIGFuZCBhcHBseSBmaWxsIGFuZCBvdXRsaW5lIHRvIGl0XHJcbiAgICAgICAgICAgIGNvbnN0IG1hcmtlciA9IGVzcmlTaW1wbGVNYXJrZXJTaW1ib2xbc3ltYm9sLnN0eWxlXShzeW1ib2wpXHJcbiAgICAgICAgICAgICAgICAuZmlsbCh7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IHN5bWJvbENvbG91ci5jb2xvdXIsXHJcbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogc3ltYm9sQ29sb3VyLm9wYWNpdHlcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuc3Ryb2tlKG91dGxpbmVTdHJva2UpXHJcbiAgICAgICAgICAgICAgICAuY2VudGVyKENPTlRBSU5FUl9DRU5URVIsIENPTlRBSU5FUl9DRU5URVIpXHJcbiAgICAgICAgICAgICAgICAucm90YXRlKHN5bWJvbC5hbmdsZSB8fCAwKTtcclxuXHJcbiAgICAgICAgICAgIGZpdEludG8obWFya2VyLCBDT05URU5UX1NJWkUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXNyaVNMUygpIHsgLy8gRVNSSSBTaW1wbGUgTGluZSBTeW1ib2xcclxuICAgICAgICAgICAgY29uc3QgbGluZUNvbG91ciA9IHBhcnNlRXNyaUNvbG91cihzeW1ib2wuY29sb3IpO1xyXG4gICAgICAgICAgICBjb25zdCBsaW5lU3Ryb2tlID0gbWFrZVN0cm9rZSh7XHJcbiAgICAgICAgICAgICAgICBjb2xvcjogbGluZUNvbG91ci5jb2xvdXIsXHJcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiBsaW5lQ29sb3VyLm9wYWNpdHksXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogc3ltYm9sLndpZHRoLFxyXG4gICAgICAgICAgICAgICAgbGluZWNhcDogJ2J1dHQnLFxyXG4gICAgICAgICAgICAgICAgZGFzaGFycmF5OiBFU1JJX0RBU0hfTUFQU1tzeW1ib2wuc3R5bGVdXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgbWluID0gQ09OVEVOVF9QQURESU5HO1xyXG4gICAgICAgICAgICBjb25zdCBtYXggPSBDT05UQUlORVJfU0laRSAtIENPTlRFTlRfUEFERElORztcclxuICAgICAgICAgICAgZHJhdy5saW5lKG1pbiwgbWluLCBtYXgsIG1heClcclxuICAgICAgICAgICAgICAgIC5zdHJva2UobGluZVN0cm9rZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlc3JpQ0xTKCkgeyAgLy8gRVNSSSBGYW5jeSBMaW5lIFN5bWJvbFxyXG4gICAgICAgICAgICB0aGlzLmVzcmlTTFMoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVzcmlTRlMoKSB7IC8vIEVTUkkgU2ltcGxlIEZpbGwgU3ltYm9sXHJcbiAgICAgICAgICAgIGNvbnN0IHN5bWJvbENvbG91ciA9IHBhcnNlRXNyaUNvbG91cihzeW1ib2wuY29sb3IpO1xyXG4gICAgICAgICAgICBjb25zdCBzeW1ib2xTdHJva2UgPSBtYWtlU3Ryb2tlKHtcclxuICAgICAgICAgICAgICAgIGNvbG9yOiBzeW1ib2xDb2xvdXIuY29sb3VyLFxyXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogc3ltYm9sQ29sb3VyLm9wYWNpdHlcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHN5bWJvbEZpbGwgPSBlc3JpU0ZTRmlsbHNbc3ltYm9sLnN0eWxlXShzeW1ib2xDb2xvdXIsIHN5bWJvbFN0cm9rZSk7XHJcblxyXG4gICAgICAgICAgICBzeW1ib2wub3V0bGluZSA9IHN5bWJvbC5vdXRsaW5lIHx8IERFRkFVTFRfT1VUTElORTtcclxuICAgICAgICAgICAgY29uc3Qgb3V0bGluZUNvbG91ciA9IHBhcnNlRXNyaUNvbG91cihzeW1ib2wub3V0bGluZS5jb2xvcik7XHJcbiAgICAgICAgICAgIGNvbnN0IG91dGxpbmVTdHJva2UgPSBtYWtlU3Ryb2tlKHtcclxuICAgICAgICAgICAgICAgIGNvbG9yOiBvdXRsaW5lQ29sb3VyLmNvbG91cixcclxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IG91dGxpbmVDb2xvdXIub3BhY2l0eSxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBzeW1ib2wub3V0bGluZS53aWR0aCxcclxuICAgICAgICAgICAgICAgIGxpbmVjYXA6ICdidXR0JyxcclxuICAgICAgICAgICAgICAgIGRhc2hhcnJheTogRVNSSV9EQVNIX01BUFNbc3ltYm9sLm91dGxpbmUuc3R5bGVdXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgZHJhdy5yZWN0KENPTlRFTlRfU0laRSwgQ09OVEVOVF9TSVpFKVxyXG4gICAgICAgICAgICAgICAgLmNlbnRlcihDT05UQUlORVJfQ0VOVEVSLCBDT05UQUlORVJfQ0VOVEVSKVxyXG4gICAgICAgICAgICAgICAgLmZpbGwoc3ltYm9sRmlsbClcclxuICAgICAgICAgICAgICAgIC5zdHJva2Uob3V0bGluZVN0cm9rZSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZXNyaVRTKCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdubyBzdXBwb3J0IGZvciBmZWF0dXJlIHNlcnZpY2UgbGVnZW5kIG9mIHRleHQgc3ltYm9scycpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGVzcmlQRlMoKSB7IC8vIEVTUkkgUGljdHVyZSBGaWxsIFN5bWJvbFxyXG4gICAgICAgICAgICAvLyBpbWFnZVVyaSBjYW4gYmUganVzdCBhbiBpbWFnZSB1cmwgaXMgc3BlY2lmaWVkIG9yIGEgZGF0YVVyaSBzdHJpbmdcclxuICAgICAgICAgICAgY29uc3QgaW1hZ2VVcmkgPSBzeW1ib2wuaW1hZ2VEYXRhID8gYGRhdGE6JHtzeW1ib2wuY29udGVudFR5cGV9O2Jhc2U2NCwke3N5bWJvbC5pbWFnZURhdGF9YCA6IHN5bWJvbC51cmw7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBpbWFnZVdpZHRoID0gc3ltYm9sLndpZHRoICogc3ltYm9sLnhzY2FsZTtcclxuICAgICAgICAgICAgY29uc3QgaW1hZ2VIZWlnaHQgPSBzeW1ib2wuaGVpZ2h0ICogc3ltYm9sLnlzY2FsZTtcclxuXHJcbiAgICAgICAgICAgIHN5bWJvbC5vdXRsaW5lID0gc3ltYm9sLm91dGxpbmUgfHwgREVGQVVMVF9PVVRMSU5FO1xyXG4gICAgICAgICAgICBjb25zdCBvdXRsaW5lQ29sb3VyID0gcGFyc2VFc3JpQ29sb3VyKHN5bWJvbC5vdXRsaW5lLmNvbG9yKTtcclxuICAgICAgICAgICAgY29uc3Qgb3V0bGluZVN0cm9rZSA9IG1ha2VTdHJva2Uoe1xyXG4gICAgICAgICAgICAgICAgY29sb3I6IG91dGxpbmVDb2xvdXIuY29sb3VyLFxyXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogb3V0bGluZUNvbG91ci5vcGFjaXR5LFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IHN5bWJvbC5vdXRsaW5lLndpZHRoLFxyXG4gICAgICAgICAgICAgICAgZGFzaGFycmF5OiBFU1JJX0RBU0hfTUFQU1tzeW1ib2wub3V0bGluZS5zdHlsZV1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBwaWN0dXJlUHJvbWlzZSA9IHNoYXJlZC5jb252ZXJ0SW1hZ2V0b0RhdGFVUkwoaW1hZ2VVcmkpXHJcbiAgICAgICAgICAgICAgICAudGhlbihpbWFnZVVyaSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbWFrZSBhIGZpbGwgZnJvbSBhIHRpbGVkIGltYWdlXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3ltYm9sRmlsbCA9IGRyYXcucGF0dGVybihpbWFnZVdpZHRoLCBpbWFnZUhlaWdodCwgYWRkID0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZC5pbWFnZShpbWFnZVVyaSwgaW1hZ2VXaWR0aCwgaW1hZ2VIZWlnaHQsIHRydWUpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZHJhdy5yZWN0KENPTlRFTlRfU0laRSwgQ09OVEVOVF9TSVpFKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2VudGVyKENPTlRBSU5FUl9DRU5URVIsIENPTlRBSU5FUl9DRU5URVIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWxsKHN5bWJvbEZpbGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHJva2Uob3V0bGluZVN0cm9rZSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBwaWN0dXJlUHJvbWlzZTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBlc3JpUE1TKCkgeyAvLyBFU1JJIFBNUz8gUGljdHVyZSBNYXJrZXIgU3ltYm9sXHJcbiAgICAgICAgICAgIC8vIGltYWdlVXJpIGNhbiBiZSBqdXN0IGFuIGltYWdlIHVybCBpcyBzcGVjaWZpZWQgb3IgYSBkYXRhVXJpIHN0cmluZ1xyXG4gICAgICAgICAgICBjb25zdCBpbWFnZVVyaSA9IHN5bWJvbC5pbWFnZURhdGEgPyBgZGF0YToke3N5bWJvbC5jb250ZW50VHlwZX07YmFzZTY0LCR7c3ltYm9sLmltYWdlRGF0YX1gIDogc3ltYm9sLnVybDtcclxuXHJcbiAgICAgICAgICAgIC8vIG5lZWQgdG8gZHJhdyB0aGUgaW1hZ2UgdG8gZ2V0IGl0cyBzaXplICh0ZWNobmljYWxseSBub3QgbmVlZGVkIGlmIHdlIGhhdmUgYSB1cmwsIGJ1dCB0aGlzIGlzIHNpbXBsZXIpXHJcbiAgICAgICAgICAgIGNvbnN0IHBpY3R1cmVQcm9taXNlID0gc2hhcmVkLmNvbnZlcnRJbWFnZXRvRGF0YVVSTChpbWFnZVVyaSlcclxuICAgICAgICAgICAgICAgIC50aGVuKGltYWdlVXJpID0+XHJcbiAgICAgICAgICAgICAgICAgICAgc3ZnRHJhd0ltYWdlKGRyYXcsIGltYWdlVXJpKSlcclxuICAgICAgICAgICAgICAgIC50aGVuKCh7IGltYWdlIH0pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpbWFnZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2VudGVyKENPTlRBSU5FUl9DRU5URVIsIENPTlRBSU5FUl9DRU5URVIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yb3RhdGUoc3ltYm9sLmFuZ2xlIHx8IDApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBzY2FsZSBpbWFnZSB0byBmaXQgaW50byB0aGUgc3ltYm9sb2d5IGl0ZW0gY29udGFpbmVyXHJcbiAgICAgICAgICAgICAgICAgICAgZml0SW50byhpbWFnZSwgQ09OVEVOVF9JTUFHRV9TSVpFKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHBpY3R1cmVQcm9taXNlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy8ganNjczplbmFibGUgcmVxdWlyZVNwYWNlc0luQW5vbnltb3VzRnVuY3Rpb25FeHByZXNzaW9uXHJcblxyXG4gICAgLy8gY29uc29sZS5sb2coc3ltYm9sLnR5cGUsIGxhYmVsLCAnLS1TVEFSVC0tJyk7XHJcbiAgICAvLyBjb25zb2xlLmxvZyhzeW1ib2wpO1xyXG5cclxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc3ltYm9sVHlwZXNbc3ltYm9sLnR5cGVdKCkpXHJcbiAgICAgICAgLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhzeW1ib2wudHlwZSwgbGFiZWwsICctLURPTkUtLScpO1xyXG5cclxuICAgICAgICAgICAgLy8gcmVtb3ZlIGVsZW1lbnQgZnJvbSB0aGUgcGFnZVxyXG4gICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChjb250YWluZXIpO1xyXG4gICAgICAgICAgICByZXR1cm4geyBsYWJlbCwgc3ZnY29kZTogZHJhdy5zdmcoKSB9O1xyXG4gICAgICAgIH0pLmNhdGNoKGVycm9yID0+IGNvbnNvbGUubG9nKGVycm9yKSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgc3Ryb2tlIHN0eWxlIGJ5IGFwcGx5aW5nIGN1c3RvbSBydWxlcyB0byB0aGUgZGVmYXVsdCBzdHJva2UuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3ZlcnJpZGVzIGFueSBjdXN0b20gcnVsZXMgdG8gYXBwbHkgb24gdG9wIG9mIHRoZSBkZWZhdWx0c1xyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBhIHN0cm9rZSBvYmplY3RcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIG1ha2VTdHJva2Uob3ZlcnJpZGVzKSB7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfU1RST0tFLCBvdmVycmlkZXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBDb252ZXJ0IGFuIEVTUkkgY29sb3VyIG9iamVjdCB0byBTVkcgcmdiIGZvcm1hdC5cclxuICAgICogQHByaXZhdGVcclxuICAgICogQHBhcmFtICB7QXJyYXl9IGMgRVNSSSBDb2xvdXIgYXJyYXlcclxuICAgICogQHJldHVybiB7T2JqZWN0fSBjb2xvdXIgYW5kIG9wYWNpdHkgaW4gU1ZHIGZvcm1hdFxyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIHBhcnNlRXNyaUNvbG91cihjKSB7XHJcbiAgICAgICAgaWYgKGMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGNvbG91cjogYHJnYigke2NbMF19LCR7Y1sxXX0sJHtjWzJdfSlgLFxyXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogY1szXSAvIDI1NVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBjb2xvdXI6ICdyZ2IoMCwgMCwgMCknLFxyXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFJlbmRlcnMgYSBzcGVjaWZpZWQgaW1hZ2Ugb24gYW4gc3ZnIGVsZW1lbnQuIFRoaXMgaXMgYSBoZWxwZXIgZnVuY3Rpb24gdGhhdCB3cmFwcyBhcm91bmQgYXN5bmMgYGRyYXcuaW1hZ2VgIGNhbGwgaW4gdGhlIHN2ZyBsaWJyYXJ5LlxyXG4gKlxyXG4gKiBAZnVuY3Rpb24gc3ZnRHJhd0ltYWdlXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBkcmF3IHN2ZyBlbGVtZW50IHRvIHJlbmRlciB0aGUgaW1hZ2Ugb250b1xyXG4gKiBAcGFyYW0ge1N0cmluZ30gaW1hZ2VVcmkgaW1hZ2UgdXJsIG9yIGRhdGFVUkwgb2YgdGhlIGltYWdlIHRvIHJlbmRlclxyXG4gKiBAcGFyYW0ge051bWJlcn0gd2lkdGggW29wdGlvbmFsID0gMF0gd2lkdGggb2YgdGhlIGltYWdlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgW29wdGlvbmFsID0gMF0gaGVpZ2h0IG9mIHRoZSBpbWFnZVxyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGNyb3NzT3JpZ2luIFtvcHRpb25hbCA9IHRydWVdIHNwZWNpZmllcyBpZiB0aGUgaW1hZ2Ugc2hvdWxkIGJlIGxvYWRlZCBhcyBjcm9zc09yaWdpblxyXG4gKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHJlc29sdmluZyB3aXRoIHRoZSBsb2FkZWQgaW1hZ2UgYW5kIGl0cyBsb2FkZXIgb2JqZWN0IChzZWUgc3ZnLmpzIGh0dHA6Ly9kb2N1bWVudHVwLmNvbS93b3V0L3N2Zy5qcyNpbWFnZSBmb3IgZGV0YWlscylcclxuICovXHJcbmZ1bmN0aW9uIHN2Z0RyYXdJbWFnZShkcmF3LCBpbWFnZVVyaSwgd2lkdGggPSAwLCBoZWlnaHQgPSAwLCBjcm9zc09yaWdpbiA9IHRydWUpIHtcclxuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgY29uc3QgaW1hZ2UgPSBkcmF3LmltYWdlKGltYWdlVXJpLCB3aWR0aCwgaGVpZ2h0LCBjcm9zc09yaWdpbilcclxuICAgICAgICAgICAgLmxvYWRlZChsb2FkZXIgPT5cclxuICAgICAgICAgICAgICAgIHJlc29sdmUoeyBpbWFnZSwgbG9hZGVyIH0pKVxyXG4gICAgICAgICAgICAuZXJyb3IoZXJyID0+IHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBwcm9taXNlO1xyXG59XHJcblxyXG4vKipcclxuICogRml0cyBzdmcgZWxlbWVudCBpbiB0aGUgc2l6ZSBzcGVjaWZpZWRcclxuICogQHBhcmFtIHtPamJlY3R9IGVsZW1lbnQgc3ZnIGVsZW1lbnQgdG8gZml0XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBDT05UQUlORVJfU0laRSB3aWR0aC9oZWlnaHQgb2YgYSBjb250YWluZXIgdG8gZml0IHRoZSBlbGVtZW50IGludG9cclxuICovXHJcbmZ1bmN0aW9uIGZpdEludG8oZWxlbWVudCwgQ09OVEFJTkVSX1NJWkUpIHtcclxuICAgIC8vIGNvbnN0IGVsZW1lbnRSYm94ID0gZWxlbWVudC5yYm94KCk7XHJcbiAgICAvLyBjb25zdCBlbGVtZW50UmJveCA9IGVsZW1lbnQuc2NyZWVuQkJveCgpO1xyXG5cclxuICAgIGNvbnN0IGVsZW1lbnRSYm94ID0gZWxlbWVudC5ub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOyAvLyBtYXJrZXIucmJveCgpOyAvL3Jib3ggZG9lc24ndCB3b3JrIHByb3Blcmx5IGluIENocm9tZSBmb3Igc29tZSByZWFzb25cclxuICAgIGNvbnN0IHNjYWxlID0gQ09OVEFJTkVSX1NJWkUgLyBNYXRoLm1heChlbGVtZW50UmJveC53aWR0aCwgZWxlbWVudFJib3guaGVpZ2h0KTtcclxuICAgIGlmIChzY2FsZSA8IDEpIHtcclxuICAgICAgICBlbGVtZW50LnNjYWxlKHNjYWxlKTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiogR2VuZXJhdGUgYW4gYXJyYXkgb2YgbGVnZW5kIGl0ZW1zIGZvciBhbiBFU1JJIHVuaXF1ZSB2YWx1ZSBvciBjbGFzcyBicmVha3MgcmVuZGVyZXIuXHJcbiogQHByaXZhdGVcclxuKiBAcGFyYW0gIHtPYmplY3R9IHJlbmRlcmVyIGFuIEVTUkkgdW5pcXVlIHZhbHVlIG9yIGNsYXNzIGJyZWFrcyByZW5kZXJlclxyXG4qIEBwYXJhbSAge0FycmF5fSBjaGlsZExpc3QgYXJyYXkgb2YgY2hpbGRyZW4gaXRlbXMgb2YgdGhlIHJlbmRlcmVyXHJcbiogQHBhcmFtICB7T2JqZWN0fSB3aW5kb3cgcmVmZXJlbmNlIHRvIHRoZSBicm93c2VyIHdpbmRvd1xyXG4qIEByZXR1cm4ge0FycmF5fSBhIGxlZ2VuZCBvYmplY3QgcG9wdWxhdGVkIHdpdGggdGhlIHN5bWJvbCBhbmQgbGFiZWxcclxuKi9cclxuZnVuY3Rpb24gc2NyYXBlTGlzdFJlbmRlcmVyKHJlbmRlcmVyLCBjaGlsZExpc3QsIHdpbmRvdykge1xyXG4gICAgY29uc3QgbGVnZW5kID0gY2hpbGRMaXN0Lm1hcChjaGlsZCA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHN5bWJvbFRvTGVnZW5kKGNoaWxkLnN5bWJvbCwgY2hpbGQubGFiZWwsIHdpbmRvdyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAocmVuZGVyZXIuZGVmYXVsdFN5bWJvbCkge1xyXG4gICAgICAgIC8vIGNsYXNzIGJyZWFrcyBkb250IGhhdmUgZGVmYXVsdCBsYWJlbFxyXG4gICAgICAgIC8vIFRPRE8gcGVyaGFwcyBwdXQgaW4gYSBkZWZhdWx0IG9mIFwiT3RoZXJcIiwgd291bGQgbmVlZCB0byBiZSBpbiBwcm9wZXIgbGFuZ3VhZ2VcclxuICAgICAgICBsZWdlbmQucHVzaChzeW1ib2xUb0xlZ2VuZChyZW5kZXJlci5kZWZhdWx0U3ltYm9sLCByZW5kZXJlci5kZWZhdWx0TGFiZWwgfHwgJycsIHdpbmRvdykpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBsZWdlbmQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGJ1aWxkUmVuZGVyZXJUb0xlZ2VuZCh3aW5kb3cpIHtcclxuICAgIC8qKlxyXG4gICAgKiBHZW5lcmF0ZSBhIGxlZ2VuZCBvYmplY3QgYmFzZWQgb24gYW4gRVNSSSByZW5kZXJlci5cclxuICAgICogQHByaXZhdGVcclxuICAgICogQHBhcmFtICB7T2JqZWN0fSByZW5kZXJlciBhbiBFU1JJIHJlbmRlcmVyIG9iamVjdCBpbiBzZXJ2ZXIgSlNPTiBmb3JtXHJcbiAgICAqIEBwYXJhbSAge0ludGVnZXJ9IGluZGV4IHRoZSBsYXllciBpbmRleCBvZiB0aGlzIHJlbmRlcmVyXHJcbiAgICAqIEByZXR1cm4ge09iamVjdH0gYW4gb2JqZWN0IG1hdGNoaW5nIHRoZSBmb3JtIG9mIGFuIEVTUkkgUkVTVCBBUEkgbGVnZW5kXHJcbiAgICAqL1xyXG4gICAgcmV0dXJuIChyZW5kZXJlciwgaW5kZXgpID0+IHtcclxuICAgICAgICAvLyBtYWtlIGJhc2ljIHNoZWxsIG9iamVjdCB3aXRoIC5sYXllcnMgYXJyYXlcclxuICAgICAgICBjb25zdCBsZWdlbmQgPSB7XHJcbiAgICAgICAgICAgIGxheWVyczogW3tcclxuICAgICAgICAgICAgICAgIGxheWVySWQ6IGluZGV4LFxyXG4gICAgICAgICAgICAgICAgbGVnZW5kOiBbXVxyXG4gICAgICAgICAgICB9XVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHN3aXRjaCAocmVuZGVyZXIudHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIFNJTVBMRTpcclxuICAgICAgICAgICAgICAgIGxlZ2VuZC5sYXllcnNbMF0ubGVnZW5kLnB1c2goc3ltYm9sVG9MZWdlbmQocmVuZGVyZXIuc3ltYm9sLCByZW5kZXJlci5sYWJlbCwgd2luZG93KSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgVU5JUVVFX1ZBTFVFOlxyXG4gICAgICAgICAgICAgICAgbGVnZW5kLmxheWVyc1swXS5sZWdlbmQgPSBzY3JhcGVMaXN0UmVuZGVyZXIocmVuZGVyZXIsIHJlbmRlcmVyLnVuaXF1ZVZhbHVlSW5mb3MsIHdpbmRvdyk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgQ0xBU1NfQlJFQUtTOlxyXG4gICAgICAgICAgICAgICAgbGVnZW5kLmxheWVyc1swXS5sZWdlbmQgPSBzY3JhcGVMaXN0UmVuZGVyZXIocmVuZGVyZXIsIHJlbmRlcmVyLmNsYXNzQnJlYWtJbmZvcywgd2luZG93KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBGSVhNRSBtYWtlIGEgYmFzaWMgYmxhbmsgZW50cnkgKGVycm9yIG1zZyBhcyBsYWJlbD8pIHRvIHByZXZlbnQgdGhpbmdzIGZyb20gYnJlYWtpbmdcclxuICAgICAgICAgICAgICAgIC8vIFJlbmRlcmVyIHdlIGRvbnQgc3VwcG9ydFxyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignZW5jb3VudGVyZWQgdW5zdXBwb3J0ZWQgcmVuZGVyZXIgbGVnZW5kIHR5cGU6ICcgKyByZW5kZXJlci50eXBlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGxlZ2VuZDtcclxuICAgIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBsZWdlbmQgaW5mb3JtYXRpb24gb2YgYW4gRVNSSSBtYXAgc2VydmljZS5cclxuICpcclxuICogQGZ1bmN0aW9uIGdldE1hcFNlcnZlckxlZ2VuZFxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGxheWVyVXJsIHNlcnZpY2UgdXJsIChyb290IHNlcnZpY2UsIG5vdCBpbmRleGVkIGVuZHBvaW50KVxyXG4gKiBAcGFyYW0gIHtPYmplY3R9IGVzcmlCdW5kbGUgY29sbGVjdGlvbiBvZiBFU1JJIEFQSSBvYmplY3RzXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlfSByZXNvbHZlcyBpbiBhbiBhcnJheSBvZiBsZWdlbmQgZGF0YVxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0TWFwU2VydmVyTGVnZW5kKGxheWVyVXJsLCBlc3JpQnVuZGxlKSB7XHJcblxyXG4gICAgLy8gc3RhbmRhcmQganNvbiByZXF1ZXN0IHdpdGggZXJyb3IgY2hlY2tpbmdcclxuICAgIGNvbnN0IGRlZlNlcnZpY2UgPSBlc3JpQnVuZGxlLmVzcmlSZXF1ZXN0KHtcclxuICAgICAgICB1cmw6IGAke2xheWVyVXJsfS9sZWdlbmRgLFxyXG4gICAgICAgIGNvbnRlbnQ6IHsgZjogJ2pzb24nIH0sXHJcbiAgICAgICAgY2FsbGJhY2tQYXJhbU5hbWU6ICdjYWxsYmFjaycsXHJcbiAgICAgICAgaGFuZGxlQXM6ICdqc29uJyxcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIHdyYXAgaW4gcHJvbWlzZSB0byBjb250YWluIGRvam8gZGVmZXJyZWRcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgZGVmU2VydmljZS50aGVuKHNydlJlc3VsdCA9PiB7XHJcblxyXG4gICAgICAgICAgICBpZiAoc3J2UmVzdWx0LmVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICByZWplY3Qoc3J2UmVzdWx0LmVycm9yKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoc3J2UmVzdWx0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIGVycm9yID0+IHtcclxuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxufVxyXG5cclxuLyoqXHJcbiAqIE91ciBzeW1ib2xvZ3kgZW5naW5lIHdvcmtzIG9mZiBvZiByZW5kZXJlcnMuIFdoZW4gZGVhbGluZyB3aXRoIGxheWVycyB3aXRoIG5vIHJlbmRlcmVycyxcclxuICogd2UgbmVlZCB0byB0YWtlIHNlcnZlci1zaWRlIGxlZ2VuZCBhbmQgY29udmVydCBpdCB0byBhIGZha2UgcmVuZGVyZXIsIHdoaWNoIGxldHMgdXNcclxuICogbGV2ZXJhZ2UgYWxsIHRoZSBleGlzdGluZyBzeW1ib2xvZ3kgY29kZS5cclxuICpcclxuICogQGZ1bmN0aW9uIG1hcFNlcnZlckxlZ2VuZFRvUmVuZGVyZXJcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtPYmplY3R9IHNlcnZlckxlZ2VuZCBsZWdlbmQganNvbiBmcm9tIGFuIGVzcmkgbWFwIHNlcnZlclxyXG4gKiBAcGFyYW0ge0ludGVnZXJ9IGxheWVySW5kZXggIHRoZSBpbmRleCBvZiB0aGUgbGF5ZXIgaW4gdGhlIGxlZ2VuZCB3ZSBhcmUgaW50ZXJlc3RlZCBpblxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBhIGZha2UgdW5pcXVlIHZhbHVlIHJlbmRlcmVyIGJhc2VkIG9mZiB0aGUgbGVnZW5kXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBtYXBTZXJ2ZXJMZWdlbmRUb1JlbmRlcmVyKHNlcnZlckxlZ2VuZCwgbGF5ZXJJbmRleCkge1xyXG4gICAgY29uc3QgbGF5ZXJMZWdlbmQgPSBzZXJ2ZXJMZWdlbmQubGF5ZXJzLmZpbmQobCA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGwubGF5ZXJJZCA9PT0gbGF5ZXJJbmRleDtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIG1ha2UgdGhlIG1vY2sgcmVuZGVyZXJcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogJ3VuaXF1ZVZhbHVlJyxcclxuICAgICAgICB1bmlxdWVWYWx1ZUluZm9zOiBsYXllckxlZ2VuZC5sZWdlbmQubWFwKGxsID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGxhYmVsOiBsbC5sYWJlbCxcclxuICAgICAgICAgICAgICAgIHN5bWJvbDoge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdlc3JpUE1TJyxcclxuICAgICAgICAgICAgICAgICAgICBpbWFnZURhdGE6IGxsLmltYWdlRGF0YSxcclxuICAgICAgICAgICAgICAgICAgICBjb250ZW50VHlwZTogbGwuY29udGVudFR5cGVcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KVxyXG4gICAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAgKiBPdXIgc3ltYm9sb2d5IGVuZ2luZSB3b3JrcyBvZmYgb2YgcmVuZGVyZXJzLiBXaGVuIGRlYWxpbmcgd2l0aCBsYXllcnMgd2l0aCBubyByZW5kZXJlcnMsXHJcbiAgKiB3ZSBuZWVkIHRvIHRha2Ugc2VydmVyLXNpZGUgbGVnZW5kIGFuZCBjb252ZXJ0IGl0IHRvIGEgZmFrZSByZW5kZXJlciwgd2hpY2ggbGV0cyB1c1xyXG4gICogbGV2ZXJhZ2UgYWxsIHRoZSBleGlzdGluZyBzeW1ib2xvZ3kgY29kZS5cclxuICAqXHJcbiAgKiBTYW1lIGFzIG1hcFNlcnZlckxlZ2VuZFRvUmVuZGVyZXIgZnVuY3Rpb24gYnV0IGNvbWJpbmVzIGFsbCBsYXllciByZW5kZXJlcnMuXHJcbiAgKlxyXG4gICogQGZ1bmN0aW9uIG1hcFNlcnZlckxlZ2VuZFRvUmVuZGVyZXJBbGxcclxuICAqIEBwcml2YXRlXHJcbiAgKiBAcGFyYW0ge09iamVjdH0gc2VydmVyTGVnZW5kIGxlZ2VuZCBqc29uIGZyb20gYW4gZXNyaSBtYXAgc2VydmVyXHJcbiAgKiBAcmV0dXJucyB7T2JqZWN0fSBhIGZha2UgdW5pcXVlIHZhbHVlIHJlbmRlcmVyIGJhc2VkIG9mZiB0aGUgbGVnZW5kXHJcbiAgKi9cclxuXHJcbmZ1bmN0aW9uIG1hcFNlcnZlckxlZ2VuZFRvUmVuZGVyZXJBbGwoc2VydmVyTGVnZW5kKSB7XHJcblxyXG4gICAgY29uc3QgbGF5ZXJSZW5kZXJzID0gc2VydmVyTGVnZW5kLmxheWVycy5tYXAobGF5ZXIgPT5cclxuICAgICAgICBsYXllci5sZWdlbmQubWFwKGxheWVyTGVnZW5kID0+ICh7XHJcbiAgICAgICAgICAgIGxhYmVsOiBsYXllckxlZ2VuZC5sYWJlbCxcclxuICAgICAgICAgICAgc3ltYm9sOiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnZXNyaVBNUycsXHJcbiAgICAgICAgICAgICAgICBpbWFnZURhdGE6IGxheWVyTGVnZW5kLmltYWdlRGF0YSxcclxuICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBsYXllckxlZ2VuZC5jb250ZW50VHlwZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSkpXHJcbiAgICApO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogJ3VuaXF1ZVZhbHVlJyxcclxuICAgICAgICB1bmlxdWVWYWx1ZUluZm9zOiBbXS5jb25jYXQoLi4ubGF5ZXJSZW5kZXJzKVxyXG4gICAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gYnVpbGRNYXBTZXJ2ZXJUb0xvY2FsTGVnZW5kKGVzcmlCdW5kbGUsIGdlb0FwaSkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBPcmNoZXN0cmF0b3IgZnVuY3Rpb24gdGhhdCB3aWxsOlxyXG4gICAgICogLSBGZXRjaCBhIGxlZ2VuZCBmcm9tIGFuIGVzcmkgbWFwIHNlcnZlclxyXG4gICAgICogLSBFeHRyYWN0IGxlZ2VuZCBmb3IgYSBzcGVjaWZpYyBzdWIgbGF5ZXJcclxuICAgICAqIC0gQ29udmVydCBzZXJ2ZXIgbGVnZW5kIHRvIGEgdGVtcG9yYXJ5IHJlbmRlcmVyXHJcbiAgICAgKiAtIENvbnZlcnQgdGVtcG9yYXJ5IHJlbmRlcmVyIHRvIGEgdmlld2VyLWZvcm1hdHRlZCBsZWdlbmQgKHJldHVybiB2YWx1ZSlcclxuICAgICAqXHJcbiAgICAgKiBAZnVuY3Rpb24gbWFwU2VydmVyVG9Mb2NhbExlZ2VuZFxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICAgIG1hcFNlcnZlclVybCAgc2VydmljZSB1cmwgKHJvb3Qgc2VydmljZSwgbm90IGluZGV4ZWQgZW5kcG9pbnQpXHJcbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9ICAgW2xheWVySW5kZXhdICB0aGUgaW5kZXggb2YgdGhlIGxheWVyIGluIHRoZSBsZWdlbmQgd2UgYXJlIGludGVyZXN0ZWQgaW4uIElmIG5vdCBwcm92aWRlZCwgYWxsIGxheWVycyB3aWxsIGJlIGNvbGxhcHNlZCBpbnRvIGEgc2luZ2xlIGxlZ2VuZFxyXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IHJlc29sdmVzIGluIGEgdmlld2VyLWNvbXBhdGlibGUgbGVnZW5kIGZvciB0aGUgZ2l2ZW4gc2VydmVyIGFuZCBsYXllciBpbmRleFxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgcmV0dXJuIChtYXBTZXJ2ZXJVcmwsIGxheWVySW5kZXgpID0+IHtcclxuICAgICAgICAvLyBnZXQgZXNyaSBsZWdlbmQgZnJvbSBzZXJ2ZXJcclxuXHJcbiAgICAgICAgcmV0dXJuIGdldE1hcFNlcnZlckxlZ2VuZChtYXBTZXJ2ZXJVcmwsIGVzcmlCdW5kbGUpLnRoZW4oc2VydmVyTGVnZW5kRGF0YSA9PiB7XHJcbiAgICAgICAgICAgIC8vIGRlcml2ZSByZW5kZXJlciBmb3Igc3BlY2lmaWVkIGxheWVyXHJcbiAgICAgICAgICAgIGxldCBmYWtlUmVuZGVyZXI7XHJcbiAgICAgICAgICAgIGxldCBpbnRJbmRleDtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBsYXllckluZGV4ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgaW50SW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgZmFrZVJlbmRlcmVyID0gbWFwU2VydmVyTGVnZW5kVG9SZW5kZXJlckFsbChzZXJ2ZXJMZWdlbmREYXRhKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGludEluZGV4ID0gcGFyc2VJbnQobGF5ZXJJbmRleCk7IC8vIHNvbWV0aW1lcyBhIHN0cmluZ2lmaWVkIHZhbHVlIGNvbWVzIGluLiBjYXJlZnVsIG5vdy5cclxuICAgICAgICAgICAgICAgIGZha2VSZW5kZXJlciA9IG1hcFNlcnZlckxlZ2VuZFRvUmVuZGVyZXIoc2VydmVyTGVnZW5kRGF0YSwgaW50SW5kZXgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBjb252ZXJ0IHJlbmRlcmVyIHRvIHZpZXdlciBzcGVjaWZpYyBsZWdlbmRcclxuICAgICAgICAgICAgcmV0dXJuIGdlb0FwaS5zeW1ib2xvZ3kucmVuZGVyZXJUb0xlZ2VuZChmYWtlUmVuZGVyZXIsIGludEluZGV4KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbn1cclxuXHJcbi8vIFRPRE8gZ2V0Wm9vbUxldmVsIHNob3VsZCBwcm9iYWJseSBsaXZlIGluIGEgZmlsZSBub3QgbmFtZWQgc3ltYm9sb2d5XHJcbi8qKlxyXG4qIFRha2VzIHRoZSBsb2QgbGlzdCBhbmQgZmluZHMgbGV2ZWwgYXMgY2xvc2UgdG8gYW5kIGFib3ZlIHNjYWxlIGxpbWl0XHJcbipcclxuKiBAcGFyYW0ge0FycmF5fSBsb2RzIGFycmF5IG9mIGVzcmkgTE9EcyBodHRwczovL2RldmVsb3BlcnMuYXJjZ2lzLmNvbS9qYXZhc2NyaXB0L2pzYXBpL2xvZC1hbWQuaHRtbFxyXG4qIEBwYXJhbSB7SW50ZWdlcn0gbWF4U2NhbGUgb2JqZWN0IGxhcmdlc3Qgem9vbSBsZXZlbCBmb3Igc2FpZCBsYXllclxyXG4qIEByZXR1cm5zIHtOdW1iZXJ9IGN1cnJlbnQgTE9EXHJcbiovXHJcbmZ1bmN0aW9uIGdldFpvb21MZXZlbChsb2RzLCBtYXhTY2FsZSkge1xyXG4gICAgLy8gRmluZCBsZXZlbCBhcyBjbG9zZSB0byBhbmQgYWJvdmUgc2NhbGVMaW1pdFxyXG4gICAgY29uc3Qgc2NhbGVMaW1pdCA9IG1heFNjYWxlOyAvLyBtYXhTY2FsZSBvYmogaW4gcmV0dXJuZWQgY29uZmlnXHJcbiAgICBsZXQgZm91bmQgPSBmYWxzZTtcclxuICAgIGxldCBjdXJyZW50TG9kID0gTWF0aC5jZWlsKGxvZHMubGVuZ3RoIC8gMik7XHJcbiAgICBsZXQgbG93TG9kID0gMDtcclxuICAgIGxldCBoaWdoTG9kID0gbG9kcy5sZW5ndGggLSAxO1xyXG5cclxuICAgIGlmIChtYXhTY2FsZSA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBsb2RzLmxlbmd0aCAtIDE7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQmluYXJ5IFNlYXJjaFxyXG4gICAgd2hpbGUgKCFmb3VuZCkge1xyXG4gICAgICAgIGlmIChsb2RzW2N1cnJlbnRMb2RdLnNjYWxlID49IHNjYWxlTGltaXQpIHtcclxuICAgICAgICAgICAgbG93TG9kID0gY3VycmVudExvZDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBoaWdoTG9kID0gY3VycmVudExvZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3VycmVudExvZCA9IE1hdGguZmxvb3IoKGhpZ2hMb2QgKyBsb3dMb2QpIC8gMik7XHJcbiAgICAgICAgaWYgKGhpZ2hMb2QgPT09IGxvd0xvZCArIDEpIHtcclxuICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBjdXJyZW50TG9kO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IChlc3JpQnVuZGxlLCBnZW9BcGksIHdpbmRvdykgPT4ge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBnZXRHcmFwaGljSWNvbixcclxuICAgICAgICBnZXRHcmFwaGljU3ltYm9sLFxyXG4gICAgICAgIHJlbmRlcmVyVG9MZWdlbmQ6IGJ1aWxkUmVuZGVyZXJUb0xlZ2VuZCh3aW5kb3cpLFxyXG4gICAgICAgIGdlbmVyYXRlUGxhY2Vob2xkZXJTeW1ib2xvZ3ksXHJcbiAgICAgICAgZ2VuZXJhdGVXTVNTeW1ib2xvZ3ksXHJcblxyXG4gICAgICAgIGxpc3RUb0ljb25TeW1ib2xvZ3k6IGxpc3QgPT4gX2xpc3RUb1N5bWJvbG9neShyZW5kZXJTeW1ib2xvZ3lJY29uLCBsaXN0KSxcclxuICAgICAgICBsaXN0VG9JbWFnZVN5bWJvbG9neTogbGlzdCA9PiBfbGlzdFRvU3ltYm9sb2d5KHJlbmRlclN5bWJvbG9neUltYWdlLCBsaXN0KSxcclxuXHJcbiAgICAgICAgZ2V0Wm9vbUxldmVsLFxyXG4gICAgICAgIGVuaGFuY2VSZW5kZXJlcixcclxuICAgICAgICBtYXBTZXJ2ZXJUb0xvY2FsTGVnZW5kOiBidWlsZE1hcFNlcnZlclRvTG9jYWxMZWdlbmQoZXNyaUJ1bmRsZSwgZ2VvQXBpKVxyXG4gICAgfTtcclxufTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3N5bWJvbG9neS5qcyJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar attribute = __webpack_require__(71);\nvar events = __webpack_require__(72);\nvar hilight = __webpack_require__(73);\nvar layer = __webpack_require__(74);\nvar legend = __webpack_require__(75);\nvar esriMap = __webpack_require__(76);\nvar proj = __webpack_require__(77);\nvar query = __webpack_require__(78);\nvar shared = __webpack_require__(23);\nvar symbology = __webpack_require__(79);\n\nfunction initAll(esriBundle, window) {\n    var debug = false;\n    var api = {};\n\n    api.layer = layer(esriBundle, api);\n    api.legend = legend();\n    api.proj = proj(esriBundle);\n    api.Map = esriMap(esriBundle, api);\n    api.attribs = attribute(esriBundle, api);\n    api.symbology = symbology(esriBundle, api, window);\n    api.hilight = hilight(esriBundle, api);\n    api.events = events();\n    api.query = query(esriBundle);\n    api.shared = shared(esriBundle);\n    api.debug = function () {\n        if (arguments.length === 1) {\n            debug = arguments[0] === true;\n        }\n\n        return debug;\n    };\n    api.esriBundle = function () {\n        if (debug) {\n            return esriBundle;\n        }\n        throw new Error('Must set debug to directly access the bundle');\n    };\n\n    return api;\n}\n\nmodule.exports = function (esriLoaderUrl, window) {\n\n    // esriDeps is an array pairing ESRI JSAPI dependencies with their imported names\n    // in esriBundle\n    var esriDeps = [['dojo/Deferred', 'Deferred'], ['dojo/query', 'dojoQuery'], ['esri/Color', 'Color'], ['esri/config', 'esriConfig'], ['esri/dijit/Basemap', 'Basemap'], ['esri/dijit/BasemapGallery', 'BasemapGallery'], ['esri/dijit/BasemapLayer', 'BasemapLayer'], ['esri/dijit/OverviewMap', 'OverviewMap'], ['esri/dijit/Scalebar', 'Scalebar'], ['esri/geometry/Extent', 'Extent'], ['esri/geometry/Point', 'Point'], ['esri/geometry/ScreenPoint', 'ScreenPoint'], ['esri/graphic', 'Graphic'], ['esri/graphicsUtils', 'graphicsUtils'], ['esri/layers/ArcGISDynamicMapServiceLayer', 'ArcGISDynamicMapServiceLayer'], ['esri/layers/ArcGISImageServiceLayer', 'ArcGISImageServiceLayer'], ['esri/layers/ArcGISTiledMapServiceLayer', 'ArcGISTiledMapServiceLayer'], ['esri/layers/FeatureLayer', 'FeatureLayer'], ['esri/layers/GraphicsLayer', 'GraphicsLayer'], ['esri/layers/LayerDrawingOptions', 'LayerDrawingOptions'], ['esri/layers/WMSLayer', 'WmsLayer'], ['esri/map', 'Map'], ['esri/request', 'esriRequest'], ['esri/SpatialReference', 'SpatialReference'], ['esri/symbols/jsonUtils', 'symbolJsonUtils'], ['esri/tasks/GeometryService', 'GeometryService'], ['esri/tasks/IdentifyParameters', 'IdentifyParameters'], ['esri/tasks/IdentifyTask', 'IdentifyTask'], ['esri/tasks/ProjectParameters', 'ProjectParameters'], ['esri/tasks/query', 'Query'], ['esri/tasks/QueryTask', 'QueryTask'], ['esri/tasks/PrintParameters', 'PrintParameters'], ['esri/tasks/PrintTask', 'PrintTask'], ['esri/tasks/PrintTemplate', 'PrintTemplate']];\n\n    function makeDojoRequests() {\n        return new Promise(function (resolve, reject) {\n\n            // NOTE: do not change the callback to an arrow function since we don't know if\n            // Dojo's require has any expectations of the scope within that function or\n            // does any odd metaprogramming\n            window.require(esriDeps.map(function (deps) {\n                return deps[0];\n            }), function () {\n                var esriBundle = {};\n\n                // iterate over arguments to avoid creating an ugly giant function call\n                // arguments is not an array so we do this the hard way\n                for (var i = 0; i < arguments.length; ++i) {\n                    esriBundle[esriDeps[i][1]] = arguments[i];\n                }\n                resolve(esriBundle);\n            });\n            window.require.on('error', reject);\n        });\n    }\n\n    // the startup for this module is:\n    // 1. add a script tag to load the API (this typically points to a custom ESRI build)\n    // 2. load all the ESRI and Dojo dependencies `makeDojoRequests()`\n    // 3. initialize all of our modules\n    // everything is done in an async model and the result is a promise which resolves to\n    // a reference to our API\n    return new Promise(function (resolve, reject) {\n        if (window.require) {\n            console.warn('window.require has been set, ' + 'attempting to reuse existing loader with no new script tag created');\n            resolve();\n            return;\n        }\n\n        var oScript = window.document.createElement('script');\n        var oHead = window.document.head || window.document.getElementsByTagName('head')[0];\n\n        oScript.type = 'text\\/javascript';\n        oScript.onerror = function (err) {\n            return reject(err);\n        };\n        oScript.onload = function () {\n            return resolve();\n        };\n        oHead.appendChild(oScript);\n        oScript.src = esriLoaderUrl; // '//ec.cloudapp.net/~aly/esri/dojo/dojo.js';\n        console.log('made a promise');\n    }).then(makeDojoRequests).then(function (esriBundle) {\n        return initAll(esriBundle, window);\n    });\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanM/OTU1MiJdLCJuYW1lcyI6WyJhdHRyaWJ1dGUiLCJyZXF1aXJlIiwiZXZlbnRzIiwiaGlsaWdodCIsImxheWVyIiwibGVnZW5kIiwiZXNyaU1hcCIsInByb2oiLCJxdWVyeSIsInNoYXJlZCIsInN5bWJvbG9neSIsImluaXRBbGwiLCJlc3JpQnVuZGxlIiwid2luZG93IiwiZGVidWciLCJhcGkiLCJNYXAiLCJhdHRyaWJzIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiRXJyb3IiLCJtb2R1bGUiLCJleHBvcnRzIiwiZXNyaUxvYWRlclVybCIsImVzcmlEZXBzIiwibWFrZURvam9SZXF1ZXN0cyIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwibWFwIiwiZGVwcyIsImkiLCJvbiIsImNvbnNvbGUiLCJ3YXJuIiwib1NjcmlwdCIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsIm9IZWFkIiwiaGVhZCIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwidHlwZSIsIm9uZXJyb3IiLCJlcnIiLCJvbmxvYWQiLCJhcHBlbmRDaGlsZCIsInNyYyIsImxvZyIsInRoZW4iXSwibWFwcGluZ3MiOiJBQUFBOztBQUNBLElBQU1BLFlBQVksbUJBQUFDLENBQVEsRUFBUixDQUFsQjtBQUNBLElBQU1DLFNBQVMsbUJBQUFELENBQVEsRUFBUixDQUFmO0FBQ0EsSUFBTUUsVUFBVSxtQkFBQUYsQ0FBUSxFQUFSLENBQWhCO0FBQ0EsSUFBTUcsUUFBUSxtQkFBQUgsQ0FBUSxFQUFSLENBQWQ7QUFDQSxJQUFNSSxTQUFTLG1CQUFBSixDQUFRLEVBQVIsQ0FBZjtBQUNBLElBQU1LLFVBQVUsbUJBQUFMLENBQVEsRUFBUixDQUFoQjtBQUNBLElBQU1NLE9BQU8sbUJBQUFOLENBQVEsRUFBUixDQUFiO0FBQ0EsSUFBTU8sUUFBUSxtQkFBQVAsQ0FBUSxFQUFSLENBQWQ7QUFDQSxJQUFNUSxTQUFTLG1CQUFBUixDQUFRLEVBQVIsQ0FBZjtB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QUFDaEJnQyxvQkFBUUMsSUFBUixDQUFhLGtDQUNULG9FQURKO0FBRUFQO0FBQ0E7QUFDSDs7QUFFRCxZQUFNUSxVQUFVdEIsT0FBT3VCLFFBQVAsQ0FBZ0JDLGFBQWhCLENBQThCLFFBQTlCLENBQWhCO0FBQ0EsWUFBTUMsUUFBUXpCLE9BQU91QixRQUFQLENBQWdCRyxJQUFoQixJQUF3QjFCLE9BQU91QixRQUFQLENBQWdCSSxvQkFBaEIsQ0FBcUMsTUFBckMsRUFBNkMsQ0FBN0MsQ0FBdEM7O0FBRUFMLGdCQUFRTSxJQUFSLEdBQWUsa0JBQWY7QUFDQU4sZ0JBQVFPLE9BQVIsR0FBa0I7QUFBQSxtQkFBT2QsT0FBT2UsR0FBUCxDQUFQO0FBQUEsU0FBbEI7QUFDQVIsZ0JBQVFTLE1BQVIsR0FBaUI7QUFBQSxtQkFBTWpCLFNBQU47QUFBQSxTQUFqQjtBQUNBVyxjQUFNTyxXQUFOLENBQWtCVixPQUFsQjtBQUNBQSxnQkFBUVcsR0FBUixHQUFjdkIsYUFBZCxDQWYwQyxDQWViO0FBQzdCVSxnQkFBUWMsR0FBUixDQUFZLGdCQUFaO0FBQ0gsS0FqQk0sRUFpQkpDLElBakJJLENBaUJDdkIsZ0JBakJELEVBaUJtQnVCLElBakJuQixDQWlCd0I7QUFBQSxlQUFjckMsUUFBUUMsVUFBUixFQUFvQkMsTUFBcEIsQ0FBZDtBQUFBLEtBakJ4QixDQUFQO0FBa0JILENBckZEIiwiZmlsZSI6IjgwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5jb25zdCBhdHRyaWJ1dGUgPSByZXF1aXJlKCcuL2F0dHJpYnV0ZS5qcycpO1xyXG5jb25zdCBldmVudHMgPSByZXF1aXJlKCcuL2V2ZW50cy5qcycpO1xyXG5jb25zdCBoaWxpZ2h0ID0gcmVxdWlyZSgnLi9oaWxpZ2h0LmpzJyk7XHJcbmNvbnN0IGxheWVyID0gcmVxdWlyZSgnLi9sYXllci5qcycpO1xyXG5jb25zdCBsZWdlbmQgPSByZXF1aXJlKCcuL2xlZ2VuZC5qcycpO1xyXG5jb25zdCBlc3JpTWFwID0gcmVxdWlyZSgnLi9tYXAvZXNyaU1hcC5qcycpO1xyXG5jb25zdCBwcm9qID0gcmVxdWlyZSgnLi9wcm9qLmpzJyk7XHJcbmNvbnN0IHF1ZXJ5ID0gcmVxdWlyZSgnLi9xdWVyeS5qcycpO1xyXG5jb25zdCBzaGFyZWQgPSByZXF1aXJlKCcuL3NoYXJlZC5qcycpO1xyXG5jb25zdCBzeW1ib2xvZ3kgPSByZXF1aXJlKCcuL3N5bWJvbG9neS5qcycpO1xyXG5cclxuZnVuY3Rpb24gaW5pdEFsbChlc3JpQnVuZGxlLCB3aW5kb3cpIHtcclxuICAgIGxldCBkZWJ1ZyA9IGZhbHNlO1xyXG4gICAgY29uc3QgYXBpID0ge307XHJcblxyXG4gICAgYXBpLmxheWVyID0gbGF5ZXIoZXNyaUJ1bmRsZSwgYXBpKTtcclxuICAgIGFwaS5sZWdlbmQgPSBsZWdlbmQoKTtcclxuICAgIGFwaS5wcm9qID0gcHJvaihlc3JpQnVuZGxlKTtcclxuICAgIGFwaS5NYXAgPSBlc3JpTWFwKGVzcmlCdW5kbGUsIGFwaSk7XHJcbiAgICBhcGkuYXR0cmlicyA9IGF0dHJpYnV0ZShlc3JpQnVuZGxlLCBhcGkpO1xyXG4gICAgYXBpLnN5bWJvbG9neSA9IHN5bWJvbG9neShlc3JpQnVuZGxlLCBhcGksIHdpbmRvdyk7XHJcbiAgICBhcGkuaGlsaWdodCA9IGhpbGlnaHQoZXNyaUJ1bmRsZSwgYXBpKTtcclxuICAgIGFwaS5ldmVudHMgPSBldmVudHMoKTtcclxuICAgIGFwaS5xdWVyeSA9IHF1ZXJ5KGVzcmlCdW5kbGUpO1xyXG4gICAgYXBpLnNoYXJlZCA9IHNoYXJlZChlc3JpQnVuZGxlKTtcclxuICAgIGFwaS5kZWJ1ZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICBkZWJ1ZyA9IGFyZ3VtZW50c1swXSA9PT0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBkZWJ1ZztcclxuICAgIH07XHJcbiAgICBhcGkuZXNyaUJ1bmRsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoZGVidWcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVzcmlCdW5kbGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBzZXQgZGVidWcgdG8gZGlyZWN0bHkgYWNjZXNzIHRoZSBidW5kbGUnKTtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIGFwaTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXNyaUxvYWRlclVybCwgd2luZG93KSB7XHJcblxyXG4gICAgLy8gZXNyaURlcHMgaXMgYW4gYXJyYXkgcGFpcmluZyBFU1JJIEpTQVBJIGRlcGVuZGVuY2llcyB3aXRoIHRoZWlyIGltcG9ydGVkIG5hbWVzXHJcbiAgICAvLyBpbiBlc3JpQnVuZGxlXHJcbiAgICBjb25zdCBlc3JpRGVwcyA9IFtcclxuICAgICAgICBbJ2Rvam8vRGVmZXJyZWQnLCAnRGVmZXJyZWQnXSxcclxuICAgICAgICBbJ2Rvam8vcXVlcnknLCAnZG9qb1F1ZXJ5J10sXHJcbiAgICAgICAgWydlc3JpL0NvbG9yJywgJ0NvbG9yJ10sXHJcbiAgICAgICAgWydlc3JpL2NvbmZpZycsICdlc3JpQ29uZmlnJ10sXHJcbiAgICAgICAgWydlc3JpL2Rpaml0L0Jhc2VtYXAnLCAnQmFzZW1hcCddLFxyXG4gICAgICAgIFsnZXNyaS9kaWppdC9CYXNlbWFwR2FsbGVyeScsICdCYXNlbWFwR2FsbGVyeSddLFxyXG4gICAgICAgIFsnZXNyaS9kaWppdC9CYXNlbWFwTGF5ZXInLCAnQmFzZW1hcExheWVyJ10sXHJcbiAgICAgICAgWydlc3JpL2Rpaml0L092ZXJ2aWV3TWFwJywgJ092ZXJ2aWV3TWFwJ10sXHJcbiAgICAgICAgWydlc3JpL2Rpaml0L1NjYWxlYmFyJywgJ1NjYWxlYmFyJ10sXHJcbiAgICAgICAgWydlc3JpL2dlb21ldHJ5L0V4dGVudCcsICdFeHRlbnQnXSxcclxuICAgICAgICBbJ2VzcmkvZ2VvbWV0cnkvUG9pbnQnLCAnUG9pbnQnXSxcclxuICAgICAgICBbJ2VzcmkvZ2VvbWV0cnkvU2NyZWVuUG9pbnQnLCAnU2NyZWVuUG9pbnQnXSxcclxuICAgICAgICBbJ2VzcmkvZ3JhcGhpYycsICdHcmFwaGljJ10sXHJcbiAgICAgICAgWydlc3JpL2dyYXBoaWNzVXRpbHMnLCAnZ3JhcGhpY3NVdGlscyddLFxyXG4gICAgICAgIFsnZXNyaS9sYXllcnMvQXJjR0lTRHluYW1pY01hcFNlcnZpY2VMYXllcicsICdBcmNHSVNEeW5hbWljTWFwU2VydmljZUxheWVyJ10sXHJcbiAgICAgICAgWydlc3JpL2xheWVycy9BcmNHSVNJbWFnZVNlcnZpY2VMYXllcicsICdBcmNHSVNJbWFnZVNlcnZpY2VMYXllciddLFxyXG4gICAgICAgIFsnZXNyaS9sYXllcnMvQXJjR0lTVGlsZWRNYXBTZXJ2aWNlTGF5ZXInLCAnQXJjR0lTVGlsZWRNYXBTZXJ2aWNlTGF5ZXInXSxcclxuICAgICAgICBbJ2VzcmkvbGF5ZXJzL0ZlYXR1cmVMYXllcicsICdGZWF0dXJlTGF5ZXInXSxcclxuICAgICAgICBbJ2VzcmkvbGF5ZXJzL0dyYXBoaWNzTGF5ZXInLCAnR3JhcGhpY3NMYXllciddLFxyXG4gICAgICAgIFsnZXNyaS9sYXllcnMvTGF5ZXJEcmF3aW5nT3B0aW9ucycsICdMYXllckRyYXdpbmdPcHRpb25zJ10sXHJcbiAgICAgICAgWydlc3JpL2xheWVycy9XTVNMYXllcicsICdXbXNMYXllciddLFxyXG4gICAgICAgIFsnZXNyaS9tYXAnLCAnTWFwJ10sXHJcbiAgICAgICAgWydlc3JpL3JlcXVlc3QnLCAnZXNyaVJlcXVlc3QnXSxcclxuICAgICAgICBbJ2VzcmkvU3BhdGlhbFJlZmVyZW5jZScsICdTcGF0aWFsUmVmZXJlbmNlJ10sXHJcbiAgICAgICAgWydlc3JpL3N5bWJvbHMvanNvblV0aWxzJywgJ3N5bWJvbEpzb25VdGlscyddLFxyXG4gICAgICAgIFsnZXNyaS90YXNrcy9HZW9tZXRyeVNlcnZpY2UnLCAnR2VvbWV0cnlTZXJ2aWNlJ10sXHJcbiAgICAgICAgWydlc3JpL3Rhc2tzL0lkZW50aWZ5UGFyYW1ldGVycycsICdJZGVudGlmeVBhcmFtZXRlcnMnXSxcclxuICAgICAgICBbJ2VzcmkvdGFza3MvSWRlbnRpZnlUYXNrJywgJ0lkZW50aWZ5VGFzayddLFxyXG4gICAgICAgIFsnZXNyaS90YXNrcy9Qcm9qZWN0UGFyYW1ldGVycycsICdQcm9qZWN0UGFyYW1ldGVycyddLFxyXG4gICAgICAgIFsnZXNyaS90YXNrcy9xdWVyeScsICdRdWVyeSddLFxyXG4gICAgICAgIFsnZXNyaS90YXNrcy9RdWVyeVRhc2snLCAnUXVlcnlUYXNrJ10sXHJcbiAgICAgICAgWydlc3JpL3Rhc2tzL1ByaW50UGFyYW1ldGVycycsICdQcmludFBhcmFtZXRlcnMnXSxcclxuICAgICAgICBbJ2VzcmkvdGFza3MvUHJpbnRUYXNrJywgJ1ByaW50VGFzayddLFxyXG4gICAgICAgIFsnZXNyaS90YXNrcy9QcmludFRlbXBsYXRlJywgJ1ByaW50VGVtcGxhdGUnXVxyXG4gICAgXTtcclxuXHJcbiAgICBmdW5jdGlvbiBtYWtlRG9qb1JlcXVlc3RzKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcblxyXG4gICAgICAgICAgICAvLyBOT1RFOiBkbyBub3QgY2hhbmdlIHRoZSBjYWxsYmFjayB0byBhbiBhcnJvdyBmdW5jdGlvbiBzaW5jZSB3ZSBkb24ndCBrbm93IGlmXHJcbiAgICAgICAgICAgIC8vIERvam8ncyByZXF1aXJlIGhhcyBhbnkgZXhwZWN0YXRpb25zIG9mIHRoZSBzY29wZSB3aXRoaW4gdGhhdCBmdW5jdGlvbiBvclxyXG4gICAgICAgICAgICAvLyBkb2VzIGFueSBvZGQgbWV0YXByb2dyYW1taW5nXHJcbiAgICAgICAgICAgIHdpbmRvdy5yZXF1aXJlKGVzcmlEZXBzLm1hcChkZXBzID0+IGRlcHNbMF0pLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlc3JpQnVuZGxlID0ge307XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gaXRlcmF0ZSBvdmVyIGFyZ3VtZW50cyB0byBhdm9pZCBjcmVhdGluZyBhbiB1Z2x5IGdpYW50IGZ1bmN0aW9uIGNhbGxcclxuICAgICAgICAgICAgICAgIC8vIGFyZ3VtZW50cyBpcyBub3QgYW4gYXJyYXkgc28gd2UgZG8gdGhpcyB0aGUgaGFyZCB3YXlcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXNyaUJ1bmRsZVtlc3JpRGVwc1tpXVsxXV0gPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKGVzcmlCdW5kbGUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgd2luZG93LnJlcXVpcmUub24oJ2Vycm9yJywgcmVqZWN0KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyB0aGUgc3RhcnR1cCBmb3IgdGhpcyBtb2R1bGUgaXM6XHJcbiAgICAvLyAxLiBhZGQgYSBzY3JpcHQgdGFnIHRvIGxvYWQgdGhlIEFQSSAodGhpcyB0eXBpY2FsbHkgcG9pbnRzIHRvIGEgY3VzdG9tIEVTUkkgYnVpbGQpXHJcbiAgICAvLyAyLiBsb2FkIGFsbCB0aGUgRVNSSSBhbmQgRG9qbyBkZXBlbmRlbmNpZXMgYG1ha2VEb2pvUmVxdWVzdHMoKWBcclxuICAgIC8vIDMuIGluaXRpYWxpemUgYWxsIG9mIG91ciBtb2R1bGVzXHJcbiAgICAvLyBldmVyeXRoaW5nIGlzIGRvbmUgaW4gYW4gYXN5bmMgbW9kZWwgYW5kIHRoZSByZXN1bHQgaXMgYSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvXHJcbiAgICAvLyBhIHJlZmVyZW5jZSB0byBvdXIgQVBJXHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGlmICh3aW5kb3cucmVxdWlyZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ3dpbmRvdy5yZXF1aXJlIGhhcyBiZWVuIHNldCwgJyArXHJcbiAgICAgICAgICAgICAgICAnYXR0ZW1wdGluZyB0byByZXVzZSBleGlzdGluZyBsb2FkZXIgd2l0aCBubyBuZXcgc2NyaXB0IHRhZyBjcmVhdGVkJyk7XHJcbiAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3Qgb1NjcmlwdCA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcclxuICAgICAgICBjb25zdCBvSGVhZCA9IHdpbmRvdy5kb2N1bWVudC5oZWFkIHx8IHdpbmRvdy5kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xyXG5cclxuICAgICAgICBvU2NyaXB0LnR5cGUgPSAndGV4dFxcL2phdmFzY3JpcHQnO1xyXG4gICAgICAgIG9TY3JpcHQub25lcnJvciA9IGVyciA9PiByZWplY3QoZXJyKTtcclxuICAgICAgICBvU2NyaXB0Lm9ubG9hZCA9ICgpID0+IHJlc29sdmUoKTtcclxuICAgICAgICBvSGVhZC5hcHBlbmRDaGlsZChvU2NyaXB0KTtcclxuICAgICAgICBvU2NyaXB0LnNyYyA9IGVzcmlMb2FkZXJVcmw7IC8vICcvL2VjLmNsb3VkYXBwLm5ldC9+YWx5L2VzcmkvZG9qby9kb2pvLmpzJztcclxuICAgICAgICBjb25zb2xlLmxvZygnbWFkZSBhIHByb21pc2UnKTtcclxuICAgIH0pLnRoZW4obWFrZURvam9SZXF1ZXN0cykudGhlbihlc3JpQnVuZGxlID0+IGluaXRBbGwoZXNyaUJ1bmRsZSwgd2luZG93KSk7XHJcbn07XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9pbmRleC5qcyJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){"use strict";eval("\n\n// TODO: this module is currently split from layer.js because layer.js is already huge and doesn't need\n// more functions we can't find.  When (if ever) we refactor this can probably merge with some other code.\n\nvar defaultRenderers = __webpack_require__(70);\n\nfunction bboxBuilder(esriBundle, apiRef) {\n    /**\r\n    * Makes a bounding box layer (a graphics layer with one rectangle graphic matching the supplied extent).\r\n    * @method makeBoundingBox\r\n    * @param {String} id the id of the bounding box to be created\r\n    * @param {EsriExtent} extent an ESRI extent object to be used for the graphics boundaries\r\n    * @param {SpatialReference} targetSr an ESRI spatial reference which is used for projecting the result\r\n    * @return {GraphicsLayer} an ESRI GraphicsLayer\r\n    */\n    return function (id, extent, targetSr) {\n        var result = new esriBundle.GraphicsLayer({ id: id, visible: true });\n        var projectedExtent = extent;\n        if (!apiRef.proj.isSpatialRefEqual(extent.spatialReference, targetSr)) {\n            projectedExtent = apiRef.proj.projectEsriExtent(extent, targetSr);\n        }\n        result.add(new esriBundle.Graphic({\n            geometry: projectedExtent,\n            symbol: defaultRenderers.boundingBoxPoly.renderer.symbol\n        }));\n        return result;\n    };\n}\n\nmodule.exports = function (esriBundle, apiRef) {\n    return {\n        makeBoundingBox: bboxBuilder(esriBundle, apiRef)\n    };\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXIvYmJveC5qcz8xNjM0Il0sIm5hbWVzIjpbImRlZmF1bHRSZW5kZXJlcnMiLCJyZXF1aXJlIiwiYmJveEJ1aWxkZXIiLCJlc3JpQnVuZGxlIiwiYXBpUmVmIiwiaWQiLCJleHRlbnQiLCJ0YXJnZXRTciIsInJlc3VsdCIsIkdyYXBoaWNzTGF5ZXIiLCJ2aXNpYmxlIiwicHJvamVjdGVkRXh0ZW50IiwicHJvaiIsImlzU3BhdGlhbFJlZkVxdWFsIiwic3BhdGlhbFJlZmVyZW5jZSIsInByb2plY3RFc3JpRXh0ZW50IiwiYWRkIiwiR3JhcGhpYyIsImdlb21ldHJ5Iiwic3ltYm9sIiwiYm91bmRpbmdCb3hQb2x5IiwicmVuZGVyZXIiLCJtb2R1bGUiLCJleHBvcnRzIiwibWFrZUJvdW5kaW5nQm94Il0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBOztBQUVBLElBQU1BLG1CQUFtQixtQkFBQUMsQ0FBUSxFQUFSLENBQXpCOztBQUVBLFNBQVNDLFdBQVQsQ0FBcUJDLFVBQXJCLEVBQWlDQyxNQUFqQyxFQUF5QztBQUNyQzs7Ozs7Ozs7QUFRQSxXQUFPLFVBQUNDLEVBQUQsRUFBS0MsTUFBTCxFQUFhQyxRQUFiLEVBQTBCO0FBQzdCLFlBQU1DLFNBQVMsSUFBSUwsV0FBV00sYUFBZixDQUE2QixFQUFFSixNQUFGLEVBQU1LLFNBQVMsSUFBZixFQUE3QixDQUFmO0FBQ0EsWUFBSUMsa0JBQWtCTCxNQUF0QjtBQUNBLFlBQUksQ0FBQ0YsT0FBT1EsSUFBUCxDQUFZQyxpQkFBWixDQUE4QlAsT0FBT1EsZ0JBQXJDLEVBQXVEUCxRQUF2RCxDQUFMLEVBQXVFO0FBQ25FSSw4QkFBa0JQLE9BQU9RLElBQVAsQ0FBWUcsaUJBQVosQ0FBOEJULE1BQTlCLEVBQXNDQyxRQUF0QyxDQUFsQjtBQUNIO0FBQ0RDLGVBQU9RLEdBQVAsQ0FBVyxJQUFJYixXQUFXYyxPQUFmLENBQXVCO0FBQzlCQyxzQkFBVVAsZUFEb0I7QUFFOUJRLG9CQUFRbkIsaUJBQWlCb0IsZUFBakIsQ0FBaUNDLFFBQWpDLENBQTBDRjtBQUZwQixTQUF2QixDQUFYO0FBSUEsZUFBT1gsTUFBUDtBQUNILEtBWEQ7QUFZSDs7QUFFRGMsT0FBT0MsT0FBUCxHQUFpQixVQUFDcEIsVUFBRCxFQUFhQyxNQUFiO0FBQUEsV0FBeUI7QUFDdENvQix5QkFBaUJ0QixZQUFZQyxVQUFaLEVBQXdCQyxNQUF4QjtBQURxQixLQUF6QjtBQUFBLENBQWpCIiwiZmlsZSI6IjgxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxuLy8gVE9ETzogdGhpcyBtb2R1bGUgaXMgY3VycmVudGx5IHNwbGl0IGZyb20gbGF5ZXIuanMgYmVjYXVzZSBsYXllci5qcyBpcyBhbHJlYWR5IGh1Z2UgYW5kIGRvZXNuJ3QgbmVlZFxyXG4vLyBtb3JlIGZ1bmN0aW9ucyB3ZSBjYW4ndCBmaW5kLiAgV2hlbiAoaWYgZXZlcikgd2UgcmVmYWN0b3IgdGhpcyBjYW4gcHJvYmFibHkgbWVyZ2Ugd2l0aCBzb21lIG90aGVyIGNvZGUuXHJcblxyXG5jb25zdCBkZWZhdWx0UmVuZGVyZXJzID0gcmVxdWlyZSgnLi4vZGVmYXVsdFJlbmRlcmVycy5qc29uJyk7XHJcblxyXG5mdW5jdGlvbiBiYm94QnVpbGRlcihlc3JpQnVuZGxlLCBhcGlSZWYpIHtcclxuICAgIC8qKlxyXG4gICAgKiBNYWtlcyBhIGJvdW5kaW5nIGJveCBsYXllciAoYSBncmFwaGljcyBsYXllciB3aXRoIG9uZSByZWN0YW5nbGUgZ3JhcGhpYyBtYXRjaGluZyB0aGUgc3VwcGxpZWQgZXh0ZW50KS5cclxuICAgICogQG1ldGhvZCBtYWtlQm91bmRpbmdCb3hcclxuICAgICogQHBhcmFtIHtTdHJpbmd9IGlkIHRoZSBpZCBvZiB0aGUgYm91bmRpbmcgYm94IHRvIGJlIGNyZWF0ZWRcclxuICAgICogQHBhcmFtIHtFc3JpRXh0ZW50fSBleHRlbnQgYW4gRVNSSSBleHRlbnQgb2JqZWN0IHRvIGJlIHVzZWQgZm9yIHRoZSBncmFwaGljcyBib3VuZGFyaWVzXHJcbiAgICAqIEBwYXJhbSB7U3BhdGlhbFJlZmVyZW5jZX0gdGFyZ2V0U3IgYW4gRVNSSSBzcGF0aWFsIHJlZmVyZW5jZSB3aGljaCBpcyB1c2VkIGZvciBwcm9qZWN0aW5nIHRoZSByZXN1bHRcclxuICAgICogQHJldHVybiB7R3JhcGhpY3NMYXllcn0gYW4gRVNSSSBHcmFwaGljc0xheWVyXHJcbiAgICAqL1xyXG4gICAgcmV0dXJuIChpZCwgZXh0ZW50LCB0YXJnZXRTcikgPT4ge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBlc3JpQnVuZGxlLkdyYXBoaWNzTGF5ZXIoeyBpZCwgdmlzaWJsZTogdHJ1ZSB9KTtcclxuICAgICAgICBsZXQgcHJvamVjdGVkRXh0ZW50ID0gZXh0ZW50O1xyXG4gICAgICAgIGlmICghYXBpUmVmLnByb2ouaXNTcGF0aWFsUmVmRXF1YWwoZXh0ZW50LnNwYXRpYWxSZWZlcmVuY2UsIHRhcmdldFNyKSkge1xyXG4gICAgICAgICAgICBwcm9qZWN0ZWRFeHRlbnQgPSBhcGlSZWYucHJvai5wcm9qZWN0RXNyaUV4dGVudChleHRlbnQsIHRhcmdldFNyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdWx0LmFkZChuZXcgZXNyaUJ1bmRsZS5HcmFwaGljKHtcclxuICAgICAgICAgICAgZ2VvbWV0cnk6IHByb2plY3RlZEV4dGVudCxcclxuICAgICAgICAgICAgc3ltYm9sOiBkZWZhdWx0UmVuZGVyZXJzLmJvdW5kaW5nQm94UG9seS5yZW5kZXJlci5zeW1ib2xcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gKGVzcmlCdW5kbGUsIGFwaVJlZikgPT4gKHtcclxuICAgIG1ha2VCb3VuZGluZ0JveDogYmJveEJ1aWxkZXIoZXNyaUJ1bmRsZSwgYXBpUmVmKVxyXG59KTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2xheWVyL2Jib3guanMiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar attribFC = __webpack_require__(18)();\n\n/**\r\n * @class DynamicFC\r\n */\n\nvar DynamicFC = function (_attribFC$AttribFC) {\n    _inherits(DynamicFC, _attribFC$AttribFC);\n\n    // dynamic child variant for feature class object.\n    // deals with stuff specific to dynamic children (i.e. virtual layer on client)\n\n    /**\r\n     * Create an feature class object for a feature class that is a child of a dynamic layer\r\n     * @param {Object} parent        the Record object that this Feature Class belongs to\r\n     * @param {String} idx           the service index of this Feature Class. an integer in string format. use '0' for non-indexed sources.\r\n     * @param {Object} layerPackage  a layer package object from the attribute module for this feature class\r\n     * @param {Object} config        the config object for this sublayer\r\n     */\n    function DynamicFC(parent, idx, layerPackage, config) {\n        _classCallCheck(this, DynamicFC);\n\n        var _this = _possibleConstructorReturn(this, (DynamicFC.__proto__ || Object.getPrototypeOf(DynamicFC)).call(this, parent, idx, layerPackage, config));\n\n        _this.opacity = config.state.opacity;\n        _this._highlightFeature = true;\n\n        // visibility is kept stateful by the parent. keeping an internal property\n        // just means we would need to keep it in synch.\n        // the DynamicRecord onLoad handler will set the initial state, so don't do it here.\n\n        // will also cache scale levels to avoid asynching code.  initialize here with no limits,\n        // then update when layer loads\n        _this._scaleSet = {\n            minScale: 0,\n            maxScale: 0\n        };\n        return _this;\n    }\n\n    _createClass(DynamicFC, [{\n        key: 'getScaleSet',\n\n\n        // returns an object with minScale and maxScale values for the feature class\n        value: function getScaleSet() {\n            return this._scaleSet;\n        }\n    }, {\n        key: 'setVisibility',\n        value: function setVisibility(value) {\n            // update visible layers array\n            var vLayers = this._parent._layer.visibleLayers.concat();\n            var intIdx = parseInt(this._idx);\n            var vIdx = vLayers.indexOf(intIdx);\n            var dirty = false;\n            var layerVisChange = false;\n            if (value && vIdx === -1) {\n                // check for first added case\n                if (vLayers.length === 1 && vLayers[0] === -1) {\n                    vLayers.pop();\n                    layerVisChange = true;\n                }\n\n                // was invisible, now visible\n                vLayers.push(intIdx);\n                dirty = true;\n            } else if (!value && vIdx > -1) {\n                // was visible, now invisible\n                vLayers.splice(vIdx, 1);\n                if (vLayers.length === 0) {\n                    vLayers.push(-1); // code for no layers\n                    layerVisChange = true;\n                }\n                dirty = true;\n            }\n\n            if (dirty) {\n                this._parent._layer.setVisibleLayers(vLayers);\n                if (layerVisChange) {\n                    this._parent._layer.setVisibility(value);\n                }\n            }\n\n            // TODO add a timer or something to cache requests.\n            //      use setVisibileLayers(arry, true) to stall the redraw\n            //      then when timer runs out, call layer.refresh\n        }\n\n        // TODO extend this function to other FC's?  do they need it?\n\n    }, {\n        key: 'getVisibility',\n        value: function getVisibility() {\n            return this._parent._layer.visibleLayers.indexOf(parseInt(this._idx)) > -1;\n        }\n    }, {\n        key: 'highlightFeature',\n        get: function get() {\n            return this._highlightFeature;\n        },\n        set: function set(value) {\n            this._highlightFeature = value;\n        }\n    }, {\n        key: 'supportsOpacity',\n        get: function get() {\n            return this._parent._isTrueDynamic;\n        }\n    }, {\n        key: 'opacity',\n        get: function get() {\n            return this._opacity;\n        },\n        set: function set(value) {\n            // avoid parent/child update loops by only doing work if value changed\n            if (this._opacity !== value) {\n                this._opacity = value;\n\n                if (this.supportsOpacity) {\n                    // only attempt to set the layer if we support that kind of magic.\n                    // instead of being consistent, esri using value from 0 to 100 for sublayer transparency where 100 is fully transparent\n                    var optionsArray = [];\n                    var drawingOptions = new this._parent._apiRef.layer.LayerDrawingOptions();\n                    drawingOptions.transparency = (value - 1) * -100;\n                    optionsArray[this._idx] = drawingOptions;\n                    this._parent._layer.setLayerDrawingOptions(optionsArray);\n                } else {\n                    // update the opacity on the parent and any sibling children\n                    this._parent.synchOpacity(value);\n                }\n            }\n        }\n    }, {\n        key: 'geomType',\n        get: function get() {\n            return this._geometryType;\n        },\n        set: function set(value) {\n            this._geometryType = value;\n        }\n    }, {\n        key: 'featureCount',\n        get: function get() {\n            return this._fcount;\n        },\n        set: function set(value) {\n            this._fcount = value;\n        }\n    }]);\n\n    return DynamicFC;\n}(attribFC.AttribFC);\n\nmodule.exports = function () {\n    return {\n        DynamicFC: DynamicFC\n    };\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXIvbGF5ZXJSZWMvZHluYW1pY0ZDLmpzP2IwOGMiXSwibmFtZXMiOlsiYXR0cmliRkMiLCJyZXF1aXJlIiwiRHluYW1pY0ZDIiwicGFyZW50IiwiaWR4IiwibGF5ZXJQYWNrYWdlIiwiY29uZmlnIiwib3BhY2l0eSIsInN0YXRlIiwiX2hpZ2hsaWdodEZlYXR1cmUiLCJfc2NhbGVTZXQiLCJtaW5TY2FsZSIsIm1heFNjYWxlIiwidmFsdWUiLCJ2TGF5ZXJzIiwiX3BhcmVudCIsIl9sYXllciIsInZpc2libGVMYXllcnMiLCJjb25jYXQiLCJpbnRJZHgiLCJwYXJzZUludCIsIl9pZHgiLCJ2SWR4IiwiaW5kZXhPZiIsImRpcnR5IiwibGF5ZXJWaXNDaGFuZ2UiLCJsZW5ndGgiLCJwb3AiLCJwdXNoIiwic3BsaWNlIiwic2V0VmlzaWJsZUxheWVycyIsInNldFZpc2liaWxpdHkiLCJfaXNUcnVlRHluYW1pYyIsIl9vcGFjaXR5Iiwic3VwcG9ydHNPcGFjaXR5Iiwib3B0aW9uc0FycmF5IiwiZHJhd2luZ09wdGlvbnMiLCJfYXBpUmVmIiwibGF5ZXIiLCJMYXllckRyYXdpbmdPcHRpb25zIiwidHJhbnNwYXJlbmN5Iiwic2V0TGF5ZXJEcmF3aW5nT3B0aW9ucyIsInN5bmNoT3BhY2l0eSIsIl9nZW9tZXRyeVR5cGUiLCJfZmNvdW50IiwiQXR0cmliRkMiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7OztBQUVBLElBQU1BLFdBQVcsbUJBQUFDLENBQVEsRUFBUixHQUFqQjs7QUFFQTs7OztJQUdNQyxTOzs7QUFDRjtBQUNBOztBQUVBOzs7Ozs7O0FBT0EsdUJBQWFDLE1BQWIsRUFBcUJDLEdBQXJCLEVBQTBCQyxZQUExQixFQUF3Q0MsTUFBeEMsRUFBZ0Q7QUFBQTs7QUFBQSwwSEFDdENILE1BRHNDLEVBQzlCQyxHQUQ4QixFQUN6QkMsWUFEeUIsRUFDWEMsTUFEVzs7QUFHNUMsY0FBS0Ms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SDtBQUNBLHlCQUFLcEIsT0FBTCxDQUFhMkIsWUFBYixDQUEwQjdCLEtBQTFCO0FBQ0g7QUFDSjtBQUNKOzs7NEJBT2U7QUFBRSxtQkFBTyxLQUFLOEIsYUFBWjtBQUE0QixTOzBCQUNoQzlCLEssRUFBTztBQUFFLGlCQUFLOEIsYUFBTCxHQUFxQjlCLEtBQXJCO0FBQTZCOzs7NEJBRWhDO0FBQUUsbUJBQU8sS0FBSytCLE9BQVo7QUFBc0IsUzswQkFDMUIvQixLLEVBQU87QUFBRSxpQkFBSytCLE9BQUwsR0FBZS9CLEtBQWY7QUFBdUI7Ozs7RUFoRTlCYixTQUFTNkMsUTs7QUFpSGpDQyxPQUFPQyxPQUFQLEdBQWlCO0FBQUEsV0FBTztBQUNwQjdDO0FBRG9CLEtBQVA7QUFBQSxDQUFqQiIsImZpbGUiOiI4Mi5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuXHJcbmNvbnN0IGF0dHJpYkZDID0gcmVxdWlyZSgnLi9hdHRyaWJGQy5qcycpKCk7XHJcblxyXG4vKipcclxuICogQGNsYXNzIER5bmFtaWNGQ1xyXG4gKi9cclxuY2xhc3MgRHluYW1pY0ZDIGV4dGVuZHMgYXR0cmliRkMuQXR0cmliRkMge1xyXG4gICAgLy8gZHluYW1pYyBjaGlsZCB2YXJpYW50IGZvciBmZWF0dXJlIGNsYXNzIG9iamVjdC5cclxuICAgIC8vIGRlYWxzIHdpdGggc3R1ZmYgc3BlY2lmaWMgdG8gZHluYW1pYyBjaGlsZHJlbiAoaS5lLiB2aXJ0dWFsIGxheWVyIG9uIGNsaWVudClcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhbiBmZWF0dXJlIGNsYXNzIG9iamVjdCBmb3IgYSBmZWF0dXJlIGNsYXNzIHRoYXQgaXMgYSBjaGlsZCBvZiBhIGR5bmFtaWMgbGF5ZXJcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJlbnQgICAgICAgIHRoZSBSZWNvcmQgb2JqZWN0IHRoYXQgdGhpcyBGZWF0dXJlIENsYXNzIGJlbG9uZ3MgdG9cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZHggICAgICAgICAgIHRoZSBzZXJ2aWNlIGluZGV4IG9mIHRoaXMgRmVhdHVyZSBDbGFzcy4gYW4gaW50ZWdlciBpbiBzdHJpbmcgZm9ybWF0LiB1c2UgJzAnIGZvciBub24taW5kZXhlZCBzb3VyY2VzLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxheWVyUGFja2FnZSAgYSBsYXllciBwYWNrYWdlIG9iamVjdCBmcm9tIHRoZSBhdHRyaWJ1dGUgbW9kdWxlIGZvciB0aGlzIGZlYXR1cmUgY2xhc3NcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgICAgICAgIHRoZSBjb25maWcgb2JqZWN0IGZvciB0aGlzIHN1YmxheWVyXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yIChwYXJlbnQsIGlkeCwgbGF5ZXJQYWNrYWdlLCBjb25maWcpIHtcclxuICAgICAgICBzdXBlcihwYXJlbnQsIGlkeCwgbGF5ZXJQYWNrYWdlLCBjb25maWcpO1xyXG5cclxuICAgICAgICB0aGlzLm9wYWNpdHkgPSBjb25maWcuc3RhdGUub3BhY2l0eTtcclxuICAgICAgICB0aGlzLl9oaWdobGlnaHRGZWF0dXJlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgLy8gdmlzaWJpbGl0eSBpcyBrZXB0IHN0YXRlZnVsIGJ5IHRoZSBwYXJlbnQuIGtlZXBpbmcgYW4gaW50ZXJuYWwgcHJvcGVydHlcclxuICAgICAgICAvLyBqdXN0IG1lYW5zIHdlIHdvdWxkIG5lZWQgdG8ga2VlcCBpdCBpbiBzeW5jaC5cclxuICAgICAgICAvLyB0aGUgRHluYW1pY1JlY29yZCBvbkxvYWQgaGFuZGxlciB3aWxsIHNldCB0aGUgaW5pdGlhbCBzdGF0ZSwgc28gZG9uJ3QgZG8gaXQgaGVyZS5cclxuXHJcbiAgICAgICAgLy8gd2lsbCBhbHNvIGNhY2hlIHNjYWxlIGxldmVscyB0byBhdm9pZCBhc3luY2hpbmcgY29kZS4gIGluaXRpYWxpemUgaGVyZSB3aXRoIG5vIGxpbWl0cyxcclxuICAgICAgICAvLyB0aGVuIHVwZGF0ZSB3aGVuIGxheWVyIGxvYWRzXHJcbiAgICAgICAgdGhpcy5fc2NhbGVTZXQgPSB7XHJcbiAgICAgICAgICAgIG1pblNjYWxlOiAwLFxyXG4gICAgICAgICAgICBtYXhTY2FsZTogMFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IGhpZ2hsaWdodEZlYXR1cmUgKCkgeyByZXR1cm4gdGhpcy5faGlnaGxpZ2h0RmVhdHVyZTsgfVxyXG4gICAgc2V0IGhpZ2hsaWdodEZlYXR1cmUgKHZhbHVlKSB7IHRoaXMuX2hpZ2hsaWdodEZlYXR1cmUgPSB2YWx1ZTsgfVxyXG5cclxuICAgIGdldCBzdXBwb3J0c09wYWNpdHkgKCkgeyByZXR1cm4gdGhpcy5fcGFyZW50Ll9pc1RydWVEeW5hbWljOyB9XHJcblxyXG4gICAgZ2V0IG9wYWNpdHkgKCkgeyByZXR1cm4gdGhpcy5fb3BhY2l0eTsgfVxyXG4gICAgc2V0IG9wYWNpdHkgKHZhbHVlKSB7XHJcbiAgICAgICAgLy8gYXZvaWQgcGFyZW50L2NoaWxkIHVwZGF0ZSBsb29wcyBieSBvbmx5IGRvaW5nIHdvcmsgaWYgdmFsdWUgY2hhbmdlZFxyXG4gICAgICAgIGlmICh0aGlzLl9vcGFjaXR5ICE9PSB2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9vcGFjaXR5ID0gdmFsdWU7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5zdXBwb3J0c09wYWNpdHkpIHtcclxuICAgICAgICAgICAgICAgIC8vIG9ubHkgYXR0ZW1wdCB0byBzZXQgdGhlIGxheWVyIGlmIHdlIHN1cHBvcnQgdGhhdCBraW5kIG9mIG1hZ2ljLlxyXG4gICAgICAgICAgICAgICAgLy8gaW5zdGVhZCBvZiBiZWluZyBjb25zaXN0ZW50LCBlc3JpIHVzaW5nIHZhbHVlIGZyb20gMCB0byAxMDAgZm9yIHN1YmxheWVyIHRyYW5zcGFyZW5jeSB3aGVyZSAxMDAgaXMgZnVsbHkgdHJhbnNwYXJlbnRcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9wdGlvbnNBcnJheSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZHJhd2luZ09wdGlvbnMgPSBuZXcgdGhpcy5fcGFyZW50Ll9hcGlSZWYubGF5ZXIuTGF5ZXJEcmF3aW5nT3B0aW9ucygpO1xyXG4gICAgICAgICAgICAgICAgZHJhd2luZ09wdGlvbnMudHJhbnNwYXJlbmN5ID0gKHZhbHVlIC0gMSkgKiAtMTAwO1xyXG4gICAgICAgICAgICAgICAgb3B0aW9uc0FycmF5W3RoaXMuX2lkeF0gPSBkcmF3aW5nT3B0aW9ucztcclxuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudC5fbGF5ZXIuc2V0TGF5ZXJEcmF3aW5nT3B0aW9ucyhvcHRpb25zQXJyYXkpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIHRoZSBvcGFjaXR5IG9uIHRoZSBwYXJlbnQgYW5kIGFueSBzaWJsaW5nIGNoaWxkcmVuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQuc3luY2hPcGFjaXR5KHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyByZXR1cm5zIGFuIG9iamVjdCB3aXRoIG1pblNjYWxlIGFuZCBtYXhTY2FsZSB2YWx1ZXMgZm9yIHRoZSBmZWF0dXJlIGNsYXNzXHJcbiAgICBnZXRTY2FsZVNldCAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NjYWxlU2V0O1xyXG4gICAgfVxyXG5cclxuICAgIGdldCBnZW9tVHlwZSAoKSB7IHJldHVybiB0aGlzLl9nZW9tZXRyeVR5cGU7IH1cclxuICAgIHNldCBnZW9tVHlwZSAodmFsdWUpIHsgdGhpcy5fZ2VvbWV0cnlUeXBlID0gdmFsdWU7IH1cclxuXHJcbiAgICBnZXQgZmVhdHVyZUNvdW50ICgpIHsgcmV0dXJuIHRoaXMuX2Zjb3VudDsgfVxyXG4gICAgc2V0IGZlYXR1cmVDb3VudCAodmFsdWUpIHsgdGhpcy5fZmNvdW50ID0gdmFsdWU7IH1cclxuXHJcbiAgICBzZXRWaXNpYmlsaXR5ICh2YWx1ZSkge1xyXG4gICAgICAgIC8vIHVwZGF0ZSB2aXNpYmxlIGxheWVycyBhcnJheVxyXG4gICAgICAgIGNvbnN0IHZMYXllcnMgPSB0aGlzLl9wYXJlbnQuX2xheWVyLnZpc2libGVMYXllcnMuY29uY2F0KCk7XHJcbiAgICAgICAgY29uc3QgaW50SWR4ID0gcGFyc2VJbnQodGhpcy5faWR4KTtcclxuICAgICAgICBjb25zdCB2SWR4ID0gdkxheWVycy5pbmRleE9mKGludElkeCk7XHJcbiAgICAgICAgbGV0IGRpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgbGV0IGxheWVyVmlzQ2hhbmdlID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKHZhbHVlICYmIHZJZHggPT09IC0xKSB7XHJcbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciBmaXJzdCBhZGRlZCBjYXNlXHJcbiAgICAgICAgICAgIGlmICh2TGF5ZXJzLmxlbmd0aCA9PT0gMSAmJiB2TGF5ZXJzWzBdID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgdkxheWVycy5wb3AoKTtcclxuICAgICAgICAgICAgICAgIGxheWVyVmlzQ2hhbmdlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gd2FzIGludmlzaWJsZSwgbm93IHZpc2libGVcclxuICAgICAgICAgICAgdkxheWVycy5wdXNoKGludElkeCk7XHJcbiAgICAgICAgICAgIGRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICB9IGVsc2UgaWYgKCF2YWx1ZSAmJiB2SWR4ID4gLTEpIHtcclxuICAgICAgICAgICAgLy8gd2FzIHZpc2libGUsIG5vdyBpbnZpc2libGVcclxuICAgICAgICAgICAgdkxheWVycy5zcGxpY2UodklkeCwgMSk7XHJcbiAgICAgICAgICAgIGlmICh2TGF5ZXJzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgdkxheWVycy5wdXNoKC0xKTsgLy8gY29kZSBmb3Igbm8gbGF5ZXJzXHJcbiAgICAgICAgICAgICAgICBsYXllclZpc0NoYW5nZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGlydHkgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGRpcnR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3BhcmVudC5fbGF5ZXIuc2V0VmlzaWJsZUxheWVycyh2TGF5ZXJzKTtcclxuICAgICAgICAgICAgaWYgKGxheWVyVmlzQ2hhbmdlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQuX2xheWVyLnNldFZpc2liaWxpdHkodmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBUT0RPIGFkZCBhIHRpbWVyIG9yIHNvbWV0aGluZyB0byBjYWNoZSByZXF1ZXN0cy5cclxuICAgICAgICAvLyAgICAgIHVzZSBzZXRWaXNpYmlsZUxheWVycyhhcnJ5LCB0cnVlKSB0byBzdGFsbCB0aGUgcmVkcmF3XHJcbiAgICAgICAgLy8gICAgICB0aGVuIHdoZW4gdGltZXIgcnVucyBvdXQsIGNhbGwgbGF5ZXIucmVmcmVzaFxyXG5cclxuICAgIH1cclxuXHJcbiAgICAvLyBUT0RPIGV4dGVuZCB0aGlzIGZ1bmN0aW9uIHRvIG90aGVyIEZDJ3M/ICBkbyB0aGV5IG5lZWQgaXQ/XHJcbiAgICBnZXRWaXNpYmlsaXR5ICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50Ll9sYXllci52aXNpYmxlTGF5ZXJzLmluZGV4T2YocGFyc2VJbnQodGhpcy5faWR4KSkgPiAtMTtcclxuICAgIH1cclxuXHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gKCkgPT4gKHtcclxuICAgIER5bmFtaWNGQ1xyXG59KTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2xheWVyL2xheWVyUmVjL2R5bmFtaWNGQy5qcyJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar attribRecord = __webpack_require__(38)();\nvar shared = __webpack_require__(2)();\nvar placeholderFC = __webpack_require__(5)();\nvar layerInterface = __webpack_require__(24)();\nvar dynamicFC = __webpack_require__(82)();\nvar attribFC = __webpack_require__(18)();\n\n/**\r\n * @class DynamicRecord\r\n */\n\nvar DynamicRecord = function (_attribRecord$AttribR) {\n    _inherits(DynamicRecord, _attribRecord$AttribR);\n\n    _createClass(DynamicRecord, [{\n        key: '_layerPassthroughBindings',\n\n        // TODO are we still using passthrough stuff?\n        get: function get() {\n            return ['setOpacity', 'setVisibility', 'setVisibleLayers', 'setLayerDrawingOptions'];\n        }\n    }, {\n        key: '_layerPassthroughProperties',\n        get: function get() {\n            return ['visibleAtMapScale', 'visible', 'spatialReference', 'layerInfos', 'supportsDynamicLayers'];\n        }\n    }, {\n        key: 'layerType',\n        get: function get() {\n            return shared.clientLayerType.ESRI_DYNAMIC;\n        }\n    }, {\n        key: 'isTrueDynamic',\n        get: function get() {\n            return this._isTrueDynamic;\n        }\n\n        /**\r\n         * Create a layer record with the appropriate geoApi layer type.\r\n         * Regarding configuration -- in the standard case, the incoming config object\r\n         * will be incomplete with regards to child state. It may not even have entries for all possible\r\n         * child sub-layers.  Given our config defaulting for children happens AFTER the layer loads,\r\n         * it means what is passed in at the constructor is generally unreliable except for any child names,\r\n         * and the class will treat that information as unreliable (the UI will set values after config defaulting\r\n         * happens). In the rare case where the config is fully formed and we want to take advantage of that,\r\n         * set the configIsComplete param to true.  Be aware that if the config is not actually complete you may\r\n         * get a layer in an undesired initial state.\r\n         *\r\n         * @param {Object} layerClass         the ESRI api object for dynamic layers\r\n         * @param {Object} esriRequest        the ESRI api object for making web requests with proxy support\r\n         * @param {Object} apiRef             object pointing to the geoApi. allows us to call other geoApi functions\r\n         * @param {Object} config             layer config values\r\n         * @param {Object} esriLayer          an optional pre-constructed layer\r\n         * @param {Function} epsgLookup       an optional lookup function for EPSG codes (see geoService for signature)\r\n         * @param {Boolean} configIsComplete  an optional flag to indicate if the config is fully flushed out (i.e. things defined for all children). Defaults to false.\r\n         */\n\n    }]);\n\n    function DynamicRecord(layerClass, esriRequest, apiRef, config, esriLayer, epsgLookup) {\n        var configIsComplete = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n\n        _classCallCheck(this, DynamicRecord);\n\n        var _this = _possibleConstructorReturn(this, (DynamicRecord.__proto__ || Object.getPrototypeOf(DynamicRecord)).call(this, layerClass, esriRequest, apiRef, config, esriLayer, epsgLookup));\n        // TODO might need some nonsense here. if not configIsComplete, and layer is set to visible in config,\n        //      we may need to hack the process so that the esri layer object is initialized as invisible,\n        //      but the config is still marked as visible so the UI knows to do the proper defaulting.\n        //      As is right now, the layer might start to pull an image from the server while our onLoad\n        //      event handler is running and shutting off visibilities.\n\n\n        _this.ArcGISDynamicMapServiceLayer = layerClass;\n        _this._configIsComplete = configIsComplete;\n\n        // TODO what is the case where we have dynamic layer already prepared\n        //      and passed in? Generally this only applies to file layers (which\n        //      are feature layers).\n\n        _this._proxies = {};\n\n        // marks if layer supports dynamic capabilities, like child opacity, renderer change, layer reorder\n        // TODO ensure false is best default (what is better for UI)\n        _this._isTrueDynamic = false;\n\n        return _this;\n    }\n\n    /**\r\n     * Return a proxy interface for a child layer\r\n     *\r\n     * @param {Integer} featureIdx    index of child entry (leaf or group)\r\n     * @return {Object}               proxy interface for given child\r\n     */\n\n\n    _createClass(DynamicRecord, [{\n        key: 'getChildProxy',\n        value: function getChildProxy(featureIdx) {\n            // TODO verify we have integer coming in and not a string\n            // NOTE we no longer have group proxies. Since it is possible for a proxy to\n            //      be requested prior to a dynamic layer being loaded (and thus have no\n            //      idea of the index is valid or the index is a group), we always give\n            //      a proxy and depend on the caller to be smart about it.\n\n            var strIdx = featureIdx.toString();\n            if (this._proxies[strIdx]) {\n                return this._proxies[strIdx];\n            } else {\n                // throw new Error(`attempt to get non-existing child proxy. Index ${featureIdx}`);\n\n                // to handle the case of a structured legend needing a proxy for a child prior to the\n                // layer loading, we treat an unknown proxy request as that case and return\n                // a proxy loaded with a placeholder.\n                // TODO how to pass in a name? add an optional second parameter? expose a \"set name\" on the proxy?\n                var pfc = new placeholderFC.PlaceholderFC(this, '');\n                var tProxy = new layerInterface.LayerInterface(pfc);\n                tProxy.convertToPlaceholder(pfc);\n                this._proxies[strIdx] = tProxy;\n                return tProxy;\n            }\n        }\n\n        // TODO docs\n\n    }, {\n        key: 'getFeatureCount',\n        value: function getFeatureCount(featureIdx) {\n            // point url to sub-index we want\n            // TODO might change how we manage index and url\n            return _get(DynamicRecord.prototype.__proto__ || Object.getPrototypeOf(DynamicRecord.prototype), 'getFeatureCount', this).call(this, this._layer.url + '/' + featureIdx);\n        }\n\n        // TODO docs\n\n    }, {\n        key: 'synchOpacity',\n        value: function synchOpacity(opacity) {\n            var _this2 = this;\n\n            // in the case where a dynamic layer does not support child opacity, if a user\n            // changes the opacity of a child, it actually just adjusts the opacity of the layer.\n            // this means that all other children of the layer need to have their opacity set\n            // to the same value. but we dont want to trigger a number of opacity change requests,\n            // so we do some trickery here.\n\n            Object.keys(this._featClasses).forEach(function (idx) {\n                var fc = _this2._featClasses[idx];\n                if (fc) {\n                    // important: must use the private ._opacity property here,\n                    // as we want to avoid the logic on the .opacity setter.\n                    fc._opacity = opacity;\n                }\n            });\n\n            // update the layer itself.\n            this.opacity = opacity;\n        }\n\n        /**\r\n        * Triggers when the layer loads.\r\n        *\r\n        * @function onLoad\r\n        */\n\n    }, {\n        key: 'onLoad',\n        value: function onLoad() {\n            var _this3 = this;\n\n            var loadPromises = _get(DynamicRecord.prototype.__proto__ || Object.getPrototypeOf(DynamicRecord.prototype), 'onLoad', this).call(this);\n            this._isTrueDynamic = this._layer.supportsDynamicLayers;\n\n            // don't worry about structured legend. the legend part is separate from\n            // the layers part. we just load what we are told to. the legend module\n            // will handle the structured part.\n\n            // see comments on the constructor to learn about _configIsComplete and\n            // what type of scenarios you can expect for incoming configs\n\n            // snapshot doesn't apply to child layers\n            // we don't include bounding box / extent, as we are inheriting it.\n            // a lack of the property means we use the layer definition\n            var dummyState = {\n                opacity: 1,\n                visibility: false,\n                query: false\n            };\n\n            // subfunction to clone a layerEntries config object.\n            // since we are using typed objects with getters and setters,\n            // our usual easy ways of cloning an object don't work (e.g. using\n            // JSON.parse(JSON.stringify(x))). This is not a great solution (understatement),\n            //  but is being done as a quick n dirty workaround. At a later time,\n            // the guts of this function can be re-examined for a better,\n            // less hardcoded solution.\n            var cloneConfig = function cloneConfig(origConfig) {\n                var clone = {};\n\n                // direct copies, no defaulting\n                clone.name = origConfig.name;\n                clone.index = origConfig.index;\n                clone.stateOnly = origConfig.stateOnly;\n                clone.nameField = origConfig.nameField;\n                clone.highlightFeature = origConfig.highlightFeature || true; // simple default\n\n                // an empty string is a valid property, so be wary of falsy logic\n                clone.outfields = origConfig.hasOwnProperty('outfields') ? origConfig.outfields : '*';\n\n                // with state, we are either complete, or pure defaults.\n                // in the non-complete case, we treat our state as unreliable and\n                // expect the client to assign properties as it does parent-child inheritance\n                // defaulting (which occurs after this onLoad function has completed)\n                if (_this3._configIsComplete) {\n                    clone.state = {\n                        visiblity: origConfig.visiblity,\n                        opacity: origConfig.opacity,\n                        query: origConfig.query\n                    };\n                } else {\n                    clone.state = Object.assign({}, dummyState);\n                }\n\n                // if extent is present, we assume it is fully defined.\n                // extents are not using fancy typed objects, so can directly reference\n                clone.extent = origConfig.extent;\n\n                return clone;\n            };\n\n            // collate any relevant overrides from the config.\n            var subConfigs = {};\n\n            this.config.layerEntries.forEach(function (le) {\n                subConfigs[le.index.toString()] = {\n                    config: cloneConfig(le),\n                    defaulted: _this3._configIsComplete\n                };\n            });\n\n            // subfunction to return a subconfig object.\n            // if it does not exist or is not defaulted, will do that first\n            // id param is an integer in string format\n            var fetchSubConfig = function fetchSubConfig(id) {\n                var serverName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\n\n                if (subConfigs[id]) {\n                    var subC = subConfigs[id];\n                    if (!subC.defaulted) {\n                        // config is incomplete, fill in blanks\n                        // we will never hit this code block a complete config was passed in\n\n                        // apply a server name if no name exists\n                        if (!subC.config.name) {\n                            subC.config.name = serverName;\n                        }\n\n                        // mark as defaulted so we don't do this again\n                        subC.defaulted = true;\n                    }\n                    return subC.config;\n                } else {\n                    // no config at all. we apply defaults, and a name from the server if available\n                    var configSeed = {\n                        name: serverName,\n                        index: parseInt(id),\n                        stateOnly: true\n                    };\n                    var newConfig = cloneConfig(configSeed);\n                    subConfigs[id] = {\n                        config: newConfig,\n                        defaulted: true\n                    };\n                    return newConfig;\n                }\n            };\n\n            // shortcut var to track all leafs that need attention\n            // in the loading process\n            var leafsToInit = [];\n\n            // this subfunction will recursively crawl a dynamic layerInfo structure.\n            // it will generate proxy objects for all groups and leafs under the\n            // input layerInfo.\n            // we also generate a tree structure of layerInfos that is in a format\n            // that makes the client happy\n            var processLayerInfo = function processLayerInfo(layerInfo, treeArray) {\n                var sId = layerInfo.id.toString();\n                var subC = fetchSubConfig(sId, layerInfo.name);\n\n                if (layerInfo.subLayerIds && layerInfo.subLayerIds.length > 0) {\n                    // group sublayer. set up our tree for the client, then crawl childs.\n\n                    var treeGroup = {\n                        entryIndex: layerInfo.id,\n                        name: subC.name,\n                        childs: []\n                    };\n                    treeArray.push(treeGroup);\n\n                    // process the kids in the group.\n                    // store the child leaves in the internal variable\n                    layerInfo.subLayerIds.forEach(function (slid) {\n                        processLayerInfo(_this3._layer.layerInfos[slid], treeGroup.childs);\n                    });\n                } else {\n                    // leaf sublayer. make placeholders, add leaf to the tree\n\n                    var pfc = new placeholderFC.PlaceholderFC(_this3, subC.name);\n                    if (_this3._proxies[sId]) {\n                        // we have a pre-made proxy (structured legend). update it.\n                        _this3._proxies[sId].updateSource(pfc);\n                    } else {\n                        // set up new proxy\n                        var leafProxy = new layerInterface.LayerInterface(null);\n                        leafProxy.convertToPlaceholder(pfc);\n                        _this3._proxies[sId] = leafProxy;\n                    }\n\n                    treeArray.push({ entryIndex: layerInfo.id });\n                    leafsToInit.push(layerInfo.id.toString());\n                }\n            };\n\n            this._childTree = []; // public structure describing the tree\n\n            // process the child layers our config is interested in, and all their children.\n            if (this.config.layerEntries) {\n                this.config.layerEntries.forEach(function (le) {\n                    if (!le.stateOnly) {\n                        processLayerInfo(_this3._layer.layerInfos[le.index], _this3._childTree);\n                    }\n                });\n            }\n\n            // converts server layer type string to client layer type string\n            var serverLayerTypeToClientLayerType = function serverLayerTypeToClientLayerType(serverType) {\n                switch (serverType) {\n                    case 'Feature Layer':\n                        return shared.clientLayerType.ESRI_FEATURE;\n                    case 'Raster Layer':\n                        return shared.clientLayerType.ESRI_RASTER;\n                    default:\n                        console.warn('Unexpected layer type in serverLayerTypeToClientLayerType', serverType);\n                        return shared.clientLayerType.UNKNOWN;\n                }\n            };\n\n            // process each leaf we walked to in the processLayerInfo loop above\n            // idx is a string\n            leafsToInit.forEach(function (idx) {\n\n                var subC = subConfigs[idx].config;\n                var attribPackage = _this3._apiRef.attribs.loadServerAttribs(_this3._layer.url, idx, subC.outfields);\n                var dFC = new dynamicFC.DynamicFC(_this3, idx, attribPackage, subC);\n                dFC.highlightFeature = subC.highlightFeature;\n                _this3._featClasses[idx] = dFC;\n\n                // if we have a proxy watching this leaf, replace its placeholder with the real data\n                var leafProxy = _this3._proxies[idx];\n                if (leafProxy) {\n                    leafProxy.convertToDynamicLeaf(dFC);\n                }\n\n                // load real symbols into our source\n                loadPromises.push(dFC.loadSymbology());\n\n                // update asynchronous values\n                var pLD = dFC.getLayerData().then(function (ld) {\n                    dFC.layerType = serverLayerTypeToClientLayerType(ld.layerType);\n\n                    // if we didn't have an extent defined on the config, use the layer extent\n                    if (!dFC.extent) {\n                        dFC.extent = ld.extent;\n                    }\n\n                    dFC._scaleSet.minScale = ld.minScale;\n                    dFC._scaleSet.maxScale = ld.maxScale;\n\n                    dFC.nameField = subC.nameField || ld.nameField || '';\n\n                    // skip a number of things if it is a raster layer\n                    // either way, return a promise so our loadPromises have a good\n                    // value to wait on.\n                    if (dFC.layerType === shared.clientLayerType.ESRI_FEATURE) {\n                        dFC.geomType = ld.geometryType;\n\n                        return _this3.getFeatureCount(idx).then(function (fc) {\n                            dFC.featureCount = fc;\n                        });\n                    } else {\n                        return Promise.resolve();\n                    }\n                }).catch(function () {\n                    dFC.layerType = shared.clientLayerType.UNRESOLVED;\n                });\n                loadPromises.push(pLD);\n            });\n\n            // TODO careful now, as the dynamicFC.DynamicFC constructor also appears to be setting visibility on the parent.\n            if (this._configIsComplete) {\n                // if we have a complete config, want to set layer visibility\n                // get an array of leaf ids that are visible.\n                // use _featClasses as it contains keys that exist on the server and are\n                // potentially visible in the client.\n                var initVis = Object.keys(this._featClasses).filter(function (fcId) {\n                    return fetchSubConfig(fcId).config.state.visibility;\n                }).map(function (fcId) {\n                    return parseInt(fcId);\n                });\n\n                if (initVis.length === 0) {\n                    initVis.push(-1); // esri code for set all to invisible\n                }\n                this._layer.setVisibleLayers(initVis);\n            } else {\n                // default configuration for non-complete config.\n                this._layer.setVisibility(false);\n                this._layer.setVisibleLayers([-1]);\n            }\n\n            Promise.all(loadPromises).then(function () {\n                _this3._stateChange(shared.states.LOADED);\n            });\n        }\n\n        // override to add child index parameter\n\n    }, {\n        key: 'zoomToScale',\n        value: function zoomToScale(childIdx, map, lods, zoomIn) {\n            var zoomGraphic = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n            // get scale set from child, then execute zoom\n            var scaleSet = this._featClasses[childIdx].getScaleSet();\n            return this._zoomToScaleSet(map, lods, zoomIn, scaleSet, zoomGraphic);\n        }\n    }, {\n        key: 'isOffScale',\n        value: function isOffScale(childIdx, mapScale) {\n            return this._featClasses[childIdx].isOffScale(mapScale);\n        }\n    }, {\n        key: 'isQueryable',\n        value: function isQueryable(childIdx) {\n            return this._featClasses[childIdx].queryable;\n        }\n\n        // TODO if we need this back, may need to implement as getChildGeomType.\n        //      appears this ovverrides the LayerRecord.getGeomType function, which returns\n        //      undefined, and that is what we want on the DynamicRecord level (as dynamic layer)\n        //      has no geometry.\n        //      Currently, all child requests for geometry go through the proxy,\n        //      so could be this child-targeting version is irrelevant.\n        /*\r\n        getGeomType (childIdx) {\r\n            return this._featClasses[childIdx].geomType;\r\n        }\r\n        */\n\n    }, {\n        key: 'getChildTree',\n        value: function getChildTree() {\n            if (this._childTree) {\n                return this._childTree;\n            } else {\n                throw new Error('Called getChildTree before layer is loaded');\n            }\n        }\n\n        /**\r\n         * Get the best user-friendly name of a field. Uses alias if alias is defined, else uses the system attribute name.\r\n         *\r\n         * @param {String} attribName     the attribute name we want a nice name for\r\n         * @param {String}  childIndex    index of the child layer whos attributes we are looking at\r\n         * @return {Promise}              resolves to the best available user friendly attribute name\r\n         */\n\n    }, {\n        key: 'aliasedFieldName',\n        value: function aliasedFieldName(attribName, childIndex) {\n            return this._featClasses[childIndex].aliasedFieldName(attribName);\n        }\n\n        /**\r\n         * Retrieves attributes from a layer for a specified feature index\r\n         * @param {String}  childIndex  index of the child layer to get attributes for\r\n         * @return {Promise}            promise resolving with formatted attributes to be consumed by the datagrid and esri feature identify\r\n         */\n\n    }, {\n        key: 'getFormattedAttributes',\n        value: function getFormattedAttributes(childIndex) {\n            return this._featClasses[childIndex].getFormattedAttributes();\n        }\n    }, {\n        key: 'fetchGraphic',\n        value: function fetchGraphic(childIndex, objId) {\n            var ignoreLocal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n            return this._featClasses[childIndex].fetchGraphic(objId, ignoreLocal);\n        }\n\n        /**\r\n         * Check to see if the attribute in question is an esriFieldTypeDate type.\r\n         *\r\n         * @param {String} attribName     the attribute name we want to check if it's a date or not\r\n         * @param {String}  childIndex    index of the child layer whos attributes we are looking at\r\n         * @return {Promise}              resolves to true or false based on the attribName type being esriFieldTypeDate\r\n         */\n\n    }, {\n        key: 'checkDateType',\n        value: function checkDateType(attribName, childIndex) {\n            return this._featClasses[childIndex].checkDateType(attribName);\n        }\n\n        /**\r\n        * Returns attribute data for a child layer.\r\n        *\r\n        * @function getAttribs\r\n        * @param {String} childIndex  the index of the child layer\r\n        * @returns {Promise}          resolves with a layer attribute data object\r\n        */\n\n    }, {\n        key: 'getAttribs',\n        value: function getAttribs(childIndex) {\n            return this._featClasses[childIndex].getAttribs();\n        }\n\n        /**\r\n        * Returns layer-specific data for a child layer\r\n        *\r\n        * @function getLayerData\r\n        * @param {String} childIndex  the index of the child layer\r\n        * @returns {Promise}          resolves with a layer data object\r\n        */\n\n    }, {\n        key: 'getLayerData',\n        value: function getLayerData(childIndex) {\n            return this._featClasses[childIndex].getLayerData();\n        }\n    }, {\n        key: 'getFeatureName',\n        value: function getFeatureName(childIndex, objId, attribs) {\n            return this._featClasses[childIndex].getFeatureName(objId, attribs);\n        }\n    }, {\n        key: 'getSymbology',\n        value: function getSymbology(childIndex) {\n            return this._featClasses[childIndex].symbology;\n        }\n\n        /**\r\n        * Run a query on a dynamic layer, return the result as a promise.\r\n        * @function identify\r\n        * @param {Object} opts additional argumets like map object, clickEvent, etc.\r\n        * @returns {Object} an object with identify results array and identify promise resolving when identify is complete; if an empty object is returned, it will be skipped\r\n        */\n\n    }, {\n        key: 'identify',\n        value: function identify(opts) {\n            var _this4 = this;\n\n            // TODO add full documentation for options parameter\n\n            // bundles results from all leaf layers\n            var identifyResults = [];\n\n            if (!shared.layerLoaded(this.state)) {\n                opts.layerIds = []; // quick quit\n            } else {\n                opts.layerIds = this._layer.visibleLayers.filter(function (leafIndex) {\n                    if (leafIndex === -1) {\n                        // this is marker for nothing is visible. get rid of it\n                        return false;\n                    } else {\n                        var fc = _this4._featClasses[leafIndex];\n                        if (fc) {\n                            // keep if it is queryable and on-scale\n                            return fc.queryable && !fc.isOffScale(opts.map.getScale()).offScale;\n                        } else {\n                            // we dont have a feature class for this id.\n                            //  it is likely a a group or something visible but not active\n                            return false;\n                        }\n                    }\n                });\n            }\n\n            // if there are no layerIds to inspect, don't hit the server\n            if (opts.layerIds.length === 0) {\n                // TODO verifiy this is correct result format if layer should be excluded from the identify process\n                return { identifyResults: [], identifyPromise: Promise.resolve() };\n            }\n\n            opts.layerIds.forEach(function (leafIndex) {\n                var identifyResult = new shared.IdentifyResult(_this4.getChildProxy(leafIndex));\n                identifyResults[leafIndex] = identifyResult;\n            });\n\n            // TODO verify if 0 is valid click tolerance. if so, need to address falsy logic.\n            opts.tolerance = opts.tolerance || this.clickTolerance || 5;\n\n            var identifyPromise = this._apiRef.layer.serverLayerIdentify(this._layer, opts).then(function (clickResults) {\n                var hitIndexes = []; // sublayers that we got results for\n\n                // transform attributes of click results into {name,data} objects\n                // one object per identified feature\n                //\n                // each feature will have its attributes converted into a table\n                // placeholder for now until we figure out how to signal the panel that\n                // we want to make a nice table\n                clickResults.forEach(function (ele) {\n                    // NOTE: the identify service returns aliased field names, so no need to look them up here.\n                    //       however, this means we need to un-alias the data when doing field lookups.\n                    // NOTE: ele.layerId is what we would call featureIdx\n                    hitIndexes.push(ele.layerId);\n\n                    // get metadata about this sublayer\n                    _this4.getLayerData(ele.layerId).then(function (lData) {\n                        var identifyResult = identifyResults[ele.layerId];\n\n                        if (lData.supportsFeatures) {\n                            var unAliasAtt = attribFC.AttribFC.unAliasAttribs(ele.feature.attributes, lData.fields);\n\n                            // TODO traditionally, we did not pass fields into attributesToDetails as data was\n                            //      already aliased from the server. now, since we are extracting field type as\n                            //      well, this means things like date formatting might not be applied to\n                            //      identify results. examine the impact of providing the fields parameter\n                            //      to data that is already aliased.\n                            identifyResult.data.push({\n                                name: ele.value,\n                                data: _this4.attributesToDetails(ele.feature.attributes),\n                                oid: unAliasAtt[lData.oidField],\n                                symbology: [{\n                                    svgcode: _this4._apiRef.symbology.getGraphicIcon(unAliasAtt, lData.renderer)\n                                }]\n                            });\n                        }\n                        identifyResult.isLoading = false;\n                    });\n                });\n\n                // set the rest of the entries to loading false\n                identifyResults.forEach(function (identifyResult) {\n                    if (hitIndexes.indexOf(identifyResult.requester.featureIdx) === -1) {\n                        identifyResult.isLoading = false;\n                    }\n                });\n            });\n\n            return {\n                identifyResults: identifyResults.filter(function (identifyResult) {\n                    return identifyResult;\n                }), // collapse sparse array\n                identifyPromise: identifyPromise\n            };\n        }\n\n        // TODO docs\n\n    }, {\n        key: 'getChildName',\n        value: function getChildName(index) {\n            // TODO revisit logic. is this the best way to do this? what are the needs of the consuming code?\n            // TODO restructure so WMS can use this too?\n            // will not use FC classes, as we also need group names\n            return this._layer.layerInfos[index].name;\n        }\n\n        // TODO we may want version of layerRecord.zoomToBoundary that targets a child index.\n        //      alternately this might go on the proxy and then we go direct from there.\n\n    }]);\n\n    return DynamicRecord;\n}(attribRecord.AttribRecord);\n\nmodule.exports = function () {\n    return {\n        DynamicRecord: DynamicRecord\n    };\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXIvbGF5ZXJSZWMvZHluYW1pY1JlY29yZC5qcz9iNjRkIl0sIm5hbWVzIjpbImF0dHJpYlJlY29yZCIsInJlcXVpcmUiLCJzaGFyZWQiLCJwbGFjZWhvbGRlckZDIiwibGF5ZXJJbnRlcmZhY2UiLCJkeW5hbWljRkMiLCJhdHRyaWJGQyIsIkR5bmFtaWNSZWNvcmQiLCJjbGllbnRMYXllclR5cGUiLCJFU1JJX0RZTkFNSUMiLCJfaXNUcnVlRHluYW1pYyIsImxheWVyQ2xhc3MiLCJlc3JpUmVxdWVzdCIsImFwaVJlZiIsImNvbmZpZyIsImVzcmlMYXllciIsImVwc2dMb29rdXAiLCJjb25maWdJc0NvbXBsZXRlIiwiQXJjR0lTRHluYW1pY01hcFNlcnZpY2VMYXllciIsIl9jb25maWdJc0NvbXBsZXRlIiwiX3Byb3hpZXMiLCJmZWF0dXJlSWR4Iiwic3RySWR4IiwidG9TdHJpbmciLCJwZmMiLCJQbGFjZWhvbGRlckZDIiwidFByb3h5IiwiTGF5ZXJJbnRlcmZhY2UiLCJjb252ZXJ0VG9QbGFjZWhvbGRlciIsIl9sYXllciIsInVybCIsIm9wYWNpdHkiLCJPYmplY3QiLCJrZXlzIiwiX2ZlYXRDbGFzc2VzIiwiZm9yRWFjaCIsImZjIiwiaWR4IiwiX29wYWNpdHkiLCJsb2FkUHJvbWlzZXMiLCJzdXBwb3J0c0R5bmFtaWNMYXllcnMiLCJkdW1teVN0YXRlIiwidmlzaWJpbGl0eSIsInF1ZXJ5IiwiY2xvbmVDb25maWciLCJjbG9uZSIsIm5hbWUiLCJvcmlnQ29uZmlnIiwiaW5kZXgiLCJzdGF0ZU9ubHkiLCJuYW1lRmllbGQiLCJoaWdobGlnaHRGZWF0dXJlIiwib3V0ZmllbGRzIiwiaGFzT3duUHJvcGVydHkiLCJzdGF0ZSIsInZpc2libGl0eSIsImFzc2lnbiIsImV4dGVudCIsInN1YkNvbmZpZ3MiLCJsYXllckVudHJpZXMiLCJsZSIsImRlZmF1bHRlZCIsImZldGNoU3ViQ29uZmlnIiwiaWQiLCJzZXJ2ZXJOYW1lIiwic3ViQyIsImNvbmZpZ1NlZWQiLCJwYXJzZUludCIsIm5ld0NvbmZpZyIsImxlYWZzVG9Jbml0IiwicHJvY2Vzc0xheWVySW5mbyIsImxheWVySW5mbyIsInRyZWVBcnJheSIsInNJZCIsInN1YkxheWVySWRzIiwibGVuZ3RoIiwidHJlZUdyb3VwIiwiZW50cnlJbmRleCIsImNoaWxkcyIsInB1c2giLCJsYXllckluZm9zIiwic2xpZCIsInVwZGF0ZVNvdXJjZSIsImxlYWZQcm94eSIsIl9jaGlsZFRyZWUiLCJzZXJ2ZXJMYXllclR5cGVUb0NsaWVudExheWVyVHlwZSIsInNlcnZlclR5cGUiLCJFU1JJX0ZFQVRVUkUiLCJFU1JJX1JBU1RFUiIsImNvbnNvbGUiLCJ3YXJuIiwiVU5LTk9XTiIsImF0dHJpYlBhY2thZ2UiLCJfYXBpUmVmIiwiYXR0cmlicyIsImxvYWRTZXJ2ZXJBdHRyaWJzIiwiZEZDIiwiRHluYW1pY0ZDIiwiY29udmVydFRvRHluYW1pY0xlYWYiLCJsb2FkU3ltYm9sb2d5IiwicExEIiwiZ2V0TGF5ZXJEYXRhIiwidGhlbiIsImxheWVyVHlwZSIsImxkIiwiX3NjYWxlU2V0IiwibWluU2NhbGUiLCJtYXhTY2FsZSIsImdlb21UeXBlIiwiZ2VvbWV0cnlUeXBlIiwiZ2V0RmVhdHVyZUNvdW50IiwiZmVhdHVyZUNvdW50IiwiUHJvbWlzZSIsInJlc29sdmUiLCJjYXRjaCIsIlVOUkVTT0xWRUQiLCJpbml0VmlzIiwiZmlsdGVyIiwiZmNJZCIsIm1hcCIsInNldFZpc2libGVMYXllcnMiLCJzZXRWaXNpYmlsaXR5IiwiYWxsIiwiX3N0YXRlQ2hhbmdlIiwic3RhdGVzIiwiTE9BREVEIiwiY2hpbGRJZHgiLCJsb2RzIiwiem9vbUluIiwiem9vbUdyYXBoaWMiLCJzY2FsZVNldCIsImdldFNjYWxlU2V0IiwiX3pvb21Ub1NjYWxlU2V0IiwibWFwU2NhbGUiLCJpc09mZlNjYWxlIiwicXVlcnlhYmxlIiwiRXJyb3IiLCJhdHRyaWJOYW1lIiwiY2hpbGRJbmRleCIsImFsaWFzZWRGaWVsZE5hbWUiLCJnZXRGb3JtYXR0ZWRBdHRyaWJ1dGVzIiwib2JqSWQiLCJpZ25vcmVMb2NhbCIsImZldGNoR3JhcGhpYyIsImNoZWNrRGF0ZVR5cGUiLCJnZXRBdHRyaWJzIiwiZ2V0RmVhdHVyZU5hbWUiLCJzeW1ib2xvZ3kiLCJvcHRzIiwiaWRlbnRpZnlSZXN1bHRzIiwibGF5ZXJMb2FkZWQiLCJsYXllcklkcyIsInZpc2libGVMYXllcnMiLCJsZWFmSW5kZXgiLCJnZXRTY2FsZSIsIm9mZlNjYWxlIiwiaWRlbnRpZnlQcm9taXNlIiwiaWRlbnRpZnlSZXN1bHQiLCJJZGVudGlmeVJlc3VsdCIsImdldENoaWxkUHJveHkiLCJ0b2xlcmFuY2UiLCJjbGlja1RvbGVyYW5jZSIsImxheWVyIiwic2VydmVyTGF5ZXJJZGVudGlmeSIsImhpdEluZGV4ZXMiLCJjbGlja1Jlc3VsdHMiLCJlbGUiLCJsYXllcklkIiwibERhdGEiLCJzdXBwb3J0c0ZlYXR1cmVzIiwidW5BbGlhc0F0dCIsIkF0dHJpYkZDIiwidW5BbGlhc0F0dHJpYnMiLCJmZWF0dXJlIiwiYXR0cmlidXRlcyIsImZpZWxkcyIsImRhdGEiLCJ2YWx1ZSIsImF0dHJpYnV0ZXNUb0RldGFpbHMiLCJvaWQiLCJvaWRGaWVsZCIsInN2Z2NvZGUiLCJnZXRHcmFwaGljSWNvbiIsInJlbmRlcmVyIiwiaXNMb2FkaW5nIiwiaW5kZXhPZiIsInJlcXVlc3RlciIsIkF0dHJpYlJlY29yZCIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7QUFFQSxJQUFNQSxlQUFlLG1CQUFBQyxDQUFRLEVBQVIsR0FBckI7QUFDQSxJQUFNQyxTQUFTLG1CQUFBRCxDQUFRLENBQVIsR0FBZjtBQUNBLElBQU1FLGdCQUFnQixtQkFBQUYsQ0FBUSxDQUFSLEdBQXRCO0FBQ0EsSUFBTUcsaUJBQWlCLG1CQUFBSCxDQUFRLEVBQVIsR0FBdkI7QUFDQSxJQUFNSSxZQUFZLG1CQUFBSixDQUFRLEVBQVIsR0FBbEI7QUFDQSxJQUFNSyxXQUFX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QU13SCxJQUFJVyxLQURXO0FBRXJCRCxzQ0FBTSxPQUFLRSxtQkFBTCxDQUF5QlosSUFBSU8sT0FBSixDQUFZQyxVQUFyQyxDQUZlO0FBR3JCSyxxQ0FBS1QsV0FBV0YsTUFBTVksUUFBakIsQ0FIZ0I7QUFJckJqQywyQ0FBVyxDQUFDO0FBQ1JrQyw2Q0FBUyxPQUFLeEYsT0FBTCxDQUFhc0QsU0FBYixDQUF1Qm1DLGNBQXZCLENBQXNDWixVQUF0QyxFQUFrREYsTUFBTWUsUUFBeEQ7QUFERCxpQ0FBRDtBQUpVLDZCQUF6QjtBQVFIO0FBQ0QxQix1Q0FBZTJCLFNBQWYsR0FBMkIsS0FBM0I7QUFDSCxxQkFyQkQ7QUFzQkgsaUJBN0JEOztBQStCQTtBQUNBbkMsZ0NBQWdCbEgsT0FBaEIsQ0FBd0IsMEJBQWtCO0FBQ3RDLHdCQUFJaUksV0FBV3FCLE9BQVgsQ0FBbUI1QixlQUFlNkIsU0FBZixDQUF5QnJLLFVBQTVDLE1BQTRELENBQUMsQ0FBakUsRUFBb0U7QUFDaEV3SSx1Q0FBZTJCLFNBQWYsR0FBMkIsS0FBM0I7QUFDSDtBQUNKLGlCQUpEO0FBTUgsYUFoRG1CLENBQXhCOztBQWtEQSxtQkFBTztBQUNIbkMsaUNBQWlCQSxnQkFBZ0JoQyxNQUFoQixDQUF1QjtBQUFBLDJCQUFrQndDLGNBQWxCO0FBQUEsaUJBQXZCLENBRGQsRUFDd0U7QUFDM0VEO0FBRkcsYUFBUDtBQUlIOztBQUVEOzs7O3FDQUNjNUcsSyxFQUFPO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLG1CQUFPLEtBQUtuQixNQUFMLENBQVltRCxVQUFaLENBQXVCaEMsS0FBdkIsRUFBOEJGLElBQXJDO0FBQ0g7O0FBRUQ7QUFDQTs7Ozs7RUE3a0J3QjlDLGFBQWEyTCxZOztBQWlsQnpDQyxPQUFPQyxPQUFQLEdBQWlCO0FBQUEsV0FBTztBQUNwQnRMO0FBRG9CLEtBQVA7QUFBQSxDQUFqQiIsImZpbGUiOiI4My5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuXHJcbmNvbnN0IGF0dHJpYlJlY29yZCA9IHJlcXVpcmUoJy4vYXR0cmliUmVjb3JkLmpzJykoKTtcclxuY29uc3Qgc2hhcmVkID0gcmVxdWlyZSgnLi9zaGFyZWQuanMnKSgpO1xyXG5jb25zdCBwbGFjZWhvbGRlckZDID0gcmVxdWlyZSgnLi9wbGFjZWhvbGRlckZDLmpzJykoKTtcclxuY29uc3QgbGF5ZXJJbnRlcmZhY2UgPSByZXF1aXJlKCcuL2xheWVySW50ZXJmYWNlLmpzJykoKTtcclxuY29uc3QgZHluYW1pY0ZDID0gcmVxdWlyZSgnLi9keW5hbWljRkMuanMnKSgpO1xyXG5jb25zdCBhdHRyaWJGQyA9IHJlcXVpcmUoJy4vYXR0cmliRkMuanMnKSgpO1xyXG5cclxuLyoqXHJcbiAqIEBjbGFzcyBEeW5hbWljUmVjb3JkXHJcbiAqL1xyXG5jbGFzcyBEeW5hbWljUmVjb3JkIGV4dGVuZHMgYXR0cmliUmVjb3JkLkF0dHJpYlJlY29yZCB7XHJcbiAgICAvLyBUT0RPIGFyZSB3ZSBzdGlsbCB1c2luZyBwYXNzdGhyb3VnaCBzdHVmZj9cclxuICAgIGdldCBfbGF5ZXJQYXNzdGhyb3VnaEJpbmRpbmdzICgpIHtcclxuICAgICAgICByZXR1cm4gWydzZXRPcGFjaXR5JywgJ3NldFZpc2liaWxpdHknLCAnc2V0VmlzaWJsZUxheWVycycsICdzZXRMYXllckRyYXdpbmdPcHRpb25zJ107XHJcbiAgICB9XHJcbiAgICBnZXQgX2xheWVyUGFzc3Rocm91Z2hQcm9wZXJ0aWVzICgpIHtcclxuICAgICAgICByZXR1cm4gWyd2aXNpYmxlQXRNYXBTY2FsZScsICd2aXNpYmxlJywgJ3NwYXRpYWxSZWZlcmVuY2UnLCAnbGF5ZXJJbmZvcycsICdzdXBwb3J0c0R5bmFtaWNMYXllcnMnXTtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgbGF5ZXJUeXBlICgpIHsgcmV0dXJuIHNoYXJlZC5jbGllbnRMYXllclR5cGUuRVNSSV9EWU5BTUlDOyB9XHJcbiAgICBnZXQgaXNUcnVlRHluYW1pYyAoKSB7IHJldHVybiB0aGlzLl9pc1RydWVEeW5hbWljOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBsYXllciByZWNvcmQgd2l0aCB0aGUgYXBwcm9wcmlhdGUgZ2VvQXBpIGxheWVyIHR5cGUuXHJcbiAgICAgKiBSZWdhcmRpbmcgY29uZmlndXJhdGlvbiAtLSBpbiB0aGUgc3RhbmRhcmQgY2FzZSwgdGhlIGluY29taW5nIGNvbmZpZyBvYmplY3RcclxuICAgICAqIHdpbGwgYmUgaW5jb21wbGV0ZSB3aXRoIHJlZ2FyZHMgdG8gY2hpbGQgc3RhdGUuIEl0IG1heSBub3QgZXZlbiBoYXZlIGVudHJpZXMgZm9yIGFsbCBwb3NzaWJsZVxyXG4gICAgICogY2hpbGQgc3ViLWxheWVycy4gIEdpdmVuIG91ciBjb25maWcgZGVmYXVsdGluZyBmb3IgY2hpbGRyZW4gaGFwcGVucyBBRlRFUiB0aGUgbGF5ZXIgbG9hZHMsXHJcbiAgICAgKiBpdCBtZWFucyB3aGF0IGlzIHBhc3NlZCBpbiBhdCB0aGUgY29uc3RydWN0b3IgaXMgZ2VuZXJhbGx5IHVucmVsaWFibGUgZXhjZXB0IGZvciBhbnkgY2hpbGQgbmFtZXMsXHJcbiAgICAgKiBhbmQgdGhlIGNsYXNzIHdpbGwgdHJlYXQgdGhhdCBpbmZvcm1hdGlvbiBhcyB1bnJlbGlhYmxlICh0aGUgVUkgd2lsbCBzZXQgdmFsdWVzIGFmdGVyIGNvbmZpZyBkZWZhdWx0aW5nXHJcbiAgICAgKiBoYXBwZW5zKS4gSW4gdGhlIHJhcmUgY2FzZSB3aGVyZSB0aGUgY29uZmlnIGlzIGZ1bGx5IGZvcm1lZCBhbmQgd2Ugd2FudCB0byB0YWtlIGFkdmFudGFnZSBvZiB0aGF0LFxyXG4gICAgICogc2V0IHRoZSBjb25maWdJc0NvbXBsZXRlIHBhcmFtIHRvIHRydWUuICBCZSBhd2FyZSB0aGF0IGlmIHRoZSBjb25maWcgaXMgbm90IGFjdHVhbGx5IGNvbXBsZXRlIHlvdSBtYXlcclxuICAgICAqIGdldCBhIGxheWVyIGluIGFuIHVuZGVzaXJlZCBpbml0aWFsIHN0YXRlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBsYXllckNsYXNzICAgICAgICAgdGhlIEVTUkkgYXBpIG9iamVjdCBmb3IgZHluYW1pYyBsYXllcnNcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlc3JpUmVxdWVzdCAgICAgICAgdGhlIEVTUkkgYXBpIG9iamVjdCBmb3IgbWFraW5nIHdlYiByZXF1ZXN0cyB3aXRoIHByb3h5IHN1cHBvcnRcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcGlSZWYgICAgICAgICAgICAgb2JqZWN0IHBvaW50aW5nIHRvIHRoZSBnZW9BcGkuIGFsbG93cyB1cyB0byBjYWxsIG90aGVyIGdlb0FwaSBmdW5jdGlvbnNcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgICAgICAgICAgICAgbGF5ZXIgY29uZmlnIHZhbHVlc1xyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVzcmlMYXllciAgICAgICAgICBhbiBvcHRpb25hbCBwcmUtY29uc3RydWN0ZWQgbGF5ZXJcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVwc2dMb29rdXAgICAgICAgYW4gb3B0aW9uYWwgbG9va3VwIGZ1bmN0aW9uIGZvciBFUFNHIGNvZGVzIChzZWUgZ2VvU2VydmljZSBmb3Igc2lnbmF0dXJlKVxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBjb25maWdJc0NvbXBsZXRlICBhbiBvcHRpb25hbCBmbGFnIHRvIGluZGljYXRlIGlmIHRoZSBjb25maWcgaXMgZnVsbHkgZmx1c2hlZCBvdXQgKGkuZS4gdGhpbmdzIGRlZmluZWQgZm9yIGFsbCBjaGlsZHJlbikuIERlZmF1bHRzIHRvIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvciAobGF5ZXJDbGFzcywgZXNyaVJlcXVlc3QsIGFwaVJlZiwgY29uZmlnLCBlc3JpTGF5ZXIsIGVwc2dMb29rdXAsIGNvbmZpZ0lzQ29tcGxldGUgPSBmYWxzZSkge1xyXG4gICAgICAgIC8vIFRPRE8gbWlnaHQgbmVlZCBzb21lIG5vbnNlbnNlIGhlcmUuIGlmIG5vdCBjb25maWdJc0NvbXBsZXRlLCBhbmQgbGF5ZXIgaXMgc2V0IHRvIHZpc2libGUgaW4gY29uZmlnLFxyXG4gICAgICAgIC8vICAgICAgd2UgbWF5IG5lZWQgdG8gaGFjayB0aGUgcHJvY2VzcyBzbyB0aGF0IHRoZSBlc3JpIGxheWVyIG9iamVjdCBpcyBpbml0aWFsaXplZCBhcyBpbnZpc2libGUsXHJcbiAgICAgICAgLy8gICAgICBidXQgdGhlIGNvbmZpZyBpcyBzdGlsbCBtYXJrZWQgYXMgdmlzaWJsZSBzbyB0aGUgVUkga25vd3MgdG8gZG8gdGhlIHByb3BlciBkZWZhdWx0aW5nLlxyXG4gICAgICAgIC8vICAgICAgQXMgaXMgcmlnaHQgbm93LCB0aGUgbGF5ZXIgbWlnaHQgc3RhcnQgdG8gcHVsbCBhbiBpbWFnZSBmcm9tIHRoZSBzZXJ2ZXIgd2hpbGUgb3VyIG9uTG9hZFxyXG4gICAgICAgIC8vICAgICAgZXZlbnQgaGFuZGxlciBpcyBydW5uaW5nIGFuZCBzaHV0dGluZyBvZmYgdmlzaWJpbGl0aWVzLlxyXG4gICAgICAgIHN1cGVyKGxheWVyQ2xhc3MsIGVzcmlSZXF1ZXN0LCBhcGlSZWYsIGNvbmZpZywgZXNyaUxheWVyLCBlcHNnTG9va3VwKTtcclxuICAgICAgICB0aGlzLkFyY0dJU0R5bmFtaWNNYXBTZXJ2aWNlTGF5ZXIgPSBsYXllckNsYXNzO1xyXG4gICAgICAgIHRoaXMuX2NvbmZpZ0lzQ29tcGxldGUgPSBjb25maWdJc0NvbXBsZXRlO1xyXG5cclxuICAgICAgICAvLyBUT0RPIHdoYXQgaXMgdGhlIGNhc2Ugd2hlcmUgd2UgaGF2ZSBkeW5hbWljIGxheWVyIGFscmVhZHkgcHJlcGFyZWRcclxuICAgICAgICAvLyAgICAgIGFuZCBwYXNzZWQgaW4/IEdlbmVyYWxseSB0aGlzIG9ubHkgYXBwbGllcyB0byBmaWxlIGxheWVycyAod2hpY2hcclxuICAgICAgICAvLyAgICAgIGFyZSBmZWF0dXJlIGxheWVycykuXHJcblxyXG4gICAgICAgIHRoaXMuX3Byb3hpZXMgPSB7fTtcclxuXHJcbiAgICAgICAgLy8gbWFya3MgaWYgbGF5ZXIgc3VwcG9ydHMgZHluYW1pYyBjYXBhYmlsaXRpZXMsIGxpa2UgY2hpbGQgb3BhY2l0eSwgcmVuZGVyZXIgY2hhbmdlLCBsYXllciByZW9yZGVyXHJcbiAgICAgICAgLy8gVE9ETyBlbnN1cmUgZmFsc2UgaXMgYmVzdCBkZWZhdWx0ICh3aGF0IGlzIGJldHRlciBmb3IgVUkpXHJcbiAgICAgICAgdGhpcy5faXNUcnVlRHluYW1pYyA9IGZhbHNlO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBhIHByb3h5IGludGVyZmFjZSBmb3IgYSBjaGlsZCBsYXllclxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gZmVhdHVyZUlkeCAgICBpbmRleCBvZiBjaGlsZCBlbnRyeSAobGVhZiBvciBncm91cClcclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICAgICBwcm94eSBpbnRlcmZhY2UgZm9yIGdpdmVuIGNoaWxkXHJcbiAgICAgKi9cclxuICAgIGdldENoaWxkUHJveHkgKGZlYXR1cmVJZHgpIHtcclxuICAgICAgICAvLyBUT0RPIHZlcmlmeSB3ZSBoYXZlIGludGVnZXIgY29taW5nIGluIGFuZCBub3QgYSBzdHJpbmdcclxuICAgICAgICAvLyBOT1RFIHdlIG5vIGxvbmdlciBoYXZlIGdyb3VwIHByb3hpZXMuIFNpbmNlIGl0IGlzIHBvc3NpYmxlIGZvciBhIHByb3h5IHRvXHJcbiAgICAgICAgLy8gICAgICBiZSByZXF1ZXN0ZWQgcHJpb3IgdG8gYSBkeW5hbWljIGxheWVyIGJlaW5nIGxvYWRlZCAoYW5kIHRodXMgaGF2ZSBub1xyXG4gICAgICAgIC8vICAgICAgaWRlYSBvZiB0aGUgaW5kZXggaXMgdmFsaWQgb3IgdGhlIGluZGV4IGlzIGEgZ3JvdXApLCB3ZSBhbHdheXMgZ2l2ZVxyXG4gICAgICAgIC8vICAgICAgYSBwcm94eSBhbmQgZGVwZW5kIG9uIHRoZSBjYWxsZXIgdG8gYmUgc21hcnQgYWJvdXQgaXQuXHJcblxyXG4gICAgICAgIGNvbnN0IHN0cklkeCA9IGZlYXR1cmVJZHgudG9TdHJpbmcoKTtcclxuICAgICAgICBpZiAodGhpcy5fcHJveGllc1tzdHJJZHhdKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcm94aWVzW3N0cklkeF07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gdGhyb3cgbmV3IEVycm9yKGBhdHRlbXB0IHRvIGdldCBub24tZXhpc3RpbmcgY2hpbGQgcHJveHkuIEluZGV4ICR7ZmVhdHVyZUlkeH1gKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHRvIGhhbmRsZSB0aGUgY2FzZSBvZiBhIHN0cnVjdHVyZWQgbGVnZW5kIG5lZWRpbmcgYSBwcm94eSBmb3IgYSBjaGlsZCBwcmlvciB0byB0aGVcclxuICAgICAgICAgICAgLy8gbGF5ZXIgbG9hZGluZywgd2UgdHJlYXQgYW4gdW5rbm93biBwcm94eSByZXF1ZXN0IGFzIHRoYXQgY2FzZSBhbmQgcmV0dXJuXHJcbiAgICAgICAgICAgIC8vIGEgcHJveHkgbG9hZGVkIHdpdGggYSBwbGFjZWhvbGRlci5cclxuICAgICAgICAgICAgLy8gVE9ETyBob3cgdG8gcGFzcyBpbiBhIG5hbWU/IGFkZCBhbiBvcHRpb25hbCBzZWNvbmQgcGFyYW1ldGVyPyBleHBvc2UgYSBcInNldCBuYW1lXCIgb24gdGhlIHByb3h5P1xyXG4gICAgICAgICAgICBjb25zdCBwZmMgPSBuZXcgcGxhY2Vob2xkZXJGQy5QbGFjZWhvbGRlckZDKHRoaXMsICcnKTtcclxuICAgICAgICAgICAgY29uc3QgdFByb3h5ID0gbmV3IGxheWVySW50ZXJmYWNlLkxheWVySW50ZXJmYWNlKHBmYyk7XHJcbiAgICAgICAgICAgIHRQcm94eS5jb252ZXJ0VG9QbGFjZWhvbGRlcihwZmMpO1xyXG4gICAgICAgICAgICB0aGlzLl9wcm94aWVzW3N0cklkeF0gPSB0UHJveHk7XHJcbiAgICAgICAgICAgIHJldHVybiB0UHJveHk7XHJcblxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBUT0RPIGRvY3NcclxuICAgIGdldEZlYXR1cmVDb3VudCAoZmVhdHVyZUlkeCkge1xyXG4gICAgICAgIC8vIHBvaW50IHVybCB0byBzdWItaW5kZXggd2Ugd2FudFxyXG4gICAgICAgIC8vIFRPRE8gbWlnaHQgY2hhbmdlIGhvdyB3ZSBtYW5hZ2UgaW5kZXggYW5kIHVybFxyXG4gICAgICAgIHJldHVybiBzdXBlci5nZXRGZWF0dXJlQ291bnQodGhpcy5fbGF5ZXIudXJsICsgJy8nICsgZmVhdHVyZUlkeCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVE9ETyBkb2NzXHJcbiAgICBzeW5jaE9wYWNpdHkgKG9wYWNpdHkpIHtcclxuICAgICAgICAvLyBpbiB0aGUgY2FzZSB3aGVyZSBhIGR5bmFtaWMgbGF5ZXIgZG9lcyBub3Qgc3VwcG9ydCBjaGlsZCBvcGFjaXR5LCBpZiBhIHVzZXJcclxuICAgICAgICAvLyBjaGFuZ2VzIHRoZSBvcGFjaXR5IG9mIGEgY2hpbGQsIGl0IGFjdHVhbGx5IGp1c3QgYWRqdXN0cyB0aGUgb3BhY2l0eSBvZiB0aGUgbGF5ZXIuXHJcbiAgICAgICAgLy8gdGhpcyBtZWFucyB0aGF0IGFsbCBvdGhlciBjaGlsZHJlbiBvZiB0aGUgbGF5ZXIgbmVlZCB0byBoYXZlIHRoZWlyIG9wYWNpdHkgc2V0XHJcbiAgICAgICAgLy8gdG8gdGhlIHNhbWUgdmFsdWUuIGJ1dCB3ZSBkb250IHdhbnQgdG8gdHJpZ2dlciBhIG51bWJlciBvZiBvcGFjaXR5IGNoYW5nZSByZXF1ZXN0cyxcclxuICAgICAgICAvLyBzbyB3ZSBkbyBzb21lIHRyaWNrZXJ5IGhlcmUuXHJcblxyXG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX2ZlYXRDbGFzc2VzKS5mb3JFYWNoKGlkeCA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZjID0gdGhpcy5fZmVhdENsYXNzZXNbaWR4XTtcclxuICAgICAgICAgICAgaWYgKGZjKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpbXBvcnRhbnQ6IG11c3QgdXNlIHRoZSBwcml2YXRlIC5fb3BhY2l0eSBwcm9wZXJ0eSBoZXJlLFxyXG4gICAgICAgICAgICAgICAgLy8gYXMgd2Ugd2FudCB0byBhdm9pZCB0aGUgbG9naWMgb24gdGhlIC5vcGFjaXR5IHNldHRlci5cclxuICAgICAgICAgICAgICAgIGZjLl9vcGFjaXR5ID0gb3BhY2l0eTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyB1cGRhdGUgdGhlIGxheWVyIGl0c2VsZi5cclxuICAgICAgICB0aGlzLm9wYWNpdHkgPSBvcGFjaXR5O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBUcmlnZ2VycyB3aGVuIHRoZSBsYXllciBsb2Fkcy5cclxuICAgICpcclxuICAgICogQGZ1bmN0aW9uIG9uTG9hZFxyXG4gICAgKi9cclxuICAgIG9uTG9hZCAoKSB7XHJcbiAgICAgICAgY29uc3QgbG9hZFByb21pc2VzID0gc3VwZXIub25Mb2FkKCk7XHJcbiAgICAgICAgdGhpcy5faXNUcnVlRHluYW1pYyA9IHRoaXMuX2xheWVyLnN1cHBvcnRzRHluYW1pY0xheWVycztcclxuXHJcbiAgICAgICAgLy8gZG9uJ3Qgd29ycnkgYWJvdXQgc3RydWN0dXJlZCBsZWdlbmQuIHRoZSBsZWdlbmQgcGFydCBpcyBzZXBhcmF0ZSBmcm9tXHJcbiAgICAgICAgLy8gdGhlIGxheWVycyBwYXJ0LiB3ZSBqdXN0IGxvYWQgd2hhdCB3ZSBhcmUgdG9sZCB0by4gdGhlIGxlZ2VuZCBtb2R1bGVcclxuICAgICAgICAvLyB3aWxsIGhhbmRsZSB0aGUgc3RydWN0dXJlZCBwYXJ0LlxyXG5cclxuICAgICAgICAvLyBzZWUgY29tbWVudHMgb24gdGhlIGNvbnN0cnVjdG9yIHRvIGxlYXJuIGFib3V0IF9jb25maWdJc0NvbXBsZXRlIGFuZFxyXG4gICAgICAgIC8vIHdoYXQgdHlwZSBvZiBzY2VuYXJpb3MgeW91IGNhbiBleHBlY3QgZm9yIGluY29taW5nIGNvbmZpZ3NcclxuXHJcbiAgICAgICAgLy8gc25hcHNob3QgZG9lc24ndCBhcHBseSB0byBjaGlsZCBsYXllcnNcclxuICAgICAgICAvLyB3ZSBkb24ndCBpbmNsdWRlIGJvdW5kaW5nIGJveCAvIGV4dGVudCwgYXMgd2UgYXJlIGluaGVyaXRpbmcgaXQuXHJcbiAgICAgICAgLy8gYSBsYWNrIG9mIHRoZSBwcm9wZXJ0eSBtZWFucyB3ZSB1c2UgdGhlIGxheWVyIGRlZmluaXRpb25cclxuICAgICAgICBjb25zdCBkdW1teVN0YXRlID0ge1xyXG4gICAgICAgICAgICBvcGFjaXR5OiAxLFxyXG4gICAgICAgICAgICB2aXNpYmlsaXR5OiBmYWxzZSxcclxuICAgICAgICAgICAgcXVlcnk6IGZhbHNlXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gc3ViZnVuY3Rpb24gdG8gY2xvbmUgYSBsYXllckVudHJpZXMgY29uZmlnIG9iamVjdC5cclxuICAgICAgICAvLyBzaW5jZSB3ZSBhcmUgdXNpbmcgdHlwZWQgb2JqZWN0cyB3aXRoIGdldHRlcnMgYW5kIHNldHRlcnMsXHJcbiAgICAgICAgLy8gb3VyIHVzdWFsIGVhc3kgd2F5cyBvZiBjbG9uaW5nIGFuIG9iamVjdCBkb24ndCB3b3JrIChlLmcuIHVzaW5nXHJcbiAgICAgICAgLy8gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh4KSkpLiBUaGlzIGlzIG5vdCBhIGdyZWF0IHNvbHV0aW9uICh1bmRlcnN0YXRlbWVudCksXHJcbiAgICAgICAgLy8gIGJ1dCBpcyBiZWluZyBkb25lIGFzIGEgcXVpY2sgbiBkaXJ0eSB3b3JrYXJvdW5kLiBBdCBhIGxhdGVyIHRpbWUsXHJcbiAgICAgICAgLy8gdGhlIGd1dHMgb2YgdGhpcyBmdW5jdGlvbiBjYW4gYmUgcmUtZXhhbWluZWQgZm9yIGEgYmV0dGVyLFxyXG4gICAgICAgIC8vIGxlc3MgaGFyZGNvZGVkIHNvbHV0aW9uLlxyXG4gICAgICAgIGNvbnN0IGNsb25lQ29uZmlnID0gb3JpZ0NvbmZpZyA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNsb25lID0ge307XHJcblxyXG4gICAgICAgICAgICAvLyBkaXJlY3QgY29waWVzLCBubyBkZWZhdWx0aW5nXHJcbiAgICAgICAgICAgIGNsb25lLm5hbWUgPSBvcmlnQ29uZmlnLm5hbWU7XHJcbiAgICAgICAgICAgIGNsb25lLmluZGV4ID0gb3JpZ0NvbmZpZy5pbmRleDtcclxuICAgICAgICAgICAgY2xvbmUuc3RhdGVPbmx5ID0gb3JpZ0NvbmZpZy5zdGF0ZU9ubHk7XHJcbiAgICAgICAgICAgIGNsb25lLm5hbWVGaWVsZCA9IG9yaWdDb25maWcubmFtZUZpZWxkO1xyXG4gICAgICAgICAgICBjbG9uZS5oaWdobGlnaHRGZWF0dXJlID0gb3JpZ0NvbmZpZy5oaWdobGlnaHRGZWF0dXJlIHx8IHRydWU7IC8vIHNpbXBsZSBkZWZhdWx0XHJcblxyXG4gICAgICAgICAgICAvLyBhbiBlbXB0eSBzdHJpbmcgaXMgYSB2YWxpZCBwcm9wZXJ0eSwgc28gYmUgd2FyeSBvZiBmYWxzeSBsb2dpY1xyXG4gICAgICAgICAgICBjbG9uZS5vdXRmaWVsZHMgPSBvcmlnQ29uZmlnLmhhc093blByb3BlcnR5KCdvdXRmaWVsZHMnKSA/IG9yaWdDb25maWcub3V0ZmllbGRzIDogJyonO1xyXG5cclxuICAgICAgICAgICAgLy8gd2l0aCBzdGF0ZSwgd2UgYXJlIGVpdGhlciBjb21wbGV0ZSwgb3IgcHVyZSBkZWZhdWx0cy5cclxuICAgICAgICAgICAgLy8gaW4gdGhlIG5vbi1jb21wbGV0ZSBjYXNlLCB3ZSB0cmVhdCBvdXIgc3RhdGUgYXMgdW5yZWxpYWJsZSBhbmRcclxuICAgICAgICAgICAgLy8gZXhwZWN0IHRoZSBjbGllbnQgdG8gYXNzaWduIHByb3BlcnRpZXMgYXMgaXQgZG9lcyBwYXJlbnQtY2hpbGQgaW5oZXJpdGFuY2VcclxuICAgICAgICAgICAgLy8gZGVmYXVsdGluZyAod2hpY2ggb2NjdXJzIGFmdGVyIHRoaXMgb25Mb2FkIGZ1bmN0aW9uIGhhcyBjb21wbGV0ZWQpXHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9jb25maWdJc0NvbXBsZXRlKSB7XHJcbiAgICAgICAgICAgICAgICBjbG9uZS5zdGF0ZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICB2aXNpYmxpdHk6IG9yaWdDb25maWcudmlzaWJsaXR5LFxyXG4gICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IG9yaWdDb25maWcub3BhY2l0eSxcclxuICAgICAgICAgICAgICAgICAgICBxdWVyeTogb3JpZ0NvbmZpZy5xdWVyeVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNsb25lLnN0YXRlID0gT2JqZWN0LmFzc2lnbih7fSwgZHVtbXlTdGF0ZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGlmIGV4dGVudCBpcyBwcmVzZW50LCB3ZSBhc3N1bWUgaXQgaXMgZnVsbHkgZGVmaW5lZC5cclxuICAgICAgICAgICAgLy8gZXh0ZW50cyBhcmUgbm90IHVzaW5nIGZhbmN5IHR5cGVkIG9iamVjdHMsIHNvIGNhbiBkaXJlY3RseSByZWZlcmVuY2VcclxuICAgICAgICAgICAgY2xvbmUuZXh0ZW50ID0gb3JpZ0NvbmZpZy5leHRlbnQ7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gY2xvbmU7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gY29sbGF0ZSBhbnkgcmVsZXZhbnQgb3ZlcnJpZGVzIGZyb20gdGhlIGNvbmZpZy5cclxuICAgICAgICBjb25zdCBzdWJDb25maWdzID0ge307XHJcblxyXG4gICAgICAgIHRoaXMuY29uZmlnLmxheWVyRW50cmllcy5mb3JFYWNoKGxlID0+IHtcclxuICAgICAgICAgICAgc3ViQ29uZmlnc1tsZS5pbmRleC50b1N0cmluZygpXSA9IHtcclxuICAgICAgICAgICAgICAgIGNvbmZpZzogY2xvbmVDb25maWcobGUpLFxyXG4gICAgICAgICAgICAgICAgZGVmYXVsdGVkOiB0aGlzLl9jb25maWdJc0NvbXBsZXRlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIHN1YmZ1bmN0aW9uIHRvIHJldHVybiBhIHN1YmNvbmZpZyBvYmplY3QuXHJcbiAgICAgICAgLy8gaWYgaXQgZG9lcyBub3QgZXhpc3Qgb3IgaXMgbm90IGRlZmF1bHRlZCwgd2lsbCBkbyB0aGF0IGZpcnN0XHJcbiAgICAgICAgLy8gaWQgcGFyYW0gaXMgYW4gaW50ZWdlciBpbiBzdHJpbmcgZm9ybWF0XHJcbiAgICAgICAgY29uc3QgZmV0Y2hTdWJDb25maWcgPSAoaWQsIHNlcnZlck5hbWUgPSAnJykgID0+IHtcclxuXHJcbiAgICAgICAgICAgIGlmIChzdWJDb25maWdzW2lkXSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3ViQyA9IHN1YkNvbmZpZ3NbaWRdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFzdWJDLmRlZmF1bHRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbmZpZyBpcyBpbmNvbXBsZXRlLCBmaWxsIGluIGJsYW5rc1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIHdpbGwgbmV2ZXIgaGl0IHRoaXMgY29kZSBibG9jayBhIGNvbXBsZXRlIGNvbmZpZyB3YXMgcGFzc2VkIGluXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFwcGx5IGEgc2VydmVyIG5hbWUgaWYgbm8gbmFtZSBleGlzdHNcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXN1YkMuY29uZmlnLm5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3ViQy5jb25maWcubmFtZSA9IHNlcnZlck5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBtYXJrIGFzIGRlZmF1bHRlZCBzbyB3ZSBkb24ndCBkbyB0aGlzIGFnYWluXHJcbiAgICAgICAgICAgICAgICAgICAgc3ViQy5kZWZhdWx0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1YkMuY29uZmlnO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gbm8gY29uZmlnIGF0IGFsbC4gd2UgYXBwbHkgZGVmYXVsdHMsIGFuZCBhIG5hbWUgZnJvbSB0aGUgc2VydmVyIGlmIGF2YWlsYWJsZVxyXG4gICAgICAgICAgICAgICAgY29uc3QgY29uZmlnU2VlZCA9IHtcclxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBzZXJ2ZXJOYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBwYXJzZUludChpZCksXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVPbmx5OiB0cnVlXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3Q29uZmlnID0gY2xvbmVDb25maWcoY29uZmlnU2VlZCk7XHJcbiAgICAgICAgICAgICAgICBzdWJDb25maWdzW2lkXSA9IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25maWc6IG5ld0NvbmZpZyxcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0ZWQ6IHRydWVcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3Q29uZmlnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gc2hvcnRjdXQgdmFyIHRvIHRyYWNrIGFsbCBsZWFmcyB0aGF0IG5lZWQgYXR0ZW50aW9uXHJcbiAgICAgICAgLy8gaW4gdGhlIGxvYWRpbmcgcHJvY2Vzc1xyXG4gICAgICAgIGNvbnN0IGxlYWZzVG9Jbml0ID0gW107XHJcblxyXG4gICAgICAgIC8vIHRoaXMgc3ViZnVuY3Rpb24gd2lsbCByZWN1cnNpdmVseSBjcmF3bCBhIGR5bmFtaWMgbGF5ZXJJbmZvIHN0cnVjdHVyZS5cclxuICAgICAgICAvLyBpdCB3aWxsIGdlbmVyYXRlIHByb3h5IG9iamVjdHMgZm9yIGFsbCBncm91cHMgYW5kIGxlYWZzIHVuZGVyIHRoZVxyXG4gICAgICAgIC8vIGlucHV0IGxheWVySW5mby5cclxuICAgICAgICAvLyB3ZSBhbHNvIGdlbmVyYXRlIGEgdHJlZSBzdHJ1Y3R1cmUgb2YgbGF5ZXJJbmZvcyB0aGF0IGlzIGluIGEgZm9ybWF0XHJcbiAgICAgICAgLy8gdGhhdCBtYWtlcyB0aGUgY2xpZW50IGhhcHB5XHJcbiAgICAgICAgY29uc3QgcHJvY2Vzc0xheWVySW5mbyA9IChsYXllckluZm8sIHRyZWVBcnJheSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBzSWQgPSBsYXllckluZm8uaWQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgY29uc3Qgc3ViQyA9IGZldGNoU3ViQ29uZmlnKHNJZCwgbGF5ZXJJbmZvLm5hbWUpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGxheWVySW5mby5zdWJMYXllcklkcyAmJiBsYXllckluZm8uc3ViTGF5ZXJJZHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgLy8gZ3JvdXAgc3VibGF5ZXIuIHNldCB1cCBvdXIgdHJlZSBmb3IgdGhlIGNsaWVudCwgdGhlbiBjcmF3bCBjaGlsZHMuXHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgdHJlZUdyb3VwID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGVudHJ5SW5kZXg6IGxheWVySW5mby5pZCxcclxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBzdWJDLm5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRzOiBbXVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHRyZWVBcnJheS5wdXNoKHRyZWVHcm91cCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gcHJvY2VzcyB0aGUga2lkcyBpbiB0aGUgZ3JvdXAuXHJcbiAgICAgICAgICAgICAgICAvLyBzdG9yZSB0aGUgY2hpbGQgbGVhdmVzIGluIHRoZSBpbnRlcm5hbCB2YXJpYWJsZVxyXG4gICAgICAgICAgICAgICAgbGF5ZXJJbmZvLnN1YkxheWVySWRzLmZvckVhY2goc2xpZCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0xheWVySW5mbyh0aGlzLl9sYXllci5sYXllckluZm9zW3NsaWRdLCB0cmVlR3JvdXAuY2hpbGRzKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGxlYWYgc3VibGF5ZXIuIG1ha2UgcGxhY2Vob2xkZXJzLCBhZGQgbGVhZiB0byB0aGUgdHJlZVxyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHBmYyA9IG5ldyBwbGFjZWhvbGRlckZDLlBsYWNlaG9sZGVyRkModGhpcywgc3ViQy5uYW1lKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wcm94aWVzW3NJZF0pIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBoYXZlIGEgcHJlLW1hZGUgcHJveHkgKHN0cnVjdHVyZWQgbGVnZW5kKS4gdXBkYXRlIGl0LlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb3hpZXNbc0lkXS51cGRhdGVTb3VyY2UocGZjKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc2V0IHVwIG5ldyBwcm94eVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxlYWZQcm94eSA9IG5ldyBsYXllckludGVyZmFjZS5MYXllckludGVyZmFjZShudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICBsZWFmUHJveHkuY29udmVydFRvUGxhY2Vob2xkZXIocGZjKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm94aWVzW3NJZF0gPSBsZWFmUHJveHk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdHJlZUFycmF5LnB1c2goeyBlbnRyeUluZGV4OiBsYXllckluZm8uaWQgfSk7XHJcbiAgICAgICAgICAgICAgICBsZWFmc1RvSW5pdC5wdXNoKGxheWVySW5mby5pZC50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMuX2NoaWxkVHJlZSA9IFtdOyAvLyBwdWJsaWMgc3RydWN0dXJlIGRlc2NyaWJpbmcgdGhlIHRyZWVcclxuXHJcbiAgICAgICAgLy8gcHJvY2VzcyB0aGUgY2hpbGQgbGF5ZXJzIG91ciBjb25maWcgaXMgaW50ZXJlc3RlZCBpbiwgYW5kIGFsbCB0aGVpciBjaGlsZHJlbi5cclxuICAgICAgICBpZiAodGhpcy5jb25maWcubGF5ZXJFbnRyaWVzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLmxheWVyRW50cmllcy5mb3JFYWNoKGxlID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghbGUuc3RhdGVPbmx5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0xheWVySW5mbyh0aGlzLl9sYXllci5sYXllckluZm9zW2xlLmluZGV4XSwgdGhpcy5fY2hpbGRUcmVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBjb252ZXJ0cyBzZXJ2ZXIgbGF5ZXIgdHlwZSBzdHJpbmcgdG8gY2xpZW50IGxheWVyIHR5cGUgc3RyaW5nXHJcbiAgICAgICAgY29uc3Qgc2VydmVyTGF5ZXJUeXBlVG9DbGllbnRMYXllclR5cGUgPSBzZXJ2ZXJUeXBlID0+IHtcclxuICAgICAgICAgICAgc3dpdGNoIChzZXJ2ZXJUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdGZWF0dXJlIExheWVyJzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2hhcmVkLmNsaWVudExheWVyVHlwZS5FU1JJX0ZFQVRVUkU7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdSYXN0ZXIgTGF5ZXInOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaGFyZWQuY2xpZW50TGF5ZXJUeXBlLkVTUklfUkFTVEVSO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1VuZXhwZWN0ZWQgbGF5ZXIgdHlwZSBpbiBzZXJ2ZXJMYXllclR5cGVUb0NsaWVudExheWVyVHlwZScsIHNlcnZlclR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaGFyZWQuY2xpZW50TGF5ZXJUeXBlLlVOS05PV047XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBwcm9jZXNzIGVhY2ggbGVhZiB3ZSB3YWxrZWQgdG8gaW4gdGhlIHByb2Nlc3NMYXllckluZm8gbG9vcCBhYm92ZVxyXG4gICAgICAgIC8vIGlkeCBpcyBhIHN0cmluZ1xyXG4gICAgICAgIGxlYWZzVG9Jbml0LmZvckVhY2goaWR4ID0+IHtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHN1YkMgPSBzdWJDb25maWdzW2lkeF0uY29uZmlnO1xyXG4gICAgICAgICAgICBjb25zdCBhdHRyaWJQYWNrYWdlID0gdGhpcy5fYXBpUmVmLmF0dHJpYnMubG9hZFNlcnZlckF0dHJpYnModGhpcy5fbGF5ZXIudXJsLCBpZHgsIHN1YkMub3V0ZmllbGRzKTtcclxuICAgICAgICAgICAgY29uc3QgZEZDID0gbmV3IGR5bmFtaWNGQy5EeW5hbWljRkModGhpcywgaWR4LCBhdHRyaWJQYWNrYWdlLCBzdWJDKTtcclxuICAgICAgICAgICAgZEZDLmhpZ2hsaWdodEZlYXR1cmUgPSBzdWJDLmhpZ2hsaWdodEZlYXR1cmU7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZlYXRDbGFzc2VzW2lkeF0gPSBkRkM7XHJcblxyXG4gICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgcHJveHkgd2F0Y2hpbmcgdGhpcyBsZWFmLCByZXBsYWNlIGl0cyBwbGFjZWhvbGRlciB3aXRoIHRoZSByZWFsIGRhdGFcclxuICAgICAgICAgICAgY29uc3QgbGVhZlByb3h5ID0gdGhpcy5fcHJveGllc1tpZHhdO1xyXG4gICAgICAgICAgICBpZiAobGVhZlByb3h5KSB7XHJcbiAgICAgICAgICAgICAgICBsZWFmUHJveHkuY29udmVydFRvRHluYW1pY0xlYWYoZEZDKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gbG9hZCByZWFsIHN5bWJvbHMgaW50byBvdXIgc291cmNlXHJcbiAgICAgICAgICAgIGxvYWRQcm9taXNlcy5wdXNoKGRGQy5sb2FkU3ltYm9sb2d5KCkpO1xyXG5cclxuICAgICAgICAgICAgLy8gdXBkYXRlIGFzeW5jaHJvbm91cyB2YWx1ZXNcclxuICAgICAgICAgICAgY29uc3QgcExEID0gZEZDLmdldExheWVyRGF0YSgpXHJcbiAgICAgICAgICAgICAgICAudGhlbihsZCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZEZDLmxheWVyVHlwZSA9IHNlcnZlckxheWVyVHlwZVRvQ2xpZW50TGF5ZXJUeXBlKGxkLmxheWVyVHlwZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIGRpZG4ndCBoYXZlIGFuIGV4dGVudCBkZWZpbmVkIG9uIHRoZSBjb25maWcsIHVzZSB0aGUgbGF5ZXIgZXh0ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkRkMuZXh0ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRGQy5leHRlbnQgPSBsZC5leHRlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBkRkMuX3NjYWxlU2V0Lm1pblNjYWxlID0gbGQubWluU2NhbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgZEZDLl9zY2FsZVNldC5tYXhTY2FsZSA9IGxkLm1heFNjYWxlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBkRkMubmFtZUZpZWxkID0gc3ViQy5uYW1lRmllbGQgfHwgbGQubmFtZUZpZWxkIHx8ICcnO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBza2lwIGEgbnVtYmVyIG9mIHRoaW5ncyBpZiBpdCBpcyBhIHJhc3RlciBsYXllclxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGVpdGhlciB3YXksIHJldHVybiBhIHByb21pc2Ugc28gb3VyIGxvYWRQcm9taXNlcyBoYXZlIGEgZ29vZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHZhbHVlIHRvIHdhaXQgb24uXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRGQy5sYXllclR5cGUgPT09IHNoYXJlZC5jbGllbnRMYXllclR5cGUuRVNSSV9GRUFUVVJFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRGQy5nZW9tVHlwZSA9IGxkLmdlb21ldHJ5VHlwZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEZlYXR1cmVDb3VudChpZHgpLnRoZW4oZmMgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZEZDLmZlYXR1cmVDb3VudCA9IGZjO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZEZDLmxheWVyVHlwZSA9IHNoYXJlZC5jbGllbnRMYXllclR5cGUuVU5SRVNPTFZFRDtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBsb2FkUHJvbWlzZXMucHVzaChwTEQpO1xyXG5cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gVE9ETyBjYXJlZnVsIG5vdywgYXMgdGhlIGR5bmFtaWNGQy5EeW5hbWljRkMgY29uc3RydWN0b3IgYWxzbyBhcHBlYXJzIHRvIGJlIHNldHRpbmcgdmlzaWJpbGl0eSBvbiB0aGUgcGFyZW50LlxyXG4gICAgICAgIGlmICh0aGlzLl9jb25maWdJc0NvbXBsZXRlKSB7XHJcbiAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgYSBjb21wbGV0ZSBjb25maWcsIHdhbnQgdG8gc2V0IGxheWVyIHZpc2liaWxpdHlcclxuICAgICAgICAgICAgLy8gZ2V0IGFuIGFycmF5IG9mIGxlYWYgaWRzIHRoYXQgYXJlIHZpc2libGUuXHJcbiAgICAgICAgICAgIC8vIHVzZSBfZmVhdENsYXNzZXMgYXMgaXQgY29udGFpbnMga2V5cyB0aGF0IGV4aXN0IG9uIHRoZSBzZXJ2ZXIgYW5kIGFyZVxyXG4gICAgICAgICAgICAvLyBwb3RlbnRpYWxseSB2aXNpYmxlIGluIHRoZSBjbGllbnQuXHJcbiAgICAgICAgICAgIGNvbnN0IGluaXRWaXMgPSBPYmplY3Qua2V5cyh0aGlzLl9mZWF0Q2xhc3NlcylcclxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZmNJZCA9PiB7cmV0dXJuIGZldGNoU3ViQ29uZmlnKGZjSWQpLmNvbmZpZy5zdGF0ZS52aXNpYmlsaXR5OyB9KVxyXG4gICAgICAgICAgICAgICAgLm1hcChmY0lkID0+IHsgcmV0dXJuIHBhcnNlSW50KGZjSWQpOyB9KTtcclxuXHJcbiAgICAgICAgICAgIGlmIChpbml0VmlzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgaW5pdFZpcy5wdXNoKC0xKTsgLy8gZXNyaSBjb2RlIGZvciBzZXQgYWxsIHRvIGludmlzaWJsZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2xheWVyLnNldFZpc2libGVMYXllcnMoaW5pdFZpcyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gZGVmYXVsdCBjb25maWd1cmF0aW9uIGZvciBub24tY29tcGxldGUgY29uZmlnLlxyXG4gICAgICAgICAgICB0aGlzLl9sYXllci5zZXRWaXNpYmlsaXR5KGZhbHNlKTtcclxuICAgICAgICAgICAgdGhpcy5fbGF5ZXIuc2V0VmlzaWJsZUxheWVycyhbLTFdKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIFByb21pc2UuYWxsKGxvYWRQcm9taXNlcykudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlQ2hhbmdlKHNoYXJlZC5zdGF0ZXMuTE9BREVEKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBvdmVycmlkZSB0byBhZGQgY2hpbGQgaW5kZXggcGFyYW1ldGVyXHJcbiAgICB6b29tVG9TY2FsZSAoY2hpbGRJZHgsIG1hcCwgbG9kcywgem9vbUluLCB6b29tR3JhcGhpYyA9IGZhbHNlKSB7XHJcbiAgICAgICAgLy8gZ2V0IHNjYWxlIHNldCBmcm9tIGNoaWxkLCB0aGVuIGV4ZWN1dGUgem9vbVxyXG4gICAgICAgIGNvbnN0IHNjYWxlU2V0ID0gdGhpcy5fZmVhdENsYXNzZXNbY2hpbGRJZHhdLmdldFNjYWxlU2V0KCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3pvb21Ub1NjYWxlU2V0KG1hcCwgbG9kcywgem9vbUluLCBzY2FsZVNldCwgem9vbUdyYXBoaWMpO1xyXG4gICAgfVxyXG5cclxuICAgIGlzT2ZmU2NhbGUgKGNoaWxkSWR4LCBtYXBTY2FsZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9mZWF0Q2xhc3Nlc1tjaGlsZElkeF0uaXNPZmZTY2FsZShtYXBTY2FsZSk7XHJcbiAgICB9XHJcblxyXG4gICAgaXNRdWVyeWFibGUgKGNoaWxkSWR4KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZlYXRDbGFzc2VzW2NoaWxkSWR4XS5xdWVyeWFibGU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVE9ETyBpZiB3ZSBuZWVkIHRoaXMgYmFjaywgbWF5IG5lZWQgdG8gaW1wbGVtZW50IGFzIGdldENoaWxkR2VvbVR5cGUuXHJcbiAgICAvLyAgICAgIGFwcGVhcnMgdGhpcyBvdnZlcnJpZGVzIHRoZSBMYXllclJlY29yZC5nZXRHZW9tVHlwZSBmdW5jdGlvbiwgd2hpY2ggcmV0dXJuc1xyXG4gICAgLy8gICAgICB1bmRlZmluZWQsIGFuZCB0aGF0IGlzIHdoYXQgd2Ugd2FudCBvbiB0aGUgRHluYW1pY1JlY29yZCBsZXZlbCAoYXMgZHluYW1pYyBsYXllcilcclxuICAgIC8vICAgICAgaGFzIG5vIGdlb21ldHJ5LlxyXG4gICAgLy8gICAgICBDdXJyZW50bHksIGFsbCBjaGlsZCByZXF1ZXN0cyBmb3IgZ2VvbWV0cnkgZ28gdGhyb3VnaCB0aGUgcHJveHksXHJcbiAgICAvLyAgICAgIHNvIGNvdWxkIGJlIHRoaXMgY2hpbGQtdGFyZ2V0aW5nIHZlcnNpb24gaXMgaXJyZWxldmFudC5cclxuICAgIC8qXHJcbiAgICBnZXRHZW9tVHlwZSAoY2hpbGRJZHgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZmVhdENsYXNzZXNbY2hpbGRJZHhdLmdlb21UeXBlO1xyXG4gICAgfVxyXG4gICAgKi9cclxuXHJcbiAgICBnZXRDaGlsZFRyZWUgKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9jaGlsZFRyZWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NoaWxkVHJlZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxlZCBnZXRDaGlsZFRyZWUgYmVmb3JlIGxheWVyIGlzIGxvYWRlZCcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgYmVzdCB1c2VyLWZyaWVuZGx5IG5hbWUgb2YgYSBmaWVsZC4gVXNlcyBhbGlhcyBpZiBhbGlhcyBpcyBkZWZpbmVkLCBlbHNlIHVzZXMgdGhlIHN5c3RlbSBhdHRyaWJ1dGUgbmFtZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0cmliTmFtZSAgICAgdGhlIGF0dHJpYnV0ZSBuYW1lIHdlIHdhbnQgYSBuaWNlIG5hbWUgZm9yXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gIGNoaWxkSW5kZXggICAgaW5kZXggb2YgdGhlIGNoaWxkIGxheWVyIHdob3MgYXR0cmlidXRlcyB3ZSBhcmUgbG9va2luZyBhdFxyXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgICAgICAgIHJlc29sdmVzIHRvIHRoZSBiZXN0IGF2YWlsYWJsZSB1c2VyIGZyaWVuZGx5IGF0dHJpYnV0ZSBuYW1lXHJcbiAgICAgKi9cclxuICAgIGFsaWFzZWRGaWVsZE5hbWUgKGF0dHJpYk5hbWUsIGNoaWxkSW5kZXgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZmVhdENsYXNzZXNbY2hpbGRJbmRleF0uYWxpYXNlZEZpZWxkTmFtZShhdHRyaWJOYW1lKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlcyBhdHRyaWJ1dGVzIGZyb20gYSBsYXllciBmb3IgYSBzcGVjaWZpZWQgZmVhdHVyZSBpbmRleFxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICBjaGlsZEluZGV4ICBpbmRleCBvZiB0aGUgY2hpbGQgbGF5ZXIgdG8gZ2V0IGF0dHJpYnV0ZXMgZm9yXHJcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSAgICAgICAgICAgIHByb21pc2UgcmVzb2x2aW5nIHdpdGggZm9ybWF0dGVkIGF0dHJpYnV0ZXMgdG8gYmUgY29uc3VtZWQgYnkgdGhlIGRhdGFncmlkIGFuZCBlc3JpIGZlYXR1cmUgaWRlbnRpZnlcclxuICAgICAqL1xyXG4gICAgZ2V0Rm9ybWF0dGVkQXR0cmlidXRlcyAoY2hpbGRJbmRleCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9mZWF0Q2xhc3Nlc1tjaGlsZEluZGV4XS5nZXRGb3JtYXR0ZWRBdHRyaWJ1dGVzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZmV0Y2hHcmFwaGljIChjaGlsZEluZGV4LCBvYmpJZCwgaWdub3JlTG9jYWwgPSBmYWxzZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9mZWF0Q2xhc3Nlc1tjaGlsZEluZGV4XS5mZXRjaEdyYXBoaWMob2JqSWQsIGlnbm9yZUxvY2FsKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrIHRvIHNlZSBpZiB0aGUgYXR0cmlidXRlIGluIHF1ZXN0aW9uIGlzIGFuIGVzcmlGaWVsZFR5cGVEYXRlIHR5cGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHJpYk5hbWUgICAgIHRoZSBhdHRyaWJ1dGUgbmFtZSB3ZSB3YW50IHRvIGNoZWNrIGlmIGl0J3MgYSBkYXRlIG9yIG5vdFxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICBjaGlsZEluZGV4ICAgIGluZGV4IG9mIHRoZSBjaGlsZCBsYXllciB3aG9zIGF0dHJpYnV0ZXMgd2UgYXJlIGxvb2tpbmcgYXRcclxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9ICAgICAgICAgICAgICByZXNvbHZlcyB0byB0cnVlIG9yIGZhbHNlIGJhc2VkIG9uIHRoZSBhdHRyaWJOYW1lIHR5cGUgYmVpbmcgZXNyaUZpZWxkVHlwZURhdGVcclxuICAgICAqL1xyXG4gICAgY2hlY2tEYXRlVHlwZSAoYXR0cmliTmFtZSwgY2hpbGRJbmRleCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9mZWF0Q2xhc3Nlc1tjaGlsZEluZGV4XS5jaGVja0RhdGVUeXBlKGF0dHJpYk5hbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBSZXR1cm5zIGF0dHJpYnV0ZSBkYXRhIGZvciBhIGNoaWxkIGxheWVyLlxyXG4gICAgKlxyXG4gICAgKiBAZnVuY3Rpb24gZ2V0QXR0cmlic1xyXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gY2hpbGRJbmRleCAgdGhlIGluZGV4IG9mIHRoZSBjaGlsZCBsYXllclxyXG4gICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gICAgICAgICAgcmVzb2x2ZXMgd2l0aCBhIGxheWVyIGF0dHJpYnV0ZSBkYXRhIG9iamVjdFxyXG4gICAgKi9cclxuICAgIGdldEF0dHJpYnMgKGNoaWxkSW5kZXgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZmVhdENsYXNzZXNbY2hpbGRJbmRleF0uZ2V0QXR0cmlicygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBSZXR1cm5zIGxheWVyLXNwZWNpZmljIGRhdGEgZm9yIGEgY2hpbGQgbGF5ZXJcclxuICAgICpcclxuICAgICogQGZ1bmN0aW9uIGdldExheWVyRGF0YVxyXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gY2hpbGRJbmRleCAgdGhlIGluZGV4IG9mIHRoZSBjaGlsZCBsYXllclxyXG4gICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gICAgICAgICAgcmVzb2x2ZXMgd2l0aCBhIGxheWVyIGRhdGEgb2JqZWN0XHJcbiAgICAqL1xyXG4gICAgZ2V0TGF5ZXJEYXRhIChjaGlsZEluZGV4KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZlYXRDbGFzc2VzW2NoaWxkSW5kZXhdLmdldExheWVyRGF0YSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldEZlYXR1cmVOYW1lIChjaGlsZEluZGV4LCBvYmpJZCwgYXR0cmlicykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9mZWF0Q2xhc3Nlc1tjaGlsZEluZGV4XS5nZXRGZWF0dXJlTmFtZShvYmpJZCwgYXR0cmlicyk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0U3ltYm9sb2d5IChjaGlsZEluZGV4KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZlYXRDbGFzc2VzW2NoaWxkSW5kZXhdLnN5bWJvbG9neTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogUnVuIGEgcXVlcnkgb24gYSBkeW5hbWljIGxheWVyLCByZXR1cm4gdGhlIHJlc3VsdCBhcyBhIHByb21pc2UuXHJcbiAgICAqIEBmdW5jdGlvbiBpZGVudGlmeVxyXG4gICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyBhZGRpdGlvbmFsIGFyZ3VtZXRzIGxpa2UgbWFwIG9iamVjdCwgY2xpY2tFdmVudCwgZXRjLlxyXG4gICAgKiBAcmV0dXJucyB7T2JqZWN0fSBhbiBvYmplY3Qgd2l0aCBpZGVudGlmeSByZXN1bHRzIGFycmF5IGFuZCBpZGVudGlmeSBwcm9taXNlIHJlc29sdmluZyB3aGVuIGlkZW50aWZ5IGlzIGNvbXBsZXRlOyBpZiBhbiBlbXB0eSBvYmplY3QgaXMgcmV0dXJuZWQsIGl0IHdpbGwgYmUgc2tpcHBlZFxyXG4gICAgKi9cclxuICAgIGlkZW50aWZ5IChvcHRzKSB7XHJcbiAgICAgICAgLy8gVE9ETyBhZGQgZnVsbCBkb2N1bWVudGF0aW9uIGZvciBvcHRpb25zIHBhcmFtZXRlclxyXG5cclxuICAgICAgICAvLyBidW5kbGVzIHJlc3VsdHMgZnJvbSBhbGwgbGVhZiBsYXllcnNcclxuICAgICAgICBjb25zdCBpZGVudGlmeVJlc3VsdHMgPSBbXTtcclxuXHJcbiAgICAgICAgaWYgKCFzaGFyZWQubGF5ZXJMb2FkZWQodGhpcy5zdGF0ZSkpIHtcclxuICAgICAgICAgICAgb3B0cy5sYXllcklkcyA9IFtdOyAvLyBxdWljayBxdWl0XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgb3B0cy5sYXllcklkcyA9IHRoaXMuX2xheWVyLnZpc2libGVMYXllcnNcclxuICAgICAgICAgICAgICAgIC5maWx0ZXIobGVhZkluZGV4ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobGVhZkluZGV4ID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIG1hcmtlciBmb3Igbm90aGluZyBpcyB2aXNpYmxlLiBnZXQgcmlkIG9mIGl0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmYyA9IHRoaXMuX2ZlYXRDbGFzc2VzW2xlYWZJbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmYykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8ga2VlcCBpZiBpdCBpcyBxdWVyeWFibGUgYW5kIG9uLXNjYWxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmMucXVlcnlhYmxlICYmICFmYy5pc09mZlNjYWxlKG9wdHMubWFwLmdldFNjYWxlKCkpLm9mZlNjYWxlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgZG9udCBoYXZlIGEgZmVhdHVyZSBjbGFzcyBmb3IgdGhpcyBpZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICBpdCBpcyBsaWtlbHkgYSBhIGdyb3VwIG9yIHNvbWV0aGluZyB2aXNpYmxlIGJ1dCBub3QgYWN0aXZlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGlmIHRoZXJlIGFyZSBubyBsYXllcklkcyB0byBpbnNwZWN0LCBkb24ndCBoaXQgdGhlIHNlcnZlclxyXG4gICAgICAgIGlmIChvcHRzLmxheWVySWRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAvLyBUT0RPIHZlcmlmaXkgdGhpcyBpcyBjb3JyZWN0IHJlc3VsdCBmb3JtYXQgaWYgbGF5ZXIgc2hvdWxkIGJlIGV4Y2x1ZGVkIGZyb20gdGhlIGlkZW50aWZ5IHByb2Nlc3NcclxuICAgICAgICAgICAgcmV0dXJuIHsgaWRlbnRpZnlSZXN1bHRzOiBbXSwgaWRlbnRpZnlQcm9taXNlOiBQcm9taXNlLnJlc29sdmUoKSB9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgb3B0cy5sYXllcklkcy5mb3JFYWNoKGxlYWZJbmRleCA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlkZW50aWZ5UmVzdWx0ID0gbmV3IHNoYXJlZC5JZGVudGlmeVJlc3VsdCh0aGlzLmdldENoaWxkUHJveHkobGVhZkluZGV4KSk7XHJcbiAgICAgICAgICAgIGlkZW50aWZ5UmVzdWx0c1tsZWFmSW5kZXhdID0gaWRlbnRpZnlSZXN1bHQ7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIFRPRE8gdmVyaWZ5IGlmIDAgaXMgdmFsaWQgY2xpY2sgdG9sZXJhbmNlLiBpZiBzbywgbmVlZCB0byBhZGRyZXNzIGZhbHN5IGxvZ2ljLlxyXG4gICAgICAgIG9wdHMudG9sZXJhbmNlID0gb3B0cy50b2xlcmFuY2UgfHwgdGhpcy5jbGlja1RvbGVyYW5jZSB8fCA1O1xyXG5cclxuICAgICAgICBjb25zdCBpZGVudGlmeVByb21pc2UgPSB0aGlzLl9hcGlSZWYubGF5ZXIuc2VydmVyTGF5ZXJJZGVudGlmeSh0aGlzLl9sYXllciwgb3B0cylcclxuICAgICAgICAgICAgLnRoZW4oY2xpY2tSZXN1bHRzID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGhpdEluZGV4ZXMgPSBbXTsgLy8gc3VibGF5ZXJzIHRoYXQgd2UgZ290IHJlc3VsdHMgZm9yXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gdHJhbnNmb3JtIGF0dHJpYnV0ZXMgb2YgY2xpY2sgcmVzdWx0cyBpbnRvIHtuYW1lLGRhdGF9IG9iamVjdHNcclxuICAgICAgICAgICAgICAgIC8vIG9uZSBvYmplY3QgcGVyIGlkZW50aWZpZWQgZmVhdHVyZVxyXG4gICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgIC8vIGVhY2ggZmVhdHVyZSB3aWxsIGhhdmUgaXRzIGF0dHJpYnV0ZXMgY29udmVydGVkIGludG8gYSB0YWJsZVxyXG4gICAgICAgICAgICAgICAgLy8gcGxhY2Vob2xkZXIgZm9yIG5vdyB1bnRpbCB3ZSBmaWd1cmUgb3V0IGhvdyB0byBzaWduYWwgdGhlIHBhbmVsIHRoYXRcclxuICAgICAgICAgICAgICAgIC8vIHdlIHdhbnQgdG8gbWFrZSBhIG5pY2UgdGFibGVcclxuICAgICAgICAgICAgICAgIGNsaWNrUmVzdWx0cy5mb3JFYWNoKGVsZSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogdGhlIGlkZW50aWZ5IHNlcnZpY2UgcmV0dXJucyBhbGlhc2VkIGZpZWxkIG5hbWVzLCBzbyBubyBuZWVkIHRvIGxvb2sgdGhlbSB1cCBoZXJlLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgIGhvd2V2ZXIsIHRoaXMgbWVhbnMgd2UgbmVlZCB0byB1bi1hbGlhcyB0aGUgZGF0YSB3aGVuIGRvaW5nIGZpZWxkIGxvb2t1cHMuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogZWxlLmxheWVySWQgaXMgd2hhdCB3ZSB3b3VsZCBjYWxsIGZlYXR1cmVJZHhcclxuICAgICAgICAgICAgICAgICAgICBoaXRJbmRleGVzLnB1c2goZWxlLmxheWVySWQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBnZXQgbWV0YWRhdGEgYWJvdXQgdGhpcyBzdWJsYXllclxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0TGF5ZXJEYXRhKGVsZS5sYXllcklkKS50aGVuKGxEYXRhID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaWRlbnRpZnlSZXN1bHQgPSBpZGVudGlmeVJlc3VsdHNbZWxlLmxheWVySWRdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxEYXRhLnN1cHBvcnRzRmVhdHVyZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHVuQWxpYXNBdHQgPSBhdHRyaWJGQy5BdHRyaWJGQy51bkFsaWFzQXR0cmlicyhlbGUuZmVhdHVyZS5hdHRyaWJ1dGVzLCBsRGF0YS5maWVsZHMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gdHJhZGl0aW9uYWxseSwgd2UgZGlkIG5vdCBwYXNzIGZpZWxkcyBpbnRvIGF0dHJpYnV0ZXNUb0RldGFpbHMgYXMgZGF0YSB3YXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgYWxyZWFkeSBhbGlhc2VkIGZyb20gdGhlIHNlcnZlci4gbm93LCBzaW5jZSB3ZSBhcmUgZXh0cmFjdGluZyBmaWVsZCB0eXBlIGFzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgIHdlbGwsIHRoaXMgbWVhbnMgdGhpbmdzIGxpa2UgZGF0ZSBmb3JtYXR0aW5nIG1pZ2h0IG5vdCBiZSBhcHBsaWVkIHRvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgIGlkZW50aWZ5IHJlc3VsdHMuIGV4YW1pbmUgdGhlIGltcGFjdCBvZiBwcm92aWRpbmcgdGhlIGZpZWxkcyBwYXJhbWV0ZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgdG8gZGF0YSB0aGF0IGlzIGFscmVhZHkgYWxpYXNlZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkZW50aWZ5UmVzdWx0LmRhdGEucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZWxlLnZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHRoaXMuYXR0cmlidXRlc1RvRGV0YWlscyhlbGUuZmVhdHVyZS5hdHRyaWJ1dGVzKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvaWQ6IHVuQWxpYXNBdHRbbERhdGEub2lkRmllbGRdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbG9neTogW3tcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ZnY29kZTogdGhpcy5fYXBpUmVmLnN5bWJvbG9neS5nZXRHcmFwaGljSWNvbih1bkFsaWFzQXR0LCBsRGF0YS5yZW5kZXJlcilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWRlbnRpZnlSZXN1bHQuaXNMb2FkaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBzZXQgdGhlIHJlc3Qgb2YgdGhlIGVudHJpZXMgdG8gbG9hZGluZyBmYWxzZVxyXG4gICAgICAgICAgICAgICAgaWRlbnRpZnlSZXN1bHRzLmZvckVhY2goaWRlbnRpZnlSZXN1bHQgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChoaXRJbmRleGVzLmluZGV4T2YoaWRlbnRpZnlSZXN1bHQucmVxdWVzdGVyLmZlYXR1cmVJZHgpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZGVudGlmeVJlc3VsdC5pc0xvYWRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBpZGVudGlmeVJlc3VsdHM6IGlkZW50aWZ5UmVzdWx0cy5maWx0ZXIoaWRlbnRpZnlSZXN1bHQgPT4gaWRlbnRpZnlSZXN1bHQpLCAvLyBjb2xsYXBzZSBzcGFyc2UgYXJyYXlcclxuICAgICAgICAgICAgaWRlbnRpZnlQcm9taXNlXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUT0RPIGRvY3NcclxuICAgIGdldENoaWxkTmFtZSAoaW5kZXgpIHtcclxuICAgICAgICAvLyBUT0RPIHJldmlzaXQgbG9naWMuIGlzIHRoaXMgdGhlIGJlc3Qgd2F5IHRvIGRvIHRoaXM/IHdoYXQgYXJlIHRoZSBuZWVkcyBvZiB0aGUgY29uc3VtaW5nIGNvZGU/XHJcbiAgICAgICAgLy8gVE9ETyByZXN0cnVjdHVyZSBzbyBXTVMgY2FuIHVzZSB0aGlzIHRvbz9cclxuICAgICAgICAvLyB3aWxsIG5vdCB1c2UgRkMgY2xhc3NlcywgYXMgd2UgYWxzbyBuZWVkIGdyb3VwIG5hbWVzXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xheWVyLmxheWVySW5mb3NbaW5kZXhdLm5hbWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVE9ETyB3ZSBtYXkgd2FudCB2ZXJzaW9uIG9mIGxheWVyUmVjb3JkLnpvb21Ub0JvdW5kYXJ5IHRoYXQgdGFyZ2V0cyBhIGNoaWxkIGluZGV4LlxyXG4gICAgLy8gICAgICBhbHRlcm5hdGVseSB0aGlzIG1pZ2h0IGdvIG9uIHRoZSBwcm94eSBhbmQgdGhlbiB3ZSBnbyBkaXJlY3QgZnJvbSB0aGVyZS5cclxuXHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gKCkgPT4gKHtcclxuICAgIER5bmFtaWNSZWNvcmRcclxufSk7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9sYXllci9sYXllclJlYy9keW5hbWljUmVjb3JkLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar attribFC = __webpack_require__(18)();\nvar placeholderFC = __webpack_require__(5)();\nvar attribRecord = __webpack_require__(38)();\nvar layerInterface = __webpack_require__(24)();\nvar shared = __webpack_require__(2)();\n\n/**\r\n * @class FeatureRecord\r\n */\n\nvar FeatureRecord = function (_attribRecord$AttribR) {\n    _inherits(FeatureRecord, _attribRecord$AttribR);\n\n    /**\r\n     * Create a layer record with the appropriate geoApi layer type.  Layer config\r\n     * should be fully merged with all layer options defined (i.e. this constructor\r\n     * will not apply any defaults).\r\n     * @param {Object} layerClass    the ESRI api object for feature layers\r\n     * @param {Object} esriRequest   the ESRI api object for making web requests with proxy support\r\n     * @param {Object} apiRef        object pointing to the geoApi. allows us to call other geoApi functions.\r\n     * @param {Object} config        layer config values\r\n     * @param {Object} esriLayer     an optional pre-constructed layer\r\n     * @param {Function} epsgLookup  an optional lookup function for EPSG codes (see geoService for signature)\r\n     */\n    function FeatureRecord(layerClass, esriRequest, apiRef, config, esriLayer, epsgLookup) {\n        _classCallCheck(this, FeatureRecord);\n\n        // handles placeholder symbol, possibly other things\n        // if we were passed a pre-loaded layer, we skip this (it will run after the load triggers\n        // in the super-constructor, thus overwriting our good results)\n        var _this = _possibleConstructorReturn(this, (FeatureRecord.__proto__ || Object.getPrototypeOf(FeatureRecord)).call(this, layerClass, esriRequest, apiRef, config, esriLayer, epsgLookup));\n\n        if (!esriLayer) {\n            _this._defaultFC = '0';\n            _this._featClasses['0'] = new placeholderFC.PlaceholderFC(_this, _this.name);\n\n            _this._geometryType = undefined;\n            _this._fcount = undefined;\n        }\n        return _this;\n    }\n\n    _createClass(FeatureRecord, [{\n        key: 'makeLayerConfig',\n        value: function makeLayerConfig() {\n            var cfg = _get(FeatureRecord.prototype.__proto__ || Object.getPrototypeOf(FeatureRecord.prototype), 'makeLayerConfig', this).call(this);\n            cfg.mode = this.config.state.snapshot ? this._layerClass.MODE_SNAPSHOT : this._layerClass.MODE_ONDEMAND;\n\n            // TODO confirm this logic. old code mapped .options.snapshot.value to the button -- meaning if we were in snapshot mode,\n            //      we would want the button disabled. in the refactor, the button may get it's enabled/disabled from a different source.\n            // this.config.state.snapshot = !this.config.state.snapshot;\n            this._snapshot = this.config.state.snapshot;\n\n            return cfg;\n        }\n    }, {\n        key: 'getGeomType',\n        value: function getGeomType() {\n            // standard case, layer has no geometry. This gets overridden in feature-based Record classes.\n            return this._geometryType;\n        }\n\n        // returns the proxy interface object for the root of the layer (i.e. main entry in legend, not nested child things)\n        // TODO docs\n\n    }, {\n        key: 'getProxy',\n        value: function getProxy() {\n            if (!this._rootProxy) {\n                this._rootProxy = new layerInterface.LayerInterface(this, this.initialConfig.controls);\n                this._rootProxy.convertToFeatureLayer(this);\n            }\n            return this._rootProxy;\n        }\n\n        /**\r\n        * Triggers when the layer loads.\r\n        *\r\n        * @function onLoad\r\n        */\n\n    }, {\n        key: 'onLoad',\n        value: function onLoad() {\n            var _this2 = this;\n\n            var loadPromises = _get(FeatureRecord.prototype.__proto__ || Object.getPrototypeOf(FeatureRecord.prototype), 'onLoad', this).call(this);\n\n            // get attribute package\n            var attribPackage = void 0;\n            var featIdx = void 0;\n            if (this.isFileLayer()) {\n                featIdx = '0';\n                attribPackage = this._apiRef.attribs.loadFileAttribs(this._layer);\n            } else {\n                var splitUrl = shared.parseUrlIndex(this._layer.url);\n                featIdx = splitUrl.index;\n                this.rootUrl = splitUrl.rootUrl;\n                attribPackage = this._apiRef.attribs.loadServerAttribs(splitUrl.rootUrl, featIdx, this.config.outfields);\n            }\n\n            // feature has only one layer\n            var aFC = new attribFC.AttribFC(this, featIdx, attribPackage, this.config);\n            this._defaultFC = featIdx;\n            this._featClasses[featIdx] = aFC;\n\n            var pLS = aFC.loadSymbology();\n\n            // update asynch data\n            var pLD = aFC.getLayerData().then(function (ld) {\n                _this2._geometryType = ld.geometryType;\n                aFC.nameField = _this2.config.nameField || ld.nameField || '';\n            });\n\n            var pFC = this.getFeatureCount().then(function (fc) {\n                _this2._fcount = fc;\n            });\n\n            // if file based (or server extent was fried), calculate extent based on geometry\n            if (!this.extent || !this.extent.xmin) {\n                this.extent = this._apiRef.proj.graphicsUtils.graphicsExtent(this._layer.graphics);\n            }\n\n            loadPromises.push(pLD, pFC, pLS);\n            Promise.all(loadPromises).then(function () {\n                _this2._stateChange(shared.states.LOADED);\n            });\n        }\n    }, {\n        key: 'getFeatureCount',\n        value: function getFeatureCount() {\n            // just use the layer url (or lack of in case of file layer)\n            return _get(FeatureRecord.prototype.__proto__ || Object.getPrototypeOf(FeatureRecord.prototype), 'getFeatureCount', this).call(this, this._layer.url);\n        }\n    }, {\n        key: 'isFileLayer',\n        value: function isFileLayer() {\n            // TODO revisit.  is it robust enough?\n            return this._layer && this._layer.url === '';\n        }\n\n        // TODO determine who is setting this. if we have an internal\n        //      snapshot process, it might become a read-only property\n\n    }, {\n        key: 'onMouseOver',\n        value: function onMouseOver(e) {\n            var _this3 = this;\n\n            /* discussion on quick-lookup.\r\n            there are two different ways to get attributes from the server for a single feature.\r\n            1. using the feature rest endpoint (FR)\r\n            2. using the feature layer's query function (FQ)\r\n            FR returns a smaller response object (it omits a pile of layer metadata). this is good.\r\n            FR is used in the hilight module. so we are already caching that response and have the\r\n            code to make the FR request. this is good.\r\n            FR always includes the geometry. which means if we hover over a feature with massive geometry and\r\n            a small attribute set, we will download way more data than we want. this is bad.\r\n            FQ has a larger response in general (metadata that we dont care about). this is bad.\r\n            FQ can omit the geometry. this is good.\r\n            FQ is not being used elsewhere, so we would have to write a new function and cache. this is bad.\r\n            Conclusion:  for time being, we will use the FR approach. In most cases it will be faster. The\r\n            one potential problem (massive geometry polys) would only have the impact of the maptip not showing\r\n            promptly (or timing out).\r\n            If we find this is a major issue, suggest re-doing fetchGraphic to use FQ for both hover and hilight,\r\n            adding parameters to include or omit the geometry.\r\n            */\n\n            if (this._hoverListeners.length > 0) {\n\n                var showBundle = {\n                    type: 'mouseOver',\n                    point: e.screenPoint,\n                    target: e.target\n                };\n\n                // tell anyone listening we moused into something\n                this._fireEvent(this._hoverListeners, showBundle);\n\n                // pull metadata for this layer.\n                var oid = void 0;\n                this.getLayerData().then(function (lInfo) {\n                    // graphic attributes will only have the OID if layer is server based\n                    oid = e.graphic.attributes[lInfo.oidField];\n\n                    var attribSetPromise = void 0;\n                    if (_this3._featClasses[_this3._defaultFC].attribsLoaded()) {\n                        // we have already pulled attributes from the server. use them.\n                        attribSetPromise = _this3.getAttribs();\n                    } else {\n                        // we have not pulled attributes from the server.\n                        // instead of downloading them all, just get the one\n                        // we are interested in\n                        attribSetPromise = _this3.fetchGraphic(oid, true).then(function (graphicBundle) {\n                            var fakeSet = {\n                                features: [graphicBundle.graphic],\n                                oidIndex: {}\n                            };\n                            fakeSet.oidIndex[oid] = 0; // because only one feature added above\n                            return fakeSet;\n                        });\n                    }\n                    return Promise.all([Promise.resolve(lInfo), attribSetPromise]);\n                }).then(function (_ref) {\n                    var _ref2 = _slicedToArray(_ref, 2),\n                        lInfo = _ref2[0],\n                        aInfo = _ref2[1];\n\n                    // get name via attribs and name field\n                    var featAttribs = aInfo.features[aInfo.oidIndex[oid]].attributes;\n\n                    // get icon via renderer and geoApi call\n                    var svgcode = _this3._apiRef.symbology.getGraphicIcon(featAttribs, lInfo.renderer);\n\n                    // duplicate the position so listener can verify this event is same as mouseOver event above\n                    var loadBundle = {\n                        type: 'tipLoaded',\n                        name: _this3.getFeatureName(oid, featAttribs),\n                        target: e.target,\n                        svgcode: svgcode\n                    };\n\n                    // tell anyone listening we moused into something\n                    _this3._fireEvent(_this3._hoverListeners, loadBundle);\n                });\n            }\n        }\n    }, {\n        key: 'onMouseOut',\n        value: function onMouseOut(e) {\n            // tell anyone listening we moused out\n            var outBundle = {\n                type: 'mouseOut',\n                target: e.target\n            };\n            this._fireEvent(this._hoverListeners, outBundle);\n        }\n\n        /**\r\n        * Run a query on a feature layer, return the result as a promise.  Fills the panelData array on resolution. // TODO update\r\n        * @function identify\r\n        * @param {Object} opts additional argumets like map object, clickEvent, etc.\r\n        * @returns {Object} an object with identify results array and identify promise resolving when identify is complete; if an empty object is returned, it will be skipped\r\n        */\n\n    }, {\n        key: 'identify',\n        value: function identify(opts) {\n            var _this4 = this;\n\n            // TODO add full documentation for options parameter\n\n            // early kickout check. not loaded/error; not visible; not queryable; off scale\n            if (!shared.layerLoaded(this.state) || !this.visibility || !this.isQueryable() || this.isOffScale(opts.map.getScale()).offScale) {\n\n                // TODO verifiy this is correct result format if layer should be excluded from the identify process\n                return { identifyResults: [], identifyPromise: Promise.resolve() };\n            }\n\n            var identifyResult = new shared.IdentifyResult(this.getProxy());\n            var tolerance = opts.tolerance || this.clickTolerance;\n\n            // run a spatial query\n            var qry = new this._apiRef.layer.Query();\n            qry.outFields = ['*']; // this will result in just objectid fields, as that is all we have in feature layers\n\n            // more accurate results without making the buffer if we're dealing with extents\n            // polygons from added file need buffer\n            // TODO further investigate why esri is requiring buffer for file-based polygons. logic says it shouldnt\n            if (this._layer.geometryType === 'esriGeometryPolygon' && !this.isFileLayer()) {\n                qry.geometry = opts.geometry;\n            } else {\n                qry.geometry = this.makeClickBuffer(opts.clickEvent.mapPoint, opts.map, tolerance);\n            }\n\n            var identifyPromise = Promise.all([this.getAttribs(), Promise.resolve(this._layer.queryFeatures(qry)), this.getLayerData()]).then(function (_ref3) {\n                var _ref4 = _slicedToArray(_ref3, 3),\n                    attributes = _ref4[0],\n                    queryResult = _ref4[1],\n                    layerData = _ref4[2];\n\n                // transform attributes of query results into {name,data} objects one object per queried feature\n                //\n                // each feature will have its attributes converted into a table\n                // placeholder for now until we figure out how to signal the panel that\n                // we want to make a nice table\n                identifyResult.isLoading = false;\n                identifyResult.data = queryResult.features.map(function (feat) {\n                    // grab the object id of the feature we clicked on.\n                    var objId = feat.attributes[layerData.oidField];\n                    var objIdStr = objId.toString();\n\n                    // use object id find location of our feature in the feature array, and grab its attributes\n                    var featAttribs = attributes.features[attributes.oidIndex[objIdStr]].attributes;\n                    return {\n                        name: _this4.getFeatureName(objIdStr, featAttribs),\n                        data: _this4.attributesToDetails(featAttribs, layerData.fields),\n                        oid: objId,\n                        symbology: [{ svgcode: _this4._apiRef.symbology.getGraphicIcon(featAttribs, layerData.renderer) }]\n                    };\n                });\n            });\n\n            return { identifyResults: [identifyResult], identifyPromise: identifyPromise };\n        }\n    }, {\n        key: 'isSnapshot',\n        get: function get() {\n            return this._snapshot;\n        },\n        set: function set(value) {\n            this._snapshot = value;\n        }\n    }, {\n        key: 'layerType',\n        get: function get() {\n            return shared.clientLayerType.ESRI_FEATURE;\n        }\n    }, {\n        key: 'featureCount',\n        get: function get() {\n            return this._fcount;\n        }\n    }]);\n\n    return FeatureRecord;\n}(attribRecord.AttribRecord);\n\nmodule.exports = function () {\n    return {\n        FeatureRecord: FeatureRecord\n    };\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXIvbGF5ZXJSZWMvZmVhdHVyZVJlY29yZC5qcz8wMTAxIl0sIm5hbWVzIjpbImF0dHJpYkZDIiwicmVxdWlyZSIsInBsYWNlaG9sZGVyRkMiLCJhdHRyaWJSZWNvcmQiLCJsYXllckludGVyZmFjZSIsInNoYXJlZCIsIkZlYXR1cmVSZWNvcmQiLCJsYXllckNsYXNzIiwiZXNyaVJlcXVlc3QiLCJhcGlSZWYiLCJjb25maWciLCJlc3JpTGF5ZXIiLCJlcHNnTG9va3VwIiwiX2RlZmF1bHRGQyIsIl9mZWF0Q2xhc3NlcyIsIlBsYWNlaG9sZGVyRkMiLCJuYW1lIiwiX2dlb21ldHJ5VHlwZSIsInVuZGVmaW5lZCIsIl9mY291bnQiLCJjZmciLCJtb2RlIiwic3RhdGUiLCJzbmFwc2hvdCIsIl9sYXllckNsYXNzIiwiTU9ERV9TTkFQU0hPVCIsIk1PREVfT05ERU1BTkQiLCJfc25hcHNob3QiLCJfcm9vdFByb3h5IiwiTGF5ZXJJbnRlcmZhY2UiLCJpbml0aWFsQ29uZmlnIiwiY29udHJvbHMiLCJjb252ZXJ0VG9GZWF0dXJlTGF5ZXIiLCJsb2FkUHJvbWlzZXMiLCJhdHRyaWJQYWNrYWdlIiwiZmVhdElkeCIsImlzRmlsZUxheWVyIiwiX2FwaVJlZiIsImF0dHJpYnMiLCJsb2FkRmlsZUF0dHJpYnMiLCJfbGF5ZXIiLCJzcGxpdFVybCIsInBhcnNlVXJsSW5kZXgiLCJ1cmwiLCJpbmRleCIsInJvb3RVcmwiLCJsb2FkU2VydmVyQXR0cmlicyIsIm91dGZpZWxkcyIsImFGQyIsIkF0dHJpYkZDIiwicExTIiwibG9hZFN5bWJvbG9neSIsInBMRCIsImdldExheWVyRGF0YSIsInRoZW4iLCJsZCIsImdlb21ldHJ5VHlwZSIsIm5hbWVGaWVsZCIsInBGQyIsImdldEZlYXR1cmVDb3VudCIsImZjIiwiZXh0ZW50IiwieG1pbiIsInByb2oiLCJncmFwaGljc1V0aWxzIiwiZ3JhcGhpY3NFeHRlbnQiLCJncmFwaGljcyIsInB1c2giLCJQcm9taXNlIiwiYWxsIiwiX3N0YXRlQ2hhbmdlIiwic3RhdGVzIiwiTE9BREVEIiwiZSIsIl9ob3Zlckxpc3RlbmVycyIsImxlbmd0aCIsInNob3dCdW5kbGUiLCJ0eXBlIiwicG9pbnQiLCJzY3JlZW5Qb2ludCIsInRhcmdldCIsIl9maXJlRXZlbnQiLCJvaWQiLCJncmFwaGljIiwiYXR0cmlidXRlcyIsImxJbmZvIiwib2lkRmllbGQiLCJhdHRyaWJTZXRQcm9taXNlIiwiYXR0cmlic0xvYWRlZCIsImdldEF0dHJpYnMiLCJmZXRjaEdyYXBoaWMiLCJmYWtlU2V0IiwiZmVhdHVyZXMiLCJncmFwaGljQnVuZGxlIiwib2lkSW5kZXgiLCJyZXNvbHZlIiwiYUluZm8iLCJmZWF0QXR0cmlicyIsInN2Z2NvZGUiLCJzeW1ib2xvZ3kiLCJnZXRHcmFwaGljSWNvbiIsInJlbmRlcmVyIiwibG9hZEJ1bmRsZSIsImdldEZlYXR1cmVOYW1lIiwib3V0QnVuZGxlIiwib3B0cyIsImxheWVyTG9hZGVkIiwidmlzaWJpbGl0eSIsImlzUXVlcnlhYmxlIiwiaXNPZmZTY2FsZSIsIm1hcCIsImdldFNjYWxlIiwib2ZmU2NhbGUiLCJpZGVudGlmeVJlc3VsdHMiLCJpZGVudGlmeVByb21pc2UiLCJpZGVudGlmeVJlc3VsdCIsIklkZW50aWZ5UmVzdWx0IiwiZ2V0UHJveHkiLCJ0b2xlcmFuY2UiLCJjbGlja1RvbGVyYW5jZSIsInFyeSIsImxheWVyIiwiUXVlcnkiLCJvdXRGaWVsZHMiLCJnZW9tZXRyeSIsIm1ha2VDbGlja0J1ZmZlciIsImNsaWNrRXZlbnQiLCJtYXBQb2ludCIsInF1ZXJ5RmVhdHVyZXMiLCJxdWVyeVJlc3VsdCIsImxheWVyRGF0YSIsImlzTG9hZGluZyIsImRhdGEiLCJvYmpJZCIsImZlYXQiLCJvYmpJZFN0ciIsInRvU3RyaW5nIiwiYXR0cmlidXRlc1RvRGV0YWlscyIsImZpZWxkcyIsInZhbHVlIiwiY2xpZW50TGF5ZXJUeXBlIiwiRVNSSV9GRUFUVVJFIiwiQXR0cmliUmVjb3JkIiwi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QyxRQUExQixDQUFkO0FBQ0Esd0JBQU1pRCxXQUFXRixNQUFNRyxRQUFOLEVBQWpCOztBQUVBO0FBQ0Esd0JBQU12QyxjQUFjYixXQUFXUSxRQUFYLENBQW9CUixXQUFXVSxRQUFYLENBQW9CeUMsUUFBcEIsQ0FBcEIsRUFBbURuRCxVQUF2RTtBQUNBLDJCQUFPO0FBQ0hwRSw4QkFBTSxPQUFLdUYsY0FBTCxDQUFvQmdDLFFBQXBCLEVBQThCdEMsV0FBOUIsQ0FESDtBQUVIbUMsOEJBQU0sT0FBS0ssbUJBQUwsQ0FBeUJ4QyxXQUF6QixFQUFzQ2lDLFVBQVVRLE1BQWhELENBRkg7QUFHSHhELDZCQUFLbUQsS0FIRjtBQUlIbEMsbUNBQVcsQ0FDUCxFQUFFRCxTQUFTLE9BQUs3RCxPQUFMLENBQWE4RCxTQUFiLENBQXVCQyxjQUF2QixDQUFzQ0gsV0FBdEMsRUFBbURpQyxVQUFVN0IsUUFBN0QsQ0FBWCxFQURPO0FBSlIscUJBQVA7QUFRSCxpQkFoQmlCLENBQXRCO0FBaUJILGFBN0JtQixDQUF4Qjs7QUErQkEsbUJBQU8sRUFBRVksaUJBQWlCLENBQUNFLGNBQUQsQ0FBbkIsRUFBcUNELGdDQUFyQyxFQUFQO0FBQ0g7Ozs0QkFuS2lCO0FBQUUsbUJBQU8sS0FBS3ZGLFNBQVo7QUFBd0IsUzswQkFDNUJnSCxLLEVBQU87QUFBRSxpQkFBS2hILFNBQUwsR0FBaUJnSCxLQUFqQjtBQUF5Qjs7OzRCQUVqQztBQUFFLG1CQUFPdEksT0FBT3VJLGVBQVAsQ0FBdUJDLFlBQTlCO0FBQTZDOzs7NEJBRTVDO0FBQUUsbUJBQU8sS0FBSzFILE9BQVo7QUFBc0I7Ozs7RUExSHBCaEIsYUFBYTJJLFk7O0FBNFJ6Q0MsT0FBT0MsT0FBUCxHQUFpQjtBQUFBLFdBQU87QUFDcEIxSTtBQURvQixLQUFQO0FBQUEsQ0FBakIiLCJmaWxlIjoiODQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG5jb25zdCBhdHRyaWJGQyA9IHJlcXVpcmUoJy4vYXR0cmliRkMuanMnKSgpO1xyXG5jb25zdCBwbGFjZWhvbGRlckZDID0gcmVxdWlyZSgnLi9wbGFjZWhvbGRlckZDLmpzJykoKTtcclxuY29uc3QgYXR0cmliUmVjb3JkID0gcmVxdWlyZSgnLi9hdHRyaWJSZWNvcmQuanMnKSgpO1xyXG5jb25zdCBsYXllckludGVyZmFjZSA9IHJlcXVpcmUoJy4vbGF5ZXJJbnRlcmZhY2UuanMnKSgpO1xyXG5jb25zdCBzaGFyZWQgPSByZXF1aXJlKCcuL3NoYXJlZC5qcycpKCk7XHJcblxyXG4vKipcclxuICogQGNsYXNzIEZlYXR1cmVSZWNvcmRcclxuICovXHJcbmNsYXNzIEZlYXR1cmVSZWNvcmQgZXh0ZW5kcyBhdHRyaWJSZWNvcmQuQXR0cmliUmVjb3JkIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIGxheWVyIHJlY29yZCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBnZW9BcGkgbGF5ZXIgdHlwZS4gIExheWVyIGNvbmZpZ1xyXG4gICAgICogc2hvdWxkIGJlIGZ1bGx5IG1lcmdlZCB3aXRoIGFsbCBsYXllciBvcHRpb25zIGRlZmluZWQgKGkuZS4gdGhpcyBjb25zdHJ1Y3RvclxyXG4gICAgICogd2lsbCBub3QgYXBwbHkgYW55IGRlZmF1bHRzKS5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBsYXllckNsYXNzICAgIHRoZSBFU1JJIGFwaSBvYmplY3QgZm9yIGZlYXR1cmUgbGF5ZXJzXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXNyaVJlcXVlc3QgICB0aGUgRVNSSSBhcGkgb2JqZWN0IGZvciBtYWtpbmcgd2ViIHJlcXVlc3RzIHdpdGggcHJveHkgc3VwcG9ydFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFwaVJlZiAgICAgICAgb2JqZWN0IHBvaW50aW5nIHRvIHRoZSBnZW9BcGkuIGFsbG93cyB1cyB0byBjYWxsIG90aGVyIGdlb0FwaSBmdW5jdGlvbnMuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnICAgICAgICBsYXllciBjb25maWcgdmFsdWVzXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXNyaUxheWVyICAgICBhbiBvcHRpb25hbCBwcmUtY29uc3RydWN0ZWQgbGF5ZXJcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVwc2dMb29rdXAgIGFuIG9wdGlvbmFsIGxvb2t1cCBmdW5jdGlvbiBmb3IgRVBTRyBjb2RlcyAoc2VlIGdlb1NlcnZpY2UgZm9yIHNpZ25hdHVyZSlcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IgKGxheWVyQ2xhc3MsIGVzcmlSZXF1ZXN0LCBhcGlSZWYsIGNvbmZpZywgZXNyaUxheWVyLCBlcHNnTG9va3VwKSB7XHJcbiAgICAgICAgc3VwZXIobGF5ZXJDbGFzcywgZXNyaVJlcXVlc3QsIGFwaVJlZiwgY29uZmlnLCBlc3JpTGF5ZXIsIGVwc2dMb29rdXApO1xyXG5cclxuICAgICAgICAvLyBoYW5kbGVzIHBsYWNlaG9sZGVyIHN5bWJvbCwgcG9zc2libHkgb3RoZXIgdGhpbmdzXHJcbiAgICAgICAgLy8gaWYgd2Ugd2VyZSBwYXNzZWQgYSBwcmUtbG9hZGVkIGxheWVyLCB3ZSBza2lwIHRoaXMgKGl0IHdpbGwgcnVuIGFmdGVyIHRoZSBsb2FkIHRyaWdnZXJzXHJcbiAgICAgICAgLy8gaW4gdGhlIHN1cGVyLWNvbnN0cnVjdG9yLCB0aHVzIG92ZXJ3cml0aW5nIG91ciBnb29kIHJlc3VsdHMpXHJcbiAgICAgICAgaWYgKCFlc3JpTGF5ZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5fZGVmYXVsdEZDID0gJzAnO1xyXG4gICAgICAgICAgICB0aGlzLl9mZWF0Q2xhc3Nlc1snMCddID0gbmV3IHBsYWNlaG9sZGVyRkMuUGxhY2Vob2xkZXJGQyh0aGlzLCB0aGlzLm5hbWUpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5fZ2VvbWV0cnlUeXBlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB0aGlzLl9mY291bnQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIG1ha2VMYXllckNvbmZpZyAoKSB7XHJcbiAgICAgICAgY29uc3QgY2ZnID0gc3VwZXIubWFrZUxheWVyQ29uZmlnKCk7XHJcbiAgICAgICAgY2ZnLm1vZGUgPSB0aGlzLmNvbmZpZy5zdGF0ZS5zbmFwc2hvdCA/IHRoaXMuX2xheWVyQ2xhc3MuTU9ERV9TTkFQU0hPVFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5fbGF5ZXJDbGFzcy5NT0RFX09OREVNQU5EO1xyXG5cclxuICAgICAgICAvLyBUT0RPIGNvbmZpcm0gdGhpcyBsb2dpYy4gb2xkIGNvZGUgbWFwcGVkIC5vcHRpb25zLnNuYXBzaG90LnZhbHVlIHRvIHRoZSBidXR0b24gLS0gbWVhbmluZyBpZiB3ZSB3ZXJlIGluIHNuYXBzaG90IG1vZGUsXHJcbiAgICAgICAgLy8gICAgICB3ZSB3b3VsZCB3YW50IHRoZSBidXR0b24gZGlzYWJsZWQuIGluIHRoZSByZWZhY3RvciwgdGhlIGJ1dHRvbiBtYXkgZ2V0IGl0J3MgZW5hYmxlZC9kaXNhYmxlZCBmcm9tIGEgZGlmZmVyZW50IHNvdXJjZS5cclxuICAgICAgICAvLyB0aGlzLmNvbmZpZy5zdGF0ZS5zbmFwc2hvdCA9ICF0aGlzLmNvbmZpZy5zdGF0ZS5zbmFwc2hvdDtcclxuICAgICAgICB0aGlzLl9zbmFwc2hvdCA9IHRoaXMuY29uZmlnLnN0YXRlLnNuYXBzaG90O1xyXG5cclxuICAgICAgICByZXR1cm4gY2ZnO1xyXG4gICAgfVxyXG5cclxuICAgIGdldEdlb21UeXBlICgpIHtcclxuICAgICAgICAvLyBzdGFuZGFyZCBjYXNlLCBsYXllciBoYXMgbm8gZ2VvbWV0cnkuIFRoaXMgZ2V0cyBvdmVycmlkZGVuIGluIGZlYXR1cmUtYmFzZWQgUmVjb3JkIGNsYXNzZXMuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dlb21ldHJ5VHlwZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyByZXR1cm5zIHRoZSBwcm94eSBpbnRlcmZhY2Ugb2JqZWN0IGZvciB0aGUgcm9vdCBvZiB0aGUgbGF5ZXIgKGkuZS4gbWFpbiBlbnRyeSBpbiBsZWdlbmQsIG5vdCBuZXN0ZWQgY2hpbGQgdGhpbmdzKVxyXG4gICAgLy8gVE9ETyBkb2NzXHJcbiAgICBnZXRQcm94eSAoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9yb290UHJveHkpIHtcclxuICAgICAgICAgICAgdGhpcy5fcm9vdFByb3h5ID0gbmV3IGxheWVySW50ZXJmYWNlLkxheWVySW50ZXJmYWNlKHRoaXMsIHRoaXMuaW5pdGlhbENvbmZpZy5jb250cm9scyk7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RQcm94eS5jb252ZXJ0VG9GZWF0dXJlTGF5ZXIodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9yb290UHJveHk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFRyaWdnZXJzIHdoZW4gdGhlIGxheWVyIGxvYWRzLlxyXG4gICAgKlxyXG4gICAgKiBAZnVuY3Rpb24gb25Mb2FkXHJcbiAgICAqL1xyXG4gICAgb25Mb2FkICgpIHtcclxuICAgICAgICBjb25zdCBsb2FkUHJvbWlzZXMgPSBzdXBlci5vbkxvYWQoKTtcclxuXHJcbiAgICAgICAgLy8gZ2V0IGF0dHJpYnV0ZSBwYWNrYWdlXHJcbiAgICAgICAgbGV0IGF0dHJpYlBhY2thZ2U7XHJcbiAgICAgICAgbGV0IGZlYXRJZHg7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNGaWxlTGF5ZXIoKSkge1xyXG4gICAgICAgICAgICBmZWF0SWR4ID0gJzAnO1xyXG4gICAgICAgICAgICBhdHRyaWJQYWNrYWdlID0gdGhpcy5fYXBpUmVmLmF0dHJpYnMubG9hZEZpbGVBdHRyaWJzKHRoaXMuX2xheWVyKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBzcGxpdFVybCA9IHNoYXJlZC5wYXJzZVVybEluZGV4KHRoaXMuX2xheWVyLnVybCk7XHJcbiAgICAgICAgICAgIGZlYXRJZHggPSBzcGxpdFVybC5pbmRleDtcclxuICAgICAgICAgICAgdGhpcy5yb290VXJsID0gc3BsaXRVcmwucm9vdFVybDtcclxuICAgICAgICAgICAgYXR0cmliUGFja2FnZSA9IHRoaXMuX2FwaVJlZi5hdHRyaWJzLmxvYWRTZXJ2ZXJBdHRyaWJzKHNwbGl0VXJsLnJvb3RVcmwsIGZlYXRJZHgsIHRoaXMuY29uZmlnLm91dGZpZWxkcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBmZWF0dXJlIGhhcyBvbmx5IG9uZSBsYXllclxyXG4gICAgICAgIGNvbnN0IGFGQyA9IG5ldyBhdHRyaWJGQy5BdHRyaWJGQyh0aGlzLCBmZWF0SWR4LCBhdHRyaWJQYWNrYWdlLCB0aGlzLmNvbmZpZyk7XHJcbiAgICAgICAgdGhpcy5fZGVmYXVsdEZDID0gZmVhdElkeDtcclxuICAgICAgICB0aGlzLl9mZWF0Q2xhc3Nlc1tmZWF0SWR4XSA9IGFGQztcclxuXHJcbiAgICAgICAgY29uc3QgcExTID0gYUZDLmxvYWRTeW1ib2xvZ3koKTtcclxuXHJcbiAgICAgICAgLy8gdXBkYXRlIGFzeW5jaCBkYXRhXHJcbiAgICAgICAgY29uc3QgcExEID0gYUZDLmdldExheWVyRGF0YSgpLnRoZW4obGQgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9nZW9tZXRyeVR5cGUgPSBsZC5nZW9tZXRyeVR5cGU7XHJcbiAgICAgICAgICAgIGFGQy5uYW1lRmllbGQgPSB0aGlzLmNvbmZpZy5uYW1lRmllbGQgfHwgbGQubmFtZUZpZWxkIHx8ICcnO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBjb25zdCBwRkMgPSB0aGlzLmdldEZlYXR1cmVDb3VudCgpLnRoZW4oZmMgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9mY291bnQgPSBmYztcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gaWYgZmlsZSBiYXNlZCAob3Igc2VydmVyIGV4dGVudCB3YXMgZnJpZWQpLCBjYWxjdWxhdGUgZXh0ZW50IGJhc2VkIG9uIGdlb21ldHJ5XHJcbiAgICAgICAgaWYgKCF0aGlzLmV4dGVudCB8fCAhdGhpcy5leHRlbnQueG1pbikge1xyXG4gICAgICAgICAgICB0aGlzLmV4dGVudCA9IHRoaXMuX2FwaVJlZi5wcm9qLmdyYXBoaWNzVXRpbHMuZ3JhcGhpY3NFeHRlbnQodGhpcy5fbGF5ZXIuZ3JhcGhpY3MpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbG9hZFByb21pc2VzLnB1c2gocExELCBwRkMsIHBMUyk7XHJcbiAgICAgICAgUHJvbWlzZS5hbGwobG9hZFByb21pc2VzKS50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fc3RhdGVDaGFuZ2Uoc2hhcmVkLnN0YXRlcy5MT0FERUQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGdldEZlYXR1cmVDb3VudCAoKSB7XHJcbiAgICAgICAgLy8ganVzdCB1c2UgdGhlIGxheWVyIHVybCAob3IgbGFjayBvZiBpbiBjYXNlIG9mIGZpbGUgbGF5ZXIpXHJcbiAgICAgICAgcmV0dXJuIHN1cGVyLmdldEZlYXR1cmVDb3VudCh0aGlzLl9sYXllci51cmwpO1xyXG4gICAgfVxyXG5cclxuICAgIGlzRmlsZUxheWVyICgpIHtcclxuICAgICAgICAvLyBUT0RPIHJldmlzaXQuICBpcyBpdCByb2J1c3QgZW5vdWdoP1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9sYXllciAmJiB0aGlzLl9sYXllci51cmwgPT09ICcnO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRPRE8gZGV0ZXJtaW5lIHdobyBpcyBzZXR0aW5nIHRoaXMuIGlmIHdlIGhhdmUgYW4gaW50ZXJuYWxcclxuICAgIC8vICAgICAgc25hcHNob3QgcHJvY2VzcywgaXQgbWlnaHQgYmVjb21lIGEgcmVhZC1vbmx5IHByb3BlcnR5XHJcbiAgICBnZXQgaXNTbmFwc2hvdCAoKSB7IHJldHVybiB0aGlzLl9zbmFwc2hvdDsgfVxyXG4gICAgc2V0IGlzU25hcHNob3QgKHZhbHVlKSB7IHRoaXMuX3NuYXBzaG90ID0gdmFsdWU7IH1cclxuXHJcbiAgICBnZXQgbGF5ZXJUeXBlICgpIHsgcmV0dXJuIHNoYXJlZC5jbGllbnRMYXllclR5cGUuRVNSSV9GRUFUVVJFOyB9XHJcblxyXG4gICAgZ2V0IGZlYXR1cmVDb3VudCAoKSB7IHJldHVybiB0aGlzLl9mY291bnQ7IH1cclxuXHJcbiAgICBvbk1vdXNlT3ZlciAoZSkge1xyXG4gICAgICAgIC8qIGRpc2N1c3Npb24gb24gcXVpY2stbG9va3VwLlxyXG4gICAgICAgIHRoZXJlIGFyZSB0d28gZGlmZmVyZW50IHdheXMgdG8gZ2V0IGF0dHJpYnV0ZXMgZnJvbSB0aGUgc2VydmVyIGZvciBhIHNpbmdsZSBmZWF0dXJlLlxyXG4gICAgICAgIDEuIHVzaW5nIHRoZSBmZWF0dXJlIHJlc3QgZW5kcG9pbnQgKEZSKVxyXG4gICAgICAgIDIuIHVzaW5nIHRoZSBmZWF0dXJlIGxheWVyJ3MgcXVlcnkgZnVuY3Rpb24gKEZRKVxyXG4gICAgICAgIEZSIHJldHVybnMgYSBzbWFsbGVyIHJlc3BvbnNlIG9iamVjdCAoaXQgb21pdHMgYSBwaWxlIG9mIGxheWVyIG1ldGFkYXRhKS4gdGhpcyBpcyBnb29kLlxyXG4gICAgICAgIEZSIGlzIHVzZWQgaW4gdGhlIGhpbGlnaHQgbW9kdWxlLiBzbyB3ZSBhcmUgYWxyZWFkeSBjYWNoaW5nIHRoYXQgcmVzcG9uc2UgYW5kIGhhdmUgdGhlXHJcbiAgICAgICAgY29kZSB0byBtYWtlIHRoZSBGUiByZXF1ZXN0LiB0aGlzIGlzIGdvb2QuXHJcbiAgICAgICAgRlIgYWx3YXlzIGluY2x1ZGVzIHRoZSBnZW9tZXRyeS4gd2hpY2ggbWVhbnMgaWYgd2UgaG92ZXIgb3ZlciBhIGZlYXR1cmUgd2l0aCBtYXNzaXZlIGdlb21ldHJ5IGFuZFxyXG4gICAgICAgIGEgc21hbGwgYXR0cmlidXRlIHNldCwgd2Ugd2lsbCBkb3dubG9hZCB3YXkgbW9yZSBkYXRhIHRoYW4gd2Ugd2FudC4gdGhpcyBpcyBiYWQuXHJcbiAgICAgICAgRlEgaGFzIGEgbGFyZ2VyIHJlc3BvbnNlIGluIGdlbmVyYWwgKG1ldGFkYXRhIHRoYXQgd2UgZG9udCBjYXJlIGFib3V0KS4gdGhpcyBpcyBiYWQuXHJcbiAgICAgICAgRlEgY2FuIG9taXQgdGhlIGdlb21ldHJ5LiB0aGlzIGlzIGdvb2QuXHJcbiAgICAgICAgRlEgaXMgbm90IGJlaW5nIHVzZWQgZWxzZXdoZXJlLCBzbyB3ZSB3b3VsZCBoYXZlIHRvIHdyaXRlIGEgbmV3IGZ1bmN0aW9uIGFuZCBjYWNoZS4gdGhpcyBpcyBiYWQuXHJcbiAgICAgICAgQ29uY2x1c2lvbjogIGZvciB0aW1lIGJlaW5nLCB3ZSB3aWxsIHVzZSB0aGUgRlIgYXBwcm9hY2guIEluIG1vc3QgY2FzZXMgaXQgd2lsbCBiZSBmYXN0ZXIuIFRoZVxyXG4gICAgICAgIG9uZSBwb3RlbnRpYWwgcHJvYmxlbSAobWFzc2l2ZSBnZW9tZXRyeSBwb2x5cykgd291bGQgb25seSBoYXZlIHRoZSBpbXBhY3Qgb2YgdGhlIG1hcHRpcCBub3Qgc2hvd2luZ1xyXG4gICAgICAgIHByb21wdGx5IChvciB0aW1pbmcgb3V0KS5cclxuICAgICAgICBJZiB3ZSBmaW5kIHRoaXMgaXMgYSBtYWpvciBpc3N1ZSwgc3VnZ2VzdCByZS1kb2luZyBmZXRjaEdyYXBoaWMgdG8gdXNlIEZRIGZvciBib3RoIGhvdmVyIGFuZCBoaWxpZ2h0LFxyXG4gICAgICAgIGFkZGluZyBwYXJhbWV0ZXJzIHRvIGluY2x1ZGUgb3Igb21pdCB0aGUgZ2VvbWV0cnkuXHJcbiAgICAgICAgKi9cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX2hvdmVyTGlzdGVuZXJzLmxlbmd0aCA+IDApIHtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHNob3dCdW5kbGUgPSB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnbW91c2VPdmVyJyxcclxuICAgICAgICAgICAgICAgIHBvaW50OiBlLnNjcmVlblBvaW50LFxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBlLnRhcmdldFxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLy8gdGVsbCBhbnlvbmUgbGlzdGVuaW5nIHdlIG1vdXNlZCBpbnRvIHNvbWV0aGluZ1xyXG4gICAgICAgICAgICB0aGlzLl9maXJlRXZlbnQodGhpcy5faG92ZXJMaXN0ZW5lcnMsIHNob3dCdW5kbGUpO1xyXG5cclxuICAgICAgICAgICAgLy8gcHVsbCBtZXRhZGF0YSBmb3IgdGhpcyBsYXllci5cclxuICAgICAgICAgICAgbGV0IG9pZDtcclxuICAgICAgICAgICAgdGhpcy5nZXRMYXllckRhdGEoKS50aGVuKGxJbmZvID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIGdyYXBoaWMgYXR0cmlidXRlcyB3aWxsIG9ubHkgaGF2ZSB0aGUgT0lEIGlmIGxheWVyIGlzIHNlcnZlciBiYXNlZFxyXG4gICAgICAgICAgICAgICAgb2lkID0gZS5ncmFwaGljLmF0dHJpYnV0ZXNbbEluZm8ub2lkRmllbGRdO1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCBhdHRyaWJTZXRQcm9taXNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2ZlYXRDbGFzc2VzW3RoaXMuX2RlZmF1bHRGQ10uYXR0cmlic0xvYWRlZCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgaGF2ZSBhbHJlYWR5IHB1bGxlZCBhdHRyaWJ1dGVzIGZyb20gdGhlIHNlcnZlci4gdXNlIHRoZW0uXHJcbiAgICAgICAgICAgICAgICAgICAgYXR0cmliU2V0UHJvbWlzZSA9IHRoaXMuZ2V0QXR0cmlicygpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBoYXZlIG5vdCBwdWxsZWQgYXR0cmlidXRlcyBmcm9tIHRoZSBzZXJ2ZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5zdGVhZCBvZiBkb3dubG9hZGluZyB0aGVtIGFsbCwganVzdCBnZXQgdGhlIG9uZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGFyZSBpbnRlcmVzdGVkIGluXHJcbiAgICAgICAgICAgICAgICAgICAgYXR0cmliU2V0UHJvbWlzZSA9IHRoaXMuZmV0Y2hHcmFwaGljKG9pZCwgdHJ1ZSkudGhlbihncmFwaGljQnVuZGxlID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmFrZVNldCA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmVzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JhcGhpY0J1bmRsZS5ncmFwaGljXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2lkSW5kZXg6IHt9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZha2VTZXQub2lkSW5kZXhbb2lkXSA9IDA7IC8vIGJlY2F1c2Ugb25seSBvbmUgZmVhdHVyZSBhZGRlZCBhYm92ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFrZVNldDtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbUHJvbWlzZS5yZXNvbHZlKGxJbmZvKSwgYXR0cmliU2V0UHJvbWlzZV0pO1xyXG4gICAgICAgICAgICB9KS50aGVuKChbbEluZm8sIGFJbmZvXSkgPT4ge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGdldCBuYW1lIHZpYSBhdHRyaWJzIGFuZCBuYW1lIGZpZWxkXHJcbiAgICAgICAgICAgICAgICBjb25zdCBmZWF0QXR0cmlicyA9IGFJbmZvLmZlYXR1cmVzW2FJbmZvLm9pZEluZGV4W29pZF1dLmF0dHJpYnV0ZXM7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gZ2V0IGljb24gdmlhIHJlbmRlcmVyIGFuZCBnZW9BcGkgY2FsbFxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3ZnY29kZSA9IHRoaXMuX2FwaVJlZi5zeW1ib2xvZ3kuZ2V0R3JhcGhpY0ljb24oZmVhdEF0dHJpYnMsIGxJbmZvLnJlbmRlcmVyKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBkdXBsaWNhdGUgdGhlIHBvc2l0aW9uIHNvIGxpc3RlbmVyIGNhbiB2ZXJpZnkgdGhpcyBldmVudCBpcyBzYW1lIGFzIG1vdXNlT3ZlciBldmVudCBhYm92ZVxyXG4gICAgICAgICAgICAgICAgY29uc3QgbG9hZEJ1bmRsZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAndGlwTG9hZGVkJyxcclxuICAgICAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLmdldEZlYXR1cmVOYW1lKG9pZCwgZmVhdEF0dHJpYnMpLFxyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogZS50YXJnZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgc3ZnY29kZVxyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyB0ZWxsIGFueW9uZSBsaXN0ZW5pbmcgd2UgbW91c2VkIGludG8gc29tZXRoaW5nXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9maXJlRXZlbnQodGhpcy5faG92ZXJMaXN0ZW5lcnMsIGxvYWRCdW5kbGUpO1xyXG5cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIG9uTW91c2VPdXQgKGUpIHtcclxuICAgICAgICAvLyB0ZWxsIGFueW9uZSBsaXN0ZW5pbmcgd2UgbW91c2VkIG91dFxyXG4gICAgICAgIGNvbnN0IG91dEJ1bmRsZSA9IHtcclxuICAgICAgICAgICAgdHlwZTogJ21vdXNlT3V0JyxcclxuICAgICAgICAgICAgdGFyZ2V0OiBlLnRhcmdldFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5fZmlyZUV2ZW50KHRoaXMuX2hvdmVyTGlzdGVuZXJzLCBvdXRCdW5kbGUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBSdW4gYSBxdWVyeSBvbiBhIGZlYXR1cmUgbGF5ZXIsIHJldHVybiB0aGUgcmVzdWx0IGFzIGEgcHJvbWlzZS4gIEZpbGxzIHRoZSBwYW5lbERhdGEgYXJyYXkgb24gcmVzb2x1dGlvbi4gLy8gVE9ETyB1cGRhdGVcclxuICAgICogQGZ1bmN0aW9uIGlkZW50aWZ5XHJcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIGFkZGl0aW9uYWwgYXJndW1ldHMgbGlrZSBtYXAgb2JqZWN0LCBjbGlja0V2ZW50LCBldGMuXHJcbiAgICAqIEByZXR1cm5zIHtPYmplY3R9IGFuIG9iamVjdCB3aXRoIGlkZW50aWZ5IHJlc3VsdHMgYXJyYXkgYW5kIGlkZW50aWZ5IHByb21pc2UgcmVzb2x2aW5nIHdoZW4gaWRlbnRpZnkgaXMgY29tcGxldGU7IGlmIGFuIGVtcHR5IG9iamVjdCBpcyByZXR1cm5lZCwgaXQgd2lsbCBiZSBza2lwcGVkXHJcbiAgICAqL1xyXG4gICAgaWRlbnRpZnkgKG9wdHMpIHtcclxuICAgICAgICAvLyBUT0RPIGFkZCBmdWxsIGRvY3VtZW50YXRpb24gZm9yIG9wdGlvbnMgcGFyYW1ldGVyXHJcblxyXG4gICAgICAgIC8vIGVhcmx5IGtpY2tvdXQgY2hlY2suIG5vdCBsb2FkZWQvZXJyb3I7IG5vdCB2aXNpYmxlOyBub3QgcXVlcnlhYmxlOyBvZmYgc2NhbGVcclxuICAgICAgICBpZiAoIXNoYXJlZC5sYXllckxvYWRlZCh0aGlzLnN0YXRlKSB8fFxyXG4gICAgICAgICAgICAhdGhpcy52aXNpYmlsaXR5IHx8XHJcbiAgICAgICAgICAgICF0aGlzLmlzUXVlcnlhYmxlKCkgfHxcclxuICAgICAgICAgICAgdGhpcy5pc09mZlNjYWxlKG9wdHMubWFwLmdldFNjYWxlKCkpLm9mZlNjYWxlKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBUT0RPIHZlcmlmaXkgdGhpcyBpcyBjb3JyZWN0IHJlc3VsdCBmb3JtYXQgaWYgbGF5ZXIgc2hvdWxkIGJlIGV4Y2x1ZGVkIGZyb20gdGhlIGlkZW50aWZ5IHByb2Nlc3NcclxuICAgICAgICAgICAgcmV0dXJuIHsgaWRlbnRpZnlSZXN1bHRzOiBbXSwgaWRlbnRpZnlQcm9taXNlOiBQcm9taXNlLnJlc29sdmUoKSB9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgaWRlbnRpZnlSZXN1bHQgPSBuZXcgc2hhcmVkLklkZW50aWZ5UmVzdWx0KHRoaXMuZ2V0UHJveHkoKSk7XHJcbiAgICAgICAgY29uc3QgdG9sZXJhbmNlID0gb3B0cy50b2xlcmFuY2UgfHwgdGhpcy5jbGlja1RvbGVyYW5jZTtcclxuXHJcbiAgICAgICAgLy8gcnVuIGEgc3BhdGlhbCBxdWVyeVxyXG4gICAgICAgIGNvbnN0IHFyeSA9IG5ldyB0aGlzLl9hcGlSZWYubGF5ZXIuUXVlcnkoKTtcclxuICAgICAgICBxcnkub3V0RmllbGRzID0gWycqJ107IC8vIHRoaXMgd2lsbCByZXN1bHQgaW4ganVzdCBvYmplY3RpZCBmaWVsZHMsIGFzIHRoYXQgaXMgYWxsIHdlIGhhdmUgaW4gZmVhdHVyZSBsYXllcnNcclxuXHJcbiAgICAgICAgLy8gbW9yZSBhY2N1cmF0ZSByZXN1bHRzIHdpdGhvdXQgbWFraW5nIHRoZSBidWZmZXIgaWYgd2UncmUgZGVhbGluZyB3aXRoIGV4dGVudHNcclxuICAgICAgICAvLyBwb2x5Z29ucyBmcm9tIGFkZGVkIGZpbGUgbmVlZCBidWZmZXJcclxuICAgICAgICAvLyBUT0RPIGZ1cnRoZXIgaW52ZXN0aWdhdGUgd2h5IGVzcmkgaXMgcmVxdWlyaW5nIGJ1ZmZlciBmb3IgZmlsZS1iYXNlZCBwb2x5Z29ucy4gbG9naWMgc2F5cyBpdCBzaG91bGRudFxyXG4gICAgICAgIGlmICh0aGlzLl9sYXllci5nZW9tZXRyeVR5cGUgPT09ICdlc3JpR2VvbWV0cnlQb2x5Z29uJyAmJiAhdGhpcy5pc0ZpbGVMYXllcigpKSB7XHJcbiAgICAgICAgICAgIHFyeS5nZW9tZXRyeSA9IG9wdHMuZ2VvbWV0cnk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcXJ5Lmdlb21ldHJ5ID0gdGhpcy5tYWtlQ2xpY2tCdWZmZXIob3B0cy5jbGlja0V2ZW50Lm1hcFBvaW50LCBvcHRzLm1hcCwgdG9sZXJhbmNlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGlkZW50aWZ5UHJvbWlzZSA9IFByb21pc2UuYWxsKFtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0QXR0cmlicygpLFxyXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2xheWVyLnF1ZXJ5RmVhdHVyZXMocXJ5KSksXHJcbiAgICAgICAgICAgICAgICB0aGlzLmdldExheWVyRGF0YSgpXHJcbiAgICAgICAgICAgIF0pXHJcbiAgICAgICAgICAgIC50aGVuKChbYXR0cmlidXRlcywgcXVlcnlSZXN1bHQsIGxheWVyRGF0YV0pID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIHRyYW5zZm9ybSBhdHRyaWJ1dGVzIG9mIHF1ZXJ5IHJlc3VsdHMgaW50byB7bmFtZSxkYXRhfSBvYmplY3RzIG9uZSBvYmplY3QgcGVyIHF1ZXJpZWQgZmVhdHVyZVxyXG4gICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgIC8vIGVhY2ggZmVhdHVyZSB3aWxsIGhhdmUgaXRzIGF0dHJpYnV0ZXMgY29udmVydGVkIGludG8gYSB0YWJsZVxyXG4gICAgICAgICAgICAgICAgLy8gcGxhY2Vob2xkZXIgZm9yIG5vdyB1bnRpbCB3ZSBmaWd1cmUgb3V0IGhvdyB0byBzaWduYWwgdGhlIHBhbmVsIHRoYXRcclxuICAgICAgICAgICAgICAgIC8vIHdlIHdhbnQgdG8gbWFrZSBhIG5pY2UgdGFibGVcclxuICAgICAgICAgICAgICAgIGlkZW50aWZ5UmVzdWx0LmlzTG9hZGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgaWRlbnRpZnlSZXN1bHQuZGF0YSA9IHF1ZXJ5UmVzdWx0LmZlYXR1cmVzLm1hcChcclxuICAgICAgICAgICAgICAgICAgICBmZWF0ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ3JhYiB0aGUgb2JqZWN0IGlkIG9mIHRoZSBmZWF0dXJlIHdlIGNsaWNrZWQgb24uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9iaklkID0gZmVhdC5hdHRyaWJ1dGVzW2xheWVyRGF0YS5vaWRGaWVsZF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9iaklkU3RyID0gb2JqSWQudG9TdHJpbmcoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVzZSBvYmplY3QgaWQgZmluZCBsb2NhdGlvbiBvZiBvdXIgZmVhdHVyZSBpbiB0aGUgZmVhdHVyZSBhcnJheSwgYW5kIGdyYWIgaXRzIGF0dHJpYnV0ZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmVhdEF0dHJpYnMgPSBhdHRyaWJ1dGVzLmZlYXR1cmVzW2F0dHJpYnV0ZXMub2lkSW5kZXhbb2JqSWRTdHJdXS5hdHRyaWJ1dGVzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogdGhpcy5nZXRGZWF0dXJlTmFtZShvYmpJZFN0ciwgZmVhdEF0dHJpYnMpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogdGhpcy5hdHRyaWJ1dGVzVG9EZXRhaWxzKGZlYXRBdHRyaWJzLCBsYXllckRhdGEuZmllbGRzKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9pZDogb2JqSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2xvZ3k6IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHN2Z2NvZGU6IHRoaXMuX2FwaVJlZi5zeW1ib2xvZ3kuZ2V0R3JhcGhpY0ljb24oZmVhdEF0dHJpYnMsIGxheWVyRGF0YS5yZW5kZXJlcikgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHsgaWRlbnRpZnlSZXN1bHRzOiBbaWRlbnRpZnlSZXN1bHRdLCBpZGVudGlmeVByb21pc2UgfTtcclxuICAgIH1cclxuXHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gKCkgPT4gKHtcclxuICAgIEZlYXR1cmVSZWNvcmRcclxufSk7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9sYXllci9sYXllclJlYy9mZWF0dXJlUmVjb3JkLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar layerRecord = __webpack_require__(20)();\nvar basicFC = __webpack_require__(19)();\nvar placeholderFC = __webpack_require__(5)();\nvar shared = __webpack_require__(2)();\n\n/**\r\n * @class ImageRecord\r\n */\n\nvar ImageRecord = function (_layerRecord$LayerRec) {\n    _inherits(ImageRecord, _layerRecord$LayerRec);\n\n    // NOTE: if we decide to support attributes from ImageServers,\n    //       we would extend from AttribRecord instead of LayerRecord\n    //       (and do a lot of testing!)\n\n    /**\r\n     * Create a layer record with the appropriate geoApi layer type.  Layer config\r\n     * should be fully merged with all layer options defined (i.e. this constructor\r\n     * will not apply any defaults).\r\n     * @param {Object} layerClass    the ESRI api object for image server layers\r\n     * @param {Object} apiRef        object pointing to the geoApi. allows us to call other geoApi functions.\r\n     * @param {Object} config        layer config values\r\n     * @param {Object} esriLayer     an optional pre-constructed layer\r\n     * @param {Function} epsgLookup  an optional lookup function for EPSG codes (see geoService for signature)\r\n     */\n    function ImageRecord(layerClass, apiRef, config, esriLayer, epsgLookup) {\n        _classCallCheck(this, ImageRecord);\n\n        // handles placeholder symbol, possibly other things\n        var _this = _possibleConstructorReturn(this, (ImageRecord.__proto__ || Object.getPrototypeOf(ImageRecord)).call(this, layerClass, apiRef, config, esriLayer, epsgLookup));\n\n        _this._defaultFC = '0';\n        _this._featClasses['0'] = new placeholderFC.PlaceholderFC(_this, _this.name);\n        return _this;\n    }\n\n    _createClass(ImageRecord, [{\n        key: 'onLoad',\n\n\n        /**\r\n        * Triggers when the layer loads.\r\n        *\r\n        * @function onLoad\r\n        */\n        value: function onLoad() {\n            var _this2 = this;\n\n            var loadPromises = _get(ImageRecord.prototype.__proto__ || Object.getPrototypeOf(ImageRecord.prototype), 'onLoad', this).call(this);\n\n            var fc = new basicFC.BasicFC(this, '0', this.config);\n            this._featClasses['0'] = fc;\n\n            loadPromises.push(fc.loadSymbology());\n\n            Promise.all(loadPromises).then(function () {\n                _this2._stateChange(shared.states.LOADED);\n            });\n        }\n    }, {\n        key: 'layerType',\n        get: function get() {\n            return shared.clientLayerType.ESRI_IMAGE;\n        }\n    }]);\n\n    return ImageRecord;\n}(layerRecord.LayerRecord);\n\nmodule.exports = function () {\n    return {\n        ImageRecord: ImageRecord\n    };\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXIvbGF5ZXJSZWMvaW1hZ2VSZWNvcmQuanM/Y2QzNyJdLCJuYW1lcyI6WyJsYXllclJlY29yZCIsInJlcXVpcmUiLCJiYXNpY0ZDIiwicGxhY2Vob2xkZXJGQyIsInNoYXJlZCIsIkltYWdlUmVjb3JkIiwibGF5ZXJDbGFzcyIsImFwaVJlZiIsImNvbmZpZyIsImVzcmlMYXllciIsImVwc2dMb29rdXAiLCJfZGVmYXVsdEZDIiwiX2ZlYXRDbGFzc2VzIiwiUGxhY2Vob2xkZXJGQyIsIm5hbWUiLCJsb2FkUHJvbWlzZXMiLCJmYyIsIkJhc2ljRkMiLCJwdXNoIiwibG9hZFN5bWJvbG9neSIsIlByb21pc2UiLCJhbGwiLCJ0aGVuIiwiX3N0YXRlQ2hhbmdlIiwic3RhdGVzIiwiTE9BREVEIiwiY2xpZW50TGF5ZXJUeXBlIiwiRVNSSV9JTUFHRSIsIkxheWVyUmVjb3JkIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7OztBQUVBLElBQU1BLGNBQWMsbUJBQUFDLENBQVEsRUFBUixHQUFwQjtBQUNBLElBQU1DLFVBQVUsbUJBQUFELENBQVEsRUFBUixHQUFoQjtBQUNBLElBQU1FLGdCQUFnQixtQkFBQUYsQ0FBUSxDQUFSLEdBQXRCO0FBQ0EsSUFBTUcsU0FBUyxtQkFBQUgsQ0FBUSxDQUFSLEdBQWY7O0FBRUE7Ozs7SUFHTUksVzs7O0FBQ0Y7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7O0FBVUEseUJBQWFDLFVBQWIsRUFBeUJDLE1BQXpCLEVBQWlDQyxNQUFqQyxFQUF5Q0MsU0FBekMsRUFBb0RDLFVBQXBELEVBQWdFO0FBQUE7O0FBRzVEO0FBSDRELDhIQUN0REosVUFEc0QsRUFDMUNDLE1BRDBDLEVBQ2xDQyxNQURrQyxFQUMxQkMsU0FEMEIsRUFDZkMsVUFEZTs7QUFJNUQsY0FBS0MsVUFBTCxHQUFrQixHQUFsQjtBQUNBLGNBQUtDLFlBQUwsQ0FBa0IsR0FBbEIsSUFBeUIsSUFBSVQsY0FBY1UsYUFBbEIsUUFBc0MsTUFBS0MsSUFBM0MsQ0FBekI7QUFMNEQ7QUFNL0Q7Ozs7OztBQUlEOzs7OztpQ0FLVTtBQUFBOztBQUNOLGdCQUFNQywrSEFBTjs7QUFFQSxnQkFBTUMsS0FBSyxJQUFJZCxRQUFRZSxPQUFaLENBQW9CLElBQXBCLEVBQTBCLEdBQTFCLEVBQStCLEtBQUtULE1BQXBDLENBQVg7QUFDQSxpQkFBS0ksWUFBTCxDQUFrQixHQUFsQixJQUF5QkksRUFBekI7O0FBRUFELHlCQUFhRyxJQUFiLENBQWtCRixHQUFHRyxhQUFILEVBQWxCOztBQUVBQyxvQkFBUUMsR0FBUixDQUFZTixZQUFaLEVBQTBCTyxJQUExQixDQUErQixZQUFNO0FBQ2pDLHVCQUFLQyxZQUFMLENBQWtCbkIsT0FBT29CLE1BQVAsQ0FBY0MsTUFBaEM7QUFDSCxhQUZEO0FBR0g7Ozs0QkFsQmdCO0FBQUUsbUJBQU9yQixPQUFPc0IsZUFBUCxDQUF1QkMsVUFBOUI7QUFBMkM7Ozs7RUF2QnhDM0IsWUFBWTRCLFc7O0FBNEN0Q0MsT0FBT0MsT0FBUCxHQUFpQjtBQUFBLFdBQU87QUFDcEJ6QjtBQURvQixLQUFQO0FBQUEsQ0FBakIiLCJmaWxlIjoiODUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG5jb25zdCBsYXllclJlY29yZCA9IHJlcXVpcmUoJy4vbGF5ZXJSZWNvcmQuanMnKSgpO1xyXG5jb25zdCBiYXNpY0ZDID0gcmVxdWlyZSgnLi9iYXNpY0ZDLmpzJykoKTtcclxuY29uc3QgcGxhY2Vob2xkZXJGQyA9IHJlcXVpcmUoJy4vcGxhY2Vob2xkZXJGQy5qcycpKCk7XHJcbmNvbnN0IHNoYXJlZCA9IHJlcXVpcmUoJy4vc2hhcmVkLmpzJykoKTtcclxuXHJcbi8qKlxyXG4gKiBAY2xhc3MgSW1hZ2VSZWNvcmRcclxuICovXHJcbmNsYXNzIEltYWdlUmVjb3JkIGV4dGVuZHMgbGF5ZXJSZWNvcmQuTGF5ZXJSZWNvcmQge1xyXG4gICAgLy8gTk9URTogaWYgd2UgZGVjaWRlIHRvIHN1cHBvcnQgYXR0cmlidXRlcyBmcm9tIEltYWdlU2VydmVycyxcclxuICAgIC8vICAgICAgIHdlIHdvdWxkIGV4dGVuZCBmcm9tIEF0dHJpYlJlY29yZCBpbnN0ZWFkIG9mIExheWVyUmVjb3JkXHJcbiAgICAvLyAgICAgICAoYW5kIGRvIGEgbG90IG9mIHRlc3RpbmchKVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgbGF5ZXIgcmVjb3JkIHdpdGggdGhlIGFwcHJvcHJpYXRlIGdlb0FwaSBsYXllciB0eXBlLiAgTGF5ZXIgY29uZmlnXHJcbiAgICAgKiBzaG91bGQgYmUgZnVsbHkgbWVyZ2VkIHdpdGggYWxsIGxheWVyIG9wdGlvbnMgZGVmaW5lZCAoaS5lLiB0aGlzIGNvbnN0cnVjdG9yXHJcbiAgICAgKiB3aWxsIG5vdCBhcHBseSBhbnkgZGVmYXVsdHMpLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGxheWVyQ2xhc3MgICAgdGhlIEVTUkkgYXBpIG9iamVjdCBmb3IgaW1hZ2Ugc2VydmVyIGxheWVyc1xyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFwaVJlZiAgICAgICAgb2JqZWN0IHBvaW50aW5nIHRvIHRoZSBnZW9BcGkuIGFsbG93cyB1cyB0byBjYWxsIG90aGVyIGdlb0FwaSBmdW5jdGlvbnMuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnICAgICAgICBsYXllciBjb25maWcgdmFsdWVzXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXNyaUxheWVyICAgICBhbiBvcHRpb25hbCBwcmUtY29uc3RydWN0ZWQgbGF5ZXJcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVwc2dMb29rdXAgIGFuIG9wdGlvbmFsIGxvb2t1cCBmdW5jdGlvbiBmb3IgRVBTRyBjb2RlcyAoc2VlIGdlb1NlcnZpY2UgZm9yIHNpZ25hdHVyZSlcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IgKGxheWVyQ2xhc3MsIGFwaVJlZiwgY29uZmlnLCBlc3JpTGF5ZXIsIGVwc2dMb29rdXApIHtcclxuICAgICAgICBzdXBlcihsYXllckNsYXNzLCBhcGlSZWYsIGNvbmZpZywgZXNyaUxheWVyLCBlcHNnTG9va3VwKTtcclxuXHJcbiAgICAgICAgLy8gaGFuZGxlcyBwbGFjZWhvbGRlciBzeW1ib2wsIHBvc3NpYmx5IG90aGVyIHRoaW5nc1xyXG4gICAgICAgIHRoaXMuX2RlZmF1bHRGQyA9ICcwJztcclxuICAgICAgICB0aGlzLl9mZWF0Q2xhc3Nlc1snMCddID0gbmV3IHBsYWNlaG9sZGVyRkMuUGxhY2Vob2xkZXJGQyh0aGlzLCB0aGlzLm5hbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldCBsYXllclR5cGUgKCkgeyByZXR1cm4gc2hhcmVkLmNsaWVudExheWVyVHlwZS5FU1JJX0lNQUdFOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFRyaWdnZXJzIHdoZW4gdGhlIGxheWVyIGxvYWRzLlxyXG4gICAgKlxyXG4gICAgKiBAZnVuY3Rpb24gb25Mb2FkXHJcbiAgICAqL1xyXG4gICAgb25Mb2FkICgpIHtcclxuICAgICAgICBjb25zdCBsb2FkUHJvbWlzZXMgPSBzdXBlci5vbkxvYWQoKTtcclxuXHJcbiAgICAgICAgY29uc3QgZmMgPSBuZXcgYmFzaWNGQy5CYXNpY0ZDKHRoaXMsICcwJywgdGhpcy5jb25maWcpO1xyXG4gICAgICAgIHRoaXMuX2ZlYXRDbGFzc2VzWycwJ10gPSBmYztcclxuXHJcbiAgICAgICAgbG9hZFByb21pc2VzLnB1c2goZmMubG9hZFN5bWJvbG9neSgpKTtcclxuXHJcbiAgICAgICAgUHJvbWlzZS5hbGwobG9hZFByb21pc2VzKS50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fc3RhdGVDaGFuZ2Uoc2hhcmVkLnN0YXRlcy5MT0FERUQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9ICgpID0+ICh7XHJcbiAgICBJbWFnZVJlY29yZFxyXG59KTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2xheWVyL2xheWVyUmVjL2ltYWdlUmVjb3JkLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){"use strict";eval("\n\n// TODO look at ripping out esriBundle, and passing specific classes as needed\n\n// Classes for handling different types of layers\n\nvar dynamicRecord = __webpack_require__(83)();\nvar featureRecord = __webpack_require__(84)();\nvar imageRecord = __webpack_require__(85)();\nvar tileRecord = __webpack_require__(87)();\nvar wmsRecord = __webpack_require__(89)();\n\n/*\r\nClass heirarchy overview:\r\n\r\nWe have FC, Record, and Interface classes\r\n\r\nFC represents a logical layer.  Think of a feature class (gis term, not programming term)\r\nor a raster source. It is one atomic layer.\r\n\r\nRecord represents a physical layer.  Think of a layer in the ESRI map stack. Think of\r\nsomething represented by an ESRI API layer object.\r\n\r\nInterface is a class that presents information to the UI and facilitates bindings.\r\nIt also exposes calls to perform actions on the layer (e.g. the action a UI button\r\nwould execute).\r\n\r\nFC classes are contained within Record classes.\r\nIf a property or function applies to a logical layer (e.g. min and max scale levels),\r\nit should reside in an FC class. If it applies to a physical layer (e.g. loading\r\nstate), it should reside in a Record.\r\n\r\nE.g.\r\nA feature layer is implemented with one Record and one FC, because by nature,\r\na feature layer can only contain data from one feature class.\r\nA dynamic layer is implemented with one Record, and a FC for every\r\nleaf child layer.\r\n\r\nAn interface object should exist for every layer-bound entry in the legend.\r\nMost Records will have one interface, as they just have one legend entry.\r\nDynamic Records will also have interfaces for children.\r\n*/\n\n// UPDATE: this idea was somewhat implemented. .layerInfo is still a promise, but we don't\n// set things to loaded until we've extracted upfront items from it.\n// IDEA: instead of having attribute .layerInfo as a promise,\n// we pair that promise with the layer's load event.  Essentially, don't\n// change our state to loaded until both the layer is loaded AND the .layerInfo\n// is loaded.  Then we store the result in a not-promise var, and everything else\n// can access it synchronously.\n// Risk: need to make sure we never need to use .layerInfo prior to the layer loading.\n// Risk: layer needs to wait until it has pulled additional info prior to being active (negligible?)\n\n// TODO full review of use of object id, specificly the type -- is it string or integer\n// TODO ditto for featureIdx.\n\n// The FC classes are meant to be internal to this module. They help manage differences between single-type layers\n// like feature layers, image layers, and composite layers like dynamic layers.\n// Can toy with alternate approaches. E.g. have a convertToPlaceholder function in the interface.\n\n// the Record classes are meant to be public facing and consumed by other modules and the client.\n\nmodule.exports = function () {\n    return {\n        DynamicRecord: dynamicRecord.DynamicRecord,\n        FeatureRecord: featureRecord.FeatureRecord,\n        ImageRecord: imageRecord.ImageRecord,\n        TileRecord: tileRecord.TileRecord,\n        WmsRecord: wmsRecord.WmsRecord\n    };\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXIvbGF5ZXJSZWMvbWFpbi5qcz80ODgwIl0sIm5hbWVzIjpbImR5bmFtaWNSZWNvcmQiLCJyZXF1aXJlIiwiZmVhdHVyZVJlY29yZCIsImltYWdlUmVjb3JkIiwidGlsZVJlY29yZCIsIndtc1JlY29yZCIsIm1vZHVsZSIsImV4cG9ydHMiLCJEeW5hbWljUmVjb3JkIiwiRmVhdHVyZVJlY29yZCIsIkltYWdlUmVjb3JkIiwiVGlsZVJlY29yZCIsIldtc1JlY29yZCJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7O0FBRUE7O0FBRUEsSUFBTUEsZ0JBQWdCLG1CQUFBQyxDQUFRLEVBQVIsR0FBdEI7QUFDQSxJQUFNQyxnQkFBZ0IsbUJBQUFELENBQVEsRUFBUixHQUF0QjtBQUNBLElBQU1FLGNBQWMsbUJBQUFGLENBQVEsRUFBUixHQUFwQjtBQUNBLElBQU1HLGFBQWEsbUJBQUFILENBQVEsRUFBUixHQUFuQjtBQUNBLElBQU1JLFlBQVksbUJBQUFKLENBQVEsRUFBUixHQUFsQjs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQStCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUFLLE9BQU9DLE9BQVAsR0FBaUI7QUFBQSxXQUFPO0FBQ3BCQyx1QkFBZVIsY0FBY1EsYUFEVDtBQUVwQkMsdUJBQWVQLGNBQWNPLGFBRlQ7QUFHcEJDLHFCQUFhUCxZQUFZTyxXQUhMO0FBSXBCQyxvQkFBWVAsV0FBV08sVUFKSDtBQUtwQkMsbUJBQVdQLFVBQVVPO0FBTEQsS0FBUDtBQUFBLENBQWpCIiwiZmlsZSI6Ijg2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxuLy8gVE9ETyBsb29rIGF0IHJpcHBpbmcgb3V0IGVzcmlCdW5kbGUsIGFuZCBwYXNzaW5nIHNwZWNpZmljIGNsYXNzZXMgYXMgbmVlZGVkXHJcblxyXG4vLyBDbGFzc2VzIGZvciBoYW5kbGluZyBkaWZmZXJlbnQgdHlwZXMgb2YgbGF5ZXJzXHJcblxyXG5jb25zdCBkeW5hbWljUmVjb3JkID0gcmVxdWlyZSgnLi9keW5hbWljUmVjb3JkLmpzJykoKTtcclxuY29uc3QgZmVhdHVyZVJlY29yZCA9IHJlcXVpcmUoJy4vZmVhdHVyZVJlY29yZC5qcycpKCk7XHJcbmNvbnN0IGltYWdlUmVjb3JkID0gcmVxdWlyZSgnLi9pbWFnZVJlY29yZC5qcycpKCk7XHJcbmNvbnN0IHRpbGVSZWNvcmQgPSByZXF1aXJlKCcuL3RpbGVSZWNvcmQuanMnKSgpO1xyXG5jb25zdCB3bXNSZWNvcmQgPSByZXF1aXJlKCcuL3dtc1JlY29yZC5qcycpKCk7XHJcblxyXG4vKlxyXG5DbGFzcyBoZWlyYXJjaHkgb3ZlcnZpZXc6XHJcblxyXG5XZSBoYXZlIEZDLCBSZWNvcmQsIGFuZCBJbnRlcmZhY2UgY2xhc3Nlc1xyXG5cclxuRkMgcmVwcmVzZW50cyBhIGxvZ2ljYWwgbGF5ZXIuICBUaGluayBvZiBhIGZlYXR1cmUgY2xhc3MgKGdpcyB0ZXJtLCBub3QgcHJvZ3JhbW1pbmcgdGVybSlcclxub3IgYSByYXN0ZXIgc291cmNlLiBJdCBpcyBvbmUgYXRvbWljIGxheWVyLlxyXG5cclxuUmVjb3JkIHJlcHJlc2VudHMgYSBwaHlzaWNhbCBsYXllci4gIFRoaW5rIG9mIGEgbGF5ZXIgaW4gdGhlIEVTUkkgbWFwIHN0YWNrLiBUaGluayBvZlxyXG5zb21ldGhpbmcgcmVwcmVzZW50ZWQgYnkgYW4gRVNSSSBBUEkgbGF5ZXIgb2JqZWN0LlxyXG5cclxuSW50ZXJmYWNlIGlzIGEgY2xhc3MgdGhhdCBwcmVzZW50cyBpbmZvcm1hdGlvbiB0byB0aGUgVUkgYW5kIGZhY2lsaXRhdGVzIGJpbmRpbmdzLlxyXG5JdCBhbHNvIGV4cG9zZXMgY2FsbHMgdG8gcGVyZm9ybSBhY3Rpb25zIG9uIHRoZSBsYXllciAoZS5nLiB0aGUgYWN0aW9uIGEgVUkgYnV0dG9uXHJcbndvdWxkIGV4ZWN1dGUpLlxyXG5cclxuRkMgY2xhc3NlcyBhcmUgY29udGFpbmVkIHdpdGhpbiBSZWNvcmQgY2xhc3Nlcy5cclxuSWYgYSBwcm9wZXJ0eSBvciBmdW5jdGlvbiBhcHBsaWVzIHRvIGEgbG9naWNhbCBsYXllciAoZS5nLiBtaW4gYW5kIG1heCBzY2FsZSBsZXZlbHMpLFxyXG5pdCBzaG91bGQgcmVzaWRlIGluIGFuIEZDIGNsYXNzLiBJZiBpdCBhcHBsaWVzIHRvIGEgcGh5c2ljYWwgbGF5ZXIgKGUuZy4gbG9hZGluZ1xyXG5zdGF0ZSksIGl0IHNob3VsZCByZXNpZGUgaW4gYSBSZWNvcmQuXHJcblxyXG5FLmcuXHJcbkEgZmVhdHVyZSBsYXllciBpcyBpbXBsZW1lbnRlZCB3aXRoIG9uZSBSZWNvcmQgYW5kIG9uZSBGQywgYmVjYXVzZSBieSBuYXR1cmUsXHJcbmEgZmVhdHVyZSBsYXllciBjYW4gb25seSBjb250YWluIGRhdGEgZnJvbSBvbmUgZmVhdHVyZSBjbGFzcy5cclxuQSBkeW5hbWljIGxheWVyIGlzIGltcGxlbWVudGVkIHdpdGggb25lIFJlY29yZCwgYW5kIGEgRkMgZm9yIGV2ZXJ5XHJcbmxlYWYgY2hpbGQgbGF5ZXIuXHJcblxyXG5BbiBpbnRlcmZhY2Ugb2JqZWN0IHNob3VsZCBleGlzdCBmb3IgZXZlcnkgbGF5ZXItYm91bmQgZW50cnkgaW4gdGhlIGxlZ2VuZC5cclxuTW9zdCBSZWNvcmRzIHdpbGwgaGF2ZSBvbmUgaW50ZXJmYWNlLCBhcyB0aGV5IGp1c3QgaGF2ZSBvbmUgbGVnZW5kIGVudHJ5LlxyXG5EeW5hbWljIFJlY29yZHMgd2lsbCBhbHNvIGhhdmUgaW50ZXJmYWNlcyBmb3IgY2hpbGRyZW4uXHJcbiovXHJcblxyXG4vLyBVUERBVEU6IHRoaXMgaWRlYSB3YXMgc29tZXdoYXQgaW1wbGVtZW50ZWQuIC5sYXllckluZm8gaXMgc3RpbGwgYSBwcm9taXNlLCBidXQgd2UgZG9uJ3RcclxuLy8gc2V0IHRoaW5ncyB0byBsb2FkZWQgdW50aWwgd2UndmUgZXh0cmFjdGVkIHVwZnJvbnQgaXRlbXMgZnJvbSBpdC5cclxuLy8gSURFQTogaW5zdGVhZCBvZiBoYXZpbmcgYXR0cmlidXRlIC5sYXllckluZm8gYXMgYSBwcm9taXNlLFxyXG4vLyB3ZSBwYWlyIHRoYXQgcHJvbWlzZSB3aXRoIHRoZSBsYXllcidzIGxvYWQgZXZlbnQuICBFc3NlbnRpYWxseSwgZG9uJ3RcclxuLy8gY2hhbmdlIG91ciBzdGF0ZSB0byBsb2FkZWQgdW50aWwgYm90aCB0aGUgbGF5ZXIgaXMgbG9hZGVkIEFORCB0aGUgLmxheWVySW5mb1xyXG4vLyBpcyBsb2FkZWQuICBUaGVuIHdlIHN0b3JlIHRoZSByZXN1bHQgaW4gYSBub3QtcHJvbWlzZSB2YXIsIGFuZCBldmVyeXRoaW5nIGVsc2VcclxuLy8gY2FuIGFjY2VzcyBpdCBzeW5jaHJvbm91c2x5LlxyXG4vLyBSaXNrOiBuZWVkIHRvIG1ha2Ugc3VyZSB3ZSBuZXZlciBuZWVkIHRvIHVzZSAubGF5ZXJJbmZvIHByaW9yIHRvIHRoZSBsYXllciBsb2FkaW5nLlxyXG4vLyBSaXNrOiBsYXllciBuZWVkcyB0byB3YWl0IHVudGlsIGl0IGhhcyBwdWxsZWQgYWRkaXRpb25hbCBpbmZvIHByaW9yIHRvIGJlaW5nIGFjdGl2ZSAobmVnbGlnaWJsZT8pXHJcblxyXG4vLyBUT0RPIGZ1bGwgcmV2aWV3IG9mIHVzZSBvZiBvYmplY3QgaWQsIHNwZWNpZmljbHkgdGhlIHR5cGUgLS0gaXMgaXQgc3RyaW5nIG9yIGludGVnZXJcclxuLy8gVE9ETyBkaXR0byBmb3IgZmVhdHVyZUlkeC5cclxuXHJcbi8vIFRoZSBGQyBjbGFzc2VzIGFyZSBtZWFudCB0byBiZSBpbnRlcm5hbCB0byB0aGlzIG1vZHVsZS4gVGhleSBoZWxwIG1hbmFnZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIHNpbmdsZS10eXBlIGxheWVyc1xyXG4vLyBsaWtlIGZlYXR1cmUgbGF5ZXJzLCBpbWFnZSBsYXllcnMsIGFuZCBjb21wb3NpdGUgbGF5ZXJzIGxpa2UgZHluYW1pYyBsYXllcnMuXHJcbi8vIENhbiB0b3kgd2l0aCBhbHRlcm5hdGUgYXBwcm9hY2hlcy4gRS5nLiBoYXZlIGEgY29udmVydFRvUGxhY2Vob2xkZXIgZnVuY3Rpb24gaW4gdGhlIGludGVyZmFjZS5cclxuXHJcbi8vIHRoZSBSZWNvcmQgY2xhc3NlcyBhcmUgbWVhbnQgdG8gYmUgcHVibGljIGZhY2luZyBhbmQgY29uc3VtZWQgYnkgb3RoZXIgbW9kdWxlcyBhbmQgdGhlIGNsaWVudC5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gKCkgPT4gKHtcclxuICAgIER5bmFtaWNSZWNvcmQ6IGR5bmFtaWNSZWNvcmQuRHluYW1pY1JlY29yZCxcclxuICAgIEZlYXR1cmVSZWNvcmQ6IGZlYXR1cmVSZWNvcmQuRmVhdHVyZVJlY29yZCxcclxuICAgIEltYWdlUmVjb3JkOiBpbWFnZVJlY29yZC5JbWFnZVJlY29yZCxcclxuICAgIFRpbGVSZWNvcmQ6IHRpbGVSZWNvcmQuVGlsZVJlY29yZCxcclxuICAgIFdtc1JlY29yZDogd21zUmVjb3JkLldtc1JlY29yZFxyXG59KTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2xheWVyL2xheWVyUmVjL21haW4uanMiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar basicFC = __webpack_require__(19)();\nvar placeholderFC = __webpack_require__(5)();\nvar layerRecord = __webpack_require__(20)();\nvar shared = __webpack_require__(2)();\n\n/**\r\n * @class TileRecord\r\n */\n\nvar TileRecord = function (_layerRecord$LayerRec) {\n    _inherits(TileRecord, _layerRecord$LayerRec);\n\n    /**\r\n     * Create a layer record with the appropriate geoApi layer type.  Layer config\r\n     * should be fully merged with all layer options defined (i.e. this constructor\r\n     * will not apply any defaults).\r\n     * @param {Object} layerClass    the ESRI api object for tile layers\r\n     * @param {Object} apiRef        object pointing to the geoApi. allows us to call other geoApi functions.\r\n     * @param {Object} config        layer config values\r\n     * @param {Object} esriLayer     an optional pre-constructed layer\r\n     * @param {Function} epsgLookup  an optional lookup function for EPSG codes (see geoService for signature)\r\n     */\n    function TileRecord(layerClass, apiRef, config, esriLayer, epsgLookup) {\n        _classCallCheck(this, TileRecord);\n\n        // handles placeholder symbol, possibly other things\n        var _this = _possibleConstructorReturn(this, (TileRecord.__proto__ || Object.getPrototypeOf(TileRecord)).call(this, layerClass, apiRef, config, esriLayer, epsgLookup));\n\n        _this._defaultFC = '0';\n        _this._featClasses['0'] = new placeholderFC.PlaceholderFC(_this, _this.name);\n        return _this;\n    }\n\n    /**\r\n    * Triggers when the layer loads.\r\n    *\r\n    * @function onLoad\r\n    */\n\n\n    _createClass(TileRecord, [{\n        key: 'onLoad',\n        value: function onLoad() {\n            var _this2 = this;\n\n            var loadPromises = _get(TileRecord.prototype.__proto__ || Object.getPrototypeOf(TileRecord.prototype), 'onLoad', this).call(this);\n\n            var fc = new basicFC.BasicFC(this, '0', this.config);\n            this._featClasses['0'] = fc;\n\n            loadPromises.push(fc.loadSymbology(true));\n\n            Promise.all(loadPromises).then(function () {\n                _this2._stateChange(shared.states.LOADED);\n            });\n        }\n    }, {\n        key: 'layerType',\n        get: function get() {\n            return shared.clientLayerType.ESRI_TILE;\n        }\n    }]);\n\n    return TileRecord;\n}(layerRecord.LayerRecord);\n\nmodule.exports = function () {\n    return {\n        TileRecord: TileRecord\n    };\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXIvbGF5ZXJSZWMvdGlsZVJlY29yZC5qcz85M2UzIl0sIm5hbWVzIjpbImJhc2ljRkMiLCJyZXF1aXJlIiwicGxhY2Vob2xkZXJGQyIsImxheWVyUmVjb3JkIiwic2hhcmVkIiwiVGlsZVJlY29yZCIsImxheWVyQ2xhc3MiLCJhcGlSZWYiLCJjb25maWciLCJlc3JpTGF5ZXIiLCJlcHNnTG9va3VwIiwiX2RlZmF1bHRGQyIsIl9mZWF0Q2xhc3NlcyIsIlBsYWNlaG9sZGVyRkMiLCJuYW1lIiwibG9hZFByb21pc2VzIiwiZmMiLCJCYXNpY0ZDIiwicHVzaCIsImxvYWRTeW1ib2xvZ3kiLCJQcm9taXNlIiwiYWxsIiwidGhlbiIsIl9zdGF0ZUNoYW5nZSIsInN0YXRlcyIsIkxPQURFRCIsImNsaWVudExheWVyVHlwZSIsIkVTUklfVElMRSIsIkxheWVyUmVjb3JkIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7OztBQUVBLElBQU1BLFVBQVUsbUJBQUFDLENBQVEsRUFBUixHQUFoQjtBQUNBLElBQU1DLGdCQUFnQixtQkFBQUQsQ0FBUSxDQUFSLEdBQXRCO0FBQ0EsSUFBTUUsY0FBYyxtQkFBQUYsQ0FBUSxFQUFSLEdBQXBCO0FBQ0EsSUFBTUcsU0FBUyxtQkFBQUgsQ0FBUSxDQUFSLEdBQWY7O0FBRUE7Ozs7SUFHTUksVTs7O0FBRUY7Ozs7Ozs7Ozs7QUFVQSx3QkFBYUMsVUFBYixFQUF5QkMsTUFBekIsRUFBaUNDLE1BQWpDLEVBQXlDQyxTQUF6QyxFQUFvREMsVUFBcEQsRUFBZ0U7QUFBQTs7QUFHNUQ7QUFINEQsNEhBQ3RESixVQURzRCxFQUMxQ0MsTUFEMEMsRUFDbENDLE1BRGtDLEVBQzFCQyxTQUQwQixFQUNmQyxVQURlOztBQUk1RCxjQUFLQyxVQUFMLEdBQWtCLEdBQWxCO0FBQ0EsY0FBS0MsWUFBTCxDQUFrQixHQUFsQixJQUF5QixJQUFJVixjQUFjVyxhQUFsQixRQUFzQyxNQUFLQyxJQUEzQyxDQUF6QjtBQUw0RDtBQU0vRDs7QUFFRDs7Ozs7Ozs7O2lDQUtVO0FBQUE7O0FBQ04sZ0JBQU1DLDZIQUFOOztBQUVBLGdCQUFNQyxLQUFLLElBQUloQixRQUFRaUIsT0FBWixDQUFvQixJQUFwQixFQUEwQixHQUExQixFQUErQixLQUFLVCxNQUFwQyxDQUFYO0FBQ0EsaUJBQUtJLFlBQUwsQ0FBa0IsR0FBbEIsSUFBeUJJLEVBQXpCOztBQUVBRCx5QkFBYUcsSUFBYixDQUFrQkYsR0FBR0csYUFBSCxDQUFpQixJQUFqQixDQUFsQjs7QUFFQUMsb0JBQVFDLEdBQVIsQ0FBWU4sWUFBWixFQUEwQk8sSUFBMUIsQ0FBK0IsWUFBTTtBQUNqQyx1QkFBS0MsWUFBTCxDQUFrQm5CLE9BQU9vQixNQUFQLENBQWNDLE1BQWhDO0FBQ0gsYUFGRDtBQUdIOzs7NEJBRWdCO0FBQUUsbUJBQU9yQixPQUFPc0IsZUFBUCxDQUF1QkMsU0FBOUI7QUFBMEM7Ozs7RUF0Q3hDeEIsWUFBWXlCLFc7O0FBMENyQ0MsT0FBT0MsT0FBUCxHQUFpQjtBQUFBLFdBQU87QUFDcEJ6QjtBQURvQixLQUFQO0FBQUEsQ0FBakIiLCJmaWxlIjoiODcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG5jb25zdCBiYXNpY0ZDID0gcmVxdWlyZSgnLi9iYXNpY0ZDLmpzJykoKTtcclxuY29uc3QgcGxhY2Vob2xkZXJGQyA9IHJlcXVpcmUoJy4vcGxhY2Vob2xkZXJGQy5qcycpKCk7XHJcbmNvbnN0IGxheWVyUmVjb3JkID0gcmVxdWlyZSgnLi9sYXllclJlY29yZC5qcycpKCk7XHJcbmNvbnN0IHNoYXJlZCA9IHJlcXVpcmUoJy4vc2hhcmVkLmpzJykoKTtcclxuXHJcbi8qKlxyXG4gKiBAY2xhc3MgVGlsZVJlY29yZFxyXG4gKi9cclxuY2xhc3MgVGlsZVJlY29yZCBleHRlbmRzIGxheWVyUmVjb3JkLkxheWVyUmVjb3JkIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIGxheWVyIHJlY29yZCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBnZW9BcGkgbGF5ZXIgdHlwZS4gIExheWVyIGNvbmZpZ1xyXG4gICAgICogc2hvdWxkIGJlIGZ1bGx5IG1lcmdlZCB3aXRoIGFsbCBsYXllciBvcHRpb25zIGRlZmluZWQgKGkuZS4gdGhpcyBjb25zdHJ1Y3RvclxyXG4gICAgICogd2lsbCBub3QgYXBwbHkgYW55IGRlZmF1bHRzKS5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBsYXllckNsYXNzICAgIHRoZSBFU1JJIGFwaSBvYmplY3QgZm9yIHRpbGUgbGF5ZXJzXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXBpUmVmICAgICAgICBvYmplY3QgcG9pbnRpbmcgdG8gdGhlIGdlb0FwaS4gYWxsb3dzIHVzIHRvIGNhbGwgb3RoZXIgZ2VvQXBpIGZ1bmN0aW9ucy5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgICAgICAgIGxheWVyIGNvbmZpZyB2YWx1ZXNcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlc3JpTGF5ZXIgICAgIGFuIG9wdGlvbmFsIHByZS1jb25zdHJ1Y3RlZCBsYXllclxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXBzZ0xvb2t1cCAgYW4gb3B0aW9uYWwgbG9va3VwIGZ1bmN0aW9uIGZvciBFUFNHIGNvZGVzIChzZWUgZ2VvU2VydmljZSBmb3Igc2lnbmF0dXJlKVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvciAobGF5ZXJDbGFzcywgYXBpUmVmLCBjb25maWcsIGVzcmlMYXllciwgZXBzZ0xvb2t1cCkge1xyXG4gICAgICAgIHN1cGVyKGxheWVyQ2xhc3MsIGFwaVJlZiwgY29uZmlnLCBlc3JpTGF5ZXIsIGVwc2dMb29rdXApO1xyXG5cclxuICAgICAgICAvLyBoYW5kbGVzIHBsYWNlaG9sZGVyIHN5bWJvbCwgcG9zc2libHkgb3RoZXIgdGhpbmdzXHJcbiAgICAgICAgdGhpcy5fZGVmYXVsdEZDID0gJzAnO1xyXG4gICAgICAgIHRoaXMuX2ZlYXRDbGFzc2VzWycwJ10gPSBuZXcgcGxhY2Vob2xkZXJGQy5QbGFjZWhvbGRlckZDKHRoaXMsIHRoaXMubmFtZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFRyaWdnZXJzIHdoZW4gdGhlIGxheWVyIGxvYWRzLlxyXG4gICAgKlxyXG4gICAgKiBAZnVuY3Rpb24gb25Mb2FkXHJcbiAgICAqL1xyXG4gICAgb25Mb2FkICgpIHtcclxuICAgICAgICBjb25zdCBsb2FkUHJvbWlzZXMgPSBzdXBlci5vbkxvYWQoKTtcclxuXHJcbiAgICAgICAgY29uc3QgZmMgPSBuZXcgYmFzaWNGQy5CYXNpY0ZDKHRoaXMsICcwJywgdGhpcy5jb25maWcpO1xyXG4gICAgICAgIHRoaXMuX2ZlYXRDbGFzc2VzWycwJ10gPSBmYztcclxuXHJcbiAgICAgICAgbG9hZFByb21pc2VzLnB1c2goZmMubG9hZFN5bWJvbG9neSh0cnVlKSk7XHJcblxyXG4gICAgICAgIFByb21pc2UuYWxsKGxvYWRQcm9taXNlcykudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlQ2hhbmdlKHNoYXJlZC5zdGF0ZXMuTE9BREVEKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgbGF5ZXJUeXBlICgpIHsgcmV0dXJuIHNoYXJlZC5jbGllbnRMYXllclR5cGUuRVNSSV9USUxFOyB9XHJcblxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9ICgpID0+ICh7XHJcbiAgICBUaWxlUmVjb3JkXHJcbn0pO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvbGF5ZXIvbGF5ZXJSZWMvdGlsZVJlY29yZC5qcyJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){"use strict";eval('\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar basicFC = __webpack_require__(19)();\n\n/**\r\n * Searches for a layer title defined by a wms.\r\n * @function getWMSLayerTitle\r\n * @private\r\n * @param  {Object} wmsLayer     esri layer object for the wms\r\n * @param  {String} wmsLayerId   layers id as defined in the wms (i.e. not wmsLayer.id)\r\n * @return {String}              layer title as defined on the service, \'\' if no title defined\r\n */\nfunction getWMSLayerTitle(wmsLayer, wmsLayerId) {\n    // TODO move this to ogc.js module?\n\n    var targetEntry = null;\n\n    // crawl esri layerInfos (which is a nested structure),\n    // returns sublayer that has matching id or null if not found.\n    // written as function to allow recursion\n    var crawlSubLayers = function crawlSubLayers(subLayerInfos, wmsLayerId) {\n\n        // we use .some to allow the search to stop when we find something\n        subLayerInfos.some(function (layerInfo) {\n            // wms ids are stored in .name\n            if (layerInfo.name === wmsLayerId) {\n                // found it. save it and exit the search\n                targetEntry = layerInfo;\n                return true;\n            } else if (layerInfo.subLayers) {\n                // search children. if in children, will exit search, else will continue\n                return crawlSubLayers(layerInfo.subLayers, wmsLayerId);\n            } else {\n                // continue search\n                return false;\n            }\n        });\n\n        return targetEntry;\n    };\n\n    // init search on root layerInfos, then process result\n    var match = crawlSubLayers(wmsLayer.layerInfos, wmsLayerId);\n    if (match && match.title) {\n        return match.title;\n    } else {\n        return \'\'; // falsy!\n    }\n}\n\n/**\r\n * @class WmsFC\r\n */\n\nvar WmsFC = function (_basicFC$BasicFC) {\n    _inherits(WmsFC, _basicFC$BasicFC);\n\n    function WmsFC() {\n        _classCallCheck(this, WmsFC);\n\n        return _possibleConstructorReturn(this, (WmsFC.__proto__ || Object.getPrototypeOf(WmsFC)).apply(this, arguments));\n    }\n\n    _createClass(WmsFC, [{\n        key: \'loadSymbology\',\n\n\n        // this will actively download / refresh the internal symbology\n        value: function loadSymbology() {\n            var _this2 = this;\n\n            var configLayerEntries = this._parent.config.layerEntries;\n            var gApi = this._parent._apiRef;\n            var legendArray = gApi.layer.ogc.getLegendUrls(this._parent._layer, configLayerEntries.map(function (le) {\n                return le.id;\n            })).map(function (imageUri, idx) {\n\n                var symbologyItem = {\n                    name: null,\n                    svgcode: null\n                };\n\n                // config specified name || server specified name || config id\n                var name = configLayerEntries[idx].name || getWMSLayerTitle(_this2._parent._layer, configLayerEntries[idx].id) || configLayerEntries[idx].id;\n\n                gApi.symbology.generateWMSSymbology(name, imageUri).then(function (data) {\n                    symbologyItem.name = data.name;\n                    symbologyItem.svgcode = data.svgcode;\n                });\n\n                return symbologyItem;\n            });\n            this.symbology = legendArray;\n            return Promise.resolve();\n        }\n    }]);\n\n    return WmsFC;\n}(basicFC.BasicFC);\n\nmodule.exports = function () {\n    return {\n        WmsFC: WmsFC\n    };\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXIvbGF5ZXJSZWMvd21zRkMuanM/MDYyZSJdLCJuYW1lcyI6WyJiYXNpY0ZDIiwicmVxdWlyZSIsImdldFdNU0xheWVyVGl0bGUiLCJ3bXNMYXllciIsIndtc0xheWVySWQiLCJ0YXJnZXRFbnRyeSIsImNyYXdsU3ViTGF5ZXJzIiwic3ViTGF5ZXJJbmZvcyIsInNvbWUiLCJsYXllckluZm8iLCJuYW1lIiwic3ViTGF5ZXJzIiwibWF0Y2giLCJsYXllckluZm9zIiwidGl0bGUiLCJXbXNGQyIsImNvbmZpZ0xheWVyRW50cmllcyIsIl9wYXJlbnQiLCJjb25maWciLCJsYXllckVudHJpZXMiLCJnQXBpIiwiX2FwaVJlZiIsImxlZ2VuZEFycmF5IiwibGF5ZXIiLCJvZ2MiLCJnZXRMZWdlbmRVcmxzIiwiX2xheWVyIiwibWFwIiwibGUiLCJpZCIsImltYWdlVXJpIiwiaWR4Iiwic3ltYm9sb2d5SXRlbSIsInN2Z2NvZGUiLCJzeW1ib2xvZ3kiLCJnZW5lcmF0ZVdNU1N5bWJvbG9neSIsInRoZW4iLCJkYXRhIiwiUHJvbWlzZSIsInJlc29sdmUiLCJCYXNpY0ZDIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7QUFFQSxJQUFNQSxVQUFVLG1CQUFBQyxDQUFRLEVBQVIsR0FBaEI7O0FBRUE7Ozs7Ozs7O0FBUUEsU0FBU0MsZ0JBQVQsQ0FBMEJDLFFBQTFCLEVBQW9DQyxVQUFwQyxFQUFnRDtBQUM1Qzs7QUFFQSxRQUFJQyxjQUFjLElBQWxCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU1DLGlCQUFpQixTQUFqQkEsY0FBaUIsQ0FBQ0MsYUFBRCxFQUFnQkgsVUFBaEIsRUFBK0I7O0FBRWxEO0FBQ0FHLHNCQUFjQyxJQUFkLENBQW1CLHFCQUFhO0FBQzVCO0FBQ0EsZ0JBQUlDLFVBQVVDLElBQVYsS0FBbUJOLFVBQXZCLEVBQW1DO0FBQy9CO0FBQ0FDLDhCQUFjSSxTQUFkO0FBQ0EsdUJBQU8sSUFBUDtBQUNILGFBSkQsTUFJTyxJQUFJQSxVQUFVRSxTQUFkLEVBQXlCO0FBQzVCO0FBQ0EsdUJBQU9MLGVBQWVHLFVBQVVFLFNBQXpCLEVBQW9DUCxVQUFwQyxDQUFQO0FBQ0gsYUFITSxNQUdBO0FBQ0g7QUFDQSx1QkFBTyxLQUFQO0FBQ0g7QUFDSixTQWJEOztBQWVBLGVBQU9DLFdBQVA7QUFDSCxLQW5CRDs7QUFxQkE7QUFDQSxRQUFNTyxRQUFRTixlQUFlSCxTQUFTVSxVQUF4QixFQUFvQ1QsVUFBcEMsQ0FBZDtBQUNBLFFBQUlRLFNBQVNBLE1BQU1FLEtBQW5CLEVBQTBCO0FBQ3RCLGVBQU9GLE1BQU1FLEtBQWI7QUFDSCxLQUZELE1BRU87QUFDSCxlQUFPLEVBQVAsQ0FERyxDQUNRO0FBQ2Q7QUFDSjs7QUFFRDs7OztJQUdNQyxLOzs7Ozs7Ozs7Ozs7O0FBRUY7d0NBQ2lCO0FBQUE7O0FBQ2IsZ0JBQU1DLHFCQUFzQixLQUFLQyxPQUFMLENBQWFDLE1BQWIsQ0FBb0JDLFlBQWhEO0FBQ0EsZ0JBQU1DLE9BQU8sS0FBS0gsT0FBTCxDQUFhSSxPQUExQjtBQUNBLGdCQUFNQyxjQUFjRixLQUFLRyxLQUFMLENBQVdDLEdBQVgsQ0FDZkMsYUFEZSxDQUNELEtBQUtSLE9BQUwsQ0FBYVMsTUFEWixFQUNvQlYsbUJBQW1CVyxHQUFuQixDQUF1QjtBQUFBLHVCQUFNQyxHQUFHQyxFQUFUO0FBQUEsYUFBdkIsQ0FEcEIsRUFFZkYsR0FGZSxDQUVYLFVBQUNHLFFBQUQsRUFBV0MsR0FBWCxFQUFtQjs7QUFFcEIsb0JBQU1DLGdCQUFnQjtBQUNsQnRCLDBCQUFNLElBRFk7QUFFbEJ1Qiw2QkFBUztBQUZTLGlCQUF0Qjs7QUFLQTtBQUNBLG9CQUFNdkIsT0FBT00sbUJBQW1CZSxHQUFuQixFQUF3QnJCLElBQXhCLElBQ1RSLGlCQUFpQixPQUFLZSxPQUFMLENBQWFTLE1BQTlCLEVBQXNDVixtQkFBbUJlLEdBQW5CLEVBQXdCRixFQUE5RCxDQURTLElBRVRiLG1CQUFtQmUsR0FBbkIsRUFBd0JGLEVBRjVCOztBQUlBVCxxQkFBS2MsU0FBTCxDQUFlQyxvQkFBZixDQUFvQ3pCLElBQXBDLEVBQTBDb0IsUUFBMUMsRUFBb0RNLElBQXBELENBQXlELGdCQUFRO0FBQzdESixrQ0FBY3RCLElBQWQsR0FBcUIyQixLQUFLM0IsSUFBMUI7QUFDQXNCLGtDQUFjQyxPQUFkLEdBQXdCSSxLQUFLSixPQUE3QjtBQUNILGlCQUhEOztBQUtBLHVCQUFPRCxhQUFQO0FBQ0gsYUFwQmUsQ0FBcEI7QUFxQkEsaUJBQUtFLFNBQUwsR0FBaUJaLFdBQWpCO0FBQ0EsbUJBQU9nQixRQUFRQyxPQUFSLEVBQVA7QUFDSDs7OztFQTdCZXZDLFFBQVF3QyxPOztBQWdDNUJDLE9BQU9DLE9BQVAsR0FBaUI7QUFBQSxXQUFPO0FBQ3BCM0I7QUFEb0IsS0FBUDtBQUFBLENBQWpCIiwiZmlsZSI6Ijg4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxuY29uc3QgYmFzaWNGQyA9IHJlcXVpcmUoJy4vYmFzaWNGQy5qcycpKCk7XHJcblxyXG4vKipcclxuICogU2VhcmNoZXMgZm9yIGEgbGF5ZXIgdGl0bGUgZGVmaW5lZCBieSBhIHdtcy5cclxuICogQGZ1bmN0aW9uIGdldFdNU0xheWVyVGl0bGVcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtICB7T2JqZWN0fSB3bXNMYXllciAgICAgZXNyaSBsYXllciBvYmplY3QgZm9yIHRoZSB3bXNcclxuICogQHBhcmFtICB7U3RyaW5nfSB3bXNMYXllcklkICAgbGF5ZXJzIGlkIGFzIGRlZmluZWQgaW4gdGhlIHdtcyAoaS5lLiBub3Qgd21zTGF5ZXIuaWQpXHJcbiAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAgICAgIGxheWVyIHRpdGxlIGFzIGRlZmluZWQgb24gdGhlIHNlcnZpY2UsICcnIGlmIG5vIHRpdGxlIGRlZmluZWRcclxuICovXHJcbmZ1bmN0aW9uIGdldFdNU0xheWVyVGl0bGUod21zTGF5ZXIsIHdtc0xheWVySWQpIHtcclxuICAgIC8vIFRPRE8gbW92ZSB0aGlzIHRvIG9nYy5qcyBtb2R1bGU/XHJcblxyXG4gICAgbGV0IHRhcmdldEVudHJ5ID0gbnVsbDtcclxuXHJcbiAgICAvLyBjcmF3bCBlc3JpIGxheWVySW5mb3MgKHdoaWNoIGlzIGEgbmVzdGVkIHN0cnVjdHVyZSksXHJcbiAgICAvLyByZXR1cm5zIHN1YmxheWVyIHRoYXQgaGFzIG1hdGNoaW5nIGlkIG9yIG51bGwgaWYgbm90IGZvdW5kLlxyXG4gICAgLy8gd3JpdHRlbiBhcyBmdW5jdGlvbiB0byBhbGxvdyByZWN1cnNpb25cclxuICAgIGNvbnN0IGNyYXdsU3ViTGF5ZXJzID0gKHN1YkxheWVySW5mb3MsIHdtc0xheWVySWQpID0+IHtcclxuXHJcbiAgICAgICAgLy8gd2UgdXNlIC5zb21lIHRvIGFsbG93IHRoZSBzZWFyY2ggdG8gc3RvcCB3aGVuIHdlIGZpbmQgc29tZXRoaW5nXHJcbiAgICAgICAgc3ViTGF5ZXJJbmZvcy5zb21lKGxheWVySW5mbyA9PiB7XHJcbiAgICAgICAgICAgIC8vIHdtcyBpZHMgYXJlIHN0b3JlZCBpbiAubmFtZVxyXG4gICAgICAgICAgICBpZiAobGF5ZXJJbmZvLm5hbWUgPT09IHdtc0xheWVySWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIGZvdW5kIGl0LiBzYXZlIGl0IGFuZCBleGl0IHRoZSBzZWFyY2hcclxuICAgICAgICAgICAgICAgIHRhcmdldEVudHJ5ID0gbGF5ZXJJbmZvO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGF5ZXJJbmZvLnN1YkxheWVycykge1xyXG4gICAgICAgICAgICAgICAgLy8gc2VhcmNoIGNoaWxkcmVuLiBpZiBpbiBjaGlsZHJlbiwgd2lsbCBleGl0IHNlYXJjaCwgZWxzZSB3aWxsIGNvbnRpbnVlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3Jhd2xTdWJMYXllcnMobGF5ZXJJbmZvLnN1YkxheWVycywgd21zTGF5ZXJJZCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjb250aW51ZSBzZWFyY2hcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gdGFyZ2V0RW50cnk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIGluaXQgc2VhcmNoIG9uIHJvb3QgbGF5ZXJJbmZvcywgdGhlbiBwcm9jZXNzIHJlc3VsdFxyXG4gICAgY29uc3QgbWF0Y2ggPSBjcmF3bFN1YkxheWVycyh3bXNMYXllci5sYXllckluZm9zLCB3bXNMYXllcklkKTtcclxuICAgIGlmIChtYXRjaCAmJiBtYXRjaC50aXRsZSkge1xyXG4gICAgICAgIHJldHVybiBtYXRjaC50aXRsZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuICcnOyAvLyBmYWxzeSFcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEBjbGFzcyBXbXNGQ1xyXG4gKi9cclxuY2xhc3MgV21zRkMgZXh0ZW5kcyBiYXNpY0ZDLkJhc2ljRkMge1xyXG5cclxuICAgIC8vIHRoaXMgd2lsbCBhY3RpdmVseSBkb3dubG9hZCAvIHJlZnJlc2ggdGhlIGludGVybmFsIHN5bWJvbG9neVxyXG4gICAgbG9hZFN5bWJvbG9neSAoKSB7XHJcbiAgICAgICAgY29uc3QgY29uZmlnTGF5ZXJFbnRyaWVzID0gIHRoaXMuX3BhcmVudC5jb25maWcubGF5ZXJFbnRyaWVzO1xyXG4gICAgICAgIGNvbnN0IGdBcGkgPSB0aGlzLl9wYXJlbnQuX2FwaVJlZjtcclxuICAgICAgICBjb25zdCBsZWdlbmRBcnJheSA9IGdBcGkubGF5ZXIub2djXHJcbiAgICAgICAgICAgIC5nZXRMZWdlbmRVcmxzKHRoaXMuX3BhcmVudC5fbGF5ZXIsIGNvbmZpZ0xheWVyRW50cmllcy5tYXAobGUgPT4gbGUuaWQpKVxyXG4gICAgICAgICAgICAubWFwKChpbWFnZVVyaSwgaWR4KSA9PiB7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3ltYm9sb2d5SXRlbSA9IHtcclxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIHN2Z2NvZGU6IG51bGxcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gY29uZmlnIHNwZWNpZmllZCBuYW1lIHx8IHNlcnZlciBzcGVjaWZpZWQgbmFtZSB8fCBjb25maWcgaWRcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBjb25maWdMYXllckVudHJpZXNbaWR4XS5uYW1lIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgZ2V0V01TTGF5ZXJUaXRsZSh0aGlzLl9wYXJlbnQuX2xheWVyLCBjb25maWdMYXllckVudHJpZXNbaWR4XS5pZCkgfHxcclxuICAgICAgICAgICAgICAgICAgICBjb25maWdMYXllckVudHJpZXNbaWR4XS5pZDtcclxuXHJcbiAgICAgICAgICAgICAgICBnQXBpLnN5bWJvbG9neS5nZW5lcmF0ZVdNU1N5bWJvbG9neShuYW1lLCBpbWFnZVVyaSkudGhlbihkYXRhID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBzeW1ib2xvZ3lJdGVtLm5hbWUgPSBkYXRhLm5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sb2d5SXRlbS5zdmdjb2RlID0gZGF0YS5zdmdjb2RlO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN5bWJvbG9neUl0ZW07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuc3ltYm9sb2d5ID0gbGVnZW5kQXJyYXk7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9ICgpID0+ICh7XHJcbiAgICBXbXNGQ1xyXG59KTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2xheWVyL2xheWVyUmVjL3dtc0ZDLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar wmsFC = __webpack_require__(88)();\nvar placeholderFC = __webpack_require__(5)();\nvar layerRecord = __webpack_require__(20)();\nvar shared = __webpack_require__(2)();\n\n/**\r\n * @class WmsRecord\r\n */\n\nvar WmsRecord = function (_layerRecord$LayerRec) {\n    _inherits(WmsRecord, _layerRecord$LayerRec);\n\n    /**\r\n     * Create a layer record with the appropriate geoApi layer type.  Layer config\r\n     * should be fully merged with all layer options defined (i.e. this constructor\r\n     * will not apply any defaults).\r\n     * @param {Object} layerClass    the ESRI api object for wms layers\r\n     * @param {Object} apiRef        object pointing to the geoApi. allows us to call other geoApi functions.\r\n     * @param {Object} config        layer config values\r\n     * @param {Object} esriLayer     an optional pre-constructed layer\r\n     * @param {Function} epsgLookup  an optional lookup function for EPSG codes (see geoService for signature)\r\n     */\n    function WmsRecord(layerClass, apiRef, config, esriLayer, epsgLookup) {\n        _classCallCheck(this, WmsRecord);\n\n        // handles placeholder symbol, possibly other things\n        var _this = _possibleConstructorReturn(this, (WmsRecord.__proto__ || Object.getPrototypeOf(WmsRecord)).call(this, layerClass, apiRef, config, esriLayer, epsgLookup));\n\n        _this._defaultFC = '0';\n        _this._featClasses['0'] = new placeholderFC.PlaceholderFC(_this, _this.name);\n\n        return _this;\n    }\n\n    _createClass(WmsRecord, [{\n        key: 'makeLayerConfig',\n        value: function makeLayerConfig() {\n            var cfg = _get(WmsRecord.prototype.__proto__ || Object.getPrototypeOf(WmsRecord.prototype), 'makeLayerConfig', this).call(this);\n            cfg.visibleLayers = this.config.layerEntries.map(function (le) {\n                return le.id;\n            });\n            return cfg;\n        }\n\n        /**\r\n        * Triggers when the layer loads.\r\n        *\r\n        * @function onLoad\r\n        */\n\n    }, {\n        key: 'onLoad',\n        value: function onLoad() {\n            var _this2 = this;\n\n            var loadPromises = _get(WmsRecord.prototype.__proto__ || Object.getPrototypeOf(WmsRecord.prototype), 'onLoad', this).call(this);\n\n            var fc = new wmsFC.WmsFC(this, '0', this.config);\n            this._featClasses['0'] = fc;\n\n            loadPromises.push(fc.loadSymbology());\n\n            Promise.all(loadPromises).then(function () {\n                _this2._stateChange(shared.states.LOADED);\n            });\n        }\n\n        /**\r\n         * Run a getFeatureInfo on a WMS layer, return the result as a promise.  Fills the panelData array on resolution.\r\n         *\r\n         * @param {Object} opts additional argumets like map object, clickEvent, etc.\r\n         * @returns {Object} an object with identify results array and identify promise resolving when identify is complete; if an empty object is returned, it will be skipped\r\n         */\n\n    }, {\n        key: 'identify',\n        value: function identify(opts) {\n            // TODO add full documentation for options parameter\n\n            // TODO consider having a constants area in geoApi / better place for this definition\n            var infoMap = {\n                'text/html;fgpv=summary': 'HTML',\n                'text/html': 'HTML',\n                'text/plain': 'Text',\n                'application/json': 'EsriFeature'\n            };\n\n            // ignore layers with no mime type, not loaded, not visible, not queryable\n            if (this.state === shared.states.ERROR || this.state === shared.states.LOADING || this.state === shared.states.NEW || !this.visibility || !this.isQueryable() || !infoMap.hasOwnProperty(this.config.featureInfoMimeType)) {\n                // TODO verifiy this is correct result format if layer should be excluded from the identify process\n                return { identifyResults: [], identifyPromise: Promise.resolve() };\n            }\n\n            var identifyResult = new shared.IdentifyResult(this.getProxy());\n\n            var identifyPromise = this._apiRef.layer.ogc.getFeatureInfo(this._layer, opts.clickEvent, this.config.layerEntries.map(function (le) {\n                return le.id;\n            }), this.config.featureInfoMimeType).then(function (data) {\n                identifyResult.isLoading = false;\n\n                // TODO: check for French service\n                // check if a result is returned by the service. If not, do not add to the array of data\n                if (data.indexOf('Search returned no results') === -1 && data !== '') {\n                    identifyResult.data.push(data);\n                }\n\n                // console.info(data);\n            });\n\n            return { identifyResults: [identifyResult], identifyPromise: identifyPromise };\n        }\n    }, {\n        key: 'layerType',\n        get: function get() {\n            return shared.clientLayerType.OGC_WMS;\n        }\n    }]);\n\n    return WmsRecord;\n}(layerRecord.LayerRecord);\n\nmodule.exports = function () {\n    return {\n        WmsRecord: WmsRecord\n    };\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXIvbGF5ZXJSZWMvd21zUmVjb3JkLmpzPzYwZTQiXSwibmFtZXMiOlsid21zRkMiLCJyZXF1aXJlIiwicGxhY2Vob2xkZXJGQyIsImxheWVyUmVjb3JkIiwic2hhcmVkIiwiV21zUmVjb3JkIiwibGF5ZXJDbGFzcyIsImFwaVJlZiIsImNvbmZpZyIsImVzcmlMYXllciIsImVwc2dMb29rdXAiLCJfZGVmYXVsdEZDIiwiX2ZlYXRDbGFzc2VzIiwiUGxhY2Vob2xkZXJGQyIsIm5hbWUiLCJjZmciLCJ2aXNpYmxlTGF5ZXJzIiwibGF5ZXJFbnRyaWVzIiwibWFwIiwibGUiLCJpZCIsImxvYWRQcm9taXNlcyIsImZjIiwiV21zRkMiLCJwdXNoIiwibG9hZFN5bWJvbG9neSIsIlByb21pc2UiLCJhbGwiLCJ0aGVuIiwiX3N0YXRlQ2hhbmdlIiwic3RhdGVzIiwiTE9BREVEIiwib3B0cyIsImluZm9NYXAiLCJzdGF0ZSIsIkVSUk9SIiwiTE9BRElORyIsIk5FVyIsInZpc2liaWxpdHkiLCJpc1F1ZXJ5YWJsZSIsImhhc093blByb3BlcnR5IiwiZmVhdHVyZUluZm9NaW1lVHlwZSIsImlkZW50aWZ5UmVzdWx0cyIsImlkZW50aWZ5UHJvbWlzZSIsInJlc29sdmUiLCJpZGVudGlmeVJlc3VsdCIsIklkZW50aWZ5UmVzdWx0IiwiZ2V0UHJveHkiLCJfYXBpUmVmIiwibGF5ZXIiLCJvZ2MiLCJnZXRGZWF0dXJlSW5mbyIsIl9sYXllciIsImNsaWNrRXZlbnQiLCJpc0xvYWRpbmciLCJkYXRhIiwiaW5kZXhPZiIsImNsaWVudExheWVyVHlwZSIsIk9HQ19XTVMiLCJMYXllclJlY29yZCIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7QUFFQSxJQUFNQSxRQUFRLG1CQUFBQyxDQUFRLEVBQVIsR0FBZDtBQUNBLElBQU1DLGdCQUFnQixtQkFBQUQsQ0FBUSxDQUFSLEdBQXRCO0FBQ0EsSUFBTUUs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QUF5QitCLElBQXpCO0FBQ0g7O0FBRUQ7QUFDSCxhQWhCbUIsQ0FBeEI7O0FBa0JBLG1CQUFPLEVBQUViLGlCQUFpQixDQUFDRyxjQUFELENBQW5CLEVBQXFDRixnQ0FBckMsRUFBUDtBQUNIOzs7NEJBM0VnQjtBQUFFLG1CQUFPdkMsT0FBT3FELGVBQVAsQ0FBdUJDLE9BQTlCO0FBQXdDOzs7O0VBckJ2Q3ZELFlBQVl3RCxXOztBQW1HcENDLE9BQU9DLE9BQVAsR0FBaUI7QUFBQSxXQUFPO0FBQ3BCeEQ7QUFEb0IsS0FBUDtBQUFBLENBQWpCIiwiZmlsZSI6Ijg5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxuY29uc3Qgd21zRkMgPSByZXF1aXJlKCcuL3dtc0ZDLmpzJykoKTtcclxuY29uc3QgcGxhY2Vob2xkZXJGQyA9IHJlcXVpcmUoJy4vcGxhY2Vob2xkZXJGQy5qcycpKCk7XHJcbmNvbnN0IGxheWVyUmVjb3JkID0gcmVxdWlyZSgnLi9sYXllclJlY29yZC5qcycpKCk7XHJcbmNvbnN0IHNoYXJlZCA9IHJlcXVpcmUoJy4vc2hhcmVkLmpzJykoKTtcclxuXHJcbi8qKlxyXG4gKiBAY2xhc3MgV21zUmVjb3JkXHJcbiAqL1xyXG5jbGFzcyBXbXNSZWNvcmQgZXh0ZW5kcyBsYXllclJlY29yZC5MYXllclJlY29yZCB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBsYXllciByZWNvcmQgd2l0aCB0aGUgYXBwcm9wcmlhdGUgZ2VvQXBpIGxheWVyIHR5cGUuICBMYXllciBjb25maWdcclxuICAgICAqIHNob3VsZCBiZSBmdWxseSBtZXJnZWQgd2l0aCBhbGwgbGF5ZXIgb3B0aW9ucyBkZWZpbmVkIChpLmUuIHRoaXMgY29uc3RydWN0b3JcclxuICAgICAqIHdpbGwgbm90IGFwcGx5IGFueSBkZWZhdWx0cykuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbGF5ZXJDbGFzcyAgICB0aGUgRVNSSSBhcGkgb2JqZWN0IGZvciB3bXMgbGF5ZXJzXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXBpUmVmICAgICAgICBvYmplY3QgcG9pbnRpbmcgdG8gdGhlIGdlb0FwaS4gYWxsb3dzIHVzIHRvIGNhbGwgb3RoZXIgZ2VvQXBpIGZ1bmN0aW9ucy5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgICAgICAgIGxheWVyIGNvbmZpZyB2YWx1ZXNcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlc3JpTGF5ZXIgICAgIGFuIG9wdGlvbmFsIHByZS1jb25zdHJ1Y3RlZCBsYXllclxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXBzZ0xvb2t1cCAgYW4gb3B0aW9uYWwgbG9va3VwIGZ1bmN0aW9uIGZvciBFUFNHIGNvZGVzIChzZWUgZ2VvU2VydmljZSBmb3Igc2lnbmF0dXJlKVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvciAobGF5ZXJDbGFzcywgYXBpUmVmLCBjb25maWcsIGVzcmlMYXllciwgZXBzZ0xvb2t1cCkge1xyXG4gICAgICAgIHN1cGVyKGxheWVyQ2xhc3MsIGFwaVJlZiwgY29uZmlnLCBlc3JpTGF5ZXIsIGVwc2dMb29rdXApO1xyXG5cclxuICAgICAgICAvLyBoYW5kbGVzIHBsYWNlaG9sZGVyIHN5bWJvbCwgcG9zc2libHkgb3RoZXIgdGhpbmdzXHJcbiAgICAgICAgdGhpcy5fZGVmYXVsdEZDID0gJzAnO1xyXG4gICAgICAgIHRoaXMuX2ZlYXRDbGFzc2VzWycwJ10gPSBuZXcgcGxhY2Vob2xkZXJGQy5QbGFjZWhvbGRlckZDKHRoaXMsIHRoaXMubmFtZSk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGdldCBsYXllclR5cGUgKCkgeyByZXR1cm4gc2hhcmVkLmNsaWVudExheWVyVHlwZS5PR0NfV01TOyB9XHJcblxyXG4gICAgbWFrZUxheWVyQ29uZmlnICgpIHtcclxuICAgICAgICBjb25zdCBjZmcgPSBzdXBlci5tYWtlTGF5ZXJDb25maWcoKTtcclxuICAgICAgICBjZmcudmlzaWJsZUxheWVycyA9IHRoaXMuY29uZmlnLmxheWVyRW50cmllcy5tYXAobGUgPT4gbGUuaWQpO1xyXG4gICAgICAgIHJldHVybiBjZmc7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFRyaWdnZXJzIHdoZW4gdGhlIGxheWVyIGxvYWRzLlxyXG4gICAgKlxyXG4gICAgKiBAZnVuY3Rpb24gb25Mb2FkXHJcbiAgICAqL1xyXG4gICAgb25Mb2FkICgpIHtcclxuICAgICAgICBjb25zdCBsb2FkUHJvbWlzZXMgPSBzdXBlci5vbkxvYWQoKTtcclxuXHJcbiAgICAgICAgY29uc3QgZmMgPSBuZXcgd21zRkMuV21zRkModGhpcywgJzAnLCB0aGlzLmNvbmZpZyk7XHJcbiAgICAgICAgdGhpcy5fZmVhdENsYXNzZXNbJzAnXSA9IGZjO1xyXG5cclxuICAgICAgICBsb2FkUHJvbWlzZXMucHVzaChmYy5sb2FkU3ltYm9sb2d5KCkpO1xyXG5cclxuICAgICAgICBQcm9taXNlLmFsbChsb2FkUHJvbWlzZXMpLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9zdGF0ZUNoYW5nZShzaGFyZWQuc3RhdGVzLkxPQURFRCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSdW4gYSBnZXRGZWF0dXJlSW5mbyBvbiBhIFdNUyBsYXllciwgcmV0dXJuIHRoZSByZXN1bHQgYXMgYSBwcm9taXNlLiAgRmlsbHMgdGhlIHBhbmVsRGF0YSBhcnJheSBvbiByZXNvbHV0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIGFkZGl0aW9uYWwgYXJndW1ldHMgbGlrZSBtYXAgb2JqZWN0LCBjbGlja0V2ZW50LCBldGMuXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBhbiBvYmplY3Qgd2l0aCBpZGVudGlmeSByZXN1bHRzIGFycmF5IGFuZCBpZGVudGlmeSBwcm9taXNlIHJlc29sdmluZyB3aGVuIGlkZW50aWZ5IGlzIGNvbXBsZXRlOyBpZiBhbiBlbXB0eSBvYmplY3QgaXMgcmV0dXJuZWQsIGl0IHdpbGwgYmUgc2tpcHBlZFxyXG4gICAgICovXHJcbiAgICBpZGVudGlmeSAob3B0cykge1xyXG4gICAgICAgIC8vIFRPRE8gYWRkIGZ1bGwgZG9jdW1lbnRhdGlvbiBmb3Igb3B0aW9ucyBwYXJhbWV0ZXJcclxuXHJcbiAgICAgICAgLy8gVE9ETyBjb25zaWRlciBoYXZpbmcgYSBjb25zdGFudHMgYXJlYSBpbiBnZW9BcGkgLyBiZXR0ZXIgcGxhY2UgZm9yIHRoaXMgZGVmaW5pdGlvblxyXG4gICAgICAgIGNvbnN0IGluZm9NYXAgPSB7XHJcbiAgICAgICAgICAgICd0ZXh0L2h0bWw7Zmdwdj1zdW1tYXJ5JzogJ0hUTUwnLFxyXG4gICAgICAgICAgICAndGV4dC9odG1sJzogJ0hUTUwnLFxyXG4gICAgICAgICAgICAndGV4dC9wbGFpbic6ICdUZXh0JyxcclxuICAgICAgICAgICAgJ2FwcGxpY2F0aW9uL2pzb24nOiAnRXNyaUZlYXR1cmUnXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gaWdub3JlIGxheWVycyB3aXRoIG5vIG1pbWUgdHlwZSwgbm90IGxvYWRlZCwgbm90IHZpc2libGUsIG5vdCBxdWVyeWFibGVcclxuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gc2hhcmVkLnN0YXRlcy5FUlJPUiB8fFxyXG4gICAgICAgICAgICB0aGlzLnN0YXRlID09PSBzaGFyZWQuc3RhdGVzLkxPQURJTkcgfHxcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9PT0gc2hhcmVkLnN0YXRlcy5ORVcgfHxcclxuICAgICAgICAgICAgIXRoaXMudmlzaWJpbGl0eSB8fFxyXG4gICAgICAgICAgICAhdGhpcy5pc1F1ZXJ5YWJsZSgpIHx8XHJcbiAgICAgICAgICAgICFpbmZvTWFwLmhhc093blByb3BlcnR5KHRoaXMuY29uZmlnLmZlYXR1cmVJbmZvTWltZVR5cGUpKSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE8gdmVyaWZpeSB0aGlzIGlzIGNvcnJlY3QgcmVzdWx0IGZvcm1hdCBpZiBsYXllciBzaG91bGQgYmUgZXhjbHVkZWQgZnJvbSB0aGUgaWRlbnRpZnkgcHJvY2Vzc1xyXG4gICAgICAgICAgICByZXR1cm4geyBpZGVudGlmeVJlc3VsdHM6IFtdLCBpZGVudGlmeVByb21pc2U6IFByb21pc2UucmVzb2x2ZSgpIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBpZGVudGlmeVJlc3VsdCA9IG5ldyBzaGFyZWQuSWRlbnRpZnlSZXN1bHQodGhpcy5nZXRQcm94eSgpKTtcclxuXHJcbiAgICAgICAgY29uc3QgaWRlbnRpZnlQcm9taXNlID0gdGhpcy5fYXBpUmVmLmxheWVyLm9nY1xyXG4gICAgICAgICAgICAuZ2V0RmVhdHVyZUluZm8oXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXllcixcclxuICAgICAgICAgICAgICAgIG9wdHMuY2xpY2tFdmVudCxcclxuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLmxheWVyRW50cmllcy5tYXAobGUgPT4gbGUuaWQpLFxyXG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWcuZmVhdHVyZUluZm9NaW1lVHlwZSlcclxuICAgICAgICAgICAgLnRoZW4oZGF0YSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZGVudGlmeVJlc3VsdC5pc0xvYWRpbmcgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBjaGVjayBmb3IgRnJlbmNoIHNlcnZpY2VcclxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGEgcmVzdWx0IGlzIHJldHVybmVkIGJ5IHRoZSBzZXJ2aWNlLiBJZiBub3QsIGRvIG5vdCBhZGQgdG8gdGhlIGFycmF5IG9mIGRhdGFcclxuICAgICAgICAgICAgICAgIGlmIChkYXRhLmluZGV4T2YoJ1NlYXJjaCByZXR1cm5lZCBubyByZXN1bHRzJykgPT09IC0xICYmIGRhdGEgIT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWRlbnRpZnlSZXN1bHQuZGF0YS5wdXNoKGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUuaW5mbyhkYXRhKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiB7IGlkZW50aWZ5UmVzdWx0czogW2lkZW50aWZ5UmVzdWx0XSwgaWRlbnRpZnlQcm9taXNlIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gKCkgPT4gKHtcclxuICAgIFdtc1JlY29yZFxyXG59KTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2xheWVyL2xheWVyUmVjL3dtc1JlY29yZC5qcyJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar yxList = __webpack_require__(174);\n\nfunction getFeatureInfoBuilder(esriBundle) {\n    /**\r\n     * Handles click events for WMS layers (makes a WMS GetFeatureInfo call behind the scenes).\r\n     *\r\n     * @param {WMSLayer} wmsLayer an ESRI WMSLayer object to be queried\r\n     * @param {Object} clickEvent an ESRI map click event (used for screen coordinates)\r\n     * @param {Array} layerList a list of strings identifying the WMS layers to be queried\r\n     * @param {String} mimeType the format to be requested for the response\r\n     * @returns {Promise} a promise which resolves with the raw text of the GetFeatureInfo response\r\n     */\n    return function (wmsLayer, clickEvent, layerList, mimeType) {\n        var wkid = void 0;\n        var req = void 0;\n        var esriMap = wmsLayer.getMap();\n        var ext = esriMap.extent;\n        var srList = wmsLayer.spatialReferences;\n        var layers = layerList.join(',');\n\n        if (srList && srList.length > 1) {\n            wkid = srList[0];\n        } else if (esriMap.spatialReference.wkid) {\n            wkid = esriMap.spatialReference.wkid;\n        }\n        if (wmsLayer.version === '1.3' || wmsLayer.version === '1.3.0') {\n            req = { CRS: 'EPSG:' + wkid, I: clickEvent.screenPoint.x, J: clickEvent.screenPoint.y,\n                STYLES: '', FORMAT: wmsLayer.imageFormat };\n            if (yxList.indexOf(String(wkid)) > -1) {\n                req.BBOX = ext.ymin + ',' + ext.xmin + ',' + ext.ymax + ',' + ext.xmax;\n            }\n        } else {\n            req = { SRS: 'EPSG:' + wkid, X: clickEvent.screenPoint.x, Y: clickEvent.screenPoint.y };\n        }\n        if (!req.hasOwnProperty('BBOX')) {\n            req.BBOX = ext.xmin + ',' + ext.ymin + ',' + ext.xmax + ',' + ext.ymax;\n        }\n        var settings = {\n            SERVICE: 'WMS',\n            REQUEST: 'GetFeatureInfo',\n            VERSION: wmsLayer.version,\n            WIDTH: esriMap.width,\n            HEIGHT: esriMap.height,\n            QUERY_LAYERS: layers,\n            LAYERS: layers,\n            INFO_FORMAT: mimeType\n        };\n\n        Object.keys(settings).forEach(function (key) {\n            return req[key] = settings[key];\n        });\n\n        return Promise.resolve(esriBundle.esriRequest({\n            url: wmsLayer.url.split('?')[0],\n            content: req,\n            handleAs: 'text'\n        }));\n    };\n}\n\nfunction parseCapabilitiesBuilder(esriBundle) {\n\n    var query = esriBundle.dojoQuery;\n\n    /**\r\n     * Fetch layer data from a WMS endpoint.  This method will execute a WMS GetCapabilities\r\n     * request against the specified URL, it requests WMS 1.3 and it is capable of parsing\r\n     * 1.3 or 1.1.1 responses.  It returns a promise which will resolve with basic layer\r\n     * metadata and querying information.\r\n     *\r\n     * metadata response format:\r\n     *   { queryTypes: [mimeType(str)],\r\n     *     layers: [\r\n     *       {name(str), desc(str), queryable(bool), layers:[recursive] }\r\n     *     ] }\r\n     *\r\n     * @param {string} wmsEndpoint a URL pointing to a WMS server (it must not include a query string)\r\n     * @return {Promise} a promise resolving with a metadata object (as specified above)\r\n     */\n    return function (wmsEndpoint) {\n        var reqPromise = new Promise(function (resolve) {\n            getCapabilities().then(function (data) {\n                return resolve(data);\n            }) // if successful, pass straight back\n            .catch(function () {\n                // if errors, try again; see fgpv-vpgf/fgpv-vpgf#908 issue\n                console.error('Get capabilities failed; trying the second time;');\n                resolve(getCapabilities());\n            });\n        });\n\n        // there might already be a way to do this in the parsing API\n        // I don't know XML parsing well enough (and I don't want to)\n        // this has now been ported from RAMP to FGPV and I still, happily,\n        // do not know any more about XML parsing now\n        function getImmediateChild(node, childName) {\n            for (var i = 0; i < node.childNodes.length; ++i) {\n                if (node.childNodes[i].nodeName === childName) {\n                    return node.childNodes[i];\n                }\n            }\n            return undefined;\n        }\n\n        // find all <Layer> nodes under the given XML node\n        // pick title, name and queryable nodes/attributes\n        // recursively called on all child <Layer> nodes\n        function getLayers(xmlNode) {\n            return query('> Layer', xmlNode).map(function (layer) {\n                var nameNode = getImmediateChild(layer, 'Name');\n                var titleNode = getImmediateChild(layer, 'Title');\n                return {\n                    name: nameNode ? nameNode.textContent : null,\n                    desc: titleNode.textContent,\n                    queryable: layer.getAttribute('queryable') === '1',\n                    layers: getLayers(layer)\n                };\n            });\n        }\n\n        function getCapabilities() {\n            var url = wmsEndpoint;\n\n            // if url has a '?' do not append to avoid errors, user must add this manually\n            if (wmsEndpoint.indexOf('?') === -1) {\n                url += '?service=WMS&version=1.3&request=GetCapabilities';\n            }\n\n            return Promise.resolve(new esriBundle.esriRequest({\n                url: url,\n                handleAs: 'xml'\n            }).promise);\n        }\n\n        return reqPromise.then(function (data) {\n            return {\n                layers: getLayers(query('Capability', data)[0]),\n                queryTypes: query('GetFeatureInfo > Format', data).map(function (node) {\n                    return node.textContent;\n                })\n            };\n        });\n    };\n}\n\n/**\r\n * Recursively crawl a wms layer info structure. Store any legends in the provided map object.\r\n *\r\n * @private\r\n * @param {Array} layerInfos array of ESRI WMSLayerInfo objects\r\n * @param {Map} urlMap a Map of sublayer names to legend urls\r\n */\nfunction crawlLayerInfos(layerInfos, urlMap) {\n    layerInfos.forEach(function (li) {\n        if (li.name) {\n            urlMap.set(li.name, li.legendURL);\n        }\n        if (li.subLayers.length > 0) {\n            crawlLayerInfos(li.subLayers, urlMap);\n        }\n    });\n}\n\n/**\r\n * Finds the appropriate legend URLs for WMS layers.\r\n *\r\n * @param {WMSLayer} wmsLayer an ESRI WMSLayer object to be queried\r\n * @param {Array} layerList a list of strings identifying the WMS layers to be queried\r\n * @returns {Array} a list of strings containing URLs for specified layers (order is preserved)\r\n */\nfunction getLegendUrls(wmsLayer, layerList) {\n    var liMap = new Map(); // use Map in case someone clever uses a WMS layer name that matches an Object's default properties\n    crawlLayerInfos(wmsLayer.layerInfos, liMap);\n    return layerList.map(function (l) {\n        return liMap.get(l);\n    });\n}\n\nmodule.exports = function (esriBundle) {\n    return {\n        WmsLayer: esriBundle.WmsLayer,\n        getFeatureInfo: getFeatureInfoBuilder(esriBundle),\n        parseCapabilities: parseCapabilitiesBuilder(esriBundle),\n        getLegendUrls: getLegendUrls\n    };\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXIvb2djLmpzPzNmNzkiXSwibmFtZXMiOlsieXhMaXN0IiwicmVxdWlyZSIsImdldEZlYXR1cmVJbmZvQnVpbGRlciIsImVzcmlCdW5kbGUiLCJ3bXNMYXllciIsImNsaWNrRXZlbnQiLCJsYXllckxpc3QiLCJtaW1lVHlwZSIsIndraWQiLCJyZXEiLCJlc3JpTWFwIiwiZ2V0TWFwIiwiZXh0IiwiZXh0ZW50Iiwic3JMaXN0Iiwic3BhdGlhbFJlZmVyZW5jZXMiLCJsYXllcnMiLCJqb2luIiwibGVuZ3RoIiwic3BhdGlhbFJlZmVyZW5jZSIsInZlcnNpb24iLCJDUlMiLCJJIiwic2NyZWVuUG9pbnQiLCJ4IiwiSiIsInkiLCJTVFlMRVMiLCJGT1JNQVQiLCJpbWFnZUZvcm1hdCIsImluZGV4T2YiLCJTdHJpbmciLCJCQk9YIiwieW1pbiIsInhtaW4iLCJ5bWF4IiwieG1heCIsIlNSUyIsIlgiLCJZIiwiaGFzT3duUHJvcGVydHkiLCJzZXR0aW5ncyIsIlNFUlZJQ0UiLCJSRVFVRVNUIiwiVkVSU0lPTiIsIldJRFRIIiwid2lkdGgiLCJIRUlHSFQiLCJoZWlnaHQiLCJRVUVSWV9MQVlFUlMiLCJMQVlFUlMiLCJJTkZPX0ZPUk1BVCIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwia2V5IiwiUHJvbWlzZSIsInJlc29sdmUiLCJlc3JpUmVxdWVzdCIsInVybCIsInNwbGl0IiwiY29udGVudCIsImhhbmRsZUFzIiwicGFyc2VDYXBhYmlsaXRpZXNCdWlsZGVyIiwicXVlcnkiLCJkb2pvUXVlcnkiLCJ3bXNFbmRwb2ludCIsInJlcVByb21pc2UiLCJnZXRDYXBhYmlsaXRpZXMiLCJ0aGVuIiwiZGF0YSIsImNhdGNoIiwiY29uc29sZSIsImVycm9yIiwiZ2V0SW1tZWRpYXRlQ2hpbGQiLCJub2RlIiwiY2hpbGROYW1lIiwiaSIsImNoaWxkTm9kZXMiLCJub2RlTmFtZSIsInVuZGVmaW5lZCIsImdldExheWVycyIsInhtbE5vZGUiLCJtYXAiLCJuYW1lTm9kZSIsImxheWVyIiwidGl0bGVOb2RlIiwibmFtZSIsInRleHRDb250ZW50IiwiZGVzYyIsInF1ZXJ5YWJsZSIsImdldEF0dHJpYnV0ZSIsInByb21pc2UiLCJxdWVyeVR5cGVzIiwiY3Jhd2xMYXllckluZm9zIiwibGF5ZXJJbmZvcyIsInVybE1hcCIsImxpIiwic2V0IiwibGVnZW5kVVJMIiwic3ViTGF5ZXJzIiwiZ2V0TGVnZW5kVXJscyIsImxpTWFwIiwiTWFwIiwiZ2V0IiwibCIsIm1vZHVsZSIsImV4cG9ydHMiLCJXbXNMYXllciIsImdldEZlYXR1cmVJbmZvIiwicGFyc2VDYXBhYmlsaXRpZXMiXSwibWFwcGluZ3MiOiJBQUFBOztBQUNBLElBQU1BLFNBQVMsbUJBQUFDLENBQVEsR0FBUixDQUFmOztBQUVBLFNBQVNDLHFCQUFULENBQStCQyxVQUEvQixFQUEyQztBQUN2Qzs7Ozs7Ozs7O0FBU0EsV0FBTyxVQUFDQyxRQUFELEVBQVdDLFVBQVgsRUFBdUJDLFNBQXZCLEVBQWtDQyxRQUFsQyxFQUErQztBQUNsRCxZQUFJQyxhQUFKO0FBQ0EsWUFBSUMsWUFBSjtBQUNBLFlBQU1DLFVBQVVOLFNBQVNPLE1BQVQsRUFBaEI7QUFDQSxZQUFNQyxNQUFNRixRQUFRRyxNQUFwQjtBQUNBLFlBQU1DLFNBQVNWLFNBQVNXLGlCQUF4QjtBQUNBLFlBQU1DLFNBQVNWLFVBQVVXLElBQVYsQ0FBZSxHQUFmLENBQWY7O0FBRUEsWUFBSUgsVUFBVUEsT0FBT0ksTUFBUCxHQUFnQixDQUE5QixFQUFpQztBQUM3QlYsbUJBQU9NLE9BQU8sQ0FBUCxDQUFQO0FBQ0gsU0FGRCxNQUVPLElBQUlKLFFBQVFTLGdCQUFSLENBQXlCWCxJQUE3QixFQUFtQztBQUN0Q0EsbUJBQU9FLFFBQVFTLGdCQUFSLENBQXlCWCxJQUFoQztBQUNIO0FBQ0QsWUFBSUosU0FBU2dCLE9BQVQsS0FBcUIsS0FBckIsSUFBOEJoQixTQUFTZ0IsT0FBVCxLQUFxQixPQUF2RCxFQUFnRTtBQUM1RFgsa0JBQU0s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QkMsVUFBekIsRUFBcUNDLE1BQXJDLEVBQTZDO0FBQ3pDRCxlQUFXekMsT0FBWCxDQUFtQixjQUFNO0FBQ3JCLFlBQUkyQyxHQUFHVixJQUFQLEVBQWE7QUFDVFMsbUJBQU9FLEdBQVAsQ0FBV0QsR0FBR1YsSUFBZCxFQUFvQlUsR0FBR0UsU0FBdkI7QUFDSDtBQUNELFlBQUlGLEdBQUdHLFNBQUgsQ0FBYWxGLE1BQWIsR0FBc0IsQ0FBMUIsRUFBNkI7QUFDekI0RSw0QkFBZ0JHLEdBQUdHLFNBQW5CLEVBQThCSixNQUE5QjtBQUNIO0FBQ0osS0FQRDtBQVFIOztBQUVEOzs7Ozs7O0FBT0EsU0FBU0ssYUFBVCxDQUF1QmpHLFFBQXZCLEVBQWlDRSxTQUFqQyxFQUE0QztBQUN4QyxRQUFNZ0csUUFBUSxJQUFJQyxHQUFKLEVBQWQsQ0FEd0MsQ0FDZjtBQUN6QlQsb0JBQWdCMUYsU0FBUzJGLFVBQXpCLEVBQXFDTyxLQUFyQztBQUNBLFdBQU9oRyxVQUFVNkUsR0FBVixDQUFjO0FBQUEsZUFBS21CLE1BQU1FLEdBQU4sQ0FBVUMsQ0FBVixDQUFMO0FBQUEsS0FBZCxDQUFQO0FBQ0g7O0FBRURDLE9BQU9DLE9BQVAsR0FBaUIsc0JBQWM7QUFDM0IsV0FBTztBQUNIQyxrQkFBVXpHLFdBQVd5RyxRQURsQjtBQUVIQyx3QkFBZ0IzRyxzQkFBc0JDLFVBQXRCLENBRmI7QUFHSDJHLDJCQUFtQi9DLHlCQUF5QjVELFVBQXpCLENBSGhCO0FBSUhrRztBQUpHLEtBQVA7QUFNSCxDQVBEIiwiZmlsZSI6IjkwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5jb25zdCB5eExpc3QgPSByZXF1aXJlKCcuL3JldmVyc2VkQXhpcy5qc29uJyk7XHJcblxyXG5mdW5jdGlvbiBnZXRGZWF0dXJlSW5mb0J1aWxkZXIoZXNyaUJ1bmRsZSkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGVzIGNsaWNrIGV2ZW50cyBmb3IgV01TIGxheWVycyAobWFrZXMgYSBXTVMgR2V0RmVhdHVyZUluZm8gY2FsbCBiZWhpbmQgdGhlIHNjZW5lcykuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtXTVNMYXllcn0gd21zTGF5ZXIgYW4gRVNSSSBXTVNMYXllciBvYmplY3QgdG8gYmUgcXVlcmllZFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNsaWNrRXZlbnQgYW4gRVNSSSBtYXAgY2xpY2sgZXZlbnQgKHVzZWQgZm9yIHNjcmVlbiBjb29yZGluYXRlcylcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxheWVyTGlzdCBhIGxpc3Qgb2Ygc3RyaW5ncyBpZGVudGlmeWluZyB0aGUgV01TIGxheWVycyB0byBiZSBxdWVyaWVkXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWltZVR5cGUgdGhlIGZvcm1hdCB0byBiZSByZXF1ZXN0ZWQgZm9yIHRoZSByZXNwb25zZVxyXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aXRoIHRoZSByYXcgdGV4dCBvZiB0aGUgR2V0RmVhdHVyZUluZm8gcmVzcG9uc2VcclxuICAgICAqL1xyXG4gICAgcmV0dXJuICh3bXNMYXllciwgY2xpY2tFdmVudCwgbGF5ZXJMaXN0LCBtaW1lVHlwZSkgPT4ge1xyXG4gICAgICAgIGxldCB3a2lkO1xyXG4gICAgICAgIGxldCByZXE7XHJcbiAgICAgICAgY29uc3QgZXNyaU1hcCA9IHdtc0xheWVyLmdldE1hcCgpO1xyXG4gICAgICAgIGNvbnN0IGV4dCA9IGVzcmlNYXAuZXh0ZW50O1xyXG4gICAgICAgIGNvbnN0IHNyTGlzdCA9IHdtc0xheWVyLnNwYXRpYWxSZWZlcmVuY2VzO1xyXG4gICAgICAgIGNvbnN0IGxheWVycyA9IGxheWVyTGlzdC5qb2luKCcsJyk7XHJcblxyXG4gICAgICAgIGlmIChzckxpc3QgJiYgc3JMaXN0Lmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgd2tpZCA9IHNyTGlzdFswXTtcclxuICAgICAgICB9IGVsc2UgaWYgKGVzcmlNYXAuc3BhdGlhbFJlZmVyZW5jZS53a2lkKSB7XHJcbiAgICAgICAgICAgIHdraWQgPSBlc3JpTWFwLnNwYXRpYWxSZWZlcmVuY2Uud2tpZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHdtc0xheWVyLnZlcnNpb24gPT09ICcxLjMnIHx8IHdtc0xheWVyLnZlcnNpb24gPT09ICcxLjMuMCcpIHtcclxuICAgICAgICAgICAgcmVxID0geyBDUlM6ICdFUFNHOicgKyB3a2lkLCBJOiBjbGlja0V2ZW50LnNjcmVlblBvaW50LngsIEo6IGNsaWNrRXZlbnQuc2NyZWVuUG9pbnQueSxcclxuICAgICAgICAgICAgICAgICAgICBTVFlMRVM6ICcnLCBGT1JNQVQ6IHdtc0xheWVyLmltYWdlRm9ybWF0IH07XHJcbiAgICAgICAgICAgIGlmICh5eExpc3QuaW5kZXhPZihTdHJpbmcod2tpZCkpID4gLTEpIHtcclxuICAgICAgICAgICAgICAgIHJlcS5CQk9YID0gYCR7ZXh0LnltaW59LCR7ZXh0LnhtaW59LCR7ZXh0LnltYXh9LCR7ZXh0LnhtYXh9YDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJlcSA9IHsgU1JTOiAnRVBTRzonICsgd2tpZCwgWDogY2xpY2tFdmVudC5zY3JlZW5Qb2ludC54LCBZOiBjbGlja0V2ZW50LnNjcmVlblBvaW50LnkgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFyZXEuaGFzT3duUHJvcGVydHkoJ0JCT1gnKSkge1xyXG4gICAgICAgICAgICByZXEuQkJPWCA9IGAke2V4dC54bWlufSwke2V4dC55bWlufSwke2V4dC54bWF4fSwke2V4dC55bWF4fWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0ge1xyXG4gICAgICAgICAgICBTRVJWSUNFOiAnV01TJyxcclxuICAgICAgICAgICAgUkVRVUVTVDogJ0dldEZlYXR1cmVJbmZvJyxcclxuICAgICAgICAgICAgVkVSU0lPTjogd21zTGF5ZXIudmVyc2lvbixcclxuICAgICAgICAgICAgV0lEVEg6IGVzcmlNYXAud2lkdGgsXHJcbiAgICAgICAgICAgIEhFSUdIVDogZXNyaU1hcC5oZWlnaHQsXHJcbiAgICAgICAgICAgIFFVRVJZX0xBWUVSUzogbGF5ZXJzLFxyXG4gICAgICAgICAgICBMQVlFUlM6IGxheWVycyxcclxuICAgICAgICAgICAgSU5GT19GT1JNQVQ6IG1pbWVUeXBlXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgT2JqZWN0LmtleXMoc2V0dGluZ3MpLmZvckVhY2goa2V5ID0+IHJlcVtrZXldID0gc2V0dGluZ3Nba2V5XSk7XHJcblxyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZXNyaUJ1bmRsZS5lc3JpUmVxdWVzdCh7XHJcbiAgICAgICAgICAgIHVybDogd21zTGF5ZXIudXJsLnNwbGl0KCc/JylbMF0sXHJcbiAgICAgICAgICAgIGNvbnRlbnQ6IHJlcSxcclxuICAgICAgICAgICAgaGFuZGxlQXM6ICd0ZXh0J1xyXG4gICAgICAgIH0pKTtcclxuICAgIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhcnNlQ2FwYWJpbGl0aWVzQnVpbGRlcihlc3JpQnVuZGxlKSB7XHJcblxyXG4gICAgY29uc3QgcXVlcnkgPSBlc3JpQnVuZGxlLmRvam9RdWVyeTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZldGNoIGxheWVyIGRhdGEgZnJvbSBhIFdNUyBlbmRwb2ludC4gIFRoaXMgbWV0aG9kIHdpbGwgZXhlY3V0ZSBhIFdNUyBHZXRDYXBhYmlsaXRpZXNcclxuICAgICAqIHJlcXVlc3QgYWdhaW5zdCB0aGUgc3BlY2lmaWVkIFVSTCwgaXQgcmVxdWVzdHMgV01TIDEuMyBhbmQgaXQgaXMgY2FwYWJsZSBvZiBwYXJzaW5nXHJcbiAgICAgKiAxLjMgb3IgMS4xLjEgcmVzcG9uc2VzLiAgSXQgcmV0dXJucyBhIHByb21pc2Ugd2hpY2ggd2lsbCByZXNvbHZlIHdpdGggYmFzaWMgbGF5ZXJcclxuICAgICAqIG1ldGFkYXRhIGFuZCBxdWVyeWluZyBpbmZvcm1hdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBtZXRhZGF0YSByZXNwb25zZSBmb3JtYXQ6XHJcbiAgICAgKiAgIHsgcXVlcnlUeXBlczogW21pbWVUeXBlKHN0cildLFxyXG4gICAgICogICAgIGxheWVyczogW1xyXG4gICAgICogICAgICAge25hbWUoc3RyKSwgZGVzYyhzdHIpLCBxdWVyeWFibGUoYm9vbCksIGxheWVyczpbcmVjdXJzaXZlXSB9XHJcbiAgICAgKiAgICAgXSB9XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHdtc0VuZHBvaW50IGEgVVJMIHBvaW50aW5nIHRvIGEgV01TIHNlcnZlciAoaXQgbXVzdCBub3QgaW5jbHVkZSBhIHF1ZXJ5IHN0cmluZylcclxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSByZXNvbHZpbmcgd2l0aCBhIG1ldGFkYXRhIG9iamVjdCAoYXMgc3BlY2lmaWVkIGFib3ZlKVxyXG4gICAgICovXHJcbiAgICByZXR1cm4gKHdtc0VuZHBvaW50KSA9PiB7XHJcbiAgICAgICAgY29uc3QgcmVxUHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xyXG4gICAgICAgICAgICBnZXRDYXBhYmlsaXRpZXMoKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZGF0YSA9PiByZXNvbHZlKGRhdGEpKSAvLyBpZiBzdWNjZXNzZnVsLCBwYXNzIHN0cmFpZ2h0IGJhY2tcclxuICAgICAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB7IC8vIGlmIGVycm9ycywgdHJ5IGFnYWluOyBzZWUgZmdwdi12cGdmL2ZncHYtdnBnZiM5MDggaXNzdWVcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdHZXQgY2FwYWJpbGl0aWVzIGZhaWxlZDsgdHJ5aW5nIHRoZSBzZWNvbmQgdGltZTsnKTtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGdldENhcGFiaWxpdGllcygpKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyB0aGVyZSBtaWdodCBhbHJlYWR5IGJlIGEgd2F5IHRvIGRvIHRoaXMgaW4gdGhlIHBhcnNpbmcgQVBJXHJcbiAgICAgICAgLy8gSSBkb24ndCBrbm93IFhNTCBwYXJzaW5nIHdlbGwgZW5vdWdoIChhbmQgSSBkb24ndCB3YW50IHRvKVxyXG4gICAgICAgIC8vIHRoaXMgaGFzIG5vdyBiZWVuIHBvcnRlZCBmcm9tIFJBTVAgdG8gRkdQViBhbmQgSSBzdGlsbCwgaGFwcGlseSxcclxuICAgICAgICAvLyBkbyBub3Qga25vdyBhbnkgbW9yZSBhYm91dCBYTUwgcGFyc2luZyBub3dcclxuICAgICAgICBmdW5jdGlvbiBnZXRJbW1lZGlhdGVDaGlsZChub2RlLCBjaGlsZE5hbWUpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIGlmIChub2RlLmNoaWxkTm9kZXNbaV0ubm9kZU5hbWUgPT09IGNoaWxkTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmNoaWxkTm9kZXNbaV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGZpbmQgYWxsIDxMYXllcj4gbm9kZXMgdW5kZXIgdGhlIGdpdmVuIFhNTCBub2RlXHJcbiAgICAgICAgLy8gcGljayB0aXRsZSwgbmFtZSBhbmQgcXVlcnlhYmxlIG5vZGVzL2F0dHJpYnV0ZXNcclxuICAgICAgICAvLyByZWN1cnNpdmVseSBjYWxsZWQgb24gYWxsIGNoaWxkIDxMYXllcj4gbm9kZXNcclxuICAgICAgICBmdW5jdGlvbiBnZXRMYXllcnMoeG1sTm9kZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcXVlcnkoJz4gTGF5ZXInLCB4bWxOb2RlKS5tYXAobGF5ZXIgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZU5vZGUgPSBnZXRJbW1lZGlhdGVDaGlsZChsYXllciwgJ05hbWUnKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRpdGxlTm9kZSA9IGdldEltbWVkaWF0ZUNoaWxkKGxheWVyLCAnVGl0bGUnKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZU5vZGUgPyBuYW1lTm9kZS50ZXh0Q29udGVudCA6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgZGVzYzogdGl0bGVOb2RlLnRleHRDb250ZW50LFxyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5YWJsZTogbGF5ZXIuZ2V0QXR0cmlidXRlKCdxdWVyeWFibGUnKSA9PT0gJzEnLFxyXG4gICAgICAgICAgICAgICAgICAgIGxheWVyczogZ2V0TGF5ZXJzKGxheWVyKVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBnZXRDYXBhYmlsaXRpZXMoKSB7XHJcbiAgICAgICAgICAgIGxldCB1cmwgPSB3bXNFbmRwb2ludDtcclxuXHJcbiAgICAgICAgICAgIC8vIGlmIHVybCBoYXMgYSAnPycgZG8gbm90IGFwcGVuZCB0byBhdm9pZCBlcnJvcnMsIHVzZXIgbXVzdCBhZGQgdGhpcyBtYW51YWxseVxyXG4gICAgICAgICAgICBpZiAod21zRW5kcG9pbnQuaW5kZXhPZignPycpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgdXJsICs9ICc/c2VydmljZT1XTVMmdmVyc2lvbj0xLjMmcmVxdWVzdD1HZXRDYXBhYmlsaXRpZXMnO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBlc3JpQnVuZGxlLmVzcmlSZXF1ZXN0KHtcclxuICAgICAgICAgICAgICAgIHVybCxcclxuICAgICAgICAgICAgICAgIGhhbmRsZUFzOiAneG1sJ1xyXG4gICAgICAgICAgICB9KS5wcm9taXNlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZXFQcm9taXNlLnRoZW4oZGF0YSA9PiAoe1xyXG4gICAgICAgICAgICBsYXllcnM6IGdldExheWVycyhxdWVyeSgnQ2FwYWJpbGl0eScsIGRhdGEpWzBdKSxcclxuICAgICAgICAgICAgcXVlcnlUeXBlczogcXVlcnkoJ0dldEZlYXR1cmVJbmZvID4gRm9ybWF0JywgZGF0YSkubWFwKG5vZGUgPT4gbm9kZS50ZXh0Q29udGVudClcclxuICAgICAgICB9KSk7XHJcbiAgICB9O1xyXG5cclxufVxyXG5cclxuLyoqXHJcbiAqIFJlY3Vyc2l2ZWx5IGNyYXdsIGEgd21zIGxheWVyIGluZm8gc3RydWN0dXJlLiBTdG9yZSBhbnkgbGVnZW5kcyBpbiB0aGUgcHJvdmlkZWQgbWFwIG9iamVjdC5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtBcnJheX0gbGF5ZXJJbmZvcyBhcnJheSBvZiBFU1JJIFdNU0xheWVySW5mbyBvYmplY3RzXHJcbiAqIEBwYXJhbSB7TWFwfSB1cmxNYXAgYSBNYXAgb2Ygc3VibGF5ZXIgbmFtZXMgdG8gbGVnZW5kIHVybHNcclxuICovXHJcbmZ1bmN0aW9uIGNyYXdsTGF5ZXJJbmZvcyhsYXllckluZm9zLCB1cmxNYXApIHtcclxuICAgIGxheWVySW5mb3MuZm9yRWFjaChsaSA9PiB7XHJcbiAgICAgICAgaWYgKGxpLm5hbWUpIHtcclxuICAgICAgICAgICAgdXJsTWFwLnNldChsaS5uYW1lLCBsaS5sZWdlbmRVUkwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGkuc3ViTGF5ZXJzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgY3Jhd2xMYXllckluZm9zKGxpLnN1YkxheWVycywgdXJsTWFwKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEZpbmRzIHRoZSBhcHByb3ByaWF0ZSBsZWdlbmQgVVJMcyBmb3IgV01TIGxheWVycy5cclxuICpcclxuICogQHBhcmFtIHtXTVNMYXllcn0gd21zTGF5ZXIgYW4gRVNSSSBXTVNMYXllciBvYmplY3QgdG8gYmUgcXVlcmllZFxyXG4gKiBAcGFyYW0ge0FycmF5fSBsYXllckxpc3QgYSBsaXN0IG9mIHN0cmluZ3MgaWRlbnRpZnlpbmcgdGhlIFdNUyBsYXllcnMgdG8gYmUgcXVlcmllZFxyXG4gKiBAcmV0dXJucyB7QXJyYXl9IGEgbGlzdCBvZiBzdHJpbmdzIGNvbnRhaW5pbmcgVVJMcyBmb3Igc3BlY2lmaWVkIGxheWVycyAob3JkZXIgaXMgcHJlc2VydmVkKVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0TGVnZW5kVXJscyh3bXNMYXllciwgbGF5ZXJMaXN0KSB7XHJcbiAgICBjb25zdCBsaU1hcCA9IG5ldyBNYXAoKTsgLy8gdXNlIE1hcCBpbiBjYXNlIHNvbWVvbmUgY2xldmVyIHVzZXMgYSBXTVMgbGF5ZXIgbmFtZSB0aGF0IG1hdGNoZXMgYW4gT2JqZWN0J3MgZGVmYXVsdCBwcm9wZXJ0aWVzXHJcbiAgICBjcmF3bExheWVySW5mb3Mod21zTGF5ZXIubGF5ZXJJbmZvcywgbGlNYXApO1xyXG4gICAgcmV0dXJuIGxheWVyTGlzdC5tYXAobCA9PiBsaU1hcC5nZXQobCkpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGVzcmlCdW5kbGUgPT4ge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBXbXNMYXllcjogZXNyaUJ1bmRsZS5XbXNMYXllcixcclxuICAgICAgICBnZXRGZWF0dXJlSW5mbzogZ2V0RmVhdHVyZUluZm9CdWlsZGVyKGVzcmlCdW5kbGUpLFxyXG4gICAgICAgIHBhcnNlQ2FwYWJpbGl0aWVzOiBwYXJzZUNhcGFiaWxpdGllc0J1aWxkZXIoZXNyaUJ1bmRsZSksXHJcbiAgICAgICAgZ2V0TGVnZW5kVXJsc1xyXG4gICAgfTtcclxufTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2xheWVyL29nYy5qcyJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){"use strict";eval("\n\n/**\r\n * Make basemap gallery based on the settings of basemap metadata.\r\n *\r\n * @function\r\n * @param {Object} esriBundle ESRI modules from the initial startup\r\n * @param {Array} basemapsConfig array of basemap settings in the form { id: string, layers: [string], title: string, thumbnailUrl: string, wkid: integer }\r\n * @param {esriMap} map ESRI map object\r\n * @return {Object} an object with the following properties:\r\n * <ul>\r\n *   <li>setBasemap {function} set current basemap with a basemap uid</li>\r\n *   <li>basemapGallery {object} basemapGallery object</li>\r\n * </ul>\r\n */\n\nfunction initBasemaps(esriBundle, basemapsConfig, map) {\n\n    var basemapGallery = new esriBundle.BasemapGallery({ showArcGISBasemaps: false, map: map });\n\n    // iterate throuh basemap configs\n    basemapsConfig.forEach(function (basemapConfig) {\n\n        // create basemap, add to basemap gallery\n        var layers = basemapConfig.layers.map(function (config) {\n            return new esriBundle.BasemapLayer({ url: config.url, opacity: basemapConfig.opacity });\n        });\n\n        var basemap = new esriBundle.Basemap({\n            id: basemapConfig.id,\n            layers: layers,\n            title: basemapConfig.name,\n            thumbnailUrl: basemapConfig.thumbnailUrl,\n            wkid: basemapConfig.wkid\n        });\n\n        basemapGallery.add(basemap);\n    });\n\n    // finalize basmap gallery\n    basemapGallery.startup();\n\n    // display message\n    // TODO: add ui hook? to display msg on screen\n    basemapGallery.on('error', function (msg) {\n        throw new Error(msg);\n    });\n\n    return basemapGallery;\n}\n\n/**\r\n  *\r\n  * The `Basemap` module provides basemap related functions.\r\n  *\r\n  * This module exports an object with the following properties\r\n  * - `Basemap` esri/dijit/Basemap class\r\n  * - `BasemapGallery` esri/dijit/BasemapGallery class\r\n  * - `BasemapLayer` esri/dijit/BasemapLayer class\r\n  * - `makeBasemaps` function that makes a basemap gallery based on the settings provided\r\n  */\n\n// Basemap related modules\nmodule.exports = { initBasemaps: initBasemaps };//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbWFwL2Jhc2VtYXAuanM/ZDc4ZSJdLCJuYW1lcyI6WyJpbml0QmFzZW1hcHMiLCJlc3JpQnVuZGxlIiwiYmFzZW1hcHNDb25maWciLCJtYXAiLCJiYXNlbWFwR2FsbGVyeSIsIkJhc2VtYXBHYWxsZXJ5Iiwic2hvd0FyY0dJU0Jhc2VtYXBzIiwiZm9yRWFjaCIsImxheWVycyIsImJhc2VtYXBDb25maWciLCJCYXNlbWFwTGF5ZXIiLCJ1cmwiLCJjb25maWciLCJvcGFjaXR5IiwiYmFzZW1hcCIsIkJhc2VtYXAiLCJpZCIsInRpdGxlIiwibmFtZSIsInRodW1ibmFpbFVybCIsIndraWQiLCJhZGQiLCJzdGFydHVwIiwib24iLCJFcnJvciIsIm1zZyIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBOzs7Ozs7Ozs7Ozs7OztBQWFBLFNBQVNBLFlBQVQsQ0FBc0JDLFVBQXRCLEVBQWtDQyxjQUFsQyxFQUFrREMsR0FBbEQsRUFBdUQ7O0FBRW5ELFFBQU1DLGlCQUFpQixJQUFJSCxXQUFXSSxjQUFmLENBQThCLEVBQUVDLG9CQUFvQixLQUF0QixFQUE2QkgsUUFBN0IsRUFBOUIsQ0FBdkI7O0FBRUE7QUFDQUQsbUJBQWVLLE9BQWYsQ0FBdUIseUJBQWlCOztBQUVwQztBQUNBLFlBQU1DLFNBQVNDLGNBQWNELE1BQWQsQ0FBcUJMLEdBQXJCLENBQXlCO0FBQUEsbUJBQ3BDLElBQUlGLFdBQVdTLFlBQWYsQ0FBNEIsRUFBRUMsS0FBS0MsT0FBT0QsR0FBZCxFQUFtQkUsU0FBU0osY0FBY0ksT0FBMUMsRUFBNUIsQ0FEb0M7QUFBQSxTQUF6QixDQUFmOztBQUdBLFlBQU1DLFVBQVUsSUFBSWIsV0FBV2MsT0FBZixDQUF1QjtBQUNuQ0MsZ0JBQUlQLGNBQWNPLEVBRGlCO0FBRW5DUixvQkFBUUEsTUFGMkI7QUFHbkNTLG1CQUFPUixjQUFjUyxJQUhjO0FBSW5DQywwQkFBY1YsY0FBY1UsWUFKTztBQUtuQ0Msa0JBQU1YLGNBQWNXO0FBTGUsU0FBdkIsQ0FBaEI7O0FBUUFoQix1QkFBZWlCLEdBQWYsQ0FBbUJQLE9BQW5CO0FBQ0gsS0FmRDs7QUFpQkE7QUFDQVYsbUJBQWVrQixPQUFmOztBQUVBO0FBQ0E7QUFDQWxCLG1CQUFlbUIsRUFBZixDQUFrQixPQUFsQixFQUEyQixlQUFPO0FBQUUsY0FBTSxJQUFJQyxLQUFKLENBQVVDLEdBQVYsQ0FBTjtBQUF1QixLQUEzRDs7QUFFQSxXQUFPckIsY0FBUDtBQUNIOztBQUVEOzs7Ozs7Ozs7OztBQVdBO0FBQ0FzQixPQUFPQyxPQUFQLEdBQWlCLEVBQUUzQiwwQkFBRixFQUFqQiIsImZpbGUiOiI5MS5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuXHJcbi8qKlxyXG4gKiBNYWtlIGJhc2VtYXAgZ2FsbGVyeSBiYXNlZCBvbiB0aGUgc2V0dGluZ3Mgb2YgYmFzZW1hcCBtZXRhZGF0YS5cclxuICpcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBlc3JpQnVuZGxlIEVTUkkgbW9kdWxlcyBmcm9tIHRoZSBpbml0aWFsIHN0YXJ0dXBcclxuICogQHBhcmFtIHtBcnJheX0gYmFzZW1hcHNDb25maWcgYXJyYXkgb2YgYmFzZW1hcCBzZXR0aW5ncyBpbiB0aGUgZm9ybSB7IGlkOiBzdHJpbmcsIGxheWVyczogW3N0cmluZ10sIHRpdGxlOiBzdHJpbmcsIHRodW1ibmFpbFVybDogc3RyaW5nLCB3a2lkOiBpbnRlZ2VyIH1cclxuICogQHBhcmFtIHtlc3JpTWFwfSBtYXAgRVNSSSBtYXAgb2JqZWN0XHJcbiAqIEByZXR1cm4ge09iamVjdH0gYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxyXG4gKiA8dWw+XHJcbiAqICAgPGxpPnNldEJhc2VtYXAge2Z1bmN0aW9ufSBzZXQgY3VycmVudCBiYXNlbWFwIHdpdGggYSBiYXNlbWFwIHVpZDwvbGk+XHJcbiAqICAgPGxpPmJhc2VtYXBHYWxsZXJ5IHtvYmplY3R9IGJhc2VtYXBHYWxsZXJ5IG9iamVjdDwvbGk+XHJcbiAqIDwvdWw+XHJcbiAqL1xyXG5mdW5jdGlvbiBpbml0QmFzZW1hcHMoZXNyaUJ1bmRsZSwgYmFzZW1hcHNDb25maWcsIG1hcCkge1xyXG5cclxuICAgIGNvbnN0IGJhc2VtYXBHYWxsZXJ5ID0gbmV3IGVzcmlCdW5kbGUuQmFzZW1hcEdhbGxlcnkoeyBzaG93QXJjR0lTQmFzZW1hcHM6IGZhbHNlLCBtYXAgfSk7XHJcblxyXG4gICAgLy8gaXRlcmF0ZSB0aHJvdWggYmFzZW1hcCBjb25maWdzXHJcbiAgICBiYXNlbWFwc0NvbmZpZy5mb3JFYWNoKGJhc2VtYXBDb25maWcgPT4ge1xyXG5cclxuICAgICAgICAvLyBjcmVhdGUgYmFzZW1hcCwgYWRkIHRvIGJhc2VtYXAgZ2FsbGVyeVxyXG4gICAgICAgIGNvbnN0IGxheWVycyA9IGJhc2VtYXBDb25maWcubGF5ZXJzLm1hcChjb25maWcgPT5cclxuICAgICAgICAgICAgbmV3IGVzcmlCdW5kbGUuQmFzZW1hcExheWVyKHsgdXJsOiBjb25maWcudXJsLCBvcGFjaXR5OiBiYXNlbWFwQ29uZmlnLm9wYWNpdHkgfSkpO1xyXG5cclxuICAgICAgICBjb25zdCBiYXNlbWFwID0gbmV3IGVzcmlCdW5kbGUuQmFzZW1hcCh7XHJcbiAgICAgICAgICAgIGlkOiBiYXNlbWFwQ29uZmlnLmlkLFxyXG4gICAgICAgICAgICBsYXllcnM6IGxheWVycyxcclxuICAgICAgICAgICAgdGl0bGU6IGJhc2VtYXBDb25maWcubmFtZSxcclxuICAgICAgICAgICAgdGh1bWJuYWlsVXJsOiBiYXNlbWFwQ29uZmlnLnRodW1ibmFpbFVybCxcclxuICAgICAgICAgICAgd2tpZDogYmFzZW1hcENvbmZpZy53a2lkXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGJhc2VtYXBHYWxsZXJ5LmFkZChiYXNlbWFwKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIGZpbmFsaXplIGJhc21hcCBnYWxsZXJ5XHJcbiAgICBiYXNlbWFwR2FsbGVyeS5zdGFydHVwKCk7XHJcblxyXG4gICAgLy8gZGlzcGxheSBtZXNzYWdlXHJcbiAgICAvLyBUT0RPOiBhZGQgdWkgaG9vaz8gdG8gZGlzcGxheSBtc2cgb24gc2NyZWVuXHJcbiAgICBiYXNlbWFwR2FsbGVyeS5vbignZXJyb3InLCBtc2cgPT4geyB0aHJvdyBuZXcgRXJyb3IobXNnKTsgfSk7XHJcblxyXG4gICAgcmV0dXJuIGJhc2VtYXBHYWxsZXJ5O1xyXG59XHJcblxyXG4vKipcclxuICAqXHJcbiAgKiBUaGUgYEJhc2VtYXBgIG1vZHVsZSBwcm92aWRlcyBiYXNlbWFwIHJlbGF0ZWQgZnVuY3Rpb25zLlxyXG4gICpcclxuICAqIFRoaXMgbW9kdWxlIGV4cG9ydHMgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzXHJcbiAgKiAtIGBCYXNlbWFwYCBlc3JpL2Rpaml0L0Jhc2VtYXAgY2xhc3NcclxuICAqIC0gYEJhc2VtYXBHYWxsZXJ5YCBlc3JpL2Rpaml0L0Jhc2VtYXBHYWxsZXJ5IGNsYXNzXHJcbiAgKiAtIGBCYXNlbWFwTGF5ZXJgIGVzcmkvZGlqaXQvQmFzZW1hcExheWVyIGNsYXNzXHJcbiAgKiAtIGBtYWtlQmFzZW1hcHNgIGZ1bmN0aW9uIHRoYXQgbWFrZXMgYSBiYXNlbWFwIGdhbGxlcnkgYmFzZWQgb24gdGhlIHNldHRpbmdzIHByb3ZpZGVkXHJcbiAgKi9cclxuXHJcbi8vIEJhc2VtYXAgcmVsYXRlZCBtb2R1bGVzXHJcbm1vZHVsZS5leHBvcnRzID0geyBpbml0QmFzZW1hcHMgfTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL21hcC9iYXNlbWFwLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){"use strict";eval("\n\n// ugly way to add rgbcolor to global scope so it can be used by canvg inside the viewer; this is done because canvg uses UMD loader and has rgbcolor as internal dependency; there is no elegant way around it; another approach would be to clone canvg and change its loader;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nwindow.RGBColor = __webpack_require__(68);\nvar canvg = __webpack_require__(93);\nvar shared = __webpack_require__(23)();\n\nvar XML_ATTRIBUTES = {\n    xmlns: 'http://www.w3.org/2000/svg',\n    'xmlns:xlink': 'http://www.w3.org/1999/xlink',\n    version: '1.1'\n};\n\n/**\r\n  * The `mapPrint` module provides map print and export image related functions.\r\n  *\r\n  * This module exports an object with the following functions\r\n  * - `printMap`\r\n  *\r\n  * NOTE: unit tests might be difficult to implement as DOM is required...\r\n  */\n\n/**\r\n* Generate the image from the esri print task\r\n*\r\n* @param {Object} esriBundle bundle of API classes\r\n* @param {Object} map esri map object\r\n* @param {Object} options options for the print task\r\n*                           url - for the esri geometry server\r\n*                           format - output format\r\n*                           width - target image height if different from default\r\n*                           height - target image width if different from default\r\n* @return {Promise} resolving when the print task created the image\r\n*                           resolve with a \"response: { url: value }\" where url is the path\r\n*                           for the print task export image\r\n*/\nfunction generateServerImage(esriBundle, map, options) {\n    // create esri print object with url to print server\n    var printTask = esriBundle.PrintTask(options.url, { async: true });\n    var printParams = new esriBundle.PrintParameters();\n    var printTemplate = new esriBundle.PrintTemplate();\n\n    // each layout has an mxd with that name on the server. We can modify and add new layout (mxd)\n    // we only support MAP_ONLY for now. See https://github.com/fgpv-vpgf/fgpv-vpgf/issues/1160\n    printTemplate.layout = 'MAP_ONLY';\n\n    // only use when layout is MAP_ONLY\n    printTemplate.exportOptions = {\n        height: options.height || map.height,\n        width: options.width || map.width,\n        dpi: 96\n    };\n\n    // pdf | png32 | png8 | jpg | gif | eps | svg | svgz\n    printTemplate.format = options.format;\n    printTemplate.showAttribution = false;\n\n    // define whether the printed map should preserve map scale or map extent.\n    // if true, the printed map will use the outScale property or default to the scale of the input map.\n    // if false, the printed map will use the same extent as the input map and thus scale might change.\n    // we always use false because the output image needs to be of the same extent as the size might be different\n    // we fit the image later because trying to fit the image with canvg when we add user added\n    // layer is tricky!\n    printTemplate.preserveScale = false;\n\n    // set map and template\n    printParams.map = map;\n    printParams.template = printTemplate;\n\n    // need to hide svg layers since we can generate an image for them locally\n    var svgLayers = hideLayers(map);\n\n    var printPromise = new Promise(function (resolve, reject) {\n        // can be use to debug print task. Gives parameters to call directly the print task from it's interface\n        // http://resources.arcgis.com/en/help/rest/apiref/exportwebmap_spec.html\n        // http://snipplr.com/view/72400/sample-json-representation-of-an-esri-web-map-for-export-web-map-task\n        // const mapJSON = printTask._getPrintDefinition(map, printParams);\n        // console.log(JSON.stringify(mapJSON));\n\n        // TODO: catch esriJobFailed. it does not trigger the complete or the error event. Need a way to catch it!\n        // execute the print task\n        printTask.execute(printParams, function (response) {\n            return resolve(shared.convertImageToCanvas(response.url));\n        }, function (error) {\n            return reject(error);\n        });\n    });\n\n    // show user added previously visible for canvg to create canvas\n    showLayers(svgLayers);\n\n    return printPromise;\n}\n\n/**\r\n* Set svg-based layer visibility to false to avoid CORS error\r\n*\r\n* @param {Object} map esri map object\r\n* @return {Array} layer array of layers where visibility is true\r\n*/\nfunction hideLayers(map) {\n    return map.graphicsLayerIds.map(function (layerId) {\n        return map.getLayer(layerId);\n    }).filter(function (layer) {\n        return layer.visible;\n    }).map(function (layer) {\n        layer.setVisibility(false);\n        return layer;\n    });\n}\n\n/**\r\n* Set user added layer visibility to true for those whoe where visible\r\n*\r\n* @param {Array} layers array of graphic layers to set visibility to true\r\n*/\nfunction showLayers(layers) {\n    layers.forEach(function (layer) {\n        return layer.setVisibility(true);\n    });\n}\n\n/**\r\n* Create a canvas from the user added layers (svg tag)\r\n*\r\n* @param {Object} map esri map object\r\n* @param {Object} options [optional = null] { width, height } values; needed to get canvas of a size different from default\r\n*                           width {Number}\r\n*                           height {Number}\r\n* @param {Object} canvas [optional = null] canvas to draw the image upon; if not supplied, a new canvas will be made\r\n* @return {Promise} resolving when the canvas have been created\r\n*                           resolve with a canvas element with user added layer on it\r\n*/\nfunction generateLocalCanvas(map) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var canvas = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n    canvas = canvas || document.createElement('canvas'); // create canvas element\n\n    // find esri map's svg node\n    // check if xmlns prefixes are set - they aren't; add them\n    // without correct prefixes, Firefox and IE refuse to render svg onto the canvas; Chrome works;\n    // related issues: fgpv-vpgf/fgpv-vpgf#1324, fgpv-vpgf/fgpv-vpgf#1307, fgpv-vpgf/fgpv-vpgf#1306\n    var svgNode = document.getElementById('esri.Map_' + map.id.split('_')[1] + '_gc');\n    if (!svgNode.getAttribute('xmlns')) {\n        Object.entries(XML_ATTRIBUTES).forEach(function (_ref) {\n            var _ref2 = _slicedToArray(_ref, 2),\n                key = _ref2[0],\n                value = _ref2[1];\n\n            return svgNode.setAttribute(key, value);\n        });\n    }\n\n    var originalOptions = void 0;\n    if (options) {\n        originalOptions = resizeSVGElement(svgNode, options);\n    }\n\n    var generationPromise = new Promise(function (resolve, reject) {\n        // parse the svg\n        // convert svg text to canvas and stuff it into canvas canvas dom node\n\n        // wrapping in try/catch since canvg has NO error handling; not sure what errors this can catch though\n        try {\n            // convert svg to text (use map id to select the svg container), then render svgxml back to canvas\n            canvg(canvas, svgNode.outerHTML, {\n                useCORS: true,\n                ignoreAnimation: true,\n                ignoreMouse: true,\n                renderCallback: function renderCallback() {\n                    if (options) {\n                        resizeSVGElement(svgNode, originalOptions.originalSize, originalOptions.originalViewbox);\n                    }\n\n                    resolve(canvas);\n                }\n            });\n        } catch (error) {\n            reject(error);\n        }\n    });\n\n    return generationPromise;\n\n    /**\r\n     * Scales up or down the specified svg element. To scale it, we need to set the viewbox to the current size and change the size of the element itself.\r\n     * @function resizeSVGElement\r\n     * @private\r\n     * @param {Object} element target svg element to be resized\r\n     * @param {Object} targetSize object with target sizes in the form of { width, height }\r\n     *                           width {Number}\r\n     *                           height {Number}\r\n     * @param {Object} targetViewbox [optional = null] target viewbox sizes in the form of { minX, minY, width, height }; if not specified, the original size will be used as the viewbox\r\n     *                           minX {Number}\r\n     *                           minxY {Number}\r\n     *                           width {Number}\r\n     *                           height {Number}\r\n     * @return {Object} returns original size and viewbox of the svg element in the form of { originalSize: { width, height }, originalViewbox: { minX, minY, width, height } }; can be used to restore the element to its original state\r\n     *                          originalSize:\r\n     *                              width {Number}\r\n     *                              height {Number}\r\n     *                          originalViewbox:\r\n     *                              minX {Number}\r\n     *                              minxY {Number}\r\n     *                              width {Number}\r\n     *                              height {Number}\r\n     */\n    function resizeSVGElement(element, targetSize) {\n        var targetViewbox = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n\n        var originalSize = {\n            width: element.width.baseVal.value,\n            height: element.height.baseVal.value\n        };\n\n        // get the current viewbox sizes\n        // if the viewbox is not defined, the viewbox is assumed to have the same dimensions as the svg element\n        // getAttribute('viewBox') returns a string in the form '{minx} {miny} {width} {height}'\n        // setAttribute('viewBox') accepts a string in the same form\n\n        var _split = (element.getAttribute('viewBox') || '0 0 ' + originalSize.width + ' ' + originalSize.height).split(' '),\n            _split2 = _slicedToArray(_split, 4),\n            ovMinX = _split2[0],\n            ovMinY = _split2[1],\n            ovWidth = _split2[2],\n            ovHeight = _split2[3];\n\n        var originalViewbox = {\n            minX: ovMinX,\n            minY: ovMinY,\n            width: ovWidth,\n            height: ovHeight\n        };\n\n        // set the width/height of the svg element to the target values\n        element.setAttribute('width', targetSize.width);\n        element.setAttribute('height', targetSize.height);\n\n        // set the viewbox width/height of the svg element to the target values; or the values of the original viewbox (if the viewbox wasn't defined before, it is now)\n        element.setAttribute('viewBox', [(targetViewbox || originalViewbox).minX, (targetViewbox || originalViewbox).minY, (targetViewbox || originalViewbox).width, (targetViewbox || originalViewbox).height].join(' '));\n\n        return {\n            originalSize: originalSize,\n            originalViewbox: originalViewbox\n        };\n    }\n}\n\n// Print map related modules\nmodule.exports = function (esriBundle) {\n    return {\n        printLocal: function printLocal(map, options) {\n            return generateLocalCanvas(map, options);\n        },\n        printServer: function printServer(map, options) {\n            return generateServerImage(esriBundle, map, options);\n        }\n    };\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbWFwL3ByaW50LmpzPzI2NGYiXSwibmFtZXMiOlsid2luZG93IiwiUkdCQ29sb3IiLCJyZXF1aXJlIiwiY2FudmciLCJzaGFyZWQiLCJYTUxfQVRUUklCVVRFUyIsInhtbG5zIiwidmVyc2lvbiIsImdlbmVyYXRlU2VydmVySW1hZ2UiLCJlc3JpQnVuZGxlIiwibWFwIiwib3B0aW9ucyIsInByaW50VGFzayIsIlByaW50VGFzayIsInVybCIsImFzeW5jIiwicHJpbnRQYXJhbXMiLCJQcmludFBhcmFtZXRlcnMiLCJwcmludFRlbXBsYXRlIiwiUHJpbnRUZW1wbGF0ZSIsImxheW91dCIsImV4cG9ydE9wdGlvbnMiLCJoZWlnaHQiLCJ3aWR0aCIsImRwaSIsImZvcm1hdCIsInNob3dBdHRyaWJ1dGlvbiIsInByZXNlcnZlU2NhbGUiLCJ0ZW1wbGF0ZSIsInN2Z0xheWVycyIsImhpZGVMYXllcnMiLCJwcmludFByb21pc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImV4ZWN1dGUiLCJjb252ZXJ0SW1hZ2VUb0NhbnZhcyIsInJlc3BvbnNlIiwiZXJyb3IiLCJzaG93TGF5ZXJzIiwiZ3JhcGhpY3NMYXllcklkcyIsImdldExheWVyIiwibGF5ZXJJZCIsImZpbHRlciIsImxheWVyIiwidmlzaWJsZSIsInNldFZpc2liaWxpdHkiLCJsYXllcnMiLCJmb3JFYWNoIiwiZ2VuZXJhdGVMb2NhbENhbnZhcyIsImNhbnZhcyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsInN2Z05vZGUiLCJnZXRFbGVtZW50QnlJZCIsImlkIiwic3BsaXQiLCJnZXRBdHRyaWJ1dGUiLCJPYmplY3QiLCJlbnRyaWVzIiwia2V5IiwidmFsdWUiLCJzZXRBdHRyaWJ1dGUiLCJvcmlnaW5hbE9wdGlvbnMiLCJyZXNpemVTVkdFbGVtZW50IiwiZ2VuZXJhdGlvblByb21pc2UiLCJvdXRlckhUTUwiLCJ1c2VDT1JTIiwiaWdub3JlQW5pbWF0aW9uIiwiaWdub3JlTW91c2UiLCJyZW5kZXJDYWxsYmFjayIsIm9yaWdpbmFsU2l6ZSIsIm9yaWdpbmFsVmlld2JveCIsImVsZW1lbnQiLCJ0YXJnZXRTaXplIiwidGFyZ2V0Vmlld2JveCIsImJhc2VWYWwiLCJvdk1pblgiLCJvdk1pblkiLCJvdldpZHRoIiwib3ZIZWlnaHQiLCJtaW5YIiwibWluWSIsImpvaW4iLCJtb2R1bGUiLCJleHBvcnRzIiwicHJpbnRMb2NhbCIsInByaW50U2VydmVyIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTs7OztBQUNBQSxPQUFPQyxRQUFQLEdBQWtCLG1CQUFBQyxDQUFRLEVBQVIsQ0FBbEI7QUFDQSxJQUFNQyxRQUFRLG1CQUFBRCxDQUFRLEVBQVIsQ0FBZDtBQUNBLElBQU1FLFNBQVMsbUJBQUFGLENBQVEsRUFBUixHQUFmOztBQUVBLElBQU1HLGlCQUFpQjtBQUNuQkMsV0FBTyw0QkFEWTtBQUVuQixtQkFBZSw4QkFGSTtBQUduQkMsYUFBUztBQUhVLENBQXZCOztBQU1BOzs7Ozs7Ozs7QUFTQTs7Ozs7Ozs7Ozs7Ozs7QUFjQSxTQUFTQyxtQkFBVCxDQUE2QkMsVUFBN0IsRUFBeUNDLEdBQXpDLEVBQThDQyxPQUE5QyxFQUF1RDtBQUNuRDtBQUNBLFFBQU1DLFlBQVlILFdBQVdJLFNBQVgsQ0FBcUJGLFFBQVFHLEdBQTdCLEVBQWtDLEVBQUVDLE9BQU8sSUFBVCxFQUFsQyxDQUFsQjtBQUNBLFFBQU1DLGNBQWMsSUFBSVAsV0FBV1EsZUFBZixFQUFwQjtBQUNBLFFBQU1DLGdCQUFnQixJQUFJVCxXQUFXVSxhQUFmLEVBQXRCOztBQUVBO0FBQ0E7QUFDQUQsa0JBQWNFLE1BQWQsR0FBdUIsVUFBdkI7O0FBRUE7QUFDQUYsa0JBQWNHLGFBQWQsR0FBOEI7QUFDMUJDLGdCQUFRWCxRQUFRVyxNQUFSLElBQWtCWixJQUFJWSxNQURKO0FBRTFCQyxlQUFPWixRQUFRWSxLQUFSLElBQWlCYixJQUFJYSxLQUZGO0FBRzFCQyxhQUFLO0FBSHFCLEtBQTlCOztBQU1BO0FBQ0FOLGtCQUFjTyxNQUFkLEdBQXVCZCxRQUFRYyxNQUEvQjtBQUNBUCxrQkFBY1EsZUFBZCxHQUFnQyxLQUFoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQVIsa0JBQWNTLGFBQWQsR0FBOEIsS0FBOUI7O0FBRUE7QUFDQVgsZ0JBQVlOLEdBQVosR0FBa0JBLEdBQWxCO0FBQ0FNLGdCQUFZWSxRQUFaLEdBQXVCVixhQUF2Qjs7QUFFQTtBQUNBLFFBQU1XLFlBQVlDLFdBQVdwQixHQUFYLENBQWxCOztBQUVBLFFBQU1xQixlQUFlLElBQUlDLE9BQUosQ0FBWSxVQUFDQyxPQUFELEVBQVVDLE1BQVYsRUFBcUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0F0QixrQkFBVXVCLE9BQVYsQ0FBa0JuQixXQUFsQixFQUNJO0FBQUEsbUJBQ0lpQixRQUFRN0IsT0FBT2dDLG9CQUFQLENBQTRCQyxTQUFTdkIsR0FBckMsQ0FBUixDQURKO0FBQUEsU0FESixFQUdJO0FBQUEsbUJBQ0lvQixPQUFPSSxLQUFQLENBREo7QUFBQSxTQUhKO0FBTUgsS0Fmb0IsQ0FBckI7O0FBaUJBO0FBQ0FDLGVBQVdWLFNBQVg7O0FBRUEsV0FBT0UsWUFBUDtBQUNIOztBQUVEOzs7Ozs7QUFNQSxTQUFTRCxVQUFULENBQW9CcEIsR0FBcEIsRUFBeUI7QUFDckIsV0FBT0EsSUFBSThCLGdCQUFKLENBQ0Y5QixHQURFLENBQ0U7QUFBQSxlQUFXQSxJQUFJK0IsUUFBSixDQUFhQyxPQUFiLENBQVg7QUFBQSxLQURGLEVBRUZDLE1BRkUsQ0FFSztBQUFBLGVBQVNDLE1BQU1DLE9BQWY7QUFBQSxLQUZMLEVBR0ZuQyxHQUhFLENBR0UsaUJBQVM7QUFDVmtDLGNBQU1FLGFBQU4sQ0FBb0IsS0FBcEI7QUFDQSxlQUFPRixLQUFQO0FBQ0gsS0FORSxDQUFQO0FBT0g7O0FBRUQ7Ozs7O0FBS0EsU0FBU0wsVUFBVCxDQUFvQlEsTUFBcEIsRUFBNEI7QUFDeEJBLFdBQU9DLE9BQVAsQ0FBZSxVQUFDSixLQUFEO0FBQUEsZUFBV0EsTUFBTUUsYUFBTixDQUFvQixJQUFwQixDQUFYO0FBQUEsS0FBZjtBQUNIOztBQUVEOzs7Ozs7Ozs7OztBQVdBLFNBQVNHLG1CQUFULENBQTZCdkMsR0FBN0IsRUFBaUU7QUFBQSxRQUEvQkMsT0FBK0IsdUVBQXJCLElBQXFCO0FBQUEsUUFBZnVDLE1BQWUsdUVBQU4sSUFBTTs7QUFDN0RBLGFBQVNBLFVBQVVDLFNBQVNDLGFBQVQsQ0FBdUIsUUFBdkIsQ0FBbkIsQ0FENkQsQ0FDUDs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFNQyxVQUFVRixTQUFTRyxjQUFULGVBQXFDNUMsSUFBSTZDLEVBQUosQ0FBT0MsS0FBUCxDQUFhLEdBQWIsRUFBa0IsQ0FBbEIsQ0FBckMsU0FBaEI7QUFDQSxRQUFJLENBQUNILFFBQVFJLFlBQVIsQ0FBcUIsT0FBckIsQ0FBTCxFQUFvQztBQUNoQ0MsZUFBT0MsT0FBUCxDQUFldEQsY0FBZixFQUErQjJDLE9BQS9CLENBQXVDO0FBQUE7QUFBQSxnQkFBRVksR0FBRjtBQUFBLGdCQUFPQyxLQUFQOztBQUFBLG1CQUNuQ1IsUUFBUVMsWUFBUixDQUFxQkYsR0FBckIsRUFBMEJDLEtBQTFCLENBRG1DO0FBQUEsU0FBdkM7QUFFSDs7QUFFRCxRQUFJRSx3QkFBSjtBQUNBLFFBQUlwRCxPQUFKLEVBQWE7QUFDVG9ELDBCQUFrQkMsaUJBQWlCWCxPQUFqQixFQUEwQjFDLE9BQTFCLENBQWxCO0FBQ0g7O0FBRUQsUUFBTXNELG9CQUFvQixJQUFJakMsT0FBSixDQUFZLFVBQUNDLE9BQUQsRUFBVUMsTUFBVixFQUFxQjtBQUN2RDtBQUNBOztBQUVBO0FBQ0EsWUFBSTtBQUNBO0FBQ0EvQixrQkFBTStDLE1BQU4sRUFBY0csUUFBUWEsU0FBdEIsRUFBaUM7QUFDN0JDLHlCQUFTLElBRG9CO0FBRTdCQyxpQ0FBaUIsSUFGWTtBQUc3QkMsNkJBQWEsSUFIZ0I7QUFJN0JDLGdDQUFnQiwwQkFBTTtBQUNsQix3QkFBSTNELE9BQUosRUFBYTtBQUNUcUQseUNBQWlCWCxPQUFqQixFQUEwQlUsZ0JBQWdCUSxZQUExQyxFQUF3RFIsZ0JBQWdCUyxlQUF4RTtBQUNIOztBQUVEdkMsNEJBQVFpQixNQUFSO0FBQ0g7QUFWNEIsYUFBakM7QUFZSCxTQWRELENBY0UsT0FBT1osS0FBUCxFQUFjO0FBQ1pKLG1CQUFPSSxLQUFQO0FBQ0g7QUFDSixLQXRCeUIsQ0FBMUI7O0FBd0JBLFdBQU8yQixpQkFBUDs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1QkEsYUFBU0QsZ0JBQVQsQ0FBMEJTLE9BQTFCLEVBQW1DQyxVQUFuQyxFQUFxRTtBQUFBLFlBQXRCQyxhQUFzQix1RUFBTixJQUFNOzs7QUFFakUsWUFBTUosZUFBZTtBQUNqQmhELG1CQUFPa0QsUUFBUWxELEtBQVIsQ0FBY3FELE9BQWQsQ0FBc0JmLEtBRFo7QUFFakJ2QyxvQkFBUW1ELFFBQVFuRCxNQUFSLENBQWVzRCxPQUFmLENBQXVCZjtBQUZkLFNBQXJCOztBQUtBO0FBQ0E7QUFDQTtBQUNBOztBQVZpRSxxQkFZN0QsQ0FBQ1ksUUFBUWhCLFlBQVIsQ0FBcUIsU0FBckIsY0FBMENjLGFBQWFoRCxLQUF2RCxTQUFnRWdELGFBQWFqRCxNQUE5RSxFQUF3RmtDLEtBQXhGLENBQThGLEdBQTlGLENBWjZEO0FBQUE7QUFBQSxZQVcxRHFCLE1BWDBEO0FBQUEsWUFXbERDLE1BWGtEO0FBQUEsWUFXMUNDLE9BWDBDO0FBQUEsWUFXakNDLFFBWGlDOztBQWNqRSxZQUFNUixrQkFBa0I7QUFDcEJTLGtCQUFNSixNQURjO0FBRXBCSyxrQkFBTUosTUFGYztBQUdwQnZELG1CQUFPd0QsT0FIYTtBQUlwQnpELG9CQUFRMEQ7QUFKWSxTQUF4Qjs7QUFPQTtBQUNBUCxnQkFBUVgsWUFBUixDQUFxQixPQUFyQixFQUE4QlksV0FBV25ELEtBQXpDO0FBQ0FrRCxnQkFBUVgsWUFBUixDQUFxQixRQUFyQixFQUErQlksV0FBV3BELE1BQTFDOztBQUVBO0FBQ0FtRCxnQkFBUVgsWUFBUixDQUFxQixTQUFyQixFQUFnQyxDQUM1QixDQUFDYSxpQkFBaUJILGVBQWxCLEVBQW1DUyxJQURQLEVBRTVCLENBQUNOLGlCQUFpQkgsZUFBbEIsRUFBbUNVLElBRlAsRUFHNUIsQ0FBQ1AsaUJBQWlCSCxlQUFsQixFQUFtQ2pELEtBSFAsRUFJNUIsQ0FBQ29ELGlCQUFpQkgsZUFBbEIsRUFBbUNsRCxNQUpQLEVBSzlCNkQsSUFMOEIsQ0FLekIsR0FMeUIsQ0FBaEM7O0FBT0EsZUFBTztBQUNIWixzQ0FERztBQUVIQztBQUZHLFNBQVA7QUFJSDtBQUNKOztBQUVEO0FBQ0FZLE9BQU9DLE9BQVAsR0FBaUIsVUFBQzVFLFVBQUQsRUFBZ0I7QUFDN0IsV0FBTztBQUNINkUsb0JBQVksb0JBQUM1RSxHQUFELEVBQU1DLE9BQU47QUFBQSxtQkFBa0JzQyxvQkFBb0J2QyxHQUFwQixFQUF5QkMsT0FBekIsQ0FBbEI7QUFBQSxTQURUO0FBRUg0RSxxQkFBYSxxQkFBQzdFLEdBQUQsRUFBTUMsT0FBTjtBQUFBLG1CQUFrQkgsb0JBQW9CQyxVQUFwQixFQUFnQ0MsR0FBaEMsRUFBcUNDLE9BQXJDLENBQWxCO0FBQUE7QUFGVixLQUFQO0FBSUgsQ0FMRCIsImZpbGUiOiI5Mi5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuXHJcbi8vIHVnbHkgd2F5IHRvIGFkZCByZ2Jjb2xvciB0byBnbG9iYWwgc2NvcGUgc28gaXQgY2FuIGJlIHVzZWQgYnkgY2FudmcgaW5zaWRlIHRoZSB2aWV3ZXI7IHRoaXMgaXMgZG9uZSBiZWNhdXNlIGNhbnZnIHVzZXMgVU1EIGxvYWRlciBhbmQgaGFzIHJnYmNvbG9yIGFzIGludGVybmFsIGRlcGVuZGVuY3k7IHRoZXJlIGlzIG5vIGVsZWdhbnQgd2F5IGFyb3VuZCBpdDsgYW5vdGhlciBhcHByb2FjaCB3b3VsZCBiZSB0byBjbG9uZSBjYW52ZyBhbmQgY2hhbmdlIGl0cyBsb2FkZXI7XHJcbndpbmRvdy5SR0JDb2xvciA9IHJlcXVpcmUoJ3JnYmNvbG9yJyk7XHJcbmNvbnN0IGNhbnZnID0gcmVxdWlyZSgnY2Fudmctb3JpZ2luJyk7XHJcbmNvbnN0IHNoYXJlZCA9IHJlcXVpcmUoJy4uL3NoYXJlZC5qcycpKCk7XHJcblxyXG5jb25zdCBYTUxfQVRUUklCVVRFUyA9IHtcclxuICAgIHhtbG5zOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxyXG4gICAgJ3htbG5zOnhsaW5rJzogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLFxyXG4gICAgdmVyc2lvbjogJzEuMSdcclxufTtcclxuXHJcbi8qKlxyXG4gICogVGhlIGBtYXBQcmludGAgbW9kdWxlIHByb3ZpZGVzIG1hcCBwcmludCBhbmQgZXhwb3J0IGltYWdlIHJlbGF0ZWQgZnVuY3Rpb25zLlxyXG4gICpcclxuICAqIFRoaXMgbW9kdWxlIGV4cG9ydHMgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBmdW5jdGlvbnNcclxuICAqIC0gYHByaW50TWFwYFxyXG4gICpcclxuICAqIE5PVEU6IHVuaXQgdGVzdHMgbWlnaHQgYmUgZGlmZmljdWx0IHRvIGltcGxlbWVudCBhcyBET00gaXMgcmVxdWlyZWQuLi5cclxuICAqL1xyXG5cclxuLyoqXHJcbiogR2VuZXJhdGUgdGhlIGltYWdlIGZyb20gdGhlIGVzcmkgcHJpbnQgdGFza1xyXG4qXHJcbiogQHBhcmFtIHtPYmplY3R9IGVzcmlCdW5kbGUgYnVuZGxlIG9mIEFQSSBjbGFzc2VzXHJcbiogQHBhcmFtIHtPYmplY3R9IG1hcCBlc3JpIG1hcCBvYmplY3RcclxuKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBvcHRpb25zIGZvciB0aGUgcHJpbnQgdGFza1xyXG4qICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsIC0gZm9yIHRoZSBlc3JpIGdlb21ldHJ5IHNlcnZlclxyXG4qICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0IC0gb3V0cHV0IGZvcm1hdFxyXG4qICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggLSB0YXJnZXQgaW1hZ2UgaGVpZ2h0IGlmIGRpZmZlcmVudCBmcm9tIGRlZmF1bHRcclxuKiAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCAtIHRhcmdldCBpbWFnZSB3aWR0aCBpZiBkaWZmZXJlbnQgZnJvbSBkZWZhdWx0XHJcbiogQHJldHVybiB7UHJvbWlzZX0gcmVzb2x2aW5nIHdoZW4gdGhlIHByaW50IHRhc2sgY3JlYXRlZCB0aGUgaW1hZ2VcclxuKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUgd2l0aCBhIFwicmVzcG9uc2U6IHsgdXJsOiB2YWx1ZSB9XCIgd2hlcmUgdXJsIGlzIHRoZSBwYXRoXHJcbiogICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgdGhlIHByaW50IHRhc2sgZXhwb3J0IGltYWdlXHJcbiovXHJcbmZ1bmN0aW9uIGdlbmVyYXRlU2VydmVySW1hZ2UoZXNyaUJ1bmRsZSwgbWFwLCBvcHRpb25zKSB7XHJcbiAgICAvLyBjcmVhdGUgZXNyaSBwcmludCBvYmplY3Qgd2l0aCB1cmwgdG8gcHJpbnQgc2VydmVyXHJcbiAgICBjb25zdCBwcmludFRhc2sgPSBlc3JpQnVuZGxlLlByaW50VGFzayhvcHRpb25zLnVybCwgeyBhc3luYzogdHJ1ZSB9KTtcclxuICAgIGNvbnN0IHByaW50UGFyYW1zID0gbmV3IGVzcmlCdW5kbGUuUHJpbnRQYXJhbWV0ZXJzKCk7XHJcbiAgICBjb25zdCBwcmludFRlbXBsYXRlID0gbmV3IGVzcmlCdW5kbGUuUHJpbnRUZW1wbGF0ZSgpO1xyXG5cclxuICAgIC8vIGVhY2ggbGF5b3V0IGhhcyBhbiBteGQgd2l0aCB0aGF0IG5hbWUgb24gdGhlIHNlcnZlci4gV2UgY2FuIG1vZGlmeSBhbmQgYWRkIG5ldyBsYXlvdXQgKG14ZClcclxuICAgIC8vIHdlIG9ubHkgc3VwcG9ydCBNQVBfT05MWSBmb3Igbm93LiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZncHYtdnBnZi9mZ3B2LXZwZ2YvaXNzdWVzLzExNjBcclxuICAgIHByaW50VGVtcGxhdGUubGF5b3V0ID0gJ01BUF9PTkxZJztcclxuXHJcbiAgICAvLyBvbmx5IHVzZSB3aGVuIGxheW91dCBpcyBNQVBfT05MWVxyXG4gICAgcHJpbnRUZW1wbGF0ZS5leHBvcnRPcHRpb25zID0ge1xyXG4gICAgICAgIGhlaWdodDogb3B0aW9ucy5oZWlnaHQgfHwgbWFwLmhlaWdodCxcclxuICAgICAgICB3aWR0aDogb3B0aW9ucy53aWR0aCB8fCBtYXAud2lkdGgsXHJcbiAgICAgICAgZHBpOiA5NlxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBwZGYgfCBwbmczMiB8IHBuZzggfCBqcGcgfCBnaWYgfCBlcHMgfCBzdmcgfCBzdmd6XHJcbiAgICBwcmludFRlbXBsYXRlLmZvcm1hdCA9IG9wdGlvbnMuZm9ybWF0O1xyXG4gICAgcHJpbnRUZW1wbGF0ZS5zaG93QXR0cmlidXRpb24gPSBmYWxzZTtcclxuXHJcbiAgICAvLyBkZWZpbmUgd2hldGhlciB0aGUgcHJpbnRlZCBtYXAgc2hvdWxkIHByZXNlcnZlIG1hcCBzY2FsZSBvciBtYXAgZXh0ZW50LlxyXG4gICAgLy8gaWYgdHJ1ZSwgdGhlIHByaW50ZWQgbWFwIHdpbGwgdXNlIHRoZSBvdXRTY2FsZSBwcm9wZXJ0eSBvciBkZWZhdWx0IHRvIHRoZSBzY2FsZSBvZiB0aGUgaW5wdXQgbWFwLlxyXG4gICAgLy8gaWYgZmFsc2UsIHRoZSBwcmludGVkIG1hcCB3aWxsIHVzZSB0aGUgc2FtZSBleHRlbnQgYXMgdGhlIGlucHV0IG1hcCBhbmQgdGh1cyBzY2FsZSBtaWdodCBjaGFuZ2UuXHJcbiAgICAvLyB3ZSBhbHdheXMgdXNlIGZhbHNlIGJlY2F1c2UgdGhlIG91dHB1dCBpbWFnZSBuZWVkcyB0byBiZSBvZiB0aGUgc2FtZSBleHRlbnQgYXMgdGhlIHNpemUgbWlnaHQgYmUgZGlmZmVyZW50XHJcbiAgICAvLyB3ZSBmaXQgdGhlIGltYWdlIGxhdGVyIGJlY2F1c2UgdHJ5aW5nIHRvIGZpdCB0aGUgaW1hZ2Ugd2l0aCBjYW52ZyB3aGVuIHdlIGFkZCB1c2VyIGFkZGVkXHJcbiAgICAvLyBsYXllciBpcyB0cmlja3khXHJcbiAgICBwcmludFRlbXBsYXRlLnByZXNlcnZlU2NhbGUgPSBmYWxzZTtcclxuXHJcbiAgICAvLyBzZXQgbWFwIGFuZCB0ZW1wbGF0ZVxyXG4gICAgcHJpbnRQYXJhbXMubWFwID0gbWFwO1xyXG4gICAgcHJpbnRQYXJhbXMudGVtcGxhdGUgPSBwcmludFRlbXBsYXRlO1xyXG5cclxuICAgIC8vIG5lZWQgdG8gaGlkZSBzdmcgbGF5ZXJzIHNpbmNlIHdlIGNhbiBnZW5lcmF0ZSBhbiBpbWFnZSBmb3IgdGhlbSBsb2NhbGx5XHJcbiAgICBjb25zdCBzdmdMYXllcnMgPSBoaWRlTGF5ZXJzKG1hcCk7XHJcblxyXG4gICAgY29uc3QgcHJpbnRQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgIC8vIGNhbiBiZSB1c2UgdG8gZGVidWcgcHJpbnQgdGFzay4gR2l2ZXMgcGFyYW1ldGVycyB0byBjYWxsIGRpcmVjdGx5IHRoZSBwcmludCB0YXNrIGZyb20gaXQncyBpbnRlcmZhY2VcclxuICAgICAgICAvLyBodHRwOi8vcmVzb3VyY2VzLmFyY2dpcy5jb20vZW4vaGVscC9yZXN0L2FwaXJlZi9leHBvcnR3ZWJtYXBfc3BlYy5odG1sXHJcbiAgICAgICAgLy8gaHR0cDovL3NuaXBwbHIuY29tL3ZpZXcvNzI0MDAvc2FtcGxlLWpzb24tcmVwcmVzZW50YXRpb24tb2YtYW4tZXNyaS13ZWItbWFwLWZvci1leHBvcnQtd2ViLW1hcC10YXNrXHJcbiAgICAgICAgLy8gY29uc3QgbWFwSlNPTiA9IHByaW50VGFzay5fZ2V0UHJpbnREZWZpbml0aW9uKG1hcCwgcHJpbnRQYXJhbXMpO1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KG1hcEpTT04pKTtcclxuXHJcbiAgICAgICAgLy8gVE9ETzogY2F0Y2ggZXNyaUpvYkZhaWxlZC4gaXQgZG9lcyBub3QgdHJpZ2dlciB0aGUgY29tcGxldGUgb3IgdGhlIGVycm9yIGV2ZW50LiBOZWVkIGEgd2F5IHRvIGNhdGNoIGl0IVxyXG4gICAgICAgIC8vIGV4ZWN1dGUgdGhlIHByaW50IHRhc2tcclxuICAgICAgICBwcmludFRhc2suZXhlY3V0ZShwcmludFBhcmFtcyxcclxuICAgICAgICAgICAgcmVzcG9uc2UgPT5cclxuICAgICAgICAgICAgICAgIHJlc29sdmUoc2hhcmVkLmNvbnZlcnRJbWFnZVRvQ2FudmFzKHJlc3BvbnNlLnVybCkpLFxyXG4gICAgICAgICAgICBlcnJvciA9PlxyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKVxyXG4gICAgICAgICk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBzaG93IHVzZXIgYWRkZWQgcHJldmlvdXNseSB2aXNpYmxlIGZvciBjYW52ZyB0byBjcmVhdGUgY2FudmFzXHJcbiAgICBzaG93TGF5ZXJzKHN2Z0xheWVycyk7XHJcblxyXG4gICAgcmV0dXJuIHByaW50UHJvbWlzZTtcclxufVxyXG5cclxuLyoqXHJcbiogU2V0IHN2Zy1iYXNlZCBsYXllciB2aXNpYmlsaXR5IHRvIGZhbHNlIHRvIGF2b2lkIENPUlMgZXJyb3JcclxuKlxyXG4qIEBwYXJhbSB7T2JqZWN0fSBtYXAgZXNyaSBtYXAgb2JqZWN0XHJcbiogQHJldHVybiB7QXJyYXl9IGxheWVyIGFycmF5IG9mIGxheWVycyB3aGVyZSB2aXNpYmlsaXR5IGlzIHRydWVcclxuKi9cclxuZnVuY3Rpb24gaGlkZUxheWVycyhtYXApIHtcclxuICAgIHJldHVybiBtYXAuZ3JhcGhpY3NMYXllcklkc1xyXG4gICAgICAgIC5tYXAobGF5ZXJJZCA9PiBtYXAuZ2V0TGF5ZXIobGF5ZXJJZCkpXHJcbiAgICAgICAgLmZpbHRlcihsYXllciA9PiBsYXllci52aXNpYmxlKVxyXG4gICAgICAgIC5tYXAobGF5ZXIgPT4ge1xyXG4gICAgICAgICAgICBsYXllci5zZXRWaXNpYmlsaXR5KGZhbHNlKTtcclxuICAgICAgICAgICAgcmV0dXJuIGxheWVyO1xyXG4gICAgICAgIH0pO1xyXG59XHJcblxyXG4vKipcclxuKiBTZXQgdXNlciBhZGRlZCBsYXllciB2aXNpYmlsaXR5IHRvIHRydWUgZm9yIHRob3NlIHdob2Ugd2hlcmUgdmlzaWJsZVxyXG4qXHJcbiogQHBhcmFtIHtBcnJheX0gbGF5ZXJzIGFycmF5IG9mIGdyYXBoaWMgbGF5ZXJzIHRvIHNldCB2aXNpYmlsaXR5IHRvIHRydWVcclxuKi9cclxuZnVuY3Rpb24gc2hvd0xheWVycyhsYXllcnMpIHtcclxuICAgIGxheWVycy5mb3JFYWNoKChsYXllcikgPT4gbGF5ZXIuc2V0VmlzaWJpbGl0eSh0cnVlKSk7XHJcbn1cclxuXHJcbi8qKlxyXG4qIENyZWF0ZSBhIGNhbnZhcyBmcm9tIHRoZSB1c2VyIGFkZGVkIGxheWVycyAoc3ZnIHRhZylcclxuKlxyXG4qIEBwYXJhbSB7T2JqZWN0fSBtYXAgZXNyaSBtYXAgb2JqZWN0XHJcbiogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgW29wdGlvbmFsID0gbnVsbF0geyB3aWR0aCwgaGVpZ2h0IH0gdmFsdWVzOyBuZWVkZWQgdG8gZ2V0IGNhbnZhcyBvZiBhIHNpemUgZGlmZmVyZW50IGZyb20gZGVmYXVsdFxyXG4qICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGgge051bWJlcn1cclxuKiAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCB7TnVtYmVyfVxyXG4qIEBwYXJhbSB7T2JqZWN0fSBjYW52YXMgW29wdGlvbmFsID0gbnVsbF0gY2FudmFzIHRvIGRyYXcgdGhlIGltYWdlIHVwb247IGlmIG5vdCBzdXBwbGllZCwgYSBuZXcgY2FudmFzIHdpbGwgYmUgbWFkZVxyXG4qIEByZXR1cm4ge1Byb21pc2V9IHJlc29sdmluZyB3aGVuIHRoZSBjYW52YXMgaGF2ZSBiZWVuIGNyZWF0ZWRcclxuKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUgd2l0aCBhIGNhbnZhcyBlbGVtZW50IHdpdGggdXNlciBhZGRlZCBsYXllciBvbiBpdFxyXG4qL1xyXG5mdW5jdGlvbiBnZW5lcmF0ZUxvY2FsQ2FudmFzKG1hcCwgb3B0aW9ucyA9IG51bGwsIGNhbnZhcyA9IG51bGwpIHtcclxuICAgIGNhbnZhcyA9IGNhbnZhcyB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTsgIC8vIGNyZWF0ZSBjYW52YXMgZWxlbWVudFxyXG5cclxuICAgIC8vIGZpbmQgZXNyaSBtYXAncyBzdmcgbm9kZVxyXG4gICAgLy8gY2hlY2sgaWYgeG1sbnMgcHJlZml4ZXMgYXJlIHNldCAtIHRoZXkgYXJlbid0OyBhZGQgdGhlbVxyXG4gICAgLy8gd2l0aG91dCBjb3JyZWN0IHByZWZpeGVzLCBGaXJlZm94IGFuZCBJRSByZWZ1c2UgdG8gcmVuZGVyIHN2ZyBvbnRvIHRoZSBjYW52YXM7IENocm9tZSB3b3JrcztcclxuICAgIC8vIHJlbGF0ZWQgaXNzdWVzOiBmZ3B2LXZwZ2YvZmdwdi12cGdmIzEzMjQsIGZncHYtdnBnZi9mZ3B2LXZwZ2YjMTMwNywgZmdwdi12cGdmL2ZncHYtdnBnZiMxMzA2XHJcbiAgICBjb25zdCBzdmdOb2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYGVzcmlcXC5NYXBfJHttYXAuaWQuc3BsaXQoJ18nKVsxXX1fZ2NgKTtcclxuICAgIGlmICghc3ZnTm9kZS5nZXRBdHRyaWJ1dGUoJ3htbG5zJykpIHtcclxuICAgICAgICBPYmplY3QuZW50cmllcyhYTUxfQVRUUklCVVRFUykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PlxyXG4gICAgICAgICAgICBzdmdOb2RlLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKSk7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IG9yaWdpbmFsT3B0aW9ucztcclxuICAgIGlmIChvcHRpb25zKSB7XHJcbiAgICAgICAgb3JpZ2luYWxPcHRpb25zID0gcmVzaXplU1ZHRWxlbWVudChzdmdOb2RlLCBvcHRpb25zKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBnZW5lcmF0aW9uUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAvLyBwYXJzZSB0aGUgc3ZnXHJcbiAgICAgICAgLy8gY29udmVydCBzdmcgdGV4dCB0byBjYW52YXMgYW5kIHN0dWZmIGl0IGludG8gY2FudmFzIGNhbnZhcyBkb20gbm9kZVxyXG5cclxuICAgICAgICAvLyB3cmFwcGluZyBpbiB0cnkvY2F0Y2ggc2luY2UgY2FudmcgaGFzIE5PIGVycm9yIGhhbmRsaW5nOyBub3Qgc3VyZSB3aGF0IGVycm9ycyB0aGlzIGNhbiBjYXRjaCB0aG91Z2hcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAvLyBjb252ZXJ0IHN2ZyB0byB0ZXh0ICh1c2UgbWFwIGlkIHRvIHNlbGVjdCB0aGUgc3ZnIGNvbnRhaW5lciksIHRoZW4gcmVuZGVyIHN2Z3htbCBiYWNrIHRvIGNhbnZhc1xyXG4gICAgICAgICAgICBjYW52ZyhjYW52YXMsIHN2Z05vZGUub3V0ZXJIVE1MLCB7XHJcbiAgICAgICAgICAgICAgICB1c2VDT1JTOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgaWdub3JlQW5pbWF0aW9uOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgaWdub3JlTW91c2U6IHRydWUsXHJcbiAgICAgICAgICAgICAgICByZW5kZXJDYWxsYmFjazogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc2l6ZVNWR0VsZW1lbnQoc3ZnTm9kZSwgb3JpZ2luYWxPcHRpb25zLm9yaWdpbmFsU2l6ZSwgb3JpZ2luYWxPcHRpb25zLm9yaWdpbmFsVmlld2JveCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGNhbnZhcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIGdlbmVyYXRpb25Qcm9taXNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2NhbGVzIHVwIG9yIGRvd24gdGhlIHNwZWNpZmllZCBzdmcgZWxlbWVudC4gVG8gc2NhbGUgaXQsIHdlIG5lZWQgdG8gc2V0IHRoZSB2aWV3Ym94IHRvIHRoZSBjdXJyZW50IHNpemUgYW5kIGNoYW5nZSB0aGUgc2l6ZSBvZiB0aGUgZWxlbWVudCBpdHNlbGYuXHJcbiAgICAgKiBAZnVuY3Rpb24gcmVzaXplU1ZHRWxlbWVudFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IHRhcmdldCBzdmcgZWxlbWVudCB0byBiZSByZXNpemVkXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0U2l6ZSBvYmplY3Qgd2l0aCB0YXJnZXQgc2l6ZXMgaW4gdGhlIGZvcm0gb2YgeyB3aWR0aCwgaGVpZ2h0IH1cclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGgge051bWJlcn1cclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0IHtOdW1iZXJ9XHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0Vmlld2JveCBbb3B0aW9uYWwgPSBudWxsXSB0YXJnZXQgdmlld2JveCBzaXplcyBpbiB0aGUgZm9ybSBvZiB7IG1pblgsIG1pblksIHdpZHRoLCBoZWlnaHQgfTsgaWYgbm90IHNwZWNpZmllZCwgdGhlIG9yaWdpbmFsIHNpemUgd2lsbCBiZSB1c2VkIGFzIHRoZSB2aWV3Ym94XHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pblgge051bWJlcn1cclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgbWlueFkge051bWJlcn1cclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGgge051bWJlcn1cclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0IHtOdW1iZXJ9XHJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHJldHVybnMgb3JpZ2luYWwgc2l6ZSBhbmQgdmlld2JveCBvZiB0aGUgc3ZnIGVsZW1lbnQgaW4gdGhlIGZvcm0gb2YgeyBvcmlnaW5hbFNpemU6IHsgd2lkdGgsIGhlaWdodCB9LCBvcmlnaW5hbFZpZXdib3g6IHsgbWluWCwgbWluWSwgd2lkdGgsIGhlaWdodCB9IH07IGNhbiBiZSB1c2VkIHRvIHJlc3RvcmUgdGhlIGVsZW1lbnQgdG8gaXRzIG9yaWdpbmFsIHN0YXRlXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxTaXplOlxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCB7TnVtYmVyfVxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQge051bWJlcn1cclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbFZpZXdib3g6XHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pblgge051bWJlcn1cclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWlueFkge051bWJlcn1cclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGgge051bWJlcn1cclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0IHtOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHJlc2l6ZVNWR0VsZW1lbnQoZWxlbWVudCwgdGFyZ2V0U2l6ZSwgdGFyZ2V0Vmlld2JveCA9IG51bGwpIHtcclxuXHJcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxTaXplID0ge1xyXG4gICAgICAgICAgICB3aWR0aDogZWxlbWVudC53aWR0aC5iYXNlVmFsLnZhbHVlLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IGVsZW1lbnQuaGVpZ2h0LmJhc2VWYWwudmFsdWVcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBnZXQgdGhlIGN1cnJlbnQgdmlld2JveCBzaXplc1xyXG4gICAgICAgIC8vIGlmIHRoZSB2aWV3Ym94IGlzIG5vdCBkZWZpbmVkLCB0aGUgdmlld2JveCBpcyBhc3N1bWVkIHRvIGhhdmUgdGhlIHNhbWUgZGltZW5zaW9ucyBhcyB0aGUgc3ZnIGVsZW1lbnRcclxuICAgICAgICAvLyBnZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnKSByZXR1cm5zIGEgc3RyaW5nIGluIHRoZSBmb3JtICd7bWlueH0ge21pbnl9IHt3aWR0aH0ge2hlaWdodH0nXHJcbiAgICAgICAgLy8gc2V0QXR0cmlidXRlKCd2aWV3Qm94JykgYWNjZXB0cyBhIHN0cmluZyBpbiB0aGUgc2FtZSBmb3JtXHJcbiAgICAgICAgY29uc3QgW292TWluWCwgb3ZNaW5ZLCBvdldpZHRoLCBvdkhlaWdodF0gPVxyXG4gICAgICAgICAgICAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnKSB8fCBgMCAwICR7b3JpZ2luYWxTaXplLndpZHRofSAke29yaWdpbmFsU2l6ZS5oZWlnaHR9YCkuc3BsaXQoJyAnKTtcclxuXHJcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxWaWV3Ym94ID0ge1xyXG4gICAgICAgICAgICBtaW5YOiBvdk1pblgsXHJcbiAgICAgICAgICAgIG1pblk6IG92TWluWSxcclxuICAgICAgICAgICAgd2lkdGg6IG92V2lkdGgsXHJcbiAgICAgICAgICAgIGhlaWdodDogb3ZIZWlnaHRcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBzZXQgdGhlIHdpZHRoL2hlaWdodCBvZiB0aGUgc3ZnIGVsZW1lbnQgdG8gdGhlIHRhcmdldCB2YWx1ZXNcclxuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB0YXJnZXRTaXplLndpZHRoKTtcclxuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgdGFyZ2V0U2l6ZS5oZWlnaHQpO1xyXG5cclxuICAgICAgICAvLyBzZXQgdGhlIHZpZXdib3ggd2lkdGgvaGVpZ2h0IG9mIHRoZSBzdmcgZWxlbWVudCB0byB0aGUgdGFyZ2V0IHZhbHVlczsgb3IgdGhlIHZhbHVlcyBvZiB0aGUgb3JpZ2luYWwgdmlld2JveCAoaWYgdGhlIHZpZXdib3ggd2Fzbid0IGRlZmluZWQgYmVmb3JlLCBpdCBpcyBub3cpXHJcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCBbXHJcbiAgICAgICAgICAgICh0YXJnZXRWaWV3Ym94IHx8IG9yaWdpbmFsVmlld2JveCkubWluWCxcclxuICAgICAgICAgICAgKHRhcmdldFZpZXdib3ggfHwgb3JpZ2luYWxWaWV3Ym94KS5taW5ZLFxyXG4gICAgICAgICAgICAodGFyZ2V0Vmlld2JveCB8fCBvcmlnaW5hbFZpZXdib3gpLndpZHRoLFxyXG4gICAgICAgICAgICAodGFyZ2V0Vmlld2JveCB8fCBvcmlnaW5hbFZpZXdib3gpLmhlaWdodFxyXG4gICAgICAgIF0uam9pbignICcpKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgb3JpZ2luYWxTaXplLFxyXG4gICAgICAgICAgICBvcmlnaW5hbFZpZXdib3hcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcblxyXG4vLyBQcmludCBtYXAgcmVsYXRlZCBtb2R1bGVzXHJcbm1vZHVsZS5leHBvcnRzID0gKGVzcmlCdW5kbGUpID0+IHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcHJpbnRMb2NhbDogKG1hcCwgb3B0aW9ucykgPT4gZ2VuZXJhdGVMb2NhbENhbnZhcyhtYXAsIG9wdGlvbnMpLFxyXG4gICAgICAgIHByaW50U2VydmVyOiAobWFwLCBvcHRpb25zKSA9PiBnZW5lcmF0ZVNlcnZlckltYWdlKGVzcmlCdW5kbGUsIG1hcCwgb3B0aW9ucylcclxuICAgIH07XHJcbn07XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9tYXAvcHJpbnQuanMiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\r\n * canvg.js - Javascript SVG parser and renderer on Canvas\r\n * MIT Licensed\r\n * Gabe Lerner (gabelerner@gmail.com)\r\n * http://code.google.com/p/canvg/\r\n *\r\n * Requires: rgbcolor.js - http://www.phpied.com/rgb-color-parser-in-javascript/\r\n */\r\n (function ( global, factory ) {\r\n\r\n\t'use strict';\r\n\r\n\t// export as AMD...\r\n\tif ( true ) {\r\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(68), __webpack_require__(169) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\t}\r\n\r\n\t// ...or as browserify\r\n\telse if ( typeof module !== 'undefined' && module.exports ) {\r\n\t\tmodule.exports = factory( require( 'rgbcolor' ), require( 'stackblur' ) );\r\n\t}\r\n\r\n\tglobal.canvg = factory( global.RGBColor, global.stackBlur );\r\n\r\n}( typeof window !== 'undefined' ? window : this, function ( RGBColor, stackBlur ) {\r\n\r\n\t// canvg(target, s)\r\n\t// empty parameters: replace all 'svg' elements on page with 'canvas' elements\r\n\t// target: canvas element or the id of a canvas element\r\n\t// s: svg string, url to svg file, or xml document\r\n\t// opts: optional hash of options\r\n\t//\t\t ignoreMouse: true => ignore mouse events\r\n\t//\t\t ignoreAnimation: true => ignore animations\r\n\t//\t\t ignoreDimensions: true => does not try to resize canvas\r\n\t//\t\t ignoreClear: true => does not clear canvas\r\n\t//\t\t offsetX: int => draws at a x offset\r\n\t//\t\t offsetY: int => draws at a y offset\r\n\t//\t\t scaleWidth: int => scales horizontally to width\r\n\t//\t\t scaleHeight: int => scales vertically to height\r\n\t//\t\t renderCallback: function => will call the function after the first render is completed\r\n\t//\t\t forceRedraw: function => will call the function on every frame, if it returns true, will redraw\r\n\tvar canvg = function (target, s, opts) {\r\n\t\t// no parameters\r\n\t\tif (target == null && s == null && opts == null) {\r\n\t\t\tvar svgTags = document.querySelectorAll('svg');\r\n\t\t\tfor (var i=0; i<svgTags.length; i++) {\r\n\t\t\t\tvar svgTag = svgTags[i];\r\n\t\t\t\tvar c = document.createElement('canvas');\r\n\t\t\t\tc.width = svgTag.clientWidth;\r\n\t\t\t\tc.height = svgTag.clientHeight;\r\n\t\t\t\tsvgTag.parentNode.insertBefore(c, svgTag);\r\n\t\t\t\tsvgTag.parentNode.removeChild(svgTag);\r\n\t\t\t\tvar div = document.createElement('div');\r\n\t\t\t\tdiv.appendChild(svgTag);\r\n\t\t\t\tcanvg(c, div.innerHTML);\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (typeof target == 'string') {\r\n\t\t\ttarget = document.getElementById(target);\r\n\t\t}\r\n\r\n\t\t// store class on canvas\r\n\t\tif (target.svg != null) target.svg.stop();\r\n\t\tvar svg = build(opts || {});\r\n\t\t// on i.e. 8 for flash canvas, we can't assign the property so check for it\r\n\t\tif (!(target.childNodes.length == 1 && target.childNodes[0].nodeName == 'OBJECT')) target.svg = svg;\r\n\r\n\t\tvar ctx = target.getContext('2d');\r\n\t\tif (typeof s.documentElement != 'undefined') {\r\n\t\t\t// load from xml doc\r\n\t\t\tsvg.loadXmlDoc(ctx, s);\r\n\t\t}\r\n\t\telse if (s.substr(0,1) == '<') {\r\n\t\t\t// load from xml string\r\n\t\t\tsvg.loadXml(ctx, s);\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// load from url\r\n\t\t\tsvg.load(ctx, s);\r\n\t\t}\r\n\t}\r\n\r\n\t// see https://developer.mozilla.org/en-US/docs/Web/API/Element.matches\r\n\tvar matchesSelector;\r\n\tif (typeof Element.prototype.matches != 'undefined') {\r\n\t\tmatchesSelector = function(node, selector) {\r\n\t\t\treturn node.matches(selector);\r\n\t\t};\r\n\t} else if (typeof Element.prototype.webkitMatchesSelector != 'undefined') {\r\n\t\tmatchesSelector = function(node, selector) {\r\n\t\t\treturn node.webkitMatchesSelector(selector);\r\n\t\t};\r\n\t} else if (typeof Element.prototype.mozMatchesSelector != 'undefined') {\r\n\t\tmatchesSelector = function(node, selector) {\r\n\t\t\treturn node.mozMatchesSelector(selector);\r\n\t\t};\r\n\t} else if (typeof Element.prototype.msMatchesSelector != 'undefined') {\r\n\t\tmatchesSelector = function(node, selector) {\r\n\t\t\treturn node.msMatchesSelector(selector);\r\n\t\t};\r\n\t} else if (typeof Element.prototype.oMatchesSelector != 'undefined') {\r\n\t\tmatchesSelector = function(node, selector) {\r\n\t\t\treturn node.oMatchesSelector(selector);\r\n\t\t};\r\n\t} else {\r\n\t\t// requires Sizzle: https://github.com/jquery/sizzle/wiki/Sizzle-Documentation\r\n\t\t// or jQuery: http://jquery.com/download/\r\n\t\t// or Zepto: http://zeptojs.com/#\r\n\t\t// without it, this is a ReferenceError\r\n\r\n\t\tif (typeof jQuery === 'function' || typeof Zepto === 'function') {\r\n\t\t\tmatchesSelector = function (node, selector) {\r\n\t\t\t\treturn $(node).is(selector);\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\tif (typeof matchesSelector === 'undefined') {\r\n\t\t\tmatchesSelector = Sizzle.matchesSelector;\r\n\t\t}\r\n\t}\r\n\r\n\t// slightly modified version of https://github.com/keeganstreet/specificity/blob/master/specificity.js\r\n\tvar attributeRegex = /(\\[[^\\]]+\\])/g;\r\n\tvar idRegex = /(#[^\\s\\+>~\\.\\[:]+)/g;\r\n\tvar classRegex = /(\\.[^\\s\\+>~\\.\\[:]+)/g;\r\n\tvar pseudoElementRegex = /(::[^\\s\\+>~\\.\\[:]+|:first-line|:first-letter|:before|:after)/gi;\r\n\tvar pseudoClassWithBracketsRegex = /(:[\\w-]+\\([^\\)]*\\))/gi;\r\n\tvar pseudoClassRegex = /(:[^\\s\\+>~\\.\\[:]+)/g;\r\n\tvar elementRegex = /([^\\s\\+>~\\.\\[:]+)/g;\r\n\tfunction getSelectorSpecificity(selector) {\r\n\t\tvar typeCount = [0, 0, 0];\r\n\t\tvar findMatch = function(regex, type) {\r\n\t\t\tvar matches = selector.match(regex);\r\n\t\t\tif (matches == null) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\ttypeCount[type] += matches.length;\r\n\t\t\tselector = selector.replace(regex, ' ');\r\n\t\t};\r\n\r\n\t\tselector = selector.replace(/:not\\(([^\\)]*)\\)/g, '     $1 ');\r\n\t\tselector = selector.replace(/{[\\s\\S]*/gm, ' ');\r\n\t\tfindMatch(attributeRegex, 1);\r\n\t\tfindMatch(idRegex, 0);\r\n\t\tfindMatch(classRegex, 1);\r\n\t\tfindMatch(pseudoElementRegex, 2);\r\n\t\tfindMatch(pseudoClassWithBracketsRegex, 1);\r\n\t\tfindMatch(pseudoClassRegex, 1);\r\n\t\tselector = selector.replace(/[\\*\\s\\+>~]/g, ' ');\r\n\t\tselector = selector.replace(/[#\\.]/g, ' ');\r\n\t\tfindMatch(elementRegex, 2);\r\n\t\treturn typeCount.join('');\r\n\t}\r\n\r\n\tfunction build(opts) {\r\n\t\tvar svg = { opts: opts };\r\n\r\n\t\tsvg.FRAMERATE = 30;\r\n\t\tsvg.MAX_VIRTUAL_PIXELS = 30000;\r\n\r\n\t\tsvg.log = function(msg) {};\r\n\t\tif (svg.opts['log'] == true && typeof console != 'undefined') {\r\n\t\t\tsvg.log = function(msg) { console.log(msg); };\r\n\t\t};\r\n\r\n\t\t// globals\r\n\t\tsvg.init = function(ctx) {\r\n\t\t\tvar uniqueId = 0;\r\n\t\t\tsvg.UniqueId = function () { uniqueId++; return 'canvg' + uniqueId;\t};\r\n\t\t\tsvg.Definitions = {};\r\n\t\t\tsvg.Styles = {};\r\n\t\t\tsvg.StylesSpecificity = {};\r\n\t\t\tsvg.Animations = [];\r\n\t\t\tsvg.Images = [];\r\n\t\t\tsvg.ctx = ctx;\r\n\t\t\tsvg.ViewPort = new (function () {\r\n\t\t\t\tthis.viewPorts = [];\r\n\t\t\t\tthis.Clear = function() { this.viewPorts = []; }\r\n\t\t\t\tthis.SetCurrent = function(width, height) { this.viewPorts.push({ width: width, height: height }); }\r\n\t\t\t\tthis.RemoveCurrent = function() { this.viewPorts.pop(); }\r\n\t\t\t\tthis.Current = function() { return this.viewPorts[this.viewPorts.length - 1]; }\r\n\t\t\t\tthis.width = function() { return this.Current().width; }\r\n\t\t\t\tthis.height = function() { return this.Current().height; }\r\n\t\t\t\tthis.ComputeSize = function(d) {\r\n\t\t\t\t\tif (d != null && typeof d == 'number') return d;\r\n\t\t\t\t\tif (d == 'x') return this.width();\r\n\t\t\t\t\tif (d == 'y') return this.height();\r\n\t\t\t\t\treturn Math.sqrt(Math.pow(this.width(), 2) + Math.pow(this.height(), 2)) / Math.sqrt(2);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t\tsvg.init();\r\n\r\n\t\t// images loaded\r\n\t\tsvg.ImagesLoaded = function() {\r\n\t\t\tfor (var i=0; i<svg.Images.length; i++) {\r\n\t\t\t\tif (!svg.Images[i].loaded) return false;\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t// trim\r\n\t\tsvg.trim = function(s) { return s.replace(/^\\s+|\\s+$/g, ''); }\r\n\r\n\t\t// compress spaces\r\n\t\tsvg.compressSpaces = function(s) { return s.replace(/[\\s\\r\\t\\n]+/gm,' '); }\r\n\r\n\t\t// ajax\r\n\t\tsvg.ajax = function(url) {\r\n\t\t\tvar AJAX;\r\n\t\t\tif(window.XMLHttpRequest){AJAX=new XMLHttpRequest();}\r\n\t\t\telse{AJAX=new ActiveXObject('Microsoft.XMLHTTP');}\r\n\t\t\tif(AJAX){\r\n\t\t\t   AJAX.open('GET',url,false);\r\n\t\t\t   AJAX.send(null);\r\n\t\t\t   return AJAX.responseText;\r\n\t\t\t}\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t// parse xml\r\n\t\tsvg.parseXml = function(xml) {\r\n\t\t\tif (typeof Windows != 'undefined' && typeof Windows.Data != 'undefined' && typeof Windows.Data.Xml != 'undefined') {\r\n\t\t\t\tvar xmlDoc = new Windows.Data.Xml.Dom.XmlDocument();\r\n\t\t\t\tvar settings = new Windows.Data.Xml.Dom.XmlLoadSettings();\r\n\t\t\t\tsettings.prohibitDtd = false;\r\n\t\t\t\txmlDoc.loadXml(xml, settings);\r\n\t\t\t\treturn xmlDoc;\r\n\t\t\t}\r\n\t\t\telse if (window.DOMParser)\r\n\t\t\t{\r\n\t\t\t\tvar parser = new DOMParser();\r\n\t\t\t\treturn parser.parseFromString(xml, 'text/xml');\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\txml = xml.replace(/<!DOCTYPE svg[^>]*>/, '');\r\n\t\t\t\tvar xmlDoc = new ActiveXObject('Microsoft.XMLDOM');\r\n\t\t\t\txmlDoc.async = 'false';\r\n\t\t\t\txmlDoc.loadXML(xml);\r\n\t\t\t\treturn xmlDoc;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tsvg.Property = function(name, value) {\r\n\t\t\tthis.name = name;\r\n\t\t\tthis.value = value;\r\n\t\t}\r\n\t\t\tsvg.Property.prototype.getValue = function() {\r\n\t\t\t\treturn this.value;\r\n\t\t\t}\r\n\r\n\t\t\tsvg.Property.prototype.hasValue = function() {\r\n\t\t\t\treturn (this.value != null && this.value !== '');\r\n\t\t\t}\r\n\r\n\t\t\t// return the numerical value of the property\r\n\t\t\tsvg.Property.prototype.numValue = function() {\r\n\t\t\t\tif (!this.hasValue()) return 0;\r\n\r\n\t\t\t\tvar n = parseFloat(this.value);\r\n\t\t\t\tif ((this.value + '').match(/%$/)) {\r\n\t\t\t\t\tn = n / 100.0;\r\n\t\t\t\t}\r\n\t\t\t\treturn n;\r\n\t\t\t}\r\n\r\n\t\t\tsvg.Property.prototype.valueOrDefault = function(def) {\r\n\t\t\t\tif (this.hasValue()) return this.value;\r\n\t\t\t\treturn def;\r\n\t\t\t}\r\n\r\n\t\t\tsvg.Property.prototype.numValueOrDefault = function(def) {\r\n\t\t\t\tif (this.hasValue()) return this.numValue();\r\n\t\t\t\treturn def;\r\n\t\t\t}\r\n\r\n\t\t\t// color extensions\r\n\t\t\t\t// augment the current color value with the opacity\r\n\t\t\t\tsvg.Property.prototype.addOpacity = function(opacityProp) {\r\n\t\t\t\t\tvar newValue = this.value;\r\n\t\t\t\t\tif (opacityProp.value != null && opacityProp.value != '' && typeof this.value == 'string') { // can only add opacity to colors, not patterns\r\n\t\t\t\t\t\tvar color = new RGBColor(this.value);\r\n\t\t\t\t\t\tif (color.ok) {\r\n\t\t\t\t\t\t\tnewValue = 'rgba(' + color.r + ', ' + color.g + ', ' + color.b + ', ' + opacityProp.numValue() + ')';\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn new svg.Property(this.name, newValue);\r\n\t\t\t\t}\r\n\r\n\t\t\t// definition extensions\r\n\t\t\t\t// get the definition from the definitions table\r\n\t\t\t\tsvg.Property.prototype.getDefinition = function() {\r\n\t\t\t\t\tvar name = this.value.match(/#([^\\)'\"]+)/);\r\n\t\t\t\t\tif (name) { name = name[1]; }\r\n\t\t\t\t\tif (!name) { name = this.value; }\r\n\t\t\t\t\treturn svg.Definitions[name];\r\n\t\t\t\t}\r\n\r\n\t\t\t\tsvg.Property.prototype.isUrlDefinition = function() {\r\n\t\t\t\t\treturn this.value.indexOf('url(') == 0\r\n\t\t\t\t}\r\n\r\n\t\t\t\tsvg.Property.prototype.getFillStyleDefinition = function(e, opacityProp) {\r\n\t\t\t\t\tvar def = this.getDefinition();\r\n\r\n\t\t\t\t\t// gradient\r\n\t\t\t\t\tif (def != null && def.createGradient) {\r\n\t\t\t\t\t\treturn def.createGradient(svg.ctx, e, opacityProp);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// pattern\r\n\t\t\t\t\tif (def != null && def.createPattern) {\r\n\t\t\t\t\t\tif (def.getHrefAttribute().hasValue()) {\r\n\t\t\t\t\t\t\tvar pt = def.attribute('patternTransform');\r\n\t\t\t\t\t\t\tdef = def.getHrefAttribute().getDefinition();\r\n\t\t\t\t\t\t\tif (pt.hasValue()) { def.attribute('patternTransform', true).value = pt.value; }\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn def.createPattern(svg.ctx, e);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\r\n\t\t\t// length extensions\r\n\t\t\t\tsvg.Property.prototype.getDPI = function(viewPort) {\r\n\t\t\t\t\treturn 96.0; // TODO: compute?\r\n\t\t\t\t}\r\n\r\n\t\t\t\tsvg.Property.prototype.getEM = function(viewPort) {\r\n\t\t\t\t\tvar em = 12;\r\n\r\n\t\t\t\t\tvar fontSize = new svg.Property('fontSize', svg.Font.Parse(svg.ctx.font).fontSize);\r\n\t\t\t\t\tif (fontSize.hasValue()) em = fontSize.toPixels(viewPort);\r\n\r\n\t\t\t\t\treturn em;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tsvg.Property.prototype.getUnits = function() {\r\n\t\t\t\t\tvar s = this.value+'';\r\n\t\t\t\t\treturn s.replace(/[0-9\\.\\-]/g,'');\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// get the length as pixels\r\n\t\t\t\tsvg.Property.prototype.toPixels = function(viewPort, processPercent) {\r\n\t\t\t\t\tif (!this.hasValue()) return 0;\r\n\t\t\t\t\tvar s = this.value+'';\r\n\t\t\t\t\tif (s.match(/em$/)) return this.numValue() * this.getEM(viewPort);\r\n\t\t\t\t\tif (s.match(/ex$/)) return this.numValue() * this.getEM(viewPort) / 2.0;\r\n\t\t\t\t\tif (s.match(/px$/)) return this.numValue();\r\n\t\t\t\t\tif (s.match(/pt$/)) return this.numValue() * this.getDPI(viewPort) * (1.0 / 72.0);\r\n\t\t\t\t\tif (s.match(/pc$/)) return this.numValue() * 15;\r\n\t\t\t\t\tif (s.match(/cm$/)) return this.numValue() * this.getDPI(viewPort) / 2.54;\r\n\t\t\t\t\tif (s.match(/mm$/)) return this.numValue() * this.getDPI(viewPort) / 25.4;\r\n\t\t\t\t\tif (s.match(/in$/)) return this.numValue() * this.getDPI(viewPort);\r\n\t\t\t\t\tif (s.match(/%$/)) return this.numValue() * svg.ViewPort.ComputeSize(viewPort);\r\n\t\t\t\t\tvar n = this.numValue();\r\n\t\t\t\t\tif (processPercent && n < 1.0) return n * svg.ViewPort.ComputeSize(viewPort);\r\n\t\t\t\t\treturn n;\r\n\t\t\t\t}\r\n\r\n\t\t\t// time extensions\r\n\t\t\t\t// get the time as milliseconds\r\n\t\t\t\tsvg.Property.prototype.toMilliseconds = function() {\r\n\t\t\t\t\tif (!this.hasValue()) return 0;\r\n\t\t\t\t\tvar s = this.value+'';\r\n\t\t\t\t\tif (s.match(/s$/)) return this.numValue() * 1000;\r\n\t\t\t\t\tif (s.match(/ms$/)) return this.numValue();\r\n\t\t\t\t\treturn this.numValue();\r\n\t\t\t\t}\r\n\r\n\t\t\t// angle extensions\r\n\t\t\t\t// get the angle as radians\r\n\t\t\t\tsvg.Property.prototype.toRadians = function() {\r\n\t\t\t\t\tif (!this.hasValue()) return 0;\r\n\t\t\t\t\tvar s = this.value+'';\r\n\t\t\t\t\tif (s.match(/deg$/)) return this.numValue() * (Math.PI / 180.0);\r\n\t\t\t\t\tif (s.match(/grad$/)) return this.numValue() * (Math.PI / 200.0);\r\n\t\t\t\t\tif (s.match(/rad$/)) return this.numValue();\r\n\t\t\t\t\treturn this.numValue() * (Math.PI / 180.0);\r\n\t\t\t\t}\r\n\r\n\t\t\t// text extensions\r\n\t\t\t\t// get the text baseline\r\n\t\t\t\tvar textBaselineMapping = {\r\n\t\t\t\t\t'baseline': 'alphabetic',\r\n\t\t\t\t\t'before-edge': 'top',\r\n\t\t\t\t\t'text-before-edge': 'top',\r\n\t\t\t\t\t'middle': 'middle',\r\n\t\t\t\t\t'central': 'middle',\r\n\t\t\t\t\t'after-edge': 'bottom',\r\n\t\t\t\t\t'text-after-edge': 'bottom',\r\n\t\t\t\t\t'ideographic': 'ideographic',\r\n\t\t\t\t\t'alphabetic': 'alphabetic',\r\n\t\t\t\t\t'hanging': 'hanging',\r\n\t\t\t\t\t'mathematical': 'alphabetic'\r\n\t\t\t\t};\r\n\t\t\t\tsvg.Property.prototype.toTextBaseline = function () {\r\n\t\t\t\t\tif (!this.hasValue()) return null;\r\n\t\t\t\t\treturn textBaselineMapping[this.value];\r\n\t\t\t\t}\r\n\r\n\t\t// fonts\r\n\t\tsvg.Font = new (function() {\r\n\t\t\tthis.Styles = 'normal|italic|oblique|inherit';\r\n\t\t\tthis.Variants = 'normal|small-caps|inherit';\r\n\t\t\tthis.Weights = 'normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit';\r\n\r\n\t\t\tthis.CreateFont = function(fontStyle, fontVariant, fontWeight, fontSize, fontFamily, inherit) {\r\n\t\t\t\tvar f = inherit != null ? this.Parse(inherit) : this.CreateFont('', '', '', '', '', svg.ctx.font);\r\n\t\t\t\treturn {\r\n\t\t\t\t\tfontFamily: fontFamily || f.fontFamily,\r\n\t\t\t\t\tfontSize: fontSize || f.fontSize,\r\n\t\t\t\t\tfontStyle: fontStyle || f.fontStyle,\r\n\t\t\t\t\tfontWeight: fontWeight || f.fontWeight,\r\n\t\t\t\t\tfontVariant: fontVariant || f.fontVariant,\r\n\t\t\t\t\ttoString: function () { return [this.fontStyle, this.fontVariant, this.fontWeight, this.fontSize, this.fontFamily].join(' ') }\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tvar that = this;\r\n\t\t\tthis.Parse = function(s) {\r\n\t\t\t\tvar f = {};\r\n\t\t\t\tvar d = svg.trim(svg.compressSpaces(s || '')).split(' ');\r\n\t\t\t\tvar set = { fontSize: false, fontStyle: false, fontWeight: false, fontVariant: false }\r\n\t\t\t\tvar ff = '';\r\n\t\t\t\tfor (var i=0; i<d.length; i++) {\r\n\t\t\t\t\tif (!set.fontStyle && that.Styles.indexOf(d[i]) != -1) { if (d[i] != 'inherit') f.fontStyle = d[i]; set.fontStyle = true; }\r\n\t\t\t\t\telse if (!set.fontVariant && that.Variants.indexOf(d[i]) != -1) { if (d[i] != 'inherit') f.fontVariant = d[i]; set.fontStyle = set.fontVariant = true;\t}\r\n\t\t\t\t\telse if (!set.fontWeight && that.Weights.indexOf(d[i]) != -1) {\tif (d[i] != 'inherit') f.fontWeight = d[i]; set.fontStyle = set.fontVariant = set.fontWeight = true; }\r\n\t\t\t\t\telse if (!set.fontSize) { if (d[i] != 'inherit') f.fontSize = d[i].split('/')[0]; set.fontStyle = set.fontVariant = set.fontWeight = set.fontSize = true; }\r\n\t\t\t\t\telse { if (d[i] != 'inherit') ff += d[i]; }\r\n\t\t\t\t} if (ff != '') f.fontFamily = ff;\r\n\t\t\t\treturn f;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t// points and paths\r\n\t\tsvg.ToNumberArray = function(s) {\r\n\t\t\tvar a = svg.trim(svg.compressSpaces((s || '').replace(/,/g, ' '))).split(' ');\r\n\t\t\tfor (var i=0; i<a.length; i++) {\r\n\t\t\t\ta[i] = parseFloat(a[i]);\r\n\t\t\t}\r\n\t\t\treturn a;\r\n\t\t}\r\n\t\tsvg.Point = function(x, y) {\r\n\t\t\tthis.x = x;\r\n\t\t\tthis.y = y;\r\n\t\t}\r\n\t\t\tsvg.Point.prototype.angleTo = function(p) {\r\n\t\t\t\treturn Math.atan2(p.y - this.y, p.x - this.x);\r\n\t\t\t}\r\n\r\n\t\t\tsvg.Point.prototype.applyTransform = function(v) {\r\n\t\t\t\tvar xp = this.x * v[0] + this.y * v[2] + v[4];\r\n\t\t\t\tvar yp = this.x * v[1] + this.y * v[3] + v[5];\r\n\t\t\t\tthis.x = xp;\r\n\t\t\t\tthis.y = yp;\r\n\t\t\t}\r\n\r\n\t\tsvg.CreatePoint = function(s) {\r\n\t\t\tvar a = svg.ToNumberArray(s);\r\n\t\t\treturn new svg.Point(a[0], a[1]);\r\n\t\t}\r\n\t\tsvg.CreatePath = function(s) {\r\n\t\t\tvar a = svg.ToNumberArray(s);\r\n\t\t\tvar path = [];\r\n\t\t\tfor (var i=0; i<a.length; i+=2) {\r\n\t\t\t\tpath.push(new svg.Point(a[i], a[i+1]));\r\n\t\t\t}\r\n\t\t\treturn path;\r\n\t\t}\r\n\r\n\t\t// bounding box\r\n\t\tsvg.BoundingBox = function(x1, y1, x2, y2) { // pass in initial points if you want\r\n\t\t\tthis.x1 = Number.NaN;\r\n\t\t\tthis.y1 = Number.NaN;\r\n\t\t\tthis.x2 = Number.NaN;\r\n\t\t\tthis.y2 = Number.NaN;\r\n\r\n\t\t\tthis.x = function() { return this.x1; }\r\n\t\t\tthis.y = function() { return this.y1; }\r\n\t\t\tthis.width = function() { return this.x2 - this.x1; }\r\n\t\t\tthis.height = function() { return this.y2 - this.y1; }\r\n\r\n\t\t\tthis.addPoint = function(x, y) {\r\n\t\t\t\tif (x != null) {\r\n\t\t\t\t\tif (isNaN(this.x1) || isNaN(this.x2)) {\r\n\t\t\t\t\t\tthis.x1 = x;\r\n\t\t\t\t\t\tthis.x2 = x;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (x < this.x1) this.x1 = x;\r\n\t\t\t\t\tif (x > this.x2) this.x2 = x;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (y != null) {\r\n\t\t\t\t\tif (isNaN(this.y1) || isNaN(this.y2)) {\r\n\t\t\t\t\t\tthis.y1 = y;\r\n\t\t\t\t\t\tthis.y2 = y;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (y < this.y1) this.y1 = y;\r\n\t\t\t\t\tif (y > this.y2) this.y2 = y;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.addX = function(x) { this.addPoint(x, null); }\r\n\t\t\tthis.addY = function(y) { this.addPoint(null, y); }\r\n\r\n\t\t\tthis.addBoundingBox = function(bb) {\r\n\t\t\t\tthis.addPoint(bb.x1, bb.y1);\r\n\t\t\t\tthis.addPoint(bb.x2, bb.y2);\r\n\t\t\t}\r\n\r\n\t\t\tthis.addQuadraticCurve = function(p0x, p0y, p1x, p1y, p2x, p2y) {\r\n\t\t\t\tvar cp1x = p0x + 2/3 * (p1x - p0x); // CP1 = QP0 + 2/3 *(QP1-QP0)\r\n\t\t\t\tvar cp1y = p0y + 2/3 * (p1y - p0y); // CP1 = QP0 + 2/3 *(QP1-QP0)\r\n\t\t\t\tvar cp2x = cp1x + 1/3 * (p2x - p0x); // CP2 = CP1 + 1/3 *(QP2-QP0)\r\n\t\t\t\tvar cp2y = cp1y + 1/3 * (p2y - p0y); // CP2 = CP1 + 1/3 *(QP2-QP0)\r\n\t\t\t\tthis.addBezierCurve(p0x, p0y, cp1x, cp2x, cp1y,\tcp2y, p2x, p2y);\r\n\t\t\t}\r\n\r\n\t\t\tthis.addBezierCurve = function(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y) {\r\n\t\t\t\t// from http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html\r\n\t\t\t\tvar p0 = [p0x, p0y], p1 = [p1x, p1y], p2 = [p2x, p2y], p3 = [p3x, p3y];\r\n\t\t\t\tthis.addPoint(p0[0], p0[1]);\r\n\t\t\t\tthis.addPoint(p3[0], p3[1]);\r\n\r\n\t\t\t\tfor (i=0; i<=1; i++) {\r\n\t\t\t\t\tvar f = function(t) {\r\n\t\t\t\t\t\treturn Math.pow(1-t, 3) * p0[i]\r\n\t\t\t\t\t\t+ 3 * Math.pow(1-t, 2) * t * p1[i]\r\n\t\t\t\t\t\t+ 3 * (1-t) * Math.pow(t, 2) * p2[i]\r\n\t\t\t\t\t\t+ Math.pow(t, 3) * p3[i];\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tvar b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];\r\n\t\t\t\t\tvar a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];\r\n\t\t\t\t\tvar c = 3 * p1[i] - 3 * p0[i];\r\n\r\n\t\t\t\t\tif (a == 0) {\r\n\t\t\t\t\t\tif (b == 0) continue;\r\n\t\t\t\t\t\tvar t = -c / b;\r\n\t\t\t\t\t\tif (0 < t && t < 1) {\r\n\t\t\t\t\t\t\tif (i == 0) this.addX(f(t));\r\n\t\t\t\t\t\t\tif (i == 1) this.addY(f(t));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tvar b2ac = Math.pow(b, 2) - 4 * c * a;\r\n\t\t\t\t\tif (b2ac < 0) continue;\r\n\t\t\t\t\tvar t1 = (-b + Math.sqrt(b2ac)) / (2 * a);\r\n\t\t\t\t\tif (0 < t1 && t1 < 1) {\r\n\t\t\t\t\t\tif (i == 0) this.addX(f(t1));\r\n\t\t\t\t\t\tif (i == 1) this.addY(f(t1));\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar t2 = (-b - Math.sqrt(b2ac)) / (2 * a);\r\n\t\t\t\t\tif (0 < t2 && t2 < 1) {\r\n\t\t\t\t\t\tif (i == 0) this.addX(f(t2));\r\n\t\t\t\t\t\tif (i == 1) this.addY(f(t2));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tthis.isPointInBox = function(x, y) {\r\n\t\t\t\treturn (this.x1 <= x && x <= this.x2 && this.y1 <= y && y <= this.y2);\r\n\t\t\t}\r\n\r\n\t\t\tthis.addPoint(x1, y1);\r\n\t\t\tthis.addPoint(x2, y2);\r\n\t\t}\r\n\r\n\t\t// transforms\r\n\t\tsvg.Transform = function(v) {\r\n\t\t\tvar that = this;\r\n\t\t\tthis.Type = {}\r\n\r\n\t\t\t// translate\r\n\t\t\tthis.Type.translate = function(s) {\r\n\t\t\t\tthis.p = svg.CreatePoint(s);\r\n\t\t\t\tthis.apply = function(ctx) {\r\n\t\t\t\t\tctx.translate(this.p.x || 0.0, this.p.y || 0.0);\r\n\t\t\t\t}\r\n\t\t\t\tthis.unapply = function(ctx) {\r\n\t\t\t\t\tctx.translate(-1.0 * this.p.x || 0.0, -1.0 * this.p.y || 0.0);\r\n\t\t\t\t}\r\n\t\t\t\tthis.applyToPoint = function(p) {\r\n\t\t\t\t\tp.applyTransform([1, 0, 0, 1, this.p.x || 0.0, this.p.y || 0.0]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// rotate\r\n\t\t\tthis.Type.rotate = function(s) {\r\n\t\t\t\tvar a = svg.ToNumberArray(s);\r\n\t\t\t\tthis.angle = new svg.Property('angle', a[0]);\r\n\t\t\t\tthis.cx = a[1] || 0;\r\n\t\t\t\tthis.cy = a[2] || 0;\r\n\t\t\t\tthis.apply = function(ctx) {\r\n\t\t\t\t\tctx.translate(this.cx, this.cy);\r\n\t\t\t\t\tctx.rotate(this.angle.toRadians());\r\n\t\t\t\t\tctx.translate(-this.cx, -this.cy);\r\n\t\t\t\t}\r\n\t\t\t\tthis.unapply = function(ctx) {\r\n\t\t\t\t\tctx.translate(this.cx, this.cy);\r\n\t\t\t\t\tctx.rotate(-1.0 * this.angle.toRadians());\r\n\t\t\t\t\tctx.translate(-this.cx, -this.cy);\r\n\t\t\t\t}\r\n\t\t\t\tthis.applyToPoint = function(p) {\r\n\t\t\t\t\tvar a = this.angle.toRadians();\r\n\t\t\t\t\tp.applyTransform([1, 0, 0, 1, this.p.x || 0.0, this.p.y || 0.0]);\r\n\t\t\t\t\tp.applyTransform([Math.cos(a), Math.sin(a), -Math.sin(a), Math.cos(a), 0, 0]);\r\n\t\t\t\t\tp.applyTransform([1, 0, 0, 1, -this.p.x || 0.0, -this.p.y || 0.0]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tthis.Type.scale = function(s) {\r\n\t\t\t\tthis.p = svg.CreatePoint(s);\r\n\t\t\t\tthis.apply = function(ctx) {\r\n\t\t\t\t\tctx.scale(this.p.x || 1.0, this.p.y || this.p.x || 1.0);\r\n\t\t\t\t}\r\n\t\t\t\tthis.unapply = function(ctx) {\r\n\t\t\t\t\tctx.scale(1.0 / this.p.x || 1.0, 1.0 / this.p.y || this.p.x || 1.0);\r\n\t\t\t\t}\r\n\t\t\t\tthis.applyToPoint = function(p) {\r\n\t\t\t\t\tp.applyTransform([this.p.x || 0.0, 0, 0, this.p.y || 0.0, 0, 0]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tthis.Type.matrix = function(s) {\r\n\t\t\t\tthis.m = svg.ToNumberArray(s);\r\n\t\t\t\tthis.apply = function(ctx) {\r\n\t\t\t\t\tctx.transform(this.m[0], this.m[1], this.m[2], this.m[3], this.m[4], this.m[5]);\r\n\t\t\t\t}\r\n\t\t\t\tthis.unapply = function(ctx) {\r\n\t\t\t\t\tvar a = this.m[0];\r\n\t\t\t\t\tvar b = this.m[2];\r\n\t\t\t\t\tvar c = this.m[4];\r\n\t\t\t\t\tvar d = this.m[1];\r\n\t\t\t\t\tvar e = this.m[3];\r\n\t\t\t\t\tvar f = this.m[5];\r\n\t\t\t\t\tvar g = 0.0;\r\n\t\t\t\t\tvar h = 0.0;\r\n\t\t\t\t\tvar i = 1.0;\r\n\t\t\t\t\tvar det = 1 / (a*(e*i-f*h)-b*(d*i-f*g)+c*(d*h-e*g));\r\n\t\t\t\t\tctx.transform(\r\n\t\t\t\t\t\tdet*(e*i-f*h),\r\n\t\t\t\t\t\tdet*(f*g-d*i),\r\n\t\t\t\t\t\tdet*(c*h-b*i),\r\n\t\t\t\t\t\tdet*(a*i-c*g),\r\n\t\t\t\t\t\tdet*(b*f-c*e),\r\n\t\t\t\t\t\tdet*(c*d-a*f)\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t\tthis.applyToPoint = function(p) {\r\n\t\t\t\t\tp.applyTransform(this.m);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tthis.Type.SkewBase = function(s) {\r\n\t\t\t\tthis.base = that.Type.matrix;\r\n\t\t\t\tthis.base(s);\r\n\t\t\t\tthis.angle = new svg.Property('angle', s);\r\n\t\t\t}\r\n\t\t\tthis.Type.SkewBase.prototype = new this.Type.matrix;\r\n\r\n\t\t\tthis.Type.skewX = function(s) {\r\n\t\t\t\tthis.base = that.Type.SkewBase;\r\n\t\t\t\tthis.base(s);\r\n\t\t\t\tthis.m = [1, 0, Math.tan(this.angle.toRadians()), 1, 0, 0];\r\n\t\t\t}\r\n\t\t\tthis.Type.skewX.prototype = new this.Type.SkewBase;\r\n\r\n\t\t\tthis.Type.skewY = function(s) {\r\n\t\t\t\tthis.base = that.Type.SkewBase;\r\n\t\t\t\tthis.base(s);\r\n\t\t\t\tthis.m = [1, Math.tan(this.angle.toRadians()), 0, 1, 0, 0];\r\n\t\t\t}\r\n\t\t\tthis.Type.skewY.prototype = new this.Type.SkewBase;\r\n\r\n\t\t\tthis.transforms = [];\r\n\r\n\t\t\tthis.apply = function(ctx) {\r\n\t\t\t\tfor (var i=0; i<this.transforms.length; i++) {\r\n\t\t\t\t\tthis.transforms[i].apply(ctx);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tthis.unapply = function(ctx) {\r\n\t\t\t\tfor (var i=this.transforms.length-1; i>=0; i--) {\r\n\t\t\t\t\tthis.transforms[i].unapply(ctx);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tthis.applyToPoint = function(p) {\r\n\t\t\t\tfor (var i=0; i<this.transforms.length; i++) {\r\n\t\t\t\t\tthis.transforms[i].applyToPoint(p);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tvar data = svg.trim(svg.compressSpaces(v)).replace(/\\)([a-zA-Z])/g, ') $1').replace(/\\)(\\s?,\\s?)/g,') ').split(/\\s(?=[a-z])/);\r\n\t\t\tfor (var i=0; i<data.length; i++) {\r\n\t\t\t\tvar type = svg.trim(data[i].split('(')[0]);\r\n\t\t\t\tvar s = data[i].split('(')[1].replace(')','');\r\n\t\t\t\tvar transformType = this.Type[type];\r\n\t\t\t\tif (typeof transformType != 'undefined') {\r\n\t\t\t\t\tvar transform = new transformType(s);\r\n\t\t\t\t\ttransform.type = type;\r\n\t\t\t\t\tthis.transforms.push(transform);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// aspect ratio\r\n\t\tsvg.AspectRatio = function(ctx, aspectRatio, width, desiredWidth, height, desiredHeight, minX, minY, refX, refY) {\r\n\t\t\t// aspect ratio - http://www.w3.org/TR/SVG/coords.html#PreserveAspectRatioAttribute\r\n\t\t\taspectRatio = svg.compressSpaces(aspectRatio);\r\n\t\t\taspectRatio = aspectRatio.replace(/^defer\\s/,''); // ignore defer\r\n\t\t\tvar align = aspectRatio.split(' ')[0] || 'xMidYMid';\r\n\t\t\tvar meetOrSlice = aspectRatio.split(' ')[1] || 'meet';\r\n\r\n\t\t\t// calculate scale\r\n\t\t\tvar scaleX = width / desiredWidth;\r\n\t\t\tvar scaleY = height / desiredHeight;\r\n\t\t\tvar scaleMin = Math.min(scaleX, scaleY);\r\n\t\t\tvar scaleMax = Math.max(scaleX, scaleY);\r\n\t\t\tif (meetOrSlice == 'meet') { desiredWidth *= scaleMin; desiredHeight *= scaleMin; }\r\n\t\t\tif (meetOrSlice == 'slice') { desiredWidth *= scaleMax; desiredHeight *= scaleMax; }\r\n\r\n\t\t\trefX = new svg.Property('refX', refX);\r\n\t\t\trefY = new svg.Property('refY', refY);\r\n\t\t\tif (refX.hasValue() && refY.hasValue()) {\r\n\t\t\t\tctx.translate(-scaleMin * refX.toPixels('x'), -scaleMin * refY.toPixels('y'));\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// align\r\n\t\t\t\tif (align.match(/^xMid/) && ((meetOrSlice == 'meet' && scaleMin == scaleY) || (meetOrSlice == 'slice' && scaleMax == scaleY))) ctx.translate(width / 2.0 - desiredWidth / 2.0, 0);\r\n\t\t\t\tif (align.match(/YMid$/) && ((meetOrSlice == 'meet' && scaleMin == scaleX) || (meetOrSlice == 'slice' && scaleMax == scaleX))) ctx.translate(0, height / 2.0 - desiredHeight / 2.0);\r\n\t\t\t\tif (align.match(/^xMax/) && ((meetOrSlice == 'meet' && scaleMin == scaleY) || (meetOrSlice == 'slice' && scaleMax == scaleY))) ctx.translate(width - desiredWidth, 0);\r\n\t\t\t\tif (align.match(/YMax$/) && ((meetOrSlice == 'meet' && scaleMin == scaleX) || (meetOrSlice == 'slice' && scaleMax == scaleX))) ctx.translate(0, height - desiredHeight);\r\n\t\t\t}\r\n\r\n\t\t\t// scale\r\n\t\t\tif (align == 'none') ctx.scale(scaleX, scaleY);\r\n\t\t\telse if (meetOrSlice == 'meet') ctx.scale(scaleMin, scaleMin);\r\n\t\t\telse if (meetOrSlice == 'slice') ctx.scale(scaleMax, scaleMax);\r\n\r\n\t\t\t// translate\r\n\t\t\tctx.translate(minX == null ? 0 : -minX, minY == null ? 0 : -minY);\r\n\t\t}\r\n\r\n\t\t// elements\r\n\t\tsvg.Element = {}\r\n\r\n\t\tsvg.EmptyProperty = new svg.Property('EMPTY', '');\r\n\r\n\t\tsvg.Element.ElementBase = function(node) {\r\n\t\t\tthis.attributes = {};\r\n\t\t\tthis.styles = {};\r\n\t\t\tthis.stylesSpecificity = {};\r\n\t\t\tthis.children = [];\r\n\r\n\t\t\t// get or create attribute\r\n\t\t\tthis.attribute = function(name, createIfNotExists) {\r\n\t\t\t\tvar a = this.attributes[name];\r\n\t\t\t\tif (a != null) return a;\r\n\r\n\t\t\t\tif (createIfNotExists == true) { a = new svg.Property(name, ''); this.attributes[name] = a; }\r\n\t\t\t\treturn a || svg.EmptyProperty;\r\n\t\t\t}\r\n\r\n\t\t\tthis.getHrefAttribute = function() {\r\n\t\t\t\tfor (var a in this.attributes) {\r\n\t\t\t\t\tif (a == 'href' || a.match(/:href$/)) {\r\n\t\t\t\t\t\treturn this.attributes[a];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn svg.EmptyProperty;\r\n\t\t\t}\r\n\r\n\t\t\t// get or create style, crawls up node tree\r\n\t\t\tthis.style = function(name, createIfNotExists, skipAncestors) {\r\n\t\t\t\tvar s = this.styles[name];\r\n\t\t\t\tif (s != null) return s;\r\n\r\n\t\t\t\tvar a = this.attribute(name);\r\n\t\t\t\tif (a != null && a.hasValue()) {\r\n\t\t\t\t\tthis.styles[name] = a; // move up to me to cache\r\n\t\t\t\t\treturn a;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (skipAncestors != true) {\r\n\t\t\t\t\tvar p = this.parent;\r\n\t\t\t\t\tif (p != null) {\r\n\t\t\t\t\t\tvar ps = p.style(name);\r\n\t\t\t\t\t\tif (ps != null && ps.hasValue()) {\r\n\t\t\t\t\t\t\treturn ps;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (createIfNotExists == true) { s = new svg.Property(name, ''); this.styles[name] = s; }\r\n\t\t\t\treturn s || svg.EmptyProperty;\r\n\t\t\t}\r\n\r\n\t\t\t// base render\r\n\t\t\tthis.render = function(ctx) {\r\n\t\t\t\t// don't render display=none\r\n\t\t\t\tif (this.style('display').value == 'none') return;\r\n\r\n\t\t\t\t// don't render visibility=hidden\r\n\t\t\t\tif (this.style('visibility').value == 'hidden') return;\r\n\r\n\t\t\t\tctx.save();\r\n\t\t\t\tif (this.style('mask').hasValue()) { // mask\r\n\t\t\t\t\tvar mask = this.style('mask').getDefinition();\r\n\t\t\t\t\tif (mask != null) mask.apply(ctx, this);\r\n\t\t\t\t}\r\n\t\t\t\telse if (this.style('filter').hasValue()) { // filter\r\n\t\t\t\t\tvar filter = this.style('filter').getDefinition();\r\n\t\t\t\t\tif (filter != null) filter.apply(ctx, this);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tthis.setContext(ctx);\r\n\t\t\t\t\tthis.renderChildren(ctx);\r\n\t\t\t\t\tthis.clearContext(ctx);\r\n\t\t\t\t}\r\n\t\t\t\tctx.restore();\r\n\t\t\t}\r\n\r\n\t\t\t// base set context\r\n\t\t\tthis.setContext = function(ctx) {\r\n\t\t\t\t// OVERRIDE ME!\r\n\t\t\t}\r\n\r\n\t\t\t// base clear context\r\n\t\t\tthis.clearContext = function(ctx) {\r\n\t\t\t\t// OVERRIDE ME!\r\n\t\t\t}\r\n\r\n\t\t\t// base render children\r\n\t\t\tthis.renderChildren = function(ctx) {\r\n\t\t\t\tfor (var i=0; i<this.children.length; i++) {\r\n\t\t\t\t\tthis.children[i].render(ctx);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tthis.addChild = function(childNode, create) {\r\n\t\t\t\tvar child = childNode;\r\n\t\t\t\tif (create) child = svg.CreateElement(childNode);\r\n\t\t\t\tchild.parent = this;\r\n\t\t\t\tif (child.type != 'title') { this.children.push(child);\t}\r\n\t\t\t}\r\n\r\n\t\t\tthis.addStylesFromStyleDefinition = function () {\r\n\t\t\t\t// add styles\r\n\t\t\t\tfor (var selector in svg.Styles) {\r\n\t\t\t\t\tif (selector[0] != '@' && matchesSelector(node, selector)) {\r\n\t\t\t\t\t\tvar styles = svg.Styles[selector];\r\n\t\t\t\t\t\tvar specificity = svg.StylesSpecificity[selector];\r\n\t\t\t\t\t\tif (styles != null) {\r\n\t\t\t\t\t\t\tfor (var name in styles) {\r\n\t\t\t\t\t\t\t\tvar existingSpecificity = this.stylesSpecificity[name];\r\n\t\t\t\t\t\t\t\tif (typeof existingSpecificity == 'undefined') {\r\n\t\t\t\t\t\t\t\t\texistingSpecificity = '000';\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tif (specificity > existingSpecificity) {\r\n\t\t\t\t\t\t\t\t\tthis.styles[name] = styles[name];\r\n\t\t\t\t\t\t\t\t\tthis.stylesSpecificity[name] = specificity;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\t\r\n\t\t\t// Microsoft Edge fix\r\n\t\t\tvar allUppercase = new RegExp(\"^[A-Z\\-]+$\");\r\n\t\t\tvar normalizeAttributeName = function (name) {\r\n\t\t\t\tif (allUppercase.test(name)) {\r\n\t\t\t\t\treturn name.toLowerCase();\r\n\t\t\t\t}\r\n\t\t\t\treturn name;\r\n\t\t\t};\r\n\r\n\t\t\tif (node != null && node.nodeType == 1) { //ELEMENT_NODE\r\n\t\t\t\t// add attributes\r\n\t\t\t\tfor (var i=0; i<node.attributes.length; i++) {\r\n\t\t\t\t\tvar attribute = node.attributes[i];\r\n\t\t\t\t\tvar nodeName = normalizeAttributeName(attribute.nodeName);\r\n\t\t\t\t\tthis.attributes[nodeName] = new svg.Property(nodeName, attribute.value);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.addStylesFromStyleDefinition();\r\n\r\n\t\t\t\t// add inline styles\r\n\t\t\t\tif (this.attribute('style').hasValue()) {\r\n\t\t\t\t\tvar styles = this.attribute('style').value.split(';');\r\n\t\t\t\t\tfor (var i=0; i<styles.length; i++) {\r\n\t\t\t\t\t\tif (svg.trim(styles[i]) != '') {\r\n\t\t\t\t\t\t\tvar style = styles[i].split(':');\r\n\t\t\t\t\t\t\tvar name = svg.trim(style[0]);\r\n\t\t\t\t\t\t\tvar value = svg.trim(style[1]);\r\n\t\t\t\t\t\t\tthis.styles[name] = new svg.Property(name, value);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// add id\r\n\t\t\t\tif (this.attribute('id').hasValue()) {\r\n\t\t\t\t\tif (svg.Definitions[this.attribute('id').value] == null) {\r\n\t\t\t\t\t\tsvg.Definitions[this.attribute('id').value] = this;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// add children\r\n\t\t\t\tfor (var i=0; i<node.childNodes.length; i++) {\r\n\t\t\t\t\tvar childNode = node.childNodes[i];\r\n\t\t\t\t\tif (childNode.nodeType == 1) this.addChild(childNode, true); //ELEMENT_NODE\r\n\t\t\t\t\tif (this.captureTextNodes && (childNode.nodeType == 3 || childNode.nodeType == 4)) {\r\n\t\t\t\t\t\tvar text = childNode.value || childNode.text || childNode.textContent || '';\r\n\t\t\t\t\t\tif (svg.compressSpaces(text) != '') {\r\n\t\t\t\t\t\t\tthis.addChild(new svg.Element.tspan(childNode), false); // TEXT_NODE\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tsvg.Element.RenderedElementBase = function(node) {\r\n\t\t\tthis.base = svg.Element.ElementBase;\r\n\t\t\tthis.base(node);\r\n\r\n\t\t\tthis.setContext = function(ctx) {\r\n\t\t\t\t// fill\r\n\t\t\t\tif (this.style('fill').isUrlDefinition()) {\r\n\t\t\t\t\tvar fs = this.style('fill').getFillStyleDefinition(this, this.style('fill-opacity'));\r\n\t\t\t\t\tif (fs != null) ctx.fillStyle = fs;\r\n\t\t\t\t}\r\n\t\t\t\telse if (this.style('fill').hasValue()) {\r\n\t\t\t\t\tvar fillStyle = this.style('fill');\r\n\t\t\t\t\tif (fillStyle.value == 'currentColor') fillStyle.value = this.style('color').value;\r\n\t\t\t\t\tif (fillStyle.value != 'inherit') ctx.fillStyle = (fillStyle.value == 'none' ? 'rgba(0,0,0,0)' : fillStyle.value);\r\n\t\t\t\t}\r\n\t\t\t\tif (this.style('fill-opacity').hasValue()) {\r\n\t\t\t\t\tvar fillStyle = new svg.Property('fill', ctx.fillStyle);\r\n\t\t\t\t\tfillStyle = fillStyle.addOpacity(this.style('fill-opacity'));\r\n\t\t\t\t\tctx.fillStyle = fillStyle.value;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// stroke\r\n\t\t\t\tif (this.style('stroke').isUrlDefinition()) {\r\n\t\t\t\t\tvar fs = this.style('stroke').getFillStyleDefinition(this, this.style('stroke-opacity'));\r\n\t\t\t\t\tif (fs != null) ctx.strokeStyle = fs;\r\n\t\t\t\t}\r\n\t\t\t\telse if (this.style('stroke').hasValue()) {\r\n\t\t\t\t\tvar strokeStyle = this.style('stroke');\r\n\t\t\t\t\tif (strokeStyle.value == 'currentColor') strokeStyle.value = this.style('color').value;\r\n\t\t\t\t\tif (strokeStyle.value != 'inherit') ctx.strokeStyle = (strokeStyle.value == 'none' ? 'rgba(0,0,0,0)' : strokeStyle.value);\r\n\t\t\t\t}\r\n\t\t\t\tif (this.style('stroke-opacity').hasValue()) {\r\n\t\t\t\t\tvar strokeStyle = new svg.Property('stroke', ctx.strokeStyle);\r\n\t\t\t\t\tstrokeStyle = strokeStyle.addOpacity(this.style('stroke-opacity'));\r\n\t\t\t\t\tctx.strokeStyle = strokeStyle.value;\r\n\t\t\t\t}\r\n\t\t\t\tif (this.style('stroke-width').hasValue()) {\r\n\t\t\t\t\tvar newLineWidth = this.style('stroke-width').toPixels();\r\n\t\t\t\t\tctx.lineWidth = newLineWidth == 0 ? 0.001 : newLineWidth; // browsers don't respect 0\r\n\t\t\t    }\r\n\t\t\t\tif (this.style('stroke-linecap').hasValue()) ctx.lineCap = this.style('stroke-linecap').value;\r\n\t\t\t\tif (this.style('stroke-linejoin').hasValue()) ctx.lineJoin = this.style('stroke-linejoin').value;\r\n\t\t\t\tif (this.style('stroke-miterlimit').hasValue()) ctx.miterLimit = this.style('stroke-miterlimit').value;\r\n\t\t\t\tif (this.style('stroke-dasharray').hasValue() && this.style('stroke-dasharray').value != 'none') {\r\n\t\t\t\t\tvar gaps = svg.ToNumberArray(this.style('stroke-dasharray').value);\r\n\t\t\t\t\tif (typeof ctx.setLineDash != 'undefined') { ctx.setLineDash(gaps); }\r\n\t\t\t\t\telse if (typeof ctx.webkitLineDash != 'undefined') { ctx.webkitLineDash = gaps; }\r\n\t\t\t\t\telse if (typeof ctx.mozDash != 'undefined' && !(gaps.length==1 && gaps[0]==0)) { ctx.mozDash = gaps; }\r\n\r\n\t\t\t\t\tvar offset = this.style('stroke-dashoffset').numValueOrDefault(1);\r\n\t\t\t\t\tif (typeof ctx.lineDashOffset != 'undefined') { ctx.lineDashOffset = offset; }\r\n\t\t\t\t\telse if (typeof ctx.webkitLineDashOffset != 'undefined') { ctx.webkitLineDashOffset = offset; }\r\n\t\t\t\t\telse if (typeof ctx.mozDashOffset != 'undefined') { ctx.mozDashOffset = offset; }\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// font\r\n\t\t\t\tif (typeof ctx.font != 'undefined') {\r\n\t\t\t\t\tctx.font = svg.Font.CreateFont(\r\n\t\t\t\t\t\tthis.style('font-style').value,\r\n\t\t\t\t\t\tthis.style('font-variant').value,\r\n\t\t\t\t\t\tthis.style('font-weight').value,\r\n\t\t\t\t\t\tthis.style('font-size').hasValue() ? this.style('font-size').toPixels() + 'px' : '',\r\n\t\t\t\t\t\tthis.style('font-family').value).toString();\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// transform\r\n\t\t\t\tif (this.style('transform', false, true).hasValue()) {\r\n\t\t\t\t\tvar transform = new svg.Transform(this.style('transform', false, true).value);\r\n\t\t\t\t\ttransform.apply(ctx);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// clip\r\n\t\t\t\tif (this.style('clip-path', false, true).hasValue()) {\r\n\t\t\t\t\tvar clip = this.style('clip-path', false, true).getDefinition();\r\n\t\t\t\t\tif (clip != null) clip.apply(ctx);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// opacity\r\n\t\t\t\tif (this.style('opacity').hasValue()) {\r\n\t\t\t\t\tctx.globalAlpha = this.style('opacity').numValue();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tsvg.Element.RenderedElementBase.prototype = new svg.Element.ElementBase;\r\n\r\n\t\tsvg.Element.PathElementBase = function(node) {\r\n\t\t\tthis.base = svg.Element.RenderedElementBase;\r\n\t\t\tthis.base(node);\r\n\r\n\t\t\tthis.path = function(ctx) {\r\n\t\t\t\tif (ctx != null) ctx.beginPath();\r\n\t\t\t\treturn new svg.BoundingBox();\r\n\t\t\t}\r\n\r\n\t\t\tthis.renderChildren = function(ctx) {\r\n\t\t\t\tthis.path(ctx);\r\n\t\t\t\tsvg.Mouse.checkPath(this, ctx);\r\n\t\t\t\tif (ctx.fillStyle != '') {\r\n\t\t\t\t\tif (this.style('fill-rule').valueOrDefault('inherit') != 'inherit') { ctx.fill(this.style('fill-rule').value); }\r\n\t\t\t\t\telse { ctx.fill(); }\r\n\t\t\t\t}\r\n\t\t\t\tif (ctx.strokeStyle != '') ctx.stroke();\r\n\r\n\t\t\t\tvar markers = this.getMarkers();\r\n\t\t\t\tif (markers != null) {\r\n\t\t\t\t\tif (this.style('marker-start').isUrlDefinition()) {\r\n\t\t\t\t\t\tvar marker = this.style('marker-start').getDefinition();\r\n\t\t\t\t\t\tmarker.render(ctx, markers[0][0], markers[0][1]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (this.style('marker-mid').isUrlDefinition()) {\r\n\t\t\t\t\t\tvar marker = this.style('marker-mid').getDefinition();\r\n\t\t\t\t\t\tfor (var i=1;i<markers.length-1;i++) {\r\n\t\t\t\t\t\t\tmarker.render(ctx, markers[i][0], markers[i][1]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (this.style('marker-end').isUrlDefinition()) {\r\n\t\t\t\t\t\tvar marker = this.style('marker-end').getDefinition();\r\n\t\t\t\t\t\tmarker.render(ctx, markers[markers.length-1][0], markers[markers.length-1][1]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tthis.getBoundingBox = function() {\r\n\t\t\t\treturn this.path();\r\n\t\t\t}\r\n\r\n\t\t\tthis.getMarkers = function() {\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t}\r\n\t\tsvg.Element.PathElementBase.prototype = new svg.Element.RenderedElementBase;\r\n\r\n\t\t// svg element\r\n\t\tsvg.Element.svg = function(node) {\r\n\t\t\tthis.base = svg.Element.RenderedElementBase;\r\n\t\t\tthis.base(node);\r\n\r\n\t\t\tthis.baseClearContext = this.clearContext;\r\n\t\t\tthis.clearContext = function(ctx) {\r\n\t\t\t\tthis.baseClearContext(ctx);\r\n\t\t\t\tsvg.ViewPort.RemoveCurrent();\r\n\t\t\t}\r\n\r\n\t\t\tthis.baseSetContext = this.setContext;\r\n\t\t\tthis.setContext = function(ctx) {\r\n\t\t\t\t// initial values and defaults\r\n\t\t\t\tctx.strokeStyle = 'rgba(0,0,0,0)';\r\n\t\t\t\tctx.lineCap = 'butt';\r\n\t\t\t\tctx.lineJoin = 'miter';\r\n\t\t\t\tctx.miterLimit = 4;\r\n\t\t\t\tif (typeof ctx.font != 'undefined' && typeof window.getComputedStyle != 'undefined') {\r\n\t\t\t\t\tctx.font = window.getComputedStyle(ctx.canvas).getPropertyValue('font');\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.baseSetContext(ctx);\r\n\r\n\t\t\t\t// create new view port\r\n\t\t\t\tif (!this.attribute('x').hasValue()) this.attribute('x', true).value = 0;\r\n\t\t\t\tif (!this.attribute('y').hasValue()) this.attribute('y', true).value = 0;\r\n\t\t\t\tctx.translate(this.attribute('x').toPixels('x'), this.attribute('y').toPixels('y'));\r\n\r\n\t\t\t\tvar width = svg.ViewPort.width();\r\n\t\t\t\tvar height = svg.ViewPort.height();\r\n\r\n\t\t\t\tif (!this.attribute('width').hasValue()) this.attribute('width', true).value = '100%';\r\n\t\t\t\tif (!this.attribute('height').hasValue()) this.attribute('height', true).value = '100%';\r\n\t\t\t\tif (typeof this.root == 'undefined') {\r\n\t\t\t\t\twidth = this.attribute('width').toPixels('x');\r\n\t\t\t\t\theight = this.attribute('height').toPixels('y');\r\n\r\n\t\t\t\t\tvar x = 0;\r\n\t\t\t\t\tvar y = 0;\r\n\t\t\t\t\tif (this.attribute('refX').hasValue() && this.attribute('refY').hasValue()) {\r\n\t\t\t\t\t\tx = -this.attribute('refX').toPixels('x');\r\n\t\t\t\t\t\ty = -this.attribute('refY').toPixels('y');\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (this.attribute('overflow').valueOrDefault('hidden') != 'visible') {\r\n\t\t\t\t\t\tctx.beginPath();\r\n\t\t\t\t\t\tctx.moveTo(x, y);\r\n\t\t\t\t\t\tctx.lineTo(width, y);\r\n\t\t\t\t\t\tctx.lineTo(width, height);\r\n\t\t\t\t\t\tctx.lineTo(x, height);\r\n\t\t\t\t\t\tctx.closePath();\r\n\t\t\t\t\t\tctx.clip();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tsvg.ViewPort.SetCurrent(width, height);\r\n\r\n\t\t\t\t// viewbox\r\n\t\t\t\tif (this.attribute('viewBox').hasValue()) {\r\n\t\t\t\t\tvar viewBox = svg.ToNumberArray(this.attribute('viewBox').value);\r\n\t\t\t\t\tvar minX = viewBox[0];\r\n\t\t\t\t\tvar minY = viewBox[1];\r\n\t\t\t\t\twidth = viewBox[2];\r\n\t\t\t\t\theight = viewBox[3];\r\n\r\n\t\t\t\t\tsvg.AspectRatio(ctx,\r\n\t\t\t\t\t\t\t\t\tthis.attribute('preserveAspectRatio').value,\r\n\t\t\t\t\t\t\t\t\tsvg.ViewPort.width(),\r\n\t\t\t\t\t\t\t\t\twidth,\r\n\t\t\t\t\t\t\t\t\tsvg.ViewPort.height(),\r\n\t\t\t\t\t\t\t\t\theight,\r\n\t\t\t\t\t\t\t\t\tminX,\r\n\t\t\t\t\t\t\t\t\tminY,\r\n\t\t\t\t\t\t\t\t\tthis.attribute('refX').value,\r\n\t\t\t\t\t\t\t\t\tthis.attribute('refY').value);\r\n\r\n\t\t\t\t\tsvg.ViewPort.RemoveCurrent();\r\n\t\t\t\t\tsvg.ViewPort.SetCurrent(viewBox[2], viewBox[3]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tsvg.Element.svg.prototype = new svg.Element.RenderedElementBase;\r\n\r\n\t\t// rect element\r\n\t\tsvg.Element.rect = function(node) {\r\n\t\t\tthis.base = svg.Element.PathElementBase;\r\n\t\t\tthis.base(node);\r\n\r\n\t\t\tthis.path = function(ctx) {\r\n\t\t\t\tvar x = this.attribute('x').toPixels('x');\r\n\t\t\t\tvar y = this.attribute('y').toPixels('y');\r\n\t\t\t\tvar width = this.attribute('width').toPixels('x');\r\n\t\t\t\tvar height = this.attribute('height').toPixels('y');\r\n\t\t\t\tvar rx = this.attribute('rx').toPixels('x');\r\n\t\t\t\tvar ry = this.attribute('ry').toPixels('y');\r\n\t\t\t\tif (this.attribute('rx').hasValue() && !this.attribute('ry').hasValue()) ry = rx;\r\n\t\t\t\tif (this.attribute('ry').hasValue() && !this.attribute('rx').hasValue()) rx = ry;\r\n\t\t\t\trx = Math.min(rx, width / 2.0);\r\n\t\t\t\try = Math.min(ry, height / 2.0);\r\n\t\t\t\tif (ctx != null) {\r\n\t\t\t\t\tctx.beginPath();\r\n\t\t\t\t\tctx.moveTo(x + rx, y);\r\n\t\t\t\t\tctx.lineTo(x + width - rx, y);\r\n\t\t\t\t\tctx.quadraticCurveTo(x + width, y, x + width, y + ry)\r\n\t\t\t\t\tctx.lineTo(x + width, y + height - ry);\r\n\t\t\t\t\tctx.quadraticCurveTo(x + width, y + height, x + width - rx, y + height)\r\n\t\t\t\t\tctx.lineTo(x + rx, y + height);\r\n\t\t\t\t\tctx.quadraticCurveTo(x, y + height, x, y + height - ry)\r\n\t\t\t\t\tctx.lineTo(x, y + ry);\r\n\t\t\t\t\tctx.quadraticCurveTo(x, y, x + rx, y)\r\n\t\t\t\t\tctx.closePath();\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn new svg.BoundingBox(x, y, x + width, y + height);\r\n\t\t\t}\r\n\t\t}\r\n\t\tsvg.Element.rect.prototype = new svg.Element.PathElementBase;\r\n\r\n\t\t// circle element\r\n\t\tsvg.Element.circle = function(node) {\r\n\t\t\tthis.base = svg.Element.PathElementBase;\r\n\t\t\tthis.base(node);\r\n\r\n\t\t\tthis.path = function(ctx) {\r\n\t\t\t\tvar cx = this.attribute('cx').toPixels('x');\r\n\t\t\t\tvar cy = this.attribute('cy').toPixels('y');\r\n\t\t\t\tvar r = this.attribute('r').toPixels();\r\n\r\n\t\t\t\tif (ctx != null) {\r\n\t\t\t\t\tctx.beginPath();\r\n\t\t\t\t\tctx.arc(cx, cy, r, 0, Math.PI * 2, true);\r\n\t\t\t\t\tctx.closePath();\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn new svg.BoundingBox(cx - r, cy - r, cx + r, cy + r);\r\n\t\t\t}\r\n\t\t}\r\n\t\tsvg.Element.circle.prototype = new svg.Element.PathElementBase;\r\n\r\n\t\t// ellipse element\r\n\t\tsvg.Element.ellipse = function(node) {\r\n\t\t\tthis.base = svg.Element.PathElementBase;\r\n\t\t\tthis.base(node);\r\n\r\n\t\t\tthis.path = function(ctx) {\r\n\t\t\t\tvar KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);\r\n\t\t\t\tvar rx = this.attribute('rx').toPixels('x');\r\n\t\t\t\tvar ry = this.attribute('ry').toPixels('y');\r\n\t\t\t\tvar cx = this.attribute('cx').toPixels('x');\r\n\t\t\t\tvar cy = this.attribute('cy').toPixels('y');\r\n\r\n\t\t\t\tif (ctx != null) {\r\n\t\t\t\t\tctx.beginPath();\r\n\t\t\t\t\tctx.moveTo(cx, cy - ry);\r\n\t\t\t\t\tctx.bezierCurveTo(cx + (KAPPA * rx), cy - ry,  cx + rx, cy - (KAPPA * ry), cx + rx, cy);\r\n\t\t\t\t\tctx.bezierCurveTo(cx + rx, cy + (KAPPA * ry), cx + (KAPPA * rx), cy + ry, cx, cy + ry);\r\n\t\t\t\t\tctx.bezierCurveTo(cx - (KAPPA * rx), cy + ry, cx - rx, cy + (KAPPA * ry), cx - rx, cy);\r\n\t\t\t\t\tctx.bezierCurveTo(cx - rx, cy - (KAPPA * ry), cx - (KAPPA * rx), cy - ry, cx, cy - ry);\r\n\t\t\t\t\tctx.closePath();\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn new svg.BoundingBox(cx - rx, cy - ry, cx + rx, cy + ry);\r\n\t\t\t}\r\n\t\t}\r\n\t\tsvg.Element.ellipse.prototype = new svg.Element.PathElementBase;\r\n\r\n\t\t// line element\r\n\t\tsvg.Element.line = function(node) {\r\n\t\t\tthis.base = svg.Element.PathElementBase;\r\n\t\t\tthis.base(node);\r\n\r\n\t\t\tthis.getPoints = function() {\r\n\t\t\t\treturn [\r\n\t\t\t\t\tnew svg.Point(this.attribute('x1').toPixels('x'), this.attribute('y1').toPixels('y')),\r\n\t\t\t\t\tnew svg.Point(this.attribute('x2').toPixels('x'), this.attribute('y2').toPixels('y'))];\r\n\t\t\t}\r\n\r\n\t\t\tthis.path = function(ctx) {\r\n\t\t\t\tvar points = this.getPoints();\r\n\r\n\t\t\t\tif (ctx != null) {\r\n\t\t\t\t\tctx.beginPath();\r\n\t\t\t\t\tctx.moveTo(points[0].x, points[0].y);\r\n\t\t\t\t\tctx.lineTo(points[1].x, points[1].y);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn new svg.BoundingBox(points[0].x, points[0].y, points[1].x, points[1].y);\r\n\t\t\t}\r\n\r\n\t\t\tthis.getMarkers = function() {\r\n\t\t\t\tvar points = this.getPoints();\r\n\t\t\t\tvar a = points[0].angleTo(points[1]);\r\n\t\t\t\treturn [[points[0], a], [points[1], a]];\r\n\t\t\t}\r\n\t\t}\r\n\t\tsvg.Element.line.prototype = new svg.Element.PathElementBase;\r\n\r\n\t\t// polyline element\r\n\t\tsvg.Element.polyline = function(node) {\r\n\t\t\tthis.base = svg.Element.PathElementBase;\r\n\t\t\tthis.base(node);\r\n\r\n\t\t\tthis.points = svg.CreatePath(this.attribute('points').value);\r\n\t\t\tthis.path = function(ctx) {\r\n\t\t\t\tvar bb = new svg.BoundingBox(this.points[0].x, this.points[0].y);\r\n\t\t\t\tif (ctx != null) {\r\n\t\t\t\t\tctx.beginPath();\r\n\t\t\t\t\tctx.moveTo(this.points[0].x, this.points[0].y);\r\n\t\t\t\t}\r\n\t\t\t\tfor (var i=1; i<this.points.length; i++) {\r\n\t\t\t\t\tbb.addPoint(this.points[i].x, this.points[i].y);\r\n\t\t\t\t\tif (ctx != null) ctx.lineTo(this.points[i].x, this.points[i].y);\r\n\t\t\t\t}\r\n\t\t\t\treturn bb;\r\n\t\t\t}\r\n\r\n\t\t\tthis.getMarkers = function() {\r\n\t\t\t\tvar markers = [];\r\n\t\t\t\tfor (var i=0; i<this.points.length - 1; i++) {\r\n\t\t\t\t\tmarkers.push([this.points[i], this.points[i].angleTo(this.points[i+1])]);\r\n\t\t\t\t}\r\n\t\t\t\tif (markers.length > 0) {\r\n\t\t\t\t\tmarkers.push([this.points[this.points.length-1], markers[markers.length-1][1]]);\r\n\t\t\t\t}\r\n\t\t\t\treturn markers;\r\n\t\t\t}\r\n\t\t}\r\n\t\tsvg.Element.polyline.prototype = new svg.Element.PathElementBase;\r\n\r\n\t\t// polygon element\r\n\t\tsvg.Element.polygon = function(node) {\r\n\t\t\tthis.base = svg.Element.polyline;\r\n\t\t\tthis.base(node);\r\n\r\n\t\t\tthis.basePath = this.path;\r\n\t\t\tthis.path = function(ctx) {\r\n\t\t\t\tvar bb = this.basePath(ctx);\r\n\t\t\t\tif (ctx != null) {\r\n\t\t\t\t\tctx.lineTo(this.points[0].x, this.points[0].y);\r\n\t\t\t\t\tctx.closePath();\r\n\t\t\t\t}\r\n\t\t\t\treturn bb;\r\n\t\t\t}\r\n\t\t}\r\n\t\tsvg.Element.polygon.prototype = new svg.Element.polyline;\r\n\r\n\t\t// path element\r\n\t\tsvg.Element.path = function(node) {\r\n\t\t\tthis.base = svg.Element.PathElementBase;\r\n\t\t\tthis.base(node);\r\n\r\n\t\t\tvar d = this.attribute('d').value;\r\n\t\t\t// TODO: convert to real lexer based on http://www.w3.org/TR/SVG11/paths.html#PathDataBNF\r\n\t\t\td = d.replace(/,/gm,' '); // get rid of all commas\r\n\t\t\t// As the end of a match can also be the start of the next match, we need to run this replace twice.\r\n\t\t\tfor(var i=0; i<2; i++)\r\n\t\t\t\td = d.replace(/([MmZzLlHhVvCcSsQqTtAa])([^\\s])/gm,'$1 $2'); // suffix commands with spaces\r\n\t\t\td = d.replace(/([^\\s])([MmZzLlHhVvCcSsQqTtAa])/gm,'$1 $2'); // prefix commands with spaces\r\n\t\t\td = d.replace(/([0-9])([+\\-])/gm,'$1 $2'); // separate digits on +- signs\r\n\t\t\t// Again, we need to run this twice to find all occurances\r\n\t\t\tfor(var i=0; i<2; i++)\r\n\t\t\t\td = d.replace(/(\\.[0-9]*)(\\.)/gm,'$1 $2'); // separate digits when they start with a comma\r\n\t\t\td = d.replace(/([Aa](\\s+[0-9]+){3})\\s+([01])\\s*([01])/gm,'$1 $3 $4 '); // shorthand elliptical arc path syntax\r\n\t\t\td = svg.compressSpaces(d); // compress multiple spaces\r\n\t\t\td = svg.trim(d);\r\n\t\t\tthis.PathParser = new (function(d) {\r\n\t\t\t\tthis.tokens = d.split(' ');\r\n\r\n\t\t\t\tthis.reset = function() {\r\n\t\t\t\t\tthis.i = -1;\r\n\t\t\t\t\tthis.command = '';\r\n\t\t\t\t\tthis.previousCommand = '';\r\n\t\t\t\t\tthis.start = new svg.Point(0, 0);\r\n\t\t\t\t\tthis.control = new svg.Point(0, 0);\r\n\t\t\t\t\tthis.current = new svg.Point(0, 0);\r\n\t\t\t\t\tthis.points = [];\r\n\t\t\t\t\tthis.angles = [];\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.isEnd = function() {\r\n\t\t\t\t\treturn this.i >= this.tokens.length - 1;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.isCommandOrEnd = function() {\r\n\t\t\t\t\tif (this.isEnd()) return true;\r\n\t\t\t\t\treturn this.tokens[this.i + 1].match(/^[A-Za-z]$/) != null;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.isRelativeCommand = function() {\r\n\t\t\t\t\tswitch(this.command)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcase 'm':\r\n\t\t\t\t\t\tcase 'l':\r\n\t\t\t\t\t\tcase 'h':\r\n\t\t\t\t\t\tcase 'v':\r\n\t\t\t\t\t\tcase 'c':\r\n\t\t\t\t\t\tcase 's':\r\n\t\t\t\t\t\tcase 'q':\r\n\t\t\t\t\t\tcase 't':\r\n\t\t\t\t\t\tcase 'a':\r\n\t\t\t\t\t\tcase 'z':\r\n\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.getToken = function() {\r\n\t\t\t\t\tthis.i++;\r\n\t\t\t\t\treturn this.tokens[this.i];\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.getScalar = function() {\r\n\t\t\t\t\treturn parseFloat(this.getToken());\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.nextCommand = function() {\r\n\t\t\t\t\tthis.previousCommand = this.command;\r\n\t\t\t\t\tthis.command = this.getToken();\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.getPoint = function() {\r\n\t\t\t\t\tvar p = new svg.Point(this.getScalar(), this.getScalar());\r\n\t\t\t\t\treturn this.makeAbsolute(p);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.getAsControlPoint = function() {\r\n\t\t\t\t\tvar p = this.getPoint();\r\n\t\t\t\t\tthis.control = p;\r\n\t\t\t\t\treturn p;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.getAsCurrentPoint = function() {\r\n\t\t\t\t\tvar p = this.getPoint();\r\n\t\t\t\t\tthis.current = p;\r\n\t\t\t\t\treturn p;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.getReflectedControlPoint = function() {\r\n\t\t\t\t\tif (this.previousCommand.toLowerCase() != 'c' &&\r\n\t\t\t\t\t    this.previousCommand.toLowerCase() != 's' &&\r\n\t\t\t\t\t\tthis.previousCommand.toLowerCase() != 'q' &&\r\n\t\t\t\t\t\tthis.previousCommand.toLowerCase() != 't' ){\r\n\t\t\t\t\t\treturn this.current;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// reflect point\r\n\t\t\t\t\tvar p = new svg.Point(2 * this.current.x - this.control.x, 2 * this.current.y - this.control.y);\r\n\t\t\t\t\treturn p;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.makeAbsolute = function(p) {\r\n\t\t\t\t\tif (this.isRelativeCommand()) {\r\n\t\t\t\t\t\tp.x += this.current.x;\r\n\t\t\t\t\t\tp.y += this.current.y;\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn p;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.addMarker = function(p, from, priorTo) {\r\n\t\t\t\t\t// if the last angle isn't filled in because we didn't have this point yet ...\r\n\t\t\t\t\tif (priorTo != null && this.angles.length > 0 && this.angles[this.angles.length-1] == null) {\r\n\t\t\t\t\t\tthis.angles[this.angles.length-1] = this.points[this.points.length-1].angleTo(priorTo);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.addMarkerAngle(p, from == null ? null : from.angleTo(p));\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.addMarkerAngle = function(p, a) {\r\n\t\t\t\t\tthis.points.push(p);\r\n\t\t\t\t\tthis.angles.push(a);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.getMarkerPoints = function() { return this.points; }\r\n\t\t\t\tthis.getMarkerAngles = function() {\r\n\t\t\t\t\tfor (var i=0; i<this.angles.length; i++) {\r\n\t\t\t\t\t\tif (this.angles[i] == null) {\r\n\t\t\t\t\t\t\tfor (var j=i+1; j<this.angles.length; j++) {\r\n\t\t\t\t\t\t\t\tif (this.angles[j] != null) {\r\n\t\t\t\t\t\t\t\t\tthis.angles[i] = this.angles[j];\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn this.angles;\r\n\t\t\t\t}\r\n\t\t\t})(d);\r\n\r\n\t\t\tthis.path = function(ctx) {\r\n\t\t\t\tvar pp = this.PathParser;\r\n\t\t\t\tpp.reset();\r\n\r\n\t\t\t\tvar bb = new svg.BoundingBox();\r\n\t\t\t\tif (ctx != null) ctx.beginPath();\r\n\t\t\t\twhile (!pp.isEnd()) {\r\n\t\t\t\t\tpp.nextCommand();\r\n\t\t\t\t\tswitch (pp.command) {\r\n\t\t\t\t\tcase 'M':\r\n\t\t\t\t\tcase 'm':\r\n\t\t\t\t\t\tvar p = pp.getAsCurrentPoint();\r\n\t\t\t\t\t\tpp.addMarker(p);\r\n\t\t\t\t\t\tbb.addPoint(p.x, p.y);\r\n\t\t\t\t\t\tif (ctx != null) ctx.moveTo(p.x, p.y);\r\n\t\t\t\t\t\tpp.start = pp.current;\r\n\t\t\t\t\t\twhile (!pp.isCommandOrEnd()) {\r\n\t\t\t\t\t\t\tvar p = pp.getAsCurrentPoint();\r\n\t\t\t\t\t\t\tpp.addMarker(p, pp.start);\r\n\t\t\t\t\t\t\tbb.addPoint(p.x, p.y);\r\n\t\t\t\t\t\t\tif (ctx != null) ctx.lineTo(p.x, p.y);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'L':\r\n\t\t\t\t\tcase 'l':\r\n\t\t\t\t\t\twhile (!pp.isCommandOrEnd()) {\r\n\t\t\t\t\t\t\tvar c = pp.current;\r\n\t\t\t\t\t\t\tvar p = pp.getAsCurrentPoint();\r\n\t\t\t\t\t\t\tpp.addMarker(p, c);\r\n\t\t\t\t\t\t\tbb.addPoint(p.x, p.y);\r\n\t\t\t\t\t\t\tif (ctx != null) ctx.lineTo(p.x, p.y);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'H':\r\n\t\t\t\t\tcase 'h':\r\n\t\t\t\t\t\twhile (!pp.isCommandOrEnd()) {\r\n\t\t\t\t\t\t\tvar newP = new svg.Point((pp.isRelativeCommand() ? pp.current.x : 0) + pp.getScalar(), pp.current.y);\r\n\t\t\t\t\t\t\tpp.addMarker(newP, pp.current);\r\n\t\t\t\t\t\t\tpp.current = newP;\r\n\t\t\t\t\t\t\tbb.addPoint(pp.current.x, pp.current.y);\r\n\t\t\t\t\t\t\tif (ctx != null) ctx.lineTo(pp.current.x, pp.current.y);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'V':\r\n\t\t\t\t\tcase 'v':\r\n\t\t\t\t\t\twhile (!pp.isCommandOrEnd()) {\r\n\t\t\t\t\t\t\tvar newP = new svg.Point(pp.current.x, (pp.isRelativeCommand() ? pp.current.y : 0) + pp.getScalar());\r\n\t\t\t\t\t\t\tpp.addMarker(newP, pp.current);\r\n\t\t\t\t\t\t\tpp.current = newP;\r\n\t\t\t\t\t\t\tbb.addPoint(pp.current.x, pp.current.y);\r\n\t\t\t\t\t\t\tif (ctx != null) ctx.lineTo(pp.current.x, pp.current.y);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'C':\r\n\t\t\t\t\tcase 'c':\r\n\t\t\t\t\t\twhile (!pp.isCommandOrEnd()) {\r\n\t\t\t\t\t\t\tvar curr = pp.current;\r\n\t\t\t\t\t\t\tvar p1 = pp.getPoint();\r\n\t\t\t\t\t\t\tvar cntrl = pp.getAsControlPoint();\r\n\t\t\t\t\t\t\tvar cp = pp.getAsCurrentPoint();\r\n\t\t\t\t\t\t\tpp.addMarker(cp, cntrl, p1);\r\n\t\t\t\t\t\t\tbb.addBezierCurve(curr.x, curr.y, p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);\r\n\t\t\t\t\t\t\tif (ctx != null) ctx.bezierCurveTo(p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'S':\r\n\t\t\t\t\tcase 's':\r\n\t\t\t\t\t\twhile (!pp.isCommandOrEnd()) {\r\n\t\t\t\t\t\t\tvar curr = pp.current;\r\n\t\t\t\t\t\t\tvar p1 = pp.getReflectedControlPoint();\r\n\t\t\t\t\t\t\tvar cntrl = pp.getAsControlPoint();\r\n\t\t\t\t\t\t\tvar cp = pp.getAsCurrentPoint();\r\n\t\t\t\t\t\t\tpp.addMarker(cp, cntrl, p1);\r\n\t\t\t\t\t\t\tbb.addBezierCurve(curr.x, curr.y, p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);\r\n\t\t\t\t\t\t\tif (ctx != null) ctx.bezierCurveTo(p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'Q':\r\n\t\t\t\t\tcase 'q':\r\n\t\t\t\t\t\twhile (!pp.isCommandOrEnd()) {\r\n\t\t\t\t\t\t\tvar curr = pp.current;\r\n\t\t\t\t\t\t\tvar cntrl = pp.getAsControlPoint();\r\n\t\t\t\t\t\t\tvar cp = pp.getAsCurrentPoint();\r\n\t\t\t\t\t\t\tpp.addMarker(cp, cntrl, cntrl);\r\n\t\t\t\t\t\t\tbb.addQuadraticCurve(curr.x, curr.y, cntrl.x, cntrl.y, cp.x, cp.y);\r\n\t\t\t\t\t\t\tif (ctx != null) ctx.quadraticCurveTo(cntrl.x, cntrl.y, cp.x, cp.y);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'T':\r\n\t\t\t\t\tcase 't':\r\n\t\t\t\t\t\twhile (!pp.isCommandOrEnd()) {\r\n\t\t\t\t\t\t\tvar curr = pp.current;\r\n\t\t\t\t\t\t\tvar cntrl = pp.getReflectedControlPoint();\r\n\t\t\t\t\t\t\tpp.control = cntrl;\r\n\t\t\t\t\t\t\tvar cp = pp.getAsCurrentPoint();\r\n\t\t\t\t\t\t\tpp.addMarker(cp, cntrl, cntrl);\r\n\t\t\t\t\t\t\tbb.addQuadraticCurve(curr.x, curr.y, cntrl.x, cntrl.y, cp.x, cp.y);\r\n\t\t\t\t\t\t\tif (ctx != null) ctx.quadraticCurveTo(cntrl.x, cntrl.y, cp.x, cp.y);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'A':\r\n\t\t\t\t\tcase 'a':\r\n\t\t\t\t\t\twhile (!pp.isCommandOrEnd()) {\r\n\t\t\t\t\t\t    var curr = pp.current;\r\n\t\t\t\t\t\t\tvar rx = pp.getScalar();\r\n\t\t\t\t\t\t\tvar ry = pp.getScalar();\r\n\t\t\t\t\t\t\tvar xAxisRotation = pp.getScalar() * (Math.PI / 180.0);\r\n\t\t\t\t\t\t\tvar largeArcFlag = pp.getScalar();\r\n\t\t\t\t\t\t\tvar sweepFlag = pp.getScalar();\r\n\t\t\t\t\t\t\tvar cp = pp.getAsCurrentPoint();\r\n\r\n\t\t\t\t\t\t\t// Conversion from endpoint to center parameterization\r\n\t\t\t\t\t\t\t// http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\r\n\t\t\t\t\t\t\t// x1', y1'\r\n\t\t\t\t\t\t\tvar currp = new svg.Point(\r\n\t\t\t\t\t\t\t\tMath.cos(xAxisRotation) * (curr.x - cp.x) / 2.0 + Math.sin(xAxisRotation) * (curr.y - cp.y) / 2.0,\r\n\t\t\t\t\t\t\t\t-Math.sin(xAxisRotation) * (curr.x - cp.x) / 2.0 + Math.cos(xAxisRotation) * (curr.y - cp.y) / 2.0\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t// adjust radii\r\n\t\t\t\t\t\t\tvar l = Math.pow(currp.x,2)/Math.pow(rx,2)+Math.pow(currp.y,2)/Math.pow(ry,2);\r\n\t\t\t\t\t\t\tif (l > 1) {\r\n\t\t\t\t\t\t\t\trx *= Math.sqrt(l);\r\n\t\t\t\t\t\t\t\try *= Math.sqrt(l);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t// cx', cy'\r\n\t\t\t\t\t\t\tvar s = (largeArcFlag == sweepFlag ? -1 : 1) * Math.sqrt(\r\n\t\t\t\t\t\t\t\t((Math.pow(rx,2)*Math.pow(ry,2))-(Math.pow(rx,2)*Math.pow(currp.y,2))-(Math.pow(ry,2)*Math.pow(currp.x,2))) /\r\n\t\t\t\t\t\t\t\t(Math.pow(rx,2)*Math.pow(currp.y,2)+Math.pow(ry,2)*Math.pow(currp.x,2))\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tif (isNaN(s)) s = 0;\r\n\t\t\t\t\t\t\tvar cpp = new svg.Point(s * rx * currp.y / ry, s * -ry * currp.x / rx);\r\n\t\t\t\t\t\t\t// cx, cy\r\n\t\t\t\t\t\t\tvar centp = new svg.Point(\r\n\t\t\t\t\t\t\t\t(curr.x + cp.x) / 2.0 + Math.cos(xAxisRotation) * cpp.x - Math.sin(xAxisRotation) * cpp.y,\r\n\t\t\t\t\t\t\t\t(curr.y + cp.y) / 2.0 + Math.sin(xAxisRotation) * cpp.x + Math.cos(xAxisRotation) * cpp.y\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t// vector magnitude\r\n\t\t\t\t\t\t\tvar m = function(v) { return Math.sqrt(Math.pow(v[0],2) + Math.pow(v[1],2)); }\r\n\t\t\t\t\t\t\t// ratio between two vectors\r\n\t\t\t\t\t\t\tvar r = function(u, v) { return (u[0]*v[0]+u[1]*v[1]) / (m(u)*m(v)) }\r\n\t\t\t\t\t\t\t// angle between two vectors\r\n\t\t\t\t\t\t\tvar a = function(u, v) { return (u[0]*v[1] < u[1]*v[0] ? -1 : 1) * Math.acos(r(u,v)); }\r\n\t\t\t\t\t\t\t// initial angle\r\n\t\t\t\t\t\t\tvar a1 = a([1,0], [(currp.x-cpp.x)/rx,(currp.y-cpp.y)/ry]);\r\n\t\t\t\t\t\t\t// angle delta\r\n\t\t\t\t\t\t\tvar u = [(currp.x-cpp.x)/rx,(currp.y-cpp.y)/ry];\r\n\t\t\t\t\t\t\tvar v = [(-currp.x-cpp.x)/rx,(-currp.y-cpp.y)/ry];\r\n\t\t\t\t\t\t\tvar ad = a(u, v);\r\n\t\t\t\t\t\t\tif (r(u,v) <= -1) ad = Math.PI;\r\n\t\t\t\t\t\t\tif (r(u,v) >= 1) ad = 0;\r\n\r\n\t\t\t\t\t\t\t// for markers\r\n\t\t\t\t\t\t\tvar dir = 1 - sweepFlag ? 1.0 : -1.0;\r\n\t\t\t\t\t\t\tvar ah = a1 + dir * (ad / 2.0);\r\n\t\t\t\t\t\t\tvar halfWay = new svg.Point(\r\n\t\t\t\t\t\t\t\tcentp.x + rx * Math.cos(ah),\r\n\t\t\t\t\t\t\t\tcentp.y + ry * Math.sin(ah)\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tpp.addMarkerAngle(halfWay, ah - dir * Math.PI / 2);\r\n\t\t\t\t\t\t\tpp.addMarkerAngle(cp, ah - dir * Math.PI);\r\n\r\n\t\t\t\t\t\t\tbb.addPoint(cp.x, cp.y); // TODO: this is too naive, make it better\r\n\t\t\t\t\t\t\tif (ctx != null) {\r\n\t\t\t\t\t\t\t\tvar r = rx > ry ? rx : ry;\r\n\t\t\t\t\t\t\t\tvar sx = rx > ry ? 1 : rx / ry;\r\n\t\t\t\t\t\t\t\tvar sy = rx > ry ? ry / rx : 1;\r\n\r\n\t\t\t\t\t\t\t\tctx.translate(centp.x, centp.y);\r\n\t\t\t\t\t\t\t\tctx.rotate(xAxisRotation);\r\n\t\t\t\t\t\t\t\tctx.scale(sx, sy);\r\n\t\t\t\t\t\t\t\tctx.arc(0, 0, r, a1, a1 + ad, 1 - sweepFlag);\r\n\t\t\t\t\t\t\t\tctx.scale(1/sx, 1/sy);\r\n\t\t\t\t\t\t\t\tctx.rotate(-xAxisRotation);\r\n\t\t\t\t\t\t\t\tctx.translate(-centp.x, -centp.y);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'Z':\r\n\t\t\t\t\tcase 'z':\r\n\t\t\t\t\t\tif (ctx != null) ctx.closePath();\r\n\t\t\t\t\t\tpp.current = pp.start;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn bb;\r\n\t\t\t}\r\n\r\n\t\t\tthis.getMarkers = function() {\r\n\t\t\t\tvar points = this.PathParser.getMarkerPoints();\r\n\t\t\t\tvar angles = this.PathParser.getMarkerAngles();\r\n\r\n\t\t\t\tvar markers = [];\r\n\t\t\t\tfor (var i=0; i<points.length; i++) {\r\n\t\t\t\t\tmarkers.push([points[i], angles[i]]);\r\n\t\t\t\t}\r\n\t\t\t\treturn markers;\r\n\t\t\t}\r\n\t\t}\r\n\t\tsvg.Element.path.prototype = new svg.Element.PathElementBase;\r\n\r\n\t\t// pattern element\r\n\t\tsvg.Element.pattern = function(node) {\r\n\t\t\tthis.base = svg.Element.ElementBase;\r\n\t\t\tthis.base(node);\r\n\r\n\t\t\tthis.createPattern = function(ctx, element) {\r\n\t\t\t\tvar width = this.attribute('width').toPixels('x', true);\r\n\t\t\t\tvar height = this.attribute('height').toPixels('y', true);\r\n\r\n\t\t\t\t// render me using a temporary svg element\r\n\t\t\t\tvar tempSvg = new svg.Element.svg();\r\n\t\t\t\ttempSvg.attributes['viewBox'] = new svg.Property('viewBox', this.attribute('viewBox').value);\r\n\t\t\t\ttempSvg.attributes['width'] = new svg.Property('width', width + 'px');\r\n\t\t\t\ttempSvg.attributes['height'] = new svg.Property('height', height + 'px');\r\n\t\t\t\ttempSvg.attributes['transform'] = new svg.Property('transform', this.attribute('patternTransform').value);\r\n\t\t\t\ttempSvg.children = this.children;\r\n\r\n\t\t\t\tvar c = document.createElement('canvas');\r\n\t\t\t\tc.width = width;\r\n\t\t\t\tc.height = height;\r\n\t\t\t\tvar cctx = c.getContext('2d');\r\n\t\t\t\tif (this.attribute('x').hasValue() && this.attribute('y').hasValue()) {\r\n\t\t\t\t\tcctx.translate(this.attribute('x').toPixels('x', true), this.attribute('y').toPixels('y', true));\r\n\t\t\t\t}\r\n\t\t\t\t// render 3x3 grid so when we transform there's no white space on edges\r\n\t\t\t\tfor (var x=-1; x<=1; x++) {\r\n\t\t\t\t\tfor (var y=-1; y<=1; y++) {\r\n\t\t\t\t\t\tcctx.save();\r\n\t\t\t\t\t\ttempSvg.attributes['x'] = new svg.Property('x', x * c.width);\r\n\t\t\t\t\t\ttempSvg.attributes['y'] = new svg.Property('y', y * c.height);\r\n\t\t\t\t\t\ttempSvg.render(cctx);\r\n\t\t\t\t\t\tcctx.restore();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tvar pattern = ctx.createPattern(c, 'repeat');\r\n\t\t\t\treturn pattern;\r\n\t\t\t}\r\n\t\t}\r\n\t\tsvg.Element.pattern.prototype = new svg.Element.ElementBase;\r\n\r\n\t\t// marker element\r\n\t\tsvg.Element.marker = function(node) {\r\n\t\t\tthis.base = svg.Element.ElementBase;\r\n\t\t\tthis.base(node);\r\n\r\n\t\t\tthis.baseRender = this.render;\r\n\t\t\tthis.render = function(ctx, point, angle) {\r\n\t\t\t\tctx.translate(point.x, point.y);\r\n\t\t\t\tif (this.attribute('orient').valueOrDefault('auto') == 'auto') ctx.rotate(angle);\r\n\t\t\t\tif (this.attribute('markerUnits').valueOrDefault('strokeWidth') == 'strokeWidth') ctx.scale(ctx.lineWidth, ctx.lineWidth);\r\n\t\t\t\tctx.save();\r\n\r\n\t\t\t\t// render me using a temporary svg element\r\n\t\t\t\tvar tempSvg = new svg.Element.svg();\r\n\t\t\t\ttempSvg.attributes['viewBox'] = new svg.Property('viewBox', this.attribute('viewBox').value);\r\n\t\t\t\ttempSvg.attributes['refX'] = new svg.Property('refX', this.attribute('refX').value);\r\n\t\t\t\ttempSvg.attributes['refY'] = new svg.Property('refY', this.attribute('refY').value);\r\n\t\t\t\ttempSvg.attributes['width'] = new svg.Property('width', this.attribute('markerWidth').value);\r\n\t\t\t\ttempSvg.attributes['height'] = new svg.Property('height', this.attribute('markerHeight').value);\r\n\t\t\t\ttempSvg.attributes['fill'] = new svg.Property('fill', this.attribute('fill').valueOrDefault('black'));\r\n\t\t\t\ttempSvg.attributes['stroke'] = new svg.Property('stroke', this.attribute('stroke').valueOrDefault('none'));\r\n\t\t\t\ttempSvg.children = this.children;\r\n\t\t\t\ttempSvg.render(ctx);\r\n\r\n\t\t\t\tctx.restore();\r\n\t\t\t\tif (this.attribute('markerUnits').valueOrDefault('strokeWidth') == 'strokeWidth') ctx.scale(1/ctx.lineWidth, 1/ctx.lineWidth);\r\n\t\t\t\tif (this.attribute('orient').valueOrDefault('auto') == 'auto') ctx.rotate(-angle);\r\n\t\t\t\tctx.translate(-point.x, -point.y);\r\n\t\t\t}\r\n\t\t}\r\n\t\tsvg.Element.marker.prototype = new svg.Element.ElementBase;\r\n\r\n\t\t// definitions element\r\n\t\tsvg.Element.defs = function(node) {\r\n\t\t\tthis.base = svg.Element.ElementBase;\r\n\t\t\tthis.base(node);\r\n\r\n\t\t\tthis.render = function(ctx) {\r\n\t\t\t\t// NOOP\r\n\t\t\t}\r\n\t\t}\r\n\t\tsvg.Element.defs.prototype = new svg.Element.ElementBase;\r\n\r\n\t\t// base for gradients\r\n\t\tsvg.Element.GradientBase = function(node) {\r\n\t\t\tthis.base = svg.Element.ElementBase;\r\n\t\t\tthis.base(node);\r\n\r\n\t\t\tthis.stops = [];\r\n\t\t\tfor (var i=0; i<this.children.length; i++) {\r\n\t\t\t\tvar child = this.children[i];\r\n\t\t\t\tif (child.type == 'stop') this.stops.push(child);\r\n\t\t\t}\r\n\r\n\t\t\tthis.getGradient = function() {\r\n\t\t\t\t// OVERRIDE ME!\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tthis.gradientUnits = function () {\r\n\t\t\t\treturn this.attribute('gradientUnits').valueOrDefault('objectBoundingBox');\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tthis.attributesToInherit = ['gradientUnits'];\r\n\t\t\t\r\n\t\t\tthis.inheritStopContainer = function (stopsContainer) {\r\n\t\t\t\tfor (var i=0; i<this.attributesToInherit.length; i++) {\r\n\t\t\t\t\tvar attributeToInherit = this.attributesToInherit[i];\r\n\t\t\t\t\tif (!this.attribute(attributeToInherit).hasValue() && stopsContainer.attribute(attributeToInherit).hasValue()) {\r\n\t\t\t\t\t\tthis.attribute(attributeToInherit, true).value = stopsContainer.attribute(attributeToInherit).value;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tthis.createGradient = function(ctx, element, parentOpacityProp) {\r\n\t\t\t\tvar stopsContainer = this;\r\n\t\t\t\tif (this.getHrefAttribute().hasValue()) {\r\n\t\t\t\t\tstopsContainer = this.getHrefAttribute().getDefinition();\r\n\t\t\t\t\tthis.inheritStopContainer(stopsContainer);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar addParentOpacity = function (color) {\r\n\t\t\t\t\tif (parentOpacityProp.hasValue()) {\r\n\t\t\t\t\t\tvar p = new svg.Property('color', color);\r\n\t\t\t\t\t\treturn p.addOpacity(parentOpacityProp).value;\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn color;\r\n\t\t\t\t};\r\n\r\n\t\t\t\tvar g = this.getGradient(ctx, element);\r\n\t\t\t\tif (g == null) return addParentOpacity(stopsContainer.stops[stopsContainer.stops.length - 1].color);\r\n\t\t\t\tfor (var i=0; i<stopsContainer.stops.length; i++) {\r\n\t\t\t\t\tg.addColorStop(stopsContainer.stops[i].offset, addParentOpacity(stopsContainer.stops[i].color));\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (this.attribute('gradientTransform').hasValue()) {\r\n\t\t\t\t\t// render as transformed pattern on temporary canvas\r\n\t\t\t\t\tvar rootView = svg.ViewPort.viewPorts[0];\r\n\r\n\t\t\t\t\tvar rect = new svg.Element.rect();\r\n\t\t\t\t\trect.attributes['x'] = new svg.Property('x', -svg.MAX_VIRTUAL_PIXELS/3.0);\r\n\t\t\t\t\trect.attributes['y'] = new svg.Property('y', -svg.MAX_VIRTUAL_PIXELS/3.0);\r\n\t\t\t\t\trect.attributes['width'] = new svg.Property('width', svg.MAX_VIRTUAL_PIXELS);\r\n\t\t\t\t\trect.attributes['height'] = new svg.Property('height', svg.MAX_VIRTUAL_PIXELS);\r\n\r\n\t\t\t\t\tvar group = new svg.Element.g();\r\n\t\t\t\t\tgroup.attributes['transform'] = new svg.Property('transform', this.attribute('gradientTransform').value);\r\n\t\t\t\t\tgroup.children = [ rect ];\r\n\r\n\t\t\t\t\tvar tempSvg = new svg.Element.svg();\r\n\t\t\t\t\ttempSvg.attributes['x'] = new svg.Property('x', 0);\r\n\t\t\t\t\ttempSvg.attributes['y'] = new svg.Property('y', 0);\r\n\t\t\t\t\ttempSvg.attributes['width'] = new svg.Property('width', rootView.width);\r\n\t\t\t\t\ttempSvg.attributes['height'] = new svg.Property('height', rootView.height);\r\n\t\t\t\t\ttempSvg.children = [ group ];\r\n\r\n\t\t\t\t\tvar c = document.createElement('canvas');\r\n\t\t\t\t\tc.width = rootView.width;\r\n\t\t\t\t\tc.height = rootView.height;\r\n\t\t\t\t\tvar tempCtx = c.getContext('2d');\r\n\t\t\t\t\ttempCtx.fillStyle = g;\r\n\t\t\t\t\ttempSvg.render(tempCtx);\r\n\t\t\t\t\treturn tempCtx.createPattern(c, 'no-repeat');\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn g;\r\n\t\t\t}\r\n\t\t}\r\n\t\tsvg.Element.GradientBase.prototype = new svg.Element.ElementBase;\r\n\r\n\t\t// linear gradient element\r\n\t\tsvg.Element.linearGradient = function(node) {\r\n\t\t\tthis.base = svg.Element.GradientBase;\r\n\t\t\tthis.base(node);\r\n\t\t\t\r\n\t\t\tthis.attributesToInherit.push('x1');\r\n\t\t\tthis.attributesToInherit.push('y1');\r\n\t\t\tthis.attributesToInherit.push('x2');\r\n\t\t\tthis.attributesToInherit.push('y2');\r\n\r\n\t\t\tthis.getGradient = function(ctx, element) {\r\n\t\t\t\tvar bb = this.gradientUnits() == 'objectBoundingBox' ? element.getBoundingBox() : null;\r\n\r\n\t\t\t\tif (!this.attribute('x1').hasValue()\r\n\t\t\t\t && !this.attribute('y1').hasValue()\r\n\t\t\t\t && !this.attribute('x2').hasValue()\r\n\t\t\t\t && !this.attribute('y2').hasValue()) {\r\n\t\t\t\t\tthis.attribute('x1', true).value = 0;\r\n\t\t\t\t\tthis.attribute('y1', true).value = 0;\r\n\t\t\t\t\tthis.attribute('x2', true).value = 1;\r\n\t\t\t\t\tthis.attribute('y2', true).value = 0;\r\n\t\t\t\t }\r\n\r\n\t\t\t\tvar x1 = (this.gradientUnits() == 'objectBoundingBox'\r\n\t\t\t\t\t? bb.x() + bb.width() * this.attribute('x1').numValue()\r\n\t\t\t\t\t: this.attribute('x1').toPixels('x'));\r\n\t\t\t\tvar y1 = (this.gradientUnits() == 'objectBoundingBox'\r\n\t\t\t\t\t? bb.y() + bb.height() * this.attribute('y1').numValue()\r\n\t\t\t\t\t: this.attribute('y1').toPixels('y'));\r\n\t\t\t\tvar x2 = (this.gradientUnits() == 'objectBoundingBox'\r\n\t\t\t\t\t? bb.x() + bb.width() * this.attribute('x2').numValue()\r\n\t\t\t\t\t: this.attribute('x2').toPixels('x'));\r\n\t\t\t\tvar y2 = (this.gradientUnits() == 'objectBoundingBox'\r\n\t\t\t\t\t? bb.y() + bb.height() * this.attribute('y2').numValue()\r\n\t\t\t\t\t: this.attribute('y2').toPixels('y'));\r\n\r\n\t\t\t\tif (x1 == x2 && y1 == y2) return null;\r\n\t\t\t\treturn ctx.createLinearGradient(x1, y1, x2, y2);\r\n\t\t\t}\r\n\t\t}\r\n\t\tsvg.Element.linearGradient.prototype = new svg.Element.GradientBase;\r\n\r\n\t\t// radial gradient element\r\n\t\tsvg.Element.radialGradient = function(node) {\r\n\t\t\tthis.base = svg.Element.GradientBase;\r\n\t\t\tthis.base(node);\r\n\t\t\t\r\n\t\t\tthis.attributesToInherit.push('cx');\r\n\t\t\tthis.attributesToInherit.push('cy');\r\n\t\t\tthis.attributesToInherit.push('r');\r\n\t\t\tthis.attributesToInherit.push('fx');\r\n\t\t\tthis.attributesToInherit.push('fy');\r\n\r\n\t\t\tthis.getGradient = function(ctx, element) {\r\n\t\t\t\tvar bb = element.getBoundingBox();\r\n\r\n\t\t\t\tif (!this.attribute('cx').hasValue()) this.attribute('cx', true).value = '50%';\r\n\t\t\t\tif (!this.attribute('cy').hasValue()) this.attribute('cy', true).value = '50%';\r\n\t\t\t\tif (!this.attribute('r').hasValue()) this.attribute('r', true).value = '50%';\r\n\r\n\t\t\t\tvar cx = (this.gradientUnits() == 'objectBoundingBox'\r\n\t\t\t\t\t? bb.x() + bb.width() * this.attribute('cx').numValue()\r\n\t\t\t\t\t: this.attribute('cx').toPixels('x'));\r\n\t\t\t\tvar cy = (this.gradientUnits() == 'objectBoundingBox'\r\n\t\t\t\t\t? bb.y() + bb.height() * this.attribute('cy').numValue()\r\n\t\t\t\t\t: this.attribute('cy').toPixels('y'));\r\n\r\n\t\t\t\tvar fx = cx;\r\n\t\t\t\tvar fy = cy;\r\n\t\t\t\tif (this.attribute('fx').hasValue()) {\r\n\t\t\t\t\tfx = (this.gradientUnits() == 'objectBoundingBox'\r\n\t\t\t\t\t? bb.x() + bb.width() * this.attribute('fx').numValue()\r\n\t\t\t\t\t: this.attribute('fx').toPixels('x'));\r\n\t\t\t\t}\r\n\t\t\t\tif (this.attribute('fy').hasValue()) {\r\n\t\t\t\t\tfy = (this.gradientUnits() == 'objectBoundingBox'\r\n\t\t\t\t\t? bb.y() + bb.height() * this.attribute('fy').numValue()\r\n\t\t\t\t\t: this.attribute('fy').toPixels('y'));\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar r = (this.gradientUnits() == 'objectBoundingBox'\r\n\t\t\t\t\t? (bb.width() + bb.height()) / 2.0 * this.attribute('r').numValue()\r\n\t\t\t\t\t: this.attribute('r').toPixels());\r\n\r\n\t\t\t\treturn ctx.createRadialGradient(fx, fy, 0, cx, cy, r);\r\n\t\t\t}\r\n\t\t}\r\n\t\tsvg.Element.radialGradient.prototype = new svg.Element.GradientBase;\r\n\r\n\t\t// gradient stop element\r\n\t\tsvg.Element.stop = function(node) {\r\n\t\t\tthis.base = svg.Element.ElementBase;\r\n\t\t\tthis.base(node);\r\n\r\n\t\t\tthis.offset = this.attribute('offset').numValue();\r\n\t\t\tif (this.offset < 0) this.offset = 0;\r\n\t\t\tif (this.offset > 1) this.offset = 1;\r\n\r\n\t\t\tvar stopColor = this.style('stop-color', true);\r\n\t\t\tif (stopColor.value === '') stopColor.value = '#000';\r\n\t\t\tif (this.style('stop-opacity').hasValue()) stopColor = stopColor.addOpacity(this.style('stop-opacity'));\r\n\t\t\tthis.color = stopColor.value;\r\n\t\t}\r\n\t\tsvg.Element.stop.prototype = new svg.Element.ElementBase;\r\n\r\n\t\t// animation base element\r\n\t\tsvg.Element.AnimateBase = function(node) {\r\n\t\t\tthis.base = svg.Element.ElementBase;\r\n\t\t\tthis.base(node);\r\n\r\n\t\t\tsvg.Animations.push(this);\r\n\r\n\t\t\tthis.duration = 0.0;\r\n\t\t\tthis.begin = this.attribute('begin').toMilliseconds();\r\n\t\t\tthis.maxDuration = this.begin + this.attribute('dur').toMilliseconds();\r\n\r\n\t\t\tthis.getProperty = function() {\r\n\t\t\t\tvar attributeType = this.attribute('attributeType').value;\r\n\t\t\t\tvar attributeName = this.attribute('attributeName').value;\r\n\r\n\t\t\t\tif (attributeType == 'CSS') {\r\n\t\t\t\t\treturn this.parent.style(attributeName, true);\r\n\t\t\t\t}\r\n\t\t\t\treturn this.parent.attribute(attributeName, true);\r\n\t\t\t};\r\n\r\n\t\t\tthis.initialValue = null;\r\n\t\t\tthis.initialUnits = '';\r\n\t\t\tthis.removed = false;\r\n\r\n\t\t\tthis.calcValue = function() {\r\n\t\t\t\t// OVERRIDE ME!\r\n\t\t\t\treturn '';\r\n\t\t\t}\r\n\r\n\t\t\tthis.update = function(delta) {\r\n\t\t\t\t// set initial value\r\n\t\t\t\tif (this.initialValue == null) {\r\n\t\t\t\t\tthis.initialValue = this.getProperty().value;\r\n\t\t\t\t\tthis.initialUnits = this.getProperty().getUnits();\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// if we're past the end time\r\n\t\t\t\tif (this.duration > this.maxDuration) {\r\n\t\t\t\t\t// loop for indefinitely repeating animations\r\n\t\t\t\t\tif (this.attribute('repeatCount').value == 'indefinite'\r\n\t\t\t\t\t || this.attribute('repeatDur').value == 'indefinite') {\r\n\t\t\t\t\t\tthis.duration = 0.0\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (this.attribute('fill').valueOrDefault('remove') == 'freeze' && !this.frozen) {\r\n\t\t\t\t\t\tthis.frozen = true;\r\n\t\t\t\t\t\tthis.parent.animationFrozen = true;\r\n\t\t\t\t\t\tthis.parent.animationFrozenValue = this.getProperty().value;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (this.attribute('fill').valueOrDefault('remove') == 'remove' && !this.removed) {\r\n\t\t\t\t\t\tthis.removed = true;\r\n\t\t\t\t\t\tthis.getProperty().value = this.parent.animationFrozen ? this.parent.animationFrozenValue : this.initialValue;\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\tthis.duration = this.duration + delta;\r\n\r\n\t\t\t\t// if we're past the begin time\r\n\t\t\t\tvar updated = false;\r\n\t\t\t\tif (this.begin < this.duration) {\r\n\t\t\t\t\tvar newValue = this.calcValue(); // tween\r\n\r\n\t\t\t\t\tif (this.attribute('type').hasValue()) {\r\n\t\t\t\t\t\t// for transform, etc.\r\n\t\t\t\t\t\tvar type = this.attribute('type').value;\r\n\t\t\t\t\t\tnewValue = type + '(' + newValue + ')';\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tthis.getProperty().value = newValue;\r\n\t\t\t\t\tupdated = true;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn updated;\r\n\t\t\t}\r\n\r\n\t\t\tthis.from = this.attribute('from');\r\n\t\t\tthis.to = this.attribute('to');\r\n\t\t\tthis.values = this.attribute('values');\r\n\t\t\tif (this.values.hasValue()) this.values.value = this.values.value.split(';');\r\n\r\n\t\t\t// fraction of duration we've covered\r\n\t\t\tthis.progress = function() {\r\n\t\t\t\tvar ret = { progress: (this.duration - this.begin) / (this.maxDuration - this.begin) };\r\n\t\t\t\tif (this.values.hasValue()) {\r\n\t\t\t\t\tvar p = ret.progress * (this.values.value.length - 1);\r\n\t\t\t\t\tvar lb = Math.floor(p), ub = Math.ceil(p);\r\n\t\t\t\t\tret.from = new svg.Property('from', parseFloat(this.values.value[lb]));\r\n\t\t\t\t\tret.to = new svg.Property('to', parseFloat(this.values.value[ub]));\r\n\t\t\t\t\tret.progress = (p - lb) / (ub - lb);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tret.from = this.from;\r\n\t\t\t\t\tret.to = this.to;\r\n\t\t\t\t}\r\n\t\t\t\treturn ret;\r\n\t\t\t}\r\n\t\t}\r\n\t\tsvg.Element.AnimateBase.prototype = new svg.Element.ElementBase;\r\n\r\n\t\t// animate element\r\n\t\tsvg.Element.animate = function(node) {\r\n\t\t\tthis.base = svg.Element.AnimateBase;\r\n\t\t\tthis.base(node);\r\n\r\n\t\t\tthis.calcValue = function() {\r\n\t\t\t\tvar p = this.progress();\r\n\r\n\t\t\t\t// tween value linearly\r\n\t\t\t\tvar newValue = p.from.numValue() + (p.to.numValue() - p.from.numValue()) * p.progress;\r\n\t\t\t\treturn newValue + this.initialUnits;\r\n\t\t\t};\r\n\t\t}\r\n\t\tsvg.Element.animate.prototype = new svg.Element.AnimateBase;\r\n\r\n\t\t// animate color element\r\n\t\tsvg.Element.animateColor = function(node) {\r\n\t\t\tthis.base = svg.Element.AnimateBase;\r\n\t\t\tthis.base(node);\r\n\r\n\t\t\tthis.calcValue = function() {\r\n\t\t\t\tvar p = this.progress();\r\n\t\t\t\tvar from = new RGBColor(p.from.value);\r\n\t\t\t\tvar to = new RGBColor(p.to.value);\r\n\r\n\t\t\t\tif (from.ok && to.ok) {\r\n\t\t\t\t\t// tween color linearly\r\n\t\t\t\t\tvar r = from.r + (to.r - from.r) * p.progress;\r\n\t\t\t\t\tvar g = from.g + (to.g - from.g) * p.progress;\r\n\t\t\t\t\tvar b = from.b + (to.b - from.b) * p.progress;\r\n\t\t\t\t\treturn 'rgb('+parseInt(r,10)+','+parseInt(g,10)+','+parseInt(b,10)+')';\r\n\t\t\t\t}\r\n\t\t\t\treturn this.attribute('from').value;\r\n\t\t\t};\r\n\t\t}\r\n\t\tsvg.Element.animateColor.prototype = new svg.Element.AnimateBase;\r\n\r\n\t\t// animate transform element\r\n\t\tsvg.Element.animateTransform = function(node) {\r\n\t\t\tthis.base = svg.Element.AnimateBase;\r\n\t\t\tthis.base(node);\r\n\r\n\t\t\tthis.calcValue = function() {\r\n\t\t\t\tvar p = this.progress();\r\n\r\n\t\t\t\t// tween value linearly\r\n\t\t\t\tvar from = svg.ToNumberArray(p.from.value);\r\n\t\t\t\tvar to = svg.ToNumberArray(p.to.value);\r\n\t\t\t\tvar newValue = '';\r\n\t\t\t\tfor (var i=0; i<from.length; i++) {\r\n\t\t\t\t\tnewValue += from[i] + (to[i] - from[i]) * p.progress + ' ';\r\n\t\t\t\t}\r\n\t\t\t\treturn newValue;\r\n\t\t\t};\r\n\t\t}\r\n\t\tsvg.Element.animateTransform.prototype = new svg.Element.animate;\r\n\r\n\t\t// font element\r\n\t\tsvg.Element.font = function(node) {\r\n\t\t\tthis.base = svg.Element.ElementBase;\r\n\t\t\tthis.base(node);\r\n\r\n\t\t\tthis.horizAdvX = this.attribute('horiz-adv-x').numValue();\r\n\r\n\t\t\tthis.isRTL = false;\r\n\t\t\tthis.isArabic = false;\r\n\t\t\tthis.fontFace = null;\r\n\t\t\tthis.missingGlyph = null;\r\n\t\t\tthis.glyphs = [];\r\n\t\t\tfor (var i=0; i<this.children.length; i++) {\r\n\t\t\t\tvar child = this.children[i];\r\n\t\t\t\tif (child.type == 'font-face') {\r\n\t\t\t\t\tthis.fontFace = child;\r\n\t\t\t\t\tif (child.style('font-family').hasValue()) {\r\n\t\t\t\t\t\tsvg.Definitions[child.style('font-family').value] = this;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse if (child.type == 'missing-glyph') this.missingGlyph = child;\r\n\t\t\t\telse if (child.type == 'glyph') {\r\n\t\t\t\t\tif (child.arabicForm != '') {\r\n\t\t\t\t\t\tthis.isRTL = true;\r\n\t\t\t\t\t\tthis.isArabic = true;\r\n\t\t\t\t\t\tif (typeof this.glyphs[child.unicode] == 'undefined') this.glyphs[child.unicode] = [];\r\n\t\t\t\t\t\tthis.glyphs[child.unicode][child.arabicForm] = child;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tthis.glyphs[child.unicode] = child;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tsvg.Element.font.prototype = new svg.Element.ElementBase;\r\n\r\n\t\t// font-face element\r\n\t\tsvg.Element.fontface = function(node) {\r\n\t\t\tthis.base = svg.Element.ElementBase;\r\n\t\t\tthis.base(node);\r\n\r\n\t\t\tthis.ascent = this.attribute('ascent').value;\r\n\t\t\tthis.descent = this.attribute('descent').value;\r\n\t\t\tthis.unitsPerEm = this.attribute('units-per-em').numValue();\r\n\t\t}\r\n\t\tsvg.Element.fontface.prototype = new svg.Element.ElementBase;\r\n\r\n\t\t// missing-glyph element\r\n\t\tsvg.Element.missingglyph = function(node) {\r\n\t\t\tthis.base = svg.Element.path;\r\n\t\t\tthis.base(node);\r\n\r\n\t\t\tthis.horizAdvX = 0;\r\n\t\t}\r\n\t\tsvg.Element.missingglyph.prototype = new svg.Element.path;\r\n\r\n\t\t// glyph element\r\n\t\tsvg.Element.glyph = function(node) {\r\n\t\t\tthis.base = svg.Element.path;\r\n\t\t\tthis.base(node);\r\n\r\n\t\t\tthis.horizAdvX = this.attribute('horiz-adv-x').numValue();\r\n\t\t\tthis.unicode = this.attribute('unicode').value;\r\n\t\t\tthis.arabicForm = this.attribute('arabic-form').value;\r\n\t\t}\r\n\t\tsvg.Element.glyph.prototype = new svg.Element.path;\r\n\r\n\t\t// text element\r\n\t\tsvg.Element.text = function(node) {\r\n\t\t\tthis.captureTextNodes = true;\r\n\t\t\tthis.base = svg.Element.RenderedElementBase;\r\n\t\t\tthis.base(node);\r\n\r\n\t\t\tthis.baseSetContext = this.setContext;\r\n\t\t\tthis.setContext = function(ctx) {\r\n\t\t\t\tthis.baseSetContext(ctx);\r\n\r\n\t\t\t\tvar textBaseline = this.style('dominant-baseline').toTextBaseline();\r\n\t\t\t\tif (textBaseline == null) textBaseline = this.style('alignment-baseline').toTextBaseline();\r\n\t\t\t\tif (textBaseline != null) ctx.textBaseline = textBaseline;\r\n\t\t\t}\r\n\r\n\t\t\tthis.getBoundingBox = function () {\r\n\t\t\t\tvar x = this.attribute('x').toPixels('x');\r\n\t\t\t\tvar y = this.attribute('y').toPixels('y');\r\n\t\t\t\tvar fontSize = this.parent.style('font-size').numValueOrDefault(svg.Font.Parse(svg.ctx.font).fontSize);\r\n\t\t\t\treturn new svg.BoundingBox(x, y - fontSize, x + Math.floor(fontSize * 2.0 / 3.0) * this.children[0].getText().length, y);\r\n\t\t\t}\r\n\r\n\t\t\tthis.renderChildren = function(ctx) {\r\n\t\t\t\tthis.x = this.attribute('x').toPixels('x');\r\n\t\t\t\tthis.y = this.attribute('y').toPixels('y');\r\n\t\t\t\tif (this.attribute('dx').hasValue()) this.x += this.attribute('dx').toPixels('x');\r\n\t\t\t\tif (this.attribute('dy').hasValue()) this.y += this.attribute('dy').toPixels('y');\r\n\t\t\t\tthis.x += this.getAnchorDelta(ctx, this, 0);\r\n\t\t\t\tfor (var i=0; i<this.children.length; i++) {\r\n\t\t\t\t\tthis.renderChild(ctx, this, this, i);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tthis.getAnchorDelta = function (ctx, parent, startI) {\r\n\t\t\t\tvar textAnchor = this.style('text-anchor').valueOrDefault('start');\r\n\t\t\t\tif (textAnchor != 'start') {\r\n\t\t\t\t\tvar width = 0;\r\n\t\t\t\t\tfor (var i=startI; i<parent.children.length; i++) {\r\n\t\t\t\t\t\tvar child = parent.children[i];\r\n\t\t\t\t\t\tif (i > startI && child.attribute('x').hasValue()) break; // new group\r\n\t\t\t\t\t\twidth += child.measureTextRecursive(ctx);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn -1 * (textAnchor == 'end' ? width : width / 2.0);\r\n\t\t\t\t}\r\n\t\t\t\treturn 0;\r\n\t\t\t}\r\n\r\n\t\t\tthis.renderChild = function(ctx, textParent, parent, i) {\r\n\t\t\t\tvar child = parent.children[i];\r\n\t\t\t\tif (child.attribute('x').hasValue()) {\r\n\t\t\t\t\tchild.x = child.attribute('x').toPixels('x') + textParent.getAnchorDelta(ctx, parent, i);\r\n\t\t\t\t\tif (child.attribute('dx').hasValue()) child.x += child.attribute('dx').toPixels('x');\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tif (child.attribute('dx').hasValue()) textParent.x += child.attribute('dx').toPixels('x');\r\n\t\t\t\t\tchild.x = textParent.x;\r\n\t\t\t\t}\r\n\t\t\t\ttextParent.x = child.x + child.measureText(ctx);\r\n\r\n\t\t\t\tif (child.attribute('y').hasValue()) {\r\n\t\t\t\t\tchild.y = child.attribute('y').toPixels('y');\r\n\t\t\t\t\tif (child.attribute('dy').hasValue()) child.y += child.attribute('dy').toPixels('y');\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tif (child.attribute('dy').hasValue()) textParent.y += child.attribute('dy').toPixels('y');\r\n\t\t\t\t\tchild.y = textParent.y;\r\n\t\t\t\t}\r\n\t\t\t\ttextParent.y = child.y;\r\n\r\n\t\t\t\tchild.render(ctx);\r\n\r\n\t\t\t\tfor (var i=0; i<child.children.length; i++) {\r\n\t\t\t\t\ttextParent.renderChild(ctx, textParent, child, i);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tsvg.Element.text.prototype = new svg.Element.RenderedElementBase;\r\n\r\n\t\t// text base\r\n\t\tsvg.Element.TextElementBase = function(node) {\r\n\t\t\tthis.base = svg.Element.RenderedElementBase;\r\n\t\t\tthis.base(node);\r\n\r\n\t\t\tthis.getGlyph = function(font, text, i) {\r\n\t\t\t\tvar c = text[i];\r\n\t\t\t\tvar glyph = null;\r\n\t\t\t\tif (font.isArabic) {\r\n\t\t\t\t\tvar arabicForm = 'isolated';\r\n\t\t\t\t\tif ((i==0 || text[i-1]==' ') && i<text.length-2 && text[i+1]!=' ') arabicForm = 'terminal';\r\n\t\t\t\t\tif (i>0 && text[i-1]!=' ' && i<text.length-2 && text[i+1]!=' ') arabicForm = 'medial';\r\n\t\t\t\t\tif (i>0 && text[i-1]!=' ' && (i == text.length-1 || text[i+1]==' ')) arabicForm = 'initial';\r\n\t\t\t\t\tif (typeof font.glyphs[c] != 'undefined') {\r\n\t\t\t\t\t\tglyph = font.glyphs[c][arabicForm];\r\n\t\t\t\t\t\tif (glyph == null && font.glyphs[c].type == 'glyph') glyph = font.glyphs[c];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tglyph = font.glyphs[c];\r\n\t\t\t\t}\r\n\t\t\t\tif (glyph == null) glyph = font.missingGlyph;\r\n\t\t\t\treturn glyph;\r\n\t\t\t}\r\n\r\n\t\t\tthis.renderChildren = function(ctx) {\r\n\t\t\t\tvar customFont = this.parent.style('font-family').getDefinition();\r\n\t\t\t\tif (customFont != null) {\r\n\t\t\t\t\tvar fontSize = this.parent.style('font-size').numValueOrDefault(svg.Font.Parse(svg.ctx.font).fontSize);\r\n\t\t\t\t\tvar fontStyle = this.parent.style('font-style').valueOrDefault(svg.Font.Parse(svg.ctx.font).fontStyle);\r\n\t\t\t\t\tvar text = this.getText();\r\n\t\t\t\t\tif (customFont.isRTL) text = text.split(\"\").reverse().join(\"\");\r\n\r\n\t\t\t\t\tvar dx = svg.ToNumberArray(this.parent.attribute('dx').value);\r\n\t\t\t\t\tfor (var i=0; i<text.length; i++) {\r\n\t\t\t\t\t\tvar glyph = this.getGlyph(customFont, text, i);\r\n\t\t\t\t\t\tvar scale = fontSize / customFont.fontFace.unitsPerEm;\r\n\t\t\t\t\t\tctx.translate(this.x, this.y);\r\n\t\t\t\t\t\tctx.scale(scale, -scale);\r\n\t\t\t\t\t\tvar lw = ctx.lineWidth;\r\n\t\t\t\t\t\tctx.lineWidth = ctx.lineWidth * customFont.fontFace.unitsPerEm / fontSize;\r\n\t\t\t\t\t\tif (fontStyle == 'italic') ctx.transform(1, 0, .4, 1, 0, 0);\r\n\t\t\t\t\t\tglyph.render(ctx);\r\n\t\t\t\t\t\tif (fontStyle == 'italic') ctx.transform(1, 0, -.4, 1, 0, 0);\r\n\t\t\t\t\t\tctx.lineWidth = lw;\r\n\t\t\t\t\t\tctx.scale(1/scale, -1/scale);\r\n\t\t\t\t\t\tctx.translate(-this.x, -this.y);\r\n\r\n\t\t\t\t\t\tthis.x += fontSize * (glyph.horizAdvX || customFont.horizAdvX) / customFont.fontFace.unitsPerEm;\r\n\t\t\t\t\t\tif (typeof dx[i] != 'undefined' && !isNaN(dx[i])) {\r\n\t\t\t\t\t\t\tthis.x += dx[i];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (ctx.fillStyle != '') ctx.fillText(svg.compressSpaces(this.getText()), this.x, this.y);\r\n\t\t\t\tif (ctx.strokeStyle != '') ctx.strokeText(svg.compressSpaces(this.getText()), this.x, this.y);\r\n\t\t\t}\r\n\r\n\t\t\tthis.getText = function() {\r\n\t\t\t\t// OVERRIDE ME\r\n\t\t\t}\r\n\r\n\t\t\tthis.measureTextRecursive = function(ctx) {\r\n\t\t\t\tvar width = this.measureText(ctx);\r\n\t\t\t\tfor (var i=0; i<this.children.length; i++) {\r\n\t\t\t\t\twidth += this.children[i].measureTextRecursive(ctx);\r\n\t\t\t\t}\r\n\t\t\t\treturn width;\r\n\t\t\t}\r\n\r\n\t\t\tthis.measureText = function(ctx) {\r\n\t\t\t\tvar customFont = this.parent.style('font-family').getDefinition();\r\n\t\t\t\tif (customFont != null) {\r\n\t\t\t\t\tvar fontSize = this.parent.style('font-size').numValueOrDefault(svg.Font.Parse(svg.ctx.font).fontSize);\r\n\t\t\t\t\tvar measure = 0;\r\n\t\t\t\t\tvar text = this.getText();\r\n\t\t\t\t\tif (customFont.isRTL) text = text.split(\"\").reverse().join(\"\");\r\n\t\t\t\t\tvar dx = svg.ToNumberArray(this.parent.attribute('dx').value);\r\n\t\t\t\t\tfor (var i=0; i<text.length; i++) {\r\n\t\t\t\t\t\tvar glyph = this.getGlyph(customFont, text, i);\r\n\t\t\t\t\t\tmeasure += (glyph.horizAdvX || customFont.horizAdvX) * fontSize / customFont.fontFace.unitsPerEm;\r\n\t\t\t\t\t\tif (typeof dx[i] != 'undefined' && !isNaN(dx[i])) {\r\n\t\t\t\t\t\t\tmeasure += dx[i];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn measure;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar textToMeasure = svg.compressSpaces(this.getText());\r\n\t\t\t\tif (!ctx.measureText) return textToMeasure.length * 10;\r\n\r\n\t\t\t\tctx.save();\r\n\t\t\t\tthis.setContext(ctx);\r\n\t\t\t\tvar width = ctx.measureText(textToMeasure).width;\r\n\t\t\t\tctx.restore();\r\n\t\t\t\treturn width;\r\n\t\t\t}\r\n\t\t}\r\n\t\tsvg.Element.TextElementBase.prototype = new svg.Element.RenderedElementBase;\r\n\r\n\t\t// tspan\r\n\t\tsvg.Element.tspan = function(node) {\r\n\t\t\tthis.captureTextNodes = true;\r\n\t\t\tthis.base = svg.Element.TextElementBase;\r\n\t\t\tthis.base(node);\r\n\r\n\t\t\tthis.text = svg.compressSpaces(node.value || node.text || node.textContent || '');\r\n\t\t\tthis.getText = function() {\r\n\t\t\t\t// if this node has children, then they own the text\r\n\t\t\t\tif (this.children.length > 0) { return ''; }\r\n\t\t\t\treturn this.text;\r\n\t\t\t}\r\n\t\t}\r\n\t\tsvg.Element.tspan.prototype = new svg.Element.TextElementBase;\r\n\r\n\t\t// tref\r\n\t\tsvg.Element.tref = function(node) {\r\n\t\t\tthis.base = svg.Element.TextElementBase;\r\n\t\t\tthis.base(node);\r\n\r\n\t\t\tthis.getText = function() {\r\n\t\t\t\tvar element = this.getHrefAttribute().getDefinition();\r\n\t\t\t\tif (element != null) return element.children[0].getText();\r\n\t\t\t}\r\n\t\t}\r\n\t\tsvg.Element.tref.prototype = new svg.Element.TextElementBase;\r\n\r\n\t\t// a element\r\n\t\tsvg.Element.a = function(node) {\r\n\t\t\tthis.base = svg.Element.TextElementBase;\r\n\t\t\tthis.base(node);\r\n\r\n\t\t\tthis.hasText = node.childNodes.length > 0;\r\n\t\t\tfor (var i=0; i<node.childNodes.length; i++) {\r\n\t\t\t\tif (node.childNodes[i].nodeType != 3) this.hasText = false;\r\n\t\t\t}\r\n\r\n\t\t\t// this might contain text\r\n\t\t\tthis.text = this.hasText ? node.childNodes[0].value : '';\r\n\t\t\tthis.getText = function() {\r\n\t\t\t\treturn this.text;\r\n\t\t\t}\r\n\r\n\t\t\tthis.baseRenderChildren = this.renderChildren;\r\n\t\t\tthis.renderChildren = function(ctx) {\r\n\t\t\t\tif (this.hasText) {\r\n\t\t\t\t\t// render as text element\r\n\t\t\t\t\tthis.baseRenderChildren(ctx);\r\n\t\t\t\t\tvar fontSize = new svg.Property('fontSize', svg.Font.Parse(svg.ctx.font).fontSize);\r\n\t\t\t\t\tsvg.Mouse.checkBoundingBox(this, new svg.BoundingBox(this.x, this.y - fontSize.toPixels('y'), this.x + this.measureText(ctx), this.y));\r\n\t\t\t\t}\r\n\t\t\t\telse if (this.children.length > 0) {\r\n\t\t\t\t\t// render as temporary group\r\n\t\t\t\t\tvar g = new svg.Element.g();\r\n\t\t\t\t\tg.children = this.children;\r\n\t\t\t\t\tg.parent = this;\r\n\t\t\t\t\tg.render(ctx);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tthis.onclick = function() {\r\n\t\t\t\twindow.open(this.getHrefAttribute().value);\r\n\t\t\t}\r\n\r\n\t\t\tthis.onmousemove = function() {\r\n\t\t\t\tsvg.ctx.canvas.style.cursor = 'pointer';\r\n\t\t\t}\r\n\t\t}\r\n\t\tsvg.Element.a.prototype = new svg.Element.TextElementBase;\r\n\r\n\t\t// image element\r\n\t\tsvg.Element.image = function(node) {\r\n\t\t\tthis.base = svg.Element.RenderedElementBase;\r\n\t\t\tthis.base(node);\r\n\r\n\t\t\tvar href = this.getHrefAttribute().value;\r\n\t\t\tif (href == '') { return; }\r\n\t\t\tvar isSvg = href.match(/\\.svg$/)\r\n\r\n\t\t\tsvg.Images.push(this);\r\n\t\t\tthis.loaded = false;\r\n\t\t\tif (!isSvg) {\r\n\t\t\t\tthis.img = document.createElement('img');\r\n\t\t\t\tif (svg.opts['useCORS'] == true) { this.img.crossOrigin = 'Anonymous'; }\r\n\t\t\t\tvar self = this;\r\n\t\t\t\tthis.img.onload = function() { self.loaded = true; }\r\n\t\t\t\tthis.img.onerror = function() { svg.log('ERROR: image \"' + href + '\" not found'); self.loaded = true; }\r\n\t\t\t\tthis.img.src = href;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthis.img = svg.ajax(href);\r\n\t\t\t\tthis.loaded = true;\r\n\t\t\t}\r\n\r\n\t\t\tthis.renderChildren = function(ctx) {\r\n\t\t\t\tvar x = this.attribute('x').toPixels('x');\r\n\t\t\t\tvar y = this.attribute('y').toPixels('y');\r\n\r\n\t\t\t\tvar width = this.attribute('width').toPixels('x');\r\n\t\t\t\tvar height = this.attribute('height').toPixels('y');\r\n\t\t\t\tif (width == 0 || height == 0) return;\r\n\r\n\t\t\t\tctx.save();\r\n\t\t\t\tif (isSvg) {\r\n\t\t\t\t\tctx.drawSvg(this.img, x, y, width, height);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tctx.translate(x, y);\r\n\t\t\t\t\tsvg.AspectRatio(ctx,\r\n\t\t\t\t\t\t\t\t\tthis.attribute('preserveAspectRatio').value,\r\n\t\t\t\t\t\t\t\t\twidth,\r\n\t\t\t\t\t\t\t\t\tthis.img.width,\r\n\t\t\t\t\t\t\t\t\theight,\r\n\t\t\t\t\t\t\t\t\tthis.img.height,\r\n\t\t\t\t\t\t\t\t\t0,\r\n\t\t\t\t\t\t\t\t\t0);\r\n\t\t\t\t\tctx.drawImage(this.img, 0, 0);\r\n\t\t\t\t}\r\n\t\t\t\tctx.restore();\r\n\t\t\t}\r\n\r\n\t\t\tthis.getBoundingBox = function() {\r\n\t\t\t\tvar x = this.attribute('x').toPixels('x');\r\n\t\t\t\tvar y = this.attribute('y').toPixels('y');\r\n\t\t\t\tvar width = this.attribute('width').toPixels('x');\r\n\t\t\t\tvar height = this.attribute('height').toPixels('y');\r\n\t\t\t\treturn new svg.BoundingBox(x, y, x + width, y + height);\r\n\t\t\t}\r\n\t\t}\r\n\t\tsvg.Element.image.prototype = new svg.Element.RenderedElementBase;\r\n\r\n\t\t// group element\r\n\t\tsvg.Element.g = function(node) {\r\n\t\t\tthis.base = svg.Element.RenderedElementBase;\r\n\t\t\tthis.base(node);\r\n\r\n\t\t\tthis.getBoundingBox = function() {\r\n\t\t\t\tvar bb = new svg.BoundingBox();\r\n\t\t\t\tfor (var i=0; i<this.children.length; i++) {\r\n\t\t\t\t\tbb.addBoundingBox(this.children[i].getBoundingBox());\r\n\t\t\t\t}\r\n\t\t\t\treturn bb;\r\n\t\t\t};\r\n\t\t}\r\n\t\tsvg.Element.g.prototype = new svg.Element.RenderedElementBase;\r\n\r\n\t\t// symbol element\r\n\t\tsvg.Element.symbol = function(node) {\r\n\t\t\tthis.base = svg.Element.RenderedElementBase;\r\n\t\t\tthis.base(node);\r\n\r\n\t\t\tthis.render = function(ctx) {\r\n\t\t\t\t// NO RENDER\r\n\t\t\t};\r\n\t\t}\r\n\t\tsvg.Element.symbol.prototype = new svg.Element.RenderedElementBase;\r\n\r\n\t\t// style element\r\n\t\tsvg.Element.style = function(node) {\r\n\t\t\tthis.base = svg.Element.ElementBase;\r\n\t\t\tthis.base(node);\r\n\r\n\t\t\t// text, or spaces then CDATA\r\n\t\t\tvar css = ''\r\n\t\t\tfor (var i=0; i<node.childNodes.length; i++) {\r\n\t\t\t  css += node.childNodes[i].data;\r\n\t\t\t}\r\n\t\t\tcss = css.replace(/(\\/\\*([^*]|[\\r\\n]|(\\*+([^*\\/]|[\\r\\n])))*\\*+\\/)|(^[\\s]*\\/\\/.*)/gm, ''); // remove comments\r\n\t\t\tcss = svg.compressSpaces(css); // replace whitespace\r\n\t\t\tvar cssDefs = css.split('}');\r\n\t\t\tfor (var i=0; i<cssDefs.length; i++) {\r\n\t\t\t\tif (svg.trim(cssDefs[i]) != '') {\r\n\t\t\t\t\tvar cssDef = cssDefs[i].split('{');\r\n\t\t\t\t\tvar cssClasses = cssDef[0].split(',');\r\n\t\t\t\t\tvar cssProps = cssDef[1].split(';');\r\n\t\t\t\t\tfor (var j=0; j<cssClasses.length; j++) {\r\n\t\t\t\t\t\tvar cssClass = svg.trim(cssClasses[j]);\r\n\t\t\t\t\t\tif (cssClass != '') {\r\n\t\t\t\t\t\t\tvar props = svg.Styles[cssClass] || {};\r\n\t\t\t\t\t\t\tfor (var k=0; k<cssProps.length; k++) {\r\n\t\t\t\t\t\t\t\tvar prop = cssProps[k].indexOf(':');\r\n\t\t\t\t\t\t\t\tvar name = cssProps[k].substr(0, prop);\r\n\t\t\t\t\t\t\t\tvar value = cssProps[k].substr(prop + 1, cssProps[k].length - prop);\r\n\t\t\t\t\t\t\t\tif (name != null && value != null) {\r\n\t\t\t\t\t\t\t\t\tprops[svg.trim(name)] = new svg.Property(svg.trim(name), svg.trim(value));\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tsvg.Styles[cssClass] = props;\r\n\t\t\t\t\t\t\tsvg.StylesSpecificity[cssClass] = getSelectorSpecificity(cssClass);\r\n\t\t\t\t\t\t\tif (cssClass == '@font-face') {\r\n\t\t\t\t\t\t\t\tvar fontFamily = props['font-family'].value.replace(/\"/g,'');\r\n\t\t\t\t\t\t\t\tvar srcs = props['src'].value.split(',');\r\n\t\t\t\t\t\t\t\tfor (var s=0; s<srcs.length; s++) {\r\n\t\t\t\t\t\t\t\t\tif (srcs[s].indexOf('format(\"svg\")') > 0) {\r\n\t\t\t\t\t\t\t\t\t\tvar urlStart = srcs[s].indexOf('url');\r\n\t\t\t\t\t\t\t\t\t\tvar urlEnd = srcs[s].indexOf(')', urlStart);\r\n\t\t\t\t\t\t\t\t\t\tvar url = srcs[s].substr(urlStart + 5, urlEnd - urlStart - 6);\r\n\t\t\t\t\t\t\t\t\t\tvar doc = svg.parseXml(svg.ajax(url));\r\n\t\t\t\t\t\t\t\t\t\tvar fonts = doc.getElementsByTagName('font');\r\n\t\t\t\t\t\t\t\t\t\tfor (var f=0; f<fonts.length; f++) {\r\n\t\t\t\t\t\t\t\t\t\t\tvar font = svg.CreateElement(fonts[f]);\r\n\t\t\t\t\t\t\t\t\t\t\tsvg.Definitions[fontFamily] = font;\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tsvg.Element.style.prototype = new svg.Element.ElementBase;\r\n\r\n\t\t// use element\r\n\t\tsvg.Element.use = function(node) {\r\n\t\t\tthis.base = svg.Element.RenderedElementBase;\r\n\t\t\tthis.base(node);\r\n\r\n\t\t\tthis.baseSetContext = this.setContext;\r\n\t\t\tthis.setContext = function(ctx) {\r\n\t\t\t\tthis.baseSetContext(ctx);\r\n\t\t\t\tif (this.attribute('x').hasValue()) ctx.translate(this.attribute('x').toPixels('x'), 0);\r\n\t\t\t\tif (this.attribute('y').hasValue()) ctx.translate(0, this.attribute('y').toPixels('y'));\r\n\t\t\t}\r\n\r\n\t\t\tvar element = this.getHrefAttribute().getDefinition();\r\n\r\n\t\t\tthis.path = function(ctx) {\r\n\t\t\t\tif (element != null) element.path(ctx);\r\n\t\t\t}\r\n\r\n\t\t\tthis.getBoundingBox = function() {\r\n\t\t\t\tif (element != null) return element.getBoundingBox();\r\n\t\t\t}\r\n\r\n\t\t\tthis.renderChildren = function(ctx) {\r\n\t\t\t\tif (element != null) {\r\n\t\t\t\t\tvar tempSvg = element;\r\n\t\t\t\t\tif (element.type == 'symbol') {\r\n\t\t\t\t\t\t// render me using a temporary svg element in symbol cases (http://www.w3.org/TR/SVG/struct.html#UseElement)\r\n\t\t\t\t\t\ttempSvg = new svg.Element.svg();\r\n\t\t\t\t\t\ttempSvg.type = 'svg';\r\n\t\t\t\t\t\ttempSvg.attributes['viewBox'] = new svg.Property('viewBox', element.attribute('viewBox').value);\r\n\t\t\t\t\t\ttempSvg.attributes['preserveAspectRatio'] = new svg.Property('preserveAspectRatio', element.attribute('preserveAspectRatio').value);\r\n\t\t\t\t\t\ttempSvg.attributes['overflow'] = new svg.Property('overflow', element.attribute('overflow').value);\r\n\t\t\t\t\t\ttempSvg.children = element.children;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (tempSvg.type == 'svg') {\r\n\t\t\t\t\t\t// if symbol or svg, inherit width/height from me\r\n\t\t\t\t\t\tif (this.attribute('width').hasValue()) tempSvg.attributes['width'] = new svg.Property('width', this.attribute('width').value);\r\n\t\t\t\t\t\tif (this.attribute('height').hasValue()) tempSvg.attributes['height'] = new svg.Property('height', this.attribute('height').value);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar oldParent = tempSvg.parent;\r\n\t\t\t\t\ttempSvg.parent = null;\r\n\t\t\t\t\ttempSvg.render(ctx);\r\n\t\t\t\t\ttempSvg.parent = oldParent;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tsvg.Element.use.prototype = new svg.Element.RenderedElementBase;\r\n\r\n\t\t// mask element\r\n\t\tsvg.Element.mask = function(node) {\r\n\t\t\tthis.base = svg.Element.ElementBase;\r\n\t\t\tthis.base(node);\r\n\r\n\t\t\tthis.apply = function(ctx, element) {\r\n\t\t\t\t// render as temp svg\r\n\t\t\t\tvar x = this.attribute('x').toPixels('x');\r\n\t\t\t\tvar y = this.attribute('y').toPixels('y');\r\n\t\t\t\tvar width = this.attribute('width').toPixels('x');\r\n\t\t\t\tvar height = this.attribute('height').toPixels('y');\r\n\r\n\t\t\t\tif (width == 0 && height == 0) {\r\n\t\t\t\t\tvar bb = new svg.BoundingBox();\r\n\t\t\t\t\tfor (var i=0; i<this.children.length; i++) {\r\n\t\t\t\t\t\tbb.addBoundingBox(this.children[i].getBoundingBox());\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvar x = Math.floor(bb.x1);\r\n\t\t\t\t\tvar y = Math.floor(bb.y1);\r\n\t\t\t\t\tvar width = Math.floor(bb.width());\r\n\t\t\t\t\tvar\theight = Math.floor(bb.height());\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// temporarily remove mask to avoid recursion\r\n\t\t\t\tvar mask = element.attribute('mask').value;\r\n\t\t\t\telement.attribute('mask').value = '';\r\n\r\n\t\t\t\t\tvar cMask = document.createElement('canvas');\r\n\t\t\t\t\tcMask.width = x + width;\r\n\t\t\t\t\tcMask.height = y + height;\r\n\t\t\t\t\tvar maskCtx = cMask.getContext('2d');\r\n\t\t\t\t\tthis.renderChildren(maskCtx);\r\n\r\n\t\t\t\t\tvar c = document.createElement('canvas');\r\n\t\t\t\t\tc.width = x + width;\r\n\t\t\t\t\tc.height = y + height;\r\n\t\t\t\t\tvar tempCtx = c.getContext('2d');\r\n\t\t\t\t\telement.render(tempCtx);\r\n\t\t\t\t\ttempCtx.globalCompositeOperation = 'destination-in';\r\n\t\t\t\t\ttempCtx.fillStyle = maskCtx.createPattern(cMask, 'no-repeat');\r\n\t\t\t\t\ttempCtx.fillRect(0, 0, x + width, y + height);\r\n\r\n\t\t\t\t\tctx.fillStyle = tempCtx.createPattern(c, 'no-repeat');\r\n\t\t\t\t\tctx.fillRect(0, 0, x + width, y + height);\r\n\r\n\t\t\t\t// reassign mask\r\n\t\t\t\telement.attribute('mask').value = mask;\r\n\t\t\t}\r\n\r\n\t\t\tthis.render = function(ctx) {\r\n\t\t\t\t// NO RENDER\r\n\t\t\t}\r\n\t\t}\r\n\t\tsvg.Element.mask.prototype = new svg.Element.ElementBase;\r\n\r\n\t\t// clip element\r\n\t\tsvg.Element.clipPath = function(node) {\r\n\t\t\tthis.base = svg.Element.ElementBase;\r\n\t\t\tthis.base(node);\r\n\r\n\t\t\tthis.apply = function(ctx) {\r\n\t\t\t\tvar oldBeginPath = CanvasRenderingContext2D.prototype.beginPath;\r\n\t\t\t\tCanvasRenderingContext2D.prototype.beginPath = function () { };\r\n\r\n\t\t\t\tvar oldClosePath = CanvasRenderingContext2D.prototype.closePath;\r\n\t\t\t\tCanvasRenderingContext2D.prototype.closePath = function () { };\r\n\r\n\t\t\t\toldBeginPath.call(ctx);\r\n\t\t\t\tfor (var i=0; i<this.children.length; i++) {\r\n\t\t\t\t\tvar child = this.children[i];\r\n\t\t\t\t\tif (typeof child.path != 'undefined') {\r\n\t\t\t\t\t\tvar transform = null;\r\n\t\t\t\t\t\tif (child.style('transform', false, true).hasValue()) {\r\n\t\t\t\t\t\t\ttransform = new svg.Transform(child.style('transform', false, true).value);\r\n\t\t\t\t\t\t\ttransform.apply(ctx);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tchild.path(ctx);\r\n\t\t\t\t\t\tCanvasRenderingContext2D.prototype.closePath = oldClosePath;\r\n\t\t\t\t\t\tif (transform) { transform.unapply(ctx); }\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\toldClosePath.call(ctx);\r\n\t\t\t\tctx.clip();\r\n\r\n\t\t\t\tCanvasRenderingContext2D.prototype.beginPath = oldBeginPath;\r\n\t\t\t\tCanvasRenderingContext2D.prototype.closePath = oldClosePath;\r\n\t\t\t}\r\n\r\n\t\t\tthis.render = function(ctx) {\r\n\t\t\t\t// NO RENDER\r\n\t\t\t}\r\n\t\t}\r\n\t\tsvg.Element.clipPath.prototype = new svg.Element.ElementBase;\r\n\r\n\t\t// filters\r\n\t\tsvg.Element.filter = function(node) {\r\n\t\t\tthis.base = svg.Element.ElementBase;\r\n\t\t\tthis.base(node);\r\n\r\n\t\t\tthis.apply = function(ctx, element) {\r\n\t\t\t\t// render as temp svg\r\n\t\t\t\tvar bb = element.getBoundingBox();\r\n\t\t\t\tvar x = Math.floor(bb.x1);\r\n\t\t\t\tvar y = Math.floor(bb.y1);\r\n\t\t\t\tvar width = Math.floor(bb.width());\r\n\t\t\t\tvar\theight = Math.floor(bb.height());\r\n\r\n\t\t\t\t// temporarily remove filter to avoid recursion\r\n\t\t\t\tvar filter = element.style('filter').value;\r\n\t\t\t\telement.style('filter').value = '';\r\n\r\n\t\t\t\tvar px = 0, py = 0;\r\n\t\t\t\tfor (var i=0; i<this.children.length; i++) {\r\n\t\t\t\t\tvar efd = this.children[i].extraFilterDistance || 0;\r\n\t\t\t\t\tpx = Math.max(px, efd);\r\n\t\t\t\t\tpy = Math.max(py, efd);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar c = document.createElement('canvas');\r\n\t\t\t\tc.width = width + 2*px;\r\n\t\t\t\tc.height = height + 2*py;\r\n\t\t\t\tvar tempCtx = c.getContext('2d');\r\n\t\t\t\ttempCtx.translate(-x + px, -y + py);\r\n\t\t\t\telement.render(tempCtx);\r\n\r\n\t\t\t\t// apply filters\r\n\t\t\t\tfor (var i=0; i<this.children.length; i++) {\r\n\t\t\t\t\tif (typeof this.children[i].apply == 'function') {\r\n\t\t\t\t\t\tthis.children[i].apply(tempCtx, 0, 0, width + 2*px, height + 2*py);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// render on me\r\n\t\t\t\tctx.drawImage(c, 0, 0, width + 2*px, height + 2*py, x - px, y - py, width + 2*px, height + 2*py);\r\n\r\n\t\t\t\t// reassign filter\r\n\t\t\t\telement.style('filter', true).value = filter;\r\n\t\t\t}\r\n\r\n\t\t\tthis.render = function(ctx) {\r\n\t\t\t\t// NO RENDER\r\n\t\t\t}\r\n\t\t}\r\n\t\tsvg.Element.filter.prototype = new svg.Element.ElementBase;\r\n\r\n\t\tsvg.Element.feMorphology = function(node) {\r\n\t\t\tthis.base = svg.Element.ElementBase;\r\n\t\t\tthis.base(node);\r\n\r\n\t\t\tthis.apply = function(ctx, x, y, width, height) {\r\n\t\t\t\t// TODO: implement\r\n\t\t\t}\r\n\t\t}\r\n\t\tsvg.Element.feMorphology.prototype = new svg.Element.ElementBase;\r\n\r\n\t\tsvg.Element.feComposite = function(node) {\r\n\t\t\tthis.base = svg.Element.ElementBase;\r\n\t\t\tthis.base(node);\r\n\r\n\t\t\tthis.apply = function(ctx, x, y, width, height) {\r\n\t\t\t\t// TODO: implement\r\n\t\t\t}\r\n\t\t}\r\n\t\tsvg.Element.feComposite.prototype = new svg.Element.ElementBase;\r\n\r\n\t\tsvg.Element.feColorMatrix = function(node) {\r\n\t\t\tthis.base = svg.Element.ElementBase;\r\n\t\t\tthis.base(node);\r\n\r\n\t\t\tvar matrix = svg.ToNumberArray(this.attribute('values').value);\r\n\t\t\tswitch (this.attribute('type').valueOrDefault('matrix')) { // http://www.w3.org/TR/SVG/filters.html#feColorMatrixElement\r\n\t\t\t\tcase 'saturate':\r\n\t\t\t\t\tvar s = matrix[0];\r\n\t\t\t\t\tmatrix = [0.213+0.787*s,0.715-0.715*s,0.072-0.072*s,0,0,\r\n\t\t\t\t\t\t\t  0.213-0.213*s,0.715+0.285*s,0.072-0.072*s,0,0,\r\n\t\t\t\t\t\t\t  0.213-0.213*s,0.715-0.715*s,0.072+0.928*s,0,0,\r\n\t\t\t\t\t\t\t  0,0,0,1,0,\r\n\t\t\t\t\t\t\t  0,0,0,0,1];\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'hueRotate':\r\n\t\t\t\t\tvar a = matrix[0] * Math.PI / 180.0;\r\n\t\t\t\t\tvar c = function (m1,m2,m3) { return m1 + Math.cos(a)*m2 + Math.sin(a)*m3; };\r\n\t\t\t\t\tmatrix = [c(0.213,0.787,-0.213),c(0.715,-0.715,-0.715),c(0.072,-0.072,0.928),0,0,\r\n\t\t\t\t\t\t\t  c(0.213,-0.213,0.143),c(0.715,0.285,0.140),c(0.072,-0.072,-0.283),0,0,\r\n\t\t\t\t\t\t\t  c(0.213,-0.213,-0.787),c(0.715,-0.715,0.715),c(0.072,0.928,0.072),0,0,\r\n\t\t\t\t\t\t\t  0,0,0,1,0,\r\n\t\t\t\t\t\t\t  0,0,0,0,1];\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'luminanceToAlpha':\r\n\t\t\t\t\tmatrix = [0,0,0,0,0,\r\n\t\t\t\t\t\t\t  0,0,0,0,0,\r\n\t\t\t\t\t\t\t  0,0,0,0,0,\r\n\t\t\t\t\t\t\t  0.2125,0.7154,0.0721,0,0,\r\n\t\t\t\t\t\t\t  0,0,0,0,1];\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tfunction imGet(img, x, y, width, height, rgba) {\r\n\t\t\t\treturn img[y*width*4 + x*4 + rgba];\r\n\t\t\t}\r\n\r\n\t\t\tfunction imSet(img, x, y, width, height, rgba, val) {\r\n\t\t\t\timg[y*width*4 + x*4 + rgba] = val;\r\n\t\t\t}\r\n\r\n\t\t\tfunction m(i, v) {\r\n\t\t\t\tvar mi = matrix[i];\r\n\t\t\t\treturn mi * (mi < 0 ? v - 255 : v);\r\n\t\t\t}\r\n\r\n\t\t\tthis.apply = function(ctx, x, y, width, height) {\r\n\t\t\t\t// assuming x==0 && y==0 for now\r\n\t\t\t\tvar srcData = ctx.getImageData(0, 0, width, height);\r\n\t\t\t\tfor (var y = 0; y < height; y++) {\r\n\t\t\t\t\tfor (var x = 0; x < width; x++) {\r\n\t\t\t\t\t\tvar r = imGet(srcData.data, x, y, width, height, 0);\r\n\t\t\t\t\t\tvar g = imGet(srcData.data, x, y, width, height, 1);\r\n\t\t\t\t\t\tvar b = imGet(srcData.data, x, y, width, height, 2);\r\n\t\t\t\t\t\tvar a = imGet(srcData.data, x, y, width, height, 3);\r\n\t\t\t\t\t\timSet(srcData.data, x, y, width, height, 0, m(0,r)+m(1,g)+m(2,b)+m(3,a)+m(4,1));\r\n\t\t\t\t\t\timSet(srcData.data, x, y, width, height, 1, m(5,r)+m(6,g)+m(7,b)+m(8,a)+m(9,1));\r\n\t\t\t\t\t\timSet(srcData.data, x, y, width, height, 2, m(10,r)+m(11,g)+m(12,b)+m(13,a)+m(14,1));\r\n\t\t\t\t\t\timSet(srcData.data, x, y, width, height, 3, m(15,r)+m(16,g)+m(17,b)+m(18,a)+m(19,1));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tctx.clearRect(0, 0, width, height);\r\n\t\t\t\tctx.putImageData(srcData, 0, 0);\r\n\t\t\t}\r\n\t\t}\r\n\t\tsvg.Element.feColorMatrix.prototype = new svg.Element.ElementBase;\r\n\r\n\t\tsvg.Element.feGaussianBlur = function(node) {\r\n\t\t\tthis.base = svg.Element.ElementBase;\r\n\t\t\tthis.base(node);\r\n\r\n\t\t\tthis.blurRadius = Math.floor(this.attribute('stdDeviation').numValue());\r\n\t\t\tthis.extraFilterDistance = this.blurRadius;\r\n\r\n\t\t\tthis.apply = function(ctx, x, y, width, height) {\r\n\t\t\t\tif (typeof stackBlur.canvasRGBA == 'undefined') {\r\n\t\t\t\t\tsvg.log('ERROR: StackBlur.js must be included for blur to work');\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// StackBlur requires canvas be on document\r\n\t\t\t\tctx.canvas.id = svg.UniqueId();\r\n\t\t\t\tctx.canvas.style.display = 'none';\r\n\t\t\t\tdocument.body.appendChild(ctx.canvas);\r\n\t\t\t\tstackBlur.canvasRGBA(ctx.canvas.id, x, y, width, height, this.blurRadius);\r\n\t\t\t\tdocument.body.removeChild(ctx.canvas);\r\n\t\t\t}\r\n\t\t}\r\n\t\tsvg.Element.feGaussianBlur.prototype = new svg.Element.ElementBase;\r\n\r\n\t\t// title element, do nothing\r\n\t\tsvg.Element.title = function(node) {\r\n\t\t}\r\n\t\tsvg.Element.title.prototype = new svg.Element.ElementBase;\r\n\r\n\t\t// desc element, do nothing\r\n\t\tsvg.Element.desc = function(node) {\r\n\t\t}\r\n\t\tsvg.Element.desc.prototype = new svg.Element.ElementBase;\r\n\r\n\t\tsvg.Element.MISSING = function(node) {\r\n\t\t\tsvg.log('ERROR: Element \\'' + node.nodeName + '\\' not yet implemented.');\r\n\t\t}\r\n\t\tsvg.Element.MISSING.prototype = new svg.Element.ElementBase;\r\n\r\n\t\t// element factory\r\n\t\tsvg.CreateElement = function(node) {\r\n\t\t\tvar className = node.nodeName.replace(/^[^:]+:/,''); // remove namespace\r\n\t\t\tclassName = className.replace(/\\-/g,''); // remove dashes\r\n\t\t\tvar e = null;\r\n\t\t\tif (typeof svg.Element[className] != 'undefined') {\r\n\t\t\t\te = new svg.Element[className](node);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\te = new svg.Element.MISSING(node);\r\n\t\t\t}\r\n\r\n\t\t\te.type = node.nodeName;\r\n\t\t\treturn e;\r\n\t\t}\r\n\r\n\t\t// load from url\r\n\t\tsvg.load = function(ctx, url) {\r\n\t\t\tsvg.loadXml(ctx, svg.ajax(url));\r\n\t\t}\r\n\r\n\t\t// load from xml\r\n\t\tsvg.loadXml = function(ctx, xml) {\r\n\t\t\tsvg.loadXmlDoc(ctx, svg.parseXml(xml));\r\n\t\t}\r\n\r\n\t\tsvg.loadXmlDoc = function(ctx, dom) {\r\n\t\t\tsvg.init(ctx);\r\n\r\n\t\t\tvar mapXY = function(p) {\r\n\t\t\t\tvar e = ctx.canvas;\r\n\t\t\t\twhile (e) {\r\n\t\t\t\t\tp.x -= e.offsetLeft;\r\n\t\t\t\t\tp.y -= e.offsetTop;\r\n\t\t\t\t\te = e.offsetParent;\r\n\t\t\t\t}\r\n\t\t\t\tif (window.scrollX) p.x += window.scrollX;\r\n\t\t\t\tif (window.scrollY) p.y += window.scrollY;\r\n\t\t\t\treturn p;\r\n\t\t\t}\r\n\r\n\t\t\t// bind mouse\r\n\t\t\tif (svg.opts['ignoreMouse'] != true) {\r\n\t\t\t\tctx.canvas.onclick = function(e) {\r\n\t\t\t\t\tvar p = mapXY(new svg.Point(e != null ? e.clientX : event.clientX, e != null ? e.clientY : event.clientY));\r\n\t\t\t\t\tsvg.Mouse.onclick(p.x, p.y);\r\n\t\t\t\t};\r\n\t\t\t\tctx.canvas.onmousemove = function(e) {\r\n\t\t\t\t\tvar p = mapXY(new svg.Point(e != null ? e.clientX : event.clientX, e != null ? e.clientY : event.clientY));\r\n\t\t\t\t\tsvg.Mouse.onmousemove(p.x, p.y);\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\tvar e = svg.CreateElement(dom.documentElement);\r\n\t\t\te.root = true;\r\n\t\t\te.addStylesFromStyleDefinition();\r\n\r\n\t\t\t// render loop\r\n\t\t\tvar isFirstRender = true;\r\n\t\t\tvar draw = function() {\r\n\t\t\t\tsvg.ViewPort.Clear();\r\n\t\t\t\tif (ctx.canvas.parentNode) svg.ViewPort.SetCurrent(ctx.canvas.parentNode.clientWidth, ctx.canvas.parentNode.clientHeight);\r\n\r\n\t\t\t\tif (svg.opts['ignoreDimensions'] != true) {\r\n\t\t\t\t\t// set canvas size\r\n\t\t\t\t\tif (e.style('width').hasValue()) {\r\n\t\t\t\t\t\tctx.canvas.width = e.style('width').toPixels('x');\r\n\t\t\t\t\t\tctx.canvas.style.width = ctx.canvas.width + 'px';\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (e.style('height').hasValue()) {\r\n\t\t\t\t\t\tctx.canvas.height = e.style('height').toPixels('y');\r\n\t\t\t\t\t\tctx.canvas.style.height = ctx.canvas.height + 'px';\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tvar cWidth = ctx.canvas.clientWidth || ctx.canvas.width;\r\n\t\t\t\tvar cHeight = ctx.canvas.clientHeight || ctx.canvas.height;\r\n\t\t\t\tif (svg.opts['ignoreDimensions'] == true && e.style('width').hasValue() && e.style('height').hasValue()) {\r\n\t\t\t\t\tcWidth = e.style('width').toPixels('x');\r\n\t\t\t\t\tcHeight = e.style('height').toPixels('y');\r\n\t\t\t\t}\r\n\t\t\t\tsvg.ViewPort.SetCurrent(cWidth, cHeight);\r\n\r\n\t\t\t\tif (svg.opts['offsetX'] != null) e.attribute('x', true).value = svg.opts['offsetX'];\r\n\t\t\t\tif (svg.opts['offsetY'] != null) e.attribute('y', true).value = svg.opts['offsetY'];\r\n\t\t\t\tif (svg.opts['scaleWidth'] != null || svg.opts['scaleHeight'] != null) {\r\n\t\t\t\t\tvar xRatio = null, yRatio = null, viewBox = svg.ToNumberArray(e.attribute('viewBox').value);\r\n\r\n\t\t\t\t\tif (svg.opts['scaleWidth'] != null) {\r\n\t\t\t\t\t\tif (e.attribute('width').hasValue()) xRatio = e.attribute('width').toPixels('x') / svg.opts['scaleWidth'];\r\n\t\t\t\t\t\telse if (!isNaN(viewBox[2])) xRatio = viewBox[2] / svg.opts['scaleWidth'];\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (svg.opts['scaleHeight'] != null) {\r\n\t\t\t\t\t\tif (e.attribute('height').hasValue()) yRatio = e.attribute('height').toPixels('y') / svg.opts['scaleHeight'];\r\n\t\t\t\t\t\telse if (!isNaN(viewBox[3])) yRatio = viewBox[3] / svg.opts['scaleHeight'];\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (xRatio == null) { xRatio = yRatio; }\r\n\t\t\t\t\tif (yRatio == null) { yRatio = xRatio; }\r\n\r\n\t\t\t\t\te.attribute('width', true).value = svg.opts['scaleWidth'];\r\n\t\t\t\t\te.attribute('height', true).value = svg.opts['scaleHeight'];\r\n\t\t\t\t\te.style('transform', true, true).value += ' scale('+(1.0/xRatio)+','+(1.0/yRatio)+')';\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// clear and render\r\n\t\t\t\tif (svg.opts['ignoreClear'] != true) {\r\n\t\t\t\t\tctx.clearRect(0, 0, cWidth, cHeight);\r\n\t\t\t\t}\r\n\t\t\t\te.render(ctx);\r\n\t\t\t\tif (isFirstRender) {\r\n\t\t\t\t\tisFirstRender = false;\r\n\t\t\t\t\tif (typeof svg.opts['renderCallback'] == 'function') svg.opts['renderCallback'](dom);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tvar waitingForImages = true;\r\n\t\t\tif (svg.ImagesLoaded()) {\r\n\t\t\t\twaitingForImages = false;\r\n\t\t\t\tdraw();\r\n\t\t\t}\r\n\t\t\tsvg.intervalID = setInterval(function() {\r\n\t\t\t\tvar needUpdate = false;\r\n\r\n\t\t\t\tif (waitingForImages && svg.ImagesLoaded()) {\r\n\t\t\t\t\twaitingForImages = false;\r\n\t\t\t\t\tneedUpdate = true;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// need update from mouse events?\r\n\t\t\t\tif (svg.opts['ignoreMouse'] != true) {\r\n\t\t\t\t\tneedUpdate = needUpdate | svg.Mouse.hasEvents();\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// need update from animations?\r\n\t\t\t\tif (svg.opts['ignoreAnimation'] != true) {\r\n\t\t\t\t\tfor (var i=0; i<svg.Animations.length; i++) {\r\n\t\t\t\t\t\tneedUpdate = needUpdate | svg.Animations[i].update(1000 / svg.FRAMERATE);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// need update from redraw?\r\n\t\t\t\tif (typeof svg.opts['forceRedraw'] == 'function') {\r\n\t\t\t\t\tif (svg.opts['forceRedraw']() == true) needUpdate = true;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// render if needed\r\n\t\t\t\tif (needUpdate) {\r\n\t\t\t\t\tdraw();\r\n\t\t\t\t\tsvg.Mouse.runEvents(); // run and clear our events\r\n\t\t\t\t}\r\n\t\t\t}, 1000 / svg.FRAMERATE);\r\n\t\t}\r\n\r\n\t\tsvg.stop = function() {\r\n\t\t\tif (svg.intervalID) {\r\n\t\t\t\tclearInterval(svg.intervalID);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tsvg.Mouse = new (function() {\r\n\t\t\tthis.events = [];\r\n\t\t\tthis.hasEvents = function() { return this.events.length != 0; }\r\n\r\n\t\t\tthis.onclick = function(x, y) {\r\n\t\t\t\tthis.events.push({ type: 'onclick', x: x, y: y,\r\n\t\t\t\t\trun: function(e) { if (e.onclick) e.onclick(); }\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tthis.onmousemove = function(x, y) {\r\n\t\t\t\tthis.events.push({ type: 'onmousemove', x: x, y: y,\r\n\t\t\t\t\trun: function(e) { if (e.onmousemove) e.onmousemove(); }\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tthis.eventElements = [];\r\n\r\n\t\t\tthis.checkPath = function(element, ctx) {\r\n\t\t\t\tfor (var i=0; i<this.events.length; i++) {\r\n\t\t\t\t\tvar e = this.events[i];\r\n\t\t\t\t\tif (ctx.isPointInPath && ctx.isPointInPath(e.x, e.y)) this.eventElements[i] = element;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tthis.checkBoundingBox = function(element, bb) {\r\n\t\t\t\tfor (var i=0; i<this.events.length; i++) {\r\n\t\t\t\t\tvar e = this.events[i];\r\n\t\t\t\t\tif (bb.isPointInBox(e.x, e.y)) this.eventElements[i] = element;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tthis.runEvents = function() {\r\n\t\t\t\tsvg.ctx.canvas.style.cursor = '';\r\n\r\n\t\t\t\tfor (var i=0; i<this.events.length; i++) {\r\n\t\t\t\t\tvar e = this.events[i];\r\n\t\t\t\t\tvar element = this.eventElements[i];\r\n\t\t\t\t\twhile (element) {\r\n\t\t\t\t\t\te.run(element);\r\n\t\t\t\t\t\telement = element.parent;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// done running, clear\r\n\t\t\t\tthis.events = [];\r\n\t\t\t\tthis.eventElements = [];\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn svg;\r\n\t};\r\n\n\tif (typeof CanvasRenderingContext2D  != 'undefined') {\r\n\t\tCanvasRenderingContext2D.prototype.drawSvg = function(s, dx, dy, dw, dh, opts) {\r\n\t\t\tvar cOpts = {\n\t\t\t\tignoreMouse: true,\r\n\t\t\t\tignoreAnimation: true,\r\n\t\t\t\tignoreDimensions: true,\r\n\t\t\t\tignoreClear: true,\r\n\t\t\t\toffsetX: dx,\r\n\t\t\t\toffsetY: dy,\r\n\t\t\t\tscaleWidth: dw,\r\n\t\t\t\tscaleHeight: dh\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfor(var prop in opts) {\r\n\t\t\t\tif(opts.hasOwnProperty(prop)){\r\n\t\t\t\t\tcOpts[prop] = opts[prop];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tcanvg(this.canvas, s, cOpts);\r\n\t\t}\r\n\t}\r\n\r\n\treturn canvg;\r\n\r\n}));\r\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NhbnZnLW9yaWdpbi9jYW52Zy5qcz8xYjRlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFB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QUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RTs7QUFFN0U7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyw2Q0FBNkM7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixZQUFZO0FBQy9CLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZELDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixpQkFBaUI7QUFDM0MsMEJBQTBCLGlCQUFpQjs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQix5QkFBeUI7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0NBQWdDOztBQUVoRTtBQUNBLHNCQUFzQjtBQUN0Qix1QkFBdUIsNEJBQTRCO0FBQ25ELEtBQUs7QUFDTDs7QUFFQTtBQUNBLHNCQUFzQjtBQUN0Qix1QkFBdUIsb0NBQW9DO0FBQzNELEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLHNCQUFzQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDIiwiZmlsZSI6IjkzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcclxuICogY2FudmcuanMgLSBKYXZhc2NyaXB0IFNWRyBwYXJzZXIgYW5kIHJlbmRlcmVyIG9uIENhbnZhc1xyXG4gKiBNSVQgTGljZW5zZWRcclxuICogR2FiZSBMZXJuZXIgKGdhYmVsZXJuZXJAZ21haWwuY29tKVxyXG4gKiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvY2FudmcvXHJcbiAqXHJcbiAqIFJlcXVpcmVzOiByZ2Jjb2xvci5qcyAtIGh0dHA6Ly93d3cucGhwaWVkLmNvbS9yZ2ItY29sb3ItcGFyc2VyLWluLWphdmFzY3JpcHQvXHJcbiAqL1xyXG4gKGZ1bmN0aW9uICggZ2xvYmFsLCBmYWN0b3J5ICkge1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblxyXG5cdC8vIGV4cG9ydCBhcyBBTUQuLi5cclxuXHRpZiAoIHR5cGVvZiBkZWZpbmUgIT09ICd1bmRlZmluZWQnICYmIGRlZmluZS5hbWQgKSB7XHJcblx0XHRkZWZpbmUoJ2NhbnZnTW9kdWxlJywgWyAncmdiY29sb3InLCAnc3RhY2tibHVyJyBdLCBmYWN0b3J5ICk7XHJcblx0fVxyXG5cclxuXHQvLyAuLi5vciBhcyBicm93c2VyaWZ5XHJcblx0ZWxzZSBpZiAoIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzICkge1xyXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCByZXF1aXJlKCAncmdiY29sb3InICksIHJlcXVpcmUoICdzdGFja2JsdXInICkgKTtcclxuXHR9XHJcblxyXG5cdGdsb2JhbC5jYW52ZyA9IGZhY3RvcnkoIGdsb2JhbC5SR0JDb2xvciwgZ2xvYmFsLnN0YWNrQmx1ciApO1xyXG5cclxufSggdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbiAoIFJHQkNvbG9yLCBzdGFja0JsdXIgKSB7XHJcblxyXG5cdC8vIGNhbnZnKHRhcmdldCwgcylcclxuXHQvLyBlbXB0eSBwYXJhbWV0ZXJzOiByZXBsYWNlIGFsbCAnc3ZnJyBlbGVtZW50cyBvbiBwYWdlIHdpdGggJ2NhbnZhcycgZWxlbWVudHNcclxuXHQvLyB0YXJnZXQ6IGNhbnZhcyBlbGVtZW50IG9yIHRoZSBpZCBvZiBhIGNhbnZhcyBlbGVtZW50XHJcblx0Ly8gczogc3ZnIHN0cmluZywgdXJsIHRvIHN2ZyBmaWxlLCBvciB4bWwgZG9jdW1lbnRcclxuXHQvLyBvcHRzOiBvcHRpb25hbCBoYXNoIG9mIG9wdGlvbnNcclxuXHQvL1x0XHQgaWdub3JlTW91c2U6IHRydWUgPT4gaWdub3JlIG1vdXNlIGV2ZW50c1xyXG5cdC8vXHRcdCBpZ25vcmVBbmltYXRpb246IHRydWUgPT4gaWdub3JlIGFuaW1hdGlvbnNcclxuXHQvL1x0XHQgaWdub3JlRGltZW5zaW9uczogdHJ1ZSA9PiBkb2VzIG5vdCB0cnkgdG8gcmVzaXplIGNhbnZhc1xyXG5cdC8vXHRcdCBpZ25vcmVDbGVhcjogdHJ1ZSA9PiBkb2VzIG5vdCBjbGVhciBjYW52YXNcclxuXHQvL1x0XHQgb2Zmc2V0WDogaW50ID0+IGRyYXdzIGF0IGEgeCBvZmZzZXRcclxuXHQvL1x0XHQgb2Zmc2V0WTogaW50ID0+IGRyYXdzIGF0IGEgeSBvZmZzZXRcclxuXHQvL1x0XHQgc2NhbGVXaWR0aDogaW50ID0+IHNjYWxlcyBob3Jpem9udGFsbHkgdG8gd2lkdGhcclxuXHQvL1x0XHQgc2NhbGVIZWlnaHQ6IGludCA9PiBzY2FsZXMgdmVydGljYWxseSB0byBoZWlnaHRcclxuXHQvL1x0XHQgcmVuZGVyQ2FsbGJhY2s6IGZ1bmN0aW9uID0+IHdpbGwgY2FsbCB0aGUgZnVuY3Rpb24gYWZ0ZXIgdGhlIGZpcnN0IHJlbmRlciBpcyBjb21wbGV0ZWRcclxuXHQvL1x0XHQgZm9yY2VSZWRyYXc6IGZ1bmN0aW9uID0+IHdpbGwgY2FsbCB0aGUgZnVuY3Rpb24gb24gZXZlcnkgZnJhbWUsIGlmIGl0IHJldHVybnMgdHJ1ZSwgd2lsbCByZWRyYXdcclxuXHR2YXIgY2FudmcgPSBmdW5jdGlvbiAodGFyZ2V0LCBzLCBvcHRzKSB7XHJcblx0XHQvLyBubyBwYXJhbWV0ZXJzXHJcblx0XHRpZiAodGFyZ2V0ID09IG51bGwgJiYgcyA9PSBudWxsICYmIG9wdHMgPT0gbnVsbCkge1xyXG5cdFx0XHR2YXIgc3ZnVGFncyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3N2ZycpO1xyXG5cdFx0XHRmb3IgKHZhciBpPTA7IGk8c3ZnVGFncy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdHZhciBzdmdUYWcgPSBzdmdUYWdzW2ldO1xyXG5cdFx0XHRcdHZhciBjID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcblx0XHRcdFx0Yy53aWR0aCA9IHN2Z1RhZy5jbGllbnRXaWR0aDtcclxuXHRcdFx0XHRjLmhlaWdodCA9IHN2Z1RhZy5jbGllbnRIZWlnaHQ7XHJcblx0XHRcdFx0c3ZnVGFnLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGMsIHN2Z1RhZyk7XHJcblx0XHRcdFx0c3ZnVGFnLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3ZnVGFnKTtcclxuXHRcdFx0XHR2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblx0XHRcdFx0ZGl2LmFwcGVuZENoaWxkKHN2Z1RhZyk7XHJcblx0XHRcdFx0Y2FudmcoYywgZGl2LmlubmVySFRNTCk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0eXBlb2YgdGFyZ2V0ID09ICdzdHJpbmcnKSB7XHJcblx0XHRcdHRhcmdldCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRhcmdldCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gc3RvcmUgY2xhc3Mgb24gY2FudmFzXHJcblx0XHRpZiAodGFyZ2V0LnN2ZyAhPSBudWxsKSB0YXJnZXQuc3ZnLnN0b3AoKTtcclxuXHRcdHZhciBzdmcgPSBidWlsZChvcHRzIHx8IHt9KTtcclxuXHRcdC8vIG9uIGkuZS4gOCBmb3IgZmxhc2ggY2FudmFzLCB3ZSBjYW4ndCBhc3NpZ24gdGhlIHByb3BlcnR5IHNvIGNoZWNrIGZvciBpdFxyXG5cdFx0aWYgKCEodGFyZ2V0LmNoaWxkTm9kZXMubGVuZ3RoID09IDEgJiYgdGFyZ2V0LmNoaWxkTm9kZXNbMF0ubm9kZU5hbWUgPT0gJ09CSkVDVCcpKSB0YXJnZXQuc3ZnID0gc3ZnO1xyXG5cclxuXHRcdHZhciBjdHggPSB0YXJnZXQuZ2V0Q29udGV4dCgnMmQnKTtcclxuXHRcdGlmICh0eXBlb2Ygcy5kb2N1bWVudEVsZW1lbnQgIT0gJ3VuZGVmaW5lZCcpIHtcclxuXHRcdFx0Ly8gbG9hZCBmcm9tIHhtbCBkb2NcclxuXHRcdFx0c3ZnLmxvYWRYbWxEb2MoY3R4LCBzKTtcclxuXHRcdH1cclxuXHRcdGVsc2UgaWYgKHMuc3Vic3RyKDAsMSkgPT0gJzwnKSB7XHJcblx0XHRcdC8vIGxvYWQgZnJvbSB4bWwgc3RyaW5nXHJcblx0XHRcdHN2Zy5sb2FkWG1sKGN0eCwgcyk7XHJcblx0XHR9XHJcblx0XHRlbHNlIHtcclxuXHRcdFx0Ly8gbG9hZCBmcm9tIHVybFxyXG5cdFx0XHRzdmcubG9hZChjdHgsIHMpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50Lm1hdGNoZXNcclxuXHR2YXIgbWF0Y2hlc1NlbGVjdG9yO1xyXG5cdGlmICh0eXBlb2YgRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcyAhPSAndW5kZWZpbmVkJykge1xyXG5cdFx0bWF0Y2hlc1NlbGVjdG9yID0gZnVuY3Rpb24obm9kZSwgc2VsZWN0b3IpIHtcclxuXHRcdFx0cmV0dXJuIG5vZGUubWF0Y2hlcyhzZWxlY3Rvcik7XHJcblx0XHR9O1xyXG5cdH0gZWxzZSBpZiAodHlwZW9mIEVsZW1lbnQucHJvdG90eXBlLndlYmtpdE1hdGNoZXNTZWxlY3RvciAhPSAndW5kZWZpbmVkJykge1xyXG5cdFx0bWF0Y2hlc1NlbGVjdG9yID0gZnVuY3Rpb24obm9kZSwgc2VsZWN0b3IpIHtcclxuXHRcdFx0cmV0dXJuIG5vZGUud2Via2l0TWF0Y2hlc1NlbGVjdG9yKHNlbGVjdG9yKTtcclxuXHRcdH07XHJcblx0fSBlbHNlIGlmICh0eXBlb2YgRWxlbWVudC5wcm90b3R5cGUubW96TWF0Y2hlc1NlbGVjdG9yICE9ICd1bmRlZmluZWQnKSB7XHJcblx0XHRtYXRjaGVzU2VsZWN0b3IgPSBmdW5jdGlvbihub2RlLCBzZWxlY3Rvcikge1xyXG5cdFx0XHRyZXR1cm4gbm9kZS5tb3pNYXRjaGVzU2VsZWN0b3Ioc2VsZWN0b3IpO1xyXG5cdFx0fTtcclxuXHR9IGVsc2UgaWYgKHR5cGVvZiBFbGVtZW50LnByb3RvdHlwZS5tc01hdGNoZXNTZWxlY3RvciAhPSAndW5kZWZpbmVkJykge1xyXG5cdFx0bWF0Y2hlc1NlbGVjdG9yID0gZnVuY3Rpb24obm9kZSwgc2VsZWN0b3IpIHtcclxuXHRcdFx0cmV0dXJuIG5vZGUubXNNYXRjaGVzU2VsZWN0b3Ioc2VsZWN0b3IpO1xyXG5cdFx0fTtcclxuXHR9IGVsc2UgaWYgKHR5cGVvZiBFbGVtZW50LnByb3RvdHlwZS5vTWF0Y2hlc1NlbGVjdG9yICE9ICd1bmRlZmluZWQnKSB7XHJcblx0XHRtYXRjaGVzU2VsZWN0b3IgPSBmdW5jdGlvbihub2RlLCBzZWxlY3Rvcikge1xyXG5cdFx0XHRyZXR1cm4gbm9kZS5vTWF0Y2hlc1NlbGVjdG9yKHNlbGVjdG9yKTtcclxuXHRcdH07XHJcblx0fSBlbHNlIHtcclxuXHRcdC8vIHJlcXVpcmVzIFNpenpsZTogaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9zaXp6bGUvd2lraS9TaXp6bGUtRG9jdW1lbnRhdGlvblxyXG5cdFx0Ly8gb3IgalF1ZXJ5OiBodHRwOi8vanF1ZXJ5LmNvbS9kb3dubG9hZC9cclxuXHRcdC8vIG9yIFplcHRvOiBodHRwOi8vemVwdG9qcy5jb20vI1xyXG5cdFx0Ly8gd2l0aG91dCBpdCwgdGhpcyBpcyBhIFJlZmVyZW5jZUVycm9yXHJcblxyXG5cdFx0aWYgKHR5cGVvZiBqUXVlcnkgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIFplcHRvID09PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdG1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uIChub2RlLCBzZWxlY3Rvcikge1xyXG5cdFx0XHRcdHJldHVybiAkKG5vZGUpLmlzKHNlbGVjdG9yKTtcclxuXHRcdFx0fTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodHlwZW9mIG1hdGNoZXNTZWxlY3RvciA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuXHRcdFx0bWF0Y2hlc1NlbGVjdG9yID0gU2l6emxlLm1hdGNoZXNTZWxlY3RvcjtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIHNsaWdodGx5IG1vZGlmaWVkIHZlcnNpb24gb2YgaHR0cHM6Ly9naXRodWIuY29tL2tlZWdhbnN0cmVldC9zcGVjaWZpY2l0eS9ibG9iL21hc3Rlci9zcGVjaWZpY2l0eS5qc1xyXG5cdHZhciBhdHRyaWJ1dGVSZWdleCA9IC8oXFxbW15cXF1dK1xcXSkvZztcclxuXHR2YXIgaWRSZWdleCA9IC8oI1teXFxzXFwrPn5cXC5cXFs6XSspL2c7XHJcblx0dmFyIGNsYXNzUmVnZXggPSAvKFxcLlteXFxzXFwrPn5cXC5cXFs6XSspL2c7XHJcblx0dmFyIHBzZXVkb0VsZW1lbnRSZWdleCA9IC8oOjpbXlxcc1xcKz5+XFwuXFxbOl0rfDpmaXJzdC1saW5lfDpmaXJzdC1sZXR0ZXJ8OmJlZm9yZXw6YWZ0ZXIpL2dpO1xyXG5cdHZhciBwc2V1ZG9DbGFzc1dpdGhCcmFja2V0c1JlZ2V4ID0gLyg6W1xcdy1dK1xcKFteXFwpXSpcXCkpL2dpO1xyXG5cdHZhciBwc2V1ZG9DbGFzc1JlZ2V4ID0gLyg6W15cXHNcXCs+flxcLlxcWzpdKykvZztcclxuXHR2YXIgZWxlbWVudFJlZ2V4ID0gLyhbXlxcc1xcKz5+XFwuXFxbOl0rKS9nO1xyXG5cdGZ1bmN0aW9uIGdldFNlbGVjdG9yU3BlY2lmaWNpdHkoc2VsZWN0b3IpIHtcclxuXHRcdHZhciB0eXBlQ291bnQgPSBbMCwgMCwgMF07XHJcblx0XHR2YXIgZmluZE1hdGNoID0gZnVuY3Rpb24ocmVnZXgsIHR5cGUpIHtcclxuXHRcdFx0dmFyIG1hdGNoZXMgPSBzZWxlY3Rvci5tYXRjaChyZWdleCk7XHJcblx0XHRcdGlmIChtYXRjaGVzID09IG51bGwpIHtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdFx0dHlwZUNvdW50W3R5cGVdICs9IG1hdGNoZXMubGVuZ3RoO1xyXG5cdFx0XHRzZWxlY3RvciA9IHNlbGVjdG9yLnJlcGxhY2UocmVnZXgsICcgJyk7XHJcblx0XHR9O1xyXG5cclxuXHRcdHNlbGVjdG9yID0gc2VsZWN0b3IucmVwbGFjZSgvOm5vdFxcKChbXlxcKV0qKVxcKS9nLCAnICAgICAkMSAnKTtcclxuXHRcdHNlbGVjdG9yID0gc2VsZWN0b3IucmVwbGFjZSgve1tcXHNcXFNdKi9nbSwgJyAnKTtcclxuXHRcdGZpbmRNYXRjaChhdHRyaWJ1dGVSZWdleCwgMSk7XHJcblx0XHRmaW5kTWF0Y2goaWRSZWdleCwgMCk7XHJcblx0XHRmaW5kTWF0Y2goY2xhc3NSZWdleCwgMSk7XHJcblx0XHRmaW5kTWF0Y2gocHNldWRvRWxlbWVudFJlZ2V4LCAyKTtcclxuXHRcdGZpbmRNYXRjaChwc2V1ZG9DbGFzc1dpdGhCcmFja2V0c1JlZ2V4LCAxKTtcclxuXHRcdGZpbmRNYXRjaChwc2V1ZG9DbGFzc1JlZ2V4LCAxKTtcclxuXHRcdHNlbGVjdG9yID0gc2VsZWN0b3IucmVwbGFjZSgvW1xcKlxcc1xcKz5+XS9nLCAnICcpO1xyXG5cdFx0c2VsZWN0b3IgPSBzZWxlY3Rvci5yZXBsYWNlKC9bI1xcLl0vZywgJyAnKTtcclxuXHRcdGZpbmRNYXRjaChlbGVtZW50UmVnZXgsIDIpO1xyXG5cdFx0cmV0dXJuIHR5cGVDb3VudC5qb2luKCcnKTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGJ1aWxkKG9wdHMpIHtcclxuXHRcdHZhciBzdmcgPSB7IG9wdHM6IG9wdHMgfTtcclxuXHJcblx0XHRzdmcuRlJBTUVSQVRFID0gMzA7XHJcblx0XHRzdmcuTUFYX1ZJUlRVQUxfUElYRUxTID0gMzAwMDA7XHJcblxyXG5cdFx0c3ZnLmxvZyA9IGZ1bmN0aW9uKG1zZykge307XHJcblx0XHRpZiAoc3ZnLm9wdHNbJ2xvZyddID09IHRydWUgJiYgdHlwZW9mIGNvbnNvbGUgIT0gJ3VuZGVmaW5lZCcpIHtcclxuXHRcdFx0c3ZnLmxvZyA9IGZ1bmN0aW9uKG1zZykgeyBjb25zb2xlLmxvZyhtc2cpOyB9O1xyXG5cdFx0fTtcclxuXHJcblx0XHQvLyBnbG9iYWxzXHJcblx0XHRzdmcuaW5pdCA9IGZ1bmN0aW9uKGN0eCkge1xyXG5cdFx0XHR2YXIgdW5pcXVlSWQgPSAwO1xyXG5cdFx0XHRzdmcuVW5pcXVlSWQgPSBmdW5jdGlvbiAoKSB7IHVuaXF1ZUlkKys7IHJldHVybiAnY2FudmcnICsgdW5pcXVlSWQ7XHR9O1xyXG5cdFx0XHRzdmcuRGVmaW5pdGlvbnMgPSB7fTtcclxuXHRcdFx0c3ZnLlN0eWxlcyA9IHt9O1xyXG5cdFx0XHRzdmcuU3R5bGVzU3BlY2lmaWNpdHkgPSB7fTtcclxuXHRcdFx0c3ZnLkFuaW1hdGlvbnMgPSBbXTtcclxuXHRcdFx0c3ZnLkltYWdlcyA9IFtdO1xyXG5cdFx0XHRzdmcuY3R4ID0gY3R4O1xyXG5cdFx0XHRzdmcuVmlld1BvcnQgPSBuZXcgKGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0XHR0aGlzLnZpZXdQb3J0cyA9IFtdO1xyXG5cdFx0XHRcdHRoaXMuQ2xlYXIgPSBmdW5jdGlvbigpIHsgdGhpcy52aWV3UG9ydHMgPSBbXTsgfVxyXG5cdFx0XHRcdHRoaXMuU2V0Q3VycmVudCA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHsgdGhpcy52aWV3UG9ydHMucHVzaCh7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfSk7IH1cclxuXHRcdFx0XHR0aGlzLlJlbW92ZUN1cnJlbnQgPSBmdW5jdGlvbigpIHsgdGhpcy52aWV3UG9ydHMucG9wKCk7IH1cclxuXHRcdFx0XHR0aGlzLkN1cnJlbnQgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMudmlld1BvcnRzW3RoaXMudmlld1BvcnRzLmxlbmd0aCAtIDFdOyB9XHJcblx0XHRcdFx0dGhpcy53aWR0aCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5DdXJyZW50KCkud2lkdGg7IH1cclxuXHRcdFx0XHR0aGlzLmhlaWdodCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5DdXJyZW50KCkuaGVpZ2h0OyB9XHJcblx0XHRcdFx0dGhpcy5Db21wdXRlU2l6ZSA9IGZ1bmN0aW9uKGQpIHtcclxuXHRcdFx0XHRcdGlmIChkICE9IG51bGwgJiYgdHlwZW9mIGQgPT0gJ251bWJlcicpIHJldHVybiBkO1xyXG5cdFx0XHRcdFx0aWYgKGQgPT0gJ3gnKSByZXR1cm4gdGhpcy53aWR0aCgpO1xyXG5cdFx0XHRcdFx0aWYgKGQgPT0gJ3knKSByZXR1cm4gdGhpcy5oZWlnaHQoKTtcclxuXHRcdFx0XHRcdHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3codGhpcy53aWR0aCgpLCAyKSArIE1hdGgucG93KHRoaXMuaGVpZ2h0KCksIDIpKSAvIE1hdGguc3FydCgyKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdFx0c3ZnLmluaXQoKTtcclxuXHJcblx0XHQvLyBpbWFnZXMgbG9hZGVkXHJcblx0XHRzdmcuSW1hZ2VzTG9hZGVkID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdGZvciAodmFyIGk9MDsgaTxzdmcuSW1hZ2VzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0aWYgKCFzdmcuSW1hZ2VzW2ldLmxvYWRlZCkgcmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHRyaW1cclxuXHRcdHN2Zy50cmltID0gZnVuY3Rpb24ocykgeyByZXR1cm4gcy5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7IH1cclxuXHJcblx0XHQvLyBjb21wcmVzcyBzcGFjZXNcclxuXHRcdHN2Zy5jb21wcmVzc1NwYWNlcyA9IGZ1bmN0aW9uKHMpIHsgcmV0dXJuIHMucmVwbGFjZSgvW1xcc1xcclxcdFxcbl0rL2dtLCcgJyk7IH1cclxuXHJcblx0XHQvLyBhamF4XHJcblx0XHRzdmcuYWpheCA9IGZ1bmN0aW9uKHVybCkge1xyXG5cdFx0XHR2YXIgQUpBWDtcclxuXHRcdFx0aWYod2luZG93LlhNTEh0dHBSZXF1ZXN0KXtBSkFYPW5ldyBYTUxIdHRwUmVxdWVzdCgpO31cclxuXHRcdFx0ZWxzZXtBSkFYPW5ldyBBY3RpdmVYT2JqZWN0KCdNaWNyb3NvZnQuWE1MSFRUUCcpO31cclxuXHRcdFx0aWYoQUpBWCl7XHJcblx0XHRcdCAgIEFKQVgub3BlbignR0VUJyx1cmwsZmFsc2UpO1xyXG5cdFx0XHQgICBBSkFYLnNlbmQobnVsbCk7XHJcblx0XHRcdCAgIHJldHVybiBBSkFYLnJlc3BvbnNlVGV4dDtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBwYXJzZSB4bWxcclxuXHRcdHN2Zy5wYXJzZVhtbCA9IGZ1bmN0aW9uKHhtbCkge1xyXG5cdFx0XHRpZiAodHlwZW9mIFdpbmRvd3MgIT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIFdpbmRvd3MuRGF0YSAhPSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgV2luZG93cy5EYXRhLlhtbCAhPSAndW5kZWZpbmVkJykge1xyXG5cdFx0XHRcdHZhciB4bWxEb2MgPSBuZXcgV2luZG93cy5EYXRhLlhtbC5Eb20uWG1sRG9jdW1lbnQoKTtcclxuXHRcdFx0XHR2YXIgc2V0dGluZ3MgPSBuZXcgV2luZG93cy5EYXRhLlhtbC5Eb20uWG1sTG9hZFNldHRpbmdzKCk7XHJcblx0XHRcdFx0c2V0dGluZ3MucHJvaGliaXREdGQgPSBmYWxzZTtcclxuXHRcdFx0XHR4bWxEb2MubG9hZFhtbCh4bWwsIHNldHRpbmdzKTtcclxuXHRcdFx0XHRyZXR1cm4geG1sRG9jO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2UgaWYgKHdpbmRvdy5ET01QYXJzZXIpXHJcblx0XHRcdHtcclxuXHRcdFx0XHR2YXIgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xyXG5cdFx0XHRcdHJldHVybiBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHhtbCwgJ3RleHQveG1sJyk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0eG1sID0geG1sLnJlcGxhY2UoLzwhRE9DVFlQRSBzdmdbXj5dKj4vLCAnJyk7XHJcblx0XHRcdFx0dmFyIHhtbERvYyA9IG5ldyBBY3RpdmVYT2JqZWN0KCdNaWNyb3NvZnQuWE1MRE9NJyk7XHJcblx0XHRcdFx0eG1sRG9jLmFzeW5jID0gJ2ZhbHNlJztcclxuXHRcdFx0XHR4bWxEb2MubG9hZFhNTCh4bWwpO1xyXG5cdFx0XHRcdHJldHVybiB4bWxEb2M7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRzdmcuUHJvcGVydHkgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xyXG5cdFx0XHR0aGlzLm5hbWUgPSBuYW1lO1xyXG5cdFx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XHJcblx0XHR9XHJcblx0XHRcdHN2Zy5Qcm9wZXJ0eS5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy52YWx1ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0c3ZnLlByb3BlcnR5LnByb3RvdHlwZS5oYXNWYWx1ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiAodGhpcy52YWx1ZSAhPSBudWxsICYmIHRoaXMudmFsdWUgIT09ICcnKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gcmV0dXJuIHRoZSBudW1lcmljYWwgdmFsdWUgb2YgdGhlIHByb3BlcnR5XHJcblx0XHRcdHN2Zy5Qcm9wZXJ0eS5wcm90b3R5cGUubnVtVmFsdWUgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRpZiAoIXRoaXMuaGFzVmFsdWUoKSkgcmV0dXJuIDA7XHJcblxyXG5cdFx0XHRcdHZhciBuID0gcGFyc2VGbG9hdCh0aGlzLnZhbHVlKTtcclxuXHRcdFx0XHRpZiAoKHRoaXMudmFsdWUgKyAnJykubWF0Y2goLyUkLykpIHtcclxuXHRcdFx0XHRcdG4gPSBuIC8gMTAwLjA7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiBuO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRzdmcuUHJvcGVydHkucHJvdG90eXBlLnZhbHVlT3JEZWZhdWx0ID0gZnVuY3Rpb24oZGVmKSB7XHJcblx0XHRcdFx0aWYgKHRoaXMuaGFzVmFsdWUoKSkgcmV0dXJuIHRoaXMudmFsdWU7XHJcblx0XHRcdFx0cmV0dXJuIGRlZjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0c3ZnLlByb3BlcnR5LnByb3RvdHlwZS5udW1WYWx1ZU9yRGVmYXVsdCA9IGZ1bmN0aW9uKGRlZikge1xyXG5cdFx0XHRcdGlmICh0aGlzLmhhc1ZhbHVlKCkpIHJldHVybiB0aGlzLm51bVZhbHVlKCk7XHJcblx0XHRcdFx0cmV0dXJuIGRlZjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gY29sb3IgZXh0ZW5zaW9uc1xyXG5cdFx0XHRcdC8vIGF1Z21lbnQgdGhlIGN1cnJlbnQgY29sb3IgdmFsdWUgd2l0aCB0aGUgb3BhY2l0eVxyXG5cdFx0XHRcdHN2Zy5Qcm9wZXJ0eS5wcm90b3R5cGUuYWRkT3BhY2l0eSA9IGZ1bmN0aW9uKG9wYWNpdHlQcm9wKSB7XHJcblx0XHRcdFx0XHR2YXIgbmV3VmFsdWUgPSB0aGlzLnZhbHVlO1xyXG5cdFx0XHRcdFx0aWYgKG9wYWNpdHlQcm9wLnZhbHVlICE9IG51bGwgJiYgb3BhY2l0eVByb3AudmFsdWUgIT0gJycgJiYgdHlwZW9mIHRoaXMudmFsdWUgPT0gJ3N0cmluZycpIHsgLy8gY2FuIG9ubHkgYWRkIG9wYWNpdHkgdG8gY29sb3JzLCBub3QgcGF0dGVybnNcclxuXHRcdFx0XHRcdFx0dmFyIGNvbG9yID0gbmV3IFJHQkNvbG9yKHRoaXMudmFsdWUpO1xyXG5cdFx0XHRcdFx0XHRpZiAoY29sb3Iub2spIHtcclxuXHRcdFx0XHRcdFx0XHRuZXdWYWx1ZSA9ICdyZ2JhKCcgKyBjb2xvci5yICsgJywgJyArIGNvbG9yLmcgKyAnLCAnICsgY29sb3IuYiArICcsICcgKyBvcGFjaXR5UHJvcC5udW1WYWx1ZSgpICsgJyknO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRyZXR1cm4gbmV3IHN2Zy5Qcm9wZXJ0eSh0aGlzLm5hbWUsIG5ld1ZhbHVlKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBkZWZpbml0aW9uIGV4dGVuc2lvbnNcclxuXHRcdFx0XHQvLyBnZXQgdGhlIGRlZmluaXRpb24gZnJvbSB0aGUgZGVmaW5pdGlvbnMgdGFibGVcclxuXHRcdFx0XHRzdmcuUHJvcGVydHkucHJvdG90eXBlLmdldERlZmluaXRpb24gPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdHZhciBuYW1lID0gdGhpcy52YWx1ZS5tYXRjaCgvIyhbXlxcKSdcIl0rKS8pO1xyXG5cdFx0XHRcdFx0aWYgKG5hbWUpIHsgbmFtZSA9IG5hbWVbMV07IH1cclxuXHRcdFx0XHRcdGlmICghbmFtZSkgeyBuYW1lID0gdGhpcy52YWx1ZTsgfVxyXG5cdFx0XHRcdFx0cmV0dXJuIHN2Zy5EZWZpbml0aW9uc1tuYW1lXTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHN2Zy5Qcm9wZXJ0eS5wcm90b3R5cGUuaXNVcmxEZWZpbml0aW9uID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy52YWx1ZS5pbmRleE9mKCd1cmwoJykgPT0gMFxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0c3ZnLlByb3BlcnR5LnByb3RvdHlwZS5nZXRGaWxsU3R5bGVEZWZpbml0aW9uID0gZnVuY3Rpb24oZSwgb3BhY2l0eVByb3ApIHtcclxuXHRcdFx0XHRcdHZhciBkZWYgPSB0aGlzLmdldERlZmluaXRpb24oKTtcclxuXHJcblx0XHRcdFx0XHQvLyBncmFkaWVudFxyXG5cdFx0XHRcdFx0aWYgKGRlZiAhPSBudWxsICYmIGRlZi5jcmVhdGVHcmFkaWVudCkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gZGVmLmNyZWF0ZUdyYWRpZW50KHN2Zy5jdHgsIGUsIG9wYWNpdHlQcm9wKTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHQvLyBwYXR0ZXJuXHJcblx0XHRcdFx0XHRpZiAoZGVmICE9IG51bGwgJiYgZGVmLmNyZWF0ZVBhdHRlcm4pIHtcclxuXHRcdFx0XHRcdFx0aWYgKGRlZi5nZXRIcmVmQXR0cmlidXRlKCkuaGFzVmFsdWUoKSkge1xyXG5cdFx0XHRcdFx0XHRcdHZhciBwdCA9IGRlZi5hdHRyaWJ1dGUoJ3BhdHRlcm5UcmFuc2Zvcm0nKTtcclxuXHRcdFx0XHRcdFx0XHRkZWYgPSBkZWYuZ2V0SHJlZkF0dHJpYnV0ZSgpLmdldERlZmluaXRpb24oKTtcclxuXHRcdFx0XHRcdFx0XHRpZiAocHQuaGFzVmFsdWUoKSkgeyBkZWYuYXR0cmlidXRlKCdwYXR0ZXJuVHJhbnNmb3JtJywgdHJ1ZSkudmFsdWUgPSBwdC52YWx1ZTsgfVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdHJldHVybiBkZWYuY3JlYXRlUGF0dGVybihzdmcuY3R4LCBlKTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBsZW5ndGggZXh0ZW5zaW9uc1xyXG5cdFx0XHRcdHN2Zy5Qcm9wZXJ0eS5wcm90b3R5cGUuZ2V0RFBJID0gZnVuY3Rpb24odmlld1BvcnQpIHtcclxuXHRcdFx0XHRcdHJldHVybiA5Ni4wOyAvLyBUT0RPOiBjb21wdXRlP1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0c3ZnLlByb3BlcnR5LnByb3RvdHlwZS5nZXRFTSA9IGZ1bmN0aW9uKHZpZXdQb3J0KSB7XHJcblx0XHRcdFx0XHR2YXIgZW0gPSAxMjtcclxuXHJcblx0XHRcdFx0XHR2YXIgZm9udFNpemUgPSBuZXcgc3ZnLlByb3BlcnR5KCdmb250U2l6ZScsIHN2Zy5Gb250LlBhcnNlKHN2Zy5jdHguZm9udCkuZm9udFNpemUpO1xyXG5cdFx0XHRcdFx0aWYgKGZvbnRTaXplLmhhc1ZhbHVlKCkpIGVtID0gZm9udFNpemUudG9QaXhlbHModmlld1BvcnQpO1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiBlbTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHN2Zy5Qcm9wZXJ0eS5wcm90b3R5cGUuZ2V0VW5pdHMgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdHZhciBzID0gdGhpcy52YWx1ZSsnJztcclxuXHRcdFx0XHRcdHJldHVybiBzLnJlcGxhY2UoL1swLTlcXC5cXC1dL2csJycpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gZ2V0IHRoZSBsZW5ndGggYXMgcGl4ZWxzXHJcblx0XHRcdFx0c3ZnLlByb3BlcnR5LnByb3RvdHlwZS50b1BpeGVscyA9IGZ1bmN0aW9uKHZpZXdQb3J0LCBwcm9jZXNzUGVyY2VudCkge1xyXG5cdFx0XHRcdFx0aWYgKCF0aGlzLmhhc1ZhbHVlKCkpIHJldHVybiAwO1xyXG5cdFx0XHRcdFx0dmFyIHMgPSB0aGlzLnZhbHVlKycnO1xyXG5cdFx0XHRcdFx0aWYgKHMubWF0Y2goL2VtJC8pKSByZXR1cm4gdGhpcy5udW1WYWx1ZSgpICogdGhpcy5nZXRFTSh2aWV3UG9ydCk7XHJcblx0XHRcdFx0XHRpZiAocy5tYXRjaCgvZXgkLykpIHJldHVybiB0aGlzLm51bVZhbHVlKCkgKiB0aGlzLmdldEVNKHZpZXdQb3J0KSAvIDIuMDtcclxuXHRcdFx0XHRcdGlmIChzLm1hdGNoKC9weCQvKSkgcmV0dXJuIHRoaXMubnVtVmFsdWUoKTtcclxuXHRcdFx0XHRcdGlmIChzLm1hdGNoKC9wdCQvKSkgcmV0dXJuIHRoaXMubnVtVmFsdWUoKSAqIHRoaXMuZ2V0RFBJKHZpZXdQb3J0KSAqICgxLjAgLyA3Mi4wKTtcclxuXHRcdFx0XHRcdGlmIChzLm1hdGNoKC9wYyQvKSkgcmV0dXJuIHRoaXMubnVtVmFsdWUoKSAqIDE1O1xyXG5cdFx0XHRcdFx0aWYgKHMubWF0Y2goL2NtJC8pKSByZXR1cm4gdGhpcy5udW1WYWx1ZSgpICogdGhpcy5nZXREUEkodmlld1BvcnQpIC8gMi41NDtcclxuXHRcdFx0XHRcdGlmIChzLm1hdGNoKC9tbSQvKSkgcmV0dXJuIHRoaXMubnVtVmFsdWUoKSAqIHRoaXMuZ2V0RFBJKHZpZXdQb3J0KSAvIDI1LjQ7XHJcblx0XHRcdFx0XHRpZiAocy5tYXRjaCgvaW4kLykpIHJldHVybiB0aGlzLm51bVZhbHVlKCkgKiB0aGlzLmdldERQSSh2aWV3UG9ydCk7XHJcblx0XHRcdFx0XHRpZiAocy5tYXRjaCgvJSQvKSkgcmV0dXJuIHRoaXMubnVtVmFsdWUoKSAqIHN2Zy5WaWV3UG9ydC5Db21wdXRlU2l6ZSh2aWV3UG9ydCk7XHJcblx0XHRcdFx0XHR2YXIgbiA9IHRoaXMubnVtVmFsdWUoKTtcclxuXHRcdFx0XHRcdGlmIChwcm9jZXNzUGVyY2VudCAmJiBuIDwgMS4wKSByZXR1cm4gbiAqIHN2Zy5WaWV3UG9ydC5Db21wdXRlU2l6ZSh2aWV3UG9ydCk7XHJcblx0XHRcdFx0XHRyZXR1cm4gbjtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHQvLyB0aW1lIGV4dGVuc2lvbnNcclxuXHRcdFx0XHQvLyBnZXQgdGhlIHRpbWUgYXMgbWlsbGlzZWNvbmRzXHJcblx0XHRcdFx0c3ZnLlByb3BlcnR5LnByb3RvdHlwZS50b01pbGxpc2Vjb25kcyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0aWYgKCF0aGlzLmhhc1ZhbHVlKCkpIHJldHVybiAwO1xyXG5cdFx0XHRcdFx0dmFyIHMgPSB0aGlzLnZhbHVlKycnO1xyXG5cdFx0XHRcdFx0aWYgKHMubWF0Y2goL3MkLykpIHJldHVybiB0aGlzLm51bVZhbHVlKCkgKiAxMDAwO1xyXG5cdFx0XHRcdFx0aWYgKHMubWF0Y2goL21zJC8pKSByZXR1cm4gdGhpcy5udW1WYWx1ZSgpO1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMubnVtVmFsdWUoKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBhbmdsZSBleHRlbnNpb25zXHJcblx0XHRcdFx0Ly8gZ2V0IHRoZSBhbmdsZSBhcyByYWRpYW5zXHJcblx0XHRcdFx0c3ZnLlByb3BlcnR5LnByb3RvdHlwZS50b1JhZGlhbnMgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdGlmICghdGhpcy5oYXNWYWx1ZSgpKSByZXR1cm4gMDtcclxuXHRcdFx0XHRcdHZhciBzID0gdGhpcy52YWx1ZSsnJztcclxuXHRcdFx0XHRcdGlmIChzLm1hdGNoKC9kZWckLykpIHJldHVybiB0aGlzLm51bVZhbHVlKCkgKiAoTWF0aC5QSSAvIDE4MC4wKTtcclxuXHRcdFx0XHRcdGlmIChzLm1hdGNoKC9ncmFkJC8pKSByZXR1cm4gdGhpcy5udW1WYWx1ZSgpICogKE1hdGguUEkgLyAyMDAuMCk7XHJcblx0XHRcdFx0XHRpZiAocy5tYXRjaCgvcmFkJC8pKSByZXR1cm4gdGhpcy5udW1WYWx1ZSgpO1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMubnVtVmFsdWUoKSAqIChNYXRoLlBJIC8gMTgwLjApO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdC8vIHRleHQgZXh0ZW5zaW9uc1xyXG5cdFx0XHRcdC8vIGdldCB0aGUgdGV4dCBiYXNlbGluZVxyXG5cdFx0XHRcdHZhciB0ZXh0QmFzZWxpbmVNYXBwaW5nID0ge1xyXG5cdFx0XHRcdFx0J2Jhc2VsaW5lJzogJ2FscGhhYmV0aWMnLFxyXG5cdFx0XHRcdFx0J2JlZm9yZS1lZGdlJzogJ3RvcCcsXHJcblx0XHRcdFx0XHQndGV4dC1iZWZvcmUtZWRnZSc6ICd0b3AnLFxyXG5cdFx0XHRcdFx0J21pZGRsZSc6ICdtaWRkbGUnLFxyXG5cdFx0XHRcdFx0J2NlbnRyYWwnOiAnbWlkZGxlJyxcclxuXHRcdFx0XHRcdCdhZnRlci1lZGdlJzogJ2JvdHRvbScsXHJcblx0XHRcdFx0XHQndGV4dC1hZnRlci1lZGdlJzogJ2JvdHRvbScsXHJcblx0XHRcdFx0XHQnaWRlb2dyYXBoaWMnOiAnaWRlb2dyYXBoaWMnLFxyXG5cdFx0XHRcdFx0J2FscGhhYmV0aWMnOiAnYWxwaGFiZXRpYycsXHJcblx0XHRcdFx0XHQnaGFuZ2luZyc6ICdoYW5naW5nJyxcclxuXHRcdFx0XHRcdCdtYXRoZW1hdGljYWwnOiAnYWxwaGFiZXRpYydcclxuXHRcdFx0XHR9O1xyXG5cdFx0XHRcdHN2Zy5Qcm9wZXJ0eS5wcm90b3R5cGUudG9UZXh0QmFzZWxpbmUgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdFx0XHRpZiAoIXRoaXMuaGFzVmFsdWUoKSkgcmV0dXJuIG51bGw7XHJcblx0XHRcdFx0XHRyZXR1cm4gdGV4dEJhc2VsaW5lTWFwcGluZ1t0aGlzLnZhbHVlXTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0Ly8gZm9udHNcclxuXHRcdHN2Zy5Gb250ID0gbmV3IChmdW5jdGlvbigpIHtcclxuXHRcdFx0dGhpcy5TdHlsZXMgPSAnbm9ybWFsfGl0YWxpY3xvYmxpcXVlfGluaGVyaXQnO1xyXG5cdFx0XHR0aGlzLlZhcmlhbnRzID0gJ25vcm1hbHxzbWFsbC1jYXBzfGluaGVyaXQnO1xyXG5cdFx0XHR0aGlzLldlaWdodHMgPSAnbm9ybWFsfGJvbGR8Ym9sZGVyfGxpZ2h0ZXJ8MTAwfDIwMHwzMDB8NDAwfDUwMHw2MDB8NzAwfDgwMHw5MDB8aW5oZXJpdCc7XHJcblxyXG5cdFx0XHR0aGlzLkNyZWF0ZUZvbnQgPSBmdW5jdGlvbihmb250U3R5bGUsIGZvbnRWYXJpYW50LCBmb250V2VpZ2h0LCBmb250U2l6ZSwgZm9udEZhbWlseSwgaW5oZXJpdCkge1xyXG5cdFx0XHRcdHZhciBmID0gaW5oZXJpdCAhPSBudWxsID8gdGhpcy5QYXJzZShpbmhlcml0KSA6IHRoaXMuQ3JlYXRlRm9udCgnJywgJycsICcnLCAnJywgJycsIHN2Zy5jdHguZm9udCk7XHJcblx0XHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRcdGZvbnRGYW1pbHk6IGZvbnRGYW1pbHkgfHwgZi5mb250RmFtaWx5LFxyXG5cdFx0XHRcdFx0Zm9udFNpemU6IGZvbnRTaXplIHx8IGYuZm9udFNpemUsXHJcblx0XHRcdFx0XHRmb250U3R5bGU6IGZvbnRTdHlsZSB8fCBmLmZvbnRTdHlsZSxcclxuXHRcdFx0XHRcdGZvbnRXZWlnaHQ6IGZvbnRXZWlnaHQgfHwgZi5mb250V2VpZ2h0LFxyXG5cdFx0XHRcdFx0Zm9udFZhcmlhbnQ6IGZvbnRWYXJpYW50IHx8IGYuZm9udFZhcmlhbnQsXHJcblx0XHRcdFx0XHR0b1N0cmluZzogZnVuY3Rpb24gKCkgeyByZXR1cm4gW3RoaXMuZm9udFN0eWxlLCB0aGlzLmZvbnRWYXJpYW50LCB0aGlzLmZvbnRXZWlnaHQsIHRoaXMuZm9udFNpemUsIHRoaXMuZm9udEZhbWlseV0uam9pbignICcpIH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciB0aGF0ID0gdGhpcztcclxuXHRcdFx0dGhpcy5QYXJzZSA9IGZ1bmN0aW9uKHMpIHtcclxuXHRcdFx0XHR2YXIgZiA9IHt9O1xyXG5cdFx0XHRcdHZhciBkID0gc3ZnLnRyaW0oc3ZnLmNvbXByZXNzU3BhY2VzKHMgfHwgJycpKS5zcGxpdCgnICcpO1xyXG5cdFx0XHRcdHZhciBzZXQgPSB7IGZvbnRTaXplOiBmYWxzZSwgZm9udFN0eWxlOiBmYWxzZSwgZm9udFdlaWdodDogZmFsc2UsIGZvbnRWYXJpYW50OiBmYWxzZSB9XHJcblx0XHRcdFx0dmFyIGZmID0gJyc7XHJcblx0XHRcdFx0Zm9yICh2YXIgaT0wOyBpPGQubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdGlmICghc2V0LmZvbnRTdHlsZSAmJiB0aGF0LlN0eWxlcy5pbmRleE9mKGRbaV0pICE9IC0xKSB7IGlmIChkW2ldICE9ICdpbmhlcml0JykgZi5mb250U3R5bGUgPSBkW2ldOyBzZXQuZm9udFN0eWxlID0gdHJ1ZTsgfVxyXG5cdFx0XHRcdFx0ZWxzZSBpZiAoIXNldC5mb250VmFyaWFudCAmJiB0aGF0LlZhcmlhbnRzLmluZGV4T2YoZFtpXSkgIT0gLTEpIHsgaWYgKGRbaV0gIT0gJ2luaGVyaXQnKSBmLmZvbnRWYXJpYW50ID0gZFtpXTsgc2V0LmZvbnRTdHlsZSA9IHNldC5mb250VmFyaWFudCA9IHRydWU7XHR9XHJcblx0XHRcdFx0XHRlbHNlIGlmICghc2V0LmZvbnRXZWlnaHQgJiYgdGhhdC5XZWlnaHRzLmluZGV4T2YoZFtpXSkgIT0gLTEpIHtcdGlmIChkW2ldICE9ICdpbmhlcml0JykgZi5mb250V2VpZ2h0ID0gZFtpXTsgc2V0LmZvbnRTdHlsZSA9IHNldC5mb250VmFyaWFudCA9IHNldC5mb250V2VpZ2h0ID0gdHJ1ZTsgfVxyXG5cdFx0XHRcdFx0ZWxzZSBpZiAoIXNldC5mb250U2l6ZSkgeyBpZiAoZFtpXSAhPSAnaW5oZXJpdCcpIGYuZm9udFNpemUgPSBkW2ldLnNwbGl0KCcvJylbMF07IHNldC5mb250U3R5bGUgPSBzZXQuZm9udFZhcmlhbnQgPSBzZXQuZm9udFdlaWdodCA9IHNldC5mb250U2l6ZSA9IHRydWU7IH1cclxuXHRcdFx0XHRcdGVsc2UgeyBpZiAoZFtpXSAhPSAnaW5oZXJpdCcpIGZmICs9IGRbaV07IH1cclxuXHRcdFx0XHR9IGlmIChmZiAhPSAnJykgZi5mb250RmFtaWx5ID0gZmY7XHJcblx0XHRcdFx0cmV0dXJuIGY7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vIHBvaW50cyBhbmQgcGF0aHNcclxuXHRcdHN2Zy5Ub051bWJlckFycmF5ID0gZnVuY3Rpb24ocykge1xyXG5cdFx0XHR2YXIgYSA9IHN2Zy50cmltKHN2Zy5jb21wcmVzc1NwYWNlcygocyB8fCAnJykucmVwbGFjZSgvLC9nLCAnICcpKSkuc3BsaXQoJyAnKTtcclxuXHRcdFx0Zm9yICh2YXIgaT0wOyBpPGEubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRhW2ldID0gcGFyc2VGbG9hdChhW2ldKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gYTtcclxuXHRcdH1cclxuXHRcdHN2Zy5Qb2ludCA9IGZ1bmN0aW9uKHgsIHkpIHtcclxuXHRcdFx0dGhpcy54ID0geDtcclxuXHRcdFx0dGhpcy55ID0geTtcclxuXHRcdH1cclxuXHRcdFx0c3ZnLlBvaW50LnByb3RvdHlwZS5hbmdsZVRvID0gZnVuY3Rpb24ocCkge1xyXG5cdFx0XHRcdHJldHVybiBNYXRoLmF0YW4yKHAueSAtIHRoaXMueSwgcC54IC0gdGhpcy54KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0c3ZnLlBvaW50LnByb3RvdHlwZS5hcHBseVRyYW5zZm9ybSA9IGZ1bmN0aW9uKHYpIHtcclxuXHRcdFx0XHR2YXIgeHAgPSB0aGlzLnggKiB2WzBdICsgdGhpcy55ICogdlsyXSArIHZbNF07XHJcblx0XHRcdFx0dmFyIHlwID0gdGhpcy54ICogdlsxXSArIHRoaXMueSAqIHZbM10gKyB2WzVdO1xyXG5cdFx0XHRcdHRoaXMueCA9IHhwO1xyXG5cdFx0XHRcdHRoaXMueSA9IHlwO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0c3ZnLkNyZWF0ZVBvaW50ID0gZnVuY3Rpb24ocykge1xyXG5cdFx0XHR2YXIgYSA9IHN2Zy5Ub051bWJlckFycmF5KHMpO1xyXG5cdFx0XHRyZXR1cm4gbmV3IHN2Zy5Qb2ludChhWzBdLCBhWzFdKTtcclxuXHRcdH1cclxuXHRcdHN2Zy5DcmVhdGVQYXRoID0gZnVuY3Rpb24ocykge1xyXG5cdFx0XHR2YXIgYSA9IHN2Zy5Ub051bWJlckFycmF5KHMpO1xyXG5cdFx0XHR2YXIgcGF0aCA9IFtdO1xyXG5cdFx0XHRmb3IgKHZhciBpPTA7IGk8YS5sZW5ndGg7IGkrPTIpIHtcclxuXHRcdFx0XHRwYXRoLnB1c2gobmV3IHN2Zy5Qb2ludChhW2ldLCBhW2krMV0pKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gcGF0aDtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBib3VuZGluZyBib3hcclxuXHRcdHN2Zy5Cb3VuZGluZ0JveCA9IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyKSB7IC8vIHBhc3MgaW4gaW5pdGlhbCBwb2ludHMgaWYgeW91IHdhbnRcclxuXHRcdFx0dGhpcy54MSA9IE51bWJlci5OYU47XHJcblx0XHRcdHRoaXMueTEgPSBOdW1iZXIuTmFOO1xyXG5cdFx0XHR0aGlzLngyID0gTnVtYmVyLk5hTjtcclxuXHRcdFx0dGhpcy55MiA9IE51bWJlci5OYU47XHJcblxyXG5cdFx0XHR0aGlzLnggPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMueDE7IH1cclxuXHRcdFx0dGhpcy55ID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnkxOyB9XHJcblx0XHRcdHRoaXMud2lkdGggPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMueDIgLSB0aGlzLngxOyB9XHJcblx0XHRcdHRoaXMuaGVpZ2h0ID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnkyIC0gdGhpcy55MTsgfVxyXG5cclxuXHRcdFx0dGhpcy5hZGRQb2ludCA9IGZ1bmN0aW9uKHgsIHkpIHtcclxuXHRcdFx0XHRpZiAoeCAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHRpZiAoaXNOYU4odGhpcy54MSkgfHwgaXNOYU4odGhpcy54MikpIHtcclxuXHRcdFx0XHRcdFx0dGhpcy54MSA9IHg7XHJcblx0XHRcdFx0XHRcdHRoaXMueDIgPSB4O1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKHggPCB0aGlzLngxKSB0aGlzLngxID0geDtcclxuXHRcdFx0XHRcdGlmICh4ID4gdGhpcy54MikgdGhpcy54MiA9IHg7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoeSAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHRpZiAoaXNOYU4odGhpcy55MSkgfHwgaXNOYU4odGhpcy55MikpIHtcclxuXHRcdFx0XHRcdFx0dGhpcy55MSA9IHk7XHJcblx0XHRcdFx0XHRcdHRoaXMueTIgPSB5O1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKHkgPCB0aGlzLnkxKSB0aGlzLnkxID0geTtcclxuXHRcdFx0XHRcdGlmICh5ID4gdGhpcy55MikgdGhpcy55MiA9IHk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMuYWRkWCA9IGZ1bmN0aW9uKHgpIHsgdGhpcy5hZGRQb2ludCh4LCBudWxsKTsgfVxyXG5cdFx0XHR0aGlzLmFkZFkgPSBmdW5jdGlvbih5KSB7IHRoaXMuYWRkUG9pbnQobnVsbCwgeSk7IH1cclxuXHJcblx0XHRcdHRoaXMuYWRkQm91bmRpbmdCb3ggPSBmdW5jdGlvbihiYikge1xyXG5cdFx0XHRcdHRoaXMuYWRkUG9pbnQoYmIueDEsIGJiLnkxKTtcclxuXHRcdFx0XHR0aGlzLmFkZFBvaW50KGJiLngyLCBiYi55Mik7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuYWRkUXVhZHJhdGljQ3VydmUgPSBmdW5jdGlvbihwMHgsIHAweSwgcDF4LCBwMXksIHAyeCwgcDJ5KSB7XHJcblx0XHRcdFx0dmFyIGNwMXggPSBwMHggKyAyLzMgKiAocDF4IC0gcDB4KTsgLy8gQ1AxID0gUVAwICsgMi8zICooUVAxLVFQMClcclxuXHRcdFx0XHR2YXIgY3AxeSA9IHAweSArIDIvMyAqIChwMXkgLSBwMHkpOyAvLyBDUDEgPSBRUDAgKyAyLzMgKihRUDEtUVAwKVxyXG5cdFx0XHRcdHZhciBjcDJ4ID0gY3AxeCArIDEvMyAqIChwMnggLSBwMHgpOyAvLyBDUDIgPSBDUDEgKyAxLzMgKihRUDItUVAwKVxyXG5cdFx0XHRcdHZhciBjcDJ5ID0gY3AxeSArIDEvMyAqIChwMnkgLSBwMHkpOyAvLyBDUDIgPSBDUDEgKyAxLzMgKihRUDItUVAwKVxyXG5cdFx0XHRcdHRoaXMuYWRkQmV6aWVyQ3VydmUocDB4LCBwMHksIGNwMXgsIGNwMngsIGNwMXksXHRjcDJ5LCBwMngsIHAyeSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuYWRkQmV6aWVyQ3VydmUgPSBmdW5jdGlvbihwMHgsIHAweSwgcDF4LCBwMXksIHAyeCwgcDJ5LCBwM3gsIHAzeSkge1xyXG5cdFx0XHRcdC8vIGZyb20gaHR0cDovL2Jsb2cuaGFja2Vycy1jYWZlLm5ldC8yMDA5LzA2L2hvdy10by1jYWxjdWxhdGUtYmV6aWVyLWN1cnZlcy1ib3VuZGluZy5odG1sXHJcblx0XHRcdFx0dmFyIHAwID0gW3AweCwgcDB5XSwgcDEgPSBbcDF4LCBwMXldLCBwMiA9IFtwMngsIHAyeV0sIHAzID0gW3AzeCwgcDN5XTtcclxuXHRcdFx0XHR0aGlzLmFkZFBvaW50KHAwWzBdLCBwMFsxXSk7XHJcblx0XHRcdFx0dGhpcy5hZGRQb2ludChwM1swXSwgcDNbMV0pO1xyXG5cclxuXHRcdFx0XHRmb3IgKGk9MDsgaTw9MTsgaSsrKSB7XHJcblx0XHRcdFx0XHR2YXIgZiA9IGZ1bmN0aW9uKHQpIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIE1hdGgucG93KDEtdCwgMykgKiBwMFtpXVxyXG5cdFx0XHRcdFx0XHQrIDMgKiBNYXRoLnBvdygxLXQsIDIpICogdCAqIHAxW2ldXHJcblx0XHRcdFx0XHRcdCsgMyAqICgxLXQpICogTWF0aC5wb3codCwgMikgKiBwMltpXVxyXG5cdFx0XHRcdFx0XHQrIE1hdGgucG93KHQsIDMpICogcDNbaV07XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0dmFyIGIgPSA2ICogcDBbaV0gLSAxMiAqIHAxW2ldICsgNiAqIHAyW2ldO1xyXG5cdFx0XHRcdFx0dmFyIGEgPSAtMyAqIHAwW2ldICsgOSAqIHAxW2ldIC0gOSAqIHAyW2ldICsgMyAqIHAzW2ldO1xyXG5cdFx0XHRcdFx0dmFyIGMgPSAzICogcDFbaV0gLSAzICogcDBbaV07XHJcblxyXG5cdFx0XHRcdFx0aWYgKGEgPT0gMCkge1xyXG5cdFx0XHRcdFx0XHRpZiAoYiA9PSAwKSBjb250aW51ZTtcclxuXHRcdFx0XHRcdFx0dmFyIHQgPSAtYyAvIGI7XHJcblx0XHRcdFx0XHRcdGlmICgwIDwgdCAmJiB0IDwgMSkge1xyXG5cdFx0XHRcdFx0XHRcdGlmIChpID09IDApIHRoaXMuYWRkWChmKHQpKTtcclxuXHRcdFx0XHRcdFx0XHRpZiAoaSA9PSAxKSB0aGlzLmFkZFkoZih0KSk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0dmFyIGIyYWMgPSBNYXRoLnBvdyhiLCAyKSAtIDQgKiBjICogYTtcclxuXHRcdFx0XHRcdGlmIChiMmFjIDwgMCkgY29udGludWU7XHJcblx0XHRcdFx0XHR2YXIgdDEgPSAoLWIgKyBNYXRoLnNxcnQoYjJhYykpIC8gKDIgKiBhKTtcclxuXHRcdFx0XHRcdGlmICgwIDwgdDEgJiYgdDEgPCAxKSB7XHJcblx0XHRcdFx0XHRcdGlmIChpID09IDApIHRoaXMuYWRkWChmKHQxKSk7XHJcblx0XHRcdFx0XHRcdGlmIChpID09IDEpIHRoaXMuYWRkWShmKHQxKSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR2YXIgdDIgPSAoLWIgLSBNYXRoLnNxcnQoYjJhYykpIC8gKDIgKiBhKTtcclxuXHRcdFx0XHRcdGlmICgwIDwgdDIgJiYgdDIgPCAxKSB7XHJcblx0XHRcdFx0XHRcdGlmIChpID09IDApIHRoaXMuYWRkWChmKHQyKSk7XHJcblx0XHRcdFx0XHRcdGlmIChpID09IDEpIHRoaXMuYWRkWShmKHQyKSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmlzUG9pbnRJbkJveCA9IGZ1bmN0aW9uKHgsIHkpIHtcclxuXHRcdFx0XHRyZXR1cm4gKHRoaXMueDEgPD0geCAmJiB4IDw9IHRoaXMueDIgJiYgdGhpcy55MSA8PSB5ICYmIHkgPD0gdGhpcy55Mik7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuYWRkUG9pbnQoeDEsIHkxKTtcclxuXHRcdFx0dGhpcy5hZGRQb2ludCh4MiwgeTIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHRyYW5zZm9ybXNcclxuXHRcdHN2Zy5UcmFuc2Zvcm0gPSBmdW5jdGlvbih2KSB7XHJcblx0XHRcdHZhciB0aGF0ID0gdGhpcztcclxuXHRcdFx0dGhpcy5UeXBlID0ge31cclxuXHJcblx0XHRcdC8vIHRyYW5zbGF0ZVxyXG5cdFx0XHR0aGlzLlR5cGUudHJhbnNsYXRlID0gZnVuY3Rpb24ocykge1xyXG5cdFx0XHRcdHRoaXMucCA9IHN2Zy5DcmVhdGVQb2ludChzKTtcclxuXHRcdFx0XHR0aGlzLmFwcGx5ID0gZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdFx0XHRjdHgudHJhbnNsYXRlKHRoaXMucC54IHx8IDAuMCwgdGhpcy5wLnkgfHwgMC4wKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dGhpcy51bmFwcGx5ID0gZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdFx0XHRjdHgudHJhbnNsYXRlKC0xLjAgKiB0aGlzLnAueCB8fCAwLjAsIC0xLjAgKiB0aGlzLnAueSB8fCAwLjApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0aGlzLmFwcGx5VG9Qb2ludCA9IGZ1bmN0aW9uKHApIHtcclxuXHRcdFx0XHRcdHAuYXBwbHlUcmFuc2Zvcm0oWzEsIDAsIDAsIDEsIHRoaXMucC54IHx8IDAuMCwgdGhpcy5wLnkgfHwgMC4wXSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyByb3RhdGVcclxuXHRcdFx0dGhpcy5UeXBlLnJvdGF0ZSA9IGZ1bmN0aW9uKHMpIHtcclxuXHRcdFx0XHR2YXIgYSA9IHN2Zy5Ub051bWJlckFycmF5KHMpO1xyXG5cdFx0XHRcdHRoaXMuYW5nbGUgPSBuZXcgc3ZnLlByb3BlcnR5KCdhbmdsZScsIGFbMF0pO1xyXG5cdFx0XHRcdHRoaXMuY3ggPSBhWzFdIHx8IDA7XHJcblx0XHRcdFx0dGhpcy5jeSA9IGFbMl0gfHwgMDtcclxuXHRcdFx0XHR0aGlzLmFwcGx5ID0gZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdFx0XHRjdHgudHJhbnNsYXRlKHRoaXMuY3gsIHRoaXMuY3kpO1xyXG5cdFx0XHRcdFx0Y3R4LnJvdGF0ZSh0aGlzLmFuZ2xlLnRvUmFkaWFucygpKTtcclxuXHRcdFx0XHRcdGN0eC50cmFuc2xhdGUoLXRoaXMuY3gsIC10aGlzLmN5KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dGhpcy51bmFwcGx5ID0gZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdFx0XHRjdHgudHJhbnNsYXRlKHRoaXMuY3gsIHRoaXMuY3kpO1xyXG5cdFx0XHRcdFx0Y3R4LnJvdGF0ZSgtMS4wICogdGhpcy5hbmdsZS50b1JhZGlhbnMoKSk7XHJcblx0XHRcdFx0XHRjdHgudHJhbnNsYXRlKC10aGlzLmN4LCAtdGhpcy5jeSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRoaXMuYXBwbHlUb1BvaW50ID0gZnVuY3Rpb24ocCkge1xyXG5cdFx0XHRcdFx0dmFyIGEgPSB0aGlzLmFuZ2xlLnRvUmFkaWFucygpO1xyXG5cdFx0XHRcdFx0cC5hcHBseVRyYW5zZm9ybShbMSwgMCwgMCwgMSwgdGhpcy5wLnggfHwgMC4wLCB0aGlzLnAueSB8fCAwLjBdKTtcclxuXHRcdFx0XHRcdHAuYXBwbHlUcmFuc2Zvcm0oW01hdGguY29zKGEpLCBNYXRoLnNpbihhKSwgLU1hdGguc2luKGEpLCBNYXRoLmNvcyhhKSwgMCwgMF0pO1xyXG5cdFx0XHRcdFx0cC5hcHBseVRyYW5zZm9ybShbMSwgMCwgMCwgMSwgLXRoaXMucC54IHx8IDAuMCwgLXRoaXMucC55IHx8IDAuMF0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5UeXBlLnNjYWxlID0gZnVuY3Rpb24ocykge1xyXG5cdFx0XHRcdHRoaXMucCA9IHN2Zy5DcmVhdGVQb2ludChzKTtcclxuXHRcdFx0XHR0aGlzLmFwcGx5ID0gZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdFx0XHRjdHguc2NhbGUodGhpcy5wLnggfHwgMS4wLCB0aGlzLnAueSB8fCB0aGlzLnAueCB8fCAxLjApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0aGlzLnVuYXBwbHkgPSBmdW5jdGlvbihjdHgpIHtcclxuXHRcdFx0XHRcdGN0eC5zY2FsZSgxLjAgLyB0aGlzLnAueCB8fCAxLjAsIDEuMCAvIHRoaXMucC55IHx8IHRoaXMucC54IHx8IDEuMCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRoaXMuYXBwbHlUb1BvaW50ID0gZnVuY3Rpb24ocCkge1xyXG5cdFx0XHRcdFx0cC5hcHBseVRyYW5zZm9ybShbdGhpcy5wLnggfHwgMC4wLCAwLCAwLCB0aGlzLnAueSB8fCAwLjAsIDAsIDBdKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuVHlwZS5tYXRyaXggPSBmdW5jdGlvbihzKSB7XHJcblx0XHRcdFx0dGhpcy5tID0gc3ZnLlRvTnVtYmVyQXJyYXkocyk7XHJcblx0XHRcdFx0dGhpcy5hcHBseSA9IGZ1bmN0aW9uKGN0eCkge1xyXG5cdFx0XHRcdFx0Y3R4LnRyYW5zZm9ybSh0aGlzLm1bMF0sIHRoaXMubVsxXSwgdGhpcy5tWzJdLCB0aGlzLm1bM10sIHRoaXMubVs0XSwgdGhpcy5tWzVdKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dGhpcy51bmFwcGx5ID0gZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdFx0XHR2YXIgYSA9IHRoaXMubVswXTtcclxuXHRcdFx0XHRcdHZhciBiID0gdGhpcy5tWzJdO1xyXG5cdFx0XHRcdFx0dmFyIGMgPSB0aGlzLm1bNF07XHJcblx0XHRcdFx0XHR2YXIgZCA9IHRoaXMubVsxXTtcclxuXHRcdFx0XHRcdHZhciBlID0gdGhpcy5tWzNdO1xyXG5cdFx0XHRcdFx0dmFyIGYgPSB0aGlzLm1bNV07XHJcblx0XHRcdFx0XHR2YXIgZyA9IDAuMDtcclxuXHRcdFx0XHRcdHZhciBoID0gMC4wO1xyXG5cdFx0XHRcdFx0dmFyIGkgPSAxLjA7XHJcblx0XHRcdFx0XHR2YXIgZGV0ID0gMSAvIChhKihlKmktZipoKS1iKihkKmktZipnKStjKihkKmgtZSpnKSk7XHJcblx0XHRcdFx0XHRjdHgudHJhbnNmb3JtKFxyXG5cdFx0XHRcdFx0XHRkZXQqKGUqaS1mKmgpLFxyXG5cdFx0XHRcdFx0XHRkZXQqKGYqZy1kKmkpLFxyXG5cdFx0XHRcdFx0XHRkZXQqKGMqaC1iKmkpLFxyXG5cdFx0XHRcdFx0XHRkZXQqKGEqaS1jKmcpLFxyXG5cdFx0XHRcdFx0XHRkZXQqKGIqZi1jKmUpLFxyXG5cdFx0XHRcdFx0XHRkZXQqKGMqZC1hKmYpXHJcblx0XHRcdFx0XHQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0aGlzLmFwcGx5VG9Qb2ludCA9IGZ1bmN0aW9uKHApIHtcclxuXHRcdFx0XHRcdHAuYXBwbHlUcmFuc2Zvcm0odGhpcy5tKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuVHlwZS5Ta2V3QmFzZSA9IGZ1bmN0aW9uKHMpIHtcclxuXHRcdFx0XHR0aGlzLmJhc2UgPSB0aGF0LlR5cGUubWF0cml4O1xyXG5cdFx0XHRcdHRoaXMuYmFzZShzKTtcclxuXHRcdFx0XHR0aGlzLmFuZ2xlID0gbmV3IHN2Zy5Qcm9wZXJ0eSgnYW5nbGUnLCBzKTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLlR5cGUuU2tld0Jhc2UucHJvdG90eXBlID0gbmV3IHRoaXMuVHlwZS5tYXRyaXg7XHJcblxyXG5cdFx0XHR0aGlzLlR5cGUuc2tld1ggPSBmdW5jdGlvbihzKSB7XHJcblx0XHRcdFx0dGhpcy5iYXNlID0gdGhhdC5UeXBlLlNrZXdCYXNlO1xyXG5cdFx0XHRcdHRoaXMuYmFzZShzKTtcclxuXHRcdFx0XHR0aGlzLm0gPSBbMSwgMCwgTWF0aC50YW4odGhpcy5hbmdsZS50b1JhZGlhbnMoKSksIDEsIDAsIDBdO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMuVHlwZS5za2V3WC5wcm90b3R5cGUgPSBuZXcgdGhpcy5UeXBlLlNrZXdCYXNlO1xyXG5cclxuXHRcdFx0dGhpcy5UeXBlLnNrZXdZID0gZnVuY3Rpb24ocykge1xyXG5cdFx0XHRcdHRoaXMuYmFzZSA9IHRoYXQuVHlwZS5Ta2V3QmFzZTtcclxuXHRcdFx0XHR0aGlzLmJhc2Uocyk7XHJcblx0XHRcdFx0dGhpcy5tID0gWzEsIE1hdGgudGFuKHRoaXMuYW5nbGUudG9SYWRpYW5zKCkpLCAwLCAxLCAwLCAwXTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLlR5cGUuc2tld1kucHJvdG90eXBlID0gbmV3IHRoaXMuVHlwZS5Ta2V3QmFzZTtcclxuXHJcblx0XHRcdHRoaXMudHJhbnNmb3JtcyA9IFtdO1xyXG5cclxuXHRcdFx0dGhpcy5hcHBseSA9IGZ1bmN0aW9uKGN0eCkge1xyXG5cdFx0XHRcdGZvciAodmFyIGk9MDsgaTx0aGlzLnRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdHRoaXMudHJhbnNmb3Jtc1tpXS5hcHBseShjdHgpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy51bmFwcGx5ID0gZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdFx0Zm9yICh2YXIgaT10aGlzLnRyYW5zZm9ybXMubGVuZ3RoLTE7IGk+PTA7IGktLSkge1xyXG5cdFx0XHRcdFx0dGhpcy50cmFuc2Zvcm1zW2ldLnVuYXBwbHkoY3R4KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuYXBwbHlUb1BvaW50ID0gZnVuY3Rpb24ocCkge1xyXG5cdFx0XHRcdGZvciAodmFyIGk9MDsgaTx0aGlzLnRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdHRoaXMudHJhbnNmb3Jtc1tpXS5hcHBseVRvUG9pbnQocCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgZGF0YSA9IHN2Zy50cmltKHN2Zy5jb21wcmVzc1NwYWNlcyh2KSkucmVwbGFjZSgvXFwpKFthLXpBLVpdKS9nLCAnKSAkMScpLnJlcGxhY2UoL1xcKShcXHM/LFxccz8pL2csJykgJykuc3BsaXQoL1xccyg/PVthLXpdKS8pO1xyXG5cdFx0XHRmb3IgKHZhciBpPTA7IGk8ZGF0YS5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdHZhciB0eXBlID0gc3ZnLnRyaW0oZGF0YVtpXS5zcGxpdCgnKCcpWzBdKTtcclxuXHRcdFx0XHR2YXIgcyA9IGRhdGFbaV0uc3BsaXQoJygnKVsxXS5yZXBsYWNlKCcpJywnJyk7XHJcblx0XHRcdFx0dmFyIHRyYW5zZm9ybVR5cGUgPSB0aGlzLlR5cGVbdHlwZV07XHJcblx0XHRcdFx0aWYgKHR5cGVvZiB0cmFuc2Zvcm1UeXBlICE9ICd1bmRlZmluZWQnKSB7XHJcblx0XHRcdFx0XHR2YXIgdHJhbnNmb3JtID0gbmV3IHRyYW5zZm9ybVR5cGUocyk7XHJcblx0XHRcdFx0XHR0cmFuc2Zvcm0udHlwZSA9IHR5cGU7XHJcblx0XHRcdFx0XHR0aGlzLnRyYW5zZm9ybXMucHVzaCh0cmFuc2Zvcm0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGFzcGVjdCByYXRpb1xyXG5cdFx0c3ZnLkFzcGVjdFJhdGlvID0gZnVuY3Rpb24oY3R4LCBhc3BlY3RSYXRpbywgd2lkdGgsIGRlc2lyZWRXaWR0aCwgaGVpZ2h0LCBkZXNpcmVkSGVpZ2h0LCBtaW5YLCBtaW5ZLCByZWZYLCByZWZZKSB7XHJcblx0XHRcdC8vIGFzcGVjdCByYXRpbyAtIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9jb29yZHMuaHRtbCNQcmVzZXJ2ZUFzcGVjdFJhdGlvQXR0cmlidXRlXHJcblx0XHRcdGFzcGVjdFJhdGlvID0gc3ZnLmNvbXByZXNzU3BhY2VzKGFzcGVjdFJhdGlvKTtcclxuXHRcdFx0YXNwZWN0UmF0aW8gPSBhc3BlY3RSYXRpby5yZXBsYWNlKC9eZGVmZXJcXHMvLCcnKTsgLy8gaWdub3JlIGRlZmVyXHJcblx0XHRcdHZhciBhbGlnbiA9IGFzcGVjdFJhdGlvLnNwbGl0KCcgJylbMF0gfHwgJ3hNaWRZTWlkJztcclxuXHRcdFx0dmFyIG1lZXRPclNsaWNlID0gYXNwZWN0UmF0aW8uc3BsaXQoJyAnKVsxXSB8fCAnbWVldCc7XHJcblxyXG5cdFx0XHQvLyBjYWxjdWxhdGUgc2NhbGVcclxuXHRcdFx0dmFyIHNjYWxlWCA9IHdpZHRoIC8gZGVzaXJlZFdpZHRoO1xyXG5cdFx0XHR2YXIgc2NhbGVZID0gaGVpZ2h0IC8gZGVzaXJlZEhlaWdodDtcclxuXHRcdFx0dmFyIHNjYWxlTWluID0gTWF0aC5taW4oc2NhbGVYLCBzY2FsZVkpO1xyXG5cdFx0XHR2YXIgc2NhbGVNYXggPSBNYXRoLm1heChzY2FsZVgsIHNjYWxlWSk7XHJcblx0XHRcdGlmIChtZWV0T3JTbGljZSA9PSAnbWVldCcpIHsgZGVzaXJlZFdpZHRoICo9IHNjYWxlTWluOyBkZXNpcmVkSGVpZ2h0ICo9IHNjYWxlTWluOyB9XHJcblx0XHRcdGlmIChtZWV0T3JTbGljZSA9PSAnc2xpY2UnKSB7IGRlc2lyZWRXaWR0aCAqPSBzY2FsZU1heDsgZGVzaXJlZEhlaWdodCAqPSBzY2FsZU1heDsgfVxyXG5cclxuXHRcdFx0cmVmWCA9IG5ldyBzdmcuUHJvcGVydHkoJ3JlZlgnLCByZWZYKTtcclxuXHRcdFx0cmVmWSA9IG5ldyBzdmcuUHJvcGVydHkoJ3JlZlknLCByZWZZKTtcclxuXHRcdFx0aWYgKHJlZlguaGFzVmFsdWUoKSAmJiByZWZZLmhhc1ZhbHVlKCkpIHtcclxuXHRcdFx0XHRjdHgudHJhbnNsYXRlKC1zY2FsZU1pbiAqIHJlZlgudG9QaXhlbHMoJ3gnKSwgLXNjYWxlTWluICogcmVmWS50b1BpeGVscygneScpKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIHtcclxuXHRcdFx0XHQvLyBhbGlnblxyXG5cdFx0XHRcdGlmIChhbGlnbi5tYXRjaCgvXnhNaWQvKSAmJiAoKG1lZXRPclNsaWNlID09ICdtZWV0JyAmJiBzY2FsZU1pbiA9PSBzY2FsZVkpIHx8IChtZWV0T3JTbGljZSA9PSAnc2xpY2UnICYmIHNjYWxlTWF4ID09IHNjYWxlWSkpKSBjdHgudHJhbnNsYXRlKHdpZHRoIC8gMi4wIC0gZGVzaXJlZFdpZHRoIC8gMi4wLCAwKTtcclxuXHRcdFx0XHRpZiAoYWxpZ24ubWF0Y2goL1lNaWQkLykgJiYgKChtZWV0T3JTbGljZSA9PSAnbWVldCcgJiYgc2NhbGVNaW4gPT0gc2NhbGVYKSB8fCAobWVldE9yU2xpY2UgPT0gJ3NsaWNlJyAmJiBzY2FsZU1heCA9PSBzY2FsZVgpKSkgY3R4LnRyYW5zbGF0ZSgwLCBoZWlnaHQgLyAyLjAgLSBkZXNpcmVkSGVpZ2h0IC8gMi4wKTtcclxuXHRcdFx0XHRpZiAoYWxpZ24ubWF0Y2goL154TWF4LykgJiYgKChtZWV0T3JTbGljZSA9PSAnbWVldCcgJiYgc2NhbGVNaW4gPT0gc2NhbGVZKSB8fCAobWVldE9yU2xpY2UgPT0gJ3NsaWNlJyAmJiBzY2FsZU1heCA9PSBzY2FsZVkpKSkgY3R4LnRyYW5zbGF0ZSh3aWR0aCAtIGRlc2lyZWRXaWR0aCwgMCk7XHJcblx0XHRcdFx0aWYgKGFsaWduLm1hdGNoKC9ZTWF4JC8pICYmICgobWVldE9yU2xpY2UgPT0gJ21lZXQnICYmIHNjYWxlTWluID09IHNjYWxlWCkgfHwgKG1lZXRPclNsaWNlID09ICdzbGljZScgJiYgc2NhbGVNYXggPT0gc2NhbGVYKSkpIGN0eC50cmFuc2xhdGUoMCwgaGVpZ2h0IC0gZGVzaXJlZEhlaWdodCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIHNjYWxlXHJcblx0XHRcdGlmIChhbGlnbiA9PSAnbm9uZScpIGN0eC5zY2FsZShzY2FsZVgsIHNjYWxlWSk7XHJcblx0XHRcdGVsc2UgaWYgKG1lZXRPclNsaWNlID09ICdtZWV0JykgY3R4LnNjYWxlKHNjYWxlTWluLCBzY2FsZU1pbik7XHJcblx0XHRcdGVsc2UgaWYgKG1lZXRPclNsaWNlID09ICdzbGljZScpIGN0eC5zY2FsZShzY2FsZU1heCwgc2NhbGVNYXgpO1xyXG5cclxuXHRcdFx0Ly8gdHJhbnNsYXRlXHJcblx0XHRcdGN0eC50cmFuc2xhdGUobWluWCA9PSBudWxsID8gMCA6IC1taW5YLCBtaW5ZID09IG51bGwgPyAwIDogLW1pblkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGVsZW1lbnRzXHJcblx0XHRzdmcuRWxlbWVudCA9IHt9XHJcblxyXG5cdFx0c3ZnLkVtcHR5UHJvcGVydHkgPSBuZXcgc3ZnLlByb3BlcnR5KCdFTVBUWScsICcnKTtcclxuXHJcblx0XHRzdmcuRWxlbWVudC5FbGVtZW50QmFzZSA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdFx0dGhpcy5hdHRyaWJ1dGVzID0ge307XHJcblx0XHRcdHRoaXMuc3R5bGVzID0ge307XHJcblx0XHRcdHRoaXMuc3R5bGVzU3BlY2lmaWNpdHkgPSB7fTtcclxuXHRcdFx0dGhpcy5jaGlsZHJlbiA9IFtdO1xyXG5cclxuXHRcdFx0Ly8gZ2V0IG9yIGNyZWF0ZSBhdHRyaWJ1dGVcclxuXHRcdFx0dGhpcy5hdHRyaWJ1dGUgPSBmdW5jdGlvbihuYW1lLCBjcmVhdGVJZk5vdEV4aXN0cykge1xyXG5cdFx0XHRcdHZhciBhID0gdGhpcy5hdHRyaWJ1dGVzW25hbWVdO1xyXG5cdFx0XHRcdGlmIChhICE9IG51bGwpIHJldHVybiBhO1xyXG5cclxuXHRcdFx0XHRpZiAoY3JlYXRlSWZOb3RFeGlzdHMgPT0gdHJ1ZSkgeyBhID0gbmV3IHN2Zy5Qcm9wZXJ0eShuYW1lLCAnJyk7IHRoaXMuYXR0cmlidXRlc1tuYW1lXSA9IGE7IH1cclxuXHRcdFx0XHRyZXR1cm4gYSB8fCBzdmcuRW1wdHlQcm9wZXJ0eTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5nZXRIcmVmQXR0cmlidXRlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0Zm9yICh2YXIgYSBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcclxuXHRcdFx0XHRcdGlmIChhID09ICdocmVmJyB8fCBhLm1hdGNoKC86aHJlZiQvKSkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzW2FdO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gc3ZnLkVtcHR5UHJvcGVydHk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGdldCBvciBjcmVhdGUgc3R5bGUsIGNyYXdscyB1cCBub2RlIHRyZWVcclxuXHRcdFx0dGhpcy5zdHlsZSA9IGZ1bmN0aW9uKG5hbWUsIGNyZWF0ZUlmTm90RXhpc3RzLCBza2lwQW5jZXN0b3JzKSB7XHJcblx0XHRcdFx0dmFyIHMgPSB0aGlzLnN0eWxlc1tuYW1lXTtcclxuXHRcdFx0XHRpZiAocyAhPSBudWxsKSByZXR1cm4gcztcclxuXHJcblx0XHRcdFx0dmFyIGEgPSB0aGlzLmF0dHJpYnV0ZShuYW1lKTtcclxuXHRcdFx0XHRpZiAoYSAhPSBudWxsICYmIGEuaGFzVmFsdWUoKSkge1xyXG5cdFx0XHRcdFx0dGhpcy5zdHlsZXNbbmFtZV0gPSBhOyAvLyBtb3ZlIHVwIHRvIG1lIHRvIGNhY2hlXHJcblx0XHRcdFx0XHRyZXR1cm4gYTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChza2lwQW5jZXN0b3JzICE9IHRydWUpIHtcclxuXHRcdFx0XHRcdHZhciBwID0gdGhpcy5wYXJlbnQ7XHJcblx0XHRcdFx0XHRpZiAocCAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdHZhciBwcyA9IHAuc3R5bGUobmFtZSk7XHJcblx0XHRcdFx0XHRcdGlmIChwcyAhPSBudWxsICYmIHBzLmhhc1ZhbHVlKCkpIHtcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcHM7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChjcmVhdGVJZk5vdEV4aXN0cyA9PSB0cnVlKSB7IHMgPSBuZXcgc3ZnLlByb3BlcnR5KG5hbWUsICcnKTsgdGhpcy5zdHlsZXNbbmFtZV0gPSBzOyB9XHJcblx0XHRcdFx0cmV0dXJuIHMgfHwgc3ZnLkVtcHR5UHJvcGVydHk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGJhc2UgcmVuZGVyXHJcblx0XHRcdHRoaXMucmVuZGVyID0gZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdFx0Ly8gZG9uJ3QgcmVuZGVyIGRpc3BsYXk9bm9uZVxyXG5cdFx0XHRcdGlmICh0aGlzLnN0eWxlKCdkaXNwbGF5JykudmFsdWUgPT0gJ25vbmUnKSByZXR1cm47XHJcblxyXG5cdFx0XHRcdC8vIGRvbid0IHJlbmRlciB2aXNpYmlsaXR5PWhpZGRlblxyXG5cdFx0XHRcdGlmICh0aGlzLnN0eWxlKCd2aXNpYmlsaXR5JykudmFsdWUgPT0gJ2hpZGRlbicpIHJldHVybjtcclxuXHJcblx0XHRcdFx0Y3R4LnNhdmUoKTtcclxuXHRcdFx0XHRpZiAodGhpcy5zdHlsZSgnbWFzaycpLmhhc1ZhbHVlKCkpIHsgLy8gbWFza1xyXG5cdFx0XHRcdFx0dmFyIG1hc2sgPSB0aGlzLnN0eWxlKCdtYXNrJykuZ2V0RGVmaW5pdGlvbigpO1xyXG5cdFx0XHRcdFx0aWYgKG1hc2sgIT0gbnVsbCkgbWFzay5hcHBseShjdHgsIHRoaXMpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIGlmICh0aGlzLnN0eWxlKCdmaWx0ZXInKS5oYXNWYWx1ZSgpKSB7IC8vIGZpbHRlclxyXG5cdFx0XHRcdFx0dmFyIGZpbHRlciA9IHRoaXMuc3R5bGUoJ2ZpbHRlcicpLmdldERlZmluaXRpb24oKTtcclxuXHRcdFx0XHRcdGlmIChmaWx0ZXIgIT0gbnVsbCkgZmlsdGVyLmFwcGx5KGN0eCwgdGhpcyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0dGhpcy5zZXRDb250ZXh0KGN0eCk7XHJcblx0XHRcdFx0XHR0aGlzLnJlbmRlckNoaWxkcmVuKGN0eCk7XHJcblx0XHRcdFx0XHR0aGlzLmNsZWFyQ29udGV4dChjdHgpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRjdHgucmVzdG9yZSgpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBiYXNlIHNldCBjb250ZXh0XHJcblx0XHRcdHRoaXMuc2V0Q29udGV4dCA9IGZ1bmN0aW9uKGN0eCkge1xyXG5cdFx0XHRcdC8vIE9WRVJSSURFIE1FIVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBiYXNlIGNsZWFyIGNvbnRleHRcclxuXHRcdFx0dGhpcy5jbGVhckNvbnRleHQgPSBmdW5jdGlvbihjdHgpIHtcclxuXHRcdFx0XHQvLyBPVkVSUklERSBNRSFcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gYmFzZSByZW5kZXIgY2hpbGRyZW5cclxuXHRcdFx0dGhpcy5yZW5kZXJDaGlsZHJlbiA9IGZ1bmN0aW9uKGN0eCkge1xyXG5cdFx0XHRcdGZvciAodmFyIGk9MDsgaTx0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHR0aGlzLmNoaWxkcmVuW2ldLnJlbmRlcihjdHgpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5hZGRDaGlsZCA9IGZ1bmN0aW9uKGNoaWxkTm9kZSwgY3JlYXRlKSB7XHJcblx0XHRcdFx0dmFyIGNoaWxkID0gY2hpbGROb2RlO1xyXG5cdFx0XHRcdGlmIChjcmVhdGUpIGNoaWxkID0gc3ZnLkNyZWF0ZUVsZW1lbnQoY2hpbGROb2RlKTtcclxuXHRcdFx0XHRjaGlsZC5wYXJlbnQgPSB0aGlzO1xyXG5cdFx0XHRcdGlmIChjaGlsZC50eXBlICE9ICd0aXRsZScpIHsgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5hZGRTdHlsZXNGcm9tU3R5bGVEZWZpbml0aW9uID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRcdC8vIGFkZCBzdHlsZXNcclxuXHRcdFx0XHRmb3IgKHZhciBzZWxlY3RvciBpbiBzdmcuU3R5bGVzKSB7XHJcblx0XHRcdFx0XHRpZiAoc2VsZWN0b3JbMF0gIT0gJ0AnICYmIG1hdGNoZXNTZWxlY3Rvcihub2RlLCBzZWxlY3RvcikpIHtcclxuXHRcdFx0XHRcdFx0dmFyIHN0eWxlcyA9IHN2Zy5TdHlsZXNbc2VsZWN0b3JdO1xyXG5cdFx0XHRcdFx0XHR2YXIgc3BlY2lmaWNpdHkgPSBzdmcuU3R5bGVzU3BlY2lmaWNpdHlbc2VsZWN0b3JdO1xyXG5cdFx0XHRcdFx0XHRpZiAoc3R5bGVzICE9IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBuYW1lIGluIHN0eWxlcykge1xyXG5cdFx0XHRcdFx0XHRcdFx0dmFyIGV4aXN0aW5nU3BlY2lmaWNpdHkgPSB0aGlzLnN0eWxlc1NwZWNpZmljaXR5W25hbWVdO1xyXG5cdFx0XHRcdFx0XHRcdFx0aWYgKHR5cGVvZiBleGlzdGluZ1NwZWNpZmljaXR5ID09ICd1bmRlZmluZWQnKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGV4aXN0aW5nU3BlY2lmaWNpdHkgPSAnMDAwJztcclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdGlmIChzcGVjaWZpY2l0eSA+IGV4aXN0aW5nU3BlY2lmaWNpdHkpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5zdHlsZXNbbmFtZV0gPSBzdHlsZXNbbmFtZV07XHJcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuc3R5bGVzU3BlY2lmaWNpdHlbbmFtZV0gPSBzcGVjaWZpY2l0eTtcclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH07XHJcblx0XHRcdFxyXG5cdFx0XHQvLyBNaWNyb3NvZnQgRWRnZSBmaXhcclxuXHRcdFx0dmFyIGFsbFVwcGVyY2FzZSA9IG5ldyBSZWdFeHAoXCJeW0EtWlxcLV0rJFwiKTtcclxuXHRcdFx0dmFyIG5vcm1hbGl6ZUF0dHJpYnV0ZU5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xyXG5cdFx0XHRcdGlmIChhbGxVcHBlcmNhc2UudGVzdChuYW1lKSkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIG5hbWUudG9Mb3dlckNhc2UoKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIG5hbWU7XHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRpZiAobm9kZSAhPSBudWxsICYmIG5vZGUubm9kZVR5cGUgPT0gMSkgeyAvL0VMRU1FTlRfTk9ERVxyXG5cdFx0XHRcdC8vIGFkZCBhdHRyaWJ1dGVzXHJcblx0XHRcdFx0Zm9yICh2YXIgaT0wOyBpPG5vZGUuYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0dmFyIGF0dHJpYnV0ZSA9IG5vZGUuYXR0cmlidXRlc1tpXTtcclxuXHRcdFx0XHRcdHZhciBub2RlTmFtZSA9IG5vcm1hbGl6ZUF0dHJpYnV0ZU5hbWUoYXR0cmlidXRlLm5vZGVOYW1lKTtcclxuXHRcdFx0XHRcdHRoaXMuYXR0cmlidXRlc1tub2RlTmFtZV0gPSBuZXcgc3ZnLlByb3BlcnR5KG5vZGVOYW1lLCBhdHRyaWJ1dGUudmFsdWUpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5hZGRTdHlsZXNGcm9tU3R5bGVEZWZpbml0aW9uKCk7XHJcblxyXG5cdFx0XHRcdC8vIGFkZCBpbmxpbmUgc3R5bGVzXHJcblx0XHRcdFx0aWYgKHRoaXMuYXR0cmlidXRlKCdzdHlsZScpLmhhc1ZhbHVlKCkpIHtcclxuXHRcdFx0XHRcdHZhciBzdHlsZXMgPSB0aGlzLmF0dHJpYnV0ZSgnc3R5bGUnKS52YWx1ZS5zcGxpdCgnOycpO1xyXG5cdFx0XHRcdFx0Zm9yICh2YXIgaT0wOyBpPHN0eWxlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0XHRpZiAoc3ZnLnRyaW0oc3R5bGVzW2ldKSAhPSAnJykge1xyXG5cdFx0XHRcdFx0XHRcdHZhciBzdHlsZSA9IHN0eWxlc1tpXS5zcGxpdCgnOicpO1xyXG5cdFx0XHRcdFx0XHRcdHZhciBuYW1lID0gc3ZnLnRyaW0oc3R5bGVbMF0pO1xyXG5cdFx0XHRcdFx0XHRcdHZhciB2YWx1ZSA9IHN2Zy50cmltKHN0eWxlWzFdKTtcclxuXHRcdFx0XHRcdFx0XHR0aGlzLnN0eWxlc1tuYW1lXSA9IG5ldyBzdmcuUHJvcGVydHkobmFtZSwgdmFsdWUpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBhZGQgaWRcclxuXHRcdFx0XHRpZiAodGhpcy5hdHRyaWJ1dGUoJ2lkJykuaGFzVmFsdWUoKSkge1xyXG5cdFx0XHRcdFx0aWYgKHN2Zy5EZWZpbml0aW9uc1t0aGlzLmF0dHJpYnV0ZSgnaWQnKS52YWx1ZV0gPT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHRzdmcuRGVmaW5pdGlvbnNbdGhpcy5hdHRyaWJ1dGUoJ2lkJykudmFsdWVdID0gdGhpcztcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIGFkZCBjaGlsZHJlblxyXG5cdFx0XHRcdGZvciAodmFyIGk9MDsgaTxub2RlLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdHZhciBjaGlsZE5vZGUgPSBub2RlLmNoaWxkTm9kZXNbaV07XHJcblx0XHRcdFx0XHRpZiAoY2hpbGROb2RlLm5vZGVUeXBlID09IDEpIHRoaXMuYWRkQ2hpbGQoY2hpbGROb2RlLCB0cnVlKTsgLy9FTEVNRU5UX05PREVcclxuXHRcdFx0XHRcdGlmICh0aGlzLmNhcHR1cmVUZXh0Tm9kZXMgJiYgKGNoaWxkTm9kZS5ub2RlVHlwZSA9PSAzIHx8IGNoaWxkTm9kZS5ub2RlVHlwZSA9PSA0KSkge1xyXG5cdFx0XHRcdFx0XHR2YXIgdGV4dCA9IGNoaWxkTm9kZS52YWx1ZSB8fCBjaGlsZE5vZGUudGV4dCB8fCBjaGlsZE5vZGUudGV4dENvbnRlbnQgfHwgJyc7XHJcblx0XHRcdFx0XHRcdGlmIChzdmcuY29tcHJlc3NTcGFjZXModGV4dCkgIT0gJycpIHtcclxuXHRcdFx0XHRcdFx0XHR0aGlzLmFkZENoaWxkKG5ldyBzdmcuRWxlbWVudC50c3BhbihjaGlsZE5vZGUpLCBmYWxzZSk7IC8vIFRFWFRfTk9ERVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0c3ZnLkVsZW1lbnQuUmVuZGVyZWRFbGVtZW50QmFzZSA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdFx0dGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XHJcblx0XHRcdHRoaXMuYmFzZShub2RlKTtcclxuXHJcblx0XHRcdHRoaXMuc2V0Q29udGV4dCA9IGZ1bmN0aW9uKGN0eCkge1xyXG5cdFx0XHRcdC8vIGZpbGxcclxuXHRcdFx0XHRpZiAodGhpcy5zdHlsZSgnZmlsbCcpLmlzVXJsRGVmaW5pdGlvbigpKSB7XHJcblx0XHRcdFx0XHR2YXIgZnMgPSB0aGlzLnN0eWxlKCdmaWxsJykuZ2V0RmlsbFN0eWxlRGVmaW5pdGlvbih0aGlzLCB0aGlzLnN0eWxlKCdmaWxsLW9wYWNpdHknKSk7XHJcblx0XHRcdFx0XHRpZiAoZnMgIT0gbnVsbCkgY3R4LmZpbGxTdHlsZSA9IGZzO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIGlmICh0aGlzLnN0eWxlKCdmaWxsJykuaGFzVmFsdWUoKSkge1xyXG5cdFx0XHRcdFx0dmFyIGZpbGxTdHlsZSA9IHRoaXMuc3R5bGUoJ2ZpbGwnKTtcclxuXHRcdFx0XHRcdGlmIChmaWxsU3R5bGUudmFsdWUgPT0gJ2N1cnJlbnRDb2xvcicpIGZpbGxTdHlsZS52YWx1ZSA9IHRoaXMuc3R5bGUoJ2NvbG9yJykudmFsdWU7XHJcblx0XHRcdFx0XHRpZiAoZmlsbFN0eWxlLnZhbHVlICE9ICdpbmhlcml0JykgY3R4LmZpbGxTdHlsZSA9IChmaWxsU3R5bGUudmFsdWUgPT0gJ25vbmUnID8gJ3JnYmEoMCwwLDAsMCknIDogZmlsbFN0eWxlLnZhbHVlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKHRoaXMuc3R5bGUoJ2ZpbGwtb3BhY2l0eScpLmhhc1ZhbHVlKCkpIHtcclxuXHRcdFx0XHRcdHZhciBmaWxsU3R5bGUgPSBuZXcgc3ZnLlByb3BlcnR5KCdmaWxsJywgY3R4LmZpbGxTdHlsZSk7XHJcblx0XHRcdFx0XHRmaWxsU3R5bGUgPSBmaWxsU3R5bGUuYWRkT3BhY2l0eSh0aGlzLnN0eWxlKCdmaWxsLW9wYWNpdHknKSk7XHJcblx0XHRcdFx0XHRjdHguZmlsbFN0eWxlID0gZmlsbFN0eWxlLnZhbHVlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gc3Ryb2tlXHJcblx0XHRcdFx0aWYgKHRoaXMuc3R5bGUoJ3N0cm9rZScpLmlzVXJsRGVmaW5pdGlvbigpKSB7XHJcblx0XHRcdFx0XHR2YXIgZnMgPSB0aGlzLnN0eWxlKCdzdHJva2UnKS5nZXRGaWxsU3R5bGVEZWZpbml0aW9uKHRoaXMsIHRoaXMuc3R5bGUoJ3N0cm9rZS1vcGFjaXR5JykpO1xyXG5cdFx0XHRcdFx0aWYgKGZzICE9IG51bGwpIGN0eC5zdHJva2VTdHlsZSA9IGZzO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIGlmICh0aGlzLnN0eWxlKCdzdHJva2UnKS5oYXNWYWx1ZSgpKSB7XHJcblx0XHRcdFx0XHR2YXIgc3Ryb2tlU3R5bGUgPSB0aGlzLnN0eWxlKCdzdHJva2UnKTtcclxuXHRcdFx0XHRcdGlmIChzdHJva2VTdHlsZS52YWx1ZSA9PSAnY3VycmVudENvbG9yJykgc3Ryb2tlU3R5bGUudmFsdWUgPSB0aGlzLnN0eWxlKCdjb2xvcicpLnZhbHVlO1xyXG5cdFx0XHRcdFx0aWYgKHN0cm9rZVN0eWxlLnZhbHVlICE9ICdpbmhlcml0JykgY3R4LnN0cm9rZVN0eWxlID0gKHN0cm9rZVN0eWxlLnZhbHVlID09ICdub25lJyA/ICdyZ2JhKDAsMCwwLDApJyA6IHN0cm9rZVN0eWxlLnZhbHVlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKHRoaXMuc3R5bGUoJ3N0cm9rZS1vcGFjaXR5JykuaGFzVmFsdWUoKSkge1xyXG5cdFx0XHRcdFx0dmFyIHN0cm9rZVN0eWxlID0gbmV3IHN2Zy5Qcm9wZXJ0eSgnc3Ryb2tlJywgY3R4LnN0cm9rZVN0eWxlKTtcclxuXHRcdFx0XHRcdHN0cm9rZVN0eWxlID0gc3Ryb2tlU3R5bGUuYWRkT3BhY2l0eSh0aGlzLnN0eWxlKCdzdHJva2Utb3BhY2l0eScpKTtcclxuXHRcdFx0XHRcdGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZVN0eWxlLnZhbHVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAodGhpcy5zdHlsZSgnc3Ryb2tlLXdpZHRoJykuaGFzVmFsdWUoKSkge1xyXG5cdFx0XHRcdFx0dmFyIG5ld0xpbmVXaWR0aCA9IHRoaXMuc3R5bGUoJ3N0cm9rZS13aWR0aCcpLnRvUGl4ZWxzKCk7XHJcblx0XHRcdFx0XHRjdHgubGluZVdpZHRoID0gbmV3TGluZVdpZHRoID09IDAgPyAwLjAwMSA6IG5ld0xpbmVXaWR0aDsgLy8gYnJvd3NlcnMgZG9uJ3QgcmVzcGVjdCAwXHJcblx0XHRcdCAgICB9XHJcblx0XHRcdFx0aWYgKHRoaXMuc3R5bGUoJ3N0cm9rZS1saW5lY2FwJykuaGFzVmFsdWUoKSkgY3R4LmxpbmVDYXAgPSB0aGlzLnN0eWxlKCdzdHJva2UtbGluZWNhcCcpLnZhbHVlO1xyXG5cdFx0XHRcdGlmICh0aGlzLnN0eWxlKCdzdHJva2UtbGluZWpvaW4nKS5oYXNWYWx1ZSgpKSBjdHgubGluZUpvaW4gPSB0aGlzLnN0eWxlKCdzdHJva2UtbGluZWpvaW4nKS52YWx1ZTtcclxuXHRcdFx0XHRpZiAodGhpcy5zdHlsZSgnc3Ryb2tlLW1pdGVybGltaXQnKS5oYXNWYWx1ZSgpKSBjdHgubWl0ZXJMaW1pdCA9IHRoaXMuc3R5bGUoJ3N0cm9rZS1taXRlcmxpbWl0JykudmFsdWU7XHJcblx0XHRcdFx0aWYgKHRoaXMuc3R5bGUoJ3N0cm9rZS1kYXNoYXJyYXknKS5oYXNWYWx1ZSgpICYmIHRoaXMuc3R5bGUoJ3N0cm9rZS1kYXNoYXJyYXknKS52YWx1ZSAhPSAnbm9uZScpIHtcclxuXHRcdFx0XHRcdHZhciBnYXBzID0gc3ZnLlRvTnVtYmVyQXJyYXkodGhpcy5zdHlsZSgnc3Ryb2tlLWRhc2hhcnJheScpLnZhbHVlKTtcclxuXHRcdFx0XHRcdGlmICh0eXBlb2YgY3R4LnNldExpbmVEYXNoICE9ICd1bmRlZmluZWQnKSB7IGN0eC5zZXRMaW5lRGFzaChnYXBzKTsgfVxyXG5cdFx0XHRcdFx0ZWxzZSBpZiAodHlwZW9mIGN0eC53ZWJraXRMaW5lRGFzaCAhPSAndW5kZWZpbmVkJykgeyBjdHgud2Via2l0TGluZURhc2ggPSBnYXBzOyB9XHJcblx0XHRcdFx0XHRlbHNlIGlmICh0eXBlb2YgY3R4Lm1vekRhc2ggIT0gJ3VuZGVmaW5lZCcgJiYgIShnYXBzLmxlbmd0aD09MSAmJiBnYXBzWzBdPT0wKSkgeyBjdHgubW96RGFzaCA9IGdhcHM7IH1cclxuXHJcblx0XHRcdFx0XHR2YXIgb2Zmc2V0ID0gdGhpcy5zdHlsZSgnc3Ryb2tlLWRhc2hvZmZzZXQnKS5udW1WYWx1ZU9yRGVmYXVsdCgxKTtcclxuXHRcdFx0XHRcdGlmICh0eXBlb2YgY3R4LmxpbmVEYXNoT2Zmc2V0ICE9ICd1bmRlZmluZWQnKSB7IGN0eC5saW5lRGFzaE9mZnNldCA9IG9mZnNldDsgfVxyXG5cdFx0XHRcdFx0ZWxzZSBpZiAodHlwZW9mIGN0eC53ZWJraXRMaW5lRGFzaE9mZnNldCAhPSAndW5kZWZpbmVkJykgeyBjdHgud2Via2l0TGluZURhc2hPZmZzZXQgPSBvZmZzZXQ7IH1cclxuXHRcdFx0XHRcdGVsc2UgaWYgKHR5cGVvZiBjdHgubW96RGFzaE9mZnNldCAhPSAndW5kZWZpbmVkJykgeyBjdHgubW96RGFzaE9mZnNldCA9IG9mZnNldDsgfVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gZm9udFxyXG5cdFx0XHRcdGlmICh0eXBlb2YgY3R4LmZvbnQgIT0gJ3VuZGVmaW5lZCcpIHtcclxuXHRcdFx0XHRcdGN0eC5mb250ID0gc3ZnLkZvbnQuQ3JlYXRlRm9udChcclxuXHRcdFx0XHRcdFx0dGhpcy5zdHlsZSgnZm9udC1zdHlsZScpLnZhbHVlLFxyXG5cdFx0XHRcdFx0XHR0aGlzLnN0eWxlKCdmb250LXZhcmlhbnQnKS52YWx1ZSxcclxuXHRcdFx0XHRcdFx0dGhpcy5zdHlsZSgnZm9udC13ZWlnaHQnKS52YWx1ZSxcclxuXHRcdFx0XHRcdFx0dGhpcy5zdHlsZSgnZm9udC1zaXplJykuaGFzVmFsdWUoKSA/IHRoaXMuc3R5bGUoJ2ZvbnQtc2l6ZScpLnRvUGl4ZWxzKCkgKyAncHgnIDogJycsXHJcblx0XHRcdFx0XHRcdHRoaXMuc3R5bGUoJ2ZvbnQtZmFtaWx5JykudmFsdWUpLnRvU3RyaW5nKCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyB0cmFuc2Zvcm1cclxuXHRcdFx0XHRpZiAodGhpcy5zdHlsZSgndHJhbnNmb3JtJywgZmFsc2UsIHRydWUpLmhhc1ZhbHVlKCkpIHtcclxuXHRcdFx0XHRcdHZhciB0cmFuc2Zvcm0gPSBuZXcgc3ZnLlRyYW5zZm9ybSh0aGlzLnN0eWxlKCd0cmFuc2Zvcm0nLCBmYWxzZSwgdHJ1ZSkudmFsdWUpO1xyXG5cdFx0XHRcdFx0dHJhbnNmb3JtLmFwcGx5KGN0eCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBjbGlwXHJcblx0XHRcdFx0aWYgKHRoaXMuc3R5bGUoJ2NsaXAtcGF0aCcsIGZhbHNlLCB0cnVlKS5oYXNWYWx1ZSgpKSB7XHJcblx0XHRcdFx0XHR2YXIgY2xpcCA9IHRoaXMuc3R5bGUoJ2NsaXAtcGF0aCcsIGZhbHNlLCB0cnVlKS5nZXREZWZpbml0aW9uKCk7XHJcblx0XHRcdFx0XHRpZiAoY2xpcCAhPSBudWxsKSBjbGlwLmFwcGx5KGN0eCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBvcGFjaXR5XHJcblx0XHRcdFx0aWYgKHRoaXMuc3R5bGUoJ29wYWNpdHknKS5oYXNWYWx1ZSgpKSB7XHJcblx0XHRcdFx0XHRjdHguZ2xvYmFsQWxwaGEgPSB0aGlzLnN0eWxlKCdvcGFjaXR5JykubnVtVmFsdWUoKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHN2Zy5FbGVtZW50LlJlbmRlcmVkRWxlbWVudEJhc2UucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xyXG5cclxuXHRcdHN2Zy5FbGVtZW50LlBhdGhFbGVtZW50QmFzZSA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdFx0dGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuUmVuZGVyZWRFbGVtZW50QmFzZTtcclxuXHRcdFx0dGhpcy5iYXNlKG5vZGUpO1xyXG5cclxuXHRcdFx0dGhpcy5wYXRoID0gZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdFx0aWYgKGN0eCAhPSBudWxsKSBjdHguYmVnaW5QYXRoKCk7XHJcblx0XHRcdFx0cmV0dXJuIG5ldyBzdmcuQm91bmRpbmdCb3goKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5yZW5kZXJDaGlsZHJlbiA9IGZ1bmN0aW9uKGN0eCkge1xyXG5cdFx0XHRcdHRoaXMucGF0aChjdHgpO1xyXG5cdFx0XHRcdHN2Zy5Nb3VzZS5jaGVja1BhdGgodGhpcywgY3R4KTtcclxuXHRcdFx0XHRpZiAoY3R4LmZpbGxTdHlsZSAhPSAnJykge1xyXG5cdFx0XHRcdFx0aWYgKHRoaXMuc3R5bGUoJ2ZpbGwtcnVsZScpLnZhbHVlT3JEZWZhdWx0KCdpbmhlcml0JykgIT0gJ2luaGVyaXQnKSB7IGN0eC5maWxsKHRoaXMuc3R5bGUoJ2ZpbGwtcnVsZScpLnZhbHVlKTsgfVxyXG5cdFx0XHRcdFx0ZWxzZSB7IGN0eC5maWxsKCk7IH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKGN0eC5zdHJva2VTdHlsZSAhPSAnJykgY3R4LnN0cm9rZSgpO1xyXG5cclxuXHRcdFx0XHR2YXIgbWFya2VycyA9IHRoaXMuZ2V0TWFya2VycygpO1xyXG5cdFx0XHRcdGlmIChtYXJrZXJzICE9IG51bGwpIHtcclxuXHRcdFx0XHRcdGlmICh0aGlzLnN0eWxlKCdtYXJrZXItc3RhcnQnKS5pc1VybERlZmluaXRpb24oKSkge1xyXG5cdFx0XHRcdFx0XHR2YXIgbWFya2VyID0gdGhpcy5zdHlsZSgnbWFya2VyLXN0YXJ0JykuZ2V0RGVmaW5pdGlvbigpO1xyXG5cdFx0XHRcdFx0XHRtYXJrZXIucmVuZGVyKGN0eCwgbWFya2Vyc1swXVswXSwgbWFya2Vyc1swXVsxXSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZiAodGhpcy5zdHlsZSgnbWFya2VyLW1pZCcpLmlzVXJsRGVmaW5pdGlvbigpKSB7XHJcblx0XHRcdFx0XHRcdHZhciBtYXJrZXIgPSB0aGlzLnN0eWxlKCdtYXJrZXItbWlkJykuZ2V0RGVmaW5pdGlvbigpO1xyXG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpPTE7aTxtYXJrZXJzLmxlbmd0aC0xO2krKykge1xyXG5cdFx0XHRcdFx0XHRcdG1hcmtlci5yZW5kZXIoY3R4LCBtYXJrZXJzW2ldWzBdLCBtYXJrZXJzW2ldWzFdKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKHRoaXMuc3R5bGUoJ21hcmtlci1lbmQnKS5pc1VybERlZmluaXRpb24oKSkge1xyXG5cdFx0XHRcdFx0XHR2YXIgbWFya2VyID0gdGhpcy5zdHlsZSgnbWFya2VyLWVuZCcpLmdldERlZmluaXRpb24oKTtcclxuXHRcdFx0XHRcdFx0bWFya2VyLnJlbmRlcihjdHgsIG1hcmtlcnNbbWFya2Vycy5sZW5ndGgtMV1bMF0sIG1hcmtlcnNbbWFya2Vycy5sZW5ndGgtMV1bMV0pO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5nZXRCb3VuZGluZ0JveCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLnBhdGgoKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5nZXRNYXJrZXJzID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHN2Zy5FbGVtZW50LlBhdGhFbGVtZW50QmFzZS5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuUmVuZGVyZWRFbGVtZW50QmFzZTtcclxuXHJcblx0XHQvLyBzdmcgZWxlbWVudFxyXG5cdFx0c3ZnLkVsZW1lbnQuc3ZnID0gZnVuY3Rpb24obm9kZSkge1xyXG5cdFx0XHR0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5SZW5kZXJlZEVsZW1lbnRCYXNlO1xyXG5cdFx0XHR0aGlzLmJhc2Uobm9kZSk7XHJcblxyXG5cdFx0XHR0aGlzLmJhc2VDbGVhckNvbnRleHQgPSB0aGlzLmNsZWFyQ29udGV4dDtcclxuXHRcdFx0dGhpcy5jbGVhckNvbnRleHQgPSBmdW5jdGlvbihjdHgpIHtcclxuXHRcdFx0XHR0aGlzLmJhc2VDbGVhckNvbnRleHQoY3R4KTtcclxuXHRcdFx0XHRzdmcuVmlld1BvcnQuUmVtb3ZlQ3VycmVudCgpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmJhc2VTZXRDb250ZXh0ID0gdGhpcy5zZXRDb250ZXh0O1xyXG5cdFx0XHR0aGlzLnNldENvbnRleHQgPSBmdW5jdGlvbihjdHgpIHtcclxuXHRcdFx0XHQvLyBpbml0aWFsIHZhbHVlcyBhbmQgZGVmYXVsdHNcclxuXHRcdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSAncmdiYSgwLDAsMCwwKSc7XHJcblx0XHRcdFx0Y3R4LmxpbmVDYXAgPSAnYnV0dCc7XHJcblx0XHRcdFx0Y3R4LmxpbmVKb2luID0gJ21pdGVyJztcclxuXHRcdFx0XHRjdHgubWl0ZXJMaW1pdCA9IDQ7XHJcblx0XHRcdFx0aWYgKHR5cGVvZiBjdHguZm9udCAhPSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmdldENvbXB1dGVkU3R5bGUgIT0gJ3VuZGVmaW5lZCcpIHtcclxuXHRcdFx0XHRcdGN0eC5mb250ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoY3R4LmNhbnZhcykuZ2V0UHJvcGVydHlWYWx1ZSgnZm9udCcpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5iYXNlU2V0Q29udGV4dChjdHgpO1xyXG5cclxuXHRcdFx0XHQvLyBjcmVhdGUgbmV3IHZpZXcgcG9ydFxyXG5cdFx0XHRcdGlmICghdGhpcy5hdHRyaWJ1dGUoJ3gnKS5oYXNWYWx1ZSgpKSB0aGlzLmF0dHJpYnV0ZSgneCcsIHRydWUpLnZhbHVlID0gMDtcclxuXHRcdFx0XHRpZiAoIXRoaXMuYXR0cmlidXRlKCd5JykuaGFzVmFsdWUoKSkgdGhpcy5hdHRyaWJ1dGUoJ3knLCB0cnVlKS52YWx1ZSA9IDA7XHJcblx0XHRcdFx0Y3R4LnRyYW5zbGF0ZSh0aGlzLmF0dHJpYnV0ZSgneCcpLnRvUGl4ZWxzKCd4JyksIHRoaXMuYXR0cmlidXRlKCd5JykudG9QaXhlbHMoJ3knKSk7XHJcblxyXG5cdFx0XHRcdHZhciB3aWR0aCA9IHN2Zy5WaWV3UG9ydC53aWR0aCgpO1xyXG5cdFx0XHRcdHZhciBoZWlnaHQgPSBzdmcuVmlld1BvcnQuaGVpZ2h0KCk7XHJcblxyXG5cdFx0XHRcdGlmICghdGhpcy5hdHRyaWJ1dGUoJ3dpZHRoJykuaGFzVmFsdWUoKSkgdGhpcy5hdHRyaWJ1dGUoJ3dpZHRoJywgdHJ1ZSkudmFsdWUgPSAnMTAwJSc7XHJcblx0XHRcdFx0aWYgKCF0aGlzLmF0dHJpYnV0ZSgnaGVpZ2h0JykuaGFzVmFsdWUoKSkgdGhpcy5hdHRyaWJ1dGUoJ2hlaWdodCcsIHRydWUpLnZhbHVlID0gJzEwMCUnO1xyXG5cdFx0XHRcdGlmICh0eXBlb2YgdGhpcy5yb290ID09ICd1bmRlZmluZWQnKSB7XHJcblx0XHRcdFx0XHR3aWR0aCA9IHRoaXMuYXR0cmlidXRlKCd3aWR0aCcpLnRvUGl4ZWxzKCd4Jyk7XHJcblx0XHRcdFx0XHRoZWlnaHQgPSB0aGlzLmF0dHJpYnV0ZSgnaGVpZ2h0JykudG9QaXhlbHMoJ3knKTtcclxuXHJcblx0XHRcdFx0XHR2YXIgeCA9IDA7XHJcblx0XHRcdFx0XHR2YXIgeSA9IDA7XHJcblx0XHRcdFx0XHRpZiAodGhpcy5hdHRyaWJ1dGUoJ3JlZlgnKS5oYXNWYWx1ZSgpICYmIHRoaXMuYXR0cmlidXRlKCdyZWZZJykuaGFzVmFsdWUoKSkge1xyXG5cdFx0XHRcdFx0XHR4ID0gLXRoaXMuYXR0cmlidXRlKCdyZWZYJykudG9QaXhlbHMoJ3gnKTtcclxuXHRcdFx0XHRcdFx0eSA9IC10aGlzLmF0dHJpYnV0ZSgncmVmWScpLnRvUGl4ZWxzKCd5Jyk7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKHRoaXMuYXR0cmlidXRlKCdvdmVyZmxvdycpLnZhbHVlT3JEZWZhdWx0KCdoaWRkZW4nKSAhPSAndmlzaWJsZScpIHtcclxuXHRcdFx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xyXG5cdFx0XHRcdFx0XHRjdHgubW92ZVRvKHgsIHkpO1xyXG5cdFx0XHRcdFx0XHRjdHgubGluZVRvKHdpZHRoLCB5KTtcclxuXHRcdFx0XHRcdFx0Y3R4LmxpbmVUbyh3aWR0aCwgaGVpZ2h0KTtcclxuXHRcdFx0XHRcdFx0Y3R4LmxpbmVUbyh4LCBoZWlnaHQpO1xyXG5cdFx0XHRcdFx0XHRjdHguY2xvc2VQYXRoKCk7XHJcblx0XHRcdFx0XHRcdGN0eC5jbGlwKCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHN2Zy5WaWV3UG9ydC5TZXRDdXJyZW50KHdpZHRoLCBoZWlnaHQpO1xyXG5cclxuXHRcdFx0XHQvLyB2aWV3Ym94XHJcblx0XHRcdFx0aWYgKHRoaXMuYXR0cmlidXRlKCd2aWV3Qm94JykuaGFzVmFsdWUoKSkge1xyXG5cdFx0XHRcdFx0dmFyIHZpZXdCb3ggPSBzdmcuVG9OdW1iZXJBcnJheSh0aGlzLmF0dHJpYnV0ZSgndmlld0JveCcpLnZhbHVlKTtcclxuXHRcdFx0XHRcdHZhciBtaW5YID0gdmlld0JveFswXTtcclxuXHRcdFx0XHRcdHZhciBtaW5ZID0gdmlld0JveFsxXTtcclxuXHRcdFx0XHRcdHdpZHRoID0gdmlld0JveFsyXTtcclxuXHRcdFx0XHRcdGhlaWdodCA9IHZpZXdCb3hbM107XHJcblxyXG5cdFx0XHRcdFx0c3ZnLkFzcGVjdFJhdGlvKGN0eCxcclxuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5hdHRyaWJ1dGUoJ3ByZXNlcnZlQXNwZWN0UmF0aW8nKS52YWx1ZSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0c3ZnLlZpZXdQb3J0LndpZHRoKCksXHJcblx0XHRcdFx0XHRcdFx0XHRcdHdpZHRoLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRzdmcuVmlld1BvcnQuaGVpZ2h0KCksXHJcblx0XHRcdFx0XHRcdFx0XHRcdGhlaWdodCxcclxuXHRcdFx0XHRcdFx0XHRcdFx0bWluWCxcclxuXHRcdFx0XHRcdFx0XHRcdFx0bWluWSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5hdHRyaWJ1dGUoJ3JlZlgnKS52YWx1ZSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5hdHRyaWJ1dGUoJ3JlZlknKS52YWx1ZSk7XHJcblxyXG5cdFx0XHRcdFx0c3ZnLlZpZXdQb3J0LlJlbW92ZUN1cnJlbnQoKTtcclxuXHRcdFx0XHRcdHN2Zy5WaWV3UG9ydC5TZXRDdXJyZW50KHZpZXdCb3hbMl0sIHZpZXdCb3hbM10pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0c3ZnLkVsZW1lbnQuc3ZnLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5SZW5kZXJlZEVsZW1lbnRCYXNlO1xyXG5cclxuXHRcdC8vIHJlY3QgZWxlbWVudFxyXG5cdFx0c3ZnLkVsZW1lbnQucmVjdCA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdFx0dGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuUGF0aEVsZW1lbnRCYXNlO1xyXG5cdFx0XHR0aGlzLmJhc2Uobm9kZSk7XHJcblxyXG5cdFx0XHR0aGlzLnBhdGggPSBmdW5jdGlvbihjdHgpIHtcclxuXHRcdFx0XHR2YXIgeCA9IHRoaXMuYXR0cmlidXRlKCd4JykudG9QaXhlbHMoJ3gnKTtcclxuXHRcdFx0XHR2YXIgeSA9IHRoaXMuYXR0cmlidXRlKCd5JykudG9QaXhlbHMoJ3knKTtcclxuXHRcdFx0XHR2YXIgd2lkdGggPSB0aGlzLmF0dHJpYnV0ZSgnd2lkdGgnKS50b1BpeGVscygneCcpO1xyXG5cdFx0XHRcdHZhciBoZWlnaHQgPSB0aGlzLmF0dHJpYnV0ZSgnaGVpZ2h0JykudG9QaXhlbHMoJ3knKTtcclxuXHRcdFx0XHR2YXIgcnggPSB0aGlzLmF0dHJpYnV0ZSgncngnKS50b1BpeGVscygneCcpO1xyXG5cdFx0XHRcdHZhciByeSA9IHRoaXMuYXR0cmlidXRlKCdyeScpLnRvUGl4ZWxzKCd5Jyk7XHJcblx0XHRcdFx0aWYgKHRoaXMuYXR0cmlidXRlKCdyeCcpLmhhc1ZhbHVlKCkgJiYgIXRoaXMuYXR0cmlidXRlKCdyeScpLmhhc1ZhbHVlKCkpIHJ5ID0gcng7XHJcblx0XHRcdFx0aWYgKHRoaXMuYXR0cmlidXRlKCdyeScpLmhhc1ZhbHVlKCkgJiYgIXRoaXMuYXR0cmlidXRlKCdyeCcpLmhhc1ZhbHVlKCkpIHJ4ID0gcnk7XHJcblx0XHRcdFx0cnggPSBNYXRoLm1pbihyeCwgd2lkdGggLyAyLjApO1xyXG5cdFx0XHRcdHJ5ID0gTWF0aC5taW4ocnksIGhlaWdodCAvIDIuMCk7XHJcblx0XHRcdFx0aWYgKGN0eCAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XHJcblx0XHRcdFx0XHRjdHgubW92ZVRvKHggKyByeCwgeSk7XHJcblx0XHRcdFx0XHRjdHgubGluZVRvKHggKyB3aWR0aCAtIHJ4LCB5KTtcclxuXHRcdFx0XHRcdGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSwgeCArIHdpZHRoLCB5ICsgcnkpXHJcblx0XHRcdFx0XHRjdHgubGluZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCAtIHJ5KTtcclxuXHRcdFx0XHRcdGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCwgeCArIHdpZHRoIC0gcngsIHkgKyBoZWlnaHQpXHJcblx0XHRcdFx0XHRjdHgubGluZVRvKHggKyByeCwgeSArIGhlaWdodCk7XHJcblx0XHRcdFx0XHRjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5ICsgaGVpZ2h0LCB4LCB5ICsgaGVpZ2h0IC0gcnkpXHJcblx0XHRcdFx0XHRjdHgubGluZVRvKHgsIHkgKyByeSk7XHJcblx0XHRcdFx0XHRjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5LCB4ICsgcngsIHkpXHJcblx0XHRcdFx0XHRjdHguY2xvc2VQYXRoKCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gbmV3IHN2Zy5Cb3VuZGluZ0JveCh4LCB5LCB4ICsgd2lkdGgsIHkgKyBoZWlnaHQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRzdmcuRWxlbWVudC5yZWN0LnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5QYXRoRWxlbWVudEJhc2U7XHJcblxyXG5cdFx0Ly8gY2lyY2xlIGVsZW1lbnRcclxuXHRcdHN2Zy5FbGVtZW50LmNpcmNsZSA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdFx0dGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuUGF0aEVsZW1lbnRCYXNlO1xyXG5cdFx0XHR0aGlzLmJhc2Uobm9kZSk7XHJcblxyXG5cdFx0XHR0aGlzLnBhdGggPSBmdW5jdGlvbihjdHgpIHtcclxuXHRcdFx0XHR2YXIgY3ggPSB0aGlzLmF0dHJpYnV0ZSgnY3gnKS50b1BpeGVscygneCcpO1xyXG5cdFx0XHRcdHZhciBjeSA9IHRoaXMuYXR0cmlidXRlKCdjeScpLnRvUGl4ZWxzKCd5Jyk7XHJcblx0XHRcdFx0dmFyIHIgPSB0aGlzLmF0dHJpYnV0ZSgncicpLnRvUGl4ZWxzKCk7XHJcblxyXG5cdFx0XHRcdGlmIChjdHggIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xyXG5cdFx0XHRcdFx0Y3R4LmFyYyhjeCwgY3ksIHIsIDAsIE1hdGguUEkgKiAyLCB0cnVlKTtcclxuXHRcdFx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVybiBuZXcgc3ZnLkJvdW5kaW5nQm94KGN4IC0gciwgY3kgLSByLCBjeCArIHIsIGN5ICsgcik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHN2Zy5FbGVtZW50LmNpcmNsZS5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuUGF0aEVsZW1lbnRCYXNlO1xyXG5cclxuXHRcdC8vIGVsbGlwc2UgZWxlbWVudFxyXG5cdFx0c3ZnLkVsZW1lbnQuZWxsaXBzZSA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdFx0dGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuUGF0aEVsZW1lbnRCYXNlO1xyXG5cdFx0XHR0aGlzLmJhc2Uobm9kZSk7XHJcblxyXG5cdFx0XHR0aGlzLnBhdGggPSBmdW5jdGlvbihjdHgpIHtcclxuXHRcdFx0XHR2YXIgS0FQUEEgPSA0ICogKChNYXRoLnNxcnQoMikgLSAxKSAvIDMpO1xyXG5cdFx0XHRcdHZhciByeCA9IHRoaXMuYXR0cmlidXRlKCdyeCcpLnRvUGl4ZWxzKCd4Jyk7XHJcblx0XHRcdFx0dmFyIHJ5ID0gdGhpcy5hdHRyaWJ1dGUoJ3J5JykudG9QaXhlbHMoJ3knKTtcclxuXHRcdFx0XHR2YXIgY3ggPSB0aGlzLmF0dHJpYnV0ZSgnY3gnKS50b1BpeGVscygneCcpO1xyXG5cdFx0XHRcdHZhciBjeSA9IHRoaXMuYXR0cmlidXRlKCdjeScpLnRvUGl4ZWxzKCd5Jyk7XHJcblxyXG5cdFx0XHRcdGlmIChjdHggIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xyXG5cdFx0XHRcdFx0Y3R4Lm1vdmVUbyhjeCwgY3kgLSByeSk7XHJcblx0XHRcdFx0XHRjdHguYmV6aWVyQ3VydmVUbyhjeCArIChLQVBQQSAqIHJ4KSwgY3kgLSByeSwgIGN4ICsgcngsIGN5IC0gKEtBUFBBICogcnkpLCBjeCArIHJ4LCBjeSk7XHJcblx0XHRcdFx0XHRjdHguYmV6aWVyQ3VydmVUbyhjeCArIHJ4LCBjeSArIChLQVBQQSAqIHJ5KSwgY3ggKyAoS0FQUEEgKiByeCksIGN5ICsgcnksIGN4LCBjeSArIHJ5KTtcclxuXHRcdFx0XHRcdGN0eC5iZXppZXJDdXJ2ZVRvKGN4IC0gKEtBUFBBICogcngpLCBjeSArIHJ5LCBjeCAtIHJ4LCBjeSArIChLQVBQQSAqIHJ5KSwgY3ggLSByeCwgY3kpO1xyXG5cdFx0XHRcdFx0Y3R4LmJlemllckN1cnZlVG8oY3ggLSByeCwgY3kgLSAoS0FQUEEgKiByeSksIGN4IC0gKEtBUFBBICogcngpLCBjeSAtIHJ5LCBjeCwgY3kgLSByeSk7XHJcblx0XHRcdFx0XHRjdHguY2xvc2VQYXRoKCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gbmV3IHN2Zy5Cb3VuZGluZ0JveChjeCAtIHJ4LCBjeSAtIHJ5LCBjeCArIHJ4LCBjeSArIHJ5KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0c3ZnLkVsZW1lbnQuZWxsaXBzZS5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuUGF0aEVsZW1lbnRCYXNlO1xyXG5cclxuXHRcdC8vIGxpbmUgZWxlbWVudFxyXG5cdFx0c3ZnLkVsZW1lbnQubGluZSA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdFx0dGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuUGF0aEVsZW1lbnRCYXNlO1xyXG5cdFx0XHR0aGlzLmJhc2Uobm9kZSk7XHJcblxyXG5cdFx0XHR0aGlzLmdldFBvaW50cyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBbXHJcblx0XHRcdFx0XHRuZXcgc3ZnLlBvaW50KHRoaXMuYXR0cmlidXRlKCd4MScpLnRvUGl4ZWxzKCd4JyksIHRoaXMuYXR0cmlidXRlKCd5MScpLnRvUGl4ZWxzKCd5JykpLFxyXG5cdFx0XHRcdFx0bmV3IHN2Zy5Qb2ludCh0aGlzLmF0dHJpYnV0ZSgneDInKS50b1BpeGVscygneCcpLCB0aGlzLmF0dHJpYnV0ZSgneTInKS50b1BpeGVscygneScpKV07XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMucGF0aCA9IGZ1bmN0aW9uKGN0eCkge1xyXG5cdFx0XHRcdHZhciBwb2ludHMgPSB0aGlzLmdldFBvaW50cygpO1xyXG5cclxuXHRcdFx0XHRpZiAoY3R4ICE9IG51bGwpIHtcclxuXHRcdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcclxuXHRcdFx0XHRcdGN0eC5tb3ZlVG8ocG9pbnRzWzBdLngsIHBvaW50c1swXS55KTtcclxuXHRcdFx0XHRcdGN0eC5saW5lVG8ocG9pbnRzWzFdLngsIHBvaW50c1sxXS55KTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVybiBuZXcgc3ZnLkJvdW5kaW5nQm94KHBvaW50c1swXS54LCBwb2ludHNbMF0ueSwgcG9pbnRzWzFdLngsIHBvaW50c1sxXS55KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5nZXRNYXJrZXJzID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0dmFyIHBvaW50cyA9IHRoaXMuZ2V0UG9pbnRzKCk7XHJcblx0XHRcdFx0dmFyIGEgPSBwb2ludHNbMF0uYW5nbGVUbyhwb2ludHNbMV0pO1xyXG5cdFx0XHRcdHJldHVybiBbW3BvaW50c1swXSwgYV0sIFtwb2ludHNbMV0sIGFdXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0c3ZnLkVsZW1lbnQubGluZS5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuUGF0aEVsZW1lbnRCYXNlO1xyXG5cclxuXHRcdC8vIHBvbHlsaW5lIGVsZW1lbnRcclxuXHRcdHN2Zy5FbGVtZW50LnBvbHlsaW5lID0gZnVuY3Rpb24obm9kZSkge1xyXG5cdFx0XHR0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5QYXRoRWxlbWVudEJhc2U7XHJcblx0XHRcdHRoaXMuYmFzZShub2RlKTtcclxuXHJcblx0XHRcdHRoaXMucG9pbnRzID0gc3ZnLkNyZWF0ZVBhdGgodGhpcy5hdHRyaWJ1dGUoJ3BvaW50cycpLnZhbHVlKTtcclxuXHRcdFx0dGhpcy5wYXRoID0gZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdFx0dmFyIGJiID0gbmV3IHN2Zy5Cb3VuZGluZ0JveCh0aGlzLnBvaW50c1swXS54LCB0aGlzLnBvaW50c1swXS55KTtcclxuXHRcdFx0XHRpZiAoY3R4ICE9IG51bGwpIHtcclxuXHRcdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcclxuXHRcdFx0XHRcdGN0eC5tb3ZlVG8odGhpcy5wb2ludHNbMF0ueCwgdGhpcy5wb2ludHNbMF0ueSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGZvciAodmFyIGk9MTsgaTx0aGlzLnBvaW50cy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0YmIuYWRkUG9pbnQodGhpcy5wb2ludHNbaV0ueCwgdGhpcy5wb2ludHNbaV0ueSk7XHJcblx0XHRcdFx0XHRpZiAoY3R4ICE9IG51bGwpIGN0eC5saW5lVG8odGhpcy5wb2ludHNbaV0ueCwgdGhpcy5wb2ludHNbaV0ueSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiBiYjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5nZXRNYXJrZXJzID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0dmFyIG1hcmtlcnMgPSBbXTtcclxuXHRcdFx0XHRmb3IgKHZhciBpPTA7IGk8dGhpcy5wb2ludHMubGVuZ3RoIC0gMTsgaSsrKSB7XHJcblx0XHRcdFx0XHRtYXJrZXJzLnB1c2goW3RoaXMucG9pbnRzW2ldLCB0aGlzLnBvaW50c1tpXS5hbmdsZVRvKHRoaXMucG9pbnRzW2krMV0pXSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmIChtYXJrZXJzLmxlbmd0aCA+IDApIHtcclxuXHRcdFx0XHRcdG1hcmtlcnMucHVzaChbdGhpcy5wb2ludHNbdGhpcy5wb2ludHMubGVuZ3RoLTFdLCBtYXJrZXJzW21hcmtlcnMubGVuZ3RoLTFdWzFdXSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiBtYXJrZXJzO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRzdmcuRWxlbWVudC5wb2x5bGluZS5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuUGF0aEVsZW1lbnRCYXNlO1xyXG5cclxuXHRcdC8vIHBvbHlnb24gZWxlbWVudFxyXG5cdFx0c3ZnLkVsZW1lbnQucG9seWdvbiA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdFx0dGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQucG9seWxpbmU7XHJcblx0XHRcdHRoaXMuYmFzZShub2RlKTtcclxuXHJcblx0XHRcdHRoaXMuYmFzZVBhdGggPSB0aGlzLnBhdGg7XHJcblx0XHRcdHRoaXMucGF0aCA9IGZ1bmN0aW9uKGN0eCkge1xyXG5cdFx0XHRcdHZhciBiYiA9IHRoaXMuYmFzZVBhdGgoY3R4KTtcclxuXHRcdFx0XHRpZiAoY3R4ICE9IG51bGwpIHtcclxuXHRcdFx0XHRcdGN0eC5saW5lVG8odGhpcy5wb2ludHNbMF0ueCwgdGhpcy5wb2ludHNbMF0ueSk7XHJcblx0XHRcdFx0XHRjdHguY2xvc2VQYXRoKCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiBiYjtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0c3ZnLkVsZW1lbnQucG9seWdvbi5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQucG9seWxpbmU7XHJcblxyXG5cdFx0Ly8gcGF0aCBlbGVtZW50XHJcblx0XHRzdmcuRWxlbWVudC5wYXRoID0gZnVuY3Rpb24obm9kZSkge1xyXG5cdFx0XHR0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5QYXRoRWxlbWVudEJhc2U7XHJcblx0XHRcdHRoaXMuYmFzZShub2RlKTtcclxuXHJcblx0XHRcdHZhciBkID0gdGhpcy5hdHRyaWJ1dGUoJ2QnKS52YWx1ZTtcclxuXHRcdFx0Ly8gVE9ETzogY29udmVydCB0byByZWFsIGxleGVyIGJhc2VkIG9uIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRzExL3BhdGhzLmh0bWwjUGF0aERhdGFCTkZcclxuXHRcdFx0ZCA9IGQucmVwbGFjZSgvLC9nbSwnICcpOyAvLyBnZXQgcmlkIG9mIGFsbCBjb21tYXNcclxuXHRcdFx0Ly8gQXMgdGhlIGVuZCBvZiBhIG1hdGNoIGNhbiBhbHNvIGJlIHRoZSBzdGFydCBvZiB0aGUgbmV4dCBtYXRjaCwgd2UgbmVlZCB0byBydW4gdGhpcyByZXBsYWNlIHR3aWNlLlxyXG5cdFx0XHRmb3IodmFyIGk9MDsgaTwyOyBpKyspXHJcblx0XHRcdFx0ZCA9IGQucmVwbGFjZSgvKFtNbVp6TGxIaFZ2Q2NTc1FxVHRBYV0pKFteXFxzXSkvZ20sJyQxICQyJyk7IC8vIHN1ZmZpeCBjb21tYW5kcyB3aXRoIHNwYWNlc1xyXG5cdFx0XHRkID0gZC5yZXBsYWNlKC8oW15cXHNdKShbTW1aekxsSGhWdkNjU3NRcVR0QWFdKS9nbSwnJDEgJDInKTsgLy8gcHJlZml4IGNvbW1hbmRzIHdpdGggc3BhY2VzXHJcblx0XHRcdGQgPSBkLnJlcGxhY2UoLyhbMC05XSkoWytcXC1dKS9nbSwnJDEgJDInKTsgLy8gc2VwYXJhdGUgZGlnaXRzIG9uICstIHNpZ25zXHJcblx0XHRcdC8vIEFnYWluLCB3ZSBuZWVkIHRvIHJ1biB0aGlzIHR3aWNlIHRvIGZpbmQgYWxsIG9jY3VyYW5jZXNcclxuXHRcdFx0Zm9yKHZhciBpPTA7IGk8MjsgaSsrKVxyXG5cdFx0XHRcdGQgPSBkLnJlcGxhY2UoLyhcXC5bMC05XSopKFxcLikvZ20sJyQxICQyJyk7IC8vIHNlcGFyYXRlIGRpZ2l0cyB3aGVuIHRoZXkgc3RhcnQgd2l0aCBhIGNvbW1hXHJcblx0XHRcdGQgPSBkLnJlcGxhY2UoLyhbQWFdKFxccytbMC05XSspezN9KVxccysoWzAxXSlcXHMqKFswMV0pL2dtLCckMSAkMyAkNCAnKTsgLy8gc2hvcnRoYW5kIGVsbGlwdGljYWwgYXJjIHBhdGggc3ludGF4XHJcblx0XHRcdGQgPSBzdmcuY29tcHJlc3NTcGFjZXMoZCk7IC8vIGNvbXByZXNzIG11bHRpcGxlIHNwYWNlc1xyXG5cdFx0XHRkID0gc3ZnLnRyaW0oZCk7XHJcblx0XHRcdHRoaXMuUGF0aFBhcnNlciA9IG5ldyAoZnVuY3Rpb24oZCkge1xyXG5cdFx0XHRcdHRoaXMudG9rZW5zID0gZC5zcGxpdCgnICcpO1xyXG5cclxuXHRcdFx0XHR0aGlzLnJlc2V0ID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHR0aGlzLmkgPSAtMTtcclxuXHRcdFx0XHRcdHRoaXMuY29tbWFuZCA9ICcnO1xyXG5cdFx0XHRcdFx0dGhpcy5wcmV2aW91c0NvbW1hbmQgPSAnJztcclxuXHRcdFx0XHRcdHRoaXMuc3RhcnQgPSBuZXcgc3ZnLlBvaW50KDAsIDApO1xyXG5cdFx0XHRcdFx0dGhpcy5jb250cm9sID0gbmV3IHN2Zy5Qb2ludCgwLCAwKTtcclxuXHRcdFx0XHRcdHRoaXMuY3VycmVudCA9IG5ldyBzdmcuUG9pbnQoMCwgMCk7XHJcblx0XHRcdFx0XHR0aGlzLnBvaW50cyA9IFtdO1xyXG5cdFx0XHRcdFx0dGhpcy5hbmdsZXMgPSBbXTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRoaXMuaXNFbmQgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdHJldHVybiB0aGlzLmkgPj0gdGhpcy50b2tlbnMubGVuZ3RoIC0gMTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRoaXMuaXNDb21tYW5kT3JFbmQgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdGlmICh0aGlzLmlzRW5kKCkpIHJldHVybiB0cnVlO1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMudG9rZW5zW3RoaXMuaSArIDFdLm1hdGNoKC9eW0EtWmEtel0kLykgIT0gbnVsbDtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRoaXMuaXNSZWxhdGl2ZUNvbW1hbmQgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdHN3aXRjaCh0aGlzLmNvbW1hbmQpXHJcblx0XHRcdFx0XHR7XHJcblx0XHRcdFx0XHRcdGNhc2UgJ20nOlxyXG5cdFx0XHRcdFx0XHRjYXNlICdsJzpcclxuXHRcdFx0XHRcdFx0Y2FzZSAnaCc6XHJcblx0XHRcdFx0XHRcdGNhc2UgJ3YnOlxyXG5cdFx0XHRcdFx0XHRjYXNlICdjJzpcclxuXHRcdFx0XHRcdFx0Y2FzZSAncyc6XHJcblx0XHRcdFx0XHRcdGNhc2UgJ3EnOlxyXG5cdFx0XHRcdFx0XHRjYXNlICd0JzpcclxuXHRcdFx0XHRcdFx0Y2FzZSAnYSc6XHJcblx0XHRcdFx0XHRcdGNhc2UgJ3onOlxyXG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5nZXRUb2tlbiA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0dGhpcy5pKys7XHJcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy50b2tlbnNbdGhpcy5pXTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRoaXMuZ2V0U2NhbGFyID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gcGFyc2VGbG9hdCh0aGlzLmdldFRva2VuKCkpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5uZXh0Q29tbWFuZCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0dGhpcy5wcmV2aW91c0NvbW1hbmQgPSB0aGlzLmNvbW1hbmQ7XHJcblx0XHRcdFx0XHR0aGlzLmNvbW1hbmQgPSB0aGlzLmdldFRva2VuKCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0aGlzLmdldFBvaW50ID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHR2YXIgcCA9IG5ldyBzdmcuUG9pbnQodGhpcy5nZXRTY2FsYXIoKSwgdGhpcy5nZXRTY2FsYXIoKSk7XHJcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5tYWtlQWJzb2x1dGUocCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0aGlzLmdldEFzQ29udHJvbFBvaW50ID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHR2YXIgcCA9IHRoaXMuZ2V0UG9pbnQoKTtcclxuXHRcdFx0XHRcdHRoaXMuY29udHJvbCA9IHA7XHJcblx0XHRcdFx0XHRyZXR1cm4gcDtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRoaXMuZ2V0QXNDdXJyZW50UG9pbnQgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdHZhciBwID0gdGhpcy5nZXRQb2ludCgpO1xyXG5cdFx0XHRcdFx0dGhpcy5jdXJyZW50ID0gcDtcclxuXHRcdFx0XHRcdHJldHVybiBwO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5nZXRSZWZsZWN0ZWRDb250cm9sUG9pbnQgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdGlmICh0aGlzLnByZXZpb3VzQ29tbWFuZC50b0xvd2VyQ2FzZSgpICE9ICdjJyAmJlxyXG5cdFx0XHRcdFx0ICAgIHRoaXMucHJldmlvdXNDb21tYW5kLnRvTG93ZXJDYXNlKCkgIT0gJ3MnICYmXHJcblx0XHRcdFx0XHRcdHRoaXMucHJldmlvdXNDb21tYW5kLnRvTG93ZXJDYXNlKCkgIT0gJ3EnICYmXHJcblx0XHRcdFx0XHRcdHRoaXMucHJldmlvdXNDb21tYW5kLnRvTG93ZXJDYXNlKCkgIT0gJ3QnICl7XHJcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLmN1cnJlbnQ7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Ly8gcmVmbGVjdCBwb2ludFxyXG5cdFx0XHRcdFx0dmFyIHAgPSBuZXcgc3ZnLlBvaW50KDIgKiB0aGlzLmN1cnJlbnQueCAtIHRoaXMuY29udHJvbC54LCAyICogdGhpcy5jdXJyZW50LnkgLSB0aGlzLmNvbnRyb2wueSk7XHJcblx0XHRcdFx0XHRyZXR1cm4gcDtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRoaXMubWFrZUFic29sdXRlID0gZnVuY3Rpb24ocCkge1xyXG5cdFx0XHRcdFx0aWYgKHRoaXMuaXNSZWxhdGl2ZUNvbW1hbmQoKSkge1xyXG5cdFx0XHRcdFx0XHRwLnggKz0gdGhpcy5jdXJyZW50Lng7XHJcblx0XHRcdFx0XHRcdHAueSArPSB0aGlzLmN1cnJlbnQueTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHJldHVybiBwO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5hZGRNYXJrZXIgPSBmdW5jdGlvbihwLCBmcm9tLCBwcmlvclRvKSB7XHJcblx0XHRcdFx0XHQvLyBpZiB0aGUgbGFzdCBhbmdsZSBpc24ndCBmaWxsZWQgaW4gYmVjYXVzZSB3ZSBkaWRuJ3QgaGF2ZSB0aGlzIHBvaW50IHlldCAuLi5cclxuXHRcdFx0XHRcdGlmIChwcmlvclRvICE9IG51bGwgJiYgdGhpcy5hbmdsZXMubGVuZ3RoID4gMCAmJiB0aGlzLmFuZ2xlc1t0aGlzLmFuZ2xlcy5sZW5ndGgtMV0gPT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHR0aGlzLmFuZ2xlc1t0aGlzLmFuZ2xlcy5sZW5ndGgtMV0gPSB0aGlzLnBvaW50c1t0aGlzLnBvaW50cy5sZW5ndGgtMV0uYW5nbGVUbyhwcmlvclRvKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHRoaXMuYWRkTWFya2VyQW5nbGUocCwgZnJvbSA9PSBudWxsID8gbnVsbCA6IGZyb20uYW5nbGVUbyhwKSk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0aGlzLmFkZE1hcmtlckFuZ2xlID0gZnVuY3Rpb24ocCwgYSkge1xyXG5cdFx0XHRcdFx0dGhpcy5wb2ludHMucHVzaChwKTtcclxuXHRcdFx0XHRcdHRoaXMuYW5nbGVzLnB1c2goYSk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0aGlzLmdldE1hcmtlclBvaW50cyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5wb2ludHM7IH1cclxuXHRcdFx0XHR0aGlzLmdldE1hcmtlckFuZ2xlcyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0Zm9yICh2YXIgaT0wOyBpPHRoaXMuYW5nbGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHRcdGlmICh0aGlzLmFuZ2xlc1tpXSA9PSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgaj1pKzE7IGo8dGhpcy5hbmdsZXMubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHRcdFx0XHRcdGlmICh0aGlzLmFuZ2xlc1tqXSAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuYW5nbGVzW2ldID0gdGhpcy5hbmdsZXNbal07XHJcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuYW5nbGVzO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSkoZCk7XHJcblxyXG5cdFx0XHR0aGlzLnBhdGggPSBmdW5jdGlvbihjdHgpIHtcclxuXHRcdFx0XHR2YXIgcHAgPSB0aGlzLlBhdGhQYXJzZXI7XHJcblx0XHRcdFx0cHAucmVzZXQoKTtcclxuXHJcblx0XHRcdFx0dmFyIGJiID0gbmV3IHN2Zy5Cb3VuZGluZ0JveCgpO1xyXG5cdFx0XHRcdGlmIChjdHggIT0gbnVsbCkgY3R4LmJlZ2luUGF0aCgpO1xyXG5cdFx0XHRcdHdoaWxlICghcHAuaXNFbmQoKSkge1xyXG5cdFx0XHRcdFx0cHAubmV4dENvbW1hbmQoKTtcclxuXHRcdFx0XHRcdHN3aXRjaCAocHAuY29tbWFuZCkge1xyXG5cdFx0XHRcdFx0Y2FzZSAnTSc6XHJcblx0XHRcdFx0XHRjYXNlICdtJzpcclxuXHRcdFx0XHRcdFx0dmFyIHAgPSBwcC5nZXRBc0N1cnJlbnRQb2ludCgpO1xyXG5cdFx0XHRcdFx0XHRwcC5hZGRNYXJrZXIocCk7XHJcblx0XHRcdFx0XHRcdGJiLmFkZFBvaW50KHAueCwgcC55KTtcclxuXHRcdFx0XHRcdFx0aWYgKGN0eCAhPSBudWxsKSBjdHgubW92ZVRvKHAueCwgcC55KTtcclxuXHRcdFx0XHRcdFx0cHAuc3RhcnQgPSBwcC5jdXJyZW50O1xyXG5cdFx0XHRcdFx0XHR3aGlsZSAoIXBwLmlzQ29tbWFuZE9yRW5kKCkpIHtcclxuXHRcdFx0XHRcdFx0XHR2YXIgcCA9IHBwLmdldEFzQ3VycmVudFBvaW50KCk7XHJcblx0XHRcdFx0XHRcdFx0cHAuYWRkTWFya2VyKHAsIHBwLnN0YXJ0KTtcclxuXHRcdFx0XHRcdFx0XHRiYi5hZGRQb2ludChwLngsIHAueSk7XHJcblx0XHRcdFx0XHRcdFx0aWYgKGN0eCAhPSBudWxsKSBjdHgubGluZVRvKHAueCwgcC55KTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdGNhc2UgJ0wnOlxyXG5cdFx0XHRcdFx0Y2FzZSAnbCc6XHJcblx0XHRcdFx0XHRcdHdoaWxlICghcHAuaXNDb21tYW5kT3JFbmQoKSkge1xyXG5cdFx0XHRcdFx0XHRcdHZhciBjID0gcHAuY3VycmVudDtcclxuXHRcdFx0XHRcdFx0XHR2YXIgcCA9IHBwLmdldEFzQ3VycmVudFBvaW50KCk7XHJcblx0XHRcdFx0XHRcdFx0cHAuYWRkTWFya2VyKHAsIGMpO1xyXG5cdFx0XHRcdFx0XHRcdGJiLmFkZFBvaW50KHAueCwgcC55KTtcclxuXHRcdFx0XHRcdFx0XHRpZiAoY3R4ICE9IG51bGwpIGN0eC5saW5lVG8ocC54LCBwLnkpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSAnSCc6XHJcblx0XHRcdFx0XHRjYXNlICdoJzpcclxuXHRcdFx0XHRcdFx0d2hpbGUgKCFwcC5pc0NvbW1hbmRPckVuZCgpKSB7XHJcblx0XHRcdFx0XHRcdFx0dmFyIG5ld1AgPSBuZXcgc3ZnLlBvaW50KChwcC5pc1JlbGF0aXZlQ29tbWFuZCgpID8gcHAuY3VycmVudC54IDogMCkgKyBwcC5nZXRTY2FsYXIoKSwgcHAuY3VycmVudC55KTtcclxuXHRcdFx0XHRcdFx0XHRwcC5hZGRNYXJrZXIobmV3UCwgcHAuY3VycmVudCk7XHJcblx0XHRcdFx0XHRcdFx0cHAuY3VycmVudCA9IG5ld1A7XHJcblx0XHRcdFx0XHRcdFx0YmIuYWRkUG9pbnQocHAuY3VycmVudC54LCBwcC5jdXJyZW50LnkpO1xyXG5cdFx0XHRcdFx0XHRcdGlmIChjdHggIT0gbnVsbCkgY3R4LmxpbmVUbyhwcC5jdXJyZW50LngsIHBwLmN1cnJlbnQueSk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlICdWJzpcclxuXHRcdFx0XHRcdGNhc2UgJ3YnOlxyXG5cdFx0XHRcdFx0XHR3aGlsZSAoIXBwLmlzQ29tbWFuZE9yRW5kKCkpIHtcclxuXHRcdFx0XHRcdFx0XHR2YXIgbmV3UCA9IG5ldyBzdmcuUG9pbnQocHAuY3VycmVudC54LCAocHAuaXNSZWxhdGl2ZUNvbW1hbmQoKSA/IHBwLmN1cnJlbnQueSA6IDApICsgcHAuZ2V0U2NhbGFyKCkpO1xyXG5cdFx0XHRcdFx0XHRcdHBwLmFkZE1hcmtlcihuZXdQLCBwcC5jdXJyZW50KTtcclxuXHRcdFx0XHRcdFx0XHRwcC5jdXJyZW50ID0gbmV3UDtcclxuXHRcdFx0XHRcdFx0XHRiYi5hZGRQb2ludChwcC5jdXJyZW50LngsIHBwLmN1cnJlbnQueSk7XHJcblx0XHRcdFx0XHRcdFx0aWYgKGN0eCAhPSBudWxsKSBjdHgubGluZVRvKHBwLmN1cnJlbnQueCwgcHAuY3VycmVudC55KTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdGNhc2UgJ0MnOlxyXG5cdFx0XHRcdFx0Y2FzZSAnYyc6XHJcblx0XHRcdFx0XHRcdHdoaWxlICghcHAuaXNDb21tYW5kT3JFbmQoKSkge1xyXG5cdFx0XHRcdFx0XHRcdHZhciBjdXJyID0gcHAuY3VycmVudDtcclxuXHRcdFx0XHRcdFx0XHR2YXIgcDEgPSBwcC5nZXRQb2ludCgpO1xyXG5cdFx0XHRcdFx0XHRcdHZhciBjbnRybCA9IHBwLmdldEFzQ29udHJvbFBvaW50KCk7XHJcblx0XHRcdFx0XHRcdFx0dmFyIGNwID0gcHAuZ2V0QXNDdXJyZW50UG9pbnQoKTtcclxuXHRcdFx0XHRcdFx0XHRwcC5hZGRNYXJrZXIoY3AsIGNudHJsLCBwMSk7XHJcblx0XHRcdFx0XHRcdFx0YmIuYWRkQmV6aWVyQ3VydmUoY3Vyci54LCBjdXJyLnksIHAxLngsIHAxLnksIGNudHJsLngsIGNudHJsLnksIGNwLngsIGNwLnkpO1xyXG5cdFx0XHRcdFx0XHRcdGlmIChjdHggIT0gbnVsbCkgY3R4LmJlemllckN1cnZlVG8ocDEueCwgcDEueSwgY250cmwueCwgY250cmwueSwgY3AueCwgY3AueSk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlICdTJzpcclxuXHRcdFx0XHRcdGNhc2UgJ3MnOlxyXG5cdFx0XHRcdFx0XHR3aGlsZSAoIXBwLmlzQ29tbWFuZE9yRW5kKCkpIHtcclxuXHRcdFx0XHRcdFx0XHR2YXIgY3VyciA9IHBwLmN1cnJlbnQ7XHJcblx0XHRcdFx0XHRcdFx0dmFyIHAxID0gcHAuZ2V0UmVmbGVjdGVkQ29udHJvbFBvaW50KCk7XHJcblx0XHRcdFx0XHRcdFx0dmFyIGNudHJsID0gcHAuZ2V0QXNDb250cm9sUG9pbnQoKTtcclxuXHRcdFx0XHRcdFx0XHR2YXIgY3AgPSBwcC5nZXRBc0N1cnJlbnRQb2ludCgpO1xyXG5cdFx0XHRcdFx0XHRcdHBwLmFkZE1hcmtlcihjcCwgY250cmwsIHAxKTtcclxuXHRcdFx0XHRcdFx0XHRiYi5hZGRCZXppZXJDdXJ2ZShjdXJyLngsIGN1cnIueSwgcDEueCwgcDEueSwgY250cmwueCwgY250cmwueSwgY3AueCwgY3AueSk7XHJcblx0XHRcdFx0XHRcdFx0aWYgKGN0eCAhPSBudWxsKSBjdHguYmV6aWVyQ3VydmVUbyhwMS54LCBwMS55LCBjbnRybC54LCBjbnRybC55LCBjcC54LCBjcC55KTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdGNhc2UgJ1EnOlxyXG5cdFx0XHRcdFx0Y2FzZSAncSc6XHJcblx0XHRcdFx0XHRcdHdoaWxlICghcHAuaXNDb21tYW5kT3JFbmQoKSkge1xyXG5cdFx0XHRcdFx0XHRcdHZhciBjdXJyID0gcHAuY3VycmVudDtcclxuXHRcdFx0XHRcdFx0XHR2YXIgY250cmwgPSBwcC5nZXRBc0NvbnRyb2xQb2ludCgpO1xyXG5cdFx0XHRcdFx0XHRcdHZhciBjcCA9IHBwLmdldEFzQ3VycmVudFBvaW50KCk7XHJcblx0XHRcdFx0XHRcdFx0cHAuYWRkTWFya2VyKGNwLCBjbnRybCwgY250cmwpO1xyXG5cdFx0XHRcdFx0XHRcdGJiLmFkZFF1YWRyYXRpY0N1cnZlKGN1cnIueCwgY3Vyci55LCBjbnRybC54LCBjbnRybC55LCBjcC54LCBjcC55KTtcclxuXHRcdFx0XHRcdFx0XHRpZiAoY3R4ICE9IG51bGwpIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKGNudHJsLngsIGNudHJsLnksIGNwLngsIGNwLnkpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSAnVCc6XHJcblx0XHRcdFx0XHRjYXNlICd0JzpcclxuXHRcdFx0XHRcdFx0d2hpbGUgKCFwcC5pc0NvbW1hbmRPckVuZCgpKSB7XHJcblx0XHRcdFx0XHRcdFx0dmFyIGN1cnIgPSBwcC5jdXJyZW50O1xyXG5cdFx0XHRcdFx0XHRcdHZhciBjbnRybCA9IHBwLmdldFJlZmxlY3RlZENvbnRyb2xQb2ludCgpO1xyXG5cdFx0XHRcdFx0XHRcdHBwLmNvbnRyb2wgPSBjbnRybDtcclxuXHRcdFx0XHRcdFx0XHR2YXIgY3AgPSBwcC5nZXRBc0N1cnJlbnRQb2ludCgpO1xyXG5cdFx0XHRcdFx0XHRcdHBwLmFkZE1hcmtlcihjcCwgY250cmwsIGNudHJsKTtcclxuXHRcdFx0XHRcdFx0XHRiYi5hZGRRdWFkcmF0aWNDdXJ2ZShjdXJyLngsIGN1cnIueSwgY250cmwueCwgY250cmwueSwgY3AueCwgY3AueSk7XHJcblx0XHRcdFx0XHRcdFx0aWYgKGN0eCAhPSBudWxsKSBjdHgucXVhZHJhdGljQ3VydmVUbyhjbnRybC54LCBjbnRybC55LCBjcC54LCBjcC55KTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdGNhc2UgJ0EnOlxyXG5cdFx0XHRcdFx0Y2FzZSAnYSc6XHJcblx0XHRcdFx0XHRcdHdoaWxlICghcHAuaXNDb21tYW5kT3JFbmQoKSkge1xyXG5cdFx0XHRcdFx0XHQgICAgdmFyIGN1cnIgPSBwcC5jdXJyZW50O1xyXG5cdFx0XHRcdFx0XHRcdHZhciByeCA9IHBwLmdldFNjYWxhcigpO1xyXG5cdFx0XHRcdFx0XHRcdHZhciByeSA9IHBwLmdldFNjYWxhcigpO1xyXG5cdFx0XHRcdFx0XHRcdHZhciB4QXhpc1JvdGF0aW9uID0gcHAuZ2V0U2NhbGFyKCkgKiAoTWF0aC5QSSAvIDE4MC4wKTtcclxuXHRcdFx0XHRcdFx0XHR2YXIgbGFyZ2VBcmNGbGFnID0gcHAuZ2V0U2NhbGFyKCk7XHJcblx0XHRcdFx0XHRcdFx0dmFyIHN3ZWVwRmxhZyA9IHBwLmdldFNjYWxhcigpO1xyXG5cdFx0XHRcdFx0XHRcdHZhciBjcCA9IHBwLmdldEFzQ3VycmVudFBvaW50KCk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdC8vIENvbnZlcnNpb24gZnJvbSBlbmRwb2ludCB0byBjZW50ZXIgcGFyYW1ldGVyaXphdGlvblxyXG5cdFx0XHRcdFx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRzExL2ltcGxub3RlLmh0bWwjQXJjSW1wbGVtZW50YXRpb25Ob3Rlc1xyXG5cdFx0XHRcdFx0XHRcdC8vIHgxJywgeTEnXHJcblx0XHRcdFx0XHRcdFx0dmFyIGN1cnJwID0gbmV3IHN2Zy5Qb2ludChcclxuXHRcdFx0XHRcdFx0XHRcdE1hdGguY29zKHhBeGlzUm90YXRpb24pICogKGN1cnIueCAtIGNwLngpIC8gMi4wICsgTWF0aC5zaW4oeEF4aXNSb3RhdGlvbikgKiAoY3Vyci55IC0gY3AueSkgLyAyLjAsXHJcblx0XHRcdFx0XHRcdFx0XHQtTWF0aC5zaW4oeEF4aXNSb3RhdGlvbikgKiAoY3Vyci54IC0gY3AueCkgLyAyLjAgKyBNYXRoLmNvcyh4QXhpc1JvdGF0aW9uKSAqIChjdXJyLnkgLSBjcC55KSAvIDIuMFxyXG5cdFx0XHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0XHRcdFx0Ly8gYWRqdXN0IHJhZGlpXHJcblx0XHRcdFx0XHRcdFx0dmFyIGwgPSBNYXRoLnBvdyhjdXJycC54LDIpL01hdGgucG93KHJ4LDIpK01hdGgucG93KGN1cnJwLnksMikvTWF0aC5wb3cocnksMik7XHJcblx0XHRcdFx0XHRcdFx0aWYgKGwgPiAxKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRyeCAqPSBNYXRoLnNxcnQobCk7XHJcblx0XHRcdFx0XHRcdFx0XHRyeSAqPSBNYXRoLnNxcnQobCk7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdC8vIGN4JywgY3knXHJcblx0XHRcdFx0XHRcdFx0dmFyIHMgPSAobGFyZ2VBcmNGbGFnID09IHN3ZWVwRmxhZyA/IC0xIDogMSkgKiBNYXRoLnNxcnQoXHJcblx0XHRcdFx0XHRcdFx0XHQoKE1hdGgucG93KHJ4LDIpKk1hdGgucG93KHJ5LDIpKS0oTWF0aC5wb3cocngsMikqTWF0aC5wb3coY3VycnAueSwyKSktKE1hdGgucG93KHJ5LDIpKk1hdGgucG93KGN1cnJwLngsMikpKSAvXHJcblx0XHRcdFx0XHRcdFx0XHQoTWF0aC5wb3cocngsMikqTWF0aC5wb3coY3VycnAueSwyKStNYXRoLnBvdyhyeSwyKSpNYXRoLnBvdyhjdXJycC54LDIpKVxyXG5cdFx0XHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0XHRcdFx0aWYgKGlzTmFOKHMpKSBzID0gMDtcclxuXHRcdFx0XHRcdFx0XHR2YXIgY3BwID0gbmV3IHN2Zy5Qb2ludChzICogcnggKiBjdXJycC55IC8gcnksIHMgKiAtcnkgKiBjdXJycC54IC8gcngpO1xyXG5cdFx0XHRcdFx0XHRcdC8vIGN4LCBjeVxyXG5cdFx0XHRcdFx0XHRcdHZhciBjZW50cCA9IG5ldyBzdmcuUG9pbnQoXHJcblx0XHRcdFx0XHRcdFx0XHQoY3Vyci54ICsgY3AueCkgLyAyLjAgKyBNYXRoLmNvcyh4QXhpc1JvdGF0aW9uKSAqIGNwcC54IC0gTWF0aC5zaW4oeEF4aXNSb3RhdGlvbikgKiBjcHAueSxcclxuXHRcdFx0XHRcdFx0XHRcdChjdXJyLnkgKyBjcC55KSAvIDIuMCArIE1hdGguc2luKHhBeGlzUm90YXRpb24pICogY3BwLnggKyBNYXRoLmNvcyh4QXhpc1JvdGF0aW9uKSAqIGNwcC55XHJcblx0XHRcdFx0XHRcdFx0KTtcclxuXHRcdFx0XHRcdFx0XHQvLyB2ZWN0b3IgbWFnbml0dWRlXHJcblx0XHRcdFx0XHRcdFx0dmFyIG0gPSBmdW5jdGlvbih2KSB7IHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3codlswXSwyKSArIE1hdGgucG93KHZbMV0sMikpOyB9XHJcblx0XHRcdFx0XHRcdFx0Ly8gcmF0aW8gYmV0d2VlbiB0d28gdmVjdG9yc1xyXG5cdFx0XHRcdFx0XHRcdHZhciByID0gZnVuY3Rpb24odSwgdikgeyByZXR1cm4gKHVbMF0qdlswXSt1WzFdKnZbMV0pIC8gKG0odSkqbSh2KSkgfVxyXG5cdFx0XHRcdFx0XHRcdC8vIGFuZ2xlIGJldHdlZW4gdHdvIHZlY3RvcnNcclxuXHRcdFx0XHRcdFx0XHR2YXIgYSA9IGZ1bmN0aW9uKHUsIHYpIHsgcmV0dXJuICh1WzBdKnZbMV0gPCB1WzFdKnZbMF0gPyAtMSA6IDEpICogTWF0aC5hY29zKHIodSx2KSk7IH1cclxuXHRcdFx0XHRcdFx0XHQvLyBpbml0aWFsIGFuZ2xlXHJcblx0XHRcdFx0XHRcdFx0dmFyIGExID0gYShbMSwwXSwgWyhjdXJycC54LWNwcC54KS9yeCwoY3VycnAueS1jcHAueSkvcnldKTtcclxuXHRcdFx0XHRcdFx0XHQvLyBhbmdsZSBkZWx0YVxyXG5cdFx0XHRcdFx0XHRcdHZhciB1ID0gWyhjdXJycC54LWNwcC54KS9yeCwoY3VycnAueS1jcHAueSkvcnldO1xyXG5cdFx0XHRcdFx0XHRcdHZhciB2ID0gWygtY3VycnAueC1jcHAueCkvcngsKC1jdXJycC55LWNwcC55KS9yeV07XHJcblx0XHRcdFx0XHRcdFx0dmFyIGFkID0gYSh1LCB2KTtcclxuXHRcdFx0XHRcdFx0XHRpZiAocih1LHYpIDw9IC0xKSBhZCA9IE1hdGguUEk7XHJcblx0XHRcdFx0XHRcdFx0aWYgKHIodSx2KSA+PSAxKSBhZCA9IDA7XHJcblxyXG5cdFx0XHRcdFx0XHRcdC8vIGZvciBtYXJrZXJzXHJcblx0XHRcdFx0XHRcdFx0dmFyIGRpciA9IDEgLSBzd2VlcEZsYWcgPyAxLjAgOiAtMS4wO1xyXG5cdFx0XHRcdFx0XHRcdHZhciBhaCA9IGExICsgZGlyICogKGFkIC8gMi4wKTtcclxuXHRcdFx0XHRcdFx0XHR2YXIgaGFsZldheSA9IG5ldyBzdmcuUG9pbnQoXHJcblx0XHRcdFx0XHRcdFx0XHRjZW50cC54ICsgcnggKiBNYXRoLmNvcyhhaCksXHJcblx0XHRcdFx0XHRcdFx0XHRjZW50cC55ICsgcnkgKiBNYXRoLnNpbihhaClcclxuXHRcdFx0XHRcdFx0XHQpO1xyXG5cdFx0XHRcdFx0XHRcdHBwLmFkZE1hcmtlckFuZ2xlKGhhbGZXYXksIGFoIC0gZGlyICogTWF0aC5QSSAvIDIpO1xyXG5cdFx0XHRcdFx0XHRcdHBwLmFkZE1hcmtlckFuZ2xlKGNwLCBhaCAtIGRpciAqIE1hdGguUEkpO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRiYi5hZGRQb2ludChjcC54LCBjcC55KTsgLy8gVE9ETzogdGhpcyBpcyB0b28gbmFpdmUsIG1ha2UgaXQgYmV0dGVyXHJcblx0XHRcdFx0XHRcdFx0aWYgKGN0eCAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdFx0XHR2YXIgciA9IHJ4ID4gcnkgPyByeCA6IHJ5O1xyXG5cdFx0XHRcdFx0XHRcdFx0dmFyIHN4ID0gcnggPiByeSA/IDEgOiByeCAvIHJ5O1xyXG5cdFx0XHRcdFx0XHRcdFx0dmFyIHN5ID0gcnggPiByeSA/IHJ5IC8gcnggOiAxO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGN0eC50cmFuc2xhdGUoY2VudHAueCwgY2VudHAueSk7XHJcblx0XHRcdFx0XHRcdFx0XHRjdHgucm90YXRlKHhBeGlzUm90YXRpb24pO1xyXG5cdFx0XHRcdFx0XHRcdFx0Y3R4LnNjYWxlKHN4LCBzeSk7XHJcblx0XHRcdFx0XHRcdFx0XHRjdHguYXJjKDAsIDAsIHIsIGExLCBhMSArIGFkLCAxIC0gc3dlZXBGbGFnKTtcclxuXHRcdFx0XHRcdFx0XHRcdGN0eC5zY2FsZSgxL3N4LCAxL3N5KTtcclxuXHRcdFx0XHRcdFx0XHRcdGN0eC5yb3RhdGUoLXhBeGlzUm90YXRpb24pO1xyXG5cdFx0XHRcdFx0XHRcdFx0Y3R4LnRyYW5zbGF0ZSgtY2VudHAueCwgLWNlbnRwLnkpO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdGNhc2UgJ1onOlxyXG5cdFx0XHRcdFx0Y2FzZSAneic6XHJcblx0XHRcdFx0XHRcdGlmIChjdHggIT0gbnVsbCkgY3R4LmNsb3NlUGF0aCgpO1xyXG5cdFx0XHRcdFx0XHRwcC5jdXJyZW50ID0gcHAuc3RhcnQ7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gYmI7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuZ2V0TWFya2VycyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHZhciBwb2ludHMgPSB0aGlzLlBhdGhQYXJzZXIuZ2V0TWFya2VyUG9pbnRzKCk7XHJcblx0XHRcdFx0dmFyIGFuZ2xlcyA9IHRoaXMuUGF0aFBhcnNlci5nZXRNYXJrZXJBbmdsZXMoKTtcclxuXHJcblx0XHRcdFx0dmFyIG1hcmtlcnMgPSBbXTtcclxuXHRcdFx0XHRmb3IgKHZhciBpPTA7IGk8cG9pbnRzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHRtYXJrZXJzLnB1c2goW3BvaW50c1tpXSwgYW5nbGVzW2ldXSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiBtYXJrZXJzO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRzdmcuRWxlbWVudC5wYXRoLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5QYXRoRWxlbWVudEJhc2U7XHJcblxyXG5cdFx0Ly8gcGF0dGVybiBlbGVtZW50XHJcblx0XHRzdmcuRWxlbWVudC5wYXR0ZXJuID0gZnVuY3Rpb24obm9kZSkge1xyXG5cdFx0XHR0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcclxuXHRcdFx0dGhpcy5iYXNlKG5vZGUpO1xyXG5cclxuXHRcdFx0dGhpcy5jcmVhdGVQYXR0ZXJuID0gZnVuY3Rpb24oY3R4LCBlbGVtZW50KSB7XHJcblx0XHRcdFx0dmFyIHdpZHRoID0gdGhpcy5hdHRyaWJ1dGUoJ3dpZHRoJykudG9QaXhlbHMoJ3gnLCB0cnVlKTtcclxuXHRcdFx0XHR2YXIgaGVpZ2h0ID0gdGhpcy5hdHRyaWJ1dGUoJ2hlaWdodCcpLnRvUGl4ZWxzKCd5JywgdHJ1ZSk7XHJcblxyXG5cdFx0XHRcdC8vIHJlbmRlciBtZSB1c2luZyBhIHRlbXBvcmFyeSBzdmcgZWxlbWVudFxyXG5cdFx0XHRcdHZhciB0ZW1wU3ZnID0gbmV3IHN2Zy5FbGVtZW50LnN2ZygpO1xyXG5cdFx0XHRcdHRlbXBTdmcuYXR0cmlidXRlc1sndmlld0JveCddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgndmlld0JveCcsIHRoaXMuYXR0cmlidXRlKCd2aWV3Qm94JykudmFsdWUpO1xyXG5cdFx0XHRcdHRlbXBTdmcuYXR0cmlidXRlc1snd2lkdGgnXSA9IG5ldyBzdmcuUHJvcGVydHkoJ3dpZHRoJywgd2lkdGggKyAncHgnKTtcclxuXHRcdFx0XHR0ZW1wU3ZnLmF0dHJpYnV0ZXNbJ2hlaWdodCddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgnaGVpZ2h0JywgaGVpZ2h0ICsgJ3B4Jyk7XHJcblx0XHRcdFx0dGVtcFN2Zy5hdHRyaWJ1dGVzWyd0cmFuc2Zvcm0nXSA9IG5ldyBzdmcuUHJvcGVydHkoJ3RyYW5zZm9ybScsIHRoaXMuYXR0cmlidXRlKCdwYXR0ZXJuVHJhbnNmb3JtJykudmFsdWUpO1xyXG5cdFx0XHRcdHRlbXBTdmcuY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xyXG5cclxuXHRcdFx0XHR2YXIgYyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG5cdFx0XHRcdGMud2lkdGggPSB3aWR0aDtcclxuXHRcdFx0XHRjLmhlaWdodCA9IGhlaWdodDtcclxuXHRcdFx0XHR2YXIgY2N0eCA9IGMuZ2V0Q29udGV4dCgnMmQnKTtcclxuXHRcdFx0XHRpZiAodGhpcy5hdHRyaWJ1dGUoJ3gnKS5oYXNWYWx1ZSgpICYmIHRoaXMuYXR0cmlidXRlKCd5JykuaGFzVmFsdWUoKSkge1xyXG5cdFx0XHRcdFx0Y2N0eC50cmFuc2xhdGUodGhpcy5hdHRyaWJ1dGUoJ3gnKS50b1BpeGVscygneCcsIHRydWUpLCB0aGlzLmF0dHJpYnV0ZSgneScpLnRvUGl4ZWxzKCd5JywgdHJ1ZSkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHQvLyByZW5kZXIgM3gzIGdyaWQgc28gd2hlbiB3ZSB0cmFuc2Zvcm0gdGhlcmUncyBubyB3aGl0ZSBzcGFjZSBvbiBlZGdlc1xyXG5cdFx0XHRcdGZvciAodmFyIHg9LTE7IHg8PTE7IHgrKykge1xyXG5cdFx0XHRcdFx0Zm9yICh2YXIgeT0tMTsgeTw9MTsgeSsrKSB7XHJcblx0XHRcdFx0XHRcdGNjdHguc2F2ZSgpO1xyXG5cdFx0XHRcdFx0XHR0ZW1wU3ZnLmF0dHJpYnV0ZXNbJ3gnXSA9IG5ldyBzdmcuUHJvcGVydHkoJ3gnLCB4ICogYy53aWR0aCk7XHJcblx0XHRcdFx0XHRcdHRlbXBTdmcuYXR0cmlidXRlc1sneSddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgneScsIHkgKiBjLmhlaWdodCk7XHJcblx0XHRcdFx0XHRcdHRlbXBTdmcucmVuZGVyKGNjdHgpO1xyXG5cdFx0XHRcdFx0XHRjY3R4LnJlc3RvcmUoKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dmFyIHBhdHRlcm4gPSBjdHguY3JlYXRlUGF0dGVybihjLCAncmVwZWF0Jyk7XHJcblx0XHRcdFx0cmV0dXJuIHBhdHRlcm47XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHN2Zy5FbGVtZW50LnBhdHRlcm4ucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xyXG5cclxuXHRcdC8vIG1hcmtlciBlbGVtZW50XHJcblx0XHRzdmcuRWxlbWVudC5tYXJrZXIgPSBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xyXG5cdFx0XHR0aGlzLmJhc2Uobm9kZSk7XHJcblxyXG5cdFx0XHR0aGlzLmJhc2VSZW5kZXIgPSB0aGlzLnJlbmRlcjtcclxuXHRcdFx0dGhpcy5yZW5kZXIgPSBmdW5jdGlvbihjdHgsIHBvaW50LCBhbmdsZSkge1xyXG5cdFx0XHRcdGN0eC50cmFuc2xhdGUocG9pbnQueCwgcG9pbnQueSk7XHJcblx0XHRcdFx0aWYgKHRoaXMuYXR0cmlidXRlKCdvcmllbnQnKS52YWx1ZU9yRGVmYXVsdCgnYXV0bycpID09ICdhdXRvJykgY3R4LnJvdGF0ZShhbmdsZSk7XHJcblx0XHRcdFx0aWYgKHRoaXMuYXR0cmlidXRlKCdtYXJrZXJVbml0cycpLnZhbHVlT3JEZWZhdWx0KCdzdHJva2VXaWR0aCcpID09ICdzdHJva2VXaWR0aCcpIGN0eC5zY2FsZShjdHgubGluZVdpZHRoLCBjdHgubGluZVdpZHRoKTtcclxuXHRcdFx0XHRjdHguc2F2ZSgpO1xyXG5cclxuXHRcdFx0XHQvLyByZW5kZXIgbWUgdXNpbmcgYSB0ZW1wb3Jhcnkgc3ZnIGVsZW1lbnRcclxuXHRcdFx0XHR2YXIgdGVtcFN2ZyA9IG5ldyBzdmcuRWxlbWVudC5zdmcoKTtcclxuXHRcdFx0XHR0ZW1wU3ZnLmF0dHJpYnV0ZXNbJ3ZpZXdCb3gnXSA9IG5ldyBzdmcuUHJvcGVydHkoJ3ZpZXdCb3gnLCB0aGlzLmF0dHJpYnV0ZSgndmlld0JveCcpLnZhbHVlKTtcclxuXHRcdFx0XHR0ZW1wU3ZnLmF0dHJpYnV0ZXNbJ3JlZlgnXSA9IG5ldyBzdmcuUHJvcGVydHkoJ3JlZlgnLCB0aGlzLmF0dHJpYnV0ZSgncmVmWCcpLnZhbHVlKTtcclxuXHRcdFx0XHR0ZW1wU3ZnLmF0dHJpYnV0ZXNbJ3JlZlknXSA9IG5ldyBzdmcuUHJvcGVydHkoJ3JlZlknLCB0aGlzLmF0dHJpYnV0ZSgncmVmWScpLnZhbHVlKTtcclxuXHRcdFx0XHR0ZW1wU3ZnLmF0dHJpYnV0ZXNbJ3dpZHRoJ10gPSBuZXcgc3ZnLlByb3BlcnR5KCd3aWR0aCcsIHRoaXMuYXR0cmlidXRlKCdtYXJrZXJXaWR0aCcpLnZhbHVlKTtcclxuXHRcdFx0XHR0ZW1wU3ZnLmF0dHJpYnV0ZXNbJ2hlaWdodCddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgnaGVpZ2h0JywgdGhpcy5hdHRyaWJ1dGUoJ21hcmtlckhlaWdodCcpLnZhbHVlKTtcclxuXHRcdFx0XHR0ZW1wU3ZnLmF0dHJpYnV0ZXNbJ2ZpbGwnXSA9IG5ldyBzdmcuUHJvcGVydHkoJ2ZpbGwnLCB0aGlzLmF0dHJpYnV0ZSgnZmlsbCcpLnZhbHVlT3JEZWZhdWx0KCdibGFjaycpKTtcclxuXHRcdFx0XHR0ZW1wU3ZnLmF0dHJpYnV0ZXNbJ3N0cm9rZSddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgnc3Ryb2tlJywgdGhpcy5hdHRyaWJ1dGUoJ3N0cm9rZScpLnZhbHVlT3JEZWZhdWx0KCdub25lJykpO1xyXG5cdFx0XHRcdHRlbXBTdmcuY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xyXG5cdFx0XHRcdHRlbXBTdmcucmVuZGVyKGN0eCk7XHJcblxyXG5cdFx0XHRcdGN0eC5yZXN0b3JlKCk7XHJcblx0XHRcdFx0aWYgKHRoaXMuYXR0cmlidXRlKCdtYXJrZXJVbml0cycpLnZhbHVlT3JEZWZhdWx0KCdzdHJva2VXaWR0aCcpID09ICdzdHJva2VXaWR0aCcpIGN0eC5zY2FsZSgxL2N0eC5saW5lV2lkdGgsIDEvY3R4LmxpbmVXaWR0aCk7XHJcblx0XHRcdFx0aWYgKHRoaXMuYXR0cmlidXRlKCdvcmllbnQnKS52YWx1ZU9yRGVmYXVsdCgnYXV0bycpID09ICdhdXRvJykgY3R4LnJvdGF0ZSgtYW5nbGUpO1xyXG5cdFx0XHRcdGN0eC50cmFuc2xhdGUoLXBvaW50LngsIC1wb2ludC55KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0c3ZnLkVsZW1lbnQubWFya2VyLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcclxuXHJcblx0XHQvLyBkZWZpbml0aW9ucyBlbGVtZW50XHJcblx0XHRzdmcuRWxlbWVudC5kZWZzID0gZnVuY3Rpb24obm9kZSkge1xyXG5cdFx0XHR0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcclxuXHRcdFx0dGhpcy5iYXNlKG5vZGUpO1xyXG5cclxuXHRcdFx0dGhpcy5yZW5kZXIgPSBmdW5jdGlvbihjdHgpIHtcclxuXHRcdFx0XHQvLyBOT09QXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHN2Zy5FbGVtZW50LmRlZnMucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xyXG5cclxuXHRcdC8vIGJhc2UgZm9yIGdyYWRpZW50c1xyXG5cdFx0c3ZnLkVsZW1lbnQuR3JhZGllbnRCYXNlID0gZnVuY3Rpb24obm9kZSkge1xyXG5cdFx0XHR0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcclxuXHRcdFx0dGhpcy5iYXNlKG5vZGUpO1xyXG5cclxuXHRcdFx0dGhpcy5zdG9wcyA9IFtdO1xyXG5cdFx0XHRmb3IgKHZhciBpPTA7IGk8dGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XHJcblx0XHRcdFx0aWYgKGNoaWxkLnR5cGUgPT0gJ3N0b3AnKSB0aGlzLnN0b3BzLnB1c2goY2hpbGQpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmdldEdyYWRpZW50ID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0Ly8gT1ZFUlJJREUgTUUhXHJcblx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHRcdHRoaXMuZ3JhZGllbnRVbml0cyA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5hdHRyaWJ1dGUoJ2dyYWRpZW50VW5pdHMnKS52YWx1ZU9yRGVmYXVsdCgnb2JqZWN0Qm91bmRpbmdCb3gnKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRcclxuXHRcdFx0dGhpcy5hdHRyaWJ1dGVzVG9Jbmhlcml0ID0gWydncmFkaWVudFVuaXRzJ107XHJcblx0XHRcdFxyXG5cdFx0XHR0aGlzLmluaGVyaXRTdG9wQ29udGFpbmVyID0gZnVuY3Rpb24gKHN0b3BzQ29udGFpbmVyKSB7XHJcblx0XHRcdFx0Zm9yICh2YXIgaT0wOyBpPHRoaXMuYXR0cmlidXRlc1RvSW5oZXJpdC5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0dmFyIGF0dHJpYnV0ZVRvSW5oZXJpdCA9IHRoaXMuYXR0cmlidXRlc1RvSW5oZXJpdFtpXTtcclxuXHRcdFx0XHRcdGlmICghdGhpcy5hdHRyaWJ1dGUoYXR0cmlidXRlVG9Jbmhlcml0KS5oYXNWYWx1ZSgpICYmIHN0b3BzQ29udGFpbmVyLmF0dHJpYnV0ZShhdHRyaWJ1dGVUb0luaGVyaXQpLmhhc1ZhbHVlKCkpIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5hdHRyaWJ1dGUoYXR0cmlidXRlVG9Jbmhlcml0LCB0cnVlKS52YWx1ZSA9IHN0b3BzQ29udGFpbmVyLmF0dHJpYnV0ZShhdHRyaWJ1dGVUb0luaGVyaXQpLnZhbHVlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5jcmVhdGVHcmFkaWVudCA9IGZ1bmN0aW9uKGN0eCwgZWxlbWVudCwgcGFyZW50T3BhY2l0eVByb3ApIHtcclxuXHRcdFx0XHR2YXIgc3RvcHNDb250YWluZXIgPSB0aGlzO1xyXG5cdFx0XHRcdGlmICh0aGlzLmdldEhyZWZBdHRyaWJ1dGUoKS5oYXNWYWx1ZSgpKSB7XHJcblx0XHRcdFx0XHRzdG9wc0NvbnRhaW5lciA9IHRoaXMuZ2V0SHJlZkF0dHJpYnV0ZSgpLmdldERlZmluaXRpb24oKTtcclxuXHRcdFx0XHRcdHRoaXMuaW5oZXJpdFN0b3BDb250YWluZXIoc3RvcHNDb250YWluZXIpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dmFyIGFkZFBhcmVudE9wYWNpdHkgPSBmdW5jdGlvbiAoY29sb3IpIHtcclxuXHRcdFx0XHRcdGlmIChwYXJlbnRPcGFjaXR5UHJvcC5oYXNWYWx1ZSgpKSB7XHJcblx0XHRcdFx0XHRcdHZhciBwID0gbmV3IHN2Zy5Qcm9wZXJ0eSgnY29sb3InLCBjb2xvcik7XHJcblx0XHRcdFx0XHRcdHJldHVybiBwLmFkZE9wYWNpdHkocGFyZW50T3BhY2l0eVByb3ApLnZhbHVlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0cmV0dXJuIGNvbG9yO1xyXG5cdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdHZhciBnID0gdGhpcy5nZXRHcmFkaWVudChjdHgsIGVsZW1lbnQpO1xyXG5cdFx0XHRcdGlmIChnID09IG51bGwpIHJldHVybiBhZGRQYXJlbnRPcGFjaXR5KHN0b3BzQ29udGFpbmVyLnN0b3BzW3N0b3BzQ29udGFpbmVyLnN0b3BzLmxlbmd0aCAtIDFdLmNvbG9yKTtcclxuXHRcdFx0XHRmb3IgKHZhciBpPTA7IGk8c3RvcHNDb250YWluZXIuc3RvcHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdGcuYWRkQ29sb3JTdG9wKHN0b3BzQ29udGFpbmVyLnN0b3BzW2ldLm9mZnNldCwgYWRkUGFyZW50T3BhY2l0eShzdG9wc0NvbnRhaW5lci5zdG9wc1tpXS5jb2xvcikpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKHRoaXMuYXR0cmlidXRlKCdncmFkaWVudFRyYW5zZm9ybScpLmhhc1ZhbHVlKCkpIHtcclxuXHRcdFx0XHRcdC8vIHJlbmRlciBhcyB0cmFuc2Zvcm1lZCBwYXR0ZXJuIG9uIHRlbXBvcmFyeSBjYW52YXNcclxuXHRcdFx0XHRcdHZhciByb290VmlldyA9IHN2Zy5WaWV3UG9ydC52aWV3UG9ydHNbMF07XHJcblxyXG5cdFx0XHRcdFx0dmFyIHJlY3QgPSBuZXcgc3ZnLkVsZW1lbnQucmVjdCgpO1xyXG5cdFx0XHRcdFx0cmVjdC5hdHRyaWJ1dGVzWyd4J10gPSBuZXcgc3ZnLlByb3BlcnR5KCd4JywgLXN2Zy5NQVhfVklSVFVBTF9QSVhFTFMvMy4wKTtcclxuXHRcdFx0XHRcdHJlY3QuYXR0cmlidXRlc1sneSddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgneScsIC1zdmcuTUFYX1ZJUlRVQUxfUElYRUxTLzMuMCk7XHJcblx0XHRcdFx0XHRyZWN0LmF0dHJpYnV0ZXNbJ3dpZHRoJ10gPSBuZXcgc3ZnLlByb3BlcnR5KCd3aWR0aCcsIHN2Zy5NQVhfVklSVFVBTF9QSVhFTFMpO1xyXG5cdFx0XHRcdFx0cmVjdC5hdHRyaWJ1dGVzWydoZWlnaHQnXSA9IG5ldyBzdmcuUHJvcGVydHkoJ2hlaWdodCcsIHN2Zy5NQVhfVklSVFVBTF9QSVhFTFMpO1xyXG5cclxuXHRcdFx0XHRcdHZhciBncm91cCA9IG5ldyBzdmcuRWxlbWVudC5nKCk7XHJcblx0XHRcdFx0XHRncm91cC5hdHRyaWJ1dGVzWyd0cmFuc2Zvcm0nXSA9IG5ldyBzdmcuUHJvcGVydHkoJ3RyYW5zZm9ybScsIHRoaXMuYXR0cmlidXRlKCdncmFkaWVudFRyYW5zZm9ybScpLnZhbHVlKTtcclxuXHRcdFx0XHRcdGdyb3VwLmNoaWxkcmVuID0gWyByZWN0IF07XHJcblxyXG5cdFx0XHRcdFx0dmFyIHRlbXBTdmcgPSBuZXcgc3ZnLkVsZW1lbnQuc3ZnKCk7XHJcblx0XHRcdFx0XHR0ZW1wU3ZnLmF0dHJpYnV0ZXNbJ3gnXSA9IG5ldyBzdmcuUHJvcGVydHkoJ3gnLCAwKTtcclxuXHRcdFx0XHRcdHRlbXBTdmcuYXR0cmlidXRlc1sneSddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgneScsIDApO1xyXG5cdFx0XHRcdFx0dGVtcFN2Zy5hdHRyaWJ1dGVzWyd3aWR0aCddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgnd2lkdGgnLCByb290Vmlldy53aWR0aCk7XHJcblx0XHRcdFx0XHR0ZW1wU3ZnLmF0dHJpYnV0ZXNbJ2hlaWdodCddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgnaGVpZ2h0Jywgcm9vdFZpZXcuaGVpZ2h0KTtcclxuXHRcdFx0XHRcdHRlbXBTdmcuY2hpbGRyZW4gPSBbIGdyb3VwIF07XHJcblxyXG5cdFx0XHRcdFx0dmFyIGMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuXHRcdFx0XHRcdGMud2lkdGggPSByb290Vmlldy53aWR0aDtcclxuXHRcdFx0XHRcdGMuaGVpZ2h0ID0gcm9vdFZpZXcuaGVpZ2h0O1xyXG5cdFx0XHRcdFx0dmFyIHRlbXBDdHggPSBjLmdldENvbnRleHQoJzJkJyk7XHJcblx0XHRcdFx0XHR0ZW1wQ3R4LmZpbGxTdHlsZSA9IGc7XHJcblx0XHRcdFx0XHR0ZW1wU3ZnLnJlbmRlcih0ZW1wQ3R4KTtcclxuXHRcdFx0XHRcdHJldHVybiB0ZW1wQ3R4LmNyZWF0ZVBhdHRlcm4oYywgJ25vLXJlcGVhdCcpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cmV0dXJuIGc7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHN2Zy5FbGVtZW50LkdyYWRpZW50QmFzZS5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XHJcblxyXG5cdFx0Ly8gbGluZWFyIGdyYWRpZW50IGVsZW1lbnRcclxuXHRcdHN2Zy5FbGVtZW50LmxpbmVhckdyYWRpZW50ID0gZnVuY3Rpb24obm9kZSkge1xyXG5cdFx0XHR0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5HcmFkaWVudEJhc2U7XHJcblx0XHRcdHRoaXMuYmFzZShub2RlKTtcclxuXHRcdFx0XHJcblx0XHRcdHRoaXMuYXR0cmlidXRlc1RvSW5oZXJpdC5wdXNoKCd4MScpO1xyXG5cdFx0XHR0aGlzLmF0dHJpYnV0ZXNUb0luaGVyaXQucHVzaCgneTEnKTtcclxuXHRcdFx0dGhpcy5hdHRyaWJ1dGVzVG9Jbmhlcml0LnB1c2goJ3gyJyk7XHJcblx0XHRcdHRoaXMuYXR0cmlidXRlc1RvSW5oZXJpdC5wdXNoKCd5MicpO1xyXG5cclxuXHRcdFx0dGhpcy5nZXRHcmFkaWVudCA9IGZ1bmN0aW9uKGN0eCwgZWxlbWVudCkge1xyXG5cdFx0XHRcdHZhciBiYiA9IHRoaXMuZ3JhZGllbnRVbml0cygpID09ICdvYmplY3RCb3VuZGluZ0JveCcgPyBlbGVtZW50LmdldEJvdW5kaW5nQm94KCkgOiBudWxsO1xyXG5cclxuXHRcdFx0XHRpZiAoIXRoaXMuYXR0cmlidXRlKCd4MScpLmhhc1ZhbHVlKClcclxuXHRcdFx0XHQgJiYgIXRoaXMuYXR0cmlidXRlKCd5MScpLmhhc1ZhbHVlKClcclxuXHRcdFx0XHQgJiYgIXRoaXMuYXR0cmlidXRlKCd4MicpLmhhc1ZhbHVlKClcclxuXHRcdFx0XHQgJiYgIXRoaXMuYXR0cmlidXRlKCd5MicpLmhhc1ZhbHVlKCkpIHtcclxuXHRcdFx0XHRcdHRoaXMuYXR0cmlidXRlKCd4MScsIHRydWUpLnZhbHVlID0gMDtcclxuXHRcdFx0XHRcdHRoaXMuYXR0cmlidXRlKCd5MScsIHRydWUpLnZhbHVlID0gMDtcclxuXHRcdFx0XHRcdHRoaXMuYXR0cmlidXRlKCd4MicsIHRydWUpLnZhbHVlID0gMTtcclxuXHRcdFx0XHRcdHRoaXMuYXR0cmlidXRlKCd5MicsIHRydWUpLnZhbHVlID0gMDtcclxuXHRcdFx0XHQgfVxyXG5cclxuXHRcdFx0XHR2YXIgeDEgPSAodGhpcy5ncmFkaWVudFVuaXRzKCkgPT0gJ29iamVjdEJvdW5kaW5nQm94J1xyXG5cdFx0XHRcdFx0PyBiYi54KCkgKyBiYi53aWR0aCgpICogdGhpcy5hdHRyaWJ1dGUoJ3gxJykubnVtVmFsdWUoKVxyXG5cdFx0XHRcdFx0OiB0aGlzLmF0dHJpYnV0ZSgneDEnKS50b1BpeGVscygneCcpKTtcclxuXHRcdFx0XHR2YXIgeTEgPSAodGhpcy5ncmFkaWVudFVuaXRzKCkgPT0gJ29iamVjdEJvdW5kaW5nQm94J1xyXG5cdFx0XHRcdFx0PyBiYi55KCkgKyBiYi5oZWlnaHQoKSAqIHRoaXMuYXR0cmlidXRlKCd5MScpLm51bVZhbHVlKClcclxuXHRcdFx0XHRcdDogdGhpcy5hdHRyaWJ1dGUoJ3kxJykudG9QaXhlbHMoJ3knKSk7XHJcblx0XHRcdFx0dmFyIHgyID0gKHRoaXMuZ3JhZGllbnRVbml0cygpID09ICdvYmplY3RCb3VuZGluZ0JveCdcclxuXHRcdFx0XHRcdD8gYmIueCgpICsgYmIud2lkdGgoKSAqIHRoaXMuYXR0cmlidXRlKCd4MicpLm51bVZhbHVlKClcclxuXHRcdFx0XHRcdDogdGhpcy5hdHRyaWJ1dGUoJ3gyJykudG9QaXhlbHMoJ3gnKSk7XHJcblx0XHRcdFx0dmFyIHkyID0gKHRoaXMuZ3JhZGllbnRVbml0cygpID09ICdvYmplY3RCb3VuZGluZ0JveCdcclxuXHRcdFx0XHRcdD8gYmIueSgpICsgYmIuaGVpZ2h0KCkgKiB0aGlzLmF0dHJpYnV0ZSgneTInKS5udW1WYWx1ZSgpXHJcblx0XHRcdFx0XHQ6IHRoaXMuYXR0cmlidXRlKCd5MicpLnRvUGl4ZWxzKCd5JykpO1xyXG5cclxuXHRcdFx0XHRpZiAoeDEgPT0geDIgJiYgeTEgPT0geTIpIHJldHVybiBudWxsO1xyXG5cdFx0XHRcdHJldHVybiBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoeDEsIHkxLCB4MiwgeTIpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRzdmcuRWxlbWVudC5saW5lYXJHcmFkaWVudC5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuR3JhZGllbnRCYXNlO1xyXG5cclxuXHRcdC8vIHJhZGlhbCBncmFkaWVudCBlbGVtZW50XHJcblx0XHRzdmcuRWxlbWVudC5yYWRpYWxHcmFkaWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdFx0dGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuR3JhZGllbnRCYXNlO1xyXG5cdFx0XHR0aGlzLmJhc2Uobm9kZSk7XHJcblx0XHRcdFxyXG5cdFx0XHR0aGlzLmF0dHJpYnV0ZXNUb0luaGVyaXQucHVzaCgnY3gnKTtcclxuXHRcdFx0dGhpcy5hdHRyaWJ1dGVzVG9Jbmhlcml0LnB1c2goJ2N5Jyk7XHJcblx0XHRcdHRoaXMuYXR0cmlidXRlc1RvSW5oZXJpdC5wdXNoKCdyJyk7XHJcblx0XHRcdHRoaXMuYXR0cmlidXRlc1RvSW5oZXJpdC5wdXNoKCdmeCcpO1xyXG5cdFx0XHR0aGlzLmF0dHJpYnV0ZXNUb0luaGVyaXQucHVzaCgnZnknKTtcclxuXHJcblx0XHRcdHRoaXMuZ2V0R3JhZGllbnQgPSBmdW5jdGlvbihjdHgsIGVsZW1lbnQpIHtcclxuXHRcdFx0XHR2YXIgYmIgPSBlbGVtZW50LmdldEJvdW5kaW5nQm94KCk7XHJcblxyXG5cdFx0XHRcdGlmICghdGhpcy5hdHRyaWJ1dGUoJ2N4JykuaGFzVmFsdWUoKSkgdGhpcy5hdHRyaWJ1dGUoJ2N4JywgdHJ1ZSkudmFsdWUgPSAnNTAlJztcclxuXHRcdFx0XHRpZiAoIXRoaXMuYXR0cmlidXRlKCdjeScpLmhhc1ZhbHVlKCkpIHRoaXMuYXR0cmlidXRlKCdjeScsIHRydWUpLnZhbHVlID0gJzUwJSc7XHJcblx0XHRcdFx0aWYgKCF0aGlzLmF0dHJpYnV0ZSgncicpLmhhc1ZhbHVlKCkpIHRoaXMuYXR0cmlidXRlKCdyJywgdHJ1ZSkudmFsdWUgPSAnNTAlJztcclxuXHJcblx0XHRcdFx0dmFyIGN4ID0gKHRoaXMuZ3JhZGllbnRVbml0cygpID09ICdvYmplY3RCb3VuZGluZ0JveCdcclxuXHRcdFx0XHRcdD8gYmIueCgpICsgYmIud2lkdGgoKSAqIHRoaXMuYXR0cmlidXRlKCdjeCcpLm51bVZhbHVlKClcclxuXHRcdFx0XHRcdDogdGhpcy5hdHRyaWJ1dGUoJ2N4JykudG9QaXhlbHMoJ3gnKSk7XHJcblx0XHRcdFx0dmFyIGN5ID0gKHRoaXMuZ3JhZGllbnRVbml0cygpID09ICdvYmplY3RCb3VuZGluZ0JveCdcclxuXHRcdFx0XHRcdD8gYmIueSgpICsgYmIuaGVpZ2h0KCkgKiB0aGlzLmF0dHJpYnV0ZSgnY3knKS5udW1WYWx1ZSgpXHJcblx0XHRcdFx0XHQ6IHRoaXMuYXR0cmlidXRlKCdjeScpLnRvUGl4ZWxzKCd5JykpO1xyXG5cclxuXHRcdFx0XHR2YXIgZnggPSBjeDtcclxuXHRcdFx0XHR2YXIgZnkgPSBjeTtcclxuXHRcdFx0XHRpZiAodGhpcy5hdHRyaWJ1dGUoJ2Z4JykuaGFzVmFsdWUoKSkge1xyXG5cdFx0XHRcdFx0ZnggPSAodGhpcy5ncmFkaWVudFVuaXRzKCkgPT0gJ29iamVjdEJvdW5kaW5nQm94J1xyXG5cdFx0XHRcdFx0PyBiYi54KCkgKyBiYi53aWR0aCgpICogdGhpcy5hdHRyaWJ1dGUoJ2Z4JykubnVtVmFsdWUoKVxyXG5cdFx0XHRcdFx0OiB0aGlzLmF0dHJpYnV0ZSgnZngnKS50b1BpeGVscygneCcpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKHRoaXMuYXR0cmlidXRlKCdmeScpLmhhc1ZhbHVlKCkpIHtcclxuXHRcdFx0XHRcdGZ5ID0gKHRoaXMuZ3JhZGllbnRVbml0cygpID09ICdvYmplY3RCb3VuZGluZ0JveCdcclxuXHRcdFx0XHRcdD8gYmIueSgpICsgYmIuaGVpZ2h0KCkgKiB0aGlzLmF0dHJpYnV0ZSgnZnknKS5udW1WYWx1ZSgpXHJcblx0XHRcdFx0XHQ6IHRoaXMuYXR0cmlidXRlKCdmeScpLnRvUGl4ZWxzKCd5JykpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dmFyIHIgPSAodGhpcy5ncmFkaWVudFVuaXRzKCkgPT0gJ29iamVjdEJvdW5kaW5nQm94J1xyXG5cdFx0XHRcdFx0PyAoYmIud2lkdGgoKSArIGJiLmhlaWdodCgpKSAvIDIuMCAqIHRoaXMuYXR0cmlidXRlKCdyJykubnVtVmFsdWUoKVxyXG5cdFx0XHRcdFx0OiB0aGlzLmF0dHJpYnV0ZSgncicpLnRvUGl4ZWxzKCkpO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KGZ4LCBmeSwgMCwgY3gsIGN5LCByKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0c3ZnLkVsZW1lbnQucmFkaWFsR3JhZGllbnQucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LkdyYWRpZW50QmFzZTtcclxuXHJcblx0XHQvLyBncmFkaWVudCBzdG9wIGVsZW1lbnRcclxuXHRcdHN2Zy5FbGVtZW50LnN0b3AgPSBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xyXG5cdFx0XHR0aGlzLmJhc2Uobm9kZSk7XHJcblxyXG5cdFx0XHR0aGlzLm9mZnNldCA9IHRoaXMuYXR0cmlidXRlKCdvZmZzZXQnKS5udW1WYWx1ZSgpO1xyXG5cdFx0XHRpZiAodGhpcy5vZmZzZXQgPCAwKSB0aGlzLm9mZnNldCA9IDA7XHJcblx0XHRcdGlmICh0aGlzLm9mZnNldCA+IDEpIHRoaXMub2Zmc2V0ID0gMTtcclxuXHJcblx0XHRcdHZhciBzdG9wQ29sb3IgPSB0aGlzLnN0eWxlKCdzdG9wLWNvbG9yJywgdHJ1ZSk7XHJcblx0XHRcdGlmIChzdG9wQ29sb3IudmFsdWUgPT09ICcnKSBzdG9wQ29sb3IudmFsdWUgPSAnIzAwMCc7XHJcblx0XHRcdGlmICh0aGlzLnN0eWxlKCdzdG9wLW9wYWNpdHknKS5oYXNWYWx1ZSgpKSBzdG9wQ29sb3IgPSBzdG9wQ29sb3IuYWRkT3BhY2l0eSh0aGlzLnN0eWxlKCdzdG9wLW9wYWNpdHknKSk7XHJcblx0XHRcdHRoaXMuY29sb3IgPSBzdG9wQ29sb3IudmFsdWU7XHJcblx0XHR9XHJcblx0XHRzdmcuRWxlbWVudC5zdG9wLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcclxuXHJcblx0XHQvLyBhbmltYXRpb24gYmFzZSBlbGVtZW50XHJcblx0XHRzdmcuRWxlbWVudC5BbmltYXRlQmFzZSA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdFx0dGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XHJcblx0XHRcdHRoaXMuYmFzZShub2RlKTtcclxuXHJcblx0XHRcdHN2Zy5BbmltYXRpb25zLnB1c2godGhpcyk7XHJcblxyXG5cdFx0XHR0aGlzLmR1cmF0aW9uID0gMC4wO1xyXG5cdFx0XHR0aGlzLmJlZ2luID0gdGhpcy5hdHRyaWJ1dGUoJ2JlZ2luJykudG9NaWxsaXNlY29uZHMoKTtcclxuXHRcdFx0dGhpcy5tYXhEdXJhdGlvbiA9IHRoaXMuYmVnaW4gKyB0aGlzLmF0dHJpYnV0ZSgnZHVyJykudG9NaWxsaXNlY29uZHMoKTtcclxuXHJcblx0XHRcdHRoaXMuZ2V0UHJvcGVydHkgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHR2YXIgYXR0cmlidXRlVHlwZSA9IHRoaXMuYXR0cmlidXRlKCdhdHRyaWJ1dGVUeXBlJykudmFsdWU7XHJcblx0XHRcdFx0dmFyIGF0dHJpYnV0ZU5hbWUgPSB0aGlzLmF0dHJpYnV0ZSgnYXR0cmlidXRlTmFtZScpLnZhbHVlO1xyXG5cclxuXHRcdFx0XHRpZiAoYXR0cmlidXRlVHlwZSA9PSAnQ1NTJykge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMucGFyZW50LnN0eWxlKGF0dHJpYnV0ZU5hbWUsIHRydWUpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5wYXJlbnQuYXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsIHRydWUpO1xyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0dGhpcy5pbml0aWFsVmFsdWUgPSBudWxsO1xyXG5cdFx0XHR0aGlzLmluaXRpYWxVbml0cyA9ICcnO1xyXG5cdFx0XHR0aGlzLnJlbW92ZWQgPSBmYWxzZTtcclxuXHJcblx0XHRcdHRoaXMuY2FsY1ZhbHVlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0Ly8gT1ZFUlJJREUgTUUhXHJcblx0XHRcdFx0cmV0dXJuICcnO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLnVwZGF0ZSA9IGZ1bmN0aW9uKGRlbHRhKSB7XHJcblx0XHRcdFx0Ly8gc2V0IGluaXRpYWwgdmFsdWVcclxuXHRcdFx0XHRpZiAodGhpcy5pbml0aWFsVmFsdWUgPT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0dGhpcy5pbml0aWFsVmFsdWUgPSB0aGlzLmdldFByb3BlcnR5KCkudmFsdWU7XHJcblx0XHRcdFx0XHR0aGlzLmluaXRpYWxVbml0cyA9IHRoaXMuZ2V0UHJvcGVydHkoKS5nZXRVbml0cygpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gaWYgd2UncmUgcGFzdCB0aGUgZW5kIHRpbWVcclxuXHRcdFx0XHRpZiAodGhpcy5kdXJhdGlvbiA+IHRoaXMubWF4RHVyYXRpb24pIHtcclxuXHRcdFx0XHRcdC8vIGxvb3AgZm9yIGluZGVmaW5pdGVseSByZXBlYXRpbmcgYW5pbWF0aW9uc1xyXG5cdFx0XHRcdFx0aWYgKHRoaXMuYXR0cmlidXRlKCdyZXBlYXRDb3VudCcpLnZhbHVlID09ICdpbmRlZmluaXRlJ1xyXG5cdFx0XHRcdFx0IHx8IHRoaXMuYXR0cmlidXRlKCdyZXBlYXREdXInKS52YWx1ZSA9PSAnaW5kZWZpbml0ZScpIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5kdXJhdGlvbiA9IDAuMFxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0ZWxzZSBpZiAodGhpcy5hdHRyaWJ1dGUoJ2ZpbGwnKS52YWx1ZU9yRGVmYXVsdCgncmVtb3ZlJykgPT0gJ2ZyZWV6ZScgJiYgIXRoaXMuZnJvemVuKSB7XHJcblx0XHRcdFx0XHRcdHRoaXMuZnJvemVuID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0dGhpcy5wYXJlbnQuYW5pbWF0aW9uRnJvemVuID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0dGhpcy5wYXJlbnQuYW5pbWF0aW9uRnJvemVuVmFsdWUgPSB0aGlzLmdldFByb3BlcnR5KCkudmFsdWU7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRlbHNlIGlmICh0aGlzLmF0dHJpYnV0ZSgnZmlsbCcpLnZhbHVlT3JEZWZhdWx0KCdyZW1vdmUnKSA9PSAncmVtb3ZlJyAmJiAhdGhpcy5yZW1vdmVkKSB7XHJcblx0XHRcdFx0XHRcdHRoaXMucmVtb3ZlZCA9IHRydWU7XHJcblx0XHRcdFx0XHRcdHRoaXMuZ2V0UHJvcGVydHkoKS52YWx1ZSA9IHRoaXMucGFyZW50LmFuaW1hdGlvbkZyb3plbiA/IHRoaXMucGFyZW50LmFuaW1hdGlvbkZyb3plblZhbHVlIDogdGhpcy5pbml0aWFsVmFsdWU7XHJcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0aGlzLmR1cmF0aW9uID0gdGhpcy5kdXJhdGlvbiArIGRlbHRhO1xyXG5cclxuXHRcdFx0XHQvLyBpZiB3ZSdyZSBwYXN0IHRoZSBiZWdpbiB0aW1lXHJcblx0XHRcdFx0dmFyIHVwZGF0ZWQgPSBmYWxzZTtcclxuXHRcdFx0XHRpZiAodGhpcy5iZWdpbiA8IHRoaXMuZHVyYXRpb24pIHtcclxuXHRcdFx0XHRcdHZhciBuZXdWYWx1ZSA9IHRoaXMuY2FsY1ZhbHVlKCk7IC8vIHR3ZWVuXHJcblxyXG5cdFx0XHRcdFx0aWYgKHRoaXMuYXR0cmlidXRlKCd0eXBlJykuaGFzVmFsdWUoKSkge1xyXG5cdFx0XHRcdFx0XHQvLyBmb3IgdHJhbnNmb3JtLCBldGMuXHJcblx0XHRcdFx0XHRcdHZhciB0eXBlID0gdGhpcy5hdHRyaWJ1dGUoJ3R5cGUnKS52YWx1ZTtcclxuXHRcdFx0XHRcdFx0bmV3VmFsdWUgPSB0eXBlICsgJygnICsgbmV3VmFsdWUgKyAnKSc7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5nZXRQcm9wZXJ0eSgpLnZhbHVlID0gbmV3VmFsdWU7XHJcblx0XHRcdFx0XHR1cGRhdGVkID0gdHJ1ZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVybiB1cGRhdGVkO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmZyb20gPSB0aGlzLmF0dHJpYnV0ZSgnZnJvbScpO1xyXG5cdFx0XHR0aGlzLnRvID0gdGhpcy5hdHRyaWJ1dGUoJ3RvJyk7XHJcblx0XHRcdHRoaXMudmFsdWVzID0gdGhpcy5hdHRyaWJ1dGUoJ3ZhbHVlcycpO1xyXG5cdFx0XHRpZiAodGhpcy52YWx1ZXMuaGFzVmFsdWUoKSkgdGhpcy52YWx1ZXMudmFsdWUgPSB0aGlzLnZhbHVlcy52YWx1ZS5zcGxpdCgnOycpO1xyXG5cclxuXHRcdFx0Ly8gZnJhY3Rpb24gb2YgZHVyYXRpb24gd2UndmUgY292ZXJlZFxyXG5cdFx0XHR0aGlzLnByb2dyZXNzID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0dmFyIHJldCA9IHsgcHJvZ3Jlc3M6ICh0aGlzLmR1cmF0aW9uIC0gdGhpcy5iZWdpbikgLyAodGhpcy5tYXhEdXJhdGlvbiAtIHRoaXMuYmVnaW4pIH07XHJcblx0XHRcdFx0aWYgKHRoaXMudmFsdWVzLmhhc1ZhbHVlKCkpIHtcclxuXHRcdFx0XHRcdHZhciBwID0gcmV0LnByb2dyZXNzICogKHRoaXMudmFsdWVzLnZhbHVlLmxlbmd0aCAtIDEpO1xyXG5cdFx0XHRcdFx0dmFyIGxiID0gTWF0aC5mbG9vcihwKSwgdWIgPSBNYXRoLmNlaWwocCk7XHJcblx0XHRcdFx0XHRyZXQuZnJvbSA9IG5ldyBzdmcuUHJvcGVydHkoJ2Zyb20nLCBwYXJzZUZsb2F0KHRoaXMudmFsdWVzLnZhbHVlW2xiXSkpO1xyXG5cdFx0XHRcdFx0cmV0LnRvID0gbmV3IHN2Zy5Qcm9wZXJ0eSgndG8nLCBwYXJzZUZsb2F0KHRoaXMudmFsdWVzLnZhbHVlW3ViXSkpO1xyXG5cdFx0XHRcdFx0cmV0LnByb2dyZXNzID0gKHAgLSBsYikgLyAodWIgLSBsYik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0cmV0LmZyb20gPSB0aGlzLmZyb207XHJcblx0XHRcdFx0XHRyZXQudG8gPSB0aGlzLnRvO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gcmV0O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRzdmcuRWxlbWVudC5BbmltYXRlQmFzZS5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XHJcblxyXG5cdFx0Ly8gYW5pbWF0ZSBlbGVtZW50XHJcblx0XHRzdmcuRWxlbWVudC5hbmltYXRlID0gZnVuY3Rpb24obm9kZSkge1xyXG5cdFx0XHR0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5BbmltYXRlQmFzZTtcclxuXHRcdFx0dGhpcy5iYXNlKG5vZGUpO1xyXG5cclxuXHRcdFx0dGhpcy5jYWxjVmFsdWUgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHR2YXIgcCA9IHRoaXMucHJvZ3Jlc3MoKTtcclxuXHJcblx0XHRcdFx0Ly8gdHdlZW4gdmFsdWUgbGluZWFybHlcclxuXHRcdFx0XHR2YXIgbmV3VmFsdWUgPSBwLmZyb20ubnVtVmFsdWUoKSArIChwLnRvLm51bVZhbHVlKCkgLSBwLmZyb20ubnVtVmFsdWUoKSkgKiBwLnByb2dyZXNzO1xyXG5cdFx0XHRcdHJldHVybiBuZXdWYWx1ZSArIHRoaXMuaW5pdGlhbFVuaXRzO1xyXG5cdFx0XHR9O1xyXG5cdFx0fVxyXG5cdFx0c3ZnLkVsZW1lbnQuYW5pbWF0ZS5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuQW5pbWF0ZUJhc2U7XHJcblxyXG5cdFx0Ly8gYW5pbWF0ZSBjb2xvciBlbGVtZW50XHJcblx0XHRzdmcuRWxlbWVudC5hbmltYXRlQ29sb3IgPSBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LkFuaW1hdGVCYXNlO1xyXG5cdFx0XHR0aGlzLmJhc2Uobm9kZSk7XHJcblxyXG5cdFx0XHR0aGlzLmNhbGNWYWx1ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHZhciBwID0gdGhpcy5wcm9ncmVzcygpO1xyXG5cdFx0XHRcdHZhciBmcm9tID0gbmV3IFJHQkNvbG9yKHAuZnJvbS52YWx1ZSk7XHJcblx0XHRcdFx0dmFyIHRvID0gbmV3IFJHQkNvbG9yKHAudG8udmFsdWUpO1xyXG5cclxuXHRcdFx0XHRpZiAoZnJvbS5vayAmJiB0by5vaykge1xyXG5cdFx0XHRcdFx0Ly8gdHdlZW4gY29sb3IgbGluZWFybHlcclxuXHRcdFx0XHRcdHZhciByID0gZnJvbS5yICsgKHRvLnIgLSBmcm9tLnIpICogcC5wcm9ncmVzcztcclxuXHRcdFx0XHRcdHZhciBnID0gZnJvbS5nICsgKHRvLmcgLSBmcm9tLmcpICogcC5wcm9ncmVzcztcclxuXHRcdFx0XHRcdHZhciBiID0gZnJvbS5iICsgKHRvLmIgLSBmcm9tLmIpICogcC5wcm9ncmVzcztcclxuXHRcdFx0XHRcdHJldHVybiAncmdiKCcrcGFyc2VJbnQociwxMCkrJywnK3BhcnNlSW50KGcsMTApKycsJytwYXJzZUludChiLDEwKSsnKSc7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiB0aGlzLmF0dHJpYnV0ZSgnZnJvbScpLnZhbHVlO1xyXG5cdFx0XHR9O1xyXG5cdFx0fVxyXG5cdFx0c3ZnLkVsZW1lbnQuYW5pbWF0ZUNvbG9yLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5BbmltYXRlQmFzZTtcclxuXHJcblx0XHQvLyBhbmltYXRlIHRyYW5zZm9ybSBlbGVtZW50XHJcblx0XHRzdmcuRWxlbWVudC5hbmltYXRlVHJhbnNmb3JtID0gZnVuY3Rpb24obm9kZSkge1xyXG5cdFx0XHR0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5BbmltYXRlQmFzZTtcclxuXHRcdFx0dGhpcy5iYXNlKG5vZGUpO1xyXG5cclxuXHRcdFx0dGhpcy5jYWxjVmFsdWUgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHR2YXIgcCA9IHRoaXMucHJvZ3Jlc3MoKTtcclxuXHJcblx0XHRcdFx0Ly8gdHdlZW4gdmFsdWUgbGluZWFybHlcclxuXHRcdFx0XHR2YXIgZnJvbSA9IHN2Zy5Ub051bWJlckFycmF5KHAuZnJvbS52YWx1ZSk7XHJcblx0XHRcdFx0dmFyIHRvID0gc3ZnLlRvTnVtYmVyQXJyYXkocC50by52YWx1ZSk7XHJcblx0XHRcdFx0dmFyIG5ld1ZhbHVlID0gJyc7XHJcblx0XHRcdFx0Zm9yICh2YXIgaT0wOyBpPGZyb20ubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdG5ld1ZhbHVlICs9IGZyb21baV0gKyAodG9baV0gLSBmcm9tW2ldKSAqIHAucHJvZ3Jlc3MgKyAnICc7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiBuZXdWYWx1ZTtcclxuXHRcdFx0fTtcclxuXHRcdH1cclxuXHRcdHN2Zy5FbGVtZW50LmFuaW1hdGVUcmFuc2Zvcm0ucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LmFuaW1hdGU7XHJcblxyXG5cdFx0Ly8gZm9udCBlbGVtZW50XHJcblx0XHRzdmcuRWxlbWVudC5mb250ID0gZnVuY3Rpb24obm9kZSkge1xyXG5cdFx0XHR0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcclxuXHRcdFx0dGhpcy5iYXNlKG5vZGUpO1xyXG5cclxuXHRcdFx0dGhpcy5ob3JpekFkdlggPSB0aGlzLmF0dHJpYnV0ZSgnaG9yaXotYWR2LXgnKS5udW1WYWx1ZSgpO1xyXG5cclxuXHRcdFx0dGhpcy5pc1JUTCA9IGZhbHNlO1xyXG5cdFx0XHR0aGlzLmlzQXJhYmljID0gZmFsc2U7XHJcblx0XHRcdHRoaXMuZm9udEZhY2UgPSBudWxsO1xyXG5cdFx0XHR0aGlzLm1pc3NpbmdHbHlwaCA9IG51bGw7XHJcblx0XHRcdHRoaXMuZ2x5cGhzID0gW107XHJcblx0XHRcdGZvciAodmFyIGk9MDsgaTx0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0dmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcclxuXHRcdFx0XHRpZiAoY2hpbGQudHlwZSA9PSAnZm9udC1mYWNlJykge1xyXG5cdFx0XHRcdFx0dGhpcy5mb250RmFjZSA9IGNoaWxkO1xyXG5cdFx0XHRcdFx0aWYgKGNoaWxkLnN0eWxlKCdmb250LWZhbWlseScpLmhhc1ZhbHVlKCkpIHtcclxuXHRcdFx0XHRcdFx0c3ZnLkRlZmluaXRpb25zW2NoaWxkLnN0eWxlKCdmb250LWZhbWlseScpLnZhbHVlXSA9IHRoaXM7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2UgaWYgKGNoaWxkLnR5cGUgPT0gJ21pc3NpbmctZ2x5cGgnKSB0aGlzLm1pc3NpbmdHbHlwaCA9IGNoaWxkO1xyXG5cdFx0XHRcdGVsc2UgaWYgKGNoaWxkLnR5cGUgPT0gJ2dseXBoJykge1xyXG5cdFx0XHRcdFx0aWYgKGNoaWxkLmFyYWJpY0Zvcm0gIT0gJycpIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5pc1JUTCA9IHRydWU7XHJcblx0XHRcdFx0XHRcdHRoaXMuaXNBcmFiaWMgPSB0cnVlO1xyXG5cdFx0XHRcdFx0XHRpZiAodHlwZW9mIHRoaXMuZ2x5cGhzW2NoaWxkLnVuaWNvZGVdID09ICd1bmRlZmluZWQnKSB0aGlzLmdseXBoc1tjaGlsZC51bmljb2RlXSA9IFtdO1xyXG5cdFx0XHRcdFx0XHR0aGlzLmdseXBoc1tjaGlsZC51bmljb2RlXVtjaGlsZC5hcmFiaWNGb3JtXSA9IGNoaWxkO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRcdHRoaXMuZ2x5cGhzW2NoaWxkLnVuaWNvZGVdID0gY2hpbGQ7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRzdmcuRWxlbWVudC5mb250LnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcclxuXHJcblx0XHQvLyBmb250LWZhY2UgZWxlbWVudFxyXG5cdFx0c3ZnLkVsZW1lbnQuZm9udGZhY2UgPSBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xyXG5cdFx0XHR0aGlzLmJhc2Uobm9kZSk7XHJcblxyXG5cdFx0XHR0aGlzLmFzY2VudCA9IHRoaXMuYXR0cmlidXRlKCdhc2NlbnQnKS52YWx1ZTtcclxuXHRcdFx0dGhpcy5kZXNjZW50ID0gdGhpcy5hdHRyaWJ1dGUoJ2Rlc2NlbnQnKS52YWx1ZTtcclxuXHRcdFx0dGhpcy51bml0c1BlckVtID0gdGhpcy5hdHRyaWJ1dGUoJ3VuaXRzLXBlci1lbScpLm51bVZhbHVlKCk7XHJcblx0XHR9XHJcblx0XHRzdmcuRWxlbWVudC5mb250ZmFjZS5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XHJcblxyXG5cdFx0Ly8gbWlzc2luZy1nbHlwaCBlbGVtZW50XHJcblx0XHRzdmcuRWxlbWVudC5taXNzaW5nZ2x5cGggPSBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LnBhdGg7XHJcblx0XHRcdHRoaXMuYmFzZShub2RlKTtcclxuXHJcblx0XHRcdHRoaXMuaG9yaXpBZHZYID0gMDtcclxuXHRcdH1cclxuXHRcdHN2Zy5FbGVtZW50Lm1pc3NpbmdnbHlwaC5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQucGF0aDtcclxuXHJcblx0XHQvLyBnbHlwaCBlbGVtZW50XHJcblx0XHRzdmcuRWxlbWVudC5nbHlwaCA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdFx0dGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQucGF0aDtcclxuXHRcdFx0dGhpcy5iYXNlKG5vZGUpO1xyXG5cclxuXHRcdFx0dGhpcy5ob3JpekFkdlggPSB0aGlzLmF0dHJpYnV0ZSgnaG9yaXotYWR2LXgnKS5udW1WYWx1ZSgpO1xyXG5cdFx0XHR0aGlzLnVuaWNvZGUgPSB0aGlzLmF0dHJpYnV0ZSgndW5pY29kZScpLnZhbHVlO1xyXG5cdFx0XHR0aGlzLmFyYWJpY0Zvcm0gPSB0aGlzLmF0dHJpYnV0ZSgnYXJhYmljLWZvcm0nKS52YWx1ZTtcclxuXHRcdH1cclxuXHRcdHN2Zy5FbGVtZW50LmdseXBoLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5wYXRoO1xyXG5cclxuXHRcdC8vIHRleHQgZWxlbWVudFxyXG5cdFx0c3ZnLkVsZW1lbnQudGV4dCA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdFx0dGhpcy5jYXB0dXJlVGV4dE5vZGVzID0gdHJ1ZTtcclxuXHRcdFx0dGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuUmVuZGVyZWRFbGVtZW50QmFzZTtcclxuXHRcdFx0dGhpcy5iYXNlKG5vZGUpO1xyXG5cclxuXHRcdFx0dGhpcy5iYXNlU2V0Q29udGV4dCA9IHRoaXMuc2V0Q29udGV4dDtcclxuXHRcdFx0dGhpcy5zZXRDb250ZXh0ID0gZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdFx0dGhpcy5iYXNlU2V0Q29udGV4dChjdHgpO1xyXG5cclxuXHRcdFx0XHR2YXIgdGV4dEJhc2VsaW5lID0gdGhpcy5zdHlsZSgnZG9taW5hbnQtYmFzZWxpbmUnKS50b1RleHRCYXNlbGluZSgpO1xyXG5cdFx0XHRcdGlmICh0ZXh0QmFzZWxpbmUgPT0gbnVsbCkgdGV4dEJhc2VsaW5lID0gdGhpcy5zdHlsZSgnYWxpZ25tZW50LWJhc2VsaW5lJykudG9UZXh0QmFzZWxpbmUoKTtcclxuXHRcdFx0XHRpZiAodGV4dEJhc2VsaW5lICE9IG51bGwpIGN0eC50ZXh0QmFzZWxpbmUgPSB0ZXh0QmFzZWxpbmU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuZ2V0Qm91bmRpbmdCb3ggPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdFx0dmFyIHggPSB0aGlzLmF0dHJpYnV0ZSgneCcpLnRvUGl4ZWxzKCd4Jyk7XHJcblx0XHRcdFx0dmFyIHkgPSB0aGlzLmF0dHJpYnV0ZSgneScpLnRvUGl4ZWxzKCd5Jyk7XHJcblx0XHRcdFx0dmFyIGZvbnRTaXplID0gdGhpcy5wYXJlbnQuc3R5bGUoJ2ZvbnQtc2l6ZScpLm51bVZhbHVlT3JEZWZhdWx0KHN2Zy5Gb250LlBhcnNlKHN2Zy5jdHguZm9udCkuZm9udFNpemUpO1xyXG5cdFx0XHRcdHJldHVybiBuZXcgc3ZnLkJvdW5kaW5nQm94KHgsIHkgLSBmb250U2l6ZSwgeCArIE1hdGguZmxvb3IoZm9udFNpemUgKiAyLjAgLyAzLjApICogdGhpcy5jaGlsZHJlblswXS5nZXRUZXh0KCkubGVuZ3RoLCB5KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5yZW5kZXJDaGlsZHJlbiA9IGZ1bmN0aW9uKGN0eCkge1xyXG5cdFx0XHRcdHRoaXMueCA9IHRoaXMuYXR0cmlidXRlKCd4JykudG9QaXhlbHMoJ3gnKTtcclxuXHRcdFx0XHR0aGlzLnkgPSB0aGlzLmF0dHJpYnV0ZSgneScpLnRvUGl4ZWxzKCd5Jyk7XHJcblx0XHRcdFx0aWYgKHRoaXMuYXR0cmlidXRlKCdkeCcpLmhhc1ZhbHVlKCkpIHRoaXMueCArPSB0aGlzLmF0dHJpYnV0ZSgnZHgnKS50b1BpeGVscygneCcpO1xyXG5cdFx0XHRcdGlmICh0aGlzLmF0dHJpYnV0ZSgnZHknKS5oYXNWYWx1ZSgpKSB0aGlzLnkgKz0gdGhpcy5hdHRyaWJ1dGUoJ2R5JykudG9QaXhlbHMoJ3knKTtcclxuXHRcdFx0XHR0aGlzLnggKz0gdGhpcy5nZXRBbmNob3JEZWx0YShjdHgsIHRoaXMsIDApO1xyXG5cdFx0XHRcdGZvciAodmFyIGk9MDsgaTx0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHR0aGlzLnJlbmRlckNoaWxkKGN0eCwgdGhpcywgdGhpcywgaSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmdldEFuY2hvckRlbHRhID0gZnVuY3Rpb24gKGN0eCwgcGFyZW50LCBzdGFydEkpIHtcclxuXHRcdFx0XHR2YXIgdGV4dEFuY2hvciA9IHRoaXMuc3R5bGUoJ3RleHQtYW5jaG9yJykudmFsdWVPckRlZmF1bHQoJ3N0YXJ0Jyk7XHJcblx0XHRcdFx0aWYgKHRleHRBbmNob3IgIT0gJ3N0YXJ0Jykge1xyXG5cdFx0XHRcdFx0dmFyIHdpZHRoID0gMDtcclxuXHRcdFx0XHRcdGZvciAodmFyIGk9c3RhcnRJOyBpPHBhcmVudC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0XHR2YXIgY2hpbGQgPSBwYXJlbnQuY2hpbGRyZW5baV07XHJcblx0XHRcdFx0XHRcdGlmIChpID4gc3RhcnRJICYmIGNoaWxkLmF0dHJpYnV0ZSgneCcpLmhhc1ZhbHVlKCkpIGJyZWFrOyAvLyBuZXcgZ3JvdXBcclxuXHRcdFx0XHRcdFx0d2lkdGggKz0gY2hpbGQubWVhc3VyZVRleHRSZWN1cnNpdmUoY3R4KTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHJldHVybiAtMSAqICh0ZXh0QW5jaG9yID09ICdlbmQnID8gd2lkdGggOiB3aWR0aCAvIDIuMCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiAwO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLnJlbmRlckNoaWxkID0gZnVuY3Rpb24oY3R4LCB0ZXh0UGFyZW50LCBwYXJlbnQsIGkpIHtcclxuXHRcdFx0XHR2YXIgY2hpbGQgPSBwYXJlbnQuY2hpbGRyZW5baV07XHJcblx0XHRcdFx0aWYgKGNoaWxkLmF0dHJpYnV0ZSgneCcpLmhhc1ZhbHVlKCkpIHtcclxuXHRcdFx0XHRcdGNoaWxkLnggPSBjaGlsZC5hdHRyaWJ1dGUoJ3gnKS50b1BpeGVscygneCcpICsgdGV4dFBhcmVudC5nZXRBbmNob3JEZWx0YShjdHgsIHBhcmVudCwgaSk7XHJcblx0XHRcdFx0XHRpZiAoY2hpbGQuYXR0cmlidXRlKCdkeCcpLmhhc1ZhbHVlKCkpIGNoaWxkLnggKz0gY2hpbGQuYXR0cmlidXRlKCdkeCcpLnRvUGl4ZWxzKCd4Jyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0aWYgKGNoaWxkLmF0dHJpYnV0ZSgnZHgnKS5oYXNWYWx1ZSgpKSB0ZXh0UGFyZW50LnggKz0gY2hpbGQuYXR0cmlidXRlKCdkeCcpLnRvUGl4ZWxzKCd4Jyk7XHJcblx0XHRcdFx0XHRjaGlsZC54ID0gdGV4dFBhcmVudC54O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0ZXh0UGFyZW50LnggPSBjaGlsZC54ICsgY2hpbGQubWVhc3VyZVRleHQoY3R4KTtcclxuXHJcblx0XHRcdFx0aWYgKGNoaWxkLmF0dHJpYnV0ZSgneScpLmhhc1ZhbHVlKCkpIHtcclxuXHRcdFx0XHRcdGNoaWxkLnkgPSBjaGlsZC5hdHRyaWJ1dGUoJ3knKS50b1BpeGVscygneScpO1xyXG5cdFx0XHRcdFx0aWYgKGNoaWxkLmF0dHJpYnV0ZSgnZHknKS5oYXNWYWx1ZSgpKSBjaGlsZC55ICs9IGNoaWxkLmF0dHJpYnV0ZSgnZHknKS50b1BpeGVscygneScpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdGlmIChjaGlsZC5hdHRyaWJ1dGUoJ2R5JykuaGFzVmFsdWUoKSkgdGV4dFBhcmVudC55ICs9IGNoaWxkLmF0dHJpYnV0ZSgnZHknKS50b1BpeGVscygneScpO1xyXG5cdFx0XHRcdFx0Y2hpbGQueSA9IHRleHRQYXJlbnQueTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dGV4dFBhcmVudC55ID0gY2hpbGQueTtcclxuXHJcblx0XHRcdFx0Y2hpbGQucmVuZGVyKGN0eCk7XHJcblxyXG5cdFx0XHRcdGZvciAodmFyIGk9MDsgaTxjaGlsZC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0dGV4dFBhcmVudC5yZW5kZXJDaGlsZChjdHgsIHRleHRQYXJlbnQsIGNoaWxkLCBpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHN2Zy5FbGVtZW50LnRleHQucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LlJlbmRlcmVkRWxlbWVudEJhc2U7XHJcblxyXG5cdFx0Ly8gdGV4dCBiYXNlXHJcblx0XHRzdmcuRWxlbWVudC5UZXh0RWxlbWVudEJhc2UgPSBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LlJlbmRlcmVkRWxlbWVudEJhc2U7XHJcblx0XHRcdHRoaXMuYmFzZShub2RlKTtcclxuXHJcblx0XHRcdHRoaXMuZ2V0R2x5cGggPSBmdW5jdGlvbihmb250LCB0ZXh0LCBpKSB7XHJcblx0XHRcdFx0dmFyIGMgPSB0ZXh0W2ldO1xyXG5cdFx0XHRcdHZhciBnbHlwaCA9IG51bGw7XHJcblx0XHRcdFx0aWYgKGZvbnQuaXNBcmFiaWMpIHtcclxuXHRcdFx0XHRcdHZhciBhcmFiaWNGb3JtID0gJ2lzb2xhdGVkJztcclxuXHRcdFx0XHRcdGlmICgoaT09MCB8fCB0ZXh0W2ktMV09PScgJykgJiYgaTx0ZXh0Lmxlbmd0aC0yICYmIHRleHRbaSsxXSE9JyAnKSBhcmFiaWNGb3JtID0gJ3Rlcm1pbmFsJztcclxuXHRcdFx0XHRcdGlmIChpPjAgJiYgdGV4dFtpLTFdIT0nICcgJiYgaTx0ZXh0Lmxlbmd0aC0yICYmIHRleHRbaSsxXSE9JyAnKSBhcmFiaWNGb3JtID0gJ21lZGlhbCc7XHJcblx0XHRcdFx0XHRpZiAoaT4wICYmIHRleHRbaS0xXSE9JyAnICYmIChpID09IHRleHQubGVuZ3RoLTEgfHwgdGV4dFtpKzFdPT0nICcpKSBhcmFiaWNGb3JtID0gJ2luaXRpYWwnO1xyXG5cdFx0XHRcdFx0aWYgKHR5cGVvZiBmb250LmdseXBoc1tjXSAhPSAndW5kZWZpbmVkJykge1xyXG5cdFx0XHRcdFx0XHRnbHlwaCA9IGZvbnQuZ2x5cGhzW2NdW2FyYWJpY0Zvcm1dO1xyXG5cdFx0XHRcdFx0XHRpZiAoZ2x5cGggPT0gbnVsbCAmJiBmb250LmdseXBoc1tjXS50eXBlID09ICdnbHlwaCcpIGdseXBoID0gZm9udC5nbHlwaHNbY107XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0Z2x5cGggPSBmb250LmdseXBoc1tjXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYgKGdseXBoID09IG51bGwpIGdseXBoID0gZm9udC5taXNzaW5nR2x5cGg7XHJcblx0XHRcdFx0cmV0dXJuIGdseXBoO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLnJlbmRlckNoaWxkcmVuID0gZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdFx0dmFyIGN1c3RvbUZvbnQgPSB0aGlzLnBhcmVudC5zdHlsZSgnZm9udC1mYW1pbHknKS5nZXREZWZpbml0aW9uKCk7XHJcblx0XHRcdFx0aWYgKGN1c3RvbUZvbnQgIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0dmFyIGZvbnRTaXplID0gdGhpcy5wYXJlbnQuc3R5bGUoJ2ZvbnQtc2l6ZScpLm51bVZhbHVlT3JEZWZhdWx0KHN2Zy5Gb250LlBhcnNlKHN2Zy5jdHguZm9udCkuZm9udFNpemUpO1xyXG5cdFx0XHRcdFx0dmFyIGZvbnRTdHlsZSA9IHRoaXMucGFyZW50LnN0eWxlKCdmb250LXN0eWxlJykudmFsdWVPckRlZmF1bHQoc3ZnLkZvbnQuUGFyc2Uoc3ZnLmN0eC5mb250KS5mb250U3R5bGUpO1xyXG5cdFx0XHRcdFx0dmFyIHRleHQgPSB0aGlzLmdldFRleHQoKTtcclxuXHRcdFx0XHRcdGlmIChjdXN0b21Gb250LmlzUlRMKSB0ZXh0ID0gdGV4dC5zcGxpdChcIlwiKS5yZXZlcnNlKCkuam9pbihcIlwiKTtcclxuXHJcblx0XHRcdFx0XHR2YXIgZHggPSBzdmcuVG9OdW1iZXJBcnJheSh0aGlzLnBhcmVudC5hdHRyaWJ1dGUoJ2R4JykudmFsdWUpO1xyXG5cdFx0XHRcdFx0Zm9yICh2YXIgaT0wOyBpPHRleHQubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdFx0dmFyIGdseXBoID0gdGhpcy5nZXRHbHlwaChjdXN0b21Gb250LCB0ZXh0LCBpKTtcclxuXHRcdFx0XHRcdFx0dmFyIHNjYWxlID0gZm9udFNpemUgLyBjdXN0b21Gb250LmZvbnRGYWNlLnVuaXRzUGVyRW07XHJcblx0XHRcdFx0XHRcdGN0eC50cmFuc2xhdGUodGhpcy54LCB0aGlzLnkpO1xyXG5cdFx0XHRcdFx0XHRjdHguc2NhbGUoc2NhbGUsIC1zY2FsZSk7XHJcblx0XHRcdFx0XHRcdHZhciBsdyA9IGN0eC5saW5lV2lkdGg7XHJcblx0XHRcdFx0XHRcdGN0eC5saW5lV2lkdGggPSBjdHgubGluZVdpZHRoICogY3VzdG9tRm9udC5mb250RmFjZS51bml0c1BlckVtIC8gZm9udFNpemU7XHJcblx0XHRcdFx0XHRcdGlmIChmb250U3R5bGUgPT0gJ2l0YWxpYycpIGN0eC50cmFuc2Zvcm0oMSwgMCwgLjQsIDEsIDAsIDApO1xyXG5cdFx0XHRcdFx0XHRnbHlwaC5yZW5kZXIoY3R4KTtcclxuXHRcdFx0XHRcdFx0aWYgKGZvbnRTdHlsZSA9PSAnaXRhbGljJykgY3R4LnRyYW5zZm9ybSgxLCAwLCAtLjQsIDEsIDAsIDApO1xyXG5cdFx0XHRcdFx0XHRjdHgubGluZVdpZHRoID0gbHc7XHJcblx0XHRcdFx0XHRcdGN0eC5zY2FsZSgxL3NjYWxlLCAtMS9zY2FsZSk7XHJcblx0XHRcdFx0XHRcdGN0eC50cmFuc2xhdGUoLXRoaXMueCwgLXRoaXMueSk7XHJcblxyXG5cdFx0XHRcdFx0XHR0aGlzLnggKz0gZm9udFNpemUgKiAoZ2x5cGguaG9yaXpBZHZYIHx8IGN1c3RvbUZvbnQuaG9yaXpBZHZYKSAvIGN1c3RvbUZvbnQuZm9udEZhY2UudW5pdHNQZXJFbTtcclxuXHRcdFx0XHRcdFx0aWYgKHR5cGVvZiBkeFtpXSAhPSAndW5kZWZpbmVkJyAmJiAhaXNOYU4oZHhbaV0pKSB7XHJcblx0XHRcdFx0XHRcdFx0dGhpcy54ICs9IGR4W2ldO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoY3R4LmZpbGxTdHlsZSAhPSAnJykgY3R4LmZpbGxUZXh0KHN2Zy5jb21wcmVzc1NwYWNlcyh0aGlzLmdldFRleHQoKSksIHRoaXMueCwgdGhpcy55KTtcclxuXHRcdFx0XHRpZiAoY3R4LnN0cm9rZVN0eWxlICE9ICcnKSBjdHguc3Ryb2tlVGV4dChzdmcuY29tcHJlc3NTcGFjZXModGhpcy5nZXRUZXh0KCkpLCB0aGlzLngsIHRoaXMueSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuZ2V0VGV4dCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdC8vIE9WRVJSSURFIE1FXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMubWVhc3VyZVRleHRSZWN1cnNpdmUgPSBmdW5jdGlvbihjdHgpIHtcclxuXHRcdFx0XHR2YXIgd2lkdGggPSB0aGlzLm1lYXN1cmVUZXh0KGN0eCk7XHJcblx0XHRcdFx0Zm9yICh2YXIgaT0wOyBpPHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdHdpZHRoICs9IHRoaXMuY2hpbGRyZW5baV0ubWVhc3VyZVRleHRSZWN1cnNpdmUoY3R4KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIHdpZHRoO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLm1lYXN1cmVUZXh0ID0gZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdFx0dmFyIGN1c3RvbUZvbnQgPSB0aGlzLnBhcmVudC5zdHlsZSgnZm9udC1mYW1pbHknKS5nZXREZWZpbml0aW9uKCk7XHJcblx0XHRcdFx0aWYgKGN1c3RvbUZvbnQgIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0dmFyIGZvbnRTaXplID0gdGhpcy5wYXJlbnQuc3R5bGUoJ2ZvbnQtc2l6ZScpLm51bVZhbHVlT3JEZWZhdWx0KHN2Zy5Gb250LlBhcnNlKHN2Zy5jdHguZm9udCkuZm9udFNpemUpO1xyXG5cdFx0XHRcdFx0dmFyIG1lYXN1cmUgPSAwO1xyXG5cdFx0XHRcdFx0dmFyIHRleHQgPSB0aGlzLmdldFRleHQoKTtcclxuXHRcdFx0XHRcdGlmIChjdXN0b21Gb250LmlzUlRMKSB0ZXh0ID0gdGV4dC5zcGxpdChcIlwiKS5yZXZlcnNlKCkuam9pbihcIlwiKTtcclxuXHRcdFx0XHRcdHZhciBkeCA9IHN2Zy5Ub051bWJlckFycmF5KHRoaXMucGFyZW50LmF0dHJpYnV0ZSgnZHgnKS52YWx1ZSk7XHJcblx0XHRcdFx0XHRmb3IgKHZhciBpPTA7IGk8dGV4dC5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0XHR2YXIgZ2x5cGggPSB0aGlzLmdldEdseXBoKGN1c3RvbUZvbnQsIHRleHQsIGkpO1xyXG5cdFx0XHRcdFx0XHRtZWFzdXJlICs9IChnbHlwaC5ob3JpekFkdlggfHwgY3VzdG9tRm9udC5ob3JpekFkdlgpICogZm9udFNpemUgLyBjdXN0b21Gb250LmZvbnRGYWNlLnVuaXRzUGVyRW07XHJcblx0XHRcdFx0XHRcdGlmICh0eXBlb2YgZHhbaV0gIT0gJ3VuZGVmaW5lZCcgJiYgIWlzTmFOKGR4W2ldKSkge1xyXG5cdFx0XHRcdFx0XHRcdG1lYXN1cmUgKz0gZHhbaV07XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHJldHVybiBtZWFzdXJlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dmFyIHRleHRUb01lYXN1cmUgPSBzdmcuY29tcHJlc3NTcGFjZXModGhpcy5nZXRUZXh0KCkpO1xyXG5cdFx0XHRcdGlmICghY3R4Lm1lYXN1cmVUZXh0KSByZXR1cm4gdGV4dFRvTWVhc3VyZS5sZW5ndGggKiAxMDtcclxuXHJcblx0XHRcdFx0Y3R4LnNhdmUoKTtcclxuXHRcdFx0XHR0aGlzLnNldENvbnRleHQoY3R4KTtcclxuXHRcdFx0XHR2YXIgd2lkdGggPSBjdHgubWVhc3VyZVRleHQodGV4dFRvTWVhc3VyZSkud2lkdGg7XHJcblx0XHRcdFx0Y3R4LnJlc3RvcmUoKTtcclxuXHRcdFx0XHRyZXR1cm4gd2lkdGg7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHN2Zy5FbGVtZW50LlRleHRFbGVtZW50QmFzZS5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuUmVuZGVyZWRFbGVtZW50QmFzZTtcclxuXHJcblx0XHQvLyB0c3BhblxyXG5cdFx0c3ZnLkVsZW1lbnQudHNwYW4gPSBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHRoaXMuY2FwdHVyZVRleHROb2RlcyA9IHRydWU7XHJcblx0XHRcdHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LlRleHRFbGVtZW50QmFzZTtcclxuXHRcdFx0dGhpcy5iYXNlKG5vZGUpO1xyXG5cclxuXHRcdFx0dGhpcy50ZXh0ID0gc3ZnLmNvbXByZXNzU3BhY2VzKG5vZGUudmFsdWUgfHwgbm9kZS50ZXh0IHx8IG5vZGUudGV4dENvbnRlbnQgfHwgJycpO1xyXG5cdFx0XHR0aGlzLmdldFRleHQgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHQvLyBpZiB0aGlzIG5vZGUgaGFzIGNoaWxkcmVuLCB0aGVuIHRoZXkgb3duIHRoZSB0ZXh0XHJcblx0XHRcdFx0aWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID4gMCkgeyByZXR1cm4gJyc7IH1cclxuXHRcdFx0XHRyZXR1cm4gdGhpcy50ZXh0O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRzdmcuRWxlbWVudC50c3Bhbi5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuVGV4dEVsZW1lbnRCYXNlO1xyXG5cclxuXHRcdC8vIHRyZWZcclxuXHRcdHN2Zy5FbGVtZW50LnRyZWYgPSBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LlRleHRFbGVtZW50QmFzZTtcclxuXHRcdFx0dGhpcy5iYXNlKG5vZGUpO1xyXG5cclxuXHRcdFx0dGhpcy5nZXRUZXh0ID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0dmFyIGVsZW1lbnQgPSB0aGlzLmdldEhyZWZBdHRyaWJ1dGUoKS5nZXREZWZpbml0aW9uKCk7XHJcblx0XHRcdFx0aWYgKGVsZW1lbnQgIT0gbnVsbCkgcmV0dXJuIGVsZW1lbnQuY2hpbGRyZW5bMF0uZ2V0VGV4dCgpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRzdmcuRWxlbWVudC50cmVmLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5UZXh0RWxlbWVudEJhc2U7XHJcblxyXG5cdFx0Ly8gYSBlbGVtZW50XHJcblx0XHRzdmcuRWxlbWVudC5hID0gZnVuY3Rpb24obm9kZSkge1xyXG5cdFx0XHR0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5UZXh0RWxlbWVudEJhc2U7XHJcblx0XHRcdHRoaXMuYmFzZShub2RlKTtcclxuXHJcblx0XHRcdHRoaXMuaGFzVGV4dCA9IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPiAwO1xyXG5cdFx0XHRmb3IgKHZhciBpPTA7IGk8bm9kZS5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0aWYgKG5vZGUuY2hpbGROb2Rlc1tpXS5ub2RlVHlwZSAhPSAzKSB0aGlzLmhhc1RleHQgPSBmYWxzZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gdGhpcyBtaWdodCBjb250YWluIHRleHRcclxuXHRcdFx0dGhpcy50ZXh0ID0gdGhpcy5oYXNUZXh0ID8gbm9kZS5jaGlsZE5vZGVzWzBdLnZhbHVlIDogJyc7XHJcblx0XHRcdHRoaXMuZ2V0VGV4dCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLnRleHQ7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuYmFzZVJlbmRlckNoaWxkcmVuID0gdGhpcy5yZW5kZXJDaGlsZHJlbjtcclxuXHRcdFx0dGhpcy5yZW5kZXJDaGlsZHJlbiA9IGZ1bmN0aW9uKGN0eCkge1xyXG5cdFx0XHRcdGlmICh0aGlzLmhhc1RleHQpIHtcclxuXHRcdFx0XHRcdC8vIHJlbmRlciBhcyB0ZXh0IGVsZW1lbnRcclxuXHRcdFx0XHRcdHRoaXMuYmFzZVJlbmRlckNoaWxkcmVuKGN0eCk7XHJcblx0XHRcdFx0XHR2YXIgZm9udFNpemUgPSBuZXcgc3ZnLlByb3BlcnR5KCdmb250U2l6ZScsIHN2Zy5Gb250LlBhcnNlKHN2Zy5jdHguZm9udCkuZm9udFNpemUpO1xyXG5cdFx0XHRcdFx0c3ZnLk1vdXNlLmNoZWNrQm91bmRpbmdCb3godGhpcywgbmV3IHN2Zy5Cb3VuZGluZ0JveCh0aGlzLngsIHRoaXMueSAtIGZvbnRTaXplLnRvUGl4ZWxzKCd5JyksIHRoaXMueCArIHRoaXMubWVhc3VyZVRleHQoY3R4KSwgdGhpcy55KSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2UgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xyXG5cdFx0XHRcdFx0Ly8gcmVuZGVyIGFzIHRlbXBvcmFyeSBncm91cFxyXG5cdFx0XHRcdFx0dmFyIGcgPSBuZXcgc3ZnLkVsZW1lbnQuZygpO1xyXG5cdFx0XHRcdFx0Zy5jaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XHJcblx0XHRcdFx0XHRnLnBhcmVudCA9IHRoaXM7XHJcblx0XHRcdFx0XHRnLnJlbmRlcihjdHgpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5vbmNsaWNrID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0d2luZG93Lm9wZW4odGhpcy5nZXRIcmVmQXR0cmlidXRlKCkudmFsdWUpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLm9ubW91c2Vtb3ZlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0c3ZnLmN0eC5jYW52YXMuc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRzdmcuRWxlbWVudC5hLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5UZXh0RWxlbWVudEJhc2U7XHJcblxyXG5cdFx0Ly8gaW1hZ2UgZWxlbWVudFxyXG5cdFx0c3ZnLkVsZW1lbnQuaW1hZ2UgPSBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LlJlbmRlcmVkRWxlbWVudEJhc2U7XHJcblx0XHRcdHRoaXMuYmFzZShub2RlKTtcclxuXHJcblx0XHRcdHZhciBocmVmID0gdGhpcy5nZXRIcmVmQXR0cmlidXRlKCkudmFsdWU7XHJcblx0XHRcdGlmIChocmVmID09ICcnKSB7IHJldHVybjsgfVxyXG5cdFx0XHR2YXIgaXNTdmcgPSBocmVmLm1hdGNoKC9cXC5zdmckLylcclxuXHJcblx0XHRcdHN2Zy5JbWFnZXMucHVzaCh0aGlzKTtcclxuXHRcdFx0dGhpcy5sb2FkZWQgPSBmYWxzZTtcclxuXHRcdFx0aWYgKCFpc1N2Zykge1xyXG5cdFx0XHRcdHRoaXMuaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XHJcblx0XHRcdFx0aWYgKHN2Zy5vcHRzWyd1c2VDT1JTJ10gPT0gdHJ1ZSkgeyB0aGlzLmltZy5jcm9zc09yaWdpbiA9ICdBbm9ueW1vdXMnOyB9XHJcblx0XHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xyXG5cdFx0XHRcdHRoaXMuaW1nLm9ubG9hZCA9IGZ1bmN0aW9uKCkgeyBzZWxmLmxvYWRlZCA9IHRydWU7IH1cclxuXHRcdFx0XHR0aGlzLmltZy5vbmVycm9yID0gZnVuY3Rpb24oKSB7IHN2Zy5sb2coJ0VSUk9SOiBpbWFnZSBcIicgKyBocmVmICsgJ1wiIG5vdCBmb3VuZCcpOyBzZWxmLmxvYWRlZCA9IHRydWU7IH1cclxuXHRcdFx0XHR0aGlzLmltZy5zcmMgPSBocmVmO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdHRoaXMuaW1nID0gc3ZnLmFqYXgoaHJlZik7XHJcblx0XHRcdFx0dGhpcy5sb2FkZWQgPSB0cnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLnJlbmRlckNoaWxkcmVuID0gZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdFx0dmFyIHggPSB0aGlzLmF0dHJpYnV0ZSgneCcpLnRvUGl4ZWxzKCd4Jyk7XHJcblx0XHRcdFx0dmFyIHkgPSB0aGlzLmF0dHJpYnV0ZSgneScpLnRvUGl4ZWxzKCd5Jyk7XHJcblxyXG5cdFx0XHRcdHZhciB3aWR0aCA9IHRoaXMuYXR0cmlidXRlKCd3aWR0aCcpLnRvUGl4ZWxzKCd4Jyk7XHJcblx0XHRcdFx0dmFyIGhlaWdodCA9IHRoaXMuYXR0cmlidXRlKCdoZWlnaHQnKS50b1BpeGVscygneScpO1xyXG5cdFx0XHRcdGlmICh3aWR0aCA9PSAwIHx8IGhlaWdodCA9PSAwKSByZXR1cm47XHJcblxyXG5cdFx0XHRcdGN0eC5zYXZlKCk7XHJcblx0XHRcdFx0aWYgKGlzU3ZnKSB7XHJcblx0XHRcdFx0XHRjdHguZHJhd1N2Zyh0aGlzLmltZywgeCwgeSwgd2lkdGgsIGhlaWdodCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0Y3R4LnRyYW5zbGF0ZSh4LCB5KTtcclxuXHRcdFx0XHRcdHN2Zy5Bc3BlY3RSYXRpbyhjdHgsXHJcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuYXR0cmlidXRlKCdwcmVzZXJ2ZUFzcGVjdFJhdGlvJykudmFsdWUsXHJcblx0XHRcdFx0XHRcdFx0XHRcdHdpZHRoLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLmltZy53aWR0aCxcclxuXHRcdFx0XHRcdFx0XHRcdFx0aGVpZ2h0LFxyXG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLmltZy5oZWlnaHQsXHJcblx0XHRcdFx0XHRcdFx0XHRcdDAsXHJcblx0XHRcdFx0XHRcdFx0XHRcdDApO1xyXG5cdFx0XHRcdFx0Y3R4LmRyYXdJbWFnZSh0aGlzLmltZywgMCwgMCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGN0eC5yZXN0b3JlKCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuZ2V0Qm91bmRpbmdCb3ggPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHR2YXIgeCA9IHRoaXMuYXR0cmlidXRlKCd4JykudG9QaXhlbHMoJ3gnKTtcclxuXHRcdFx0XHR2YXIgeSA9IHRoaXMuYXR0cmlidXRlKCd5JykudG9QaXhlbHMoJ3knKTtcclxuXHRcdFx0XHR2YXIgd2lkdGggPSB0aGlzLmF0dHJpYnV0ZSgnd2lkdGgnKS50b1BpeGVscygneCcpO1xyXG5cdFx0XHRcdHZhciBoZWlnaHQgPSB0aGlzLmF0dHJpYnV0ZSgnaGVpZ2h0JykudG9QaXhlbHMoJ3knKTtcclxuXHRcdFx0XHRyZXR1cm4gbmV3IHN2Zy5Cb3VuZGluZ0JveCh4LCB5LCB4ICsgd2lkdGgsIHkgKyBoZWlnaHQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRzdmcuRWxlbWVudC5pbWFnZS5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuUmVuZGVyZWRFbGVtZW50QmFzZTtcclxuXHJcblx0XHQvLyBncm91cCBlbGVtZW50XHJcblx0XHRzdmcuRWxlbWVudC5nID0gZnVuY3Rpb24obm9kZSkge1xyXG5cdFx0XHR0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5SZW5kZXJlZEVsZW1lbnRCYXNlO1xyXG5cdFx0XHR0aGlzLmJhc2Uobm9kZSk7XHJcblxyXG5cdFx0XHR0aGlzLmdldEJvdW5kaW5nQm94ID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0dmFyIGJiID0gbmV3IHN2Zy5Cb3VuZGluZ0JveCgpO1xyXG5cdFx0XHRcdGZvciAodmFyIGk9MDsgaTx0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHRiYi5hZGRCb3VuZGluZ0JveCh0aGlzLmNoaWxkcmVuW2ldLmdldEJvdW5kaW5nQm94KCkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gYmI7XHJcblx0XHRcdH07XHJcblx0XHR9XHJcblx0XHRzdmcuRWxlbWVudC5nLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5SZW5kZXJlZEVsZW1lbnRCYXNlO1xyXG5cclxuXHRcdC8vIHN5bWJvbCBlbGVtZW50XHJcblx0XHRzdmcuRWxlbWVudC5zeW1ib2wgPSBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LlJlbmRlcmVkRWxlbWVudEJhc2U7XHJcblx0XHRcdHRoaXMuYmFzZShub2RlKTtcclxuXHJcblx0XHRcdHRoaXMucmVuZGVyID0gZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdFx0Ly8gTk8gUkVOREVSXHJcblx0XHRcdH07XHJcblx0XHR9XHJcblx0XHRzdmcuRWxlbWVudC5zeW1ib2wucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LlJlbmRlcmVkRWxlbWVudEJhc2U7XHJcblxyXG5cdFx0Ly8gc3R5bGUgZWxlbWVudFxyXG5cdFx0c3ZnLkVsZW1lbnQuc3R5bGUgPSBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xyXG5cdFx0XHR0aGlzLmJhc2Uobm9kZSk7XHJcblxyXG5cdFx0XHQvLyB0ZXh0LCBvciBzcGFjZXMgdGhlbiBDREFUQVxyXG5cdFx0XHR2YXIgY3NzID0gJydcclxuXHRcdFx0Zm9yICh2YXIgaT0wOyBpPG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHQgIGNzcyArPSBub2RlLmNoaWxkTm9kZXNbaV0uZGF0YTtcclxuXHRcdFx0fVxyXG5cdFx0XHRjc3MgPSBjc3MucmVwbGFjZSgvKFxcL1xcKihbXipdfFtcXHJcXG5dfChcXCorKFteKlxcL118W1xcclxcbl0pKSkqXFwqK1xcLyl8KF5bXFxzXSpcXC9cXC8uKikvZ20sICcnKTsgLy8gcmVtb3ZlIGNvbW1lbnRzXHJcblx0XHRcdGNzcyA9IHN2Zy5jb21wcmVzc1NwYWNlcyhjc3MpOyAvLyByZXBsYWNlIHdoaXRlc3BhY2VcclxuXHRcdFx0dmFyIGNzc0RlZnMgPSBjc3Muc3BsaXQoJ30nKTtcclxuXHRcdFx0Zm9yICh2YXIgaT0wOyBpPGNzc0RlZnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRpZiAoc3ZnLnRyaW0oY3NzRGVmc1tpXSkgIT0gJycpIHtcclxuXHRcdFx0XHRcdHZhciBjc3NEZWYgPSBjc3NEZWZzW2ldLnNwbGl0KCd7Jyk7XHJcblx0XHRcdFx0XHR2YXIgY3NzQ2xhc3NlcyA9IGNzc0RlZlswXS5zcGxpdCgnLCcpO1xyXG5cdFx0XHRcdFx0dmFyIGNzc1Byb3BzID0gY3NzRGVmWzFdLnNwbGl0KCc7Jyk7XHJcblx0XHRcdFx0XHRmb3IgKHZhciBqPTA7IGo8Y3NzQ2xhc3Nlcy5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdFx0XHR2YXIgY3NzQ2xhc3MgPSBzdmcudHJpbShjc3NDbGFzc2VzW2pdKTtcclxuXHRcdFx0XHRcdFx0aWYgKGNzc0NsYXNzICE9ICcnKSB7XHJcblx0XHRcdFx0XHRcdFx0dmFyIHByb3BzID0gc3ZnLlN0eWxlc1tjc3NDbGFzc10gfHwge307XHJcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgaz0wOyBrPGNzc1Byb3BzLmxlbmd0aDsgaysrKSB7XHJcblx0XHRcdFx0XHRcdFx0XHR2YXIgcHJvcCA9IGNzc1Byb3BzW2tdLmluZGV4T2YoJzonKTtcclxuXHRcdFx0XHRcdFx0XHRcdHZhciBuYW1lID0gY3NzUHJvcHNba10uc3Vic3RyKDAsIHByb3ApO1xyXG5cdFx0XHRcdFx0XHRcdFx0dmFyIHZhbHVlID0gY3NzUHJvcHNba10uc3Vic3RyKHByb3AgKyAxLCBjc3NQcm9wc1trXS5sZW5ndGggLSBwcm9wKTtcclxuXHRcdFx0XHRcdFx0XHRcdGlmIChuYW1lICE9IG51bGwgJiYgdmFsdWUgIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRwcm9wc1tzdmcudHJpbShuYW1lKV0gPSBuZXcgc3ZnLlByb3BlcnR5KHN2Zy50cmltKG5hbWUpLCBzdmcudHJpbSh2YWx1ZSkpO1xyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRzdmcuU3R5bGVzW2Nzc0NsYXNzXSA9IHByb3BzO1xyXG5cdFx0XHRcdFx0XHRcdHN2Zy5TdHlsZXNTcGVjaWZpY2l0eVtjc3NDbGFzc10gPSBnZXRTZWxlY3RvclNwZWNpZmljaXR5KGNzc0NsYXNzKTtcclxuXHRcdFx0XHRcdFx0XHRpZiAoY3NzQ2xhc3MgPT0gJ0Bmb250LWZhY2UnKSB7XHJcblx0XHRcdFx0XHRcdFx0XHR2YXIgZm9udEZhbWlseSA9IHByb3BzWydmb250LWZhbWlseSddLnZhbHVlLnJlcGxhY2UoL1wiL2csJycpO1xyXG5cdFx0XHRcdFx0XHRcdFx0dmFyIHNyY3MgPSBwcm9wc1snc3JjJ10udmFsdWUuc3BsaXQoJywnKTtcclxuXHRcdFx0XHRcdFx0XHRcdGZvciAodmFyIHM9MDsgczxzcmNzLmxlbmd0aDsgcysrKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGlmIChzcmNzW3NdLmluZGV4T2YoJ2Zvcm1hdChcInN2Z1wiKScpID4gMCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHZhciB1cmxTdGFydCA9IHNyY3Nbc10uaW5kZXhPZigndXJsJyk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0dmFyIHVybEVuZCA9IHNyY3Nbc10uaW5kZXhPZignKScsIHVybFN0YXJ0KTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHR2YXIgdXJsID0gc3Jjc1tzXS5zdWJzdHIodXJsU3RhcnQgKyA1LCB1cmxFbmQgLSB1cmxTdGFydCAtIDYpO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHZhciBkb2MgPSBzdmcucGFyc2VYbWwoc3ZnLmFqYXgodXJsKSk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0dmFyIGZvbnRzID0gZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdmb250Jyk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgZj0wOyBmPGZvbnRzLmxlbmd0aDsgZisrKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR2YXIgZm9udCA9IHN2Zy5DcmVhdGVFbGVtZW50KGZvbnRzW2ZdKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHN2Zy5EZWZpbml0aW9uc1tmb250RmFtaWx5XSA9IGZvbnQ7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRzdmcuRWxlbWVudC5zdHlsZS5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XHJcblxyXG5cdFx0Ly8gdXNlIGVsZW1lbnRcclxuXHRcdHN2Zy5FbGVtZW50LnVzZSA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdFx0dGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuUmVuZGVyZWRFbGVtZW50QmFzZTtcclxuXHRcdFx0dGhpcy5iYXNlKG5vZGUpO1xyXG5cclxuXHRcdFx0dGhpcy5iYXNlU2V0Q29udGV4dCA9IHRoaXMuc2V0Q29udGV4dDtcclxuXHRcdFx0dGhpcy5zZXRDb250ZXh0ID0gZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdFx0dGhpcy5iYXNlU2V0Q29udGV4dChjdHgpO1xyXG5cdFx0XHRcdGlmICh0aGlzLmF0dHJpYnV0ZSgneCcpLmhhc1ZhbHVlKCkpIGN0eC50cmFuc2xhdGUodGhpcy5hdHRyaWJ1dGUoJ3gnKS50b1BpeGVscygneCcpLCAwKTtcclxuXHRcdFx0XHRpZiAodGhpcy5hdHRyaWJ1dGUoJ3knKS5oYXNWYWx1ZSgpKSBjdHgudHJhbnNsYXRlKDAsIHRoaXMuYXR0cmlidXRlKCd5JykudG9QaXhlbHMoJ3knKSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBlbGVtZW50ID0gdGhpcy5nZXRIcmVmQXR0cmlidXRlKCkuZ2V0RGVmaW5pdGlvbigpO1xyXG5cclxuXHRcdFx0dGhpcy5wYXRoID0gZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdFx0aWYgKGVsZW1lbnQgIT0gbnVsbCkgZWxlbWVudC5wYXRoKGN0eCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuZ2V0Qm91bmRpbmdCb3ggPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRpZiAoZWxlbWVudCAhPSBudWxsKSByZXR1cm4gZWxlbWVudC5nZXRCb3VuZGluZ0JveCgpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLnJlbmRlckNoaWxkcmVuID0gZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdFx0aWYgKGVsZW1lbnQgIT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0dmFyIHRlbXBTdmcgPSBlbGVtZW50O1xyXG5cdFx0XHRcdFx0aWYgKGVsZW1lbnQudHlwZSA9PSAnc3ltYm9sJykge1xyXG5cdFx0XHRcdFx0XHQvLyByZW5kZXIgbWUgdXNpbmcgYSB0ZW1wb3Jhcnkgc3ZnIGVsZW1lbnQgaW4gc3ltYm9sIGNhc2VzIChodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvc3RydWN0Lmh0bWwjVXNlRWxlbWVudClcclxuXHRcdFx0XHRcdFx0dGVtcFN2ZyA9IG5ldyBzdmcuRWxlbWVudC5zdmcoKTtcclxuXHRcdFx0XHRcdFx0dGVtcFN2Zy50eXBlID0gJ3N2Zyc7XHJcblx0XHRcdFx0XHRcdHRlbXBTdmcuYXR0cmlidXRlc1sndmlld0JveCddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgndmlld0JveCcsIGVsZW1lbnQuYXR0cmlidXRlKCd2aWV3Qm94JykudmFsdWUpO1xyXG5cdFx0XHRcdFx0XHR0ZW1wU3ZnLmF0dHJpYnV0ZXNbJ3ByZXNlcnZlQXNwZWN0UmF0aW8nXSA9IG5ldyBzdmcuUHJvcGVydHkoJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLCBlbGVtZW50LmF0dHJpYnV0ZSgncHJlc2VydmVBc3BlY3RSYXRpbycpLnZhbHVlKTtcclxuXHRcdFx0XHRcdFx0dGVtcFN2Zy5hdHRyaWJ1dGVzWydvdmVyZmxvdyddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgnb3ZlcmZsb3cnLCBlbGVtZW50LmF0dHJpYnV0ZSgnb3ZlcmZsb3cnKS52YWx1ZSk7XHJcblx0XHRcdFx0XHRcdHRlbXBTdmcuY2hpbGRyZW4gPSBlbGVtZW50LmNoaWxkcmVuO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKHRlbXBTdmcudHlwZSA9PSAnc3ZnJykge1xyXG5cdFx0XHRcdFx0XHQvLyBpZiBzeW1ib2wgb3Igc3ZnLCBpbmhlcml0IHdpZHRoL2hlaWdodCBmcm9tIG1lXHJcblx0XHRcdFx0XHRcdGlmICh0aGlzLmF0dHJpYnV0ZSgnd2lkdGgnKS5oYXNWYWx1ZSgpKSB0ZW1wU3ZnLmF0dHJpYnV0ZXNbJ3dpZHRoJ10gPSBuZXcgc3ZnLlByb3BlcnR5KCd3aWR0aCcsIHRoaXMuYXR0cmlidXRlKCd3aWR0aCcpLnZhbHVlKTtcclxuXHRcdFx0XHRcdFx0aWYgKHRoaXMuYXR0cmlidXRlKCdoZWlnaHQnKS5oYXNWYWx1ZSgpKSB0ZW1wU3ZnLmF0dHJpYnV0ZXNbJ2hlaWdodCddID0gbmV3IHN2Zy5Qcm9wZXJ0eSgnaGVpZ2h0JywgdGhpcy5hdHRyaWJ1dGUoJ2hlaWdodCcpLnZhbHVlKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHZhciBvbGRQYXJlbnQgPSB0ZW1wU3ZnLnBhcmVudDtcclxuXHRcdFx0XHRcdHRlbXBTdmcucGFyZW50ID0gbnVsbDtcclxuXHRcdFx0XHRcdHRlbXBTdmcucmVuZGVyKGN0eCk7XHJcblx0XHRcdFx0XHR0ZW1wU3ZnLnBhcmVudCA9IG9sZFBhcmVudDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHN2Zy5FbGVtZW50LnVzZS5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuUmVuZGVyZWRFbGVtZW50QmFzZTtcclxuXHJcblx0XHQvLyBtYXNrIGVsZW1lbnRcclxuXHRcdHN2Zy5FbGVtZW50Lm1hc2sgPSBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xyXG5cdFx0XHR0aGlzLmJhc2Uobm9kZSk7XHJcblxyXG5cdFx0XHR0aGlzLmFwcGx5ID0gZnVuY3Rpb24oY3R4LCBlbGVtZW50KSB7XHJcblx0XHRcdFx0Ly8gcmVuZGVyIGFzIHRlbXAgc3ZnXHJcblx0XHRcdFx0dmFyIHggPSB0aGlzLmF0dHJpYnV0ZSgneCcpLnRvUGl4ZWxzKCd4Jyk7XHJcblx0XHRcdFx0dmFyIHkgPSB0aGlzLmF0dHJpYnV0ZSgneScpLnRvUGl4ZWxzKCd5Jyk7XHJcblx0XHRcdFx0dmFyIHdpZHRoID0gdGhpcy5hdHRyaWJ1dGUoJ3dpZHRoJykudG9QaXhlbHMoJ3gnKTtcclxuXHRcdFx0XHR2YXIgaGVpZ2h0ID0gdGhpcy5hdHRyaWJ1dGUoJ2hlaWdodCcpLnRvUGl4ZWxzKCd5Jyk7XHJcblxyXG5cdFx0XHRcdGlmICh3aWR0aCA9PSAwICYmIGhlaWdodCA9PSAwKSB7XHJcblx0XHRcdFx0XHR2YXIgYmIgPSBuZXcgc3ZnLkJvdW5kaW5nQm94KCk7XHJcblx0XHRcdFx0XHRmb3IgKHZhciBpPTA7IGk8dGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0XHRiYi5hZGRCb3VuZGluZ0JveCh0aGlzLmNoaWxkcmVuW2ldLmdldEJvdW5kaW5nQm94KCkpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0dmFyIHggPSBNYXRoLmZsb29yKGJiLngxKTtcclxuXHRcdFx0XHRcdHZhciB5ID0gTWF0aC5mbG9vcihiYi55MSk7XHJcblx0XHRcdFx0XHR2YXIgd2lkdGggPSBNYXRoLmZsb29yKGJiLndpZHRoKCkpO1xyXG5cdFx0XHRcdFx0dmFyXHRoZWlnaHQgPSBNYXRoLmZsb29yKGJiLmhlaWdodCgpKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIHRlbXBvcmFyaWx5IHJlbW92ZSBtYXNrIHRvIGF2b2lkIHJlY3Vyc2lvblxyXG5cdFx0XHRcdHZhciBtYXNrID0gZWxlbWVudC5hdHRyaWJ1dGUoJ21hc2snKS52YWx1ZTtcclxuXHRcdFx0XHRlbGVtZW50LmF0dHJpYnV0ZSgnbWFzaycpLnZhbHVlID0gJyc7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGNNYXNrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcblx0XHRcdFx0XHRjTWFzay53aWR0aCA9IHggKyB3aWR0aDtcclxuXHRcdFx0XHRcdGNNYXNrLmhlaWdodCA9IHkgKyBoZWlnaHQ7XHJcblx0XHRcdFx0XHR2YXIgbWFza0N0eCA9IGNNYXNrLmdldENvbnRleHQoJzJkJyk7XHJcblx0XHRcdFx0XHR0aGlzLnJlbmRlckNoaWxkcmVuKG1hc2tDdHgpO1xyXG5cclxuXHRcdFx0XHRcdHZhciBjID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcblx0XHRcdFx0XHRjLndpZHRoID0geCArIHdpZHRoO1xyXG5cdFx0XHRcdFx0Yy5oZWlnaHQgPSB5ICsgaGVpZ2h0O1xyXG5cdFx0XHRcdFx0dmFyIHRlbXBDdHggPSBjLmdldENvbnRleHQoJzJkJyk7XHJcblx0XHRcdFx0XHRlbGVtZW50LnJlbmRlcih0ZW1wQ3R4KTtcclxuXHRcdFx0XHRcdHRlbXBDdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLWluJztcclxuXHRcdFx0XHRcdHRlbXBDdHguZmlsbFN0eWxlID0gbWFza0N0eC5jcmVhdGVQYXR0ZXJuKGNNYXNrLCAnbm8tcmVwZWF0Jyk7XHJcblx0XHRcdFx0XHR0ZW1wQ3R4LmZpbGxSZWN0KDAsIDAsIHggKyB3aWR0aCwgeSArIGhlaWdodCk7XHJcblxyXG5cdFx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9IHRlbXBDdHguY3JlYXRlUGF0dGVybihjLCAnbm8tcmVwZWF0Jyk7XHJcblx0XHRcdFx0XHRjdHguZmlsbFJlY3QoMCwgMCwgeCArIHdpZHRoLCB5ICsgaGVpZ2h0KTtcclxuXHJcblx0XHRcdFx0Ly8gcmVhc3NpZ24gbWFza1xyXG5cdFx0XHRcdGVsZW1lbnQuYXR0cmlidXRlKCdtYXNrJykudmFsdWUgPSBtYXNrO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLnJlbmRlciA9IGZ1bmN0aW9uKGN0eCkge1xyXG5cdFx0XHRcdC8vIE5PIFJFTkRFUlxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRzdmcuRWxlbWVudC5tYXNrLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcclxuXHJcblx0XHQvLyBjbGlwIGVsZW1lbnRcclxuXHRcdHN2Zy5FbGVtZW50LmNsaXBQYXRoID0gZnVuY3Rpb24obm9kZSkge1xyXG5cdFx0XHR0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcclxuXHRcdFx0dGhpcy5iYXNlKG5vZGUpO1xyXG5cclxuXHRcdFx0dGhpcy5hcHBseSA9IGZ1bmN0aW9uKGN0eCkge1xyXG5cdFx0XHRcdHZhciBvbGRCZWdpblBhdGggPSBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLmJlZ2luUGF0aDtcclxuXHRcdFx0XHRDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLmJlZ2luUGF0aCA9IGZ1bmN0aW9uICgpIHsgfTtcclxuXHJcblx0XHRcdFx0dmFyIG9sZENsb3NlUGF0aCA9IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUuY2xvc2VQYXRoO1xyXG5cdFx0XHRcdENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUuY2xvc2VQYXRoID0gZnVuY3Rpb24gKCkgeyB9O1xyXG5cclxuXHRcdFx0XHRvbGRCZWdpblBhdGguY2FsbChjdHgpO1xyXG5cdFx0XHRcdGZvciAodmFyIGk9MDsgaTx0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHR2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xyXG5cdFx0XHRcdFx0aWYgKHR5cGVvZiBjaGlsZC5wYXRoICE9ICd1bmRlZmluZWQnKSB7XHJcblx0XHRcdFx0XHRcdHZhciB0cmFuc2Zvcm0gPSBudWxsO1xyXG5cdFx0XHRcdFx0XHRpZiAoY2hpbGQuc3R5bGUoJ3RyYW5zZm9ybScsIGZhbHNlLCB0cnVlKS5oYXNWYWx1ZSgpKSB7XHJcblx0XHRcdFx0XHRcdFx0dHJhbnNmb3JtID0gbmV3IHN2Zy5UcmFuc2Zvcm0oY2hpbGQuc3R5bGUoJ3RyYW5zZm9ybScsIGZhbHNlLCB0cnVlKS52YWx1ZSk7XHJcblx0XHRcdFx0XHRcdFx0dHJhbnNmb3JtLmFwcGx5KGN0eCk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0Y2hpbGQucGF0aChjdHgpO1xyXG5cdFx0XHRcdFx0XHRDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLmNsb3NlUGF0aCA9IG9sZENsb3NlUGF0aDtcclxuXHRcdFx0XHRcdFx0aWYgKHRyYW5zZm9ybSkgeyB0cmFuc2Zvcm0udW5hcHBseShjdHgpOyB9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdG9sZENsb3NlUGF0aC5jYWxsKGN0eCk7XHJcblx0XHRcdFx0Y3R4LmNsaXAoKTtcclxuXHJcblx0XHRcdFx0Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5iZWdpblBhdGggPSBvbGRCZWdpblBhdGg7XHJcblx0XHRcdFx0Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5jbG9zZVBhdGggPSBvbGRDbG9zZVBhdGg7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMucmVuZGVyID0gZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdFx0Ly8gTk8gUkVOREVSXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHN2Zy5FbGVtZW50LmNsaXBQYXRoLnByb3RvdHlwZSA9IG5ldyBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcclxuXHJcblx0XHQvLyBmaWx0ZXJzXHJcblx0XHRzdmcuRWxlbWVudC5maWx0ZXIgPSBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xyXG5cdFx0XHR0aGlzLmJhc2Uobm9kZSk7XHJcblxyXG5cdFx0XHR0aGlzLmFwcGx5ID0gZnVuY3Rpb24oY3R4LCBlbGVtZW50KSB7XHJcblx0XHRcdFx0Ly8gcmVuZGVyIGFzIHRlbXAgc3ZnXHJcblx0XHRcdFx0dmFyIGJiID0gZWxlbWVudC5nZXRCb3VuZGluZ0JveCgpO1xyXG5cdFx0XHRcdHZhciB4ID0gTWF0aC5mbG9vcihiYi54MSk7XHJcblx0XHRcdFx0dmFyIHkgPSBNYXRoLmZsb29yKGJiLnkxKTtcclxuXHRcdFx0XHR2YXIgd2lkdGggPSBNYXRoLmZsb29yKGJiLndpZHRoKCkpO1xyXG5cdFx0XHRcdHZhclx0aGVpZ2h0ID0gTWF0aC5mbG9vcihiYi5oZWlnaHQoKSk7XHJcblxyXG5cdFx0XHRcdC8vIHRlbXBvcmFyaWx5IHJlbW92ZSBmaWx0ZXIgdG8gYXZvaWQgcmVjdXJzaW9uXHJcblx0XHRcdFx0dmFyIGZpbHRlciA9IGVsZW1lbnQuc3R5bGUoJ2ZpbHRlcicpLnZhbHVlO1xyXG5cdFx0XHRcdGVsZW1lbnQuc3R5bGUoJ2ZpbHRlcicpLnZhbHVlID0gJyc7XHJcblxyXG5cdFx0XHRcdHZhciBweCA9IDAsIHB5ID0gMDtcclxuXHRcdFx0XHRmb3IgKHZhciBpPTA7IGk8dGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0dmFyIGVmZCA9IHRoaXMuY2hpbGRyZW5baV0uZXh0cmFGaWx0ZXJEaXN0YW5jZSB8fCAwO1xyXG5cdFx0XHRcdFx0cHggPSBNYXRoLm1heChweCwgZWZkKTtcclxuXHRcdFx0XHRcdHB5ID0gTWF0aC5tYXgocHksIGVmZCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR2YXIgYyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG5cdFx0XHRcdGMud2lkdGggPSB3aWR0aCArIDIqcHg7XHJcblx0XHRcdFx0Yy5oZWlnaHQgPSBoZWlnaHQgKyAyKnB5O1xyXG5cdFx0XHRcdHZhciB0ZW1wQ3R4ID0gYy5nZXRDb250ZXh0KCcyZCcpO1xyXG5cdFx0XHRcdHRlbXBDdHgudHJhbnNsYXRlKC14ICsgcHgsIC15ICsgcHkpO1xyXG5cdFx0XHRcdGVsZW1lbnQucmVuZGVyKHRlbXBDdHgpO1xyXG5cclxuXHRcdFx0XHQvLyBhcHBseSBmaWx0ZXJzXHJcblx0XHRcdFx0Zm9yICh2YXIgaT0wOyBpPHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdGlmICh0eXBlb2YgdGhpcy5jaGlsZHJlbltpXS5hcHBseSA9PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdFx0XHRcdHRoaXMuY2hpbGRyZW5baV0uYXBwbHkodGVtcEN0eCwgMCwgMCwgd2lkdGggKyAyKnB4LCBoZWlnaHQgKyAyKnB5KTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIHJlbmRlciBvbiBtZVxyXG5cdFx0XHRcdGN0eC5kcmF3SW1hZ2UoYywgMCwgMCwgd2lkdGggKyAyKnB4LCBoZWlnaHQgKyAyKnB5LCB4IC0gcHgsIHkgLSBweSwgd2lkdGggKyAyKnB4LCBoZWlnaHQgKyAyKnB5KTtcclxuXHJcblx0XHRcdFx0Ly8gcmVhc3NpZ24gZmlsdGVyXHJcblx0XHRcdFx0ZWxlbWVudC5zdHlsZSgnZmlsdGVyJywgdHJ1ZSkudmFsdWUgPSBmaWx0ZXI7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMucmVuZGVyID0gZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdFx0Ly8gTk8gUkVOREVSXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHN2Zy5FbGVtZW50LmZpbHRlci5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XHJcblxyXG5cdFx0c3ZnLkVsZW1lbnQuZmVNb3JwaG9sb2d5ID0gZnVuY3Rpb24obm9kZSkge1xyXG5cdFx0XHR0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcclxuXHRcdFx0dGhpcy5iYXNlKG5vZGUpO1xyXG5cclxuXHRcdFx0dGhpcy5hcHBseSA9IGZ1bmN0aW9uKGN0eCwgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xyXG5cdFx0XHRcdC8vIFRPRE86IGltcGxlbWVudFxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRzdmcuRWxlbWVudC5mZU1vcnBob2xvZ3kucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xyXG5cclxuXHRcdHN2Zy5FbGVtZW50LmZlQ29tcG9zaXRlID0gZnVuY3Rpb24obm9kZSkge1xyXG5cdFx0XHR0aGlzLmJhc2UgPSBzdmcuRWxlbWVudC5FbGVtZW50QmFzZTtcclxuXHRcdFx0dGhpcy5iYXNlKG5vZGUpO1xyXG5cclxuXHRcdFx0dGhpcy5hcHBseSA9IGZ1bmN0aW9uKGN0eCwgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xyXG5cdFx0XHRcdC8vIFRPRE86IGltcGxlbWVudFxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRzdmcuRWxlbWVudC5mZUNvbXBvc2l0ZS5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XHJcblxyXG5cdFx0c3ZnLkVsZW1lbnQuZmVDb2xvck1hdHJpeCA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdFx0dGhpcy5iYXNlID0gc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XHJcblx0XHRcdHRoaXMuYmFzZShub2RlKTtcclxuXHJcblx0XHRcdHZhciBtYXRyaXggPSBzdmcuVG9OdW1iZXJBcnJheSh0aGlzLmF0dHJpYnV0ZSgndmFsdWVzJykudmFsdWUpO1xyXG5cdFx0XHRzd2l0Y2ggKHRoaXMuYXR0cmlidXRlKCd0eXBlJykudmFsdWVPckRlZmF1bHQoJ21hdHJpeCcpKSB7IC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9maWx0ZXJzLmh0bWwjZmVDb2xvck1hdHJpeEVsZW1lbnRcclxuXHRcdFx0XHRjYXNlICdzYXR1cmF0ZSc6XHJcblx0XHRcdFx0XHR2YXIgcyA9IG1hdHJpeFswXTtcclxuXHRcdFx0XHRcdG1hdHJpeCA9IFswLjIxMyswLjc4NypzLDAuNzE1LTAuNzE1KnMsMC4wNzItMC4wNzIqcywwLDAsXHJcblx0XHRcdFx0XHRcdFx0ICAwLjIxMy0wLjIxMypzLDAuNzE1KzAuMjg1KnMsMC4wNzItMC4wNzIqcywwLDAsXHJcblx0XHRcdFx0XHRcdFx0ICAwLjIxMy0wLjIxMypzLDAuNzE1LTAuNzE1KnMsMC4wNzIrMC45MjgqcywwLDAsXHJcblx0XHRcdFx0XHRcdFx0ICAwLDAsMCwxLDAsXHJcblx0XHRcdFx0XHRcdFx0ICAwLDAsMCwwLDFdO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0Y2FzZSAnaHVlUm90YXRlJzpcclxuXHRcdFx0XHRcdHZhciBhID0gbWF0cml4WzBdICogTWF0aC5QSSAvIDE4MC4wO1xyXG5cdFx0XHRcdFx0dmFyIGMgPSBmdW5jdGlvbiAobTEsbTIsbTMpIHsgcmV0dXJuIG0xICsgTWF0aC5jb3MoYSkqbTIgKyBNYXRoLnNpbihhKSptMzsgfTtcclxuXHRcdFx0XHRcdG1hdHJpeCA9IFtjKDAuMjEzLDAuNzg3LC0wLjIxMyksYygwLjcxNSwtMC43MTUsLTAuNzE1KSxjKDAuMDcyLC0wLjA3MiwwLjkyOCksMCwwLFxyXG5cdFx0XHRcdFx0XHRcdCAgYygwLjIxMywtMC4yMTMsMC4xNDMpLGMoMC43MTUsMC4yODUsMC4xNDApLGMoMC4wNzIsLTAuMDcyLC0wLjI4MyksMCwwLFxyXG5cdFx0XHRcdFx0XHRcdCAgYygwLjIxMywtMC4yMTMsLTAuNzg3KSxjKDAuNzE1LC0wLjcxNSwwLjcxNSksYygwLjA3MiwwLjkyOCwwLjA3MiksMCwwLFxyXG5cdFx0XHRcdFx0XHRcdCAgMCwwLDAsMSwwLFxyXG5cdFx0XHRcdFx0XHRcdCAgMCwwLDAsMCwxXTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgJ2x1bWluYW5jZVRvQWxwaGEnOlxyXG5cdFx0XHRcdFx0bWF0cml4ID0gWzAsMCwwLDAsMCxcclxuXHRcdFx0XHRcdFx0XHQgIDAsMCwwLDAsMCxcclxuXHRcdFx0XHRcdFx0XHQgIDAsMCwwLDAsMCxcclxuXHRcdFx0XHRcdFx0XHQgIDAuMjEyNSwwLjcxNTQsMC4wNzIxLDAsMCxcclxuXHRcdFx0XHRcdFx0XHQgIDAsMCwwLDAsMV07XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZnVuY3Rpb24gaW1HZXQoaW1nLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCByZ2JhKSB7XHJcblx0XHRcdFx0cmV0dXJuIGltZ1t5KndpZHRoKjQgKyB4KjQgKyByZ2JhXTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZnVuY3Rpb24gaW1TZXQoaW1nLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCByZ2JhLCB2YWwpIHtcclxuXHRcdFx0XHRpbWdbeSp3aWR0aCo0ICsgeCo0ICsgcmdiYV0gPSB2YWw7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZ1bmN0aW9uIG0oaSwgdikge1xyXG5cdFx0XHRcdHZhciBtaSA9IG1hdHJpeFtpXTtcclxuXHRcdFx0XHRyZXR1cm4gbWkgKiAobWkgPCAwID8gdiAtIDI1NSA6IHYpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmFwcGx5ID0gZnVuY3Rpb24oY3R4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XHJcblx0XHRcdFx0Ly8gYXNzdW1pbmcgeD09MCAmJiB5PT0wIGZvciBub3dcclxuXHRcdFx0XHR2YXIgc3JjRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCk7XHJcblx0XHRcdFx0Zm9yICh2YXIgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xyXG5cdFx0XHRcdFx0Zm9yICh2YXIgeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XHJcblx0XHRcdFx0XHRcdHZhciByID0gaW1HZXQoc3JjRGF0YS5kYXRhLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCAwKTtcclxuXHRcdFx0XHRcdFx0dmFyIGcgPSBpbUdldChzcmNEYXRhLmRhdGEsIHgsIHksIHdpZHRoLCBoZWlnaHQsIDEpO1xyXG5cdFx0XHRcdFx0XHR2YXIgYiA9IGltR2V0KHNyY0RhdGEuZGF0YSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgMik7XHJcblx0XHRcdFx0XHRcdHZhciBhID0gaW1HZXQoc3JjRGF0YS5kYXRhLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCAzKTtcclxuXHRcdFx0XHRcdFx0aW1TZXQoc3JjRGF0YS5kYXRhLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCAwLCBtKDAscikrbSgxLGcpK20oMixiKSttKDMsYSkrbSg0LDEpKTtcclxuXHRcdFx0XHRcdFx0aW1TZXQoc3JjRGF0YS5kYXRhLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCAxLCBtKDUscikrbSg2LGcpK20oNyxiKSttKDgsYSkrbSg5LDEpKTtcclxuXHRcdFx0XHRcdFx0aW1TZXQoc3JjRGF0YS5kYXRhLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCAyLCBtKDEwLHIpK20oMTEsZykrbSgxMixiKSttKDEzLGEpK20oMTQsMSkpO1xyXG5cdFx0XHRcdFx0XHRpbVNldChzcmNEYXRhLmRhdGEsIHgsIHksIHdpZHRoLCBoZWlnaHQsIDMsIG0oMTUscikrbSgxNixnKSttKDE3LGIpK20oMTgsYSkrbSgxOSwxKSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XHJcblx0XHRcdFx0Y3R4LnB1dEltYWdlRGF0YShzcmNEYXRhLCAwLCAwKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0c3ZnLkVsZW1lbnQuZmVDb2xvck1hdHJpeC5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XHJcblxyXG5cdFx0c3ZnLkVsZW1lbnQuZmVHYXVzc2lhbkJsdXIgPSBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHRoaXMuYmFzZSA9IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xyXG5cdFx0XHR0aGlzLmJhc2Uobm9kZSk7XHJcblxyXG5cdFx0XHR0aGlzLmJsdXJSYWRpdXMgPSBNYXRoLmZsb29yKHRoaXMuYXR0cmlidXRlKCdzdGREZXZpYXRpb24nKS5udW1WYWx1ZSgpKTtcclxuXHRcdFx0dGhpcy5leHRyYUZpbHRlckRpc3RhbmNlID0gdGhpcy5ibHVyUmFkaXVzO1xyXG5cclxuXHRcdFx0dGhpcy5hcHBseSA9IGZ1bmN0aW9uKGN0eCwgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xyXG5cdFx0XHRcdGlmICh0eXBlb2Ygc3RhY2tCbHVyLmNhbnZhc1JHQkEgPT0gJ3VuZGVmaW5lZCcpIHtcclxuXHRcdFx0XHRcdHN2Zy5sb2coJ0VSUk9SOiBTdGFja0JsdXIuanMgbXVzdCBiZSBpbmNsdWRlZCBmb3IgYmx1ciB0byB3b3JrJyk7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBTdGFja0JsdXIgcmVxdWlyZXMgY2FudmFzIGJlIG9uIGRvY3VtZW50XHJcblx0XHRcdFx0Y3R4LmNhbnZhcy5pZCA9IHN2Zy5VbmlxdWVJZCgpO1xyXG5cdFx0XHRcdGN0eC5jYW52YXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuXHRcdFx0XHRkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGN0eC5jYW52YXMpO1xyXG5cdFx0XHRcdHN0YWNrQmx1ci5jYW52YXNSR0JBKGN0eC5jYW52YXMuaWQsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHRoaXMuYmx1clJhZGl1cyk7XHJcblx0XHRcdFx0ZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChjdHguY2FudmFzKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0c3ZnLkVsZW1lbnQuZmVHYXVzc2lhbkJsdXIucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xyXG5cclxuXHRcdC8vIHRpdGxlIGVsZW1lbnQsIGRvIG5vdGhpbmdcclxuXHRcdHN2Zy5FbGVtZW50LnRpdGxlID0gZnVuY3Rpb24obm9kZSkge1xyXG5cdFx0fVxyXG5cdFx0c3ZnLkVsZW1lbnQudGl0bGUucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xyXG5cclxuXHRcdC8vIGRlc2MgZWxlbWVudCwgZG8gbm90aGluZ1xyXG5cdFx0c3ZnLkVsZW1lbnQuZGVzYyA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdH1cclxuXHRcdHN2Zy5FbGVtZW50LmRlc2MucHJvdG90eXBlID0gbmV3IHN2Zy5FbGVtZW50LkVsZW1lbnRCYXNlO1xyXG5cclxuXHRcdHN2Zy5FbGVtZW50Lk1JU1NJTkcgPSBmdW5jdGlvbihub2RlKSB7XHJcblx0XHRcdHN2Zy5sb2coJ0VSUk9SOiBFbGVtZW50IFxcJycgKyBub2RlLm5vZGVOYW1lICsgJ1xcJyBub3QgeWV0IGltcGxlbWVudGVkLicpO1xyXG5cdFx0fVxyXG5cdFx0c3ZnLkVsZW1lbnQuTUlTU0lORy5wcm90b3R5cGUgPSBuZXcgc3ZnLkVsZW1lbnQuRWxlbWVudEJhc2U7XHJcblxyXG5cdFx0Ly8gZWxlbWVudCBmYWN0b3J5XHJcblx0XHRzdmcuQ3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdFx0dmFyIGNsYXNzTmFtZSA9IG5vZGUubm9kZU5hbWUucmVwbGFjZSgvXlteOl0rOi8sJycpOyAvLyByZW1vdmUgbmFtZXNwYWNlXHJcblx0XHRcdGNsYXNzTmFtZSA9IGNsYXNzTmFtZS5yZXBsYWNlKC9cXC0vZywnJyk7IC8vIHJlbW92ZSBkYXNoZXNcclxuXHRcdFx0dmFyIGUgPSBudWxsO1xyXG5cdFx0XHRpZiAodHlwZW9mIHN2Zy5FbGVtZW50W2NsYXNzTmFtZV0gIT0gJ3VuZGVmaW5lZCcpIHtcclxuXHRcdFx0XHRlID0gbmV3IHN2Zy5FbGVtZW50W2NsYXNzTmFtZV0obm9kZSk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0ZSA9IG5ldyBzdmcuRWxlbWVudC5NSVNTSU5HKG5vZGUpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRlLnR5cGUgPSBub2RlLm5vZGVOYW1lO1xyXG5cdFx0XHRyZXR1cm4gZTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBsb2FkIGZyb20gdXJsXHJcblx0XHRzdmcubG9hZCA9IGZ1bmN0aW9uKGN0eCwgdXJsKSB7XHJcblx0XHRcdHN2Zy5sb2FkWG1sKGN0eCwgc3ZnLmFqYXgodXJsKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gbG9hZCBmcm9tIHhtbFxyXG5cdFx0c3ZnLmxvYWRYbWwgPSBmdW5jdGlvbihjdHgsIHhtbCkge1xyXG5cdFx0XHRzdmcubG9hZFhtbERvYyhjdHgsIHN2Zy5wYXJzZVhtbCh4bWwpKTtcclxuXHRcdH1cclxuXHJcblx0XHRzdmcubG9hZFhtbERvYyA9IGZ1bmN0aW9uKGN0eCwgZG9tKSB7XHJcblx0XHRcdHN2Zy5pbml0KGN0eCk7XHJcblxyXG5cdFx0XHR2YXIgbWFwWFkgPSBmdW5jdGlvbihwKSB7XHJcblx0XHRcdFx0dmFyIGUgPSBjdHguY2FudmFzO1xyXG5cdFx0XHRcdHdoaWxlIChlKSB7XHJcblx0XHRcdFx0XHRwLnggLT0gZS5vZmZzZXRMZWZ0O1xyXG5cdFx0XHRcdFx0cC55IC09IGUub2Zmc2V0VG9wO1xyXG5cdFx0XHRcdFx0ZSA9IGUub2Zmc2V0UGFyZW50O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiAod2luZG93LnNjcm9sbFgpIHAueCArPSB3aW5kb3cuc2Nyb2xsWDtcclxuXHRcdFx0XHRpZiAod2luZG93LnNjcm9sbFkpIHAueSArPSB3aW5kb3cuc2Nyb2xsWTtcclxuXHRcdFx0XHRyZXR1cm4gcDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gYmluZCBtb3VzZVxyXG5cdFx0XHRpZiAoc3ZnLm9wdHNbJ2lnbm9yZU1vdXNlJ10gIT0gdHJ1ZSkge1xyXG5cdFx0XHRcdGN0eC5jYW52YXMub25jbGljayA9IGZ1bmN0aW9uKGUpIHtcclxuXHRcdFx0XHRcdHZhciBwID0gbWFwWFkobmV3IHN2Zy5Qb2ludChlICE9IG51bGwgPyBlLmNsaWVudFggOiBldmVudC5jbGllbnRYLCBlICE9IG51bGwgPyBlLmNsaWVudFkgOiBldmVudC5jbGllbnRZKSk7XHJcblx0XHRcdFx0XHRzdmcuTW91c2Uub25jbGljayhwLngsIHAueSk7XHJcblx0XHRcdFx0fTtcclxuXHRcdFx0XHRjdHguY2FudmFzLm9ubW91c2Vtb3ZlID0gZnVuY3Rpb24oZSkge1xyXG5cdFx0XHRcdFx0dmFyIHAgPSBtYXBYWShuZXcgc3ZnLlBvaW50KGUgIT0gbnVsbCA/IGUuY2xpZW50WCA6IGV2ZW50LmNsaWVudFgsIGUgIT0gbnVsbCA/IGUuY2xpZW50WSA6IGV2ZW50LmNsaWVudFkpKTtcclxuXHRcdFx0XHRcdHN2Zy5Nb3VzZS5vbm1vdXNlbW92ZShwLngsIHAueSk7XHJcblx0XHRcdFx0fTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIGUgPSBzdmcuQ3JlYXRlRWxlbWVudChkb20uZG9jdW1lbnRFbGVtZW50KTtcclxuXHRcdFx0ZS5yb290ID0gdHJ1ZTtcclxuXHRcdFx0ZS5hZGRTdHlsZXNGcm9tU3R5bGVEZWZpbml0aW9uKCk7XHJcblxyXG5cdFx0XHQvLyByZW5kZXIgbG9vcFxyXG5cdFx0XHR2YXIgaXNGaXJzdFJlbmRlciA9IHRydWU7XHJcblx0XHRcdHZhciBkcmF3ID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0c3ZnLlZpZXdQb3J0LkNsZWFyKCk7XHJcblx0XHRcdFx0aWYgKGN0eC5jYW52YXMucGFyZW50Tm9kZSkgc3ZnLlZpZXdQb3J0LlNldEN1cnJlbnQoY3R4LmNhbnZhcy5wYXJlbnROb2RlLmNsaWVudFdpZHRoLCBjdHguY2FudmFzLnBhcmVudE5vZGUuY2xpZW50SGVpZ2h0KTtcclxuXHJcblx0XHRcdFx0aWYgKHN2Zy5vcHRzWydpZ25vcmVEaW1lbnNpb25zJ10gIT0gdHJ1ZSkge1xyXG5cdFx0XHRcdFx0Ly8gc2V0IGNhbnZhcyBzaXplXHJcblx0XHRcdFx0XHRpZiAoZS5zdHlsZSgnd2lkdGgnKS5oYXNWYWx1ZSgpKSB7XHJcblx0XHRcdFx0XHRcdGN0eC5jYW52YXMud2lkdGggPSBlLnN0eWxlKCd3aWR0aCcpLnRvUGl4ZWxzKCd4Jyk7XHJcblx0XHRcdFx0XHRcdGN0eC5jYW52YXMuc3R5bGUud2lkdGggPSBjdHguY2FudmFzLndpZHRoICsgJ3B4JztcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmIChlLnN0eWxlKCdoZWlnaHQnKS5oYXNWYWx1ZSgpKSB7XHJcblx0XHRcdFx0XHRcdGN0eC5jYW52YXMuaGVpZ2h0ID0gZS5zdHlsZSgnaGVpZ2h0JykudG9QaXhlbHMoJ3knKTtcclxuXHRcdFx0XHRcdFx0Y3R4LmNhbnZhcy5zdHlsZS5oZWlnaHQgPSBjdHguY2FudmFzLmhlaWdodCArICdweCc7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHZhciBjV2lkdGggPSBjdHguY2FudmFzLmNsaWVudFdpZHRoIHx8IGN0eC5jYW52YXMud2lkdGg7XHJcblx0XHRcdFx0dmFyIGNIZWlnaHQgPSBjdHguY2FudmFzLmNsaWVudEhlaWdodCB8fCBjdHguY2FudmFzLmhlaWdodDtcclxuXHRcdFx0XHRpZiAoc3ZnLm9wdHNbJ2lnbm9yZURpbWVuc2lvbnMnXSA9PSB0cnVlICYmIGUuc3R5bGUoJ3dpZHRoJykuaGFzVmFsdWUoKSAmJiBlLnN0eWxlKCdoZWlnaHQnKS5oYXNWYWx1ZSgpKSB7XHJcblx0XHRcdFx0XHRjV2lkdGggPSBlLnN0eWxlKCd3aWR0aCcpLnRvUGl4ZWxzKCd4Jyk7XHJcblx0XHRcdFx0XHRjSGVpZ2h0ID0gZS5zdHlsZSgnaGVpZ2h0JykudG9QaXhlbHMoJ3knKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0c3ZnLlZpZXdQb3J0LlNldEN1cnJlbnQoY1dpZHRoLCBjSGVpZ2h0KTtcclxuXHJcblx0XHRcdFx0aWYgKHN2Zy5vcHRzWydvZmZzZXRYJ10gIT0gbnVsbCkgZS5hdHRyaWJ1dGUoJ3gnLCB0cnVlKS52YWx1ZSA9IHN2Zy5vcHRzWydvZmZzZXRYJ107XHJcblx0XHRcdFx0aWYgKHN2Zy5vcHRzWydvZmZzZXRZJ10gIT0gbnVsbCkgZS5hdHRyaWJ1dGUoJ3knLCB0cnVlKS52YWx1ZSA9IHN2Zy5vcHRzWydvZmZzZXRZJ107XHJcblx0XHRcdFx0aWYgKHN2Zy5vcHRzWydzY2FsZVdpZHRoJ10gIT0gbnVsbCB8fCBzdmcub3B0c1snc2NhbGVIZWlnaHQnXSAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHR2YXIgeFJhdGlvID0gbnVsbCwgeVJhdGlvID0gbnVsbCwgdmlld0JveCA9IHN2Zy5Ub051bWJlckFycmF5KGUuYXR0cmlidXRlKCd2aWV3Qm94JykudmFsdWUpO1xyXG5cclxuXHRcdFx0XHRcdGlmIChzdmcub3B0c1snc2NhbGVXaWR0aCddICE9IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0aWYgKGUuYXR0cmlidXRlKCd3aWR0aCcpLmhhc1ZhbHVlKCkpIHhSYXRpbyA9IGUuYXR0cmlidXRlKCd3aWR0aCcpLnRvUGl4ZWxzKCd4JykgLyBzdmcub3B0c1snc2NhbGVXaWR0aCddO1xyXG5cdFx0XHRcdFx0XHRlbHNlIGlmICghaXNOYU4odmlld0JveFsyXSkpIHhSYXRpbyA9IHZpZXdCb3hbMl0gLyBzdmcub3B0c1snc2NhbGVXaWR0aCddO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGlmIChzdmcub3B0c1snc2NhbGVIZWlnaHQnXSAhPSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdGlmIChlLmF0dHJpYnV0ZSgnaGVpZ2h0JykuaGFzVmFsdWUoKSkgeVJhdGlvID0gZS5hdHRyaWJ1dGUoJ2hlaWdodCcpLnRvUGl4ZWxzKCd5JykgLyBzdmcub3B0c1snc2NhbGVIZWlnaHQnXTtcclxuXHRcdFx0XHRcdFx0ZWxzZSBpZiAoIWlzTmFOKHZpZXdCb3hbM10pKSB5UmF0aW8gPSB2aWV3Qm94WzNdIC8gc3ZnLm9wdHNbJ3NjYWxlSGVpZ2h0J107XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKHhSYXRpbyA9PSBudWxsKSB7IHhSYXRpbyA9IHlSYXRpbzsgfVxyXG5cdFx0XHRcdFx0aWYgKHlSYXRpbyA9PSBudWxsKSB7IHlSYXRpbyA9IHhSYXRpbzsgfVxyXG5cclxuXHRcdFx0XHRcdGUuYXR0cmlidXRlKCd3aWR0aCcsIHRydWUpLnZhbHVlID0gc3ZnLm9wdHNbJ3NjYWxlV2lkdGgnXTtcclxuXHRcdFx0XHRcdGUuYXR0cmlidXRlKCdoZWlnaHQnLCB0cnVlKS52YWx1ZSA9IHN2Zy5vcHRzWydzY2FsZUhlaWdodCddO1xyXG5cdFx0XHRcdFx0ZS5zdHlsZSgndHJhbnNmb3JtJywgdHJ1ZSwgdHJ1ZSkudmFsdWUgKz0gJyBzY2FsZSgnKygxLjAveFJhdGlvKSsnLCcrKDEuMC95UmF0aW8pKycpJztcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIGNsZWFyIGFuZCByZW5kZXJcclxuXHRcdFx0XHRpZiAoc3ZnLm9wdHNbJ2lnbm9yZUNsZWFyJ10gIT0gdHJ1ZSkge1xyXG5cdFx0XHRcdFx0Y3R4LmNsZWFyUmVjdCgwLCAwLCBjV2lkdGgsIGNIZWlnaHQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlLnJlbmRlcihjdHgpO1xyXG5cdFx0XHRcdGlmIChpc0ZpcnN0UmVuZGVyKSB7XHJcblx0XHRcdFx0XHRpc0ZpcnN0UmVuZGVyID0gZmFsc2U7XHJcblx0XHRcdFx0XHRpZiAodHlwZW9mIHN2Zy5vcHRzWydyZW5kZXJDYWxsYmFjayddID09ICdmdW5jdGlvbicpIHN2Zy5vcHRzWydyZW5kZXJDYWxsYmFjayddKGRvbSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgd2FpdGluZ0ZvckltYWdlcyA9IHRydWU7XHJcblx0XHRcdGlmIChzdmcuSW1hZ2VzTG9hZGVkKCkpIHtcclxuXHRcdFx0XHR3YWl0aW5nRm9ySW1hZ2VzID0gZmFsc2U7XHJcblx0XHRcdFx0ZHJhdygpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHN2Zy5pbnRlcnZhbElEID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0dmFyIG5lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0XHRcdFx0aWYgKHdhaXRpbmdGb3JJbWFnZXMgJiYgc3ZnLkltYWdlc0xvYWRlZCgpKSB7XHJcblx0XHRcdFx0XHR3YWl0aW5nRm9ySW1hZ2VzID0gZmFsc2U7XHJcblx0XHRcdFx0XHRuZWVkVXBkYXRlID0gdHJ1ZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIG5lZWQgdXBkYXRlIGZyb20gbW91c2UgZXZlbnRzP1xyXG5cdFx0XHRcdGlmIChzdmcub3B0c1snaWdub3JlTW91c2UnXSAhPSB0cnVlKSB7XHJcblx0XHRcdFx0XHRuZWVkVXBkYXRlID0gbmVlZFVwZGF0ZSB8IHN2Zy5Nb3VzZS5oYXNFdmVudHMoKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIG5lZWQgdXBkYXRlIGZyb20gYW5pbWF0aW9ucz9cclxuXHRcdFx0XHRpZiAoc3ZnLm9wdHNbJ2lnbm9yZUFuaW1hdGlvbiddICE9IHRydWUpIHtcclxuXHRcdFx0XHRcdGZvciAodmFyIGk9MDsgaTxzdmcuQW5pbWF0aW9ucy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0XHRuZWVkVXBkYXRlID0gbmVlZFVwZGF0ZSB8IHN2Zy5BbmltYXRpb25zW2ldLnVwZGF0ZSgxMDAwIC8gc3ZnLkZSQU1FUkFURSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBuZWVkIHVwZGF0ZSBmcm9tIHJlZHJhdz9cclxuXHRcdFx0XHRpZiAodHlwZW9mIHN2Zy5vcHRzWydmb3JjZVJlZHJhdyddID09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0XHRcdGlmIChzdmcub3B0c1snZm9yY2VSZWRyYXcnXSgpID09IHRydWUpIG5lZWRVcGRhdGUgPSB0cnVlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gcmVuZGVyIGlmIG5lZWRlZFxyXG5cdFx0XHRcdGlmIChuZWVkVXBkYXRlKSB7XHJcblx0XHRcdFx0XHRkcmF3KCk7XHJcblx0XHRcdFx0XHRzdmcuTW91c2UucnVuRXZlbnRzKCk7IC8vIHJ1biBhbmQgY2xlYXIgb3VyIGV2ZW50c1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSwgMTAwMCAvIHN2Zy5GUkFNRVJBVEUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHN2Zy5zdG9wID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdGlmIChzdmcuaW50ZXJ2YWxJRCkge1xyXG5cdFx0XHRcdGNsZWFySW50ZXJ2YWwoc3ZnLmludGVydmFsSUQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0c3ZnLk1vdXNlID0gbmV3IChmdW5jdGlvbigpIHtcclxuXHRcdFx0dGhpcy5ldmVudHMgPSBbXTtcclxuXHRcdFx0dGhpcy5oYXNFdmVudHMgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuZXZlbnRzLmxlbmd0aCAhPSAwOyB9XHJcblxyXG5cdFx0XHR0aGlzLm9uY2xpY2sgPSBmdW5jdGlvbih4LCB5KSB7XHJcblx0XHRcdFx0dGhpcy5ldmVudHMucHVzaCh7IHR5cGU6ICdvbmNsaWNrJywgeDogeCwgeTogeSxcclxuXHRcdFx0XHRcdHJ1bjogZnVuY3Rpb24oZSkgeyBpZiAoZS5vbmNsaWNrKSBlLm9uY2xpY2soKTsgfVxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLm9ubW91c2Vtb3ZlID0gZnVuY3Rpb24oeCwgeSkge1xyXG5cdFx0XHRcdHRoaXMuZXZlbnRzLnB1c2goeyB0eXBlOiAnb25tb3VzZW1vdmUnLCB4OiB4LCB5OiB5LFxyXG5cdFx0XHRcdFx0cnVuOiBmdW5jdGlvbihlKSB7IGlmIChlLm9ubW91c2Vtb3ZlKSBlLm9ubW91c2Vtb3ZlKCk7IH1cclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5ldmVudEVsZW1lbnRzID0gW107XHJcblxyXG5cdFx0XHR0aGlzLmNoZWNrUGF0aCA9IGZ1bmN0aW9uKGVsZW1lbnQsIGN0eCkge1xyXG5cdFx0XHRcdGZvciAodmFyIGk9MDsgaTx0aGlzLmV2ZW50cy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0dmFyIGUgPSB0aGlzLmV2ZW50c1tpXTtcclxuXHRcdFx0XHRcdGlmIChjdHguaXNQb2ludEluUGF0aCAmJiBjdHguaXNQb2ludEluUGF0aChlLngsIGUueSkpIHRoaXMuZXZlbnRFbGVtZW50c1tpXSA9IGVsZW1lbnQ7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmNoZWNrQm91bmRpbmdCb3ggPSBmdW5jdGlvbihlbGVtZW50LCBiYikge1xyXG5cdFx0XHRcdGZvciAodmFyIGk9MDsgaTx0aGlzLmV2ZW50cy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0dmFyIGUgPSB0aGlzLmV2ZW50c1tpXTtcclxuXHRcdFx0XHRcdGlmIChiYi5pc1BvaW50SW5Cb3goZS54LCBlLnkpKSB0aGlzLmV2ZW50RWxlbWVudHNbaV0gPSBlbGVtZW50O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5ydW5FdmVudHMgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRzdmcuY3R4LmNhbnZhcy5zdHlsZS5jdXJzb3IgPSAnJztcclxuXHJcblx0XHRcdFx0Zm9yICh2YXIgaT0wOyBpPHRoaXMuZXZlbnRzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHR2YXIgZSA9IHRoaXMuZXZlbnRzW2ldO1xyXG5cdFx0XHRcdFx0dmFyIGVsZW1lbnQgPSB0aGlzLmV2ZW50RWxlbWVudHNbaV07XHJcblx0XHRcdFx0XHR3aGlsZSAoZWxlbWVudCkge1xyXG5cdFx0XHRcdFx0XHRlLnJ1bihlbGVtZW50KTtcclxuXHRcdFx0XHRcdFx0ZWxlbWVudCA9IGVsZW1lbnQucGFyZW50O1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gZG9uZSBydW5uaW5nLCBjbGVhclxyXG5cdFx0XHRcdHRoaXMuZXZlbnRzID0gW107XHJcblx0XHRcdFx0dGhpcy5ldmVudEVsZW1lbnRzID0gW107XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHRcdHJldHVybiBzdmc7XHJcblx0fTtcclxuXG5cdGlmICh0eXBlb2YgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEICAhPSAndW5kZWZpbmVkJykge1xyXG5cdFx0Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZS5kcmF3U3ZnID0gZnVuY3Rpb24ocywgZHgsIGR5LCBkdywgZGgsIG9wdHMpIHtcclxuXHRcdFx0dmFyIGNPcHRzID0ge1xuXHRcdFx0XHRpZ25vcmVNb3VzZTogdHJ1ZSxcclxuXHRcdFx0XHRpZ25vcmVBbmltYXRpb246IHRydWUsXHJcblx0XHRcdFx0aWdub3JlRGltZW5zaW9uczogdHJ1ZSxcclxuXHRcdFx0XHRpZ25vcmVDbGVhcjogdHJ1ZSxcclxuXHRcdFx0XHRvZmZzZXRYOiBkeCxcclxuXHRcdFx0XHRvZmZzZXRZOiBkeSxcclxuXHRcdFx0XHRzY2FsZVdpZHRoOiBkdyxcclxuXHRcdFx0XHRzY2FsZUhlaWdodDogZGhcclxuXHRcdFx0fVxyXG5cdFx0XHRcclxuXHRcdFx0Zm9yKHZhciBwcm9wIGluIG9wdHMpIHtcclxuXHRcdFx0XHRpZihvcHRzLmhhc093blByb3BlcnR5KHByb3ApKXtcclxuXHRcdFx0XHRcdGNPcHRzW3Byb3BdID0gb3B0c1twcm9wXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0Y2FudmcodGhpcy5jYW52YXMsIHMsIGNPcHRzKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiBjYW52ZztcclxuXHJcbn0pKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NhbnZnLW9yaWdpbi9jYW52Zy5qc1xuLy8gbW9kdWxlIGlkID0gOTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("var dsv = __webpack_require__(95),\r\n    sexagesimal = __webpack_require__(164);\r\n\r\nfunction isLat(f) { return !!f.match(/(Lat)(itude)?/gi); }\r\nfunction isLon(f) { return !!f.match(/(L)(on|ng)(gitude)?/i); }\r\n\r\nfunction keyCount(o) {\r\n    return (typeof o == 'object') ? Object.keys(o).length : 0;\r\n}\r\n\r\nfunction autoDelimiter(x) {\r\n    var delimiters = [',', ';', '\\t', '|'];\r\n    var results = [];\r\n\r\n    delimiters.forEach(function(delimiter) {\r\n        var res = dsv(delimiter).parse(x);\r\n        if (res.length >= 1) {\r\n            var count = keyCount(res[0]);\r\n            for (var i = 0; i < res.length; i++) {\r\n                if (keyCount(res[i]) !== count) return;\r\n            }\r\n            results.push({\r\n                delimiter: delimiter,\r\n                arity: Object.keys(res[0]).length,\r\n            });\r\n        }\r\n    });\r\n\r\n    if (results.length) {\r\n        return results.sort(function(a, b) {\r\n            return b.arity - a.arity;\r\n        })[0].delimiter;\r\n    } else {\r\n        return null;\r\n    }\r\n}\r\n\r\nfunction auto(x) {\r\n    var delimiter = autoDelimiter(x);\r\n    if (!delimiter) return null;\r\n    return dsv(delimiter).parse(x);\r\n}\r\n\r\nfunction csv2geojson(x, options, callback) {\r\n\r\n    if (!callback) {\r\n        callback = options;\r\n        options = {};\r\n    }\r\n\r\n    options.delimiter = options.delimiter || ',';\r\n\r\n    var latfield = options.latfield || '',\r\n        lonfield = options.lonfield || '',\r\n        crs = options.crs || '';\r\n\r\n    var features = [],\r\n        featurecollection = { type: 'FeatureCollection', features: features };\r\n\r\n    if (crs !== '') {\r\n        featurecollection.crs = { type: 'name', properties: { name: crs } };\r\n    }\r\n\r\n    if (options.delimiter === 'auto' && typeof x == 'string') {\r\n        options.delimiter = autoDelimiter(x);\r\n        if (!options.delimiter) return callback({\r\n            type: 'Error',\r\n            message: 'Could not autodetect delimiter'\r\n        });\r\n    }\r\n\r\n    var parsed = (typeof x == 'string') ? dsv(options.delimiter).parse(x) : x;\r\n\r\n    if (!parsed.length) return callback(null, featurecollection);\r\n\r\n    if (!latfield || !lonfield) {\r\n        for (var f in parsed[0]) {\r\n            if (!latfield && isLat(f)) latfield = f;\r\n            if (!lonfield && isLon(f)) lonfield = f;\r\n        }\r\n        if (!latfield || !lonfield) {\r\n            var fields = [];\r\n            for (var k in parsed[0]) fields.push(k);\r\n            return callback({\r\n                type: 'Error',\r\n                message: 'Latitude and longitude fields not present',\r\n                data: parsed,\r\n                fields: fields\r\n            });\r\n        }\r\n    }\r\n\r\n    var errors = [];\r\n\r\n    for (var i = 0; i < parsed.length; i++) {\r\n        if (parsed[i][lonfield] !== undefined &&\r\n            parsed[i][lonfield] !== undefined) {\r\n\r\n            var lonk = parsed[i][lonfield],\r\n                latk = parsed[i][latfield],\r\n                lonf, latf,\r\n                a;\r\n\r\n            a = sexagesimal(lonk, 'EW');\r\n            if (a) lonk = a;\r\n            a = sexagesimal(latk, 'NS');\r\n            if (a) latk = a;\r\n\r\n            lonf = parseFloat(lonk);\r\n            latf = parseFloat(latk);\r\n\r\n            if (isNaN(lonf) ||\r\n                isNaN(latf)) {\r\n                errors.push({\r\n                    message: 'A row contained an invalid value for latitude or longitude',\r\n                    row: parsed[i]\r\n                });\r\n            } else {\r\n                if (!options.includeLatLon) {\r\n                    delete parsed[i][lonfield];\r\n                    delete parsed[i][latfield];\r\n                }\r\n\r\n                features.push({\r\n                    type: 'Feature',\r\n                    properties: parsed[i],\r\n                    geometry: {\r\n                        type: 'Point',\r\n                        coordinates: [\r\n                            parseFloat(lonf),\r\n                            parseFloat(latf)\r\n                        ]\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    callback(errors.length ? errors: null, featurecollection);\r\n}\r\n\r\nfunction toLine(gj) {\r\n    var features = gj.features;\r\n    var line = {\r\n        type: 'Feature',\r\n        geometry: {\r\n            type: 'LineString',\r\n            coordinates: []\r\n        }\r\n    };\r\n    for (var i = 0; i < features.length; i++) {\r\n        line.geometry.coordinates.push(features[i].geometry.coordinates);\r\n    }\r\n    line.properties = features.reduce(function(aggregatedProperties, newFeature) {\r\n      for (var key in newFeature.properties) {\r\n        if (!aggregatedProperties[key]) {\r\n          aggregatedProperties[key] = [];\r\n        }\r\n        aggregatedProperties[key].push(newFeature.properties[key]);\r\n      }\r\n      return aggregatedProperties;\r\n    }, {});\r\n    return {\r\n        type: 'FeatureCollection',\r\n        features: [line]\r\n    };\r\n}\r\n\r\nfunction toPolygon(gj) {\r\n    var features = gj.features;\r\n    var poly = {\r\n        type: 'Feature',\r\n        geometry: {\r\n            type: 'Polygon',\r\n            coordinates: [[]]\r\n        }\r\n    };\r\n    for (var i = 0; i < features.length; i++) {\r\n        poly.geometry.coordinates[0].push(features[i].geometry.coordinates);\r\n    }\r\n    poly.properties = features.reduce(function(aggregatedProperties, newFeature) {\r\n      for (var key in newFeature.properties) {\r\n        if (!aggregatedProperties[key]) {\r\n          aggregatedProperties[key] = [];\r\n        }\r\n        aggregatedProperties[key].push(newFeature.properties[key]);\r\n      }\r\n      return aggregatedProperties;\r\n    }, {});\r\n    return {\r\n        type: 'FeatureCollection',\r\n        features: [poly]\r\n    };\r\n}\r\n\r\nmodule.exports = {\r\n    isLon: isLon,\r\n    isLat: isLat,\r\n    csv: dsv.csv.parse,\r\n    tsv: dsv.tsv.parse,\r\n    dsv: dsv,\r\n    auto: auto,\r\n    csv2geojson: csv2geojson,\r\n    toLine: toLine,\r\n    toPolygon: toPolygon\r\n};\r\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2NzdjJnZW9qc29uL2luZGV4LmpzPzQxMDQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQSxtQkFBbUIscUNBQXFDO0FBQ3hELG1CQUFtQiwwQ0FBMEM7O0FBRTdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixnQkFBZ0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0EsaUNBQWlDLDRCQUE0QixZQUFZO0FBQ3pFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ijk0LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGRzdiA9IHJlcXVpcmUoJ2RzdicpLFxyXG4gICAgc2V4YWdlc2ltYWwgPSByZXF1aXJlKCdzZXhhZ2VzaW1hbCcpO1xyXG5cclxuZnVuY3Rpb24gaXNMYXQoZikgeyByZXR1cm4gISFmLm1hdGNoKC8oTGF0KShpdHVkZSk/L2dpKTsgfVxyXG5mdW5jdGlvbiBpc0xvbihmKSB7IHJldHVybiAhIWYubWF0Y2goLyhMKShvbnxuZykoZ2l0dWRlKT8vaSk7IH1cclxuXHJcbmZ1bmN0aW9uIGtleUNvdW50KG8pIHtcclxuICAgIHJldHVybiAodHlwZW9mIG8gPT0gJ29iamVjdCcpID8gT2JqZWN0LmtleXMobykubGVuZ3RoIDogMDtcclxufVxyXG5cclxuZnVuY3Rpb24gYXV0b0RlbGltaXRlcih4KSB7XHJcbiAgICB2YXIgZGVsaW1pdGVycyA9IFsnLCcsICc7JywgJ1xcdCcsICd8J107XHJcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xyXG5cclxuICAgIGRlbGltaXRlcnMuZm9yRWFjaChmdW5jdGlvbihkZWxpbWl0ZXIpIHtcclxuICAgICAgICB2YXIgcmVzID0gZHN2KGRlbGltaXRlcikucGFyc2UoeCk7XHJcbiAgICAgICAgaWYgKHJlcy5sZW5ndGggPj0gMSkge1xyXG4gICAgICAgICAgICB2YXIgY291bnQgPSBrZXlDb3VudChyZXNbMF0pO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGtleUNvdW50KHJlc1tpXSkgIT09IGNvdW50KSByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIGRlbGltaXRlcjogZGVsaW1pdGVyLFxyXG4gICAgICAgICAgICAgICAgYXJpdHk6IE9iamVjdC5rZXlzKHJlc1swXSkubGVuZ3RoLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAocmVzdWx0cy5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gcmVzdWx0cy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGIuYXJpdHkgLSBhLmFyaXR5O1xyXG4gICAgICAgIH0pWzBdLmRlbGltaXRlcjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGF1dG8oeCkge1xyXG4gICAgdmFyIGRlbGltaXRlciA9IGF1dG9EZWxpbWl0ZXIoeCk7XHJcbiAgICBpZiAoIWRlbGltaXRlcikgcmV0dXJuIG51bGw7XHJcbiAgICByZXR1cm4gZHN2KGRlbGltaXRlcikucGFyc2UoeCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNzdjJnZW9qc29uKHgsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XHJcblxyXG4gICAgaWYgKCFjYWxsYmFjaykge1xyXG4gICAgICAgIGNhbGxiYWNrID0gb3B0aW9ucztcclxuICAgICAgICBvcHRpb25zID0ge307XHJcbiAgICB9XHJcblxyXG4gICAgb3B0aW9ucy5kZWxpbWl0ZXIgPSBvcHRpb25zLmRlbGltaXRlciB8fCAnLCc7XHJcblxyXG4gICAgdmFyIGxhdGZpZWxkID0gb3B0aW9ucy5sYXRmaWVsZCB8fCAnJyxcclxuICAgICAgICBsb25maWVsZCA9IG9wdGlvbnMubG9uZmllbGQgfHwgJycsXHJcbiAgICAgICAgY3JzID0gb3B0aW9ucy5jcnMgfHwgJyc7XHJcblxyXG4gICAgdmFyIGZlYXR1cmVzID0gW10sXHJcbiAgICAgICAgZmVhdHVyZWNvbGxlY3Rpb24gPSB7IHR5cGU6ICdGZWF0dXJlQ29sbGVjdGlvbicsIGZlYXR1cmVzOiBmZWF0dXJlcyB9O1xyXG5cclxuICAgIGlmIChjcnMgIT09ICcnKSB7XHJcbiAgICAgICAgZmVhdHVyZWNvbGxlY3Rpb24uY3JzID0geyB0eXBlOiAnbmFtZScsIHByb3BlcnRpZXM6IHsgbmFtZTogY3JzIH0gfTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAob3B0aW9ucy5kZWxpbWl0ZXIgPT09ICdhdXRvJyAmJiB0eXBlb2YgeCA9PSAnc3RyaW5nJykge1xyXG4gICAgICAgIG9wdGlvbnMuZGVsaW1pdGVyID0gYXV0b0RlbGltaXRlcih4KTtcclxuICAgICAgICBpZiAoIW9wdGlvbnMuZGVsaW1pdGVyKSByZXR1cm4gY2FsbGJhY2soe1xyXG4gICAgICAgICAgICB0eXBlOiAnRXJyb3InLFxyXG4gICAgICAgICAgICBtZXNzYWdlOiAnQ291bGQgbm90IGF1dG9kZXRlY3QgZGVsaW1pdGVyJ1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBwYXJzZWQgPSAodHlwZW9mIHggPT0gJ3N0cmluZycpID8gZHN2KG9wdGlvbnMuZGVsaW1pdGVyKS5wYXJzZSh4KSA6IHg7XHJcblxyXG4gICAgaWYgKCFwYXJzZWQubGVuZ3RoKSByZXR1cm4gY2FsbGJhY2sobnVsbCwgZmVhdHVyZWNvbGxlY3Rpb24pO1xyXG5cclxuICAgIGlmICghbGF0ZmllbGQgfHwgIWxvbmZpZWxkKSB7XHJcbiAgICAgICAgZm9yICh2YXIgZiBpbiBwYXJzZWRbMF0pIHtcclxuICAgICAgICAgICAgaWYgKCFsYXRmaWVsZCAmJiBpc0xhdChmKSkgbGF0ZmllbGQgPSBmO1xyXG4gICAgICAgICAgICBpZiAoIWxvbmZpZWxkICYmIGlzTG9uKGYpKSBsb25maWVsZCA9IGY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbGF0ZmllbGQgfHwgIWxvbmZpZWxkKSB7XHJcbiAgICAgICAgICAgIHZhciBmaWVsZHMgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgayBpbiBwYXJzZWRbMF0pIGZpZWxkcy5wdXNoKGspO1xyXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ0Vycm9yJyxcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdMYXRpdHVkZSBhbmQgbG9uZ2l0dWRlIGZpZWxkcyBub3QgcHJlc2VudCcsXHJcbiAgICAgICAgICAgICAgICBkYXRhOiBwYXJzZWQsXHJcbiAgICAgICAgICAgICAgICBmaWVsZHM6IGZpZWxkc1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGVycm9ycyA9IFtdO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyc2VkLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKHBhcnNlZFtpXVtsb25maWVsZF0gIT09IHVuZGVmaW5lZCAmJlxyXG4gICAgICAgICAgICBwYXJzZWRbaV1bbG9uZmllbGRdICE9PSB1bmRlZmluZWQpIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBsb25rID0gcGFyc2VkW2ldW2xvbmZpZWxkXSxcclxuICAgICAgICAgICAgICAgIGxhdGsgPSBwYXJzZWRbaV1bbGF0ZmllbGRdLFxyXG4gICAgICAgICAgICAgICAgbG9uZiwgbGF0ZixcclxuICAgICAgICAgICAgICAgIGE7XHJcblxyXG4gICAgICAgICAgICBhID0gc2V4YWdlc2ltYWwobG9uaywgJ0VXJyk7XHJcbiAgICAgICAgICAgIGlmIChhKSBsb25rID0gYTtcclxuICAgICAgICAgICAgYSA9IHNleGFnZXNpbWFsKGxhdGssICdOUycpO1xyXG4gICAgICAgICAgICBpZiAoYSkgbGF0ayA9IGE7XHJcblxyXG4gICAgICAgICAgICBsb25mID0gcGFyc2VGbG9hdChsb25rKTtcclxuICAgICAgICAgICAgbGF0ZiA9IHBhcnNlRmxvYXQobGF0ayk7XHJcblxyXG4gICAgICAgICAgICBpZiAoaXNOYU4obG9uZikgfHxcclxuICAgICAgICAgICAgICAgIGlzTmFOKGxhdGYpKSB7XHJcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ0Egcm93IGNvbnRhaW5lZCBhbiBpbnZhbGlkIHZhbHVlIGZvciBsYXRpdHVkZSBvciBsb25naXR1ZGUnLFxyXG4gICAgICAgICAgICAgICAgICAgIHJvdzogcGFyc2VkW2ldXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5pbmNsdWRlTGF0TG9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHBhcnNlZFtpXVtsb25maWVsZF07XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHBhcnNlZFtpXVtsYXRmaWVsZF07XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgZmVhdHVyZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0ZlYXR1cmUnLFxyXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHBhcnNlZFtpXSxcclxuICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnUG9pbnQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlczogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VGbG9hdChsb25mKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQobGF0ZilcclxuICAgICAgICAgICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNhbGxiYWNrKGVycm9ycy5sZW5ndGggPyBlcnJvcnM6IG51bGwsIGZlYXR1cmVjb2xsZWN0aW9uKTtcclxufVxyXG5cclxuZnVuY3Rpb24gdG9MaW5lKGdqKSB7XHJcbiAgICB2YXIgZmVhdHVyZXMgPSBnai5mZWF0dXJlcztcclxuICAgIHZhciBsaW5lID0ge1xyXG4gICAgICAgIHR5cGU6ICdGZWF0dXJlJyxcclxuICAgICAgICBnZW9tZXRyeToge1xyXG4gICAgICAgICAgICB0eXBlOiAnTGluZVN0cmluZycsXHJcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBbXVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbGluZS5nZW9tZXRyeS5jb29yZGluYXRlcy5wdXNoKGZlYXR1cmVzW2ldLmdlb21ldHJ5LmNvb3JkaW5hdGVzKTtcclxuICAgIH1cclxuICAgIGxpbmUucHJvcGVydGllcyA9IGZlYXR1cmVzLnJlZHVjZShmdW5jdGlvbihhZ2dyZWdhdGVkUHJvcGVydGllcywgbmV3RmVhdHVyZSkge1xyXG4gICAgICBmb3IgKHZhciBrZXkgaW4gbmV3RmVhdHVyZS5wcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgaWYgKCFhZ2dyZWdhdGVkUHJvcGVydGllc1trZXldKSB7XHJcbiAgICAgICAgICBhZ2dyZWdhdGVkUHJvcGVydGllc1trZXldID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFnZ3JlZ2F0ZWRQcm9wZXJ0aWVzW2tleV0ucHVzaChuZXdGZWF0dXJlLnByb3BlcnRpZXNba2V5XSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGFnZ3JlZ2F0ZWRQcm9wZXJ0aWVzO1xyXG4gICAgfSwge30pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAnRmVhdHVyZUNvbGxlY3Rpb24nLFxyXG4gICAgICAgIGZlYXR1cmVzOiBbbGluZV1cclxuICAgIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRvUG9seWdvbihnaikge1xyXG4gICAgdmFyIGZlYXR1cmVzID0gZ2ouZmVhdHVyZXM7XHJcbiAgICB2YXIgcG9seSA9IHtcclxuICAgICAgICB0eXBlOiAnRmVhdHVyZScsXHJcbiAgICAgICAgZ2VvbWV0cnk6IHtcclxuICAgICAgICAgICAgdHlwZTogJ1BvbHlnb24nLFxyXG4gICAgICAgICAgICBjb29yZGluYXRlczogW1tdXVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgcG9seS5nZW9tZXRyeS5jb29yZGluYXRlc1swXS5wdXNoKGZlYXR1cmVzW2ldLmdlb21ldHJ5LmNvb3JkaW5hdGVzKTtcclxuICAgIH1cclxuICAgIHBvbHkucHJvcGVydGllcyA9IGZlYXR1cmVzLnJlZHVjZShmdW5jdGlvbihhZ2dyZWdhdGVkUHJvcGVydGllcywgbmV3RmVhdHVyZSkge1xyXG4gICAgICBmb3IgKHZhciBrZXkgaW4gbmV3RmVhdHVyZS5wcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgaWYgKCFhZ2dyZWdhdGVkUHJvcGVydGllc1trZXldKSB7XHJcbiAgICAgICAgICBhZ2dyZWdhdGVkUHJvcGVydGllc1trZXldID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFnZ3JlZ2F0ZWRQcm9wZXJ0aWVzW2tleV0ucHVzaChuZXdGZWF0dXJlLnByb3BlcnRpZXNba2V5XSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGFnZ3JlZ2F0ZWRQcm9wZXJ0aWVzO1xyXG4gICAgfSwge30pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiAnRmVhdHVyZUNvbGxlY3Rpb24nLFxyXG4gICAgICAgIGZlYXR1cmVzOiBbcG9seV1cclxuICAgIH07XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgaXNMb246IGlzTG9uLFxyXG4gICAgaXNMYXQ6IGlzTGF0LFxyXG4gICAgY3N2OiBkc3YuY3N2LnBhcnNlLFxyXG4gICAgdHN2OiBkc3YudHN2LnBhcnNlLFxyXG4gICAgZHN2OiBkc3YsXHJcbiAgICBhdXRvOiBhdXRvLFxyXG4gICAgY3N2Mmdlb2pzb246IGNzdjJnZW9qc29uLFxyXG4gICAgdG9MaW5lOiB0b0xpbmUsXHJcbiAgICB0b1BvbHlnb246IHRvUG9seWdvblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3N2Mmdlb2pzb24vaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDk0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(__dirname) {var fs = __webpack_require__(175);\n\nmodule.exports = new Function(fs.readFileSync(__dirname + "/dsv.js", "utf8") + ";return dsv")();\n\n/* WEBPACK VAR INJECTION */}.call(exports, "/"))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Rzdi9pbmRleC5qcz9jNDM3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLGlGQUFpRiIsImZpbGUiOiI5NS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgRnVuY3Rpb24oZnMucmVhZEZpbGVTeW5jKF9fZGlybmFtZSArIFwiL2Rzdi5qc1wiLCBcInV0ZjhcIikgKyBcIjtyZXR1cm4gZHN2XCIpKCk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZHN2L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA5NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9')},function(module,exports,__webpack_require__){"use strict";eval('\n\nvar utils = __webpack_require__(1);\n\nvar table = [\n    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA,\n    0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,\n    0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,\n    0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91,\n    0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE,\n    0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,\n    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC,\n    0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5,\n    0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,\n    0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,\n    0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940,\n    0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,\n    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116,\n    0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,\n    0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,\n    0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,\n    0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A,\n    0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,\n    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818,\n    0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,\n    0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,\n    0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457,\n    0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C,\n    0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,\n    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2,\n    0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB,\n    0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,\n    0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,\n    0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086,\n    0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,\n    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4,\n    0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD,\n    0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,\n    0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683,\n    0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8,\n    0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,\n    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE,\n    0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7,\n    0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,\n    0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,\n    0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252,\n    0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,\n    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60,\n    0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79,\n    0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,\n    0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F,\n    0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04,\n    0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,\n    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A,\n    0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,\n    0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,\n    0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21,\n    0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E,\n    0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,\n    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C,\n    0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,\n    0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,\n    0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB,\n    0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0,\n    0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,\n    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6,\n    0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF,\n    0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,\n    0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D\n];\n\n/**\n *\n *  Javascript crc32\n *  http://www.webtoolkit.info/\n *\n */\nmodule.exports = function crc32(input, crc) {\n    if (typeof input === "undefined" || !input.length) {\n        return 0;\n    }\n\n    var isArray = utils.getTypeOf(input) !== "string";\n\n    if (typeof(crc) == "undefined") {\n        crc = 0;\n    }\n    var x = 0;\n    var y = 0;\n    var b = 0;\n\n    crc = crc ^ (-1);\n    for (var i = 0, iTop = input.length; i < iTop; i++) {\n        b = isArray ? input[i] : input.charCodeAt(i);\n        y = (crc ^ b) & 0xFF;\n        x = table[y];\n        crc = (crc >>> 8) ^ x;\n    }\n\n    return crc ^ (-1);\n};\n// vim: set shiftwidth=4 softtabstop=4:\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2pzemlwL2xpYi9jcmMzMi5qcz84MDc3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0MsVUFBVTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsImZpbGUiOiI5Ni5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG52YXIgdGFibGUgPSBbXG4gICAgMHgwMDAwMDAwMCwgMHg3NzA3MzA5NiwgMHhFRTBFNjEyQywgMHg5OTA5NTFCQSxcbiAgICAweDA3NkRDNDE5LCAweDcwNkFGNDhGLCAweEU5NjNBNTM1LCAweDlFNjQ5NUEzLFxuICAgIDB4MEVEQjg4MzIsIDB4NzlEQ0I4QTQsIDB4RTBENUU5MUUsIDB4OTdEMkQ5ODgsXG4gICAgMHgwOUI2NEMyQiwgMHg3RUIxN0NCRCwgMHhFN0I4MkQwNywgMHg5MEJGMUQ5MSxcbiAgICAweDFEQjcxMDY0LCAweDZBQjAyMEYyLCAweEYzQjk3MTQ4LCAweDg0QkU0MURFLFxuICAgIDB4MUFEQUQ0N0QsIDB4NkREREU0RUIsIDB4RjRENEI1NTEsIDB4ODNEMzg1QzcsXG4gICAgMHgxMzZDOTg1NiwgMHg2NDZCQThDMCwgMHhGRDYyRjk3QSwgMHg4QTY1QzlFQyxcbiAgICAweDE0MDE1QzRGLCAweDYzMDY2Q0Q5LCAweEZBMEYzRDYzLCAweDhEMDgwREY1LFxuICAgIDB4M0I2RTIwQzgsIDB4NEM2OTEwNUUsIDB4RDU2MDQxRTQsIDB4QTI2NzcxNzIsXG4gICAgMHgzQzAzRTREMSwgMHg0QjA0RDQ0NywgMHhEMjBEODVGRCwgMHhBNTBBQjU2QixcbiAgICAweDM1QjVBOEZBLCAweDQyQjI5ODZDLCAweERCQkJDOUQ2LCAweEFDQkNGOTQwLFxuICAgIDB4MzJEODZDRTMsIDB4NDVERjVDNzUsIDB4RENENjBEQ0YsIDB4QUJEMTNENTksXG4gICAgMHgyNkQ5MzBBQywgMHg1MURFMDAzQSwgMHhDOEQ3NTE4MCwgMHhCRkQwNjExNixcbiAgICAweDIxQjRGNEI1LCAweDU2QjNDNDIzLCAweENGQkE5NTk5LCAweEI4QkRBNTBGLFxuICAgIDB4MjgwMkI4OUUsIDB4NUYwNTg4MDgsIDB4QzYwQ0Q5QjIsIDB4QjEwQkU5MjQsXG4gICAgMHgyRjZGN0M4NywgMHg1ODY4NEMxMSwgMHhDMTYxMURBQiwgMHhCNjY2MkQzRCxcbiAgICAweDc2REM0MTkwLCAweDAxREI3MTA2LCAweDk4RDIyMEJDLCAweEVGRDUxMDJBLFxuICAgIDB4NzFCMTg1ODksIDB4MDZCNkI1MUYsIDB4OUZCRkU0QTUsIDB4RThCOEQ0MzMsXG4gICAgMHg3ODA3QzlBMiwgMHgwRjAwRjkzNCwgMHg5NjA5QTg4RSwgMHhFMTBFOTgxOCxcbiAgICAweDdGNkEwREJCLCAweDA4NkQzRDJELCAweDkxNjQ2Qzk3LCAweEU2NjM1QzAxLFxuICAgIDB4NkI2QjUxRjQsIDB4MUM2QzYxNjIsIDB4ODU2NTMwRDgsIDB4RjI2MjAwNEUsXG4gICAgMHg2QzA2OTVFRCwgMHgxQjAxQTU3QiwgMHg4MjA4RjRDMSwgMHhGNTBGQzQ1NyxcbiAgICAweDY1QjBEOUM2LCAweDEyQjdFOTUwLCAweDhCQkVCOEVBLCAweEZDQjk4ODdDLFxuICAgIDB4NjJERDFEREYsIDB4MTVEQTJENDksIDB4OENEMzdDRjMsIDB4RkJENDRDNjUsXG4gICAgMHg0REIyNjE1OCwgMHgzQUI1NTFDRSwgMHhBM0JDMDA3NCwgMHhENEJCMzBFMixcbiAgICAweDRBREZBNTQxLCAweDNERDg5NUQ3LCAweEE0RDFDNDZELCAweEQzRDZGNEZCLFxuICAgIDB4NDM2OUU5NkEsIDB4MzQ2RUQ5RkMsIDB4QUQ2Nzg4NDYsIDB4REE2MEI4RDAsXG4gICAgMHg0NDA0MkQ3MywgMHgzMzAzMURFNSwgMHhBQTBBNEM1RiwgMHhERDBEN0NDOSxcbiAgICAweDUwMDU3MTNDLCAweDI3MDI0MUFBLCAweEJFMEIxMDEwLCAweEM5MEMyMDg2LFxuICAgIDB4NTc2OEI1MjUsIDB4MjA2Rjg1QjMsIDB4Qjk2NkQ0MDksIDB4Q0U2MUU0OUYsXG4gICAgMHg1RURFRjkwRSwgMHgyOUQ5Qzk5OCwgMHhCMEQwOTgyMiwgMHhDN0Q3QThCNCxcbiAgICAweDU5QjMzRDE3LCAweDJFQjQwRDgxLCAweEI3QkQ1QzNCLCAweEMwQkE2Q0FELFxuICAgIDB4RURCODgzMjAsIDB4OUFCRkIzQjYsIDB4MDNCNkUyMEMsIDB4NzRCMUQyOUEsXG4gICAgMHhFQUQ1NDczOSwgMHg5REQyNzdBRiwgMHgwNERCMjYxNSwgMHg3M0RDMTY4MyxcbiAgICAweEUzNjMwQjEyLCAweDk0NjQzQjg0LCAweDBENkQ2QTNFLCAweDdBNkE1QUE4LFxuICAgIDB4RTQwRUNGMEIsIDB4OTMwOUZGOUQsIDB4MEEwMEFFMjcsIDB4N0QwNzlFQjEsXG4gICAgMHhGMDBGOTM0NCwgMHg4NzA4QTNEMiwgMHgxRTAxRjI2OCwgMHg2OTA2QzJGRSxcbiAgICAweEY3NjI1NzVELCAweDgwNjU2N0NCLCAweDE5NkMzNjcxLCAweDZFNkIwNkU3LFxuICAgIDB4RkVENDFCNzYsIDB4ODlEMzJCRTAsIDB4MTBEQTdBNUEsIDB4NjdERDRBQ0MsXG4gICAgMHhGOUI5REY2RiwgMHg4RUJFRUZGOSwgMHgxN0I3QkU0MywgMHg2MEIwOEVENSxcbiAgICAweEQ2RDZBM0U4LCAweEExRDE5MzdFLCAweDM4RDhDMkM0LCAweDRGREZGMjUyLFxuICAgIDB4RDFCQjY3RjEsIDB4QTZCQzU3NjcsIDB4M0ZCNTA2REQsIDB4NDhCMjM2NEIsXG4gICAgMHhEODBEMkJEQSwgMHhBRjBBMUI0QywgMHgzNjAzNEFGNiwgMHg0MTA0N0E2MCxcbiAgICAweERGNjBFRkMzLCAweEE4NjdERjU1LCAweDMxNkU4RUVGLCAweDQ2NjlCRTc5LFxuICAgIDB4Q0I2MUIzOEMsIDB4QkM2NjgzMUEsIDB4MjU2RkQyQTAsIDB4NTI2OEUyMzYsXG4gICAgMHhDQzBDNzc5NSwgMHhCQjBCNDcwMywgMHgyMjAyMTZCOSwgMHg1NTA1MjYyRixcbiAgICAweEM1QkEzQkJFLCAweEIyQkQwQjI4LCAweDJCQjQ1QTkyLCAweDVDQjM2QTA0LFxuICAgIDB4QzJEN0ZGQTcsIDB4QjVEMENGMzEsIDB4MkNEOTlFOEIsIDB4NUJERUFFMUQsXG4gICAgMHg5QjY0QzJCMCwgMHhFQzYzRjIyNiwgMHg3NTZBQTM5QywgMHgwMjZEOTMwQSxcbiAgICAweDlDMDkwNkE5LCAweEVCMEUzNjNGLCAweDcyMDc2Nzg1LCAweDA1MDA1NzEzLFxuICAgIDB4OTVCRjRBODIsIDB4RTJCODdBMTQsIDB4N0JCMTJCQUUsIDB4MENCNjFCMzgsXG4gICAgMHg5MkQyOEU5QiwgMHhFNUQ1QkUwRCwgMHg3Q0RDRUZCNywgMHgwQkRCREYyMSxcbiAgICAweDg2RDNEMkQ0LCAweEYxRDRFMjQyLCAweDY4RERCM0Y4LCAweDFGREE4MzZFLFxuICAgIDB4ODFCRTE2Q0QsIDB4RjZCOTI2NUIsIDB4NkZCMDc3RTEsIDB4MThCNzQ3NzcsXG4gICAgMHg4ODA4NUFFNiwgMHhGRjBGNkE3MCwgMHg2NjA2M0JDQSwgMHgxMTAxMEI1QyxcbiAgICAweDhGNjU5RUZGLCAweEY4NjJBRTY5LCAweDYxNkJGRkQzLCAweDE2NkNDRjQ1LFxuICAgIDB4QTAwQUUyNzgsIDB4RDcwREQyRUUsIDB4NEUwNDgzNTQsIDB4MzkwM0IzQzIsXG4gICAgMHhBNzY3MjY2MSwgMHhEMDYwMTZGNywgMHg0OTY5NDc0RCwgMHgzRTZFNzdEQixcbiAgICAweEFFRDE2QTRBLCAweEQ5RDY1QURDLCAweDQwREYwQjY2LCAweDM3RDgzQkYwLFxuICAgIDB4QTlCQ0FFNTMsIDB4REVCQjlFQzUsIDB4NDdCMkNGN0YsIDB4MzBCNUZGRTksXG4gICAgMHhCREJERjIxQywgMHhDQUJBQzI4QSwgMHg1M0IzOTMzMCwgMHgyNEI0QTNBNixcbiAgICAweEJBRDAzNjA1LCAweENERDcwNjkzLCAweDU0REU1NzI5LCAweDIzRDk2N0JGLFxuICAgIDB4QjM2NjdBMkUsIDB4QzQ2MTRBQjgsIDB4NUQ2ODFCMDIsIDB4MkE2RjJCOTQsXG4gICAgMHhCNDBCQkUzNywgMHhDMzBDOEVBMSwgMHg1QTA1REYxQiwgMHgyRDAyRUY4RFxuXTtcblxuLyoqXG4gKlxuICogIEphdmFzY3JpcHQgY3JjMzJcbiAqICBodHRwOi8vd3d3LndlYnRvb2xraXQuaW5mby9cbiAqXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JjMzIoaW5wdXQsIGNyYykge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09IFwidW5kZWZpbmVkXCIgfHwgIWlucHV0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICB2YXIgaXNBcnJheSA9IHV0aWxzLmdldFR5cGVPZihpbnB1dCkgIT09IFwic3RyaW5nXCI7XG5cbiAgICBpZiAodHlwZW9mKGNyYykgPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBjcmMgPSAwO1xuICAgIH1cbiAgICB2YXIgeCA9IDA7XG4gICAgdmFyIHkgPSAwO1xuICAgIHZhciBiID0gMDtcblxuICAgIGNyYyA9IGNyYyBeICgtMSk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlUb3AgPSBpbnB1dC5sZW5ndGg7IGkgPCBpVG9wOyBpKyspIHtcbiAgICAgICAgYiA9IGlzQXJyYXkgPyBpbnB1dFtpXSA6IGlucHV0LmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIHkgPSAoY3JjIF4gYikgJiAweEZGO1xuICAgICAgICB4ID0gdGFibGVbeV07XG4gICAgICAgIGNyYyA9IChjcmMgPj4+IDgpIF4geDtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JjIF4gKC0xKTtcbn07XG4vLyB2aW06IHNldCBzaGlmdHdpZHRoPTQgc29mdHRhYnN0b3A9NDpcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9qc3ppcC9saWIvY3JjMzIuanNcbi8vIG1vZHVsZSBpZCA9IDk2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,exports,__webpack_require__){"use strict";eval('\nvar utils = __webpack_require__(1);\n\n/**\n * @deprecated\n * This function will be removed in a future version without replacement.\n */\nexports.string2binary = function(str) {\n    return utils.string2binary(str);\n};\n\n/**\n * @deprecated\n * This function will be removed in a future version without replacement.\n */\nexports.string2Uint8Array = function(str) {\n    return utils.transformTo("uint8array", str);\n};\n\n/**\n * @deprecated\n * This function will be removed in a future version without replacement.\n */\nexports.uint8Array2String = function(array) {\n    return utils.transformTo("string", array);\n};\n\n/**\n * @deprecated\n * This function will be removed in a future version without replacement.\n */\nexports.string2Blob = function(str) {\n    var buffer = utils.transformTo("arraybuffer", str);\n    return utils.arrayBuffer2Blob(buffer);\n};\n\n/**\n * @deprecated\n * This function will be removed in a future version without replacement.\n */\nexports.arrayBuffer2Blob = function(buffer) {\n    return utils.arrayBuffer2Blob(buffer);\n};\n\n/**\n * @deprecated\n * This function will be removed in a future version without replacement.\n */\nexports.transformTo = function(outputType, input) {\n    return utils.transformTo(outputType, input);\n};\n\n/**\n * @deprecated\n * This function will be removed in a future version without replacement.\n */\nexports.getTypeOf = function(input) {\n    return utils.getTypeOf(input);\n};\n\n/**\n * @deprecated\n * This function will be removed in a future version without replacement.\n */\nexports.checkSupport = function(type) {\n    return utils.checkSupport(type);\n};\n\n/**\n * @deprecated\n * This value will be removed in a future version without replacement.\n */\nexports.MAX_VALUE_16BITS = utils.MAX_VALUE_16BITS;\n\n/**\n * @deprecated\n * This value will be removed in a future version without replacement.\n */\nexports.MAX_VALUE_32BITS = utils.MAX_VALUE_32BITS;\n\n\n/**\n * @deprecated\n * This function will be removed in a future version without replacement.\n */\nexports.pretty = function(str) {\n    return utils.pretty(str);\n};\n\n/**\n * @deprecated\n * This function will be removed in a future version without replacement.\n */\nexports.findCompression = function(compressionMethod) {\n    return utils.findCompression(compressionMethod);\n};\n\n/**\n * @deprecated\n * This function will be removed in a future version without replacement.\n */\nexports.isRegExp = function (object) {\n    return utils.isRegExp(object);\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2pzemlwL2xpYi9kZXByZWNhdGVkUHVibGljVXRpbHMuanM/OGE5MyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI5Ny5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbiB3aXRob3V0IHJlcGxhY2VtZW50LlxuICovXG5leHBvcnRzLnN0cmluZzJiaW5hcnkgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gdXRpbHMuc3RyaW5nMmJpbmFyeShzdHIpO1xufTtcblxuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbiB3aXRob3V0IHJlcGxhY2VtZW50LlxuICovXG5leHBvcnRzLnN0cmluZzJVaW50OEFycmF5ID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIHV0aWxzLnRyYW5zZm9ybVRvKFwidWludDhhcnJheVwiLCBzdHIpO1xufTtcblxuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbiB3aXRob3V0IHJlcGxhY2VtZW50LlxuICovXG5leHBvcnRzLnVpbnQ4QXJyYXkyU3RyaW5nID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICByZXR1cm4gdXRpbHMudHJhbnNmb3JtVG8oXCJzdHJpbmdcIiwgYXJyYXkpO1xufTtcblxuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbiB3aXRob3V0IHJlcGxhY2VtZW50LlxuICovXG5leHBvcnRzLnN0cmluZzJCbG9iID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgdmFyIGJ1ZmZlciA9IHV0aWxzLnRyYW5zZm9ybVRvKFwiYXJyYXlidWZmZXJcIiwgc3RyKTtcbiAgICByZXR1cm4gdXRpbHMuYXJyYXlCdWZmZXIyQmxvYihidWZmZXIpO1xufTtcblxuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbiB3aXRob3V0IHJlcGxhY2VtZW50LlxuICovXG5leHBvcnRzLmFycmF5QnVmZmVyMkJsb2IgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgICByZXR1cm4gdXRpbHMuYXJyYXlCdWZmZXIyQmxvYihidWZmZXIpO1xufTtcblxuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbiB3aXRob3V0IHJlcGxhY2VtZW50LlxuICovXG5leHBvcnRzLnRyYW5zZm9ybVRvID0gZnVuY3Rpb24ob3V0cHV0VHlwZSwgaW5wdXQpIHtcbiAgICByZXR1cm4gdXRpbHMudHJhbnNmb3JtVG8ob3V0cHV0VHlwZSwgaW5wdXQpO1xufTtcblxuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbiB3aXRob3V0IHJlcGxhY2VtZW50LlxuICovXG5leHBvcnRzLmdldFR5cGVPZiA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgcmV0dXJuIHV0aWxzLmdldFR5cGVPZihpbnB1dCk7XG59O1xuXG4vKipcbiAqIEBkZXByZWNhdGVkXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uIHdpdGhvdXQgcmVwbGFjZW1lbnQuXG4gKi9cbmV4cG9ydHMuY2hlY2tTdXBwb3J0ID0gZnVuY3Rpb24odHlwZSkge1xuICAgIHJldHVybiB1dGlscy5jaGVja1N1cHBvcnQodHlwZSk7XG59O1xuXG4vKipcbiAqIEBkZXByZWNhdGVkXG4gKiBUaGlzIHZhbHVlIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uIHdpdGhvdXQgcmVwbGFjZW1lbnQuXG4gKi9cbmV4cG9ydHMuTUFYX1ZBTFVFXzE2QklUUyA9IHV0aWxzLk1BWF9WQUxVRV8xNkJJVFM7XG5cbi8qKlxuICogQGRlcHJlY2F0ZWRcbiAqIFRoaXMgdmFsdWUgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24gd2l0aG91dCByZXBsYWNlbWVudC5cbiAqL1xuZXhwb3J0cy5NQVhfVkFMVUVfMzJCSVRTID0gdXRpbHMuTUFYX1ZBTFVFXzMyQklUUztcblxuXG4vKipcbiAqIEBkZXByZWNhdGVkXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uIHdpdGhvdXQgcmVwbGFjZW1lbnQuXG4gKi9cbmV4cG9ydHMucHJldHR5ID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIHV0aWxzLnByZXR0eShzdHIpO1xufTtcblxuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbiB3aXRob3V0IHJlcGxhY2VtZW50LlxuICovXG5leHBvcnRzLmZpbmRDb21wcmVzc2lvbiA9IGZ1bmN0aW9uKGNvbXByZXNzaW9uTWV0aG9kKSB7XG4gICAgcmV0dXJuIHV0aWxzLmZpbmRDb21wcmVzc2lvbihjb21wcmVzc2lvbk1ldGhvZCk7XG59O1xuXG4vKipcbiAqIEBkZXByZWNhdGVkXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uIHdpdGhvdXQgcmVwbGFjZW1lbnQuXG4gKi9cbmV4cG9ydHMuaXNSZWdFeHAgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgcmV0dXJuIHV0aWxzLmlzUmVnRXhwKG9iamVjdCk7XG59O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vanN6aXAvbGliL2RlcHJlY2F0ZWRQdWJsaWNVdGlscy5qc1xuLy8gbW9kdWxlIGlkID0gOTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports,__webpack_require__){"use strict";eval('\nvar USE_TYPEDARRAY = (typeof Uint8Array !== \'undefined\') && (typeof Uint16Array !== \'undefined\') && (typeof Uint32Array !== \'undefined\');\n\nvar pako = __webpack_require__(106);\nexports.uncompressInputType = USE_TYPEDARRAY ? "uint8array" : "array";\nexports.compressInputType = USE_TYPEDARRAY ? "uint8array" : "array";\n\nexports.magic = "\\x08\\x00";\nexports.compress = function(input, compressionOptions) {\n    return pako.deflateRaw(input, {\n        level : compressionOptions.level || -1 // default compression\n    });\n};\nexports.uncompress =  function(input) {\n    return pako.inflateRaw(input);\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2pzemlwL2xpYi9mbGF0ZS5qcz9hZWQ0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ijk4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xudmFyIFVTRV9UWVBFREFSUkFZID0gKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJykgJiYgKHR5cGVvZiBVaW50MTZBcnJheSAhPT0gJ3VuZGVmaW5lZCcpICYmICh0eXBlb2YgVWludDMyQXJyYXkgIT09ICd1bmRlZmluZWQnKTtcblxudmFyIHBha28gPSByZXF1aXJlKFwicGFrb1wiKTtcbmV4cG9ydHMudW5jb21wcmVzc0lucHV0VHlwZSA9IFVTRV9UWVBFREFSUkFZID8gXCJ1aW50OGFycmF5XCIgOiBcImFycmF5XCI7XG5leHBvcnRzLmNvbXByZXNzSW5wdXRUeXBlID0gVVNFX1RZUEVEQVJSQVkgPyBcInVpbnQ4YXJyYXlcIiA6IFwiYXJyYXlcIjtcblxuZXhwb3J0cy5tYWdpYyA9IFwiXFx4MDhcXHgwMFwiO1xuZXhwb3J0cy5jb21wcmVzcyA9IGZ1bmN0aW9uKGlucHV0LCBjb21wcmVzc2lvbk9wdGlvbnMpIHtcbiAgICByZXR1cm4gcGFrby5kZWZsYXRlUmF3KGlucHV0LCB7XG4gICAgICAgIGxldmVsIDogY29tcHJlc3Npb25PcHRpb25zLmxldmVsIHx8IC0xIC8vIGRlZmF1bHQgY29tcHJlc3Npb25cbiAgICB9KTtcbn07XG5leHBvcnRzLnVuY29tcHJlc3MgPSAgZnVuY3Rpb24oaW5wdXQpIHtcbiAgICByZXR1cm4gcGFrby5pbmZsYXRlUmF3KGlucHV0KTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vanN6aXAvbGliL2ZsYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSA5OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9')},function(module,exports,__webpack_require__){"use strict";eval('\n\nvar base64 = __webpack_require__(25);\n\n/**\nUsage:\n   zip = new JSZip();\n   zip.file("hello.txt", "Hello, World!").file("tempfile", "nothing");\n   zip.folder("images").file("smile.gif", base64Data, {base64: true});\n   zip.file("Xmas.txt", "Ho ho ho !", {date : new Date("December 25, 2007 00:00:01")});\n   zip.remove("tempfile");\n\n   base64zip = zip.generate();\n\n**/\n\n/**\n * Representation a of zip file in js\n * @constructor\n * @param {String=|ArrayBuffer=|Uint8Array=} data the data to load, if any (optional).\n * @param {Object=} options the options for creating this objects (optional).\n */\nfunction JSZip(data, options) {\n    // if this constructor isused without`new`, itadds `new` beforeitself:\n    if(!(this instanceof JSZip)) return new JSZip(data, options);\n\n    // object containing the files :\n    // {\n    //   "folder/" : {...},\n    //   "folder/data.txt" : {...}\n    // }\n    this.files = {};\n\n    this.comment = null;\n\n    // Where we are in the hierarchy\n    this.root = "";\n    if (data) {\n        this.load(data, options);\n    }\n    this.clone = function() {\n        var newObj = new JSZip();\n        for (var i in this) {\n            if (typeof this[i] !== "function") {\n                newObj[i] = this[i];\n            }\n        }\n        return newObj;\n    };\n}\nJSZip.prototype = __webpack_require__(28);\nJSZip.prototype.load = __webpack_require__(100);\nJSZip.support = __webpack_require__(6);\nJSZip.defaults = __webpack_require__(44);\n\n/**\n * @deprecated\n * This namespace will be removed in a future version without replacement.\n */\nJSZip.utils = __webpack_require__(97);\n\nJSZip.base64 = {\n    /**\n     * @deprecated\n     * This method will be removed in a future version without replacement.\n     */\n    encode : function(input) {\n        return base64.encode(input);\n    },\n    /**\n     * @deprecated\n     * This method will be removed in a future version without replacement.\n     */\n    decode : function(input) {\n        return base64.decode(input);\n    }\n};\nJSZip.compressions = __webpack_require__(26);\nmodule.exports = JSZip;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2pzemlwL2xpYi9pbmRleC5qcz82M2QwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGFBQWE7QUFDcEUsdUNBQXVDLDhDQUE4QztBQUNyRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlDQUFpQztBQUM1QyxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixJQUFJO0FBQzFCLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiOTkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCcuL2Jhc2U2NCcpO1xuXG4vKipcblVzYWdlOlxuICAgemlwID0gbmV3IEpTWmlwKCk7XG4gICB6aXAuZmlsZShcImhlbGxvLnR4dFwiLCBcIkhlbGxvLCBXb3JsZCFcIikuZmlsZShcInRlbXBmaWxlXCIsIFwibm90aGluZ1wiKTtcbiAgIHppcC5mb2xkZXIoXCJpbWFnZXNcIikuZmlsZShcInNtaWxlLmdpZlwiLCBiYXNlNjREYXRhLCB7YmFzZTY0OiB0cnVlfSk7XG4gICB6aXAuZmlsZShcIlhtYXMudHh0XCIsIFwiSG8gaG8gaG8gIVwiLCB7ZGF0ZSA6IG5ldyBEYXRlKFwiRGVjZW1iZXIgMjUsIDIwMDcgMDA6MDA6MDFcIil9KTtcbiAgIHppcC5yZW1vdmUoXCJ0ZW1wZmlsZVwiKTtcblxuICAgYmFzZTY0emlwID0gemlwLmdlbmVyYXRlKCk7XG5cbioqL1xuXG4vKipcbiAqIFJlcHJlc2VudGF0aW9uIGEgb2YgemlwIGZpbGUgaW4ganNcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtTdHJpbmc9fEFycmF5QnVmZmVyPXxVaW50OEFycmF5PX0gZGF0YSB0aGUgZGF0YSB0byBsb2FkLCBpZiBhbnkgKG9wdGlvbmFsKS5cbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyB0aGUgb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGhpcyBvYmplY3RzIChvcHRpb25hbCkuXG4gKi9cbmZ1bmN0aW9uIEpTWmlwKGRhdGEsIG9wdGlvbnMpIHtcbiAgICAvLyBpZiB0aGlzIGNvbnN0cnVjdG9yIGlzwqB1c2VkIHdpdGhvdXTCoGBuZXdgLCBpdMKgYWRkcyBgbmV3YCBiZWZvcmXCoGl0c2VsZjpcbiAgICBpZighKHRoaXMgaW5zdGFuY2VvZiBKU1ppcCkpIHJldHVybiBuZXcgSlNaaXAoZGF0YSwgb3B0aW9ucyk7XG5cbiAgICAvLyBvYmplY3QgY29udGFpbmluZyB0aGUgZmlsZXMgOlxuICAgIC8vIHtcbiAgICAvLyAgIFwiZm9sZGVyL1wiIDogey4uLn0sXG4gICAgLy8gICBcImZvbGRlci9kYXRhLnR4dFwiIDogey4uLn1cbiAgICAvLyB9XG4gICAgdGhpcy5maWxlcyA9IHt9O1xuXG4gICAgdGhpcy5jb21tZW50ID0gbnVsbDtcblxuICAgIC8vIFdoZXJlIHdlIGFyZSBpbiB0aGUgaGllcmFyY2h5XG4gICAgdGhpcy5yb290ID0gXCJcIjtcbiAgICBpZiAoZGF0YSkge1xuICAgICAgICB0aGlzLmxvYWQoZGF0YSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHRoaXMuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG5ld09iaiA9IG5ldyBKU1ppcCgpO1xuICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpc1tpXSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgbmV3T2JqW2ldID0gdGhpc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3T2JqO1xuICAgIH07XG59XG5KU1ppcC5wcm90b3R5cGUgPSByZXF1aXJlKCcuL29iamVjdCcpO1xuSlNaaXAucHJvdG90eXBlLmxvYWQgPSByZXF1aXJlKCcuL2xvYWQnKTtcbkpTWmlwLnN1cHBvcnQgPSByZXF1aXJlKCcuL3N1cHBvcnQnKTtcbkpTWmlwLmRlZmF1bHRzID0gcmVxdWlyZSgnLi9kZWZhdWx0cycpO1xuXG4vKipcbiAqIEBkZXByZWNhdGVkXG4gKiBUaGlzIG5hbWVzcGFjZSB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbiB3aXRob3V0IHJlcGxhY2VtZW50LlxuICovXG5KU1ppcC51dGlscyA9IHJlcXVpcmUoJy4vZGVwcmVjYXRlZFB1YmxpY1V0aWxzJyk7XG5cbkpTWmlwLmJhc2U2NCA9IHtcbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uIHdpdGhvdXQgcmVwbGFjZW1lbnQuXG4gICAgICovXG4gICAgZW5jb2RlIDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGJhc2U2NC5lbmNvZGUoaW5wdXQpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbiB3aXRob3V0IHJlcGxhY2VtZW50LlxuICAgICAqL1xuICAgIGRlY29kZSA6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBiYXNlNjQuZGVjb2RlKGlucHV0KTtcbiAgICB9XG59O1xuSlNaaXAuY29tcHJlc3Npb25zID0gcmVxdWlyZSgnLi9jb21wcmVzc2lvbnMnKTtcbm1vZHVsZS5leHBvcnRzID0gSlNaaXA7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vanN6aXAvbGliL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA5OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9')},function(module,exports,__webpack_require__){"use strict";eval("\nvar base64 = __webpack_require__(25);\nvar utf8 = __webpack_require__(48);\nvar utils = __webpack_require__(1);\nvar ZipEntries = __webpack_require__(104);\nmodule.exports = function(data, options) {\n    var files, zipEntries, i, input;\n    options = utils.extend(options || {}, {\n        base64: false,\n        checkCRC32: false,\n        optimizedBinaryString : false,\n        createFolders: false,\n        decodeFileName: utf8.utf8decode\n    });\n    if (options.base64) {\n        data = base64.decode(data);\n    }\n\n    zipEntries = new ZipEntries(data, options);\n    files = zipEntries.files;\n    for (i = 0; i < files.length; i++) {\n        input = files[i];\n        this.file(input.fileNameStr, input.decompressed, {\n            binary: true,\n            optimizedBinaryString: true,\n            date: input.date,\n            dir: input.dir,\n            comment : input.fileCommentStr.length ? input.fileCommentStr : null,\n            unixPermissions : input.unixPermissions,\n            dosPermissions : input.dosPermissions,\n            createFolders: options.createFolders\n        });\n    }\n    if (zipEntries.zipComment.length) {\n        this.comment = zipEntries.zipComment;\n    }\n\n    return this;\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2pzemlwL2xpYi9sb2FkLmpzPzI1ZTYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsa0JBQWtCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJmaWxlIjoiMTAwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xudmFyIGJhc2U2NCA9IHJlcXVpcmUoJy4vYmFzZTY0Jyk7XG52YXIgdXRmOCA9IHJlcXVpcmUoJy4vdXRmOCcpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIFppcEVudHJpZXMgPSByZXF1aXJlKCcuL3ppcEVudHJpZXMnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZGF0YSwgb3B0aW9ucykge1xuICAgIHZhciBmaWxlcywgemlwRW50cmllcywgaSwgaW5wdXQ7XG4gICAgb3B0aW9ucyA9IHV0aWxzLmV4dGVuZChvcHRpb25zIHx8IHt9LCB7XG4gICAgICAgIGJhc2U2NDogZmFsc2UsXG4gICAgICAgIGNoZWNrQ1JDMzI6IGZhbHNlLFxuICAgICAgICBvcHRpbWl6ZWRCaW5hcnlTdHJpbmcgOiBmYWxzZSxcbiAgICAgICAgY3JlYXRlRm9sZGVyczogZmFsc2UsXG4gICAgICAgIGRlY29kZUZpbGVOYW1lOiB1dGY4LnV0ZjhkZWNvZGVcbiAgICB9KTtcbiAgICBpZiAob3B0aW9ucy5iYXNlNjQpIHtcbiAgICAgICAgZGF0YSA9IGJhc2U2NC5kZWNvZGUoZGF0YSk7XG4gICAgfVxuXG4gICAgemlwRW50cmllcyA9IG5ldyBaaXBFbnRyaWVzKGRhdGEsIG9wdGlvbnMpO1xuICAgIGZpbGVzID0gemlwRW50cmllcy5maWxlcztcbiAgICBmb3IgKGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaW5wdXQgPSBmaWxlc1tpXTtcbiAgICAgICAgdGhpcy5maWxlKGlucHV0LmZpbGVOYW1lU3RyLCBpbnB1dC5kZWNvbXByZXNzZWQsIHtcbiAgICAgICAgICAgIGJpbmFyeTogdHJ1ZSxcbiAgICAgICAgICAgIG9wdGltaXplZEJpbmFyeVN0cmluZzogdHJ1ZSxcbiAgICAgICAgICAgIGRhdGU6IGlucHV0LmRhdGUsXG4gICAgICAgICAgICBkaXI6IGlucHV0LmRpcixcbiAgICAgICAgICAgIGNvbW1lbnQgOiBpbnB1dC5maWxlQ29tbWVudFN0ci5sZW5ndGggPyBpbnB1dC5maWxlQ29tbWVudFN0ciA6IG51bGwsXG4gICAgICAgICAgICB1bml4UGVybWlzc2lvbnMgOiBpbnB1dC51bml4UGVybWlzc2lvbnMsXG4gICAgICAgICAgICBkb3NQZXJtaXNzaW9ucyA6IGlucHV0LmRvc1Blcm1pc3Npb25zLFxuICAgICAgICAgICAgY3JlYXRlRm9sZGVyczogb3B0aW9ucy5jcmVhdGVGb2xkZXJzXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoemlwRW50cmllcy56aXBDb21tZW50Lmxlbmd0aCkge1xuICAgICAgICB0aGlzLmNvbW1lbnQgPSB6aXBFbnRyaWVzLnppcENvbW1lbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2pzemlwL2xpYi9sb2FkLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){"use strict";eval("\nvar Uint8ArrayReader = __webpack_require__(47);\n\nfunction NodeBufferReader(data) {\n    this.data = data;\n    this.length = this.data.length;\n    this.index = 0;\n    this.zero = 0;\n}\nNodeBufferReader.prototype = new Uint8ArrayReader();\n\n/**\n * @see DataReader.readData\n */\nNodeBufferReader.prototype.readData = function(size) {\n    this.checkOffset(size);\n    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);\n    this.index += size;\n    return result;\n};\nmodule.exports = NodeBufferReader;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2pzemlwL2xpYi9ub2RlQnVmZmVyUmVhZGVyLmpzPzdjZDkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxMDEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgVWludDhBcnJheVJlYWRlciA9IHJlcXVpcmUoJy4vdWludDhBcnJheVJlYWRlcicpO1xuXG5mdW5jdGlvbiBOb2RlQnVmZmVyUmVhZGVyKGRhdGEpIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMubGVuZ3RoID0gdGhpcy5kYXRhLmxlbmd0aDtcbiAgICB0aGlzLmluZGV4ID0gMDtcbiAgICB0aGlzLnplcm8gPSAwO1xufVxuTm9kZUJ1ZmZlclJlYWRlci5wcm90b3R5cGUgPSBuZXcgVWludDhBcnJheVJlYWRlcigpO1xuXG4vKipcbiAqIEBzZWUgRGF0YVJlYWRlci5yZWFkRGF0YVxuICovXG5Ob2RlQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5yZWFkRGF0YSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgICB0aGlzLmNoZWNrT2Zmc2V0KHNpemUpO1xuICAgIHZhciByZXN1bHQgPSB0aGlzLmRhdGEuc2xpY2UodGhpcy56ZXJvICsgdGhpcy5pbmRleCwgdGhpcy56ZXJvICsgdGhpcy5pbmRleCArIHNpemUpO1xuICAgIHRoaXMuaW5kZXggKz0gc2l6ZTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbm1vZHVsZS5leHBvcnRzID0gTm9kZUJ1ZmZlclJlYWRlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9qc3ppcC9saWIvbm9kZUJ1ZmZlclJlYWRlci5qc1xuLy8gbW9kdWxlIGlkID0gMTAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){"use strict";eval('\n\nvar utils = __webpack_require__(1);\n\n/**\n * An object to write any content to a string.\n * @constructor\n */\nvar StringWriter = function() {\n    this.data = [];\n};\nStringWriter.prototype = {\n    /**\n     * Append any content to the current string.\n     * @param {Object} input the content to add.\n     */\n    append: function(input) {\n        input = utils.transformTo("string", input);\n        this.data.push(input);\n    },\n    /**\n     * Finalize the construction an return the result.\n     * @return {string} the generated string.\n     */\n    finalize: function() {\n        return this.data.join("");\n    }\n};\n\nmodule.exports = StringWriter;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2pzemlwL2xpYi9zdHJpbmdXcml0ZXIuanM/OTMwYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIxMDIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuLyoqXG4gKiBBbiBvYmplY3QgdG8gd3JpdGUgYW55IGNvbnRlbnQgdG8gYSBzdHJpbmcuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFN0cmluZ1dyaXRlciA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZGF0YSA9IFtdO1xufTtcblN0cmluZ1dyaXRlci5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogQXBwZW5kIGFueSBjb250ZW50IHRvIHRoZSBjdXJyZW50IHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXQgdGhlIGNvbnRlbnQgdG8gYWRkLlxuICAgICAqL1xuICAgIGFwcGVuZDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgaW5wdXQgPSB1dGlscy50cmFuc2Zvcm1UbyhcInN0cmluZ1wiLCBpbnB1dCk7XG4gICAgICAgIHRoaXMuZGF0YS5wdXNoKGlucHV0KTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEZpbmFsaXplIHRoZSBjb25zdHJ1Y3Rpb24gYW4gcmV0dXJuIHRoZSByZXN1bHQuXG4gICAgICogQHJldHVybiB7c3RyaW5nfSB0aGUgZ2VuZXJhdGVkIHN0cmluZy5cbiAgICAgKi9cbiAgICBmaW5hbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEuam9pbihcIlwiKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmluZ1dyaXRlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9qc3ppcC9saWIvc3RyaW5nV3JpdGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports,__webpack_require__){"use strict";eval('\n\nvar utils = __webpack_require__(1);\n\n/**\n * An object to write any content to an Uint8Array.\n * @constructor\n * @param {number} length The length of the array.\n */\nvar Uint8ArrayWriter = function(length) {\n    this.data = new Uint8Array(length);\n    this.index = 0;\n};\nUint8ArrayWriter.prototype = {\n    /**\n     * Append any content to the current array.\n     * @param {Object} input the content to add.\n     */\n    append: function(input) {\n        if (input.length !== 0) {\n            // with an empty Uint8Array, Opera fails with a "Offset larger than array size"\n            input = utils.transformTo("uint8array", input);\n            this.data.set(input, this.index);\n            this.index += input.length;\n        }\n    },\n    /**\n     * Finalize the construction an return the result.\n     * @return {Uint8Array} the generated array.\n     */\n    finalize: function() {\n        return this.data;\n    }\n};\n\nmodule.exports = Uint8ArrayWriter;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2pzemlwL2xpYi91aW50OEFycmF5V3JpdGVyLmpzPzc4ZGMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIxMDMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuLyoqXG4gKiBBbiBvYmplY3QgdG8gd3JpdGUgYW55IGNvbnRlbnQgdG8gYW4gVWludDhBcnJheS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBUaGUgbGVuZ3RoIG9mIHRoZSBhcnJheS5cbiAqL1xudmFyIFVpbnQ4QXJyYXlXcml0ZXIgPSBmdW5jdGlvbihsZW5ndGgpIHtcbiAgICB0aGlzLmRhdGEgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIHRoaXMuaW5kZXggPSAwO1xufTtcblVpbnQ4QXJyYXlXcml0ZXIucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIEFwcGVuZCBhbnkgY29udGVudCB0byB0aGUgY3VycmVudCBhcnJheS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXQgdGhlIGNvbnRlbnQgdG8gYWRkLlxuICAgICAqL1xuICAgIGFwcGVuZDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgaWYgKGlucHV0Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgLy8gd2l0aCBhbiBlbXB0eSBVaW50OEFycmF5LCBPcGVyYSBmYWlscyB3aXRoIGEgXCJPZmZzZXQgbGFyZ2VyIHRoYW4gYXJyYXkgc2l6ZVwiXG4gICAgICAgICAgICBpbnB1dCA9IHV0aWxzLnRyYW5zZm9ybVRvKFwidWludDhhcnJheVwiLCBpbnB1dCk7XG4gICAgICAgICAgICB0aGlzLmRhdGEuc2V0KGlucHV0LCB0aGlzLmluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuaW5kZXggKz0gaW5wdXQubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBGaW5hbGl6ZSB0aGUgY29uc3RydWN0aW9uIGFuIHJldHVybiB0aGUgcmVzdWx0LlxuICAgICAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9IHRoZSBnZW5lcmF0ZWQgYXJyYXkuXG4gICAgICovXG4gICAgZmluYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVWludDhBcnJheVdyaXRlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9qc3ppcC9saWIvdWludDhBcnJheVdyaXRlci5qc1xuLy8gbW9kdWxlIGlkID0gMTAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,exports,__webpack_require__){"use strict";eval('\nvar StringReader = __webpack_require__(46);\nvar NodeBufferReader = __webpack_require__(101);\nvar Uint8ArrayReader = __webpack_require__(47);\nvar ArrayReader = __webpack_require__(41);\nvar utils = __webpack_require__(1);\nvar sig = __webpack_require__(45);\nvar ZipEntry = __webpack_require__(105);\nvar support = __webpack_require__(6);\nvar jszipProto = __webpack_require__(28);\n//  class ZipEntries {{{\n/**\n * All the entries in the zip file.\n * @constructor\n * @param {String|ArrayBuffer|Uint8Array} data the binary stream to load.\n * @param {Object} loadOptions Options for loading the stream.\n */\nfunction ZipEntries(data, loadOptions) {\n    this.files = [];\n    this.loadOptions = loadOptions;\n    if (data) {\n        this.load(data);\n    }\n}\nZipEntries.prototype = {\n    /**\n     * Check that the reader is on the speficied signature.\n     * @param {string} expectedSignature the expected signature.\n     * @throws {Error} if it is an other signature.\n     */\n    checkSignature: function(expectedSignature) {\n        var signature = this.reader.readString(4);\n        if (signature !== expectedSignature) {\n            throw new Error("Corrupted zip or bug : unexpected signature " + "(" + utils.pretty(signature) + ", expected " + utils.pretty(expectedSignature) + ")");\n        }\n    },\n    /**\n     * Check if the given signature is at the given index.\n     * @param {number} askedIndex the index to check.\n     * @param {string} expectedSignature the signature to expect.\n     * @return {boolean} true if the signature is here, false otherwise.\n     */\n    isSignature: function(askedIndex, expectedSignature) {\n        var currentIndex = this.reader.index;\n        this.reader.setIndex(askedIndex);\n        var signature = this.reader.readString(4);\n        var result = signature === expectedSignature;\n        this.reader.setIndex(currentIndex);\n        return result;\n    },\n    /**\n     * Read the end of the central directory.\n     */\n    readBlockEndOfCentral: function() {\n        this.diskNumber = this.reader.readInt(2);\n        this.diskWithCentralDirStart = this.reader.readInt(2);\n        this.centralDirRecordsOnThisDisk = this.reader.readInt(2);\n        this.centralDirRecords = this.reader.readInt(2);\n        this.centralDirSize = this.reader.readInt(4);\n        this.centralDirOffset = this.reader.readInt(4);\n\n        this.zipCommentLength = this.reader.readInt(2);\n        // warning : the encoding depends of the system locale\n        // On a linux machine with LANG=en_US.utf8, this field is utf8 encoded.\n        // On a windows machine, this field is encoded with the localized windows code page.\n        var zipComment = this.reader.readData(this.zipCommentLength);\n        var decodeParamType = support.uint8array ? "uint8array" : "array";\n        // To get consistent behavior with the generation part, we will assume that\n        // this is utf8 encoded unless specified otherwise.\n        var decodeContent = utils.transformTo(decodeParamType, zipComment);\n        this.zipComment = this.loadOptions.decodeFileName(decodeContent);\n    },\n    /**\n     * Read the end of the Zip 64 central directory.\n     * Not merged with the method readEndOfCentral :\n     * The end of central can coexist with its Zip64 brother,\n     * I don\'t want to read the wrong number of bytes !\n     */\n    readBlockZip64EndOfCentral: function() {\n        this.zip64EndOfCentralSize = this.reader.readInt(8);\n        this.versionMadeBy = this.reader.readString(2);\n        this.versionNeeded = this.reader.readInt(2);\n        this.diskNumber = this.reader.readInt(4);\n        this.diskWithCentralDirStart = this.reader.readInt(4);\n        this.centralDirRecordsOnThisDisk = this.reader.readInt(8);\n        this.centralDirRecords = this.reader.readInt(8);\n        this.centralDirSize = this.reader.readInt(8);\n        this.centralDirOffset = this.reader.readInt(8);\n\n        this.zip64ExtensibleData = {};\n        var extraDataSize = this.zip64EndOfCentralSize - 44,\n            index = 0,\n            extraFieldId,\n            extraFieldLength,\n            extraFieldValue;\n        while (index < extraDataSize) {\n            extraFieldId = this.reader.readInt(2);\n            extraFieldLength = this.reader.readInt(4);\n            extraFieldValue = this.reader.readString(extraFieldLength);\n            this.zip64ExtensibleData[extraFieldId] = {\n                id: extraFieldId,\n                length: extraFieldLength,\n                value: extraFieldValue\n            };\n        }\n    },\n    /**\n     * Read the end of the Zip 64 central directory locator.\n     */\n    readBlockZip64EndOfCentralLocator: function() {\n        this.diskWithZip64CentralDirStart = this.reader.readInt(4);\n        this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);\n        this.disksCount = this.reader.readInt(4);\n        if (this.disksCount > 1) {\n            throw new Error("Multi-volumes zip are not supported");\n        }\n    },\n    /**\n     * Read the local files, based on the offset read in the central part.\n     */\n    readLocalFiles: function() {\n        var i, file;\n        for (i = 0; i < this.files.length; i++) {\n            file = this.files[i];\n            this.reader.setIndex(file.localHeaderOffset);\n            this.checkSignature(sig.LOCAL_FILE_HEADER);\n            file.readLocalPart(this.reader);\n            file.handleUTF8();\n            file.processAttributes();\n        }\n    },\n    /**\n     * Read the central directory.\n     */\n    readCentralDir: function() {\n        var file;\n\n        this.reader.setIndex(this.centralDirOffset);\n        while (this.reader.readString(4) === sig.CENTRAL_FILE_HEADER) {\n            file = new ZipEntry({\n                zip64: this.zip64\n            }, this.loadOptions);\n            file.readCentralPart(this.reader);\n            this.files.push(file);\n        }\n\n        if (this.centralDirRecords !== this.files.length) {\n            if (this.centralDirRecords !== 0 && this.files.length === 0) {\n                // We expected some records but couldn\'t find ANY.\n                // This is really suspicious, as if something went wrong.\n                throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);\n            } else {\n                // We found some records but not all.\n                // Something is wrong but we got something for the user: no error here.\n                // console.warn("expected", this.centralDirRecords, "records in central dir, got", this.files.length);\n            }\n        }\n    },\n    /**\n     * Read the end of central directory.\n     */\n    readEndOfCentral: function() {\n        var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);\n        if (offset < 0) {\n            // Check if the content is a truncated zip or complete garbage.\n            // A "LOCAL_FILE_HEADER" is not required at the beginning (auto\n            // extractible zip for example) but it can give a good hint.\n            // If an ajax request was used without responseType, we will also\n            // get unreadable data.\n            var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);\n\n            if (isGarbage) {\n                throw new Error("Can\'t find end of central directory : is this a zip file ? " +\n                                "If it is, see http://stuk.github.io/jszip/documentation/howto/read_zip.html");\n            } else {\n                throw new Error("Corrupted zip : can\'t find end of central directory");\n            }\n        }\n        this.reader.setIndex(offset);\n        var endOfCentralDirOffset = offset;\n        this.checkSignature(sig.CENTRAL_DIRECTORY_END);\n        this.readBlockEndOfCentral();\n\n\n        /* extract from the zip spec :\n            4)  If one of the fields in the end of central directory\n                record is too small to hold required data, the field\n                should be set to -1 (0xFFFF or 0xFFFFFFFF) and the\n                ZIP64 format record should be created.\n            5)  The end of central directory record and the\n                Zip64 end of central directory locator record must\n                reside on the same disk when splitting or spanning\n                an archive.\n         */\n        if (this.diskNumber === utils.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils.MAX_VALUE_16BITS || this.centralDirRecords === utils.MAX_VALUE_16BITS || this.centralDirSize === utils.MAX_VALUE_32BITS || this.centralDirOffset === utils.MAX_VALUE_32BITS) {\n            this.zip64 = true;\n\n            /*\n            Warning : the zip64 extension is supported, but ONLY if the 64bits integer read from\n            the zip file can fit into a 32bits integer. This cannot be solved : Javascript represents\n            all numbers as 64-bit double precision IEEE 754 floating point numbers.\n            So, we have 53bits for integers and bitwise operations treat everything as 32bits.\n            see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Bitwise_Operators\n            and http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf section 8.5\n            */\n\n            // should look for a zip64 EOCD locator\n            offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);\n            if (offset < 0) {\n                throw new Error("Corrupted zip : can\'t find the ZIP64 end of central directory locator");\n            }\n            this.reader.setIndex(offset);\n            this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);\n            this.readBlockZip64EndOfCentralLocator();\n\n            // now the zip64 EOCD record\n            if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, sig.ZIP64_CENTRAL_DIRECTORY_END)) {\n                // console.warn("ZIP64 end of central directory not where expected.");\n                this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);\n                if (this.relativeOffsetEndOfZip64CentralDir < 0) {\n                    throw new Error("Corrupted zip : can\'t find the ZIP64 end of central directory");\n                }\n            }\n            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);\n            this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);\n            this.readBlockZip64EndOfCentral();\n        }\n\n        var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;\n        if (this.zip64) {\n            expectedEndOfCentralDirOffset += 20; // end of central dir 64 locator\n            expectedEndOfCentralDirOffset += 12 /* should not include the leading 12 bytes */ + this.zip64EndOfCentralSize;\n        }\n\n        var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;\n\n        if (extraBytes > 0) {\n            // console.warn(extraBytes, "extra bytes at beginning or within zipfile");\n            if (this.isSignature(endOfCentralDirOffset, sig.CENTRAL_FILE_HEADER)) {\n                // The offsets seem wrong, but we have something at the specified offset.\n                // So we keep it.\n            } else {\n                // the offset is wrong, update the "zero" of the reader\n                // this happens if data has been prepended (crx files for example)\n                this.reader.zero = extraBytes;\n            }\n        } else if (extraBytes < 0) {\n            throw new Error("Corrupted zip: missing " + Math.abs(extraBytes) + " bytes.");\n        }\n    },\n    prepareReader: function(data) {\n        var type = utils.getTypeOf(data);\n        utils.checkSupport(type);\n        if (type === "string" && !support.uint8array) {\n            this.reader = new StringReader(data, this.loadOptions.optimizedBinaryString);\n        }\n        else if (type === "nodebuffer") {\n            this.reader = new NodeBufferReader(data);\n        }\n        else if (support.uint8array) {\n            this.reader = new Uint8ArrayReader(utils.transformTo("uint8array", data));\n        } else if (support.array) {\n            this.reader = new ArrayReader(utils.transformTo("array", data));\n        } else {\n            throw new Error("Unexpected error: unsupported type \'" + type + "\'");\n        }\n    },\n    /**\n     * Read a zip file and create ZipEntries.\n     * @param {String|ArrayBuffer|Uint8Array|Buffer} data the binary string representing a zip file.\n     */\n    load: function(data) {\n        this.prepareReader(data);\n        this.readEndOfCentral();\n        this.readCentralDir();\n        this.readLocalFiles();\n    }\n};\n// }}} end of ZipEntries\nmodule.exports = ZipEntries;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2pzemlwL2xpYi96aXBFbnRyaWVzLmpzPzdlMDkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsOEJBQThCO0FBQ3pDLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZUFBZSxxQ0FBcUM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiIsImZpbGUiOiIxMDQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgU3RyaW5nUmVhZGVyID0gcmVxdWlyZSgnLi9zdHJpbmdSZWFkZXInKTtcbnZhciBOb2RlQnVmZmVyUmVhZGVyID0gcmVxdWlyZSgnLi9ub2RlQnVmZmVyUmVhZGVyJyk7XG52YXIgVWludDhBcnJheVJlYWRlciA9IHJlcXVpcmUoJy4vdWludDhBcnJheVJlYWRlcicpO1xudmFyIEFycmF5UmVhZGVyID0gcmVxdWlyZSgnLi9hcnJheVJlYWRlcicpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIHNpZyA9IHJlcXVpcmUoJy4vc2lnbmF0dXJlJyk7XG52YXIgWmlwRW50cnkgPSByZXF1aXJlKCcuL3ppcEVudHJ5Jyk7XG52YXIgc3VwcG9ydCA9IHJlcXVpcmUoJy4vc3VwcG9ydCcpO1xudmFyIGpzemlwUHJvdG8gPSByZXF1aXJlKCcuL29iamVjdCcpO1xuLy8gIGNsYXNzIFppcEVudHJpZXMge3t7XG4vKipcbiAqIEFsbCB0aGUgZW50cmllcyBpbiB0aGUgemlwIGZpbGUuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl9IGRhdGEgdGhlIGJpbmFyeSBzdHJlYW0gdG8gbG9hZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBsb2FkT3B0aW9ucyBPcHRpb25zIGZvciBsb2FkaW5nIHRoZSBzdHJlYW0uXG4gKi9cbmZ1bmN0aW9uIFppcEVudHJpZXMoZGF0YSwgbG9hZE9wdGlvbnMpIHtcbiAgICB0aGlzLmZpbGVzID0gW107XG4gICAgdGhpcy5sb2FkT3B0aW9ucyA9IGxvYWRPcHRpb25zO1xuICAgIGlmIChkYXRhKSB7XG4gICAgICAgIHRoaXMubG9hZChkYXRhKTtcbiAgICB9XG59XG5aaXBFbnRyaWVzLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBDaGVjayB0aGF0IHRoZSByZWFkZXIgaXMgb24gdGhlIHNwZWZpY2llZCBzaWduYXR1cmUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV4cGVjdGVkU2lnbmF0dXJlIHRoZSBleHBlY3RlZCBzaWduYXR1cmUuXG4gICAgICogQHRocm93cyB7RXJyb3J9IGlmIGl0IGlzIGFuIG90aGVyIHNpZ25hdHVyZS5cbiAgICAgKi9cbiAgICBjaGVja1NpZ25hdHVyZTogZnVuY3Rpb24oZXhwZWN0ZWRTaWduYXR1cmUpIHtcbiAgICAgICAgdmFyIHNpZ25hdHVyZSA9IHRoaXMucmVhZGVyLnJlYWRTdHJpbmcoNCk7XG4gICAgICAgIGlmIChzaWduYXR1cmUgIT09IGV4cGVjdGVkU2lnbmF0dXJlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3JydXB0ZWQgemlwIG9yIGJ1ZyA6IHVuZXhwZWN0ZWQgc2lnbmF0dXJlIFwiICsgXCIoXCIgKyB1dGlscy5wcmV0dHkoc2lnbmF0dXJlKSArIFwiLCBleHBlY3RlZCBcIiArIHV0aWxzLnByZXR0eShleHBlY3RlZFNpZ25hdHVyZSkgKyBcIilcIik7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBnaXZlbiBzaWduYXR1cmUgaXMgYXQgdGhlIGdpdmVuIGluZGV4LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhc2tlZEluZGV4IHRoZSBpbmRleCB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwZWN0ZWRTaWduYXR1cmUgdGhlIHNpZ25hdHVyZSB0byBleHBlY3QuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgc2lnbmF0dXJlIGlzIGhlcmUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBpc1NpZ25hdHVyZTogZnVuY3Rpb24oYXNrZWRJbmRleCwgZXhwZWN0ZWRTaWduYXR1cmUpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRJbmRleCA9IHRoaXMucmVhZGVyLmluZGV4O1xuICAgICAgICB0aGlzLnJlYWRlci5zZXRJbmRleChhc2tlZEluZGV4KTtcbiAgICAgICAgdmFyIHNpZ25hdHVyZSA9IHRoaXMucmVhZGVyLnJlYWRTdHJpbmcoNCk7XG4gICAgICAgIHZhciByZXN1bHQgPSBzaWduYXR1cmUgPT09IGV4cGVjdGVkU2lnbmF0dXJlO1xuICAgICAgICB0aGlzLnJlYWRlci5zZXRJbmRleChjdXJyZW50SW5kZXgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVhZCB0aGUgZW5kIG9mIHRoZSBjZW50cmFsIGRpcmVjdG9yeS5cbiAgICAgKi9cbiAgICByZWFkQmxvY2tFbmRPZkNlbnRyYWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmRpc2tOdW1iZXIgPSB0aGlzLnJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICB0aGlzLmRpc2tXaXRoQ2VudHJhbERpclN0YXJ0ID0gdGhpcy5yZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5jZW50cmFsRGlyUmVjb3Jkc09uVGhpc0Rpc2sgPSB0aGlzLnJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICB0aGlzLmNlbnRyYWxEaXJSZWNvcmRzID0gdGhpcy5yZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5jZW50cmFsRGlyU2l6ZSA9IHRoaXMucmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgIHRoaXMuY2VudHJhbERpck9mZnNldCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoNCk7XG5cbiAgICAgICAgdGhpcy56aXBDb21tZW50TGVuZ3RoID0gdGhpcy5yZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgLy8gd2FybmluZyA6IHRoZSBlbmNvZGluZyBkZXBlbmRzIG9mIHRoZSBzeXN0ZW0gbG9jYWxlXG4gICAgICAgIC8vIE9uIGEgbGludXggbWFjaGluZSB3aXRoIExBTkc9ZW5fVVMudXRmOCwgdGhpcyBmaWVsZCBpcyB1dGY4IGVuY29kZWQuXG4gICAgICAgIC8vIE9uIGEgd2luZG93cyBtYWNoaW5lLCB0aGlzIGZpZWxkIGlzIGVuY29kZWQgd2l0aCB0aGUgbG9jYWxpemVkIHdpbmRvd3MgY29kZSBwYWdlLlxuICAgICAgICB2YXIgemlwQ29tbWVudCA9IHRoaXMucmVhZGVyLnJlYWREYXRhKHRoaXMuemlwQ29tbWVudExlbmd0aCk7XG4gICAgICAgIHZhciBkZWNvZGVQYXJhbVR5cGUgPSBzdXBwb3J0LnVpbnQ4YXJyYXkgPyBcInVpbnQ4YXJyYXlcIiA6IFwiYXJyYXlcIjtcbiAgICAgICAgLy8gVG8gZ2V0IGNvbnNpc3RlbnQgYmVoYXZpb3Igd2l0aCB0aGUgZ2VuZXJhdGlvbiBwYXJ0LCB3ZSB3aWxsIGFzc3VtZSB0aGF0XG4gICAgICAgIC8vIHRoaXMgaXMgdXRmOCBlbmNvZGVkIHVubGVzcyBzcGVjaWZpZWQgb3RoZXJ3aXNlLlxuICAgICAgICB2YXIgZGVjb2RlQ29udGVudCA9IHV0aWxzLnRyYW5zZm9ybVRvKGRlY29kZVBhcmFtVHlwZSwgemlwQ29tbWVudCk7XG4gICAgICAgIHRoaXMuemlwQ29tbWVudCA9IHRoaXMubG9hZE9wdGlvbnMuZGVjb2RlRmlsZU5hbWUoZGVjb2RlQ29udGVudCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSBlbmQgb2YgdGhlIFppcCA2NCBjZW50cmFsIGRpcmVjdG9yeS5cbiAgICAgKiBOb3QgbWVyZ2VkIHdpdGggdGhlIG1ldGhvZCByZWFkRW5kT2ZDZW50cmFsIDpcbiAgICAgKiBUaGUgZW5kIG9mIGNlbnRyYWwgY2FuIGNvZXhpc3Qgd2l0aCBpdHMgWmlwNjQgYnJvdGhlcixcbiAgICAgKiBJIGRvbid0IHdhbnQgdG8gcmVhZCB0aGUgd3JvbmcgbnVtYmVyIG9mIGJ5dGVzICFcbiAgICAgKi9cbiAgICByZWFkQmxvY2taaXA2NEVuZE9mQ2VudHJhbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuemlwNjRFbmRPZkNlbnRyYWxTaXplID0gdGhpcy5yZWFkZXIucmVhZEludCg4KTtcbiAgICAgICAgdGhpcy52ZXJzaW9uTWFkZUJ5ID0gdGhpcy5yZWFkZXIucmVhZFN0cmluZygyKTtcbiAgICAgICAgdGhpcy52ZXJzaW9uTmVlZGVkID0gdGhpcy5yZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5kaXNrTnVtYmVyID0gdGhpcy5yZWFkZXIucmVhZEludCg0KTtcbiAgICAgICAgdGhpcy5kaXNrV2l0aENlbnRyYWxEaXJTdGFydCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgIHRoaXMuY2VudHJhbERpclJlY29yZHNPblRoaXNEaXNrID0gdGhpcy5yZWFkZXIucmVhZEludCg4KTtcbiAgICAgICAgdGhpcy5jZW50cmFsRGlyUmVjb3JkcyA9IHRoaXMucmVhZGVyLnJlYWRJbnQoOCk7XG4gICAgICAgIHRoaXMuY2VudHJhbERpclNpemUgPSB0aGlzLnJlYWRlci5yZWFkSW50KDgpO1xuICAgICAgICB0aGlzLmNlbnRyYWxEaXJPZmZzZXQgPSB0aGlzLnJlYWRlci5yZWFkSW50KDgpO1xuXG4gICAgICAgIHRoaXMuemlwNjRFeHRlbnNpYmxlRGF0YSA9IHt9O1xuICAgICAgICB2YXIgZXh0cmFEYXRhU2l6ZSA9IHRoaXMuemlwNjRFbmRPZkNlbnRyYWxTaXplIC0gNDQsXG4gICAgICAgICAgICBpbmRleCA9IDAsXG4gICAgICAgICAgICBleHRyYUZpZWxkSWQsXG4gICAgICAgICAgICBleHRyYUZpZWxkTGVuZ3RoLFxuICAgICAgICAgICAgZXh0cmFGaWVsZFZhbHVlO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBleHRyYURhdGFTaXplKSB7XG4gICAgICAgICAgICBleHRyYUZpZWxkSWQgPSB0aGlzLnJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICAgICAgZXh0cmFGaWVsZExlbmd0aCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgICAgICBleHRyYUZpZWxkVmFsdWUgPSB0aGlzLnJlYWRlci5yZWFkU3RyaW5nKGV4dHJhRmllbGRMZW5ndGgpO1xuICAgICAgICAgICAgdGhpcy56aXA2NEV4dGVuc2libGVEYXRhW2V4dHJhRmllbGRJZF0gPSB7XG4gICAgICAgICAgICAgICAgaWQ6IGV4dHJhRmllbGRJZCxcbiAgICAgICAgICAgICAgICBsZW5ndGg6IGV4dHJhRmllbGRMZW5ndGgsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGV4dHJhRmllbGRWYWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVhZCB0aGUgZW5kIG9mIHRoZSBaaXAgNjQgY2VudHJhbCBkaXJlY3RvcnkgbG9jYXRvci5cbiAgICAgKi9cbiAgICByZWFkQmxvY2taaXA2NEVuZE9mQ2VudHJhbExvY2F0b3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmRpc2tXaXRoWmlwNjRDZW50cmFsRGlyU3RhcnQgPSB0aGlzLnJlYWRlci5yZWFkSW50KDQpO1xuICAgICAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0RW5kT2ZaaXA2NENlbnRyYWxEaXIgPSB0aGlzLnJlYWRlci5yZWFkSW50KDgpO1xuICAgICAgICB0aGlzLmRpc2tzQ291bnQgPSB0aGlzLnJlYWRlci5yZWFkSW50KDQpO1xuICAgICAgICBpZiAodGhpcy5kaXNrc0NvdW50ID4gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVsdGktdm9sdW1lcyB6aXAgYXJlIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIGxvY2FsIGZpbGVzLCBiYXNlZCBvbiB0aGUgb2Zmc2V0IHJlYWQgaW4gdGhlIGNlbnRyYWwgcGFydC5cbiAgICAgKi9cbiAgICByZWFkTG9jYWxGaWxlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpLCBmaWxlO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5maWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZmlsZSA9IHRoaXMuZmlsZXNbaV07XG4gICAgICAgICAgICB0aGlzLnJlYWRlci5zZXRJbmRleChmaWxlLmxvY2FsSGVhZGVyT2Zmc2V0KTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tTaWduYXR1cmUoc2lnLkxPQ0FMX0ZJTEVfSEVBREVSKTtcbiAgICAgICAgICAgIGZpbGUucmVhZExvY2FsUGFydCh0aGlzLnJlYWRlcik7XG4gICAgICAgICAgICBmaWxlLmhhbmRsZVVURjgoKTtcbiAgICAgICAgICAgIGZpbGUucHJvY2Vzc0F0dHJpYnV0ZXMoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVhZCB0aGUgY2VudHJhbCBkaXJlY3RvcnkuXG4gICAgICovXG4gICAgcmVhZENlbnRyYWxEaXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZmlsZTtcblxuICAgICAgICB0aGlzLnJlYWRlci5zZXRJbmRleCh0aGlzLmNlbnRyYWxEaXJPZmZzZXQpO1xuICAgICAgICB3aGlsZSAodGhpcy5yZWFkZXIucmVhZFN0cmluZyg0KSA9PT0gc2lnLkNFTlRSQUxfRklMRV9IRUFERVIpIHtcbiAgICAgICAgICAgIGZpbGUgPSBuZXcgWmlwRW50cnkoe1xuICAgICAgICAgICAgICAgIHppcDY0OiB0aGlzLnppcDY0XG4gICAgICAgICAgICB9LCB0aGlzLmxvYWRPcHRpb25zKTtcbiAgICAgICAgICAgIGZpbGUucmVhZENlbnRyYWxQYXJ0KHRoaXMucmVhZGVyKTtcbiAgICAgICAgICAgIHRoaXMuZmlsZXMucHVzaChmaWxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmNlbnRyYWxEaXJSZWNvcmRzICE9PSB0aGlzLmZpbGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2VudHJhbERpclJlY29yZHMgIT09IDAgJiYgdGhpcy5maWxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBleHBlY3RlZCBzb21lIHJlY29yZHMgYnV0IGNvdWxkbid0IGZpbmQgQU5ZLlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgcmVhbGx5IHN1c3BpY2lvdXMsIGFzIGlmIHNvbWV0aGluZyB3ZW50IHdyb25nLlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvcnJ1cHRlZCB6aXAgb3IgYnVnOiBleHBlY3RlZCBcIiArIHRoaXMuY2VudHJhbERpclJlY29yZHMgKyBcIiByZWNvcmRzIGluIGNlbnRyYWwgZGlyLCBnb3QgXCIgKyB0aGlzLmZpbGVzLmxlbmd0aCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFdlIGZvdW5kIHNvbWUgcmVjb3JkcyBidXQgbm90IGFsbC5cbiAgICAgICAgICAgICAgICAvLyBTb21ldGhpbmcgaXMgd3JvbmcgYnV0IHdlIGdvdCBzb21ldGhpbmcgZm9yIHRoZSB1c2VyOiBubyBlcnJvciBoZXJlLlxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybihcImV4cGVjdGVkXCIsIHRoaXMuY2VudHJhbERpclJlY29yZHMsIFwicmVjb3JkcyBpbiBjZW50cmFsIGRpciwgZ290XCIsIHRoaXMuZmlsZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVhZCB0aGUgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5LlxuICAgICAqL1xuICAgIHJlYWRFbmRPZkNlbnRyYWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5yZWFkZXIubGFzdEluZGV4T2ZTaWduYXR1cmUoc2lnLkNFTlRSQUxfRElSRUNUT1JZX0VORCk7XG4gICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgY29udGVudCBpcyBhIHRydW5jYXRlZCB6aXAgb3IgY29tcGxldGUgZ2FyYmFnZS5cbiAgICAgICAgICAgIC8vIEEgXCJMT0NBTF9GSUxFX0hFQURFUlwiIGlzIG5vdCByZXF1aXJlZCBhdCB0aGUgYmVnaW5uaW5nIChhdXRvXG4gICAgICAgICAgICAvLyBleHRyYWN0aWJsZSB6aXAgZm9yIGV4YW1wbGUpIGJ1dCBpdCBjYW4gZ2l2ZSBhIGdvb2QgaGludC5cbiAgICAgICAgICAgIC8vIElmIGFuIGFqYXggcmVxdWVzdCB3YXMgdXNlZCB3aXRob3V0IHJlc3BvbnNlVHlwZSwgd2Ugd2lsbCBhbHNvXG4gICAgICAgICAgICAvLyBnZXQgdW5yZWFkYWJsZSBkYXRhLlxuICAgICAgICAgICAgdmFyIGlzR2FyYmFnZSA9ICF0aGlzLmlzU2lnbmF0dXJlKDAsIHNpZy5MT0NBTF9GSUxFX0hFQURFUik7XG5cbiAgICAgICAgICAgIGlmIChpc0dhcmJhZ2UpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBmaW5kIGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeSA6IGlzIHRoaXMgYSB6aXAgZmlsZSA/IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJJZiBpdCBpcywgc2VlIGh0dHA6Ly9zdHVrLmdpdGh1Yi5pby9qc3ppcC9kb2N1bWVudGF0aW9uL2hvd3RvL3JlYWRfemlwLmh0bWxcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvcnJ1cHRlZCB6aXAgOiBjYW4ndCBmaW5kIGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlYWRlci5zZXRJbmRleChvZmZzZXQpO1xuICAgICAgICB2YXIgZW5kT2ZDZW50cmFsRGlyT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLmNoZWNrU2lnbmF0dXJlKHNpZy5DRU5UUkFMX0RJUkVDVE9SWV9FTkQpO1xuICAgICAgICB0aGlzLnJlYWRCbG9ja0VuZE9mQ2VudHJhbCgpO1xuXG5cbiAgICAgICAgLyogZXh0cmFjdCBmcm9tIHRoZSB6aXAgc3BlYyA6XG4gICAgICAgICAgICA0KSAgSWYgb25lIG9mIHRoZSBmaWVsZHMgaW4gdGhlIGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeVxuICAgICAgICAgICAgICAgIHJlY29yZCBpcyB0b28gc21hbGwgdG8gaG9sZCByZXF1aXJlZCBkYXRhLCB0aGUgZmllbGRcbiAgICAgICAgICAgICAgICBzaG91bGQgYmUgc2V0IHRvIC0xICgweEZGRkYgb3IgMHhGRkZGRkZGRikgYW5kIHRoZVxuICAgICAgICAgICAgICAgIFpJUDY0IGZvcm1hdCByZWNvcmQgc2hvdWxkIGJlIGNyZWF0ZWQuXG4gICAgICAgICAgICA1KSAgVGhlIGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeSByZWNvcmQgYW5kIHRoZVxuICAgICAgICAgICAgICAgIFppcDY0IGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeSBsb2NhdG9yIHJlY29yZCBtdXN0XG4gICAgICAgICAgICAgICAgcmVzaWRlIG9uIHRoZSBzYW1lIGRpc2sgd2hlbiBzcGxpdHRpbmcgb3Igc3Bhbm5pbmdcbiAgICAgICAgICAgICAgICBhbiBhcmNoaXZlLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHRoaXMuZGlza051bWJlciA9PT0gdXRpbHMuTUFYX1ZBTFVFXzE2QklUUyB8fCB0aGlzLmRpc2tXaXRoQ2VudHJhbERpclN0YXJ0ID09PSB1dGlscy5NQVhfVkFMVUVfMTZCSVRTIHx8IHRoaXMuY2VudHJhbERpclJlY29yZHNPblRoaXNEaXNrID09PSB1dGlscy5NQVhfVkFMVUVfMTZCSVRTIHx8IHRoaXMuY2VudHJhbERpclJlY29yZHMgPT09IHV0aWxzLk1BWF9WQUxVRV8xNkJJVFMgfHwgdGhpcy5jZW50cmFsRGlyU2l6ZSA9PT0gdXRpbHMuTUFYX1ZBTFVFXzMyQklUUyB8fCB0aGlzLmNlbnRyYWxEaXJPZmZzZXQgPT09IHV0aWxzLk1BWF9WQUxVRV8zMkJJVFMpIHtcbiAgICAgICAgICAgIHRoaXMuemlwNjQgPSB0cnVlO1xuXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgV2FybmluZyA6IHRoZSB6aXA2NCBleHRlbnNpb24gaXMgc3VwcG9ydGVkLCBidXQgT05MWSBpZiB0aGUgNjRiaXRzIGludGVnZXIgcmVhZCBmcm9tXG4gICAgICAgICAgICB0aGUgemlwIGZpbGUgY2FuIGZpdCBpbnRvIGEgMzJiaXRzIGludGVnZXIuIFRoaXMgY2Fubm90IGJlIHNvbHZlZCA6IEphdmFzY3JpcHQgcmVwcmVzZW50c1xuICAgICAgICAgICAgYWxsIG51bWJlcnMgYXMgNjQtYml0IGRvdWJsZSBwcmVjaXNpb24gSUVFRSA3NTQgZmxvYXRpbmcgcG9pbnQgbnVtYmVycy5cbiAgICAgICAgICAgIFNvLCB3ZSBoYXZlIDUzYml0cyBmb3IgaW50ZWdlcnMgYW5kIGJpdHdpc2Ugb3BlcmF0aW9ucyB0cmVhdCBldmVyeXRoaW5nIGFzIDMyYml0cy5cbiAgICAgICAgICAgIHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0phdmFTY3JpcHQvUmVmZXJlbmNlL09wZXJhdG9ycy9CaXR3aXNlX09wZXJhdG9yc1xuICAgICAgICAgICAgYW5kIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9wdWJsaWNhdGlvbnMvZmlsZXMvRUNNQS1TVC9FQ01BLTI2Mi5wZGYgc2VjdGlvbiA4LjVcbiAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIC8vIHNob3VsZCBsb29rIGZvciBhIHppcDY0IEVPQ0QgbG9jYXRvclxuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5yZWFkZXIubGFzdEluZGV4T2ZTaWduYXR1cmUoc2lnLlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0xPQ0FUT1IpO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3JydXB0ZWQgemlwIDogY2FuJ3QgZmluZCB0aGUgWklQNjQgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5IGxvY2F0b3JcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlYWRlci5zZXRJbmRleChvZmZzZXQpO1xuICAgICAgICAgICAgdGhpcy5jaGVja1NpZ25hdHVyZShzaWcuWklQNjRfQ0VOVFJBTF9ESVJFQ1RPUllfTE9DQVRPUik7XG4gICAgICAgICAgICB0aGlzLnJlYWRCbG9ja1ppcDY0RW5kT2ZDZW50cmFsTG9jYXRvcigpO1xuXG4gICAgICAgICAgICAvLyBub3cgdGhlIHppcDY0IEVPQ0QgcmVjb3JkXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNTaWduYXR1cmUodGhpcy5yZWxhdGl2ZU9mZnNldEVuZE9mWmlwNjRDZW50cmFsRGlyLCBzaWcuWklQNjRfQ0VOVFJBTF9ESVJFQ1RPUllfRU5EKSkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybihcIlpJUDY0IGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeSBub3Qgd2hlcmUgZXhwZWN0ZWQuXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVsYXRpdmVPZmZzZXRFbmRPZlppcDY0Q2VudHJhbERpciA9IHRoaXMucmVhZGVyLmxhc3RJbmRleE9mU2lnbmF0dXJlKHNpZy5aSVA2NF9DRU5UUkFMX0RJUkVDVE9SWV9FTkQpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlbGF0aXZlT2Zmc2V0RW5kT2ZaaXA2NENlbnRyYWxEaXIgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvcnJ1cHRlZCB6aXAgOiBjYW4ndCBmaW5kIHRoZSBaSVA2NCBlbmQgb2YgY2VudHJhbCBkaXJlY3RvcnlcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZWFkZXIuc2V0SW5kZXgodGhpcy5yZWxhdGl2ZU9mZnNldEVuZE9mWmlwNjRDZW50cmFsRGlyKTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tTaWduYXR1cmUoc2lnLlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0VORCk7XG4gICAgICAgICAgICB0aGlzLnJlYWRCbG9ja1ppcDY0RW5kT2ZDZW50cmFsKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZXhwZWN0ZWRFbmRPZkNlbnRyYWxEaXJPZmZzZXQgPSB0aGlzLmNlbnRyYWxEaXJPZmZzZXQgKyB0aGlzLmNlbnRyYWxEaXJTaXplO1xuICAgICAgICBpZiAodGhpcy56aXA2NCkge1xuICAgICAgICAgICAgZXhwZWN0ZWRFbmRPZkNlbnRyYWxEaXJPZmZzZXQgKz0gMjA7IC8vIGVuZCBvZiBjZW50cmFsIGRpciA2NCBsb2NhdG9yXG4gICAgICAgICAgICBleHBlY3RlZEVuZE9mQ2VudHJhbERpck9mZnNldCArPSAxMiAvKiBzaG91bGQgbm90IGluY2x1ZGUgdGhlIGxlYWRpbmcgMTIgYnl0ZXMgKi8gKyB0aGlzLnppcDY0RW5kT2ZDZW50cmFsU2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBleHRyYUJ5dGVzID0gZW5kT2ZDZW50cmFsRGlyT2Zmc2V0IC0gZXhwZWN0ZWRFbmRPZkNlbnRyYWxEaXJPZmZzZXQ7XG5cbiAgICAgICAgaWYgKGV4dHJhQnl0ZXMgPiAwKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oZXh0cmFCeXRlcywgXCJleHRyYSBieXRlcyBhdCBiZWdpbm5pbmcgb3Igd2l0aGluIHppcGZpbGVcIik7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1NpZ25hdHVyZShlbmRPZkNlbnRyYWxEaXJPZmZzZXQsIHNpZy5DRU5UUkFMX0ZJTEVfSEVBREVSKSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBvZmZzZXRzIHNlZW0gd3JvbmcsIGJ1dCB3ZSBoYXZlIHNvbWV0aGluZyBhdCB0aGUgc3BlY2lmaWVkIG9mZnNldC5cbiAgICAgICAgICAgICAgICAvLyBTb+KApiB3ZSBrZWVwIGl0LlxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB0aGUgb2Zmc2V0IGlzIHdyb25nLCB1cGRhdGUgdGhlIFwiemVyb1wiIG9mIHRoZSByZWFkZXJcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGhhcHBlbnMgaWYgZGF0YSBoYXMgYmVlbiBwcmVwZW5kZWQgKGNyeCBmaWxlcyBmb3IgZXhhbXBsZSlcbiAgICAgICAgICAgICAgICB0aGlzLnJlYWRlci56ZXJvID0gZXh0cmFCeXRlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChleHRyYUJ5dGVzIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29ycnVwdGVkIHppcDogbWlzc2luZyBcIiArIE1hdGguYWJzKGV4dHJhQnl0ZXMpICsgXCIgYnl0ZXMuXCIpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBwcmVwYXJlUmVhZGVyOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHZhciB0eXBlID0gdXRpbHMuZ2V0VHlwZU9mKGRhdGEpO1xuICAgICAgICB1dGlscy5jaGVja1N1cHBvcnQodHlwZSk7XG4gICAgICAgIGlmICh0eXBlID09PSBcInN0cmluZ1wiICYmICFzdXBwb3J0LnVpbnQ4YXJyYXkpIHtcbiAgICAgICAgICAgIHRoaXMucmVhZGVyID0gbmV3IFN0cmluZ1JlYWRlcihkYXRhLCB0aGlzLmxvYWRPcHRpb25zLm9wdGltaXplZEJpbmFyeVN0cmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gXCJub2RlYnVmZmVyXCIpIHtcbiAgICAgICAgICAgIHRoaXMucmVhZGVyID0gbmV3IE5vZGVCdWZmZXJSZWFkZXIoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3VwcG9ydC51aW50OGFycmF5KSB7XG4gICAgICAgICAgICB0aGlzLnJlYWRlciA9IG5ldyBVaW50OEFycmF5UmVhZGVyKHV0aWxzLnRyYW5zZm9ybVRvKFwidWludDhhcnJheVwiLCBkYXRhKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5hcnJheSkge1xuICAgICAgICAgICAgdGhpcy5yZWFkZXIgPSBuZXcgQXJyYXlSZWFkZXIodXRpbHMudHJhbnNmb3JtVG8oXCJhcnJheVwiLCBkYXRhKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGVycm9yOiB1bnN1cHBvcnRlZCB0eXBlICdcIiArIHR5cGUgKyBcIidcIik7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlYWQgYSB6aXAgZmlsZSBhbmQgY3JlYXRlIFppcEVudHJpZXMuXG4gICAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGRhdGEgdGhlIGJpbmFyeSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgemlwIGZpbGUuXG4gICAgICovXG4gICAgbG9hZDogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB0aGlzLnByZXBhcmVSZWFkZXIoZGF0YSk7XG4gICAgICAgIHRoaXMucmVhZEVuZE9mQ2VudHJhbCgpO1xuICAgICAgICB0aGlzLnJlYWRDZW50cmFsRGlyKCk7XG4gICAgICAgIHRoaXMucmVhZExvY2FsRmlsZXMoKTtcbiAgICB9XG59O1xuLy8gfX19IGVuZCBvZiBaaXBFbnRyaWVzXG5tb2R1bGUuZXhwb3J0cyA9IFppcEVudHJpZXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vanN6aXAvbGliL3ppcEVudHJpZXMuanNcbi8vIG1vZHVsZSBpZCA9IDEwNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9')},function(module,exports,__webpack_require__){"use strict";eval('\nvar StringReader = __webpack_require__(46);\nvar utils = __webpack_require__(1);\nvar CompressedObject = __webpack_require__(42);\nvar jszipProto = __webpack_require__(28);\nvar support = __webpack_require__(6);\n\nvar MADE_BY_DOS = 0x00;\nvar MADE_BY_UNIX = 0x03;\n\n// class ZipEntry {{{\n/**\n * An entry in the zip file.\n * @constructor\n * @param {Object} options Options of the current file.\n * @param {Object} loadOptions Options for loading the stream.\n */\nfunction ZipEntry(options, loadOptions) {\n    this.options = options;\n    this.loadOptions = loadOptions;\n}\nZipEntry.prototype = {\n    /**\n     * say if the file is encrypted.\n     * @return {boolean} true if the file is encrypted, false otherwise.\n     */\n    isEncrypted: function() {\n        // bit 1 is set\n        return (this.bitFlag & 0x0001) === 0x0001;\n    },\n    /**\n     * say if the file has utf-8 filename/comment.\n     * @return {boolean} true if the filename/comment is in utf-8, false otherwise.\n     */\n    useUTF8: function() {\n        // bit 11 is set\n        return (this.bitFlag & 0x0800) === 0x0800;\n    },\n    /**\n     * Prepare the function used to generate the compressed content from this ZipFile.\n     * @param {DataReader} reader the reader to use.\n     * @param {number} from the offset from where we should read the data.\n     * @param {number} length the length of the data to read.\n     * @return {Function} the callback to get the compressed content (the type depends of the DataReader class).\n     */\n    prepareCompressedContent: function(reader, from, length) {\n        return function() {\n            var previousIndex = reader.index;\n            reader.setIndex(from);\n            var compressedFileData = reader.readData(length);\n            reader.setIndex(previousIndex);\n\n            return compressedFileData;\n        };\n    },\n    /**\n     * Prepare the function used to generate the uncompressed content from this ZipFile.\n     * @param {DataReader} reader the reader to use.\n     * @param {number} from the offset from where we should read the data.\n     * @param {number} length the length of the data to read.\n     * @param {JSZip.compression} compression the compression used on this file.\n     * @param {number} uncompressedSize the uncompressed size to expect.\n     * @return {Function} the callback to get the uncompressed content (the type depends of the DataReader class).\n     */\n    prepareContent: function(reader, from, length, compression, uncompressedSize) {\n        return function() {\n\n            var compressedFileData = utils.transformTo(compression.uncompressInputType, this.getCompressedContent());\n            var uncompressedFileData = compression.uncompress(compressedFileData);\n\n            if (uncompressedFileData.length !== uncompressedSize) {\n                throw new Error("Bug : uncompressed data size mismatch");\n            }\n\n            return uncompressedFileData;\n        };\n    },\n    /**\n     * Read the local part of a zip file and add the info in this object.\n     * @param {DataReader} reader the reader to use.\n     */\n    readLocalPart: function(reader) {\n        var compression, localExtraFieldsLength;\n\n        // we already know everything from the central dir !\n        // If the central dir data are false, we are doomed.\n        // On the bright side, the local part is scary  : zip64, data descriptors, both, etc.\n        // The less data we get here, the more reliable this should be.\n        // Let\'s skip the whole header and dash to the data !\n        reader.skip(22);\n        // in some zip created on windows, the filename stored in the central dir contains \\ instead of /.\n        // Strangely, the filename here is OK.\n        // I would love to treat these zip files as corrupted (see http://www.info-zip.org/FAQ.html#backslashes\n        // or APPNOTE#4.4.17.1, "All slashes MUST be forward slashes \'/\'") but there are a lot of bad zip generators...\n        // Search "unzip mismatching "local" filename continuing with "central" filename version" on\n        // the internet.\n        //\n        // I think I see the logic here : the central directory is used to display\n        // content and the local directory is used to extract the files. Mixing / and \\\n        // may be used to display \\ to windows users and use / when extracting the files.\n        // Unfortunately, this lead also to some issues : http://seclists.org/fulldisclosure/2009/Sep/394\n        this.fileNameLength = reader.readInt(2);\n        localExtraFieldsLength = reader.readInt(2); // can\'t be sure this will be the same as the central dir\n        this.fileName = reader.readData(this.fileNameLength);\n        reader.skip(localExtraFieldsLength);\n\n        if (this.compressedSize == -1 || this.uncompressedSize == -1) {\n            throw new Error("Bug or corrupted zip : didn\'t get enough informations from the central directory " + "(compressedSize == -1 || uncompressedSize == -1)");\n        }\n\n        compression = utils.findCompression(this.compressionMethod);\n        if (compression === null) { // no compression found\n            throw new Error("Corrupted zip : compression " + utils.pretty(this.compressionMethod) + " unknown (inner file : " +  utils.transformTo("string", this.fileName) + ")");\n        }\n        this.decompressed = new CompressedObject();\n        this.decompressed.compressedSize = this.compressedSize;\n        this.decompressed.uncompressedSize = this.uncompressedSize;\n        this.decompressed.crc32 = this.crc32;\n        this.decompressed.compressionMethod = this.compressionMethod;\n        this.decompressed.getCompressedContent = this.prepareCompressedContent(reader, reader.index, this.compressedSize, compression);\n        this.decompressed.getContent = this.prepareContent(reader, reader.index, this.compressedSize, compression, this.uncompressedSize);\n\n        // we need to compute the crc32...\n        if (this.loadOptions.checkCRC32) {\n            this.decompressed = utils.transformTo("string", this.decompressed.getContent());\n            if (jszipProto.crc32(this.decompressed) !== this.crc32) {\n                throw new Error("Corrupted zip : CRC32 mismatch");\n            }\n        }\n    },\n\n    /**\n     * Read the central part of a zip file and add the info in this object.\n     * @param {DataReader} reader the reader to use.\n     */\n    readCentralPart: function(reader) {\n        this.versionMadeBy = reader.readInt(2);\n        this.versionNeeded = reader.readInt(2);\n        this.bitFlag = reader.readInt(2);\n        this.compressionMethod = reader.readString(2);\n        this.date = reader.readDate();\n        this.crc32 = reader.readInt(4);\n        this.compressedSize = reader.readInt(4);\n        this.uncompressedSize = reader.readInt(4);\n        this.fileNameLength = reader.readInt(2);\n        this.extraFieldsLength = reader.readInt(2);\n        this.fileCommentLength = reader.readInt(2);\n        this.diskNumberStart = reader.readInt(2);\n        this.internalFileAttributes = reader.readInt(2);\n        this.externalFileAttributes = reader.readInt(4);\n        this.localHeaderOffset = reader.readInt(4);\n\n        if (this.isEncrypted()) {\n            throw new Error("Encrypted zip are not supported");\n        }\n\n        this.fileName = reader.readData(this.fileNameLength);\n        this.readExtraFields(reader);\n        this.parseZIP64ExtraField(reader);\n        this.fileComment = reader.readData(this.fileCommentLength);\n    },\n\n    /**\n     * Parse the external file attributes and get the unix/dos permissions.\n     */\n    processAttributes: function () {\n        this.unixPermissions = null;\n        this.dosPermissions = null;\n        var madeBy = this.versionMadeBy >> 8;\n\n        // Check if we have the DOS directory flag set.\n        // We look for it in the DOS and UNIX permissions\n        // but some unknown platform could set it as a compatibility flag.\n        this.dir = this.externalFileAttributes & 0x0010 ? true : false;\n\n        if(madeBy === MADE_BY_DOS) {\n            // first 6 bits (0 to 5)\n            this.dosPermissions = this.externalFileAttributes & 0x3F;\n        }\n\n        if(madeBy === MADE_BY_UNIX) {\n            this.unixPermissions = (this.externalFileAttributes >> 16) & 0xFFFF;\n            // the octal permissions are in (this.unixPermissions & 0x01FF).toString(8);\n        }\n\n        // fail safe : if the name ends with a / it probably means a folder\n        if (!this.dir && this.fileNameStr.slice(-1) === \'/\') {\n            this.dir = true;\n        }\n    },\n\n    /**\n     * Parse the ZIP64 extra field and merge the info in the current ZipEntry.\n     * @param {DataReader} reader the reader to use.\n     */\n    parseZIP64ExtraField: function(reader) {\n\n        if (!this.extraFields[0x0001]) {\n            return;\n        }\n\n        // should be something, preparing the extra reader\n        var extraReader = new StringReader(this.extraFields[0x0001].value);\n\n        // I really hope that these 64bits integer can fit in 32 bits integer, because js\n        // won\'t let us have more.\n        if (this.uncompressedSize === utils.MAX_VALUE_32BITS) {\n            this.uncompressedSize = extraReader.readInt(8);\n        }\n        if (this.compressedSize === utils.MAX_VALUE_32BITS) {\n            this.compressedSize = extraReader.readInt(8);\n        }\n        if (this.localHeaderOffset === utils.MAX_VALUE_32BITS) {\n            this.localHeaderOffset = extraReader.readInt(8);\n        }\n        if (this.diskNumberStart === utils.MAX_VALUE_32BITS) {\n            this.diskNumberStart = extraReader.readInt(4);\n        }\n    },\n    /**\n     * Read the central part of a zip file and add the info in this object.\n     * @param {DataReader} reader the reader to use.\n     */\n    readExtraFields: function(reader) {\n        var start = reader.index,\n            extraFieldId,\n            extraFieldLength,\n            extraFieldValue;\n\n        this.extraFields = this.extraFields || {};\n\n        while (reader.index < start + this.extraFieldsLength) {\n            extraFieldId = reader.readInt(2);\n            extraFieldLength = reader.readInt(2);\n            extraFieldValue = reader.readString(extraFieldLength);\n\n            this.extraFields[extraFieldId] = {\n                id: extraFieldId,\n                length: extraFieldLength,\n                value: extraFieldValue\n            };\n        }\n    },\n    /**\n     * Apply an UTF8 transformation if needed.\n     */\n    handleUTF8: function() {\n        var decodeParamType = support.uint8array ? "uint8array" : "array";\n        if (this.useUTF8()) {\n            this.fileNameStr = jszipProto.utf8decode(this.fileName);\n            this.fileCommentStr = jszipProto.utf8decode(this.fileComment);\n        } else {\n            var upath = this.findExtraFieldUnicodePath();\n            if (upath !== null) {\n                this.fileNameStr = upath;\n            } else {\n                var fileNameByteArray =  utils.transformTo(decodeParamType, this.fileName);\n                this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);\n            }\n\n            var ucomment = this.findExtraFieldUnicodeComment();\n            if (ucomment !== null) {\n                this.fileCommentStr = ucomment;\n            } else {\n                var commentByteArray =  utils.transformTo(decodeParamType, this.fileComment);\n                this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);\n            }\n        }\n    },\n\n    /**\n     * Find the unicode path declared in the extra field, if any.\n     * @return {String} the unicode path, null otherwise.\n     */\n    findExtraFieldUnicodePath: function() {\n        var upathField = this.extraFields[0x7075];\n        if (upathField) {\n            var extraReader = new StringReader(upathField.value);\n\n            // wrong version\n            if (extraReader.readInt(1) !== 1) {\n                return null;\n            }\n\n            // the crc of the filename changed, this field is out of date.\n            if (jszipProto.crc32(this.fileName) !== extraReader.readInt(4)) {\n                return null;\n            }\n\n            return jszipProto.utf8decode(extraReader.readString(upathField.length - 5));\n        }\n        return null;\n    },\n\n    /**\n     * Find the unicode comment declared in the extra field, if any.\n     * @return {String} the unicode comment, null otherwise.\n     */\n    findExtraFieldUnicodeComment: function() {\n        var ucommentField = this.extraFields[0x6375];\n        if (ucommentField) {\n            var extraReader = new StringReader(ucommentField.value);\n\n            // wrong version\n            if (extraReader.readInt(1) !== 1) {\n                return null;\n            }\n\n            // the crc of the comment changed, this field is out of date.\n            if (jszipProto.crc32(this.fileComment) !== extraReader.readInt(4)) {\n                return null;\n            }\n\n            return jszipProto.utf8decode(extraReader.readString(ucommentField.length - 5));\n        }\n        return null;\n    }\n};\nmodule.exports = ZipEntry;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2pzemlwL2xpYi96aXBFbnRyeS5qcz83NmMxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLGtCQUFrQjtBQUNqQyxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxMDUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgU3RyaW5nUmVhZGVyID0gcmVxdWlyZSgnLi9zdHJpbmdSZWFkZXInKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBDb21wcmVzc2VkT2JqZWN0ID0gcmVxdWlyZSgnLi9jb21wcmVzc2VkT2JqZWN0Jyk7XG52YXIganN6aXBQcm90byA9IHJlcXVpcmUoJy4vb2JqZWN0Jyk7XG52YXIgc3VwcG9ydCA9IHJlcXVpcmUoJy4vc3VwcG9ydCcpO1xuXG52YXIgTUFERV9CWV9ET1MgPSAweDAwO1xudmFyIE1BREVfQllfVU5JWCA9IDB4MDM7XG5cbi8vIGNsYXNzIFppcEVudHJ5IHt7e1xuLyoqXG4gKiBBbiBlbnRyeSBpbiB0aGUgemlwIGZpbGUuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2YgdGhlIGN1cnJlbnQgZmlsZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBsb2FkT3B0aW9ucyBPcHRpb25zIGZvciBsb2FkaW5nIHRoZSBzdHJlYW0uXG4gKi9cbmZ1bmN0aW9uIFppcEVudHJ5KG9wdGlvbnMsIGxvYWRPcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmxvYWRPcHRpb25zID0gbG9hZE9wdGlvbnM7XG59XG5aaXBFbnRyeS5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogc2F5IGlmIHRoZSBmaWxlIGlzIGVuY3J5cHRlZC5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBmaWxlIGlzIGVuY3J5cHRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGlzRW5jcnlwdGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gYml0IDEgaXMgc2V0XG4gICAgICAgIHJldHVybiAodGhpcy5iaXRGbGFnICYgMHgwMDAxKSA9PT0gMHgwMDAxO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogc2F5IGlmIHRoZSBmaWxlIGhhcyB1dGYtOCBmaWxlbmFtZS9jb21tZW50LlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIGZpbGVuYW1lL2NvbW1lbnQgaXMgaW4gdXRmLTgsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICB1c2VVVEY4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gYml0IDExIGlzIHNldFxuICAgICAgICByZXR1cm4gKHRoaXMuYml0RmxhZyAmIDB4MDgwMCkgPT09IDB4MDgwMDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFByZXBhcmUgdGhlIGZ1bmN0aW9uIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIGNvbXByZXNzZWQgY29udGVudCBmcm9tIHRoaXMgWmlwRmlsZS5cbiAgICAgKiBAcGFyYW0ge0RhdGFSZWFkZXJ9IHJlYWRlciB0aGUgcmVhZGVyIHRvIHVzZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbSB0aGUgb2Zmc2V0IGZyb20gd2hlcmUgd2Ugc2hvdWxkIHJlYWQgdGhlIGRhdGEuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCB0aGUgbGVuZ3RoIG9mIHRoZSBkYXRhIHRvIHJlYWQuXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IHRoZSBjYWxsYmFjayB0byBnZXQgdGhlIGNvbXByZXNzZWQgY29udGVudCAodGhlIHR5cGUgZGVwZW5kcyBvZiB0aGUgRGF0YVJlYWRlciBjbGFzcykuXG4gICAgICovXG4gICAgcHJlcGFyZUNvbXByZXNzZWRDb250ZW50OiBmdW5jdGlvbihyZWFkZXIsIGZyb20sIGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXNJbmRleCA9IHJlYWRlci5pbmRleDtcbiAgICAgICAgICAgIHJlYWRlci5zZXRJbmRleChmcm9tKTtcbiAgICAgICAgICAgIHZhciBjb21wcmVzc2VkRmlsZURhdGEgPSByZWFkZXIucmVhZERhdGEobGVuZ3RoKTtcbiAgICAgICAgICAgIHJlYWRlci5zZXRJbmRleChwcmV2aW91c0luZGV4KTtcblxuICAgICAgICAgICAgcmV0dXJuIGNvbXByZXNzZWRGaWxlRGF0YTtcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFByZXBhcmUgdGhlIGZ1bmN0aW9uIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIHVuY29tcHJlc3NlZCBjb250ZW50IGZyb20gdGhpcyBaaXBGaWxlLlxuICAgICAqIEBwYXJhbSB7RGF0YVJlYWRlcn0gcmVhZGVyIHRoZSByZWFkZXIgdG8gdXNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tIHRoZSBvZmZzZXQgZnJvbSB3aGVyZSB3ZSBzaG91bGQgcmVhZCB0aGUgZGF0YS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIHRoZSBsZW5ndGggb2YgdGhlIGRhdGEgdG8gcmVhZC5cbiAgICAgKiBAcGFyYW0ge0pTWmlwLmNvbXByZXNzaW9ufSBjb21wcmVzc2lvbiB0aGUgY29tcHJlc3Npb24gdXNlZCBvbiB0aGlzIGZpbGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHVuY29tcHJlc3NlZFNpemUgdGhlIHVuY29tcHJlc3NlZCBzaXplIHRvIGV4cGVjdC5cbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gdGhlIGNhbGxiYWNrIHRvIGdldCB0aGUgdW5jb21wcmVzc2VkIGNvbnRlbnQgKHRoZSB0eXBlIGRlcGVuZHMgb2YgdGhlIERhdGFSZWFkZXIgY2xhc3MpLlxuICAgICAqL1xuICAgIHByZXBhcmVDb250ZW50OiBmdW5jdGlvbihyZWFkZXIsIGZyb20sIGxlbmd0aCwgY29tcHJlc3Npb24sIHVuY29tcHJlc3NlZFNpemUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICB2YXIgY29tcHJlc3NlZEZpbGVEYXRhID0gdXRpbHMudHJhbnNmb3JtVG8oY29tcHJlc3Npb24udW5jb21wcmVzc0lucHV0VHlwZSwgdGhpcy5nZXRDb21wcmVzc2VkQ29udGVudCgpKTtcbiAgICAgICAgICAgIHZhciB1bmNvbXByZXNzZWRGaWxlRGF0YSA9IGNvbXByZXNzaW9uLnVuY29tcHJlc3MoY29tcHJlc3NlZEZpbGVEYXRhKTtcblxuICAgICAgICAgICAgaWYgKHVuY29tcHJlc3NlZEZpbGVEYXRhLmxlbmd0aCAhPT0gdW5jb21wcmVzc2VkU2l6ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJ1ZyA6IHVuY29tcHJlc3NlZCBkYXRhIHNpemUgbWlzbWF0Y2hcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB1bmNvbXByZXNzZWRGaWxlRGF0YTtcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIGxvY2FsIHBhcnQgb2YgYSB6aXAgZmlsZSBhbmQgYWRkIHRoZSBpbmZvIGluIHRoaXMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RGF0YVJlYWRlcn0gcmVhZGVyIHRoZSByZWFkZXIgdG8gdXNlLlxuICAgICAqL1xuICAgIHJlYWRMb2NhbFBhcnQ6IGZ1bmN0aW9uKHJlYWRlcikge1xuICAgICAgICB2YXIgY29tcHJlc3Npb24sIGxvY2FsRXh0cmFGaWVsZHNMZW5ndGg7XG5cbiAgICAgICAgLy8gd2UgYWxyZWFkeSBrbm93IGV2ZXJ5dGhpbmcgZnJvbSB0aGUgY2VudHJhbCBkaXIgIVxuICAgICAgICAvLyBJZiB0aGUgY2VudHJhbCBkaXIgZGF0YSBhcmUgZmFsc2UsIHdlIGFyZSBkb29tZWQuXG4gICAgICAgIC8vIE9uIHRoZSBicmlnaHQgc2lkZSwgdGhlIGxvY2FsIHBhcnQgaXMgc2NhcnkgIDogemlwNjQsIGRhdGEgZGVzY3JpcHRvcnMsIGJvdGgsIGV0Yy5cbiAgICAgICAgLy8gVGhlIGxlc3MgZGF0YSB3ZSBnZXQgaGVyZSwgdGhlIG1vcmUgcmVsaWFibGUgdGhpcyBzaG91bGQgYmUuXG4gICAgICAgIC8vIExldCdzIHNraXAgdGhlIHdob2xlIGhlYWRlciBhbmQgZGFzaCB0byB0aGUgZGF0YSAhXG4gICAgICAgIHJlYWRlci5za2lwKDIyKTtcbiAgICAgICAgLy8gaW4gc29tZSB6aXAgY3JlYXRlZCBvbiB3aW5kb3dzLCB0aGUgZmlsZW5hbWUgc3RvcmVkIGluIHRoZSBjZW50cmFsIGRpciBjb250YWlucyBcXCBpbnN0ZWFkIG9mIC8uXG4gICAgICAgIC8vIFN0cmFuZ2VseSwgdGhlIGZpbGVuYW1lIGhlcmUgaXMgT0suXG4gICAgICAgIC8vIEkgd291bGQgbG92ZSB0byB0cmVhdCB0aGVzZSB6aXAgZmlsZXMgYXMgY29ycnVwdGVkIChzZWUgaHR0cDovL3d3dy5pbmZvLXppcC5vcmcvRkFRLmh0bWwjYmFja3NsYXNoZXNcbiAgICAgICAgLy8gb3IgQVBQTk9URSM0LjQuMTcuMSwgXCJBbGwgc2xhc2hlcyBNVVNUIGJlIGZvcndhcmQgc2xhc2hlcyAnLydcIikgYnV0IHRoZXJlIGFyZSBhIGxvdCBvZiBiYWQgemlwIGdlbmVyYXRvcnMuLi5cbiAgICAgICAgLy8gU2VhcmNoIFwidW56aXAgbWlzbWF0Y2hpbmcgXCJsb2NhbFwiIGZpbGVuYW1lIGNvbnRpbnVpbmcgd2l0aCBcImNlbnRyYWxcIiBmaWxlbmFtZSB2ZXJzaW9uXCIgb25cbiAgICAgICAgLy8gdGhlIGludGVybmV0LlxuICAgICAgICAvL1xuICAgICAgICAvLyBJIHRoaW5rIEkgc2VlIHRoZSBsb2dpYyBoZXJlIDogdGhlIGNlbnRyYWwgZGlyZWN0b3J5IGlzIHVzZWQgdG8gZGlzcGxheVxuICAgICAgICAvLyBjb250ZW50IGFuZCB0aGUgbG9jYWwgZGlyZWN0b3J5IGlzIHVzZWQgdG8gZXh0cmFjdCB0aGUgZmlsZXMuIE1peGluZyAvIGFuZCBcXFxuICAgICAgICAvLyBtYXkgYmUgdXNlZCB0byBkaXNwbGF5IFxcIHRvIHdpbmRvd3MgdXNlcnMgYW5kIHVzZSAvIHdoZW4gZXh0cmFjdGluZyB0aGUgZmlsZXMuXG4gICAgICAgIC8vIFVuZm9ydHVuYXRlbHksIHRoaXMgbGVhZCBhbHNvIHRvIHNvbWUgaXNzdWVzIDogaHR0cDovL3NlY2xpc3RzLm9yZy9mdWxsZGlzY2xvc3VyZS8yMDA5L1NlcC8zOTRcbiAgICAgICAgdGhpcy5maWxlTmFtZUxlbmd0aCA9IHJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICBsb2NhbEV4dHJhRmllbGRzTGVuZ3RoID0gcmVhZGVyLnJlYWRJbnQoMik7IC8vIGNhbid0IGJlIHN1cmUgdGhpcyB3aWxsIGJlIHRoZSBzYW1lIGFzIHRoZSBjZW50cmFsIGRpclxuICAgICAgICB0aGlzLmZpbGVOYW1lID0gcmVhZGVyLnJlYWREYXRhKHRoaXMuZmlsZU5hbWVMZW5ndGgpO1xuICAgICAgICByZWFkZXIuc2tpcChsb2NhbEV4dHJhRmllbGRzTGVuZ3RoKTtcblxuICAgICAgICBpZiAodGhpcy5jb21wcmVzc2VkU2l6ZSA9PSAtMSB8fCB0aGlzLnVuY29tcHJlc3NlZFNpemUgPT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJ1ZyBvciBjb3JydXB0ZWQgemlwIDogZGlkbid0IGdldCBlbm91Z2ggaW5mb3JtYXRpb25zIGZyb20gdGhlIGNlbnRyYWwgZGlyZWN0b3J5IFwiICsgXCIoY29tcHJlc3NlZFNpemUgPT0gLTEgfHwgdW5jb21wcmVzc2VkU2l6ZSA9PSAtMSlcIik7XG4gICAgICAgIH1cblxuICAgICAgICBjb21wcmVzc2lvbiA9IHV0aWxzLmZpbmRDb21wcmVzc2lvbih0aGlzLmNvbXByZXNzaW9uTWV0aG9kKTtcbiAgICAgICAgaWYgKGNvbXByZXNzaW9uID09PSBudWxsKSB7IC8vIG5vIGNvbXByZXNzaW9uIGZvdW5kXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3JydXB0ZWQgemlwIDogY29tcHJlc3Npb24gXCIgKyB1dGlscy5wcmV0dHkodGhpcy5jb21wcmVzc2lvbk1ldGhvZCkgKyBcIiB1bmtub3duIChpbm5lciBmaWxlIDogXCIgKyAgdXRpbHMudHJhbnNmb3JtVG8oXCJzdHJpbmdcIiwgdGhpcy5maWxlTmFtZSkgKyBcIilcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZWNvbXByZXNzZWQgPSBuZXcgQ29tcHJlc3NlZE9iamVjdCgpO1xuICAgICAgICB0aGlzLmRlY29tcHJlc3NlZC5jb21wcmVzc2VkU2l6ZSA9IHRoaXMuY29tcHJlc3NlZFNpemU7XG4gICAgICAgIHRoaXMuZGVjb21wcmVzc2VkLnVuY29tcHJlc3NlZFNpemUgPSB0aGlzLnVuY29tcHJlc3NlZFNpemU7XG4gICAgICAgIHRoaXMuZGVjb21wcmVzc2VkLmNyYzMyID0gdGhpcy5jcmMzMjtcbiAgICAgICAgdGhpcy5kZWNvbXByZXNzZWQuY29tcHJlc3Npb25NZXRob2QgPSB0aGlzLmNvbXByZXNzaW9uTWV0aG9kO1xuICAgICAgICB0aGlzLmRlY29tcHJlc3NlZC5nZXRDb21wcmVzc2VkQ29udGVudCA9IHRoaXMucHJlcGFyZUNvbXByZXNzZWRDb250ZW50KHJlYWRlciwgcmVhZGVyLmluZGV4LCB0aGlzLmNvbXByZXNzZWRTaXplLCBjb21wcmVzc2lvbik7XG4gICAgICAgIHRoaXMuZGVjb21wcmVzc2VkLmdldENvbnRlbnQgPSB0aGlzLnByZXBhcmVDb250ZW50KHJlYWRlciwgcmVhZGVyLmluZGV4LCB0aGlzLmNvbXByZXNzZWRTaXplLCBjb21wcmVzc2lvbiwgdGhpcy51bmNvbXByZXNzZWRTaXplKTtcblxuICAgICAgICAvLyB3ZSBuZWVkIHRvIGNvbXB1dGUgdGhlIGNyYzMyLi4uXG4gICAgICAgIGlmICh0aGlzLmxvYWRPcHRpb25zLmNoZWNrQ1JDMzIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVjb21wcmVzc2VkID0gdXRpbHMudHJhbnNmb3JtVG8oXCJzdHJpbmdcIiwgdGhpcy5kZWNvbXByZXNzZWQuZ2V0Q29udGVudCgpKTtcbiAgICAgICAgICAgIGlmIChqc3ppcFByb3RvLmNyYzMyKHRoaXMuZGVjb21wcmVzc2VkKSAhPT0gdGhpcy5jcmMzMikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvcnJ1cHRlZCB6aXAgOiBDUkMzMiBtaXNtYXRjaFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSBjZW50cmFsIHBhcnQgb2YgYSB6aXAgZmlsZSBhbmQgYWRkIHRoZSBpbmZvIGluIHRoaXMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RGF0YVJlYWRlcn0gcmVhZGVyIHRoZSByZWFkZXIgdG8gdXNlLlxuICAgICAqL1xuICAgIHJlYWRDZW50cmFsUGFydDogZnVuY3Rpb24ocmVhZGVyKSB7XG4gICAgICAgIHRoaXMudmVyc2lvbk1hZGVCeSA9IHJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICB0aGlzLnZlcnNpb25OZWVkZWQgPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5iaXRGbGFnID0gcmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuY29tcHJlc3Npb25NZXRob2QgPSByZWFkZXIucmVhZFN0cmluZygyKTtcbiAgICAgICAgdGhpcy5kYXRlID0gcmVhZGVyLnJlYWREYXRlKCk7XG4gICAgICAgIHRoaXMuY3JjMzIgPSByZWFkZXIucmVhZEludCg0KTtcbiAgICAgICAgdGhpcy5jb21wcmVzc2VkU2l6ZSA9IHJlYWRlci5yZWFkSW50KDQpO1xuICAgICAgICB0aGlzLnVuY29tcHJlc3NlZFNpemUgPSByZWFkZXIucmVhZEludCg0KTtcbiAgICAgICAgdGhpcy5maWxlTmFtZUxlbmd0aCA9IHJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICB0aGlzLmV4dHJhRmllbGRzTGVuZ3RoID0gcmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuZmlsZUNvbW1lbnRMZW5ndGggPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5kaXNrTnVtYmVyU3RhcnQgPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5pbnRlcm5hbEZpbGVBdHRyaWJ1dGVzID0gcmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuZXh0ZXJuYWxGaWxlQXR0cmlidXRlcyA9IHJlYWRlci5yZWFkSW50KDQpO1xuICAgICAgICB0aGlzLmxvY2FsSGVhZGVyT2Zmc2V0ID0gcmVhZGVyLnJlYWRJbnQoNCk7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNFbmNyeXB0ZWQoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRW5jcnlwdGVkIHppcCBhcmUgbm90IHN1cHBvcnRlZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZmlsZU5hbWUgPSByZWFkZXIucmVhZERhdGEodGhpcy5maWxlTmFtZUxlbmd0aCk7XG4gICAgICAgIHRoaXMucmVhZEV4dHJhRmllbGRzKHJlYWRlcik7XG4gICAgICAgIHRoaXMucGFyc2VaSVA2NEV4dHJhRmllbGQocmVhZGVyKTtcbiAgICAgICAgdGhpcy5maWxlQ29tbWVudCA9IHJlYWRlci5yZWFkRGF0YSh0aGlzLmZpbGVDb21tZW50TGVuZ3RoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGFyc2UgdGhlIGV4dGVybmFsIGZpbGUgYXR0cmlidXRlcyBhbmQgZ2V0IHRoZSB1bml4L2RvcyBwZXJtaXNzaW9ucy5cbiAgICAgKi9cbiAgICBwcm9jZXNzQXR0cmlidXRlczogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVuaXhQZXJtaXNzaW9ucyA9IG51bGw7XG4gICAgICAgIHRoaXMuZG9zUGVybWlzc2lvbnMgPSBudWxsO1xuICAgICAgICB2YXIgbWFkZUJ5ID0gdGhpcy52ZXJzaW9uTWFkZUJ5ID4+IDg7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSB0aGUgRE9TIGRpcmVjdG9yeSBmbGFnIHNldC5cbiAgICAgICAgLy8gV2UgbG9vayBmb3IgaXQgaW4gdGhlIERPUyBhbmQgVU5JWCBwZXJtaXNzaW9uc1xuICAgICAgICAvLyBidXQgc29tZSB1bmtub3duIHBsYXRmb3JtIGNvdWxkIHNldCBpdCBhcyBhIGNvbXBhdGliaWxpdHkgZmxhZy5cbiAgICAgICAgdGhpcy5kaXIgPSB0aGlzLmV4dGVybmFsRmlsZUF0dHJpYnV0ZXMgJiAweDAwMTAgPyB0cnVlIDogZmFsc2U7XG5cbiAgICAgICAgaWYobWFkZUJ5ID09PSBNQURFX0JZX0RPUykge1xuICAgICAgICAgICAgLy8gZmlyc3QgNiBiaXRzICgwIHRvIDUpXG4gICAgICAgICAgICB0aGlzLmRvc1Blcm1pc3Npb25zID0gdGhpcy5leHRlcm5hbEZpbGVBdHRyaWJ1dGVzICYgMHgzRjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKG1hZGVCeSA9PT0gTUFERV9CWV9VTklYKSB7XG4gICAgICAgICAgICB0aGlzLnVuaXhQZXJtaXNzaW9ucyA9ICh0aGlzLmV4dGVybmFsRmlsZUF0dHJpYnV0ZXMgPj4gMTYpICYgMHhGRkZGO1xuICAgICAgICAgICAgLy8gdGhlIG9jdGFsIHBlcm1pc3Npb25zIGFyZSBpbiAodGhpcy51bml4UGVybWlzc2lvbnMgJiAweDAxRkYpLnRvU3RyaW5nKDgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmFpbCBzYWZlIDogaWYgdGhlIG5hbWUgZW5kcyB3aXRoIGEgLyBpdCBwcm9iYWJseSBtZWFucyBhIGZvbGRlclxuICAgICAgICBpZiAoIXRoaXMuZGlyICYmIHRoaXMuZmlsZU5hbWVTdHIuc2xpY2UoLTEpID09PSAnLycpIHtcbiAgICAgICAgICAgIHRoaXMuZGlyID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSB0aGUgWklQNjQgZXh0cmEgZmllbGQgYW5kIG1lcmdlIHRoZSBpbmZvIGluIHRoZSBjdXJyZW50IFppcEVudHJ5LlxuICAgICAqIEBwYXJhbSB7RGF0YVJlYWRlcn0gcmVhZGVyIHRoZSByZWFkZXIgdG8gdXNlLlxuICAgICAqL1xuICAgIHBhcnNlWklQNjRFeHRyYUZpZWxkOiBmdW5jdGlvbihyZWFkZXIpIHtcblxuICAgICAgICBpZiAoIXRoaXMuZXh0cmFGaWVsZHNbMHgwMDAxXSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2hvdWxkIGJlIHNvbWV0aGluZywgcHJlcGFyaW5nIHRoZSBleHRyYSByZWFkZXJcbiAgICAgICAgdmFyIGV4dHJhUmVhZGVyID0gbmV3IFN0cmluZ1JlYWRlcih0aGlzLmV4dHJhRmllbGRzWzB4MDAwMV0udmFsdWUpO1xuXG4gICAgICAgIC8vIEkgcmVhbGx5IGhvcGUgdGhhdCB0aGVzZSA2NGJpdHMgaW50ZWdlciBjYW4gZml0IGluIDMyIGJpdHMgaW50ZWdlciwgYmVjYXVzZSBqc1xuICAgICAgICAvLyB3b24ndCBsZXQgdXMgaGF2ZSBtb3JlLlxuICAgICAgICBpZiAodGhpcy51bmNvbXByZXNzZWRTaXplID09PSB1dGlscy5NQVhfVkFMVUVfMzJCSVRTKSB7XG4gICAgICAgICAgICB0aGlzLnVuY29tcHJlc3NlZFNpemUgPSBleHRyYVJlYWRlci5yZWFkSW50KDgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbXByZXNzZWRTaXplID09PSB1dGlscy5NQVhfVkFMVUVfMzJCSVRTKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXByZXNzZWRTaXplID0gZXh0cmFSZWFkZXIucmVhZEludCg4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5sb2NhbEhlYWRlck9mZnNldCA9PT0gdXRpbHMuTUFYX1ZBTFVFXzMyQklUUykge1xuICAgICAgICAgICAgdGhpcy5sb2NhbEhlYWRlck9mZnNldCA9IGV4dHJhUmVhZGVyLnJlYWRJbnQoOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGlza051bWJlclN0YXJ0ID09PSB1dGlscy5NQVhfVkFMVUVfMzJCSVRTKSB7XG4gICAgICAgICAgICB0aGlzLmRpc2tOdW1iZXJTdGFydCA9IGV4dHJhUmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIGNlbnRyYWwgcGFydCBvZiBhIHppcCBmaWxlIGFuZCBhZGQgdGhlIGluZm8gaW4gdGhpcyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtEYXRhUmVhZGVyfSByZWFkZXIgdGhlIHJlYWRlciB0byB1c2UuXG4gICAgICovXG4gICAgcmVhZEV4dHJhRmllbGRzOiBmdW5jdGlvbihyZWFkZXIpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gcmVhZGVyLmluZGV4LFxuICAgICAgICAgICAgZXh0cmFGaWVsZElkLFxuICAgICAgICAgICAgZXh0cmFGaWVsZExlbmd0aCxcbiAgICAgICAgICAgIGV4dHJhRmllbGRWYWx1ZTtcblxuICAgICAgICB0aGlzLmV4dHJhRmllbGRzID0gdGhpcy5leHRyYUZpZWxkcyB8fCB7fTtcblxuICAgICAgICB3aGlsZSAocmVhZGVyLmluZGV4IDwgc3RhcnQgKyB0aGlzLmV4dHJhRmllbGRzTGVuZ3RoKSB7XG4gICAgICAgICAgICBleHRyYUZpZWxkSWQgPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgICAgIGV4dHJhRmllbGRMZW5ndGggPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgICAgIGV4dHJhRmllbGRWYWx1ZSA9IHJlYWRlci5yZWFkU3RyaW5nKGV4dHJhRmllbGRMZW5ndGgpO1xuXG4gICAgICAgICAgICB0aGlzLmV4dHJhRmllbGRzW2V4dHJhRmllbGRJZF0gPSB7XG4gICAgICAgICAgICAgICAgaWQ6IGV4dHJhRmllbGRJZCxcbiAgICAgICAgICAgICAgICBsZW5ndGg6IGV4dHJhRmllbGRMZW5ndGgsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGV4dHJhRmllbGRWYWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQXBwbHkgYW4gVVRGOCB0cmFuc2Zvcm1hdGlvbiBpZiBuZWVkZWQuXG4gICAgICovXG4gICAgaGFuZGxlVVRGODogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkZWNvZGVQYXJhbVR5cGUgPSBzdXBwb3J0LnVpbnQ4YXJyYXkgPyBcInVpbnQ4YXJyYXlcIiA6IFwiYXJyYXlcIjtcbiAgICAgICAgaWYgKHRoaXMudXNlVVRGOCgpKSB7XG4gICAgICAgICAgICB0aGlzLmZpbGVOYW1lU3RyID0ganN6aXBQcm90by51dGY4ZGVjb2RlKHRoaXMuZmlsZU5hbWUpO1xuICAgICAgICAgICAgdGhpcy5maWxlQ29tbWVudFN0ciA9IGpzemlwUHJvdG8udXRmOGRlY29kZSh0aGlzLmZpbGVDb21tZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB1cGF0aCA9IHRoaXMuZmluZEV4dHJhRmllbGRVbmljb2RlUGF0aCgpO1xuICAgICAgICAgICAgaWYgKHVwYXRoICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maWxlTmFtZVN0ciA9IHVwYXRoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlsZU5hbWVCeXRlQXJyYXkgPSAgdXRpbHMudHJhbnNmb3JtVG8oZGVjb2RlUGFyYW1UeXBlLCB0aGlzLmZpbGVOYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbGVOYW1lU3RyID0gdGhpcy5sb2FkT3B0aW9ucy5kZWNvZGVGaWxlTmFtZShmaWxlTmFtZUJ5dGVBcnJheSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB1Y29tbWVudCA9IHRoaXMuZmluZEV4dHJhRmllbGRVbmljb2RlQ29tbWVudCgpO1xuICAgICAgICAgICAgaWYgKHVjb21tZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maWxlQ29tbWVudFN0ciA9IHVjb21tZW50O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgY29tbWVudEJ5dGVBcnJheSA9ICB1dGlscy50cmFuc2Zvcm1UbyhkZWNvZGVQYXJhbVR5cGUsIHRoaXMuZmlsZUNvbW1lbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsZUNvbW1lbnRTdHIgPSB0aGlzLmxvYWRPcHRpb25zLmRlY29kZUZpbGVOYW1lKGNvbW1lbnRCeXRlQXJyYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIHVuaWNvZGUgcGF0aCBkZWNsYXJlZCBpbiB0aGUgZXh0cmEgZmllbGQsIGlmIGFueS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSB1bmljb2RlIHBhdGgsIG51bGwgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGZpbmRFeHRyYUZpZWxkVW5pY29kZVBhdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdXBhdGhGaWVsZCA9IHRoaXMuZXh0cmFGaWVsZHNbMHg3MDc1XTtcbiAgICAgICAgaWYgKHVwYXRoRmllbGQpIHtcbiAgICAgICAgICAgIHZhciBleHRyYVJlYWRlciA9IG5ldyBTdHJpbmdSZWFkZXIodXBhdGhGaWVsZC52YWx1ZSk7XG5cbiAgICAgICAgICAgIC8vIHdyb25nIHZlcnNpb25cbiAgICAgICAgICAgIGlmIChleHRyYVJlYWRlci5yZWFkSW50KDEpICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHRoZSBjcmMgb2YgdGhlIGZpbGVuYW1lIGNoYW5nZWQsIHRoaXMgZmllbGQgaXMgb3V0IG9mIGRhdGUuXG4gICAgICAgICAgICBpZiAoanN6aXBQcm90by5jcmMzMih0aGlzLmZpbGVOYW1lKSAhPT0gZXh0cmFSZWFkZXIucmVhZEludCg0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ganN6aXBQcm90by51dGY4ZGVjb2RlKGV4dHJhUmVhZGVyLnJlYWRTdHJpbmcodXBhdGhGaWVsZC5sZW5ndGggLSA1KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIHVuaWNvZGUgY29tbWVudCBkZWNsYXJlZCBpbiB0aGUgZXh0cmEgZmllbGQsIGlmIGFueS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSB1bmljb2RlIGNvbW1lbnQsIG51bGwgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGZpbmRFeHRyYUZpZWxkVW5pY29kZUNvbW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdWNvbW1lbnRGaWVsZCA9IHRoaXMuZXh0cmFGaWVsZHNbMHg2Mzc1XTtcbiAgICAgICAgaWYgKHVjb21tZW50RmllbGQpIHtcbiAgICAgICAgICAgIHZhciBleHRyYVJlYWRlciA9IG5ldyBTdHJpbmdSZWFkZXIodWNvbW1lbnRGaWVsZC52YWx1ZSk7XG5cbiAgICAgICAgICAgIC8vIHdyb25nIHZlcnNpb25cbiAgICAgICAgICAgIGlmIChleHRyYVJlYWRlci5yZWFkSW50KDEpICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHRoZSBjcmMgb2YgdGhlIGNvbW1lbnQgY2hhbmdlZCwgdGhpcyBmaWVsZCBpcyBvdXQgb2YgZGF0ZS5cbiAgICAgICAgICAgIGlmIChqc3ppcFByb3RvLmNyYzMyKHRoaXMuZmlsZUNvbW1lbnQpICE9PSBleHRyYVJlYWRlci5yZWFkSW50KDQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBqc3ppcFByb3RvLnV0ZjhkZWNvZGUoZXh0cmFSZWFkZXIucmVhZFN0cmluZyh1Y29tbWVudEZpZWxkLmxlbmd0aCAtIDUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBaaXBFbnRyeTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9qc3ppcC9saWIvemlwRW50cnkuanNcbi8vIG1vZHVsZSBpZCA9IDEwNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9')},function(module,exports,__webpack_require__){"use strict";eval("// Top level file is just a mixin of submodules & constants\n\n\nvar assign    = __webpack_require__(3).assign;\n\nvar deflate   = __webpack_require__(107);\nvar inflate   = __webpack_require__(108);\nvar constants = __webpack_require__(51);\n\nvar pako = {};\n\nassign(pako, deflate, inflate, constants);\n\nmodule.exports = pako;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2pzemlwL34vcGFrby9pbmRleC5qcz82MjFkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBIiwiZmlsZSI6IjEwNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIFRvcCBsZXZlbCBmaWxlIGlzIGp1c3QgYSBtaXhpbiBvZiBzdWJtb2R1bGVzICYgY29uc3RhbnRzXG4ndXNlIHN0cmljdCc7XG5cbnZhciBhc3NpZ24gICAgPSByZXF1aXJlKCcuL2xpYi91dGlscy9jb21tb24nKS5hc3NpZ247XG5cbnZhciBkZWZsYXRlICAgPSByZXF1aXJlKCcuL2xpYi9kZWZsYXRlJyk7XG52YXIgaW5mbGF0ZSAgID0gcmVxdWlyZSgnLi9saWIvaW5mbGF0ZScpO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vbGliL3psaWIvY29uc3RhbnRzJyk7XG5cbnZhciBwYWtvID0ge307XG5cbmFzc2lnbihwYWtvLCBkZWZsYXRlLCBpbmZsYXRlLCBjb25zdGFudHMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBha287XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vanN6aXAvfi9wYWtvL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){"use strict";eval("\n\n\nvar zlib_deflate = __webpack_require__(109);\nvar utils        = __webpack_require__(3);\nvar strings      = __webpack_require__(49);\nvar msg          = __webpack_require__(29);\nvar ZStream      = __webpack_require__(53);\n\nvar toString = Object.prototype.toString;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\nvar Z_NO_FLUSH      = 0;\nvar Z_FINISH        = 4;\n\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\nvar Z_SYNC_FLUSH    = 2;\n\nvar Z_DEFAULT_COMPRESSION = -1;\n\nvar Z_DEFAULT_STRATEGY    = 0;\n\nvar Z_DEFLATED  = 8;\n\n/* ===========================================================================*/\n\n\n/**\n * class Deflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[deflate]],\n * [[deflateRaw]] and [[gzip]].\n **/\n\n/* internal\n * Deflate.chunks -> Array\n *\n * Chunks of output data, if [[Deflate#onData]] not overriden.\n **/\n\n/**\n * Deflate.result -> Uint8Array|Array\n *\n * Compressed result, generated by default [[Deflate#onData]]\n * and [[Deflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you\n * push a chunk with explicit flush (call [[Deflate#push]] with\n * `Z_SYNC_FLUSH` param).\n **/\n\n/**\n * Deflate.err -> Number\n *\n * Error code after deflate finished. 0 (Z_OK) on success.\n * You will not need it in real life, because deflate errors\n * are possible only on wrong options or bad `onData` / `onEnd`\n * custom handlers.\n **/\n\n/**\n * Deflate.msg -> String\n *\n * Error message, if [[Deflate.err]] != 0\n **/\n\n\n/**\n * new Deflate(options)\n * - options (Object): zlib deflate options.\n *\n * Creates new deflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `level`\n * - `windowBits`\n * - `memLevel`\n * - `strategy`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw deflate\n * - `gzip` (Boolean) - create gzip wrapper\n * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n *    (each char code [0..255])\n * - `header` (Object) - custom header for gzip\n *   - `text` (Boolean) - true if compressed data believed to be text\n *   - `time` (Number) - modification time, unix timestamp\n *   - `os` (Number) - operation system code\n *   - `extra` (Array) - array of bytes with extra data (max 65536)\n *   - `name` (String) - file name (binary string)\n *   - `comment` (String) - comment (binary string)\n *   - `hcrc` (Boolean) - true if header crc should be added\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * var deflate = new pako.Deflate({ level: 3});\n *\n * deflate.push(chunk1, false);\n * deflate.push(chunk2, true);  // true -> last chunk\n *\n * if (deflate.err) { throw new Error(deflate.err); }\n *\n * console.log(deflate.result);\n * ```\n **/\nfunction Deflate(options) {\n  if (!(this instanceof Deflate)) return new Deflate(options);\n\n  this.options = utils.assign({\n    level: Z_DEFAULT_COMPRESSION,\n    method: Z_DEFLATED,\n    chunkSize: 16384,\n    windowBits: 15,\n    memLevel: 8,\n    strategy: Z_DEFAULT_STRATEGY,\n    to: ''\n  }, options || {});\n\n  var opt = this.options;\n\n  if (opt.raw && (opt.windowBits > 0)) {\n    opt.windowBits = -opt.windowBits;\n  }\n\n  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {\n    opt.windowBits += 16;\n  }\n\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\n  this.msg    = '';     // error message\n  this.ended  = false;  // used to avoid multiple onEnd() calls\n  this.chunks = [];     // chunks of compressed data\n\n  this.strm = new ZStream();\n  this.strm.avail_out = 0;\n\n  var status = zlib_deflate.deflateInit2(\n    this.strm,\n    opt.level,\n    opt.method,\n    opt.windowBits,\n    opt.memLevel,\n    opt.strategy\n  );\n\n  if (status !== Z_OK) {\n    throw new Error(msg[status]);\n  }\n\n  if (opt.header) {\n    zlib_deflate.deflateSetHeader(this.strm, opt.header);\n  }\n\n  if (opt.dictionary) {\n    var dict;\n    // Convert data if needed\n    if (typeof opt.dictionary === 'string') {\n      // If we need to compress text, change encoding to utf8.\n      dict = strings.string2buf(opt.dictionary);\n    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n      dict = new Uint8Array(opt.dictionary);\n    } else {\n      dict = opt.dictionary;\n    }\n\n    status = zlib_deflate.deflateSetDictionary(this.strm, dict);\n\n    if (status !== Z_OK) {\n      throw new Error(msg[status]);\n    }\n\n    this._dict_set = true;\n  }\n}\n\n/**\n * Deflate#push(data[, mode]) -> Boolean\n * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be\n *   converted to utf8 byte sequence.\n * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` meansh Z_FINISH.\n *\n * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with\n * new compressed chunks. Returns `true` on success. The last data block must have\n * mode Z_FINISH (or `true`). That will flush internal pending buffers and call\n * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you\n * can use mode Z_SYNC_FLUSH, keeping the compression context.\n *\n * On fail call [[Deflate#onEnd]] with error code and return false.\n *\n * We strongly recommend to use `Uint8Array` on input for best speed (output\n * array format is detected automatically). Also, don't skip last param and always\n * use the same type in your code (boolean or number). That will improve JS speed.\n *\n * For regular `Array`-s make sure all elements are [0..255].\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\nDeflate.prototype.push = function (data, mode) {\n  var strm = this.strm;\n  var chunkSize = this.options.chunkSize;\n  var status, _mode;\n\n  if (this.ended) { return false; }\n\n  _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH : Z_NO_FLUSH);\n\n  // Convert data if needed\n  if (typeof data === 'string') {\n    // If we need to compress text, change encoding to utf8.\n    strm.input = strings.string2buf(data);\n  } else if (toString.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  do {\n    if (strm.avail_out === 0) {\n      strm.output = new utils.Buf8(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n    status = zlib_deflate.deflate(strm, _mode);    /* no bad return value */\n\n    if (status !== Z_STREAM_END && status !== Z_OK) {\n      this.onEnd(status);\n      this.ended = true;\n      return false;\n    }\n    if (strm.avail_out === 0 || (strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {\n      if (this.options.to === 'string') {\n        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));\n      } else {\n        this.onData(utils.shrinkBuf(strm.output, strm.next_out));\n      }\n    }\n  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);\n\n  // Finalize on the last chunk.\n  if (_mode === Z_FINISH) {\n    status = zlib_deflate.deflateEnd(this.strm);\n    this.onEnd(status);\n    this.ended = true;\n    return status === Z_OK;\n  }\n\n  // callback interim results if Z_SYNC_FLUSH.\n  if (_mode === Z_SYNC_FLUSH) {\n    this.onEnd(Z_OK);\n    strm.avail_out = 0;\n    return true;\n  }\n\n  return true;\n};\n\n\n/**\n * Deflate#onData(chunk) -> Void\n * - chunk (Uint8Array|Array|String): ouput data. Type of array depends\n *   on js engine support. When string output requested, each chunk\n *   will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\nDeflate.prototype.onData = function (chunk) {\n  this.chunks.push(chunk);\n};\n\n\n/**\n * Deflate#onEnd(status) -> Void\n * - status (Number): deflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called once after you tell deflate that the input stream is\n * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)\n * or if an error happened. By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\nDeflate.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === Z_OK) {\n    if (this.options.to === 'string') {\n      this.result = this.chunks.join('');\n    } else {\n      this.result = utils.flattenChunks(this.chunks);\n    }\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n\n\n/**\n * deflate(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * Compress `data` with deflate algorithm and `options`.\n *\n * Supported options are:\n *\n * - level\n * - windowBits\n * - memLevel\n * - strategy\n * - dictionary\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n *    (each char code [0..255])\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);\n *\n * console.log(pako.deflate(data));\n * ```\n **/\nfunction deflate(input, options) {\n  var deflator = new Deflate(options);\n\n  deflator.push(input, true);\n\n  // That will never happens, if you don't cheat with options :)\n  if (deflator.err) { throw deflator.msg || msg[deflator.err]; }\n\n  return deflator.result;\n}\n\n\n/**\n * deflateRaw(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nfunction deflateRaw(input, options) {\n  options = options || {};\n  options.raw = true;\n  return deflate(input, options);\n}\n\n\n/**\n * gzip(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but create gzip wrapper instead of\n * deflate one.\n **/\nfunction gzip(input, options) {\n  options = options || {};\n  options.gzip = true;\n  return deflate(input, options);\n}\n\n\nexports.Deflate = Deflate;\nexports.deflate = deflate;\nexports.deflateRaw = deflateRaw;\nexports.gzip = gzip;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2pzemlwL34vcGFrby9saWIvZGVmbGF0ZS5qcz9jYzAyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFVBQVU7QUFDN0M7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLHFCQUFxQiw4QkFBOEI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLGVBQWU7O0FBRWxCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCLG1CQUFtQjtBQUNuQixzQkFBc0I7QUFDdEIsbUJBQW1COztBQUVuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGNBQWM7O0FBRWpDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHFCQUFxQix5Q0FBeUM7O0FBRTlEO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTA3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB6bGliX2RlZmxhdGUgPSByZXF1aXJlKCcuL3psaWIvZGVmbGF0ZScpO1xudmFyIHV0aWxzICAgICAgICA9IHJlcXVpcmUoJy4vdXRpbHMvY29tbW9uJyk7XG52YXIgc3RyaW5ncyAgICAgID0gcmVxdWlyZSgnLi91dGlscy9zdHJpbmdzJyk7XG52YXIgbXNnICAgICAgICAgID0gcmVxdWlyZSgnLi96bGliL21lc3NhZ2VzJyk7XG52YXIgWlN0cmVhbSAgICAgID0gcmVxdWlyZSgnLi96bGliL3pzdHJlYW0nKTtcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbnZhciBaX05PX0ZMVVNIICAgICAgPSAwO1xudmFyIFpfRklOSVNIICAgICAgICA9IDQ7XG5cbnZhciBaX09LICAgICAgICAgICAgPSAwO1xudmFyIFpfU1RSRUFNX0VORCAgICA9IDE7XG52YXIgWl9TWU5DX0ZMVVNIICAgID0gMjtcblxudmFyIFpfREVGQVVMVF9DT01QUkVTU0lPTiA9IC0xO1xuXG52YXIgWl9ERUZBVUxUX1NUUkFURUdZICAgID0gMDtcblxudmFyIFpfREVGTEFURUQgID0gODtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vKipcbiAqIGNsYXNzIERlZmxhdGVcbiAqXG4gKiBHZW5lcmljIEpTLXN0eWxlIHdyYXBwZXIgZm9yIHpsaWIgY2FsbHMuIElmIHlvdSBkb24ndCBuZWVkXG4gKiBzdHJlYW1pbmcgYmVoYXZpb3VyIC0gdXNlIG1vcmUgc2ltcGxlIGZ1bmN0aW9uczogW1tkZWZsYXRlXV0sXG4gKiBbW2RlZmxhdGVSYXddXSBhbmQgW1tnemlwXV0uXG4gKiovXG5cbi8qIGludGVybmFsXG4gKiBEZWZsYXRlLmNodW5rcyAtPiBBcnJheVxuICpcbiAqIENodW5rcyBvZiBvdXRwdXQgZGF0YSwgaWYgW1tEZWZsYXRlI29uRGF0YV1dIG5vdCBvdmVycmlkZW4uXG4gKiovXG5cbi8qKlxuICogRGVmbGF0ZS5yZXN1bHQgLT4gVWludDhBcnJheXxBcnJheVxuICpcbiAqIENvbXByZXNzZWQgcmVzdWx0LCBnZW5lcmF0ZWQgYnkgZGVmYXVsdCBbW0RlZmxhdGUjb25EYXRhXV1cbiAqIGFuZCBbW0RlZmxhdGUjb25FbmRdXSBoYW5kbGVycy4gRmlsbGVkIGFmdGVyIHlvdSBwdXNoIGxhc3QgY2h1bmtcbiAqIChjYWxsIFtbRGVmbGF0ZSNwdXNoXV0gd2l0aCBgWl9GSU5JU0hgIC8gYHRydWVgIHBhcmFtKSAgb3IgaWYgeW91XG4gKiBwdXNoIGEgY2h1bmsgd2l0aCBleHBsaWNpdCBmbHVzaCAoY2FsbCBbW0RlZmxhdGUjcHVzaF1dIHdpdGhcbiAqIGBaX1NZTkNfRkxVU0hgIHBhcmFtKS5cbiAqKi9cblxuLyoqXG4gKiBEZWZsYXRlLmVyciAtPiBOdW1iZXJcbiAqXG4gKiBFcnJvciBjb2RlIGFmdGVyIGRlZmxhdGUgZmluaXNoZWQuIDAgKFpfT0spIG9uIHN1Y2Nlc3MuXG4gKiBZb3Ugd2lsbCBub3QgbmVlZCBpdCBpbiByZWFsIGxpZmUsIGJlY2F1c2UgZGVmbGF0ZSBlcnJvcnNcbiAqIGFyZSBwb3NzaWJsZSBvbmx5IG9uIHdyb25nIG9wdGlvbnMgb3IgYmFkIGBvbkRhdGFgIC8gYG9uRW5kYFxuICogY3VzdG9tIGhhbmRsZXJzLlxuICoqL1xuXG4vKipcbiAqIERlZmxhdGUubXNnIC0+IFN0cmluZ1xuICpcbiAqIEVycm9yIG1lc3NhZ2UsIGlmIFtbRGVmbGF0ZS5lcnJdXSAhPSAwXG4gKiovXG5cblxuLyoqXG4gKiBuZXcgRGVmbGF0ZShvcHRpb25zKVxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGRlZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBDcmVhdGVzIG5ldyBkZWZsYXRvciBpbnN0YW5jZSB3aXRoIHNwZWNpZmllZCBwYXJhbXMuIFRocm93cyBleGNlcHRpb25cbiAqIG9uIGJhZCBwYXJhbXMuIFN1cHBvcnRlZCBvcHRpb25zOlxuICpcbiAqIC0gYGxldmVsYFxuICogLSBgd2luZG93Qml0c2BcbiAqIC0gYG1lbUxldmVsYFxuICogLSBgc3RyYXRlZ3lgXG4gKiAtIGBkaWN0aW9uYXJ5YFxuICpcbiAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZClcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZXNlLlxuICpcbiAqIEFkZGl0aW9uYWwgb3B0aW9ucywgZm9yIGludGVybmFsIG5lZWRzOlxuICpcbiAqIC0gYGNodW5rU2l6ZWAgLSBzaXplIG9mIGdlbmVyYXRlZCBkYXRhIGNodW5rcyAoMTZLIGJ5IGRlZmF1bHQpXG4gKiAtIGByYXdgIChCb29sZWFuKSAtIGRvIHJhdyBkZWZsYXRlXG4gKiAtIGBnemlwYCAoQm9vbGVhbikgLSBjcmVhdGUgZ3ppcCB3cmFwcGVyXG4gKiAtIGB0b2AgKFN0cmluZykgLSBpZiBlcXVhbCB0byAnc3RyaW5nJywgdGhlbiByZXN1bHQgd2lsbCBiZSBcImJpbmFyeSBzdHJpbmdcIlxuICogICAgKGVhY2ggY2hhciBjb2RlIFswLi4yNTVdKVxuICogLSBgaGVhZGVyYCAoT2JqZWN0KSAtIGN1c3RvbSBoZWFkZXIgZm9yIGd6aXBcbiAqICAgLSBgdGV4dGAgKEJvb2xlYW4pIC0gdHJ1ZSBpZiBjb21wcmVzc2VkIGRhdGEgYmVsaWV2ZWQgdG8gYmUgdGV4dFxuICogICAtIGB0aW1lYCAoTnVtYmVyKSAtIG1vZGlmaWNhdGlvbiB0aW1lLCB1bml4IHRpbWVzdGFtcFxuICogICAtIGBvc2AgKE51bWJlcikgLSBvcGVyYXRpb24gc3lzdGVtIGNvZGVcbiAqICAgLSBgZXh0cmFgIChBcnJheSkgLSBhcnJheSBvZiBieXRlcyB3aXRoIGV4dHJhIGRhdGEgKG1heCA2NTUzNilcbiAqICAgLSBgbmFtZWAgKFN0cmluZykgLSBmaWxlIG5hbWUgKGJpbmFyeSBzdHJpbmcpXG4gKiAgIC0gYGNvbW1lbnRgIChTdHJpbmcpIC0gY29tbWVudCAoYmluYXJ5IHN0cmluZylcbiAqICAgLSBgaGNyY2AgKEJvb2xlYW4pIC0gdHJ1ZSBpZiBoZWFkZXIgY3JjIHNob3VsZCBiZSBhZGRlZFxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIHBha28gPSByZXF1aXJlKCdwYWtvJylcbiAqICAgLCBjaHVuazEgPSBVaW50OEFycmF5KFsxLDIsMyw0LDUsNiw3LDgsOV0pXG4gKiAgICwgY2h1bmsyID0gVWludDhBcnJheShbMTAsMTEsMTIsMTMsMTQsMTUsMTYsMTcsMTgsMTldKTtcbiAqXG4gKiB2YXIgZGVmbGF0ZSA9IG5ldyBwYWtvLkRlZmxhdGUoeyBsZXZlbDogM30pO1xuICpcbiAqIGRlZmxhdGUucHVzaChjaHVuazEsIGZhbHNlKTtcbiAqIGRlZmxhdGUucHVzaChjaHVuazIsIHRydWUpOyAgLy8gdHJ1ZSAtPiBsYXN0IGNodW5rXG4gKlxuICogaWYgKGRlZmxhdGUuZXJyKSB7IHRocm93IG5ldyBFcnJvcihkZWZsYXRlLmVycik7IH1cbiAqXG4gKiBjb25zb2xlLmxvZyhkZWZsYXRlLnJlc3VsdCk7XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIERlZmxhdGUob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRGVmbGF0ZSkpIHJldHVybiBuZXcgRGVmbGF0ZShvcHRpb25zKTtcblxuICB0aGlzLm9wdGlvbnMgPSB1dGlscy5hc3NpZ24oe1xuICAgIGxldmVsOiBaX0RFRkFVTFRfQ09NUFJFU1NJT04sXG4gICAgbWV0aG9kOiBaX0RFRkxBVEVELFxuICAgIGNodW5rU2l6ZTogMTYzODQsXG4gICAgd2luZG93Qml0czogMTUsXG4gICAgbWVtTGV2ZWw6IDgsXG4gICAgc3RyYXRlZ3k6IFpfREVGQVVMVF9TVFJBVEVHWSxcbiAgICB0bzogJydcbiAgfSwgb3B0aW9ucyB8fCB7fSk7XG5cbiAgdmFyIG9wdCA9IHRoaXMub3B0aW9ucztcblxuICBpZiAob3B0LnJhdyAmJiAob3B0LndpbmRvd0JpdHMgPiAwKSkge1xuICAgIG9wdC53aW5kb3dCaXRzID0gLW9wdC53aW5kb3dCaXRzO1xuICB9XG5cbiAgZWxzZSBpZiAob3B0Lmd6aXAgJiYgKG9wdC53aW5kb3dCaXRzID4gMCkgJiYgKG9wdC53aW5kb3dCaXRzIDwgMTYpKSB7XG4gICAgb3B0LndpbmRvd0JpdHMgKz0gMTY7XG4gIH1cblxuICB0aGlzLmVyciAgICA9IDA7ICAgICAgLy8gZXJyb3IgY29kZSwgaWYgaGFwcGVucyAoMCA9IFpfT0spXG4gIHRoaXMubXNnICAgID0gJyc7ICAgICAvLyBlcnJvciBtZXNzYWdlXG4gIHRoaXMuZW5kZWQgID0gZmFsc2U7ICAvLyB1c2VkIHRvIGF2b2lkIG11bHRpcGxlIG9uRW5kKCkgY2FsbHNcbiAgdGhpcy5jaHVua3MgPSBbXTsgICAgIC8vIGNodW5rcyBvZiBjb21wcmVzc2VkIGRhdGFcblxuICB0aGlzLnN0cm0gPSBuZXcgWlN0cmVhbSgpO1xuICB0aGlzLnN0cm0uYXZhaWxfb3V0ID0gMDtcblxuICB2YXIgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGVJbml0MihcbiAgICB0aGlzLnN0cm0sXG4gICAgb3B0LmxldmVsLFxuICAgIG9wdC5tZXRob2QsXG4gICAgb3B0LndpbmRvd0JpdHMsXG4gICAgb3B0Lm1lbUxldmVsLFxuICAgIG9wdC5zdHJhdGVneVxuICApO1xuXG4gIGlmIChzdGF0dXMgIT09IFpfT0spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnW3N0YXR1c10pO1xuICB9XG5cbiAgaWYgKG9wdC5oZWFkZXIpIHtcbiAgICB6bGliX2RlZmxhdGUuZGVmbGF0ZVNldEhlYWRlcih0aGlzLnN0cm0sIG9wdC5oZWFkZXIpO1xuICB9XG5cbiAgaWYgKG9wdC5kaWN0aW9uYXJ5KSB7XG4gICAgdmFyIGRpY3Q7XG4gICAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICAgIGlmICh0eXBlb2Ygb3B0LmRpY3Rpb25hcnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBJZiB3ZSBuZWVkIHRvIGNvbXByZXNzIHRleHQsIGNoYW5nZSBlbmNvZGluZyB0byB1dGY4LlxuICAgICAgZGljdCA9IHN0cmluZ3Muc3RyaW5nMmJ1ZihvcHQuZGljdGlvbmFyeSk7XG4gICAgfSBlbHNlIGlmICh0b1N0cmluZy5jYWxsKG9wdC5kaWN0aW9uYXJ5KSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgICAgZGljdCA9IG5ldyBVaW50OEFycmF5KG9wdC5kaWN0aW9uYXJ5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGljdCA9IG9wdC5kaWN0aW9uYXJ5O1xuICAgIH1cblxuICAgIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sIGRpY3QpO1xuXG4gICAgaWYgKHN0YXR1cyAhPT0gWl9PSykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZ1tzdGF0dXNdKTtcbiAgICB9XG5cbiAgICB0aGlzLl9kaWN0X3NldCA9IHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBEZWZsYXRlI3B1c2goZGF0YVssIG1vZGVdKSAtPiBCb29sZWFuXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8QXJyYXlCdWZmZXJ8U3RyaW5nKTogaW5wdXQgZGF0YS4gU3RyaW5ncyB3aWxsIGJlXG4gKiAgIGNvbnZlcnRlZCB0byB1dGY4IGJ5dGUgc2VxdWVuY2UuXG4gKiAtIG1vZGUgKE51bWJlcnxCb29sZWFuKTogMC4uNiBmb3IgY29ycmVzcG9uZGluZyBaX05PX0ZMVVNILi5aX1RSRUUgbW9kZXMuXG4gKiAgIFNlZSBjb25zdGFudHMuIFNraXBwZWQgb3IgYGZhbHNlYCBtZWFucyBaX05PX0ZMVVNILCBgdHJ1ZWAgbWVhbnNoIFpfRklOSVNILlxuICpcbiAqIFNlbmRzIGlucHV0IGRhdGEgdG8gZGVmbGF0ZSBwaXBlLCBnZW5lcmF0aW5nIFtbRGVmbGF0ZSNvbkRhdGFdXSBjYWxscyB3aXRoXG4gKiBuZXcgY29tcHJlc3NlZCBjaHVua3MuIFJldHVybnMgYHRydWVgIG9uIHN1Y2Nlc3MuIFRoZSBsYXN0IGRhdGEgYmxvY2sgbXVzdCBoYXZlXG4gKiBtb2RlIFpfRklOSVNIIChvciBgdHJ1ZWApLiBUaGF0IHdpbGwgZmx1c2ggaW50ZXJuYWwgcGVuZGluZyBidWZmZXJzIGFuZCBjYWxsXG4gKiBbW0RlZmxhdGUjb25FbmRdXS4gRm9yIGludGVyaW0gZXhwbGljaXQgZmx1c2hlcyAod2l0aG91dCBlbmRpbmcgdGhlIHN0cmVhbSkgeW91XG4gKiBjYW4gdXNlIG1vZGUgWl9TWU5DX0ZMVVNILCBrZWVwaW5nIHRoZSBjb21wcmVzc2lvbiBjb250ZXh0LlxuICpcbiAqIE9uIGZhaWwgY2FsbCBbW0RlZmxhdGUjb25FbmRdXSB3aXRoIGVycm9yIGNvZGUgYW5kIHJldHVybiBmYWxzZS5cbiAqXG4gKiBXZSBzdHJvbmdseSByZWNvbW1lbmQgdG8gdXNlIGBVaW50OEFycmF5YCBvbiBpbnB1dCBmb3IgYmVzdCBzcGVlZCAob3V0cHV0XG4gKiBhcnJheSBmb3JtYXQgaXMgZGV0ZWN0ZWQgYXV0b21hdGljYWxseSkuIEFsc28sIGRvbid0IHNraXAgbGFzdCBwYXJhbSBhbmQgYWx3YXlzXG4gKiB1c2UgdGhlIHNhbWUgdHlwZSBpbiB5b3VyIGNvZGUgKGJvb2xlYW4gb3IgbnVtYmVyKS4gVGhhdCB3aWxsIGltcHJvdmUgSlMgc3BlZWQuXG4gKlxuICogRm9yIHJlZ3VsYXIgYEFycmF5YC1zIG1ha2Ugc3VyZSBhbGwgZWxlbWVudHMgYXJlIFswLi4yNTVdLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBwdXNoKGNodW5rLCBmYWxzZSk7IC8vIHB1c2ggb25lIG9mIGRhdGEgY2h1bmtzXG4gKiAuLi5cbiAqIHB1c2goY2h1bmssIHRydWUpOyAgLy8gcHVzaCBsYXN0IGNodW5rXG4gKiBgYGBcbiAqKi9cbkRlZmxhdGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZGF0YSwgbW9kZSkge1xuICB2YXIgc3RybSA9IHRoaXMuc3RybTtcbiAgdmFyIGNodW5rU2l6ZSA9IHRoaXMub3B0aW9ucy5jaHVua1NpemU7XG4gIHZhciBzdGF0dXMsIF9tb2RlO1xuXG4gIGlmICh0aGlzLmVuZGVkKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIF9tb2RlID0gKG1vZGUgPT09IH5+bW9kZSkgPyBtb2RlIDogKChtb2RlID09PSB0cnVlKSA/IFpfRklOSVNIIDogWl9OT19GTFVTSCk7XG5cbiAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gSWYgd2UgbmVlZCB0byBjb21wcmVzcyB0ZXh0LCBjaGFuZ2UgZW5jb2RpbmcgdG8gdXRmOC5cbiAgICBzdHJtLmlucHV0ID0gc3RyaW5ncy5zdHJpbmcyYnVmKGRhdGEpO1xuICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwoZGF0YSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICBzdHJtLmlucHV0ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgc3RybS5pbnB1dCA9IGRhdGE7XG4gIH1cblxuICBzdHJtLm5leHRfaW4gPSAwO1xuICBzdHJtLmF2YWlsX2luID0gc3RybS5pbnB1dC5sZW5ndGg7XG5cbiAgZG8ge1xuICAgIGlmIChzdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgc3RybS5vdXRwdXQgPSBuZXcgdXRpbHMuQnVmOChjaHVua1NpemUpO1xuICAgICAgc3RybS5uZXh0X291dCA9IDA7XG4gICAgICBzdHJtLmF2YWlsX291dCA9IGNodW5rU2l6ZTtcbiAgICB9XG4gICAgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGUoc3RybSwgX21vZGUpOyAgICAvKiBubyBiYWQgcmV0dXJuIHZhbHVlICovXG5cbiAgICBpZiAoc3RhdHVzICE9PSBaX1NUUkVBTV9FTkQgJiYgc3RhdHVzICE9PSBaX09LKSB7XG4gICAgICB0aGlzLm9uRW5kKHN0YXR1cyk7XG4gICAgICB0aGlzLmVuZGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwIHx8IChzdHJtLmF2YWlsX2luID09PSAwICYmIChfbW9kZSA9PT0gWl9GSU5JU0ggfHwgX21vZGUgPT09IFpfU1lOQ19GTFVTSCkpKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLm9uRGF0YShzdHJpbmdzLmJ1ZjJiaW5zdHJpbmcodXRpbHMuc2hyaW5rQnVmKHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0KSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vbkRhdGEodXRpbHMuc2hyaW5rQnVmKHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0KSk7XG4gICAgICB9XG4gICAgfVxuICB9IHdoaWxlICgoc3RybS5hdmFpbF9pbiA+IDAgfHwgc3RybS5hdmFpbF9vdXQgPT09IDApICYmIHN0YXR1cyAhPT0gWl9TVFJFQU1fRU5EKTtcblxuICAvLyBGaW5hbGl6ZSBvbiB0aGUgbGFzdCBjaHVuay5cbiAgaWYgKF9tb2RlID09PSBaX0ZJTklTSCkge1xuICAgIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlRW5kKHRoaXMuc3RybSk7XG4gICAgdGhpcy5vbkVuZChzdGF0dXMpO1xuICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgIHJldHVybiBzdGF0dXMgPT09IFpfT0s7XG4gIH1cblxuICAvLyBjYWxsYmFjayBpbnRlcmltIHJlc3VsdHMgaWYgWl9TWU5DX0ZMVVNILlxuICBpZiAoX21vZGUgPT09IFpfU1lOQ19GTFVTSCkge1xuICAgIHRoaXMub25FbmQoWl9PSyk7XG4gICAgc3RybS5hdmFpbF9vdXQgPSAwO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cbi8qKlxuICogRGVmbGF0ZSNvbkRhdGEoY2h1bmspIC0+IFZvaWRcbiAqIC0gY2h1bmsgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogb3VwdXQgZGF0YS4gVHlwZSBvZiBhcnJheSBkZXBlbmRzXG4gKiAgIG9uIGpzIGVuZ2luZSBzdXBwb3J0LiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLCBlYWNoIGNodW5rXG4gKiAgIHdpbGwgYmUgc3RyaW5nLlxuICpcbiAqIEJ5IGRlZmF1bHQsIHN0b3JlcyBkYXRhIGJsb2NrcyBpbiBgY2h1bmtzW11gIHByb3BlcnR5IGFuZCBnbHVlXG4gKiB0aG9zZSBpbiBgb25FbmRgLiBPdmVycmlkZSB0aGlzIGhhbmRsZXIsIGlmIHlvdSBuZWVkIGFub3RoZXIgYmVoYXZpb3VyLlxuICoqL1xuRGVmbGF0ZS5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHRoaXMuY2h1bmtzLnB1c2goY2h1bmspO1xufTtcblxuXG4vKipcbiAqIERlZmxhdGUjb25FbmQoc3RhdHVzKSAtPiBWb2lkXG4gKiAtIHN0YXR1cyAoTnVtYmVyKTogZGVmbGF0ZSBzdGF0dXMuIDAgKFpfT0spIG9uIHN1Y2Nlc3MsXG4gKiAgIG90aGVyIGlmIG5vdC5cbiAqXG4gKiBDYWxsZWQgb25jZSBhZnRlciB5b3UgdGVsbCBkZWZsYXRlIHRoYXQgdGhlIGlucHV0IHN0cmVhbSBpc1xuICogY29tcGxldGUgKFpfRklOSVNIKSBvciBzaG91bGQgYmUgZmx1c2hlZCAoWl9TWU5DX0ZMVVNIKVxuICogb3IgaWYgYW4gZXJyb3IgaGFwcGVuZWQuIEJ5IGRlZmF1bHQgLSBqb2luIGNvbGxlY3RlZCBjaHVua3MsXG4gKiBmcmVlIG1lbW9yeSBhbmQgZmlsbCBgcmVzdWx0c2AgLyBgZXJyYCBwcm9wZXJ0aWVzLlxuICoqL1xuRGVmbGF0ZS5wcm90b3R5cGUub25FbmQgPSBmdW5jdGlvbiAoc3RhdHVzKSB7XG4gIC8vIE9uIHN1Y2Nlc3MgLSBqb2luXG4gIGlmIChzdGF0dXMgPT09IFpfT0spIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5yZXN1bHQgPSB0aGlzLmNodW5rcy5qb2luKCcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZXN1bHQgPSB1dGlscy5mbGF0dGVuQ2h1bmtzKHRoaXMuY2h1bmtzKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5jaHVua3MgPSBbXTtcbiAgdGhpcy5lcnIgPSBzdGF0dXM7XG4gIHRoaXMubXNnID0gdGhpcy5zdHJtLm1zZztcbn07XG5cblxuLyoqXG4gKiBkZWZsYXRlKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGRlZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBDb21wcmVzcyBgZGF0YWAgd2l0aCBkZWZsYXRlIGFsZ29yaXRobSBhbmQgYG9wdGlvbnNgLlxuICpcbiAqIFN1cHBvcnRlZCBvcHRpb25zIGFyZTpcbiAqXG4gKiAtIGxldmVsXG4gKiAtIHdpbmRvd0JpdHNcbiAqIC0gbWVtTGV2ZWxcbiAqIC0gc3RyYXRlZ3lcbiAqIC0gZGljdGlvbmFyeVxuICpcbiAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZClcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZXNlLlxuICpcbiAqIFN1Z2FyIChvcHRpb25zKTpcbiAqXG4gKiAtIGByYXdgIChCb29sZWFuKSAtIHNheSB0aGF0IHdlIHdvcmsgd2l0aCByYXcgc3RyZWFtLCBpZiB5b3UgZG9uJ3Qgd2lzaCB0byBzcGVjaWZ5XG4gKiAgIG5lZ2F0aXZlIHdpbmRvd0JpdHMgaW1wbGljaXRseS5cbiAqIC0gYHRvYCAoU3RyaW5nKSAtIGlmIGVxdWFsIHRvICdzdHJpbmcnLCB0aGVuIHJlc3VsdCB3aWxsIGJlIFwiYmluYXJ5IHN0cmluZ1wiXG4gKiAgICAoZWFjaCBjaGFyIGNvZGUgWzAuLjI1NV0pXG4gKlxuICogIyMjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKVxuICogICAsIGRhdGEgPSBVaW50OEFycmF5KFsxLDIsMyw0LDUsNiw3LDgsOV0pO1xuICpcbiAqIGNvbnNvbGUubG9nKHBha28uZGVmbGF0ZShkYXRhKSk7XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIGRlZmxhdGUoaW5wdXQsIG9wdGlvbnMpIHtcbiAgdmFyIGRlZmxhdG9yID0gbmV3IERlZmxhdGUob3B0aW9ucyk7XG5cbiAgZGVmbGF0b3IucHVzaChpbnB1dCwgdHJ1ZSk7XG5cbiAgLy8gVGhhdCB3aWxsIG5ldmVyIGhhcHBlbnMsIGlmIHlvdSBkb24ndCBjaGVhdCB3aXRoIG9wdGlvbnMgOilcbiAgaWYgKGRlZmxhdG9yLmVycikgeyB0aHJvdyBkZWZsYXRvci5tc2cgfHwgbXNnW2RlZmxhdG9yLmVycl07IH1cblxuICByZXR1cm4gZGVmbGF0b3IucmVzdWx0O1xufVxuXG5cbi8qKlxuICogZGVmbGF0ZVJhdyhkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogVGhlIHNhbWUgYXMgW1tkZWZsYXRlXV0sIGJ1dCBjcmVhdGVzIHJhdyBkYXRhLCB3aXRob3V0IHdyYXBwZXJcbiAqIChoZWFkZXIgYW5kIGFkbGVyMzIgY3JjKS5cbiAqKi9cbmZ1bmN0aW9uIGRlZmxhdGVSYXcoaW5wdXQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMucmF3ID0gdHJ1ZTtcbiAgcmV0dXJuIGRlZmxhdGUoaW5wdXQsIG9wdGlvbnMpO1xufVxuXG5cbi8qKlxuICogZ3ppcChkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogVGhlIHNhbWUgYXMgW1tkZWZsYXRlXV0sIGJ1dCBjcmVhdGUgZ3ppcCB3cmFwcGVyIGluc3RlYWQgb2ZcbiAqIGRlZmxhdGUgb25lLlxuICoqL1xuZnVuY3Rpb24gZ3ppcChpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5nemlwID0gdHJ1ZTtcbiAgcmV0dXJuIGRlZmxhdGUoaW5wdXQsIG9wdGlvbnMpO1xufVxuXG5cbmV4cG9ydHMuRGVmbGF0ZSA9IERlZmxhdGU7XG5leHBvcnRzLmRlZmxhdGUgPSBkZWZsYXRlO1xuZXhwb3J0cy5kZWZsYXRlUmF3ID0gZGVmbGF0ZVJhdztcbmV4cG9ydHMuZ3ppcCA9IGd6aXA7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vanN6aXAvfi9wYWtvL2xpYi9kZWZsYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){"use strict";eval("\n\n\nvar zlib_inflate = __webpack_require__(112);\nvar utils        = __webpack_require__(3);\nvar strings      = __webpack_require__(49);\nvar c            = __webpack_require__(51);\nvar msg          = __webpack_require__(29);\nvar ZStream      = __webpack_require__(53);\nvar GZheader     = __webpack_require__(110);\n\nvar toString = Object.prototype.toString;\n\n/**\n * class Inflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[inflate]]\n * and [[inflateRaw]].\n **/\n\n/* internal\n * inflate.chunks -> Array\n *\n * Chunks of output data, if [[Inflate#onData]] not overriden.\n **/\n\n/**\n * Inflate.result -> Uint8Array|Array|String\n *\n * Uncompressed result, generated by default [[Inflate#onData]]\n * and [[Inflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you\n * push a chunk with explicit flush (call [[Inflate#push]] with\n * `Z_SYNC_FLUSH` param).\n **/\n\n/**\n * Inflate.err -> Number\n *\n * Error code after inflate finished. 0 (Z_OK) on success.\n * Should be checked if broken data possible.\n **/\n\n/**\n * Inflate.msg -> String\n *\n * Error message, if [[Inflate.err]] != 0\n **/\n\n\n/**\n * new Inflate(options)\n * - options (Object): zlib inflate options.\n *\n * Creates new inflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `windowBits`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw inflate\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n * By default, when no options set, autodetect deflate/gzip data format via\n * wrapper header.\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * var inflate = new pako.Inflate({ level: 3});\n *\n * inflate.push(chunk1, false);\n * inflate.push(chunk2, true);  // true -> last chunk\n *\n * if (inflate.err) { throw new Error(inflate.err); }\n *\n * console.log(inflate.result);\n * ```\n **/\nfunction Inflate(options) {\n  if (!(this instanceof Inflate)) return new Inflate(options);\n\n  this.options = utils.assign({\n    chunkSize: 16384,\n    windowBits: 0,\n    to: ''\n  }, options || {});\n\n  var opt = this.options;\n\n  // Force window size for `raw` data, if not set directly,\n  // because we have no header for autodetect.\n  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {\n    opt.windowBits = -opt.windowBits;\n    if (opt.windowBits === 0) { opt.windowBits = -15; }\n  }\n\n  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate\n  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&\n      !(options && options.windowBits)) {\n    opt.windowBits += 32;\n  }\n\n  // Gzip header has no info about windows size, we can do autodetect only\n  // for deflate. So, if window size not set, force it to max when gzip possible\n  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {\n    // bit 3 (16) -> gzipped data\n    // bit 4 (32) -> autodetect gzip/deflate\n    if ((opt.windowBits & 15) === 0) {\n      opt.windowBits |= 15;\n    }\n  }\n\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\n  this.msg    = '';     // error message\n  this.ended  = false;  // used to avoid multiple onEnd() calls\n  this.chunks = [];     // chunks of compressed data\n\n  this.strm   = new ZStream();\n  this.strm.avail_out = 0;\n\n  var status  = zlib_inflate.inflateInit2(\n    this.strm,\n    opt.windowBits\n  );\n\n  if (status !== c.Z_OK) {\n    throw new Error(msg[status]);\n  }\n\n  this.header = new GZheader();\n\n  zlib_inflate.inflateGetHeader(this.strm, this.header);\n}\n\n/**\n * Inflate#push(data[, mode]) -> Boolean\n * - data (Uint8Array|Array|ArrayBuffer|String): input data\n * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` meansh Z_FINISH.\n *\n * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with\n * new output chunks. Returns `true` on success. The last data block must have\n * mode Z_FINISH (or `true`). That will flush internal pending buffers and call\n * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you\n * can use mode Z_SYNC_FLUSH, keeping the decompression context.\n *\n * On fail call [[Inflate#onEnd]] with error code and return false.\n *\n * We strongly recommend to use `Uint8Array` on input for best speed (output\n * format is detected automatically). Also, don't skip last param and always\n * use the same type in your code (boolean or number). That will improve JS speed.\n *\n * For regular `Array`-s make sure all elements are [0..255].\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\nInflate.prototype.push = function (data, mode) {\n  var strm = this.strm;\n  var chunkSize = this.options.chunkSize;\n  var dictionary = this.options.dictionary;\n  var status, _mode;\n  var next_out_utf8, tail, utf8str;\n  var dict;\n\n  // Flag to properly process Z_BUF_ERROR on testing inflate call\n  // when we check that all output data was flushed.\n  var allowBufError = false;\n\n  if (this.ended) { return false; }\n  _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);\n\n  // Convert data if needed\n  if (typeof data === 'string') {\n    // Only binary strings can be decompressed on practice\n    strm.input = strings.binstring2buf(data);\n  } else if (toString.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  do {\n    if (strm.avail_out === 0) {\n      strm.output = new utils.Buf8(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n\n    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);    /* no bad return value */\n\n    if (status === c.Z_NEED_DICT && dictionary) {\n      // Convert data if needed\n      if (typeof dictionary === 'string') {\n        dict = strings.string2buf(dictionary);\n      } else if (toString.call(dictionary) === '[object ArrayBuffer]') {\n        dict = new Uint8Array(dictionary);\n      } else {\n        dict = dictionary;\n      }\n\n      status = zlib_inflate.inflateSetDictionary(this.strm, dict);\n\n    }\n\n    if (status === c.Z_BUF_ERROR && allowBufError === true) {\n      status = c.Z_OK;\n      allowBufError = false;\n    }\n\n    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {\n      this.onEnd(status);\n      this.ended = true;\n      return false;\n    }\n\n    if (strm.next_out) {\n      if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))) {\n\n        if (this.options.to === 'string') {\n\n          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);\n\n          tail = strm.next_out - next_out_utf8;\n          utf8str = strings.buf2string(strm.output, next_out_utf8);\n\n          // move tail\n          strm.next_out = tail;\n          strm.avail_out = chunkSize - tail;\n          if (tail) { utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }\n\n          this.onData(utf8str);\n\n        } else {\n          this.onData(utils.shrinkBuf(strm.output, strm.next_out));\n        }\n      }\n    }\n\n    // When no more input data, we should check that internal inflate buffers\n    // are flushed. The only way to do it when avail_out = 0 - run one more\n    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.\n    // Here we set flag to process this error properly.\n    //\n    // NOTE. Deflate does not return error in this case and does not needs such\n    // logic.\n    if (strm.avail_in === 0 && strm.avail_out === 0) {\n      allowBufError = true;\n    }\n\n  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);\n\n  if (status === c.Z_STREAM_END) {\n    _mode = c.Z_FINISH;\n  }\n\n  // Finalize on the last chunk.\n  if (_mode === c.Z_FINISH) {\n    status = zlib_inflate.inflateEnd(this.strm);\n    this.onEnd(status);\n    this.ended = true;\n    return status === c.Z_OK;\n  }\n\n  // callback interim results if Z_SYNC_FLUSH.\n  if (_mode === c.Z_SYNC_FLUSH) {\n    this.onEnd(c.Z_OK);\n    strm.avail_out = 0;\n    return true;\n  }\n\n  return true;\n};\n\n\n/**\n * Inflate#onData(chunk) -> Void\n * - chunk (Uint8Array|Array|String): ouput data. Type of array depends\n *   on js engine support. When string output requested, each chunk\n *   will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\nInflate.prototype.onData = function (chunk) {\n  this.chunks.push(chunk);\n};\n\n\n/**\n * Inflate#onEnd(status) -> Void\n * - status (Number): inflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called either after you tell inflate that the input stream is\n * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)\n * or if an error happened. By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\nInflate.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === c.Z_OK) {\n    if (this.options.to === 'string') {\n      // Glue & convert here, until we teach pako to send\n      // utf8 alligned strings to onData\n      this.result = this.chunks.join('');\n    } else {\n      this.result = utils.flattenChunks(this.chunks);\n    }\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n\n\n/**\n * inflate(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Decompress `data` with inflate/ungzip and `options`. Autodetect\n * format via wrapper header by default. That's why we don't provide\n * separate `ungzip` method.\n *\n * Supported options are:\n *\n * - windowBits\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])\n *   , output;\n *\n * try {\n *   output = pako.inflate(input);\n * } catch (err)\n *   console.log(err);\n * }\n * ```\n **/\nfunction inflate(input, options) {\n  var inflator = new Inflate(options);\n\n  inflator.push(input, true);\n\n  // That will never happens, if you don't cheat with options :)\n  if (inflator.err) { throw inflator.msg || msg[inflator.err]; }\n\n  return inflator.result;\n}\n\n\n/**\n * inflateRaw(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * The same as [[inflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nfunction inflateRaw(input, options) {\n  options = options || {};\n  options.raw = true;\n  return inflate(input, options);\n}\n\n\n/**\n * ungzip(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Just shortcut to [[inflate]], because it autodetects format\n * by header.content. Done for convenience.\n **/\n\n\nexports.Inflate = Inflate;\nexports.inflate = inflate;\nexports.inflateRaw = inflateRaw;\nexports.ungzip  = inflate;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2pzemlwL34vcGFrby9saWIvaW5mbGF0ZS5qcz8yN2I0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsVUFBVTtBQUM3QztBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EscUJBQXFCLDhCQUE4QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLGVBQWU7O0FBRWxCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHNCQUFzQjtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEIsbUJBQW1CO0FBQ25CLHNCQUFzQjtBQUN0QixtQkFBbUI7O0FBRW5CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixjQUFjO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0RBQXNEOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrRUFBa0U7O0FBRXZGOztBQUVBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxxQkFBcUIseUNBQXlDOztBQUU5RDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTA4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB6bGliX2luZmxhdGUgPSByZXF1aXJlKCcuL3psaWIvaW5mbGF0ZScpO1xudmFyIHV0aWxzICAgICAgICA9IHJlcXVpcmUoJy4vdXRpbHMvY29tbW9uJyk7XG52YXIgc3RyaW5ncyAgICAgID0gcmVxdWlyZSgnLi91dGlscy9zdHJpbmdzJyk7XG52YXIgYyAgICAgICAgICAgID0gcmVxdWlyZSgnLi96bGliL2NvbnN0YW50cycpO1xudmFyIG1zZyAgICAgICAgICA9IHJlcXVpcmUoJy4vemxpYi9tZXNzYWdlcycpO1xudmFyIFpTdHJlYW0gICAgICA9IHJlcXVpcmUoJy4vemxpYi96c3RyZWFtJyk7XG52YXIgR1poZWFkZXIgICAgID0gcmVxdWlyZSgnLi96bGliL2d6aGVhZGVyJyk7XG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogY2xhc3MgSW5mbGF0ZVxuICpcbiAqIEdlbmVyaWMgSlMtc3R5bGUgd3JhcHBlciBmb3IgemxpYiBjYWxscy4gSWYgeW91IGRvbid0IG5lZWRcbiAqIHN0cmVhbWluZyBiZWhhdmlvdXIgLSB1c2UgbW9yZSBzaW1wbGUgZnVuY3Rpb25zOiBbW2luZmxhdGVdXVxuICogYW5kIFtbaW5mbGF0ZVJhd11dLlxuICoqL1xuXG4vKiBpbnRlcm5hbFxuICogaW5mbGF0ZS5jaHVua3MgLT4gQXJyYXlcbiAqXG4gKiBDaHVua3Mgb2Ygb3V0cHV0IGRhdGEsIGlmIFtbSW5mbGF0ZSNvbkRhdGFdXSBub3Qgb3ZlcnJpZGVuLlxuICoqL1xuXG4vKipcbiAqIEluZmxhdGUucmVzdWx0IC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKlxuICogVW5jb21wcmVzc2VkIHJlc3VsdCwgZ2VuZXJhdGVkIGJ5IGRlZmF1bHQgW1tJbmZsYXRlI29uRGF0YV1dXG4gKiBhbmQgW1tJbmZsYXRlI29uRW5kXV0gaGFuZGxlcnMuIEZpbGxlZCBhZnRlciB5b3UgcHVzaCBsYXN0IGNodW5rXG4gKiAoY2FsbCBbW0luZmxhdGUjcHVzaF1dIHdpdGggYFpfRklOSVNIYCAvIGB0cnVlYCBwYXJhbSkgb3IgaWYgeW91XG4gKiBwdXNoIGEgY2h1bmsgd2l0aCBleHBsaWNpdCBmbHVzaCAoY2FsbCBbW0luZmxhdGUjcHVzaF1dIHdpdGhcbiAqIGBaX1NZTkNfRkxVU0hgIHBhcmFtKS5cbiAqKi9cblxuLyoqXG4gKiBJbmZsYXRlLmVyciAtPiBOdW1iZXJcbiAqXG4gKiBFcnJvciBjb2RlIGFmdGVyIGluZmxhdGUgZmluaXNoZWQuIDAgKFpfT0spIG9uIHN1Y2Nlc3MuXG4gKiBTaG91bGQgYmUgY2hlY2tlZCBpZiBicm9rZW4gZGF0YSBwb3NzaWJsZS5cbiAqKi9cblxuLyoqXG4gKiBJbmZsYXRlLm1zZyAtPiBTdHJpbmdcbiAqXG4gKiBFcnJvciBtZXNzYWdlLCBpZiBbW0luZmxhdGUuZXJyXV0gIT0gMFxuICoqL1xuXG5cbi8qKlxuICogbmV3IEluZmxhdGUob3B0aW9ucylcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBpbmZsYXRlIG9wdGlvbnMuXG4gKlxuICogQ3JlYXRlcyBuZXcgaW5mbGF0b3IgaW5zdGFuY2Ugd2l0aCBzcGVjaWZpZWQgcGFyYW1zLiBUaHJvd3MgZXhjZXB0aW9uXG4gKiBvbiBiYWQgcGFyYW1zLiBTdXBwb3J0ZWQgb3B0aW9uczpcbiAqXG4gKiAtIGB3aW5kb3dCaXRzYFxuICogLSBgZGljdGlvbmFyeWBcbiAqXG4gKiBbaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkXShodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWQpXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGVzZS5cbiAqXG4gKiBBZGRpdGlvbmFsIG9wdGlvbnMsIGZvciBpbnRlcm5hbCBuZWVkczpcbiAqXG4gKiAtIGBjaHVua1NpemVgIC0gc2l6ZSBvZiBnZW5lcmF0ZWQgZGF0YSBjaHVua3MgKDE2SyBieSBkZWZhdWx0KVxuICogLSBgcmF3YCAoQm9vbGVhbikgLSBkbyByYXcgaW5mbGF0ZVxuICogLSBgdG9gIChTdHJpbmcpIC0gaWYgZXF1YWwgdG8gJ3N0cmluZycsIHRoZW4gcmVzdWx0IHdpbGwgYmUgY29udmVydGVkXG4gKiAgIGZyb20gdXRmOCB0byB1dGYxNiAoamF2YXNjcmlwdCkgc3RyaW5nLiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLFxuICogICBjaHVuayBsZW5ndGggY2FuIGRpZmZlciBmcm9tIGBjaHVua1NpemVgLCBkZXBlbmRpbmcgb24gY29udGVudC5cbiAqXG4gKiBCeSBkZWZhdWx0LCB3aGVuIG5vIG9wdGlvbnMgc2V0LCBhdXRvZGV0ZWN0IGRlZmxhdGUvZ3ppcCBkYXRhIGZvcm1hdCB2aWFcbiAqIHdyYXBwZXIgaGVhZGVyLlxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIHBha28gPSByZXF1aXJlKCdwYWtvJylcbiAqICAgLCBjaHVuazEgPSBVaW50OEFycmF5KFsxLDIsMyw0LDUsNiw3LDgsOV0pXG4gKiAgICwgY2h1bmsyID0gVWludDhBcnJheShbMTAsMTEsMTIsMTMsMTQsMTUsMTYsMTcsMTgsMTldKTtcbiAqXG4gKiB2YXIgaW5mbGF0ZSA9IG5ldyBwYWtvLkluZmxhdGUoeyBsZXZlbDogM30pO1xuICpcbiAqIGluZmxhdGUucHVzaChjaHVuazEsIGZhbHNlKTtcbiAqIGluZmxhdGUucHVzaChjaHVuazIsIHRydWUpOyAgLy8gdHJ1ZSAtPiBsYXN0IGNodW5rXG4gKlxuICogaWYgKGluZmxhdGUuZXJyKSB7IHRocm93IG5ldyBFcnJvcihpbmZsYXRlLmVycik7IH1cbiAqXG4gKiBjb25zb2xlLmxvZyhpbmZsYXRlLnJlc3VsdCk7XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIEluZmxhdGUob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSW5mbGF0ZSkpIHJldHVybiBuZXcgSW5mbGF0ZShvcHRpb25zKTtcblxuICB0aGlzLm9wdGlvbnMgPSB1dGlscy5hc3NpZ24oe1xuICAgIGNodW5rU2l6ZTogMTYzODQsXG4gICAgd2luZG93Qml0czogMCxcbiAgICB0bzogJydcbiAgfSwgb3B0aW9ucyB8fCB7fSk7XG5cbiAgdmFyIG9wdCA9IHRoaXMub3B0aW9ucztcblxuICAvLyBGb3JjZSB3aW5kb3cgc2l6ZSBmb3IgYHJhd2AgZGF0YSwgaWYgbm90IHNldCBkaXJlY3RseSxcbiAgLy8gYmVjYXVzZSB3ZSBoYXZlIG5vIGhlYWRlciBmb3IgYXV0b2RldGVjdC5cbiAgaWYgKG9wdC5yYXcgJiYgKG9wdC53aW5kb3dCaXRzID49IDApICYmIChvcHQud2luZG93Qml0cyA8IDE2KSkge1xuICAgIG9wdC53aW5kb3dCaXRzID0gLW9wdC53aW5kb3dCaXRzO1xuICAgIGlmIChvcHQud2luZG93Qml0cyA9PT0gMCkgeyBvcHQud2luZG93Qml0cyA9IC0xNTsgfVxuICB9XG5cbiAgLy8gSWYgYHdpbmRvd0JpdHNgIG5vdCBkZWZpbmVkIChhbmQgbW9kZSBub3QgcmF3KSAtIHNldCBhdXRvZGV0ZWN0IGZsYWcgZm9yIGd6aXAvZGVmbGF0ZVxuICBpZiAoKG9wdC53aW5kb3dCaXRzID49IDApICYmIChvcHQud2luZG93Qml0cyA8IDE2KSAmJlxuICAgICAgIShvcHRpb25zICYmIG9wdGlvbnMud2luZG93Qml0cykpIHtcbiAgICBvcHQud2luZG93Qml0cyArPSAzMjtcbiAgfVxuXG4gIC8vIEd6aXAgaGVhZGVyIGhhcyBubyBpbmZvIGFib3V0IHdpbmRvd3Mgc2l6ZSwgd2UgY2FuIGRvIGF1dG9kZXRlY3Qgb25seVxuICAvLyBmb3IgZGVmbGF0ZS4gU28sIGlmIHdpbmRvdyBzaXplIG5vdCBzZXQsIGZvcmNlIGl0IHRvIG1heCB3aGVuIGd6aXAgcG9zc2libGVcbiAgaWYgKChvcHQud2luZG93Qml0cyA+IDE1KSAmJiAob3B0LndpbmRvd0JpdHMgPCA0OCkpIHtcbiAgICAvLyBiaXQgMyAoMTYpIC0+IGd6aXBwZWQgZGF0YVxuICAgIC8vIGJpdCA0ICgzMikgLT4gYXV0b2RldGVjdCBnemlwL2RlZmxhdGVcbiAgICBpZiAoKG9wdC53aW5kb3dCaXRzICYgMTUpID09PSAwKSB7XG4gICAgICBvcHQud2luZG93Qml0cyB8PSAxNTtcbiAgICB9XG4gIH1cblxuICB0aGlzLmVyciAgICA9IDA7ICAgICAgLy8gZXJyb3IgY29kZSwgaWYgaGFwcGVucyAoMCA9IFpfT0spXG4gIHRoaXMubXNnICAgID0gJyc7ICAgICAvLyBlcnJvciBtZXNzYWdlXG4gIHRoaXMuZW5kZWQgID0gZmFsc2U7ICAvLyB1c2VkIHRvIGF2b2lkIG11bHRpcGxlIG9uRW5kKCkgY2FsbHNcbiAgdGhpcy5jaHVua3MgPSBbXTsgICAgIC8vIGNodW5rcyBvZiBjb21wcmVzc2VkIGRhdGFcblxuICB0aGlzLnN0cm0gICA9IG5ldyBaU3RyZWFtKCk7XG4gIHRoaXMuc3RybS5hdmFpbF9vdXQgPSAwO1xuXG4gIHZhciBzdGF0dXMgID0gemxpYl9pbmZsYXRlLmluZmxhdGVJbml0MihcbiAgICB0aGlzLnN0cm0sXG4gICAgb3B0LndpbmRvd0JpdHNcbiAgKTtcblxuICBpZiAoc3RhdHVzICE9PSBjLlpfT0spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnW3N0YXR1c10pO1xuICB9XG5cbiAgdGhpcy5oZWFkZXIgPSBuZXcgR1poZWFkZXIoKTtcblxuICB6bGliX2luZmxhdGUuaW5mbGF0ZUdldEhlYWRlcih0aGlzLnN0cm0sIHRoaXMuaGVhZGVyKTtcbn1cblxuLyoqXG4gKiBJbmZsYXRlI3B1c2goZGF0YVssIG1vZGVdKSAtPiBCb29sZWFuXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8QXJyYXlCdWZmZXJ8U3RyaW5nKTogaW5wdXQgZGF0YVxuICogLSBtb2RlIChOdW1iZXJ8Qm9vbGVhbik6IDAuLjYgZm9yIGNvcnJlc3BvbmRpbmcgWl9OT19GTFVTSC4uWl9UUkVFIG1vZGVzLlxuICogICBTZWUgY29uc3RhbnRzLiBTa2lwcGVkIG9yIGBmYWxzZWAgbWVhbnMgWl9OT19GTFVTSCwgYHRydWVgIG1lYW5zaCBaX0ZJTklTSC5cbiAqXG4gKiBTZW5kcyBpbnB1dCBkYXRhIHRvIGluZmxhdGUgcGlwZSwgZ2VuZXJhdGluZyBbW0luZmxhdGUjb25EYXRhXV0gY2FsbHMgd2l0aFxuICogbmV3IG91dHB1dCBjaHVua3MuIFJldHVybnMgYHRydWVgIG9uIHN1Y2Nlc3MuIFRoZSBsYXN0IGRhdGEgYmxvY2sgbXVzdCBoYXZlXG4gKiBtb2RlIFpfRklOSVNIIChvciBgdHJ1ZWApLiBUaGF0IHdpbGwgZmx1c2ggaW50ZXJuYWwgcGVuZGluZyBidWZmZXJzIGFuZCBjYWxsXG4gKiBbW0luZmxhdGUjb25FbmRdXS4gRm9yIGludGVyaW0gZXhwbGljaXQgZmx1c2hlcyAod2l0aG91dCBlbmRpbmcgdGhlIHN0cmVhbSkgeW91XG4gKiBjYW4gdXNlIG1vZGUgWl9TWU5DX0ZMVVNILCBrZWVwaW5nIHRoZSBkZWNvbXByZXNzaW9uIGNvbnRleHQuXG4gKlxuICogT24gZmFpbCBjYWxsIFtbSW5mbGF0ZSNvbkVuZF1dIHdpdGggZXJyb3IgY29kZSBhbmQgcmV0dXJuIGZhbHNlLlxuICpcbiAqIFdlIHN0cm9uZ2x5IHJlY29tbWVuZCB0byB1c2UgYFVpbnQ4QXJyYXlgIG9uIGlucHV0IGZvciBiZXN0IHNwZWVkIChvdXRwdXRcbiAqIGZvcm1hdCBpcyBkZXRlY3RlZCBhdXRvbWF0aWNhbGx5KS4gQWxzbywgZG9uJ3Qgc2tpcCBsYXN0IHBhcmFtIGFuZCBhbHdheXNcbiAqIHVzZSB0aGUgc2FtZSB0eXBlIGluIHlvdXIgY29kZSAoYm9vbGVhbiBvciBudW1iZXIpLiBUaGF0IHdpbGwgaW1wcm92ZSBKUyBzcGVlZC5cbiAqXG4gKiBGb3IgcmVndWxhciBgQXJyYXlgLXMgbWFrZSBzdXJlIGFsbCBlbGVtZW50cyBhcmUgWzAuLjI1NV0uXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHB1c2goY2h1bmssIGZhbHNlKTsgLy8gcHVzaCBvbmUgb2YgZGF0YSBjaHVua3NcbiAqIC4uLlxuICogcHVzaChjaHVuaywgdHJ1ZSk7ICAvLyBwdXNoIGxhc3QgY2h1bmtcbiAqIGBgYFxuICoqL1xuSW5mbGF0ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChkYXRhLCBtb2RlKSB7XG4gIHZhciBzdHJtID0gdGhpcy5zdHJtO1xuICB2YXIgY2h1bmtTaXplID0gdGhpcy5vcHRpb25zLmNodW5rU2l6ZTtcbiAgdmFyIGRpY3Rpb25hcnkgPSB0aGlzLm9wdGlvbnMuZGljdGlvbmFyeTtcbiAgdmFyIHN0YXR1cywgX21vZGU7XG4gIHZhciBuZXh0X291dF91dGY4LCB0YWlsLCB1dGY4c3RyO1xuICB2YXIgZGljdDtcblxuICAvLyBGbGFnIHRvIHByb3Blcmx5IHByb2Nlc3MgWl9CVUZfRVJST1Igb24gdGVzdGluZyBpbmZsYXRlIGNhbGxcbiAgLy8gd2hlbiB3ZSBjaGVjayB0aGF0IGFsbCBvdXRwdXQgZGF0YSB3YXMgZmx1c2hlZC5cbiAgdmFyIGFsbG93QnVmRXJyb3IgPSBmYWxzZTtcblxuICBpZiAodGhpcy5lbmRlZCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgX21vZGUgPSAobW9kZSA9PT0gfn5tb2RlKSA/IG1vZGUgOiAoKG1vZGUgPT09IHRydWUpID8gYy5aX0ZJTklTSCA6IGMuWl9OT19GTFVTSCk7XG5cbiAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gT25seSBiaW5hcnkgc3RyaW5ncyBjYW4gYmUgZGVjb21wcmVzc2VkIG9uIHByYWN0aWNlXG4gICAgc3RybS5pbnB1dCA9IHN0cmluZ3MuYmluc3RyaW5nMmJ1ZihkYXRhKTtcbiAgfSBlbHNlIGlmICh0b1N0cmluZy5jYWxsKGRhdGEpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7XG4gICAgc3RybS5pbnB1dCA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICB9IGVsc2Uge1xuICAgIHN0cm0uaW5wdXQgPSBkYXRhO1xuICB9XG5cbiAgc3RybS5uZXh0X2luID0gMDtcbiAgc3RybS5hdmFpbF9pbiA9IHN0cm0uaW5wdXQubGVuZ3RoO1xuXG4gIGRvIHtcbiAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHN0cm0ub3V0cHV0ID0gbmV3IHV0aWxzLkJ1ZjgoY2h1bmtTaXplKTtcbiAgICAgIHN0cm0ubmV4dF9vdXQgPSAwO1xuICAgICAgc3RybS5hdmFpbF9vdXQgPSBjaHVua1NpemU7XG4gICAgfVxuXG4gICAgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGUoc3RybSwgYy5aX05PX0ZMVVNIKTsgICAgLyogbm8gYmFkIHJldHVybiB2YWx1ZSAqL1xuXG4gICAgaWYgKHN0YXR1cyA9PT0gYy5aX05FRURfRElDVCAmJiBkaWN0aW9uYXJ5KSB7XG4gICAgICAvLyBDb252ZXJ0IGRhdGEgaWYgbmVlZGVkXG4gICAgICBpZiAodHlwZW9mIGRpY3Rpb25hcnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGRpY3QgPSBzdHJpbmdzLnN0cmluZzJidWYoZGljdGlvbmFyeSk7XG4gICAgICB9IGVsc2UgaWYgKHRvU3RyaW5nLmNhbGwoZGljdGlvbmFyeSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICAgICAgZGljdCA9IG5ldyBVaW50OEFycmF5KGRpY3Rpb25hcnkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGljdCA9IGRpY3Rpb25hcnk7XG4gICAgICB9XG5cbiAgICAgIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sIGRpY3QpO1xuXG4gICAgfVxuXG4gICAgaWYgKHN0YXR1cyA9PT0gYy5aX0JVRl9FUlJPUiAmJiBhbGxvd0J1ZkVycm9yID09PSB0cnVlKSB7XG4gICAgICBzdGF0dXMgPSBjLlpfT0s7XG4gICAgICBhbGxvd0J1ZkVycm9yID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHN0YXR1cyAhPT0gYy5aX1NUUkVBTV9FTkQgJiYgc3RhdHVzICE9PSBjLlpfT0spIHtcbiAgICAgIHRoaXMub25FbmQoc3RhdHVzKTtcbiAgICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChzdHJtLm5leHRfb3V0KSB7XG4gICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDAgfHwgc3RhdHVzID09PSBjLlpfU1RSRUFNX0VORCB8fCAoc3RybS5hdmFpbF9pbiA9PT0gMCAmJiAoX21vZGUgPT09IGMuWl9GSU5JU0ggfHwgX21vZGUgPT09IGMuWl9TWU5DX0ZMVVNIKSkpIHtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAnc3RyaW5nJykge1xuXG4gICAgICAgICAgbmV4dF9vdXRfdXRmOCA9IHN0cmluZ3MudXRmOGJvcmRlcihzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCk7XG5cbiAgICAgICAgICB0YWlsID0gc3RybS5uZXh0X291dCAtIG5leHRfb3V0X3V0Zjg7XG4gICAgICAgICAgdXRmOHN0ciA9IHN0cmluZ3MuYnVmMnN0cmluZyhzdHJtLm91dHB1dCwgbmV4dF9vdXRfdXRmOCk7XG5cbiAgICAgICAgICAvLyBtb3ZlIHRhaWxcbiAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gdGFpbDtcbiAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGNodW5rU2l6ZSAtIHRhaWw7XG4gICAgICAgICAgaWYgKHRhaWwpIHsgdXRpbHMuYXJyYXlTZXQoc3RybS5vdXRwdXQsIHN0cm0ub3V0cHV0LCBuZXh0X291dF91dGY4LCB0YWlsLCAwKTsgfVxuXG4gICAgICAgICAgdGhpcy5vbkRhdGEodXRmOHN0cik7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm9uRGF0YSh1dGlscy5zaHJpbmtCdWYoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFdoZW4gbm8gbW9yZSBpbnB1dCBkYXRhLCB3ZSBzaG91bGQgY2hlY2sgdGhhdCBpbnRlcm5hbCBpbmZsYXRlIGJ1ZmZlcnNcbiAgICAvLyBhcmUgZmx1c2hlZC4gVGhlIG9ubHkgd2F5IHRvIGRvIGl0IHdoZW4gYXZhaWxfb3V0ID0gMCAtIHJ1biBvbmUgbW9yZVxuICAgIC8vIGluZmxhdGUgcGFzcy4gQnV0IGlmIG91dHB1dCBkYXRhIG5vdCBleGlzdHMsIGluZmxhdGUgcmV0dXJuIFpfQlVGX0VSUk9SLlxuICAgIC8vIEhlcmUgd2Ugc2V0IGZsYWcgdG8gcHJvY2VzcyB0aGlzIGVycm9yIHByb3Blcmx5LlxuICAgIC8vXG4gICAgLy8gTk9URS4gRGVmbGF0ZSBkb2VzIG5vdCByZXR1cm4gZXJyb3IgaW4gdGhpcyBjYXNlIGFuZCBkb2VzIG5vdCBuZWVkcyBzdWNoXG4gICAgLy8gbG9naWMuXG4gICAgaWYgKHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIGFsbG93QnVmRXJyb3IgPSB0cnVlO1xuICAgIH1cblxuICB9IHdoaWxlICgoc3RybS5hdmFpbF9pbiA+IDAgfHwgc3RybS5hdmFpbF9vdXQgPT09IDApICYmIHN0YXR1cyAhPT0gYy5aX1NUUkVBTV9FTkQpO1xuXG4gIGlmIChzdGF0dXMgPT09IGMuWl9TVFJFQU1fRU5EKSB7XG4gICAgX21vZGUgPSBjLlpfRklOSVNIO1xuICB9XG5cbiAgLy8gRmluYWxpemUgb24gdGhlIGxhc3QgY2h1bmsuXG4gIGlmIChfbW9kZSA9PT0gYy5aX0ZJTklTSCkge1xuICAgIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlRW5kKHRoaXMuc3RybSk7XG4gICAgdGhpcy5vbkVuZChzdGF0dXMpO1xuICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgIHJldHVybiBzdGF0dXMgPT09IGMuWl9PSztcbiAgfVxuXG4gIC8vIGNhbGxiYWNrIGludGVyaW0gcmVzdWx0cyBpZiBaX1NZTkNfRkxVU0guXG4gIGlmIChfbW9kZSA9PT0gYy5aX1NZTkNfRkxVU0gpIHtcbiAgICB0aGlzLm9uRW5kKGMuWl9PSyk7XG4gICAgc3RybS5hdmFpbF9vdXQgPSAwO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cbi8qKlxuICogSW5mbGF0ZSNvbkRhdGEoY2h1bmspIC0+IFZvaWRcbiAqIC0gY2h1bmsgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogb3VwdXQgZGF0YS4gVHlwZSBvZiBhcnJheSBkZXBlbmRzXG4gKiAgIG9uIGpzIGVuZ2luZSBzdXBwb3J0LiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLCBlYWNoIGNodW5rXG4gKiAgIHdpbGwgYmUgc3RyaW5nLlxuICpcbiAqIEJ5IGRlZmF1bHQsIHN0b3JlcyBkYXRhIGJsb2NrcyBpbiBgY2h1bmtzW11gIHByb3BlcnR5IGFuZCBnbHVlXG4gKiB0aG9zZSBpbiBgb25FbmRgLiBPdmVycmlkZSB0aGlzIGhhbmRsZXIsIGlmIHlvdSBuZWVkIGFub3RoZXIgYmVoYXZpb3VyLlxuICoqL1xuSW5mbGF0ZS5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHRoaXMuY2h1bmtzLnB1c2goY2h1bmspO1xufTtcblxuXG4vKipcbiAqIEluZmxhdGUjb25FbmQoc3RhdHVzKSAtPiBWb2lkXG4gKiAtIHN0YXR1cyAoTnVtYmVyKTogaW5mbGF0ZSBzdGF0dXMuIDAgKFpfT0spIG9uIHN1Y2Nlc3MsXG4gKiAgIG90aGVyIGlmIG5vdC5cbiAqXG4gKiBDYWxsZWQgZWl0aGVyIGFmdGVyIHlvdSB0ZWxsIGluZmxhdGUgdGhhdCB0aGUgaW5wdXQgc3RyZWFtIGlzXG4gKiBjb21wbGV0ZSAoWl9GSU5JU0gpIG9yIHNob3VsZCBiZSBmbHVzaGVkIChaX1NZTkNfRkxVU0gpXG4gKiBvciBpZiBhbiBlcnJvciBoYXBwZW5lZC4gQnkgZGVmYXVsdCAtIGpvaW4gY29sbGVjdGVkIGNodW5rcyxcbiAqIGZyZWUgbWVtb3J5IGFuZCBmaWxsIGByZXN1bHRzYCAvIGBlcnJgIHByb3BlcnRpZXMuXG4gKiovXG5JbmZsYXRlLnByb3RvdHlwZS5vbkVuZCA9IGZ1bmN0aW9uIChzdGF0dXMpIHtcbiAgLy8gT24gc3VjY2VzcyAtIGpvaW5cbiAgaWYgKHN0YXR1cyA9PT0gYy5aX09LKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy50byA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIEdsdWUgJiBjb252ZXJ0IGhlcmUsIHVudGlsIHdlIHRlYWNoIHBha28gdG8gc2VuZFxuICAgICAgLy8gdXRmOCBhbGxpZ25lZCBzdHJpbmdzIHRvIG9uRGF0YVxuICAgICAgdGhpcy5yZXN1bHQgPSB0aGlzLmNodW5rcy5qb2luKCcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZXN1bHQgPSB1dGlscy5mbGF0dGVuQ2h1bmtzKHRoaXMuY2h1bmtzKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5jaHVua3MgPSBbXTtcbiAgdGhpcy5lcnIgPSBzdGF0dXM7XG4gIHRoaXMubXNnID0gdGhpcy5zdHJtLm1zZztcbn07XG5cblxuLyoqXG4gKiBpbmZsYXRlKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGRlY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgaW5mbGF0ZSBvcHRpb25zLlxuICpcbiAqIERlY29tcHJlc3MgYGRhdGFgIHdpdGggaW5mbGF0ZS91bmd6aXAgYW5kIGBvcHRpb25zYC4gQXV0b2RldGVjdFxuICogZm9ybWF0IHZpYSB3cmFwcGVyIGhlYWRlciBieSBkZWZhdWx0LiBUaGF0J3Mgd2h5IHdlIGRvbid0IHByb3ZpZGVcbiAqIHNlcGFyYXRlIGB1bmd6aXBgIG1ldGhvZC5cbiAqXG4gKiBTdXBwb3J0ZWQgb3B0aW9ucyBhcmU6XG4gKlxuICogLSB3aW5kb3dCaXRzXG4gKlxuICogW2h0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZF0oaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkKVxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogU3VnYXIgKG9wdGlvbnMpOlxuICpcbiAqIC0gYHJhd2AgKEJvb2xlYW4pIC0gc2F5IHRoYXQgd2Ugd29yayB3aXRoIHJhdyBzdHJlYW0sIGlmIHlvdSBkb24ndCB3aXNoIHRvIHNwZWNpZnlcbiAqICAgbmVnYXRpdmUgd2luZG93Qml0cyBpbXBsaWNpdGx5LlxuICogLSBgdG9gIChTdHJpbmcpIC0gaWYgZXF1YWwgdG8gJ3N0cmluZycsIHRoZW4gcmVzdWx0IHdpbGwgYmUgY29udmVydGVkXG4gKiAgIGZyb20gdXRmOCB0byB1dGYxNiAoamF2YXNjcmlwdCkgc3RyaW5nLiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLFxuICogICBjaHVuayBsZW5ndGggY2FuIGRpZmZlciBmcm9tIGBjaHVua1NpemVgLCBkZXBlbmRpbmcgb24gY29udGVudC5cbiAqXG4gKlxuICogIyMjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKVxuICogICAsIGlucHV0ID0gcGFrby5kZWZsYXRlKFsxLDIsMyw0LDUsNiw3LDgsOV0pXG4gKiAgICwgb3V0cHV0O1xuICpcbiAqIHRyeSB7XG4gKiAgIG91dHB1dCA9IHBha28uaW5mbGF0ZShpbnB1dCk7XG4gKiB9IGNhdGNoIChlcnIpXG4gKiAgIGNvbnNvbGUubG9nKGVycik7XG4gKiB9XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIGluZmxhdGUoaW5wdXQsIG9wdGlvbnMpIHtcbiAgdmFyIGluZmxhdG9yID0gbmV3IEluZmxhdGUob3B0aW9ucyk7XG5cbiAgaW5mbGF0b3IucHVzaChpbnB1dCwgdHJ1ZSk7XG5cbiAgLy8gVGhhdCB3aWxsIG5ldmVyIGhhcHBlbnMsIGlmIHlvdSBkb24ndCBjaGVhdCB3aXRoIG9wdGlvbnMgOilcbiAgaWYgKGluZmxhdG9yLmVycikgeyB0aHJvdyBpbmZsYXRvci5tc2cgfHwgbXNnW2luZmxhdG9yLmVycl07IH1cblxuICByZXR1cm4gaW5mbGF0b3IucmVzdWx0O1xufVxuXG5cbi8qKlxuICogaW5mbGF0ZVJhdyhkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBkZWNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBUaGUgc2FtZSBhcyBbW2luZmxhdGVdXSwgYnV0IGNyZWF0ZXMgcmF3IGRhdGEsIHdpdGhvdXQgd3JhcHBlclxuICogKGhlYWRlciBhbmQgYWRsZXIzMiBjcmMpLlxuICoqL1xuZnVuY3Rpb24gaW5mbGF0ZVJhdyhpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5yYXcgPSB0cnVlO1xuICByZXR1cm4gaW5mbGF0ZShpbnB1dCwgb3B0aW9ucyk7XG59XG5cblxuLyoqXG4gKiB1bmd6aXAoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gZGVjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBpbmZsYXRlIG9wdGlvbnMuXG4gKlxuICogSnVzdCBzaG9ydGN1dCB0byBbW2luZmxhdGVdXSwgYmVjYXVzZSBpdCBhdXRvZGV0ZWN0cyBmb3JtYXRcbiAqIGJ5IGhlYWRlci5jb250ZW50LiBEb25lIGZvciBjb252ZW5pZW5jZS5cbiAqKi9cblxuXG5leHBvcnRzLkluZmxhdGUgPSBJbmZsYXRlO1xuZXhwb3J0cy5pbmZsYXRlID0gaW5mbGF0ZTtcbmV4cG9ydHMuaW5mbGF0ZVJhdyA9IGluZmxhdGVSYXc7XG5leHBvcnRzLnVuZ3ppcCAgPSBpbmZsYXRlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2pzemlwL34vcGFrby9saWIvaW5mbGF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){"use strict";eval('\n\nvar utils   = __webpack_require__(3);\nvar trees   = __webpack_require__(114);\nvar adler32 = __webpack_require__(50);\nvar crc32   = __webpack_require__(52);\nvar msg     = __webpack_require__(29);\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n/* Allowed flush values; see deflate() and inflate() below for details */\nvar Z_NO_FLUSH      = 0;\nvar Z_PARTIAL_FLUSH = 1;\n//var Z_SYNC_FLUSH    = 2;\nvar Z_FULL_FLUSH    = 3;\nvar Z_FINISH        = 4;\nvar Z_BLOCK         = 5;\n//var Z_TREES         = 6;\n\n\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\n//var Z_NEED_DICT     = 2;\n//var Z_ERRNO         = -1;\nvar Z_STREAM_ERROR  = -2;\nvar Z_DATA_ERROR    = -3;\n//var Z_MEM_ERROR     = -4;\nvar Z_BUF_ERROR     = -5;\n//var Z_VERSION_ERROR = -6;\n\n\n/* compression levels */\n//var Z_NO_COMPRESSION      = 0;\n//var Z_BEST_SPEED          = 1;\n//var Z_BEST_COMPRESSION    = 9;\nvar Z_DEFAULT_COMPRESSION = -1;\n\n\nvar Z_FILTERED            = 1;\nvar Z_HUFFMAN_ONLY        = 2;\nvar Z_RLE                 = 3;\nvar Z_FIXED               = 4;\nvar Z_DEFAULT_STRATEGY    = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\n//var Z_BINARY              = 0;\n//var Z_TEXT                = 1;\n//var Z_ASCII               = 1; // = Z_TEXT\nvar Z_UNKNOWN             = 2;\n\n\n/* The deflate compression method */\nvar Z_DEFLATED  = 8;\n\n/*============================================================================*/\n\n\nvar MAX_MEM_LEVEL = 9;\n/* Maximum value for memLevel in deflateInit2 */\nvar MAX_WBITS = 15;\n/* 32K LZ77 window */\nvar DEF_MEM_LEVEL = 8;\n\n\nvar LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\nvar LITERALS      = 256;\n/* number of literal bytes 0..255 */\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\nvar D_CODES       = 30;\n/* number of distance codes */\nvar BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\nvar HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\nvar MAX_BITS  = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nvar MIN_MATCH = 3;\nvar MAX_MATCH = 258;\nvar MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);\n\nvar PRESET_DICT = 0x20;\n\nvar INIT_STATE = 42;\nvar EXTRA_STATE = 69;\nvar NAME_STATE = 73;\nvar COMMENT_STATE = 91;\nvar HCRC_STATE = 103;\nvar BUSY_STATE = 113;\nvar FINISH_STATE = 666;\n\nvar BS_NEED_MORE      = 1; /* block not completed, need more input or more output */\nvar BS_BLOCK_DONE     = 2; /* block flush performed */\nvar BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */\nvar BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */\n\nvar OS_CODE = 0x03; // Unix :) . Don\'t detect, use this default.\n\nfunction err(strm, errorCode) {\n  strm.msg = msg[errorCode];\n  return errorCode;\n}\n\nfunction rank(f) {\n  return ((f) << 1) - ((f) > 4 ? 9 : 0);\n}\n\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n\n/* =========================================================================\n * Flush as much pending output as possible. All deflate() output goes\n * through this function so some applications may wish to modify it\n * to avoid allocating a large strm->output buffer and copying into it.\n * (See also read_buf()).\n */\nfunction flush_pending(strm) {\n  var s = strm.state;\n\n  //_tr_flush_bits(s);\n  var len = s.pending;\n  if (len > strm.avail_out) {\n    len = strm.avail_out;\n  }\n  if (len === 0) { return; }\n\n  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);\n  strm.next_out += len;\n  s.pending_out += len;\n  strm.total_out += len;\n  strm.avail_out -= len;\n  s.pending -= len;\n  if (s.pending === 0) {\n    s.pending_out = 0;\n  }\n}\n\n\nfunction flush_block_only(s, last) {\n  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);\n  s.block_start = s.strstart;\n  flush_pending(s.strm);\n}\n\n\nfunction put_byte(s, b) {\n  s.pending_buf[s.pending++] = b;\n}\n\n\n/* =========================================================================\n * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n * IN assertion: the stream state is correct and there is enough room in\n * pending_buf.\n */\nfunction putShortMSB(s, b) {\n//  put_byte(s, (Byte)(b >> 8));\n//  put_byte(s, (Byte)(b & 0xff));\n  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;\n  s.pending_buf[s.pending++] = b & 0xff;\n}\n\n\n/* ===========================================================================\n * Read a new buffer from the current input stream, update the adler32\n * and total number of bytes read.  All deflate() input goes through\n * this function so some applications may wish to modify it to avoid\n * allocating a large strm->input buffer and copying from it.\n * (See also flush_pending()).\n */\nfunction read_buf(strm, buf, start, size) {\n  var len = strm.avail_in;\n\n  if (len > size) { len = size; }\n  if (len === 0) { return 0; }\n\n  strm.avail_in -= len;\n\n  // zmemcpy(buf, strm->next_in, len);\n  utils.arraySet(buf, strm.input, strm.next_in, len, start);\n  if (strm.state.wrap === 1) {\n    strm.adler = adler32(strm.adler, buf, len, start);\n  }\n\n  else if (strm.state.wrap === 2) {\n    strm.adler = crc32(strm.adler, buf, len, start);\n  }\n\n  strm.next_in += len;\n  strm.total_in += len;\n\n  return len;\n}\n\n\n/* ===========================================================================\n * Set match_start to the longest match starting at the given string and\n * return its length. Matches shorter or equal to prev_length are discarded,\n * in which case the result is equal to prev_length and match_start is\n * garbage.\n * IN assertions: cur_match is the head of the hash chain for the current\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n * OUT assertion: the match length is not greater than s->lookahead.\n */\nfunction longest_match(s, cur_match) {\n  var chain_length = s.max_chain_length;      /* max hash chain length */\n  var scan = s.strstart; /* current string */\n  var match;                       /* matched string */\n  var len;                           /* length of current match */\n  var best_len = s.prev_length;              /* best match length so far */\n  var nice_match = s.nice_match;             /* stop if match long enough */\n  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?\n      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;\n\n  var _win = s.window; // shortcut\n\n  var wmask = s.w_mask;\n  var prev  = s.prev;\n\n  /* Stop when cur_match becomes <= limit. To simplify the code,\n   * we prevent matches with the string of window index 0.\n   */\n\n  var strend = s.strstart + MAX_MATCH;\n  var scan_end1  = _win[scan + best_len - 1];\n  var scan_end   = _win[scan + best_len];\n\n  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n   * It is easy to get rid of this optimization if necessary.\n   */\n  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");\n\n  /* Do not waste too much time if we already have a good match: */\n  if (s.prev_length >= s.good_match) {\n    chain_length >>= 2;\n  }\n  /* Do not look for matches beyond the end of the input. This is necessary\n   * to make deflate deterministic.\n   */\n  if (nice_match > s.lookahead) { nice_match = s.lookahead; }\n\n  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");\n\n  do {\n    // Assert(cur_match < s->strstart, "no future");\n    match = cur_match;\n\n    /* Skip to next match if the match length cannot increase\n     * or if the match length is less than 2.  Note that the checks below\n     * for insufficient lookahead only occur occasionally for performance\n     * reasons.  Therefore uninitialized memory will be accessed, and\n     * conditional jumps will be made that depend on those values.\n     * However the length of the match is limited to the lookahead, so\n     * the output of deflate is not affected by the uninitialized values.\n     */\n\n    if (_win[match + best_len]     !== scan_end  ||\n        _win[match + best_len - 1] !== scan_end1 ||\n        _win[match]                !== _win[scan] ||\n        _win[++match]              !== _win[scan + 1]) {\n      continue;\n    }\n\n    /* The check at best_len-1 can be removed because it will be made\n     * again later. (This heuristic is not always a win.)\n     * It is not necessary to compare scan[2] and match[2] since they\n     * are always equal when the other bytes match, given that\n     * the hash keys are equal and that HASH_BITS >= 8.\n     */\n    scan += 2;\n    match++;\n    // Assert(*scan == *match, "match[2]?");\n\n    /* We check for insufficient lookahead only every 8th comparison;\n     * the 256th check will be made at strstart+258.\n     */\n    do {\n      /*jshint noempty:false*/\n    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             scan < strend);\n\n    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");\n\n    len = MAX_MATCH - (strend - scan);\n    scan = strend - MAX_MATCH;\n\n    if (len > best_len) {\n      s.match_start = cur_match;\n      best_len = len;\n      if (len >= nice_match) {\n        break;\n      }\n      scan_end1  = _win[scan + best_len - 1];\n      scan_end   = _win[scan + best_len];\n    }\n  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n\n  if (best_len <= s.lookahead) {\n    return best_len;\n  }\n  return s.lookahead;\n}\n\n\n/* ===========================================================================\n * Fill the window when the lookahead becomes insufficient.\n * Updates strstart and lookahead.\n *\n * IN assertion: lookahead < MIN_LOOKAHEAD\n * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n *    At least one byte has been read, or avail_in == 0; reads are\n *    performed for at least two bytes (required for the zip translate_eol\n *    option -- not supported here).\n */\nfunction fill_window(s) {\n  var _w_size = s.w_size;\n  var p, n, m, more, str;\n\n  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");\n\n  do {\n    more = s.window_size - s.lookahead - s.strstart;\n\n    // JS ints have 32 bit, block below not needed\n    /* Deal with !@#$% 64K limit: */\n    //if (sizeof(int) <= 2) {\n    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n    //        more = wsize;\n    //\n    //  } else if (more == (unsigned)(-1)) {\n    //        /* Very unlikely, but possible on 16 bit machine if\n    //         * strstart == 0 && lookahead == 1 (input done a byte at time)\n    //         */\n    //        more--;\n    //    }\n    //}\n\n\n    /* If the window is almost full and there is insufficient lookahead,\n     * move the upper half to the lower one to make room in the upper half.\n     */\n    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n\n      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);\n      s.match_start -= _w_size;\n      s.strstart -= _w_size;\n      /* we now have strstart >= MAX_DIST */\n      s.block_start -= _w_size;\n\n      /* Slide the hash table (could be avoided with 32 bit values\n       at the expense of memory usage). We slide even when level == 0\n       to keep the hash table consistent if we switch back to level > 0\n       later. (Using level 0 permanently is not an optimal usage of\n       zlib, so we don\'t care about this pathological case.)\n       */\n\n      n = s.hash_size;\n      p = n;\n      do {\n        m = s.head[--p];\n        s.head[p] = (m >= _w_size ? m - _w_size : 0);\n      } while (--n);\n\n      n = _w_size;\n      p = n;\n      do {\n        m = s.prev[--p];\n        s.prev[p] = (m >= _w_size ? m - _w_size : 0);\n        /* If n is not on any hash chain, prev[n] is garbage but\n         * its value will never be used.\n         */\n      } while (--n);\n\n      more += _w_size;\n    }\n    if (s.strm.avail_in === 0) {\n      break;\n    }\n\n    /* If there was no sliding:\n     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n     *    more == window_size - lookahead - strstart\n     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n     * => more >= window_size - 2*WSIZE + 2\n     * In the BIG_MEM or MMAP case (not yet supported),\n     *   window_size == input_size + MIN_LOOKAHEAD  &&\n     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n     * Otherwise, window_size == 2*WSIZE so more >= 2.\n     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n     */\n    //Assert(more >= 2, "more < 2");\n    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n    s.lookahead += n;\n\n    /* Initialize the hash value now that we have some input: */\n    if (s.lookahead + s.insert >= MIN_MATCH) {\n      str = s.strstart - s.insert;\n      s.ins_h = s.window[str];\n\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;\n//#if MIN_MATCH != 3\n//        Call update_hash() MIN_MATCH-3 more times\n//#endif\n      while (s.insert) {\n        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n\n        s.prev[str & s.w_mask] = s.head[s.ins_h];\n        s.head[s.ins_h] = str;\n        str++;\n        s.insert--;\n        if (s.lookahead + s.insert < MIN_MATCH) {\n          break;\n        }\n      }\n    }\n    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n     * but this is not important since only literal bytes will be emitted.\n     */\n\n  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n\n  /* If the WIN_INIT bytes after the end of the current data have never been\n   * written, then zero those bytes in order to avoid memory check reports of\n   * the use of uninitialized (or uninitialised as Julian writes) bytes by\n   * the longest match routines.  Update the high water mark for the next\n   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n   */\n//  if (s.high_water < s.window_size) {\n//    var curr = s.strstart + s.lookahead;\n//    var init = 0;\n//\n//    if (s.high_water < curr) {\n//      /* Previous high water mark below current data -- zero WIN_INIT\n//       * bytes or up to end of window, whichever is less.\n//       */\n//      init = s.window_size - curr;\n//      if (init > WIN_INIT)\n//        init = WIN_INIT;\n//      zmemzero(s->window + curr, (unsigned)init);\n//      s->high_water = curr + init;\n//    }\n//    else if (s->high_water < (ulg)curr + WIN_INIT) {\n//      /* High water mark at or above current data, but below current data\n//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n//       * to end of window, whichever is less.\n//       */\n//      init = (ulg)curr + WIN_INIT - s->high_water;\n//      if (init > s->window_size - s->high_water)\n//        init = s->window_size - s->high_water;\n//      zmemzero(s->window + s->high_water, (unsigned)init);\n//      s->high_water += init;\n//    }\n//  }\n//\n//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n//    "not enough room for search");\n}\n\n/* ===========================================================================\n * Copy without compression as much as possible from the input stream, return\n * the current block state.\n * This function does not insert new strings in the dictionary since\n * uncompressible data is probably not useful. This function is used\n * only for the level=0 compression option.\n * NOTE: this function should be optimized to avoid extra copying from\n * window to pending_buf.\n */\nfunction deflate_stored(s, flush) {\n  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited\n   * to pending_buf_size, and each stored block has a 5 byte header:\n   */\n  var max_block_size = 0xffff;\n\n  if (max_block_size > s.pending_buf_size - 5) {\n    max_block_size = s.pending_buf_size - 5;\n  }\n\n  /* Copy as much as possible from input to output: */\n  for (;;) {\n    /* Fill the window as much as possible: */\n    if (s.lookahead <= 1) {\n\n      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||\n      //  s->block_start >= (long)s->w_size, "slide too late");\n//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||\n//        s.block_start >= s.w_size)) {\n//        throw  new Error("slide too late");\n//      }\n\n      fill_window(s);\n      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n\n      if (s.lookahead === 0) {\n        break;\n      }\n      /* flush the current block */\n    }\n    //Assert(s->block_start >= 0L, "block gone");\n//    if (s.block_start < 0) throw new Error("block gone");\n\n    s.strstart += s.lookahead;\n    s.lookahead = 0;\n\n    /* Emit a stored block if pending_buf will be full: */\n    var max_start = s.block_start + max_block_size;\n\n    if (s.strstart === 0 || s.strstart >= max_start) {\n      /* strstart == 0 is possible when wraparound on 16-bit machine */\n      s.lookahead = s.strstart - max_start;\n      s.strstart = max_start;\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n\n\n    }\n    /* Flush if we may have to slide, otherwise block_start may become\n     * negative and the data will be gone:\n     */\n    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n\n  s.insert = 0;\n\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n\n  if (s.strstart > s.block_start) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_NEED_MORE;\n}\n\n/* ===========================================================================\n * Compress as much as possible from the input stream, return the current\n * block state.\n * This function does not perform lazy evaluation of matches and inserts\n * new strings in the dictionary only for unmatched strings or for short\n * matches. It is used only for the fast compression options.\n */\nfunction deflate_fast(s, flush) {\n  var hash_head;        /* head of the hash chain */\n  var bflush;           /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) {\n        break; /* flush the current block */\n      }\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     * At this point we have always match_length < MIN_MATCH\n     */\n    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n    }\n    if (s.match_length >= MIN_MATCH) {\n      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n\n      /*** _tr_tally_dist(s, s.strstart - s.match_start,\n                     s.match_length - MIN_MATCH, bflush); ***/\n      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n\n      /* Insert new strings in the hash table only if the match length\n       * is not too large. This saves time but degrades compression.\n       */\n      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {\n        s.match_length--; /* string at strstart already in table */\n        do {\n          s.strstart++;\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n          /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n           * always MIN_MATCH bytes ahead.\n           */\n        } while (--s.match_length !== 0);\n        s.strstart++;\n      } else\n      {\n        s.strstart += s.match_length;\n        s.match_length = 0;\n        s.ins_h = s.window[s.strstart];\n        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;\n\n//#if MIN_MATCH != 3\n//                Call UPDATE_HASH() MIN_MATCH-3 more times\n//#endif\n        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n         * matter since it will be recomputed at next deflate call.\n         */\n      }\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,"%c", s.window[s.strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* ===========================================================================\n * Same as above, but achieves better compression. We use a lazy\n * evaluation for matches: a match is finally adopted only if there is\n * no better match at the next window position.\n */\nfunction deflate_slow(s, flush) {\n  var hash_head;          /* head of hash chain */\n  var bflush;              /* set if current block must be flushed */\n\n  var max_insert;\n\n  /* Process the input block. */\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     */\n    s.prev_length = s.match_length;\n    s.prev_match = s.match_start;\n    s.match_length = MIN_MATCH - 1;\n\n    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&\n        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n\n      if (s.match_length <= 5 &&\n         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {\n\n        /* If prev_match is also MIN_MATCH, match_start is garbage\n         * but we will ignore the current match anyway.\n         */\n        s.match_length = MIN_MATCH - 1;\n      }\n    }\n    /* If there was a match at the previous step and the current\n     * match is not better, output the previous match:\n     */\n    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n      max_insert = s.strstart + s.lookahead - MIN_MATCH;\n      /* Do not insert strings in hash table beyond this. */\n\n      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n\n      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n                     s.prev_length - MIN_MATCH, bflush);***/\n      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\n      /* Insert in hash table all strings up to the end of the match.\n       * strstart-1 and strstart are already inserted. If there is not\n       * enough lookahead, the last two strings are not inserted in\n       * the hash table.\n       */\n      s.lookahead -= s.prev_length - 1;\n      s.prev_length -= 2;\n      do {\n        if (++s.strstart <= max_insert) {\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n        }\n      } while (--s.prev_length !== 0);\n      s.match_available = 0;\n      s.match_length = MIN_MATCH - 1;\n      s.strstart++;\n\n      if (bflush) {\n        /*** FLUSH_BLOCK(s, 0); ***/\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n      }\n\n    } else if (s.match_available) {\n      /* If there was no match at the previous position, output a\n       * single literal. If there was a match but the current match\n       * is longer, truncate the previous match to a single literal.\n       */\n      //Tracevv((stderr,"%c", s->window[s->strstart-1]));\n      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\n      if (bflush) {\n        /*** FLUSH_BLOCK_ONLY(s, 0) ***/\n        flush_block_only(s, false);\n        /***/\n      }\n      s.strstart++;\n      s.lookahead--;\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n    } else {\n      /* There is no previous match to compare with, wait for\n       * the next step to decide.\n       */\n      s.match_available = 1;\n      s.strstart++;\n      s.lookahead--;\n    }\n  }\n  //Assert (flush != Z_NO_FLUSH, "no flush?");\n  if (s.match_available) {\n    //Tracevv((stderr,"%c", s->window[s->strstart-1]));\n    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\n    s.match_available = 0;\n  }\n  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_BLOCK_DONE;\n}\n\n\n/* ===========================================================================\n * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n * deflate switches away from Z_RLE.)\n */\nfunction deflate_rle(s, flush) {\n  var bflush;            /* set if current block must be flushed */\n  var prev;              /* byte at distance one to match */\n  var scan, strend;      /* scan goes up to strend for length of run */\n\n  var _win = s.window;\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the longest run, plus one for the unrolled loop.\n     */\n    if (s.lookahead <= MAX_MATCH) {\n      fill_window(s);\n      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* See how many times the previous byte repeats */\n    s.match_length = 0;\n    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n      scan = s.strstart - 1;\n      prev = _win[scan];\n      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n        strend = s.strstart + MAX_MATCH;\n        do {\n          /*jshint noempty:false*/\n        } while (prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 scan < strend);\n        s.match_length = MAX_MATCH - (strend - scan);\n        if (s.match_length > s.lookahead) {\n          s.match_length = s.lookahead;\n        }\n      }\n      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");\n    }\n\n    /* Emit match if have run of MIN_MATCH or longer, else emit literal */\n    if (s.match_length >= MIN_MATCH) {\n      //check_match(s, s.strstart, s.strstart - 1, s.match_length);\n\n      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/\n      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n      s.strstart += s.match_length;\n      s.match_length = 0;\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,"%c", s->window[s->strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* ===========================================================================\n * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n * (It will be regenerated if this run of deflate switches away from Huffman.)\n */\nfunction deflate_huff(s, flush) {\n  var bflush;             /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we have a literal to write. */\n    if (s.lookahead === 0) {\n      fill_window(s);\n      if (s.lookahead === 0) {\n        if (flush === Z_NO_FLUSH) {\n          return BS_NEED_MORE;\n        }\n        break;      /* flush the current block */\n      }\n    }\n\n    /* Output a literal byte */\n    s.match_length = 0;\n    //Tracevv((stderr,"%c", s->window[s->strstart]));\n    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n    s.lookahead--;\n    s.strstart++;\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\n * the desired pack level (0..9). The values given below have been tuned to\n * exclude worst case performance for pathological files. Better values may be\n * found for specific files.\n */\nfunction Config(good_length, max_lazy, nice_length, max_chain, func) {\n  this.good_length = good_length;\n  this.max_lazy = max_lazy;\n  this.nice_length = nice_length;\n  this.max_chain = max_chain;\n  this.func = func;\n}\n\nvar configuration_table;\n\nconfiguration_table = [\n  /*      good lazy nice chain */\n  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */\n  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */\n  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */\n  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */\n\n  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */\n  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */\n  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */\n  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */\n  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */\n  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */\n];\n\n\n/* ===========================================================================\n * Initialize the "longest match" routines for a new zlib stream\n */\nfunction lm_init(s) {\n  s.window_size = 2 * s.w_size;\n\n  /*** CLEAR_HASH(s); ***/\n  zero(s.head); // Fill with NIL (= 0);\n\n  /* Set the default configuration parameters:\n   */\n  s.max_lazy_match = configuration_table[s.level].max_lazy;\n  s.good_match = configuration_table[s.level].good_length;\n  s.nice_match = configuration_table[s.level].nice_length;\n  s.max_chain_length = configuration_table[s.level].max_chain;\n\n  s.strstart = 0;\n  s.block_start = 0;\n  s.lookahead = 0;\n  s.insert = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  s.ins_h = 0;\n}\n\n\nfunction DeflateState() {\n  this.strm = null;            /* pointer back to this zlib stream */\n  this.status = 0;            /* as the name implies */\n  this.pending_buf = null;      /* output still pending */\n  this.pending_buf_size = 0;  /* size of pending_buf */\n  this.pending_out = 0;       /* next pending byte to output to the stream */\n  this.pending = 0;           /* nb of bytes in the pending buffer */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.gzhead = null;         /* gzip header information to write */\n  this.gzindex = 0;           /* where in extra, name, or comment */\n  this.method = Z_DEFLATED; /* can only be DEFLATED */\n  this.last_flush = -1;   /* value of flush param for previous deflate call */\n\n  this.w_size = 0;  /* LZ77 window size (32K by default) */\n  this.w_bits = 0;  /* log2(w_size)  (8..16) */\n  this.w_mask = 0;  /* w_size - 1 */\n\n  this.window = null;\n  /* Sliding window. Input bytes are read into the second half of the window,\n   * and move to the first half later to keep a dictionary of at least wSize\n   * bytes. With this organization, matches are limited to a distance of\n   * wSize-MAX_MATCH bytes, but this ensures that IO is always\n   * performed with a length multiple of the block size.\n   */\n\n  this.window_size = 0;\n  /* Actual size of window: 2*wSize, except when the user input buffer\n   * is directly used as sliding window.\n   */\n\n  this.prev = null;\n  /* Link to older string with same hash index. To limit the size of this\n   * array to 64K, this link is maintained only for the last 32K strings.\n   * An index in this array is thus a window index modulo 32K.\n   */\n\n  this.head = null;   /* Heads of the hash chains or NIL. */\n\n  this.ins_h = 0;       /* hash index of string to be inserted */\n  this.hash_size = 0;   /* number of elements in hash table */\n  this.hash_bits = 0;   /* log2(hash_size) */\n  this.hash_mask = 0;   /* hash_size-1 */\n\n  this.hash_shift = 0;\n  /* Number of bits by which ins_h must be shifted at each input\n   * step. It must be such that after MIN_MATCH steps, the oldest\n   * byte no longer takes part in the hash key, that is:\n   *   hash_shift * MIN_MATCH >= hash_bits\n   */\n\n  this.block_start = 0;\n  /* Window position at the beginning of the current output block. Gets\n   * negative when the window is moved backwards.\n   */\n\n  this.match_length = 0;      /* length of best match */\n  this.prev_match = 0;        /* previous match */\n  this.match_available = 0;   /* set if previous match exists */\n  this.strstart = 0;          /* start of string to insert */\n  this.match_start = 0;       /* start of matching string */\n  this.lookahead = 0;         /* number of valid bytes ahead in window */\n\n  this.prev_length = 0;\n  /* Length of the best match at previous step. Matches not greater than this\n   * are discarded. This is used in the lazy match evaluation.\n   */\n\n  this.max_chain_length = 0;\n  /* To speed up deflation, hash chains are never searched beyond this\n   * length.  A higher limit improves compression ratio but degrades the\n   * speed.\n   */\n\n  this.max_lazy_match = 0;\n  /* Attempt to find a better match only when the current match is strictly\n   * smaller than this value. This mechanism is used only for compression\n   * levels >= 4.\n   */\n  // That\'s alias to max_lazy_match, don\'t use directly\n  //this.max_insert_length = 0;\n  /* Insert new strings in the hash table only if the match length is not\n   * greater than this length. This saves time but degrades compression.\n   * max_insert_length is used only for compression levels <= 3.\n   */\n\n  this.level = 0;     /* compression level (1..9) */\n  this.strategy = 0;  /* favor or force Huffman coding*/\n\n  this.good_match = 0;\n  /* Use a faster search when the previous match is longer than this */\n\n  this.nice_match = 0; /* Stop searching when current match exceeds this */\n\n              /* used by trees.c: */\n\n  /* Didn\'t use ct_data typedef below to suppress compiler warning */\n\n  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n\n  // Use flat array of DOUBLE size, with interleaved fata,\n  // because JS does not support effective\n  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);\n  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);\n  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);\n  zero(this.dyn_ltree);\n  zero(this.dyn_dtree);\n  zero(this.bl_tree);\n\n  this.l_desc   = null;         /* desc. for literal tree */\n  this.d_desc   = null;         /* desc. for distance tree */\n  this.bl_desc  = null;         /* desc. for bit length tree */\n\n  //ush bl_count[MAX_BITS+1];\n  this.bl_count = new utils.Buf16(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */\n  zero(this.heap);\n\n  this.heap_len = 0;               /* number of elements in the heap */\n  this.heap_max = 0;               /* element of largest frequency */\n  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n   * The same heap array is used to build all trees.\n   */\n\n  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];\n  zero(this.depth);\n  /* Depth of each subtree used as tie breaker for trees of equal frequency\n   */\n\n  this.l_buf = 0;          /* buffer index for literals or lengths */\n\n  this.lit_bufsize = 0;\n  /* Size of match buffer for literals/lengths.  There are 4 reasons for\n   * limiting lit_bufsize to 64K:\n   *   - frequencies can be kept in 16 bit counters\n   *   - if compression is not successful for the first block, all input\n   *     data is still in the window so we can still emit a stored block even\n   *     when input comes from standard input.  (This can also be done for\n   *     all blocks if lit_bufsize is not greater than 32K.)\n   *   - if compression is not successful for a file smaller than 64K, we can\n   *     even emit a stored file instead of a stored block (saving 5 bytes).\n   *     This is applicable only for zip (not gzip or zlib).\n   *   - creating new Huffman trees less frequently may not provide fast\n   *     adaptation to changes in the input data statistics. (Take for\n   *     example a binary file with poorly compressible code followed by\n   *     a highly compressible string table.) Smaller buffer sizes give\n   *     fast adaptation but have of course the overhead of transmitting\n   *     trees more frequently.\n   *   - I can\'t count above 4\n   */\n\n  this.last_lit = 0;      /* running index in l_buf */\n\n  this.d_buf = 0;\n  /* Buffer index for distances. To simplify the code, d_buf and l_buf have\n   * the same number of elements. To use different lengths, an extra flag\n   * array would be necessary.\n   */\n\n  this.opt_len = 0;       /* bit length of current block with optimal trees */\n  this.static_len = 0;    /* bit length of current block with static trees */\n  this.matches = 0;       /* number of string matches in current block */\n  this.insert = 0;        /* bytes at end of window left to insert */\n\n\n  this.bi_buf = 0;\n  /* Output buffer. bits are inserted starting at the bottom (least\n   * significant bits).\n   */\n  this.bi_valid = 0;\n  /* Number of valid bits in bi_buf.  All bits above the last valid bit\n   * are always zero.\n   */\n\n  // Used for window memory init. We safely ignore it for JS. That makes\n  // sense only for pointers and memory check tools.\n  //this.high_water = 0;\n  /* High water mark offset in window for initialized bytes -- bytes above\n   * this are set to zero in order to avoid memory check warnings when\n   * longest match routines access bytes past the input.  This is then\n   * updated to the new high water mark.\n   */\n}\n\n\nfunction deflateResetKeep(strm) {\n  var s;\n\n  if (!strm || !strm.state) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.total_in = strm.total_out = 0;\n  strm.data_type = Z_UNKNOWN;\n\n  s = strm.state;\n  s.pending = 0;\n  s.pending_out = 0;\n\n  if (s.wrap < 0) {\n    s.wrap = -s.wrap;\n    /* was made negative by deflate(..., Z_FINISH); */\n  }\n  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);\n  strm.adler = (s.wrap === 2) ?\n    0  // crc32(0, Z_NULL, 0)\n  :\n    1; // adler32(0, Z_NULL, 0)\n  s.last_flush = Z_NO_FLUSH;\n  trees._tr_init(s);\n  return Z_OK;\n}\n\n\nfunction deflateReset(strm) {\n  var ret = deflateResetKeep(strm);\n  if (ret === Z_OK) {\n    lm_init(strm.state);\n  }\n  return ret;\n}\n\n\nfunction deflateSetHeader(strm, head) {\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }\n  strm.state.gzhead = head;\n  return Z_OK;\n}\n\n\nfunction deflateInit2(strm, level, method, windowBits, memLevel, strategy) {\n  if (!strm) { // === Z_NULL\n    return Z_STREAM_ERROR;\n  }\n  var wrap = 1;\n\n  if (level === Z_DEFAULT_COMPRESSION) {\n    level = 6;\n  }\n\n  if (windowBits < 0) { /* suppress zlib wrapper */\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n\n  else if (windowBits > 15) {\n    wrap = 2;           /* write gzip wrapper instead */\n    windowBits -= 16;\n  }\n\n\n  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||\n    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||\n    strategy < 0 || strategy > Z_FIXED) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n\n  if (windowBits === 8) {\n    windowBits = 9;\n  }\n  /* until 256-byte window bug fixed */\n\n  var s = new DeflateState();\n\n  strm.state = s;\n  s.strm = strm;\n\n  s.wrap = wrap;\n  s.gzhead = null;\n  s.w_bits = windowBits;\n  s.w_size = 1 << s.w_bits;\n  s.w_mask = s.w_size - 1;\n\n  s.hash_bits = memLevel + 7;\n  s.hash_size = 1 << s.hash_bits;\n  s.hash_mask = s.hash_size - 1;\n  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n\n  s.window = new utils.Buf8(s.w_size * 2);\n  s.head = new utils.Buf16(s.hash_size);\n  s.prev = new utils.Buf16(s.w_size);\n\n  // Don\'t need mem init magic for JS.\n  //s.high_water = 0;  /* nothing written to s->window yet */\n\n  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */\n\n  s.pending_buf_size = s.lit_bufsize * 4;\n\n  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);\n  //s->pending_buf = (uchf *) overlay;\n  s.pending_buf = new utils.Buf8(s.pending_buf_size);\n\n  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\n  s.d_buf = 1 * s.lit_bufsize;\n\n  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\n  s.l_buf = (1 + 2) * s.lit_bufsize;\n\n  s.level = level;\n  s.strategy = strategy;\n  s.method = method;\n\n  return deflateReset(strm);\n}\n\nfunction deflateInit(strm, level) {\n  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n}\n\n\nfunction deflate(strm, flush) {\n  var old_flush, s;\n  var beg, val; // for gzip header write only\n\n  if (!strm || !strm.state ||\n    flush > Z_BLOCK || flush < 0) {\n    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\n  }\n\n  s = strm.state;\n\n  if (!strm.output ||\n      (!strm.input && strm.avail_in !== 0) ||\n      (s.status === FINISH_STATE && flush !== Z_FINISH)) {\n    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);\n  }\n\n  s.strm = strm; /* just in case */\n  old_flush = s.last_flush;\n  s.last_flush = flush;\n\n  /* Write the header */\n  if (s.status === INIT_STATE) {\n\n    if (s.wrap === 2) { // GZIP header\n      strm.adler = 0;  //crc32(0L, Z_NULL, 0);\n      put_byte(s, 31);\n      put_byte(s, 139);\n      put_byte(s, 8);\n      if (!s.gzhead) { // s->gzhead == Z_NULL\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, OS_CODE);\n        s.status = BUSY_STATE;\n      }\n      else {\n        put_byte(s, (s.gzhead.text ? 1 : 0) +\n                    (s.gzhead.hcrc ? 2 : 0) +\n                    (!s.gzhead.extra ? 0 : 4) +\n                    (!s.gzhead.name ? 0 : 8) +\n                    (!s.gzhead.comment ? 0 : 16)\n                );\n        put_byte(s, s.gzhead.time & 0xff);\n        put_byte(s, (s.gzhead.time >> 8) & 0xff);\n        put_byte(s, (s.gzhead.time >> 16) & 0xff);\n        put_byte(s, (s.gzhead.time >> 24) & 0xff);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, s.gzhead.os & 0xff);\n        if (s.gzhead.extra && s.gzhead.extra.length) {\n          put_byte(s, s.gzhead.extra.length & 0xff);\n          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);\n        }\n        if (s.gzhead.hcrc) {\n          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);\n        }\n        s.gzindex = 0;\n        s.status = EXTRA_STATE;\n      }\n    }\n    else // DEFLATE header\n    {\n      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;\n      var level_flags = -1;\n\n      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n        level_flags = 0;\n      } else if (s.level < 6) {\n        level_flags = 1;\n      } else if (s.level === 6) {\n        level_flags = 2;\n      } else {\n        level_flags = 3;\n      }\n      header |= (level_flags << 6);\n      if (s.strstart !== 0) { header |= PRESET_DICT; }\n      header += 31 - (header % 31);\n\n      s.status = BUSY_STATE;\n      putShortMSB(s, header);\n\n      /* Save the adler32 of the preset dictionary: */\n      if (s.strstart !== 0) {\n        putShortMSB(s, strm.adler >>> 16);\n        putShortMSB(s, strm.adler & 0xffff);\n      }\n      strm.adler = 1; // adler32(0L, Z_NULL, 0);\n    }\n  }\n\n//#ifdef GZIP\n  if (s.status === EXTRA_STATE) {\n    if (s.gzhead.extra/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n\n      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            break;\n          }\n        }\n        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);\n        s.gzindex++;\n      }\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (s.gzindex === s.gzhead.extra.length) {\n        s.gzindex = 0;\n        s.status = NAME_STATE;\n      }\n    }\n    else {\n      s.status = NAME_STATE;\n    }\n  }\n  if (s.status === NAME_STATE) {\n    if (s.gzhead.name/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.name.length) {\n          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.gzindex = 0;\n        s.status = COMMENT_STATE;\n      }\n    }\n    else {\n      s.status = COMMENT_STATE;\n    }\n  }\n  if (s.status === COMMENT_STATE) {\n    if (s.gzhead.comment/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.comment.length) {\n          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.status = HCRC_STATE;\n      }\n    }\n    else {\n      s.status = HCRC_STATE;\n    }\n  }\n  if (s.status === HCRC_STATE) {\n    if (s.gzhead.hcrc) {\n      if (s.pending + 2 > s.pending_buf_size) {\n        flush_pending(strm);\n      }\n      if (s.pending + 2 <= s.pending_buf_size) {\n        put_byte(s, strm.adler & 0xff);\n        put_byte(s, (strm.adler >> 8) & 0xff);\n        strm.adler = 0; //crc32(0L, Z_NULL, 0);\n        s.status = BUSY_STATE;\n      }\n    }\n    else {\n      s.status = BUSY_STATE;\n    }\n  }\n//#endif\n\n  /* Flush as much pending output as possible */\n  if (s.pending !== 0) {\n    flush_pending(strm);\n    if (strm.avail_out === 0) {\n      /* Since avail_out is 0, deflate will be called again with\n       * more output space, but possibly with both pending and\n       * avail_in equal to zero. There won\'t be anything to do,\n       * but this is not an error situation so make sure we\n       * return OK instead of BUF_ERROR at next call of deflate:\n       */\n      s.last_flush = -1;\n      return Z_OK;\n    }\n\n    /* Make sure there is something to do and avoid duplicate consecutive\n     * flushes. For repeated and useless calls with Z_FINISH, we keep\n     * returning Z_STREAM_END instead of Z_BUF_ERROR.\n     */\n  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&\n    flush !== Z_FINISH) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* User must not provide more input after the first FINISH: */\n  if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* Start a new block or continue the current one.\n   */\n  if (strm.avail_in !== 0 || s.lookahead !== 0 ||\n    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {\n    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :\n      (s.strategy === Z_RLE ? deflate_rle(s, flush) :\n        configuration_table[s.level].func(s, flush));\n\n    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n      s.status = FINISH_STATE;\n    }\n    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n      if (strm.avail_out === 0) {\n        s.last_flush = -1;\n        /* avoid BUF_ERROR next call, see above */\n      }\n      return Z_OK;\n      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n       * of deflate should use the same flush parameter to make sure\n       * that the flush is complete. So we don\'t have to output an\n       * empty block here, this will be done at next call. This also\n       * ensures that for a very small output buffer, we emit at most\n       * one empty block.\n       */\n    }\n    if (bstate === BS_BLOCK_DONE) {\n      if (flush === Z_PARTIAL_FLUSH) {\n        trees._tr_align(s);\n      }\n      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */\n\n        trees._tr_stored_block(s, 0, 0, false);\n        /* For a full flush, this empty block will be recognized\n         * as a special marker by inflate_sync().\n         */\n        if (flush === Z_FULL_FLUSH) {\n          /*** CLEAR_HASH(s); ***/             /* forget history */\n          zero(s.head); // Fill with NIL (= 0);\n\n          if (s.lookahead === 0) {\n            s.strstart = 0;\n            s.block_start = 0;\n            s.insert = 0;\n          }\n        }\n      }\n      flush_pending(strm);\n      if (strm.avail_out === 0) {\n        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */\n        return Z_OK;\n      }\n    }\n  }\n  //Assert(strm->avail_out > 0, "bug2");\n  //if (strm.avail_out <= 0) { throw new Error("bug2");}\n\n  if (flush !== Z_FINISH) { return Z_OK; }\n  if (s.wrap <= 0) { return Z_STREAM_END; }\n\n  /* Write the trailer */\n  if (s.wrap === 2) {\n    put_byte(s, strm.adler & 0xff);\n    put_byte(s, (strm.adler >> 8) & 0xff);\n    put_byte(s, (strm.adler >> 16) & 0xff);\n    put_byte(s, (strm.adler >> 24) & 0xff);\n    put_byte(s, strm.total_in & 0xff);\n    put_byte(s, (strm.total_in >> 8) & 0xff);\n    put_byte(s, (strm.total_in >> 16) & 0xff);\n    put_byte(s, (strm.total_in >> 24) & 0xff);\n  }\n  else\n  {\n    putShortMSB(s, strm.adler >>> 16);\n    putShortMSB(s, strm.adler & 0xffff);\n  }\n\n  flush_pending(strm);\n  /* If avail_out is zero, the application will call deflate again\n   * to flush the rest.\n   */\n  if (s.wrap > 0) { s.wrap = -s.wrap; }\n  /* write the trailer only once! */\n  return s.pending !== 0 ? Z_OK : Z_STREAM_END;\n}\n\nfunction deflateEnd(strm) {\n  var status;\n\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  status = strm.state.status;\n  if (status !== INIT_STATE &&\n    status !== EXTRA_STATE &&\n    status !== NAME_STATE &&\n    status !== COMMENT_STATE &&\n    status !== HCRC_STATE &&\n    status !== BUSY_STATE &&\n    status !== FINISH_STATE\n  ) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.state = null;\n\n  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;\n}\n\n\n/* =========================================================================\n * Initializes the compression dictionary from the given byte\n * sequence without producing any compressed output.\n */\nfunction deflateSetDictionary(strm, dictionary) {\n  var dictLength = dictionary.length;\n\n  var s;\n  var str, n;\n  var wrap;\n  var avail;\n  var next;\n  var input;\n  var tmpDict;\n\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  s = strm.state;\n  wrap = s.wrap;\n\n  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {\n    return Z_STREAM_ERROR;\n  }\n\n  /* when using zlib wrappers, compute Adler-32 for provided dictionary */\n  if (wrap === 1) {\n    /* adler32(strm->adler, dictionary, dictLength); */\n    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);\n  }\n\n  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */\n\n  /* if dictionary would fill window, just replace the history */\n  if (dictLength >= s.w_size) {\n    if (wrap === 0) {            /* already empty otherwise */\n      /*** CLEAR_HASH(s); ***/\n      zero(s.head); // Fill with NIL (= 0);\n      s.strstart = 0;\n      s.block_start = 0;\n      s.insert = 0;\n    }\n    /* use the tail */\n    // dictionary = dictionary.slice(dictLength - s.w_size);\n    tmpDict = new utils.Buf8(s.w_size);\n    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);\n    dictionary = tmpDict;\n    dictLength = s.w_size;\n  }\n  /* insert dictionary into window and hash */\n  avail = strm.avail_in;\n  next = strm.next_in;\n  input = strm.input;\n  strm.avail_in = dictLength;\n  strm.next_in = 0;\n  strm.input = dictionary;\n  fill_window(s);\n  while (s.lookahead >= MIN_MATCH) {\n    str = s.strstart;\n    n = s.lookahead - (MIN_MATCH - 1);\n    do {\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n\n      s.prev[str & s.w_mask] = s.head[s.ins_h];\n\n      s.head[s.ins_h] = str;\n      str++;\n    } while (--n);\n    s.strstart = str;\n    s.lookahead = MIN_MATCH - 1;\n    fill_window(s);\n  }\n  s.strstart += s.lookahead;\n  s.block_start = s.strstart;\n  s.insert = s.lookahead;\n  s.lookahead = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  strm.next_in = next;\n  strm.input = input;\n  strm.avail_in = avail;\n  s.wrap = wrap;\n  return Z_OK;\n}\n\n\nexports.deflateInit = deflateInit;\nexports.deflateInit2 = deflateInit2;\nexports.deflateReset = deflateReset;\nexports.deflateResetKeep = deflateResetKeep;\nexports.deflateSetHeader = deflateSetHeader;\nexports.deflate = deflate;\nexports.deflateEnd = deflateEnd;\nexports.deflateSetDictionary = deflateSetDictionary;\nexports.deflateInfo = \'pako deflate (from Nodeca project)\';\n\n/* Not implemented\nexports.deflateBound = deflateBound;\nexports.deflateCopy = deflateCopy;\nexports.deflateParams = deflateParams;\nexports.deflatePending = deflatePending;\nexports.deflatePrime = deflatePrime;\nexports.deflateTune = deflateTune;\n*/\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2pzemlwL34vcGFrby9saWIvemxpYi9kZWZsYXRlLmpzPzg2N2MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7OztBQUdBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLDBCQUEwQjs7QUFFMUIsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLHNCQUFzQixxQkFBcUIsY0FBYyxFQUFFOzs7QUFHL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsWUFBWTtBQUMvQixrQkFBa0IsVUFBVTs7QUFFNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4Qyx3QkFBd0I7QUFDeEIsWUFBWTtBQUNaLFVBQVU7QUFDViwrQkFBK0I7QUFDL0IsZ0NBQWdDO0FBQ2hDO0FBQ0E7O0FBRUEsc0JBQXNCOztBQUV0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsMEJBQTBCOztBQUUzRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBOztBQUVBLGFBQWE7O0FBRWI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQix5QkFBeUI7QUFDekIsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTA5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgICA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xudmFyIHRyZWVzICAgPSByZXF1aXJlKCcuL3RyZWVzJyk7XG52YXIgYWRsZXIzMiA9IHJlcXVpcmUoJy4vYWRsZXIzMicpO1xudmFyIGNyYzMyICAgPSByZXF1aXJlKCcuL2NyYzMyJyk7XG52YXIgbXNnICAgICA9IHJlcXVpcmUoJy4vbWVzc2FnZXMnKTtcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuLyogQWxsb3dlZCBmbHVzaCB2YWx1ZXM7IHNlZSBkZWZsYXRlKCkgYW5kIGluZmxhdGUoKSBiZWxvdyBmb3IgZGV0YWlscyAqL1xudmFyIFpfTk9fRkxVU0ggICAgICA9IDA7XG52YXIgWl9QQVJUSUFMX0ZMVVNIID0gMTtcbi8vdmFyIFpfU1lOQ19GTFVTSCAgICA9IDI7XG52YXIgWl9GVUxMX0ZMVVNIICAgID0gMztcbnZhciBaX0ZJTklTSCAgICAgICAgPSA0O1xudmFyIFpfQkxPQ0sgICAgICAgICA9IDU7XG4vL3ZhciBaX1RSRUVTICAgICAgICAgPSA2O1xuXG5cbi8qIFJldHVybiBjb2RlcyBmb3IgdGhlIGNvbXByZXNzaW9uL2RlY29tcHJlc3Npb24gZnVuY3Rpb25zLiBOZWdhdGl2ZSB2YWx1ZXNcbiAqIGFyZSBlcnJvcnMsIHBvc2l0aXZlIHZhbHVlcyBhcmUgdXNlZCBmb3Igc3BlY2lhbCBidXQgbm9ybWFsIGV2ZW50cy5cbiAqL1xudmFyIFpfT0sgICAgICAgICAgICA9IDA7XG52YXIgWl9TVFJFQU1fRU5EICAgID0gMTtcbi8vdmFyIFpfTkVFRF9ESUNUICAgICA9IDI7XG4vL3ZhciBaX0VSUk5PICAgICAgICAgPSAtMTtcbnZhciBaX1NUUkVBTV9FUlJPUiAgPSAtMjtcbnZhciBaX0RBVEFfRVJST1IgICAgPSAtMztcbi8vdmFyIFpfTUVNX0VSUk9SICAgICA9IC00O1xudmFyIFpfQlVGX0VSUk9SICAgICA9IC01O1xuLy92YXIgWl9WRVJTSU9OX0VSUk9SID0gLTY7XG5cblxuLyogY29tcHJlc3Npb24gbGV2ZWxzICovXG4vL3ZhciBaX05PX0NPTVBSRVNTSU9OICAgICAgPSAwO1xuLy92YXIgWl9CRVNUX1NQRUVEICAgICAgICAgID0gMTtcbi8vdmFyIFpfQkVTVF9DT01QUkVTU0lPTiAgICA9IDk7XG52YXIgWl9ERUZBVUxUX0NPTVBSRVNTSU9OID0gLTE7XG5cblxudmFyIFpfRklMVEVSRUQgICAgICAgICAgICA9IDE7XG52YXIgWl9IVUZGTUFOX09OTFkgICAgICAgID0gMjtcbnZhciBaX1JMRSAgICAgICAgICAgICAgICAgPSAzO1xudmFyIFpfRklYRUQgICAgICAgICAgICAgICA9IDQ7XG52YXIgWl9ERUZBVUxUX1NUUkFURUdZICAgID0gMDtcblxuLyogUG9zc2libGUgdmFsdWVzIG9mIHRoZSBkYXRhX3R5cGUgZmllbGQgKHRob3VnaCBzZWUgaW5mbGF0ZSgpKSAqL1xuLy92YXIgWl9CSU5BUlkgICAgICAgICAgICAgID0gMDtcbi8vdmFyIFpfVEVYVCAgICAgICAgICAgICAgICA9IDE7XG4vL3ZhciBaX0FTQ0lJICAgICAgICAgICAgICAgPSAxOyAvLyA9IFpfVEVYVFxudmFyIFpfVU5LTk9XTiAgICAgICAgICAgICA9IDI7XG5cblxuLyogVGhlIGRlZmxhdGUgY29tcHJlc3Npb24gbWV0aG9kICovXG52YXIgWl9ERUZMQVRFRCAgPSA4O1xuXG4vKj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbnZhciBNQVhfTUVNX0xFVkVMID0gOTtcbi8qIE1heGltdW0gdmFsdWUgZm9yIG1lbUxldmVsIGluIGRlZmxhdGVJbml0MiAqL1xudmFyIE1BWF9XQklUUyA9IDE1O1xuLyogMzJLIExaNzcgd2luZG93ICovXG52YXIgREVGX01FTV9MRVZFTCA9IDg7XG5cblxudmFyIExFTkdUSF9DT0RFUyAgPSAyOTtcbi8qIG51bWJlciBvZiBsZW5ndGggY29kZXMsIG5vdCBjb3VudGluZyB0aGUgc3BlY2lhbCBFTkRfQkxPQ0sgY29kZSAqL1xudmFyIExJVEVSQUxTICAgICAgPSAyNTY7XG4vKiBudW1iZXIgb2YgbGl0ZXJhbCBieXRlcyAwLi4yNTUgKi9cbnZhciBMX0NPREVTICAgICAgID0gTElURVJBTFMgKyAxICsgTEVOR1RIX0NPREVTO1xuLyogbnVtYmVyIG9mIExpdGVyYWwgb3IgTGVuZ3RoIGNvZGVzLCBpbmNsdWRpbmcgdGhlIEVORF9CTE9DSyBjb2RlICovXG52YXIgRF9DT0RFUyAgICAgICA9IDMwO1xuLyogbnVtYmVyIG9mIGRpc3RhbmNlIGNvZGVzICovXG52YXIgQkxfQ09ERVMgICAgICA9IDE5O1xuLyogbnVtYmVyIG9mIGNvZGVzIHVzZWQgdG8gdHJhbnNmZXIgdGhlIGJpdCBsZW5ndGhzICovXG52YXIgSEVBUF9TSVpFICAgICA9IDIgKiBMX0NPREVTICsgMTtcbi8qIG1heGltdW0gaGVhcCBzaXplICovXG52YXIgTUFYX0JJVFMgID0gMTU7XG4vKiBBbGwgY29kZXMgbXVzdCBub3QgZXhjZWVkIE1BWF9CSVRTIGJpdHMgKi9cblxudmFyIE1JTl9NQVRDSCA9IDM7XG52YXIgTUFYX01BVENIID0gMjU4O1xudmFyIE1JTl9MT09LQUhFQUQgPSAoTUFYX01BVENIICsgTUlOX01BVENIICsgMSk7XG5cbnZhciBQUkVTRVRfRElDVCA9IDB4MjA7XG5cbnZhciBJTklUX1NUQVRFID0gNDI7XG52YXIgRVhUUkFfU1RBVEUgPSA2OTtcbnZhciBOQU1FX1NUQVRFID0gNzM7XG52YXIgQ09NTUVOVF9TVEFURSA9IDkxO1xudmFyIEhDUkNfU1RBVEUgPSAxMDM7XG52YXIgQlVTWV9TVEFURSA9IDExMztcbnZhciBGSU5JU0hfU1RBVEUgPSA2NjY7XG5cbnZhciBCU19ORUVEX01PUkUgICAgICA9IDE7IC8qIGJsb2NrIG5vdCBjb21wbGV0ZWQsIG5lZWQgbW9yZSBpbnB1dCBvciBtb3JlIG91dHB1dCAqL1xudmFyIEJTX0JMT0NLX0RPTkUgICAgID0gMjsgLyogYmxvY2sgZmx1c2ggcGVyZm9ybWVkICovXG52YXIgQlNfRklOSVNIX1NUQVJURUQgPSAzOyAvKiBmaW5pc2ggc3RhcnRlZCwgbmVlZCBvbmx5IG1vcmUgb3V0cHV0IGF0IG5leHQgZGVmbGF0ZSAqL1xudmFyIEJTX0ZJTklTSF9ET05FICAgID0gNDsgLyogZmluaXNoIGRvbmUsIGFjY2VwdCBubyBtb3JlIGlucHV0IG9yIG91dHB1dCAqL1xuXG52YXIgT1NfQ09ERSA9IDB4MDM7IC8vIFVuaXggOikgLiBEb24ndCBkZXRlY3QsIHVzZSB0aGlzIGRlZmF1bHQuXG5cbmZ1bmN0aW9uIGVycihzdHJtLCBlcnJvckNvZGUpIHtcbiAgc3RybS5tc2cgPSBtc2dbZXJyb3JDb2RlXTtcbiAgcmV0dXJuIGVycm9yQ29kZTtcbn1cblxuZnVuY3Rpb24gcmFuayhmKSB7XG4gIHJldHVybiAoKGYpIDw8IDEpIC0gKChmKSA+IDQgPyA5IDogMCk7XG59XG5cbmZ1bmN0aW9uIHplcm8oYnVmKSB7IHZhciBsZW4gPSBidWYubGVuZ3RoOyB3aGlsZSAoLS1sZW4gPj0gMCkgeyBidWZbbGVuXSA9IDA7IH0gfVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZsdXNoIGFzIG11Y2ggcGVuZGluZyBvdXRwdXQgYXMgcG9zc2libGUuIEFsbCBkZWZsYXRlKCkgb3V0cHV0IGdvZXNcbiAqIHRocm91Z2ggdGhpcyBmdW5jdGlvbiBzbyBzb21lIGFwcGxpY2F0aW9ucyBtYXkgd2lzaCB0byBtb2RpZnkgaXRcbiAqIHRvIGF2b2lkIGFsbG9jYXRpbmcgYSBsYXJnZSBzdHJtLT5vdXRwdXQgYnVmZmVyIGFuZCBjb3B5aW5nIGludG8gaXQuXG4gKiAoU2VlIGFsc28gcmVhZF9idWYoKSkuXG4gKi9cbmZ1bmN0aW9uIGZsdXNoX3BlbmRpbmcoc3RybSkge1xuICB2YXIgcyA9IHN0cm0uc3RhdGU7XG5cbiAgLy9fdHJfZmx1c2hfYml0cyhzKTtcbiAgdmFyIGxlbiA9IHMucGVuZGluZztcbiAgaWYgKGxlbiA+IHN0cm0uYXZhaWxfb3V0KSB7XG4gICAgbGVuID0gc3RybS5hdmFpbF9vdXQ7XG4gIH1cbiAgaWYgKGxlbiA9PT0gMCkgeyByZXR1cm47IH1cblxuICB1dGlscy5hcnJheVNldChzdHJtLm91dHB1dCwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nX291dCwgbGVuLCBzdHJtLm5leHRfb3V0KTtcbiAgc3RybS5uZXh0X291dCArPSBsZW47XG4gIHMucGVuZGluZ19vdXQgKz0gbGVuO1xuICBzdHJtLnRvdGFsX291dCArPSBsZW47XG4gIHN0cm0uYXZhaWxfb3V0IC09IGxlbjtcbiAgcy5wZW5kaW5nIC09IGxlbjtcbiAgaWYgKHMucGVuZGluZyA9PT0gMCkge1xuICAgIHMucGVuZGluZ19vdXQgPSAwO1xuICB9XG59XG5cblxuZnVuY3Rpb24gZmx1c2hfYmxvY2tfb25seShzLCBsYXN0KSB7XG4gIHRyZWVzLl90cl9mbHVzaF9ibG9jayhzLCAocy5ibG9ja19zdGFydCA+PSAwID8gcy5ibG9ja19zdGFydCA6IC0xKSwgcy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQsIGxhc3QpO1xuICBzLmJsb2NrX3N0YXJ0ID0gcy5zdHJzdGFydDtcbiAgZmx1c2hfcGVuZGluZyhzLnN0cm0pO1xufVxuXG5cbmZ1bmN0aW9uIHB1dF9ieXRlKHMsIGIpIHtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBiO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFB1dCBhIHNob3J0IGluIHRoZSBwZW5kaW5nIGJ1ZmZlci4gVGhlIDE2LWJpdCB2YWx1ZSBpcyBwdXQgaW4gTVNCIG9yZGVyLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgc3RyZWFtIHN0YXRlIGlzIGNvcnJlY3QgYW5kIHRoZXJlIGlzIGVub3VnaCByb29tIGluXG4gKiBwZW5kaW5nX2J1Zi5cbiAqL1xuZnVuY3Rpb24gcHV0U2hvcnRNU0IocywgYikge1xuLy8gIHB1dF9ieXRlKHMsIChCeXRlKShiID4+IDgpKTtcbi8vICBwdXRfYnl0ZShzLCAoQnl0ZSkoYiAmIDB4ZmYpKTtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSAoYiA+Pj4gOCkgJiAweGZmO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IGIgJiAweGZmO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUmVhZCBhIG5ldyBidWZmZXIgZnJvbSB0aGUgY3VycmVudCBpbnB1dCBzdHJlYW0sIHVwZGF0ZSB0aGUgYWRsZXIzMlxuICogYW5kIHRvdGFsIG51bWJlciBvZiBieXRlcyByZWFkLiAgQWxsIGRlZmxhdGUoKSBpbnB1dCBnb2VzIHRocm91Z2hcbiAqIHRoaXMgZnVuY3Rpb24gc28gc29tZSBhcHBsaWNhdGlvbnMgbWF5IHdpc2ggdG8gbW9kaWZ5IGl0IHRvIGF2b2lkXG4gKiBhbGxvY2F0aW5nIGEgbGFyZ2Ugc3RybS0+aW5wdXQgYnVmZmVyIGFuZCBjb3B5aW5nIGZyb20gaXQuXG4gKiAoU2VlIGFsc28gZmx1c2hfcGVuZGluZygpKS5cbiAqL1xuZnVuY3Rpb24gcmVhZF9idWYoc3RybSwgYnVmLCBzdGFydCwgc2l6ZSkge1xuICB2YXIgbGVuID0gc3RybS5hdmFpbF9pbjtcblxuICBpZiAobGVuID4gc2l6ZSkgeyBsZW4gPSBzaXplOyB9XG4gIGlmIChsZW4gPT09IDApIHsgcmV0dXJuIDA7IH1cblxuICBzdHJtLmF2YWlsX2luIC09IGxlbjtcblxuICAvLyB6bWVtY3B5KGJ1Ziwgc3RybS0+bmV4dF9pbiwgbGVuKTtcbiAgdXRpbHMuYXJyYXlTZXQoYnVmLCBzdHJtLmlucHV0LCBzdHJtLm5leHRfaW4sIGxlbiwgc3RhcnQpO1xuICBpZiAoc3RybS5zdGF0ZS53cmFwID09PSAxKSB7XG4gICAgc3RybS5hZGxlciA9IGFkbGVyMzIoc3RybS5hZGxlciwgYnVmLCBsZW4sIHN0YXJ0KTtcbiAgfVxuXG4gIGVsc2UgaWYgKHN0cm0uc3RhdGUud3JhcCA9PT0gMikge1xuICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBidWYsIGxlbiwgc3RhcnQpO1xuICB9XG5cbiAgc3RybS5uZXh0X2luICs9IGxlbjtcbiAgc3RybS50b3RhbF9pbiArPSBsZW47XG5cbiAgcmV0dXJuIGxlbjtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNldCBtYXRjaF9zdGFydCB0byB0aGUgbG9uZ2VzdCBtYXRjaCBzdGFydGluZyBhdCB0aGUgZ2l2ZW4gc3RyaW5nIGFuZFxuICogcmV0dXJuIGl0cyBsZW5ndGguIE1hdGNoZXMgc2hvcnRlciBvciBlcXVhbCB0byBwcmV2X2xlbmd0aCBhcmUgZGlzY2FyZGVkLFxuICogaW4gd2hpY2ggY2FzZSB0aGUgcmVzdWx0IGlzIGVxdWFsIHRvIHByZXZfbGVuZ3RoIGFuZCBtYXRjaF9zdGFydCBpc1xuICogZ2FyYmFnZS5cbiAqIElOIGFzc2VydGlvbnM6IGN1cl9tYXRjaCBpcyB0aGUgaGVhZCBvZiB0aGUgaGFzaCBjaGFpbiBmb3IgdGhlIGN1cnJlbnRcbiAqICAgc3RyaW5nIChzdHJzdGFydCkgYW5kIGl0cyBkaXN0YW5jZSBpcyA8PSBNQVhfRElTVCwgYW5kIHByZXZfbGVuZ3RoID49IDFcbiAqIE9VVCBhc3NlcnRpb246IHRoZSBtYXRjaCBsZW5ndGggaXMgbm90IGdyZWF0ZXIgdGhhbiBzLT5sb29rYWhlYWQuXG4gKi9cbmZ1bmN0aW9uIGxvbmdlc3RfbWF0Y2gocywgY3VyX21hdGNoKSB7XG4gIHZhciBjaGFpbl9sZW5ndGggPSBzLm1heF9jaGFpbl9sZW5ndGg7ICAgICAgLyogbWF4IGhhc2ggY2hhaW4gbGVuZ3RoICovXG4gIHZhciBzY2FuID0gcy5zdHJzdGFydDsgLyogY3VycmVudCBzdHJpbmcgKi9cbiAgdmFyIG1hdGNoOyAgICAgICAgICAgICAgICAgICAgICAgLyogbWF0Y2hlZCBzdHJpbmcgKi9cbiAgdmFyIGxlbjsgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBsZW5ndGggb2YgY3VycmVudCBtYXRjaCAqL1xuICB2YXIgYmVzdF9sZW4gPSBzLnByZXZfbGVuZ3RoOyAgICAgICAgICAgICAgLyogYmVzdCBtYXRjaCBsZW5ndGggc28gZmFyICovXG4gIHZhciBuaWNlX21hdGNoID0gcy5uaWNlX21hdGNoOyAgICAgICAgICAgICAvKiBzdG9wIGlmIG1hdGNoIGxvbmcgZW5vdWdoICovXG4gIHZhciBsaW1pdCA9IChzLnN0cnN0YXJ0ID4gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkpID9cbiAgICAgIHMuc3Ryc3RhcnQgLSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSA6IDAvKk5JTCovO1xuXG4gIHZhciBfd2luID0gcy53aW5kb3c7IC8vIHNob3J0Y3V0XG5cbiAgdmFyIHdtYXNrID0gcy53X21hc2s7XG4gIHZhciBwcmV2ICA9IHMucHJldjtcblxuICAvKiBTdG9wIHdoZW4gY3VyX21hdGNoIGJlY29tZXMgPD0gbGltaXQuIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLFxuICAgKiB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nIG9mIHdpbmRvdyBpbmRleCAwLlxuICAgKi9cblxuICB2YXIgc3RyZW5kID0gcy5zdHJzdGFydCArIE1BWF9NQVRDSDtcbiAgdmFyIHNjYW5fZW5kMSAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbiAtIDFdO1xuICB2YXIgc2Nhbl9lbmQgICA9IF93aW5bc2NhbiArIGJlc3RfbGVuXTtcblxuICAvKiBUaGUgY29kZSBpcyBvcHRpbWl6ZWQgZm9yIEhBU0hfQklUUyA+PSA4IGFuZCBNQVhfTUFUQ0gtMiBtdWx0aXBsZSBvZiAxNi5cbiAgICogSXQgaXMgZWFzeSB0byBnZXQgcmlkIG9mIHRoaXMgb3B0aW1pemF0aW9uIGlmIG5lY2Vzc2FyeS5cbiAgICovXG4gIC8vIEFzc2VydChzLT5oYXNoX2JpdHMgPj0gOCAmJiBNQVhfTUFUQ0ggPT0gMjU4LCBcIkNvZGUgdG9vIGNsZXZlclwiKTtcblxuICAvKiBEbyBub3Qgd2FzdGUgdG9vIG11Y2ggdGltZSBpZiB3ZSBhbHJlYWR5IGhhdmUgYSBnb29kIG1hdGNoOiAqL1xuICBpZiAocy5wcmV2X2xlbmd0aCA+PSBzLmdvb2RfbWF0Y2gpIHtcbiAgICBjaGFpbl9sZW5ndGggPj49IDI7XG4gIH1cbiAgLyogRG8gbm90IGxvb2sgZm9yIG1hdGNoZXMgYmV5b25kIHRoZSBlbmQgb2YgdGhlIGlucHV0LiBUaGlzIGlzIG5lY2Vzc2FyeVxuICAgKiB0byBtYWtlIGRlZmxhdGUgZGV0ZXJtaW5pc3RpYy5cbiAgICovXG4gIGlmIChuaWNlX21hdGNoID4gcy5sb29rYWhlYWQpIHsgbmljZV9tYXRjaCA9IHMubG9va2FoZWFkOyB9XG5cbiAgLy8gQXNzZXJ0KCh1bGcpcy0+c3Ryc3RhcnQgPD0gcy0+d2luZG93X3NpemUtTUlOX0xPT0tBSEVBRCwgXCJuZWVkIGxvb2thaGVhZFwiKTtcblxuICBkbyB7XG4gICAgLy8gQXNzZXJ0KGN1cl9tYXRjaCA8IHMtPnN0cnN0YXJ0LCBcIm5vIGZ1dHVyZVwiKTtcbiAgICBtYXRjaCA9IGN1cl9tYXRjaDtcblxuICAgIC8qIFNraXAgdG8gbmV4dCBtYXRjaCBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGNhbm5vdCBpbmNyZWFzZVxuICAgICAqIG9yIGlmIHRoZSBtYXRjaCBsZW5ndGggaXMgbGVzcyB0aGFuIDIuICBOb3RlIHRoYXQgdGhlIGNoZWNrcyBiZWxvd1xuICAgICAqIGZvciBpbnN1ZmZpY2llbnQgbG9va2FoZWFkIG9ubHkgb2NjdXIgb2NjYXNpb25hbGx5IGZvciBwZXJmb3JtYW5jZVxuICAgICAqIHJlYXNvbnMuICBUaGVyZWZvcmUgdW5pbml0aWFsaXplZCBtZW1vcnkgd2lsbCBiZSBhY2Nlc3NlZCwgYW5kXG4gICAgICogY29uZGl0aW9uYWwganVtcHMgd2lsbCBiZSBtYWRlIHRoYXQgZGVwZW5kIG9uIHRob3NlIHZhbHVlcy5cbiAgICAgKiBIb3dldmVyIHRoZSBsZW5ndGggb2YgdGhlIG1hdGNoIGlzIGxpbWl0ZWQgdG8gdGhlIGxvb2thaGVhZCwgc29cbiAgICAgKiB0aGUgb3V0cHV0IG9mIGRlZmxhdGUgaXMgbm90IGFmZmVjdGVkIGJ5IHRoZSB1bmluaXRpYWxpemVkIHZhbHVlcy5cbiAgICAgKi9cblxuICAgIGlmIChfd2luW21hdGNoICsgYmVzdF9sZW5dICAgICAhPT0gc2Nhbl9lbmQgIHx8XG4gICAgICAgIF93aW5bbWF0Y2ggKyBiZXN0X2xlbiAtIDFdICE9PSBzY2FuX2VuZDEgfHxcbiAgICAgICAgX3dpblttYXRjaF0gICAgICAgICAgICAgICAgIT09IF93aW5bc2Nhbl0gfHxcbiAgICAgICAgX3dpblsrK21hdGNoXSAgICAgICAgICAgICAgIT09IF93aW5bc2NhbiArIDFdKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvKiBUaGUgY2hlY2sgYXQgYmVzdF9sZW4tMSBjYW4gYmUgcmVtb3ZlZCBiZWNhdXNlIGl0IHdpbGwgYmUgbWFkZVxuICAgICAqIGFnYWluIGxhdGVyLiAoVGhpcyBoZXVyaXN0aWMgaXMgbm90IGFsd2F5cyBhIHdpbi4pXG4gICAgICogSXQgaXMgbm90IG5lY2Vzc2FyeSB0byBjb21wYXJlIHNjYW5bMl0gYW5kIG1hdGNoWzJdIHNpbmNlIHRoZXlcbiAgICAgKiBhcmUgYWx3YXlzIGVxdWFsIHdoZW4gdGhlIG90aGVyIGJ5dGVzIG1hdGNoLCBnaXZlbiB0aGF0XG4gICAgICogdGhlIGhhc2gga2V5cyBhcmUgZXF1YWwgYW5kIHRoYXQgSEFTSF9CSVRTID49IDguXG4gICAgICovXG4gICAgc2NhbiArPSAyO1xuICAgIG1hdGNoKys7XG4gICAgLy8gQXNzZXJ0KCpzY2FuID09ICptYXRjaCwgXCJtYXRjaFsyXT9cIik7XG5cbiAgICAvKiBXZSBjaGVjayBmb3IgaW5zdWZmaWNpZW50IGxvb2thaGVhZCBvbmx5IGV2ZXJ5IDh0aCBjb21wYXJpc29uO1xuICAgICAqIHRoZSAyNTZ0aCBjaGVjayB3aWxsIGJlIG1hZGUgYXQgc3Ryc3RhcnQrMjU4LlxuICAgICAqL1xuICAgIGRvIHtcbiAgICAgIC8qanNoaW50IG5vZW1wdHk6ZmFsc2UqL1xuICAgIH0gd2hpbGUgKF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBzY2FuIDwgc3RyZW5kKTtcblxuICAgIC8vIEFzc2VydChzY2FuIDw9IHMtPndpbmRvdysodW5zaWduZWQpKHMtPndpbmRvd19zaXplLTEpLCBcIndpbGQgc2NhblwiKTtcblxuICAgIGxlbiA9IE1BWF9NQVRDSCAtIChzdHJlbmQgLSBzY2FuKTtcbiAgICBzY2FuID0gc3RyZW5kIC0gTUFYX01BVENIO1xuXG4gICAgaWYgKGxlbiA+IGJlc3RfbGVuKSB7XG4gICAgICBzLm1hdGNoX3N0YXJ0ID0gY3VyX21hdGNoO1xuICAgICAgYmVzdF9sZW4gPSBsZW47XG4gICAgICBpZiAobGVuID49IG5pY2VfbWF0Y2gpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzY2FuX2VuZDEgID0gX3dpbltzY2FuICsgYmVzdF9sZW4gLSAxXTtcbiAgICAgIHNjYW5fZW5kICAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbl07XG4gICAgfVxuICB9IHdoaWxlICgoY3VyX21hdGNoID0gcHJldltjdXJfbWF0Y2ggJiB3bWFza10pID4gbGltaXQgJiYgLS1jaGFpbl9sZW5ndGggIT09IDApO1xuXG4gIGlmIChiZXN0X2xlbiA8PSBzLmxvb2thaGVhZCkge1xuICAgIHJldHVybiBiZXN0X2xlbjtcbiAgfVxuICByZXR1cm4gcy5sb29rYWhlYWQ7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGaWxsIHRoZSB3aW5kb3cgd2hlbiB0aGUgbG9va2FoZWFkIGJlY29tZXMgaW5zdWZmaWNpZW50LlxuICogVXBkYXRlcyBzdHJzdGFydCBhbmQgbG9va2FoZWFkLlxuICpcbiAqIElOIGFzc2VydGlvbjogbG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRFxuICogT1VUIGFzc2VydGlvbnM6IHN0cnN0YXJ0IDw9IHdpbmRvd19zaXplLU1JTl9MT09LQUhFQURcbiAqICAgIEF0IGxlYXN0IG9uZSBieXRlIGhhcyBiZWVuIHJlYWQsIG9yIGF2YWlsX2luID09IDA7IHJlYWRzIGFyZVxuICogICAgcGVyZm9ybWVkIGZvciBhdCBsZWFzdCB0d28gYnl0ZXMgKHJlcXVpcmVkIGZvciB0aGUgemlwIHRyYW5zbGF0ZV9lb2xcbiAqICAgIG9wdGlvbiAtLSBub3Qgc3VwcG9ydGVkIGhlcmUpLlxuICovXG5mdW5jdGlvbiBmaWxsX3dpbmRvdyhzKSB7XG4gIHZhciBfd19zaXplID0gcy53X3NpemU7XG4gIHZhciBwLCBuLCBtLCBtb3JlLCBzdHI7XG5cbiAgLy9Bc3NlcnQocy0+bG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCwgXCJhbHJlYWR5IGVub3VnaCBsb29rYWhlYWRcIik7XG5cbiAgZG8ge1xuICAgIG1vcmUgPSBzLndpbmRvd19zaXplIC0gcy5sb29rYWhlYWQgLSBzLnN0cnN0YXJ0O1xuXG4gICAgLy8gSlMgaW50cyBoYXZlIDMyIGJpdCwgYmxvY2sgYmVsb3cgbm90IG5lZWRlZFxuICAgIC8qIERlYWwgd2l0aCAhQCMkJSA2NEsgbGltaXQ6ICovXG4gICAgLy9pZiAoc2l6ZW9mKGludCkgPD0gMikge1xuICAgIC8vICAgIGlmIChtb3JlID09IDAgJiYgcy0+c3Ryc3RhcnQgPT0gMCAmJiBzLT5sb29rYWhlYWQgPT0gMCkge1xuICAgIC8vICAgICAgICBtb3JlID0gd3NpemU7XG4gICAgLy9cbiAgICAvLyAgfSBlbHNlIGlmIChtb3JlID09ICh1bnNpZ25lZCkoLTEpKSB7XG4gICAgLy8gICAgICAgIC8qIFZlcnkgdW5saWtlbHksIGJ1dCBwb3NzaWJsZSBvbiAxNiBiaXQgbWFjaGluZSBpZlxuICAgIC8vICAgICAgICAgKiBzdHJzdGFydCA9PSAwICYmIGxvb2thaGVhZCA9PSAxIChpbnB1dCBkb25lIGEgYnl0ZSBhdCB0aW1lKVxuICAgIC8vICAgICAgICAgKi9cbiAgICAvLyAgICAgICAgbW9yZS0tO1xuICAgIC8vICAgIH1cbiAgICAvL31cblxuXG4gICAgLyogSWYgdGhlIHdpbmRvdyBpcyBhbG1vc3QgZnVsbCBhbmQgdGhlcmUgaXMgaW5zdWZmaWNpZW50IGxvb2thaGVhZCxcbiAgICAgKiBtb3ZlIHRoZSB1cHBlciBoYWxmIHRvIHRoZSBsb3dlciBvbmUgdG8gbWFrZSByb29tIGluIHRoZSB1cHBlciBoYWxmLlxuICAgICAqL1xuICAgIGlmIChzLnN0cnN0YXJ0ID49IF93X3NpemUgKyAoX3dfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSB7XG5cbiAgICAgIHV0aWxzLmFycmF5U2V0KHMud2luZG93LCBzLndpbmRvdywgX3dfc2l6ZSwgX3dfc2l6ZSwgMCk7XG4gICAgICBzLm1hdGNoX3N0YXJ0IC09IF93X3NpemU7XG4gICAgICBzLnN0cnN0YXJ0IC09IF93X3NpemU7XG4gICAgICAvKiB3ZSBub3cgaGF2ZSBzdHJzdGFydCA+PSBNQVhfRElTVCAqL1xuICAgICAgcy5ibG9ja19zdGFydCAtPSBfd19zaXplO1xuXG4gICAgICAvKiBTbGlkZSB0aGUgaGFzaCB0YWJsZSAoY291bGQgYmUgYXZvaWRlZCB3aXRoIDMyIGJpdCB2YWx1ZXNcbiAgICAgICBhdCB0aGUgZXhwZW5zZSBvZiBtZW1vcnkgdXNhZ2UpLiBXZSBzbGlkZSBldmVuIHdoZW4gbGV2ZWwgPT0gMFxuICAgICAgIHRvIGtlZXAgdGhlIGhhc2ggdGFibGUgY29uc2lzdGVudCBpZiB3ZSBzd2l0Y2ggYmFjayB0byBsZXZlbCA+IDBcbiAgICAgICBsYXRlci4gKFVzaW5nIGxldmVsIDAgcGVybWFuZW50bHkgaXMgbm90IGFuIG9wdGltYWwgdXNhZ2Ugb2ZcbiAgICAgICB6bGliLCBzbyB3ZSBkb24ndCBjYXJlIGFib3V0IHRoaXMgcGF0aG9sb2dpY2FsIGNhc2UuKVxuICAgICAgICovXG5cbiAgICAgIG4gPSBzLmhhc2hfc2l6ZTtcbiAgICAgIHAgPSBuO1xuICAgICAgZG8ge1xuICAgICAgICBtID0gcy5oZWFkWy0tcF07XG4gICAgICAgIHMuaGVhZFtwXSA9IChtID49IF93X3NpemUgPyBtIC0gX3dfc2l6ZSA6IDApO1xuICAgICAgfSB3aGlsZSAoLS1uKTtcblxuICAgICAgbiA9IF93X3NpemU7XG4gICAgICBwID0gbjtcbiAgICAgIGRvIHtcbiAgICAgICAgbSA9IHMucHJldlstLXBdO1xuICAgICAgICBzLnByZXZbcF0gPSAobSA+PSBfd19zaXplID8gbSAtIF93X3NpemUgOiAwKTtcbiAgICAgICAgLyogSWYgbiBpcyBub3Qgb24gYW55IGhhc2ggY2hhaW4sIHByZXZbbl0gaXMgZ2FyYmFnZSBidXRcbiAgICAgICAgICogaXRzIHZhbHVlIHdpbGwgbmV2ZXIgYmUgdXNlZC5cbiAgICAgICAgICovXG4gICAgICB9IHdoaWxlICgtLW4pO1xuXG4gICAgICBtb3JlICs9IF93X3NpemU7XG4gICAgfVxuICAgIGlmIChzLnN0cm0uYXZhaWxfaW4gPT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8qIElmIHRoZXJlIHdhcyBubyBzbGlkaW5nOlxuICAgICAqICAgIHN0cnN0YXJ0IDw9IFdTSVpFK01BWF9ESVNULTEgJiYgbG9va2FoZWFkIDw9IE1JTl9MT09LQUhFQUQgLSAxICYmXG4gICAgICogICAgbW9yZSA9PSB3aW5kb3dfc2l6ZSAtIGxvb2thaGVhZCAtIHN0cnN0YXJ0XG4gICAgICogPT4gbW9yZSA+PSB3aW5kb3dfc2l6ZSAtIChNSU5fTE9PS0FIRUFELTEgKyBXU0laRSArIE1BWF9ESVNULTEpXG4gICAgICogPT4gbW9yZSA+PSB3aW5kb3dfc2l6ZSAtIDIqV1NJWkUgKyAyXG4gICAgICogSW4gdGhlIEJJR19NRU0gb3IgTU1BUCBjYXNlIChub3QgeWV0IHN1cHBvcnRlZCksXG4gICAgICogICB3aW5kb3dfc2l6ZSA9PSBpbnB1dF9zaXplICsgTUlOX0xPT0tBSEVBRCAgJiZcbiAgICAgKiAgIHN0cnN0YXJ0ICsgcy0+bG9va2FoZWFkIDw9IGlucHV0X3NpemUgPT4gbW9yZSA+PSBNSU5fTE9PS0FIRUFELlxuICAgICAqIE90aGVyd2lzZSwgd2luZG93X3NpemUgPT0gMipXU0laRSBzbyBtb3JlID49IDIuXG4gICAgICogSWYgdGhlcmUgd2FzIHNsaWRpbmcsIG1vcmUgPj0gV1NJWkUuIFNvIGluIGFsbCBjYXNlcywgbW9yZSA+PSAyLlxuICAgICAqL1xuICAgIC8vQXNzZXJ0KG1vcmUgPj0gMiwgXCJtb3JlIDwgMlwiKTtcbiAgICBuID0gcmVhZF9idWYocy5zdHJtLCBzLndpbmRvdywgcy5zdHJzdGFydCArIHMubG9va2FoZWFkLCBtb3JlKTtcbiAgICBzLmxvb2thaGVhZCArPSBuO1xuXG4gICAgLyogSW5pdGlhbGl6ZSB0aGUgaGFzaCB2YWx1ZSBub3cgdGhhdCB3ZSBoYXZlIHNvbWUgaW5wdXQ6ICovXG4gICAgaWYgKHMubG9va2FoZWFkICsgcy5pbnNlcnQgPj0gTUlOX01BVENIKSB7XG4gICAgICBzdHIgPSBzLnN0cnN0YXJ0IC0gcy5pbnNlcnQ7XG4gICAgICBzLmluc19oID0gcy53aW5kb3dbc3RyXTtcblxuICAgICAgLyogVVBEQVRFX0hBU0gocywgcy0+aW5zX2gsIHMtPndpbmRvd1tzdHIgKyAxXSk7ICovXG4gICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzdHIgKyAxXSkgJiBzLmhhc2hfbWFzaztcbi8vI2lmIE1JTl9NQVRDSCAhPSAzXG4vLyAgICAgICAgQ2FsbCB1cGRhdGVfaGFzaCgpIE1JTl9NQVRDSC0zIG1vcmUgdGltZXNcbi8vI2VuZGlmXG4gICAgICB3aGlsZSAocy5pbnNlcnQpIHtcbiAgICAgICAgLyogVVBEQVRFX0hBU0gocywgcy0+aW5zX2gsIHMtPndpbmRvd1tzdHIgKyBNSU5fTUFUQ0gtMV0pOyAqL1xuICAgICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzdHIgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcblxuICAgICAgICBzLnByZXZbc3RyICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzdHI7XG4gICAgICAgIHN0cisrO1xuICAgICAgICBzLmluc2VydC0tO1xuICAgICAgICBpZiAocy5sb29rYWhlYWQgKyBzLmluc2VydCA8IE1JTl9NQVRDSCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qIElmIHRoZSB3aG9sZSBpbnB1dCBoYXMgbGVzcyB0aGFuIE1JTl9NQVRDSCBieXRlcywgaW5zX2ggaXMgZ2FyYmFnZSxcbiAgICAgKiBidXQgdGhpcyBpcyBub3QgaW1wb3J0YW50IHNpbmNlIG9ubHkgbGl0ZXJhbCBieXRlcyB3aWxsIGJlIGVtaXR0ZWQuXG4gICAgICovXG5cbiAgfSB3aGlsZSAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIHMuc3RybS5hdmFpbF9pbiAhPT0gMCk7XG5cbiAgLyogSWYgdGhlIFdJTl9JTklUIGJ5dGVzIGFmdGVyIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgZGF0YSBoYXZlIG5ldmVyIGJlZW5cbiAgICogd3JpdHRlbiwgdGhlbiB6ZXJvIHRob3NlIGJ5dGVzIGluIG9yZGVyIHRvIGF2b2lkIG1lbW9yeSBjaGVjayByZXBvcnRzIG9mXG4gICAqIHRoZSB1c2Ugb2YgdW5pbml0aWFsaXplZCAob3IgdW5pbml0aWFsaXNlZCBhcyBKdWxpYW4gd3JpdGVzKSBieXRlcyBieVxuICAgKiB0aGUgbG9uZ2VzdCBtYXRjaCByb3V0aW5lcy4gIFVwZGF0ZSB0aGUgaGlnaCB3YXRlciBtYXJrIGZvciB0aGUgbmV4dFxuICAgKiB0aW1lIHRocm91Z2ggaGVyZS4gIFdJTl9JTklUIGlzIHNldCB0byBNQVhfTUFUQ0ggc2luY2UgdGhlIGxvbmdlc3QgbWF0Y2hcbiAgICogcm91dGluZXMgYWxsb3cgc2Nhbm5pbmcgdG8gc3Ryc3RhcnQgKyBNQVhfTUFUQ0gsIGlnbm9yaW5nIGxvb2thaGVhZC5cbiAgICovXG4vLyAgaWYgKHMuaGlnaF93YXRlciA8IHMud2luZG93X3NpemUpIHtcbi8vICAgIHZhciBjdXJyID0gcy5zdHJzdGFydCArIHMubG9va2FoZWFkO1xuLy8gICAgdmFyIGluaXQgPSAwO1xuLy9cbi8vICAgIGlmIChzLmhpZ2hfd2F0ZXIgPCBjdXJyKSB7XG4vLyAgICAgIC8qIFByZXZpb3VzIGhpZ2ggd2F0ZXIgbWFyayBiZWxvdyBjdXJyZW50IGRhdGEgLS0gemVybyBXSU5fSU5JVFxuLy8gICAgICAgKiBieXRlcyBvciB1cCB0byBlbmQgb2Ygd2luZG93LCB3aGljaGV2ZXIgaXMgbGVzcy5cbi8vICAgICAgICovXG4vLyAgICAgIGluaXQgPSBzLndpbmRvd19zaXplIC0gY3Vycjtcbi8vICAgICAgaWYgKGluaXQgPiBXSU5fSU5JVClcbi8vICAgICAgICBpbml0ID0gV0lOX0lOSVQ7XG4vLyAgICAgIHptZW16ZXJvKHMtPndpbmRvdyArIGN1cnIsICh1bnNpZ25lZClpbml0KTtcbi8vICAgICAgcy0+aGlnaF93YXRlciA9IGN1cnIgKyBpbml0O1xuLy8gICAgfVxuLy8gICAgZWxzZSBpZiAocy0+aGlnaF93YXRlciA8ICh1bGcpY3VyciArIFdJTl9JTklUKSB7XG4vLyAgICAgIC8qIEhpZ2ggd2F0ZXIgbWFyayBhdCBvciBhYm92ZSBjdXJyZW50IGRhdGEsIGJ1dCBiZWxvdyBjdXJyZW50IGRhdGFcbi8vICAgICAgICogcGx1cyBXSU5fSU5JVCAtLSB6ZXJvIG91dCB0byBjdXJyZW50IGRhdGEgcGx1cyBXSU5fSU5JVCwgb3IgdXBcbi8vICAgICAgICogdG8gZW5kIG9mIHdpbmRvdywgd2hpY2hldmVyIGlzIGxlc3MuXG4vLyAgICAgICAqL1xuLy8gICAgICBpbml0ID0gKHVsZyljdXJyICsgV0lOX0lOSVQgLSBzLT5oaWdoX3dhdGVyO1xuLy8gICAgICBpZiAoaW5pdCA+IHMtPndpbmRvd19zaXplIC0gcy0+aGlnaF93YXRlcilcbi8vICAgICAgICBpbml0ID0gcy0+d2luZG93X3NpemUgLSBzLT5oaWdoX3dhdGVyO1xuLy8gICAgICB6bWVtemVybyhzLT53aW5kb3cgKyBzLT5oaWdoX3dhdGVyLCAodW5zaWduZWQpaW5pdCk7XG4vLyAgICAgIHMtPmhpZ2hfd2F0ZXIgKz0gaW5pdDtcbi8vICAgIH1cbi8vICB9XG4vL1xuLy8gIEFzc2VydCgodWxnKXMtPnN0cnN0YXJ0IDw9IHMtPndpbmRvd19zaXplIC0gTUlOX0xPT0tBSEVBRCxcbi8vICAgIFwibm90IGVub3VnaCByb29tIGZvciBzZWFyY2hcIik7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weSB3aXRob3V0IGNvbXByZXNzaW9uIGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSB0aGUgaW5wdXQgc3RyZWFtLCByZXR1cm5cbiAqIHRoZSBjdXJyZW50IGJsb2NrIHN0YXRlLlxuICogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBpbnNlcnQgbmV3IHN0cmluZ3MgaW4gdGhlIGRpY3Rpb25hcnkgc2luY2VcbiAqIHVuY29tcHJlc3NpYmxlIGRhdGEgaXMgcHJvYmFibHkgbm90IHVzZWZ1bC4gVGhpcyBmdW5jdGlvbiBpcyB1c2VkXG4gKiBvbmx5IGZvciB0aGUgbGV2ZWw9MCBjb21wcmVzc2lvbiBvcHRpb24uXG4gKiBOT1RFOiB0aGlzIGZ1bmN0aW9uIHNob3VsZCBiZSBvcHRpbWl6ZWQgdG8gYXZvaWQgZXh0cmEgY29weWluZyBmcm9tXG4gKiB3aW5kb3cgdG8gcGVuZGluZ19idWYuXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfc3RvcmVkKHMsIGZsdXNoKSB7XG4gIC8qIFN0b3JlZCBibG9ja3MgYXJlIGxpbWl0ZWQgdG8gMHhmZmZmIGJ5dGVzLCBwZW5kaW5nX2J1ZiBpcyBsaW1pdGVkXG4gICAqIHRvIHBlbmRpbmdfYnVmX3NpemUsIGFuZCBlYWNoIHN0b3JlZCBibG9jayBoYXMgYSA1IGJ5dGUgaGVhZGVyOlxuICAgKi9cbiAgdmFyIG1heF9ibG9ja19zaXplID0gMHhmZmZmO1xuXG4gIGlmIChtYXhfYmxvY2tfc2l6ZSA+IHMucGVuZGluZ19idWZfc2l6ZSAtIDUpIHtcbiAgICBtYXhfYmxvY2tfc2l6ZSA9IHMucGVuZGluZ19idWZfc2l6ZSAtIDU7XG4gIH1cblxuICAvKiBDb3B5IGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSBpbnB1dCB0byBvdXRwdXQ6ICovXG4gIGZvciAoOzspIHtcbiAgICAvKiBGaWxsIHRoZSB3aW5kb3cgYXMgbXVjaCBhcyBwb3NzaWJsZTogKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPD0gMSkge1xuXG4gICAgICAvL0Fzc2VydChzLT5zdHJzdGFydCA8IHMtPndfc2l6ZStNQVhfRElTVChzKSB8fFxuICAgICAgLy8gIHMtPmJsb2NrX3N0YXJ0ID49IChsb25nKXMtPndfc2l6ZSwgXCJzbGlkZSB0b28gbGF0ZVwiKTtcbi8vICAgICAgaWYgKCEocy5zdHJzdGFydCA8IHMud19zaXplICsgKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkgfHxcbi8vICAgICAgICBzLmJsb2NrX3N0YXJ0ID49IHMud19zaXplKSkge1xuLy8gICAgICAgIHRocm93ICBuZXcgRXJyb3IoXCJzbGlkZSB0b28gbGF0ZVwiKTtcbi8vICAgICAgfVxuXG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuXG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgIH1cbiAgICAvL0Fzc2VydChzLT5ibG9ja19zdGFydCA+PSAwTCwgXCJibG9jayBnb25lXCIpO1xuLy8gICAgaWYgKHMuYmxvY2tfc3RhcnQgPCAwKSB0aHJvdyBuZXcgRXJyb3IoXCJibG9jayBnb25lXCIpO1xuXG4gICAgcy5zdHJzdGFydCArPSBzLmxvb2thaGVhZDtcbiAgICBzLmxvb2thaGVhZCA9IDA7XG5cbiAgICAvKiBFbWl0IGEgc3RvcmVkIGJsb2NrIGlmIHBlbmRpbmdfYnVmIHdpbGwgYmUgZnVsbDogKi9cbiAgICB2YXIgbWF4X3N0YXJ0ID0gcy5ibG9ja19zdGFydCArIG1heF9ibG9ja19zaXplO1xuXG4gICAgaWYgKHMuc3Ryc3RhcnQgPT09IDAgfHwgcy5zdHJzdGFydCA+PSBtYXhfc3RhcnQpIHtcbiAgICAgIC8qIHN0cnN0YXJ0ID09IDAgaXMgcG9zc2libGUgd2hlbiB3cmFwYXJvdW5kIG9uIDE2LWJpdCBtYWNoaW5lICovXG4gICAgICBzLmxvb2thaGVhZCA9IHMuc3Ryc3RhcnQgLSBtYXhfc3RhcnQ7XG4gICAgICBzLnN0cnN0YXJ0ID0gbWF4X3N0YXJ0O1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cblxuXG4gICAgfVxuICAgIC8qIEZsdXNoIGlmIHdlIG1heSBoYXZlIHRvIHNsaWRlLCBvdGhlcndpc2UgYmxvY2tfc3RhcnQgbWF5IGJlY29tZVxuICAgICAqIG5lZ2F0aXZlIGFuZCB0aGUgZGF0YSB3aWxsIGJlIGdvbmU6XG4gICAgICovXG4gICAgaWYgKHMuc3Ryc3RhcnQgLSBzLmJsb2NrX3N0YXJ0ID49IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuXG4gIHMuaW5zZXJ0ID0gMDtcblxuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cblxuICBpZiAocy5zdHJzdGFydCA+IHMuYmxvY2tfc3RhcnQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cblxuICByZXR1cm4gQlNfTkVFRF9NT1JFO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbXByZXNzIGFzIG11Y2ggYXMgcG9zc2libGUgZnJvbSB0aGUgaW5wdXQgc3RyZWFtLCByZXR1cm4gdGhlIGN1cnJlbnRcbiAqIGJsb2NrIHN0YXRlLlxuICogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBwZXJmb3JtIGxhenkgZXZhbHVhdGlvbiBvZiBtYXRjaGVzIGFuZCBpbnNlcnRzXG4gKiBuZXcgc3RyaW5ncyBpbiB0aGUgZGljdGlvbmFyeSBvbmx5IGZvciB1bm1hdGNoZWQgc3RyaW5ncyBvciBmb3Igc2hvcnRcbiAqIG1hdGNoZXMuIEl0IGlzIHVzZWQgb25seSBmb3IgdGhlIGZhc3QgY29tcHJlc3Npb24gb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9mYXN0KHMsIGZsdXNoKSB7XG4gIHZhciBoYXNoX2hlYWQ7ICAgICAgICAvKiBoZWFkIG9mIHRoZSBoYXNoIGNoYWluICovXG4gIHZhciBiZmx1c2g7ICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cblxuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgYWx3YXlzIGhhdmUgZW5vdWdoIGxvb2thaGVhZCwgZXhjZXB0XG4gICAgICogYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQgZmlsZS4gV2UgbmVlZCBNQVhfTUFUQ0ggYnl0ZXNcbiAgICAgKiBmb3IgdGhlIG5leHQgbWF0Y2gsIHBsdXMgTUlOX01BVENIIGJ5dGVzIHRvIGluc2VydCB0aGVcbiAgICAgKiBzdHJpbmcgZm9sbG93aW5nIHRoZSBuZXh0IG1hdGNoLlxuICAgICAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQpIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgIGJyZWFrOyAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qIEluc2VydCB0aGUgc3RyaW5nIHdpbmRvd1tzdHJzdGFydCAuLiBzdHJzdGFydCsyXSBpbiB0aGVcbiAgICAgKiBkaWN0aW9uYXJ5LCBhbmQgc2V0IGhhc2hfaGVhZCB0byB0aGUgaGVhZCBvZiB0aGUgaGFzaCBjaGFpbjpcbiAgICAgKi9cbiAgICBoYXNoX2hlYWQgPSAwLypOSUwqLztcbiAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqL1xuICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgLyoqKi9cbiAgICB9XG5cbiAgICAvKiBGaW5kIHRoZSBsb25nZXN0IG1hdGNoLCBkaXNjYXJkaW5nIHRob3NlIDw9IHByZXZfbGVuZ3RoLlxuICAgICAqIEF0IHRoaXMgcG9pbnQgd2UgaGF2ZSBhbHdheXMgbWF0Y2hfbGVuZ3RoIDwgTUlOX01BVENIXG4gICAgICovXG4gICAgaWYgKGhhc2hfaGVhZCAhPT0gMC8qTklMKi8gJiYgKChzLnN0cnN0YXJ0IC0gaGFzaF9oZWFkKSA8PSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkpIHtcbiAgICAgIC8qIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLCB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nXG4gICAgICAgKiBvZiB3aW5kb3cgaW5kZXggMCAoaW4gcGFydGljdWxhciB3ZSBoYXZlIHRvIGF2b2lkIGEgbWF0Y2hcbiAgICAgICAqIG9mIHRoZSBzdHJpbmcgd2l0aCBpdHNlbGYgYXQgdGhlIHN0YXJ0IG9mIHRoZSBpbnB1dCBmaWxlKS5cbiAgICAgICAqL1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSBsb25nZXN0X21hdGNoKHMsIGhhc2hfaGVhZCk7XG4gICAgICAvKiBsb25nZXN0X21hdGNoKCkgc2V0cyBtYXRjaF9zdGFydCAqL1xuICAgIH1cbiAgICBpZiAocy5tYXRjaF9sZW5ndGggPj0gTUlOX01BVENIKSB7XG4gICAgICAvLyBjaGVja19tYXRjaChzLCBzLnN0cnN0YXJ0LCBzLm1hdGNoX3N0YXJ0LCBzLm1hdGNoX2xlbmd0aCk7IC8vIGZvciBkZWJ1ZyBvbmx5XG5cbiAgICAgIC8qKiogX3RyX3RhbGx5X2Rpc3Qocywgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIHMuc3Ryc3RhcnQgLSBzLm1hdGNoX3N0YXJ0LCBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCk7XG5cbiAgICAgIHMubG9va2FoZWFkIC09IHMubWF0Y2hfbGVuZ3RoO1xuXG4gICAgICAvKiBJbnNlcnQgbmV3IHN0cmluZ3MgaW4gdGhlIGhhc2ggdGFibGUgb25seSBpZiB0aGUgbWF0Y2ggbGVuZ3RoXG4gICAgICAgKiBpcyBub3QgdG9vIGxhcmdlLiBUaGlzIHNhdmVzIHRpbWUgYnV0IGRlZ3JhZGVzIGNvbXByZXNzaW9uLlxuICAgICAgICovXG4gICAgICBpZiAocy5tYXRjaF9sZW5ndGggPD0gcy5tYXhfbGF6eV9tYXRjaC8qbWF4X2luc2VydF9sZW5ndGgqLyAmJiBzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgICAgcy5tYXRjaF9sZW5ndGgtLTsgLyogc3RyaW5nIGF0IHN0cnN0YXJ0IGFscmVhZHkgaW4gdGFibGUgKi9cbiAgICAgICAgZG8ge1xuICAgICAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqL1xuICAgICAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcbiAgICAgICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgICAgIC8qKiovXG4gICAgICAgICAgLyogc3Ryc3RhcnQgbmV2ZXIgZXhjZWVkcyBXU0laRS1NQVhfTUFUQ0gsIHNvIHRoZXJlIGFyZVxuICAgICAgICAgICAqIGFsd2F5cyBNSU5fTUFUQ0ggYnl0ZXMgYWhlYWQuXG4gICAgICAgICAgICovXG4gICAgICAgIH0gd2hpbGUgKC0tcy5tYXRjaF9sZW5ndGggIT09IDApO1xuICAgICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICB9IGVsc2VcbiAgICAgIHtcbiAgICAgICAgcy5zdHJzdGFydCArPSBzLm1hdGNoX2xlbmd0aDtcbiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgICAgICBzLmluc19oID0gcy53aW5kb3dbcy5zdHJzdGFydF07XG4gICAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMuaW5zX2gsIHMud2luZG93W3Muc3Ryc3RhcnQrMV0pOyAqL1xuICAgICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgMV0pICYgcy5oYXNoX21hc2s7XG5cbi8vI2lmIE1JTl9NQVRDSCAhPSAzXG4vLyAgICAgICAgICAgICAgICBDYWxsIFVQREFURV9IQVNIKCkgTUlOX01BVENILTMgbW9yZSB0aW1lc1xuLy8jZW5kaWZcbiAgICAgICAgLyogSWYgbG9va2FoZWFkIDwgTUlOX01BVENILCBpbnNfaCBpcyBnYXJiYWdlLCBidXQgaXQgZG9lcyBub3RcbiAgICAgICAgICogbWF0dGVyIHNpbmNlIGl0IHdpbGwgYmUgcmVjb21wdXRlZCBhdCBuZXh0IGRlZmxhdGUgY2FsbC5cbiAgICAgICAgICovXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIE5vIG1hdGNoLCBvdXRwdXQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy53aW5kb3dbcy5zdHJzdGFydF0pKTtcbiAgICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnRdKTtcblxuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICB9XG4gICAgaWYgKGJmbHVzaCkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cbiAgcy5pbnNlcnQgPSAoKHMuc3Ryc3RhcnQgPCAoTUlOX01BVENIIC0gMSkpID8gcy5zdHJzdGFydCA6IE1JTl9NQVRDSCAtIDEpO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2FtZSBhcyBhYm92ZSwgYnV0IGFjaGlldmVzIGJldHRlciBjb21wcmVzc2lvbi4gV2UgdXNlIGEgbGF6eVxuICogZXZhbHVhdGlvbiBmb3IgbWF0Y2hlczogYSBtYXRjaCBpcyBmaW5hbGx5IGFkb3B0ZWQgb25seSBpZiB0aGVyZSBpc1xuICogbm8gYmV0dGVyIG1hdGNoIGF0IHRoZSBuZXh0IHdpbmRvdyBwb3NpdGlvbi5cbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9zbG93KHMsIGZsdXNoKSB7XG4gIHZhciBoYXNoX2hlYWQ7ICAgICAgICAgIC8qIGhlYWQgb2YgaGFzaCBjaGFpbiAqL1xuICB2YXIgYmZsdXNoOyAgICAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG5cbiAgdmFyIG1heF9pbnNlcnQ7XG5cbiAgLyogUHJvY2VzcyB0aGUgaW5wdXQgYmxvY2suICovXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBhbHdheXMgaGF2ZSBlbm91Z2ggbG9va2FoZWFkLCBleGNlcHRcbiAgICAgKiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xuICAgICAqIGZvciB0aGUgbmV4dCBtYXRjaCwgcGx1cyBNSU5fTUFUQ0ggYnl0ZXMgdG8gaW5zZXJ0IHRoZVxuICAgICAqIHN0cmluZyBmb2xsb3dpbmcgdGhlIG5leHQgbWF0Y2guXG4gICAgICovXG4gICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHsgYnJlYWs7IH0gLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICB9XG5cbiAgICAvKiBJbnNlcnQgdGhlIHN0cmluZyB3aW5kb3dbc3Ryc3RhcnQgLi4gc3Ryc3RhcnQrMl0gaW4gdGhlXG4gICAgICogZGljdGlvbmFyeSwgYW5kIHNldCBoYXNoX2hlYWQgdG8gdGhlIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW46XG4gICAgICovXG4gICAgaGFzaF9oZWFkID0gMC8qTklMKi87XG4gICAgaWYgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcbiAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgIC8qKiovXG4gICAgfVxuXG4gICAgLyogRmluZCB0aGUgbG9uZ2VzdCBtYXRjaCwgZGlzY2FyZGluZyB0aG9zZSA8PSBwcmV2X2xlbmd0aC5cbiAgICAgKi9cbiAgICBzLnByZXZfbGVuZ3RoID0gcy5tYXRjaF9sZW5ndGg7XG4gICAgcy5wcmV2X21hdGNoID0gcy5tYXRjaF9zdGFydDtcbiAgICBzLm1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG5cbiAgICBpZiAoaGFzaF9oZWFkICE9PSAwLypOSUwqLyAmJiBzLnByZXZfbGVuZ3RoIDwgcy5tYXhfbGF6eV9tYXRjaCAmJlxuICAgICAgICBzLnN0cnN0YXJ0IC0gaGFzaF9oZWFkIDw9IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpLypNQVhfRElTVChzKSovKSB7XG4gICAgICAvKiBUbyBzaW1wbGlmeSB0aGUgY29kZSwgd2UgcHJldmVudCBtYXRjaGVzIHdpdGggdGhlIHN0cmluZ1xuICAgICAgICogb2Ygd2luZG93IGluZGV4IDAgKGluIHBhcnRpY3VsYXIgd2UgaGF2ZSB0byBhdm9pZCBhIG1hdGNoXG4gICAgICAgKiBvZiB0aGUgc3RyaW5nIHdpdGggaXRzZWxmIGF0IHRoZSBzdGFydCBvZiB0aGUgaW5wdXQgZmlsZSkuXG4gICAgICAgKi9cbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gbG9uZ2VzdF9tYXRjaChzLCBoYXNoX2hlYWQpO1xuICAgICAgLyogbG9uZ2VzdF9tYXRjaCgpIHNldHMgbWF0Y2hfc3RhcnQgKi9cblxuICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoIDw9IDUgJiZcbiAgICAgICAgIChzLnN0cmF0ZWd5ID09PSBaX0ZJTFRFUkVEIHx8IChzLm1hdGNoX2xlbmd0aCA9PT0gTUlOX01BVENIICYmIHMuc3Ryc3RhcnQgLSBzLm1hdGNoX3N0YXJ0ID4gNDA5Ni8qVE9PX0ZBUiovKSkpIHtcblxuICAgICAgICAvKiBJZiBwcmV2X21hdGNoIGlzIGFsc28gTUlOX01BVENILCBtYXRjaF9zdGFydCBpcyBnYXJiYWdlXG4gICAgICAgICAqIGJ1dCB3ZSB3aWxsIGlnbm9yZSB0aGUgY3VycmVudCBtYXRjaCBhbnl3YXkuXG4gICAgICAgICAqL1xuICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gICAgICB9XG4gICAgfVxuICAgIC8qIElmIHRoZXJlIHdhcyBhIG1hdGNoIGF0IHRoZSBwcmV2aW91cyBzdGVwIGFuZCB0aGUgY3VycmVudFxuICAgICAqIG1hdGNoIGlzIG5vdCBiZXR0ZXIsIG91dHB1dCB0aGUgcHJldmlvdXMgbWF0Y2g6XG4gICAgICovXG4gICAgaWYgKHMucHJldl9sZW5ndGggPj0gTUlOX01BVENIICYmIHMubWF0Y2hfbGVuZ3RoIDw9IHMucHJldl9sZW5ndGgpIHtcbiAgICAgIG1heF9pbnNlcnQgPSBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQgLSBNSU5fTUFUQ0g7XG4gICAgICAvKiBEbyBub3QgaW5zZXJ0IHN0cmluZ3MgaW4gaGFzaCB0YWJsZSBiZXlvbmQgdGhpcy4gKi9cblxuICAgICAgLy9jaGVja19tYXRjaChzLCBzLnN0cnN0YXJ0LTEsIHMucHJldl9tYXRjaCwgcy5wcmV2X2xlbmd0aCk7XG5cbiAgICAgIC8qKipfdHJfdGFsbHlfZGlzdChzLCBzLnN0cnN0YXJ0IC0gMSAtIHMucHJldl9tYXRjaCxcbiAgICAgICAgICAgICAgICAgICAgIHMucHJldl9sZW5ndGggLSBNSU5fTUFUQ0gsIGJmbHVzaCk7KioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIHMuc3Ryc3RhcnQgLSAxIC0gcy5wcmV2X21hdGNoLCBzLnByZXZfbGVuZ3RoIC0gTUlOX01BVENIKTtcbiAgICAgIC8qIEluc2VydCBpbiBoYXNoIHRhYmxlIGFsbCBzdHJpbmdzIHVwIHRvIHRoZSBlbmQgb2YgdGhlIG1hdGNoLlxuICAgICAgICogc3Ryc3RhcnQtMSBhbmQgc3Ryc3RhcnQgYXJlIGFscmVhZHkgaW5zZXJ0ZWQuIElmIHRoZXJlIGlzIG5vdFxuICAgICAgICogZW5vdWdoIGxvb2thaGVhZCwgdGhlIGxhc3QgdHdvIHN0cmluZ3MgYXJlIG5vdCBpbnNlcnRlZCBpblxuICAgICAgICogdGhlIGhhc2ggdGFibGUuXG4gICAgICAgKi9cbiAgICAgIHMubG9va2FoZWFkIC09IHMucHJldl9sZW5ndGggLSAxO1xuICAgICAgcy5wcmV2X2xlbmd0aCAtPSAyO1xuICAgICAgZG8ge1xuICAgICAgICBpZiAoKytzLnN0cnN0YXJ0IDw9IG1heF9pbnNlcnQpIHtcbiAgICAgICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqL1xuICAgICAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcbiAgICAgICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKC0tcy5wcmV2X2xlbmd0aCAhPT0gMCk7XG4gICAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gICAgICBzLnN0cnN0YXJ0Kys7XG5cbiAgICAgIGlmIChiZmx1c2gpIHtcbiAgICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgICB9XG4gICAgICAgIC8qKiovXG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKHMubWF0Y2hfYXZhaWxhYmxlKSB7XG4gICAgICAvKiBJZiB0aGVyZSB3YXMgbm8gbWF0Y2ggYXQgdGhlIHByZXZpb3VzIHBvc2l0aW9uLCBvdXRwdXQgYVxuICAgICAgICogc2luZ2xlIGxpdGVyYWwuIElmIHRoZXJlIHdhcyBhIG1hdGNoIGJ1dCB0aGUgY3VycmVudCBtYXRjaFxuICAgICAgICogaXMgbG9uZ2VyLCB0cnVuY2F0ZSB0aGUgcHJldmlvdXMgbWF0Y2ggdG8gYSBzaW5nbGUgbGl0ZXJhbC5cbiAgICAgICAqL1xuICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnQtMV0pKTtcbiAgICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0LTFdLCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydCAtIDFdKTtcblxuICAgICAgaWYgKGJmbHVzaCkge1xuICAgICAgICAvKioqIEZMVVNIX0JMT0NLX09OTFkocywgMCkgKioqL1xuICAgICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgICAgLyoqKi9cbiAgICAgIH1cbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiBUaGVyZSBpcyBubyBwcmV2aW91cyBtYXRjaCB0byBjb21wYXJlIHdpdGgsIHdhaXQgZm9yXG4gICAgICAgKiB0aGUgbmV4dCBzdGVwIHRvIGRlY2lkZS5cbiAgICAgICAqL1xuICAgICAgcy5tYXRjaF9hdmFpbGFibGUgPSAxO1xuICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGZsdXNoICE9IFpfTk9fRkxVU0gsIFwibm8gZmx1c2g/XCIpO1xuICBpZiAocy5tYXRjaF9hdmFpbGFibGUpIHtcbiAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydC0xXSkpO1xuICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0LTFdLCBiZmx1c2gpOyAqKiovXG4gICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnQgLSAxXSk7XG5cbiAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gIH1cbiAgcy5pbnNlcnQgPSBzLnN0cnN0YXJ0IDwgTUlOX01BVENIIC0gMSA/IHMuc3Ryc3RhcnQgOiBNSU5fTUFUQ0ggLSAxO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cblxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZvciBaX1JMRSwgc2ltcGx5IGxvb2sgZm9yIHJ1bnMgb2YgYnl0ZXMsIGdlbmVyYXRlIG1hdGNoZXMgb25seSBvZiBkaXN0YW5jZVxuICogb25lLiAgRG8gbm90IG1haW50YWluIGEgaGFzaCB0YWJsZS4gIChJdCB3aWxsIGJlIHJlZ2VuZXJhdGVkIGlmIHRoaXMgcnVuIG9mXG4gKiBkZWZsYXRlIHN3aXRjaGVzIGF3YXkgZnJvbSBaX1JMRS4pXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfcmxlKHMsIGZsdXNoKSB7XG4gIHZhciBiZmx1c2g7ICAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG4gIHZhciBwcmV2OyAgICAgICAgICAgICAgLyogYnl0ZSBhdCBkaXN0YW5jZSBvbmUgdG8gbWF0Y2ggKi9cbiAgdmFyIHNjYW4sIHN0cmVuZDsgICAgICAvKiBzY2FuIGdvZXMgdXAgdG8gc3RyZW5kIGZvciBsZW5ndGggb2YgcnVuICovXG5cbiAgdmFyIF93aW4gPSBzLndpbmRvdztcblxuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgYWx3YXlzIGhhdmUgZW5vdWdoIGxvb2thaGVhZCwgZXhjZXB0XG4gICAgICogYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQgZmlsZS4gV2UgbmVlZCBNQVhfTUFUQ0ggYnl0ZXNcbiAgICAgKiBmb3IgdGhlIGxvbmdlc3QgcnVuLCBwbHVzIG9uZSBmb3IgdGhlIHVucm9sbGVkIGxvb3AuXG4gICAgICovXG4gICAgaWYgKHMubG9va2FoZWFkIDw9IE1BWF9NQVRDSCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPD0gTUFYX01BVENIICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHsgYnJlYWs7IH0gLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICB9XG5cbiAgICAvKiBTZWUgaG93IG1hbnkgdGltZXMgdGhlIHByZXZpb3VzIGJ5dGUgcmVwZWF0cyAqL1xuICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIICYmIHMuc3Ryc3RhcnQgPiAwKSB7XG4gICAgICBzY2FuID0gcy5zdHJzdGFydCAtIDE7XG4gICAgICBwcmV2ID0gX3dpbltzY2FuXTtcbiAgICAgIGlmIChwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSkge1xuICAgICAgICBzdHJlbmQgPSBzLnN0cnN0YXJ0ICsgTUFYX01BVENIO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgLypqc2hpbnQgbm9lbXB0eTpmYWxzZSovXG4gICAgICAgIH0gd2hpbGUgKHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgc2NhbiA8IHN0cmVuZCk7XG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUFYX01BVENIIC0gKHN0cmVuZCAtIHNjYW4pO1xuICAgICAgICBpZiAocy5tYXRjaF9sZW5ndGggPiBzLmxvb2thaGVhZCkge1xuICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gcy5sb29rYWhlYWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vQXNzZXJ0KHNjYW4gPD0gcy0+d2luZG93Kyh1SW50KShzLT53aW5kb3dfc2l6ZS0xKSwgXCJ3aWxkIHNjYW5cIik7XG4gICAgfVxuXG4gICAgLyogRW1pdCBtYXRjaCBpZiBoYXZlIHJ1biBvZiBNSU5fTUFUQ0ggb3IgbG9uZ2VyLCBlbHNlIGVtaXQgbGl0ZXJhbCAqL1xuICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8vY2hlY2tfbWF0Y2gocywgcy5zdHJzdGFydCwgcy5zdHJzdGFydCAtIDEsIHMubWF0Y2hfbGVuZ3RoKTtcblxuICAgICAgLyoqKiBfdHJfdGFsbHlfZGlzdChzLCAxLCBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDEsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENIKTtcblxuICAgICAgcy5sb29rYWhlYWQgLT0gcy5tYXRjaF9sZW5ndGg7XG4gICAgICBzLnN0cnN0YXJ0ICs9IHMubWF0Y2hfbGVuZ3RoO1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiBObyBtYXRjaCwgb3V0cHV0IGEgbGl0ZXJhbCBieXRlICovXG4gICAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydF0pKTtcbiAgICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnRdKTtcblxuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICB9XG4gICAgaWYgKGJmbHVzaCkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cbiAgcy5pbnNlcnQgPSAwO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRm9yIFpfSFVGRk1BTl9PTkxZLCBkbyBub3QgbG9vayBmb3IgbWF0Y2hlcy4gIERvIG5vdCBtYWludGFpbiBhIGhhc2ggdGFibGUuXG4gKiAoSXQgd2lsbCBiZSByZWdlbmVyYXRlZCBpZiB0aGlzIHJ1biBvZiBkZWZsYXRlIHN3aXRjaGVzIGF3YXkgZnJvbSBIdWZmbWFuLilcbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9odWZmKHMsIGZsdXNoKSB7XG4gIHZhciBiZmx1c2g7ICAgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBoYXZlIGEgbGl0ZXJhbCB0byB3cml0ZS4gKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7ICAgICAgLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBPdXRwdXQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnRdKSk7XG4gICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnRdLCBiZmx1c2gpOyAqKiovXG4gICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnRdKTtcbiAgICBzLmxvb2thaGVhZC0tO1xuICAgIHMuc3Ryc3RhcnQrKztcbiAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuICBzLmluc2VydCA9IDA7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn1cblxuLyogVmFsdWVzIGZvciBtYXhfbGF6eV9tYXRjaCwgZ29vZF9tYXRjaCBhbmQgbWF4X2NoYWluX2xlbmd0aCwgZGVwZW5kaW5nIG9uXG4gKiB0aGUgZGVzaXJlZCBwYWNrIGxldmVsICgwLi45KS4gVGhlIHZhbHVlcyBnaXZlbiBiZWxvdyBoYXZlIGJlZW4gdHVuZWQgdG9cbiAqIGV4Y2x1ZGUgd29yc3QgY2FzZSBwZXJmb3JtYW5jZSBmb3IgcGF0aG9sb2dpY2FsIGZpbGVzLiBCZXR0ZXIgdmFsdWVzIG1heSBiZVxuICogZm91bmQgZm9yIHNwZWNpZmljIGZpbGVzLlxuICovXG5mdW5jdGlvbiBDb25maWcoZ29vZF9sZW5ndGgsIG1heF9sYXp5LCBuaWNlX2xlbmd0aCwgbWF4X2NoYWluLCBmdW5jKSB7XG4gIHRoaXMuZ29vZF9sZW5ndGggPSBnb29kX2xlbmd0aDtcbiAgdGhpcy5tYXhfbGF6eSA9IG1heF9sYXp5O1xuICB0aGlzLm5pY2VfbGVuZ3RoID0gbmljZV9sZW5ndGg7XG4gIHRoaXMubWF4X2NoYWluID0gbWF4X2NoYWluO1xuICB0aGlzLmZ1bmMgPSBmdW5jO1xufVxuXG52YXIgY29uZmlndXJhdGlvbl90YWJsZTtcblxuY29uZmlndXJhdGlvbl90YWJsZSA9IFtcbiAgLyogICAgICBnb29kIGxhenkgbmljZSBjaGFpbiAqL1xuICBuZXcgQ29uZmlnKDAsIDAsIDAsIDAsIGRlZmxhdGVfc3RvcmVkKSwgICAgICAgICAgLyogMCBzdG9yZSBvbmx5ICovXG4gIG5ldyBDb25maWcoNCwgNCwgOCwgNCwgZGVmbGF0ZV9mYXN0KSwgICAgICAgICAgICAvKiAxIG1heCBzcGVlZCwgbm8gbGF6eSBtYXRjaGVzICovXG4gIG5ldyBDb25maWcoNCwgNSwgMTYsIDgsIGRlZmxhdGVfZmFzdCksICAgICAgICAgICAvKiAyICovXG4gIG5ldyBDb25maWcoNCwgNiwgMzIsIDMyLCBkZWZsYXRlX2Zhc3QpLCAgICAgICAgICAvKiAzICovXG5cbiAgbmV3IENvbmZpZyg0LCA0LCAxNiwgMTYsIGRlZmxhdGVfc2xvdyksICAgICAgICAgIC8qIDQgbGF6eSBtYXRjaGVzICovXG4gIG5ldyBDb25maWcoOCwgMTYsIDMyLCAzMiwgZGVmbGF0ZV9zbG93KSwgICAgICAgICAvKiA1ICovXG4gIG5ldyBDb25maWcoOCwgMTYsIDEyOCwgMTI4LCBkZWZsYXRlX3Nsb3cpLCAgICAgICAvKiA2ICovXG4gIG5ldyBDb25maWcoOCwgMzIsIDEyOCwgMjU2LCBkZWZsYXRlX3Nsb3cpLCAgICAgICAvKiA3ICovXG4gIG5ldyBDb25maWcoMzIsIDEyOCwgMjU4LCAxMDI0LCBkZWZsYXRlX3Nsb3cpLCAgICAvKiA4ICovXG4gIG5ldyBDb25maWcoMzIsIDI1OCwgMjU4LCA0MDk2LCBkZWZsYXRlX3Nsb3cpICAgICAvKiA5IG1heCBjb21wcmVzc2lvbiAqL1xuXTtcblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgdGhlIFwibG9uZ2VzdCBtYXRjaFwiIHJvdXRpbmVzIGZvciBhIG5ldyB6bGliIHN0cmVhbVxuICovXG5mdW5jdGlvbiBsbV9pbml0KHMpIHtcbiAgcy53aW5kb3dfc2l6ZSA9IDIgKiBzLndfc2l6ZTtcblxuICAvKioqIENMRUFSX0hBU0gocyk7ICoqKi9cbiAgemVybyhzLmhlYWQpOyAvLyBGaWxsIHdpdGggTklMICg9IDApO1xuXG4gIC8qIFNldCB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnM6XG4gICAqL1xuICBzLm1heF9sYXp5X21hdGNoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5tYXhfbGF6eTtcbiAgcy5nb29kX21hdGNoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5nb29kX2xlbmd0aDtcbiAgcy5uaWNlX21hdGNoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5uaWNlX2xlbmd0aDtcbiAgcy5tYXhfY2hhaW5fbGVuZ3RoID0gY29uZmlndXJhdGlvbl90YWJsZVtzLmxldmVsXS5tYXhfY2hhaW47XG5cbiAgcy5zdHJzdGFydCA9IDA7XG4gIHMuYmxvY2tfc3RhcnQgPSAwO1xuICBzLmxvb2thaGVhZCA9IDA7XG4gIHMuaW5zZXJ0ID0gMDtcbiAgcy5tYXRjaF9sZW5ndGggPSBzLnByZXZfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICBzLmluc19oID0gMDtcbn1cblxuXG5mdW5jdGlvbiBEZWZsYXRlU3RhdGUoKSB7XG4gIHRoaXMuc3RybSA9IG51bGw7ICAgICAgICAgICAgLyogcG9pbnRlciBiYWNrIHRvIHRoaXMgemxpYiBzdHJlYW0gKi9cbiAgdGhpcy5zdGF0dXMgPSAwOyAgICAgICAgICAgIC8qIGFzIHRoZSBuYW1lIGltcGxpZXMgKi9cbiAgdGhpcy5wZW5kaW5nX2J1ZiA9IG51bGw7ICAgICAgLyogb3V0cHV0IHN0aWxsIHBlbmRpbmcgKi9cbiAgdGhpcy5wZW5kaW5nX2J1Zl9zaXplID0gMDsgIC8qIHNpemUgb2YgcGVuZGluZ19idWYgKi9cbiAgdGhpcy5wZW5kaW5nX291dCA9IDA7ICAgICAgIC8qIG5leHQgcGVuZGluZyBieXRlIHRvIG91dHB1dCB0byB0aGUgc3RyZWFtICovXG4gIHRoaXMucGVuZGluZyA9IDA7ICAgICAgICAgICAvKiBuYiBvZiBieXRlcyBpbiB0aGUgcGVuZGluZyBidWZmZXIgKi9cbiAgdGhpcy53cmFwID0gMDsgICAgICAgICAgICAgIC8qIGJpdCAwIHRydWUgZm9yIHpsaWIsIGJpdCAxIHRydWUgZm9yIGd6aXAgKi9cbiAgdGhpcy5nemhlYWQgPSBudWxsOyAgICAgICAgIC8qIGd6aXAgaGVhZGVyIGluZm9ybWF0aW9uIHRvIHdyaXRlICovXG4gIHRoaXMuZ3ppbmRleCA9IDA7ICAgICAgICAgICAvKiB3aGVyZSBpbiBleHRyYSwgbmFtZSwgb3IgY29tbWVudCAqL1xuICB0aGlzLm1ldGhvZCA9IFpfREVGTEFURUQ7IC8qIGNhbiBvbmx5IGJlIERFRkxBVEVEICovXG4gIHRoaXMubGFzdF9mbHVzaCA9IC0xOyAgIC8qIHZhbHVlIG9mIGZsdXNoIHBhcmFtIGZvciBwcmV2aW91cyBkZWZsYXRlIGNhbGwgKi9cblxuICB0aGlzLndfc2l6ZSA9IDA7ICAvKiBMWjc3IHdpbmRvdyBzaXplICgzMksgYnkgZGVmYXVsdCkgKi9cbiAgdGhpcy53X2JpdHMgPSAwOyAgLyogbG9nMih3X3NpemUpICAoOC4uMTYpICovXG4gIHRoaXMud19tYXNrID0gMDsgIC8qIHdfc2l6ZSAtIDEgKi9cblxuICB0aGlzLndpbmRvdyA9IG51bGw7XG4gIC8qIFNsaWRpbmcgd2luZG93LiBJbnB1dCBieXRlcyBhcmUgcmVhZCBpbnRvIHRoZSBzZWNvbmQgaGFsZiBvZiB0aGUgd2luZG93LFxuICAgKiBhbmQgbW92ZSB0byB0aGUgZmlyc3QgaGFsZiBsYXRlciB0byBrZWVwIGEgZGljdGlvbmFyeSBvZiBhdCBsZWFzdCB3U2l6ZVxuICAgKiBieXRlcy4gV2l0aCB0aGlzIG9yZ2FuaXphdGlvbiwgbWF0Y2hlcyBhcmUgbGltaXRlZCB0byBhIGRpc3RhbmNlIG9mXG4gICAqIHdTaXplLU1BWF9NQVRDSCBieXRlcywgYnV0IHRoaXMgZW5zdXJlcyB0aGF0IElPIGlzIGFsd2F5c1xuICAgKiBwZXJmb3JtZWQgd2l0aCBhIGxlbmd0aCBtdWx0aXBsZSBvZiB0aGUgYmxvY2sgc2l6ZS5cbiAgICovXG5cbiAgdGhpcy53aW5kb3dfc2l6ZSA9IDA7XG4gIC8qIEFjdHVhbCBzaXplIG9mIHdpbmRvdzogMip3U2l6ZSwgZXhjZXB0IHdoZW4gdGhlIHVzZXIgaW5wdXQgYnVmZmVyXG4gICAqIGlzIGRpcmVjdGx5IHVzZWQgYXMgc2xpZGluZyB3aW5kb3cuXG4gICAqL1xuXG4gIHRoaXMucHJldiA9IG51bGw7XG4gIC8qIExpbmsgdG8gb2xkZXIgc3RyaW5nIHdpdGggc2FtZSBoYXNoIGluZGV4LiBUbyBsaW1pdCB0aGUgc2l6ZSBvZiB0aGlzXG4gICAqIGFycmF5IHRvIDY0SywgdGhpcyBsaW5rIGlzIG1haW50YWluZWQgb25seSBmb3IgdGhlIGxhc3QgMzJLIHN0cmluZ3MuXG4gICAqIEFuIGluZGV4IGluIHRoaXMgYXJyYXkgaXMgdGh1cyBhIHdpbmRvdyBpbmRleCBtb2R1bG8gMzJLLlxuICAgKi9cblxuICB0aGlzLmhlYWQgPSBudWxsOyAgIC8qIEhlYWRzIG9mIHRoZSBoYXNoIGNoYWlucyBvciBOSUwuICovXG5cbiAgdGhpcy5pbnNfaCA9IDA7ICAgICAgIC8qIGhhc2ggaW5kZXggb2Ygc3RyaW5nIHRvIGJlIGluc2VydGVkICovXG4gIHRoaXMuaGFzaF9zaXplID0gMDsgICAvKiBudW1iZXIgb2YgZWxlbWVudHMgaW4gaGFzaCB0YWJsZSAqL1xuICB0aGlzLmhhc2hfYml0cyA9IDA7ICAgLyogbG9nMihoYXNoX3NpemUpICovXG4gIHRoaXMuaGFzaF9tYXNrID0gMDsgICAvKiBoYXNoX3NpemUtMSAqL1xuXG4gIHRoaXMuaGFzaF9zaGlmdCA9IDA7XG4gIC8qIE51bWJlciBvZiBiaXRzIGJ5IHdoaWNoIGluc19oIG11c3QgYmUgc2hpZnRlZCBhdCBlYWNoIGlucHV0XG4gICAqIHN0ZXAuIEl0IG11c3QgYmUgc3VjaCB0aGF0IGFmdGVyIE1JTl9NQVRDSCBzdGVwcywgdGhlIG9sZGVzdFxuICAgKiBieXRlIG5vIGxvbmdlciB0YWtlcyBwYXJ0IGluIHRoZSBoYXNoIGtleSwgdGhhdCBpczpcbiAgICogICBoYXNoX3NoaWZ0ICogTUlOX01BVENIID49IGhhc2hfYml0c1xuICAgKi9cblxuICB0aGlzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgLyogV2luZG93IHBvc2l0aW9uIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGN1cnJlbnQgb3V0cHV0IGJsb2NrLiBHZXRzXG4gICAqIG5lZ2F0aXZlIHdoZW4gdGhlIHdpbmRvdyBpcyBtb3ZlZCBiYWNrd2FyZHMuXG4gICAqL1xuXG4gIHRoaXMubWF0Y2hfbGVuZ3RoID0gMDsgICAgICAvKiBsZW5ndGggb2YgYmVzdCBtYXRjaCAqL1xuICB0aGlzLnByZXZfbWF0Y2ggPSAwOyAgICAgICAgLyogcHJldmlvdXMgbWF0Y2ggKi9cbiAgdGhpcy5tYXRjaF9hdmFpbGFibGUgPSAwOyAgIC8qIHNldCBpZiBwcmV2aW91cyBtYXRjaCBleGlzdHMgKi9cbiAgdGhpcy5zdHJzdGFydCA9IDA7ICAgICAgICAgIC8qIHN0YXJ0IG9mIHN0cmluZyB0byBpbnNlcnQgKi9cbiAgdGhpcy5tYXRjaF9zdGFydCA9IDA7ICAgICAgIC8qIHN0YXJ0IG9mIG1hdGNoaW5nIHN0cmluZyAqL1xuICB0aGlzLmxvb2thaGVhZCA9IDA7ICAgICAgICAgLyogbnVtYmVyIG9mIHZhbGlkIGJ5dGVzIGFoZWFkIGluIHdpbmRvdyAqL1xuXG4gIHRoaXMucHJldl9sZW5ndGggPSAwO1xuICAvKiBMZW5ndGggb2YgdGhlIGJlc3QgbWF0Y2ggYXQgcHJldmlvdXMgc3RlcC4gTWF0Y2hlcyBub3QgZ3JlYXRlciB0aGFuIHRoaXNcbiAgICogYXJlIGRpc2NhcmRlZC4gVGhpcyBpcyB1c2VkIGluIHRoZSBsYXp5IG1hdGNoIGV2YWx1YXRpb24uXG4gICAqL1xuXG4gIHRoaXMubWF4X2NoYWluX2xlbmd0aCA9IDA7XG4gIC8qIFRvIHNwZWVkIHVwIGRlZmxhdGlvbiwgaGFzaCBjaGFpbnMgYXJlIG5ldmVyIHNlYXJjaGVkIGJleW9uZCB0aGlzXG4gICAqIGxlbmd0aC4gIEEgaGlnaGVyIGxpbWl0IGltcHJvdmVzIGNvbXByZXNzaW9uIHJhdGlvIGJ1dCBkZWdyYWRlcyB0aGVcbiAgICogc3BlZWQuXG4gICAqL1xuXG4gIHRoaXMubWF4X2xhenlfbWF0Y2ggPSAwO1xuICAvKiBBdHRlbXB0IHRvIGZpbmQgYSBiZXR0ZXIgbWF0Y2ggb25seSB3aGVuIHRoZSBjdXJyZW50IG1hdGNoIGlzIHN0cmljdGx5XG4gICAqIHNtYWxsZXIgdGhhbiB0aGlzIHZhbHVlLiBUaGlzIG1lY2hhbmlzbSBpcyB1c2VkIG9ubHkgZm9yIGNvbXByZXNzaW9uXG4gICAqIGxldmVscyA+PSA0LlxuICAgKi9cbiAgLy8gVGhhdCdzIGFsaWFzIHRvIG1heF9sYXp5X21hdGNoLCBkb24ndCB1c2UgZGlyZWN0bHlcbiAgLy90aGlzLm1heF9pbnNlcnRfbGVuZ3RoID0gMDtcbiAgLyogSW5zZXJ0IG5ldyBzdHJpbmdzIGluIHRoZSBoYXNoIHRhYmxlIG9ubHkgaWYgdGhlIG1hdGNoIGxlbmd0aCBpcyBub3RcbiAgICogZ3JlYXRlciB0aGFuIHRoaXMgbGVuZ3RoLiBUaGlzIHNhdmVzIHRpbWUgYnV0IGRlZ3JhZGVzIGNvbXByZXNzaW9uLlxuICAgKiBtYXhfaW5zZXJ0X2xlbmd0aCBpcyB1c2VkIG9ubHkgZm9yIGNvbXByZXNzaW9uIGxldmVscyA8PSAzLlxuICAgKi9cblxuICB0aGlzLmxldmVsID0gMDsgICAgIC8qIGNvbXByZXNzaW9uIGxldmVsICgxLi45KSAqL1xuICB0aGlzLnN0cmF0ZWd5ID0gMDsgIC8qIGZhdm9yIG9yIGZvcmNlIEh1ZmZtYW4gY29kaW5nKi9cblxuICB0aGlzLmdvb2RfbWF0Y2ggPSAwO1xuICAvKiBVc2UgYSBmYXN0ZXIgc2VhcmNoIHdoZW4gdGhlIHByZXZpb3VzIG1hdGNoIGlzIGxvbmdlciB0aGFuIHRoaXMgKi9cblxuICB0aGlzLm5pY2VfbWF0Y2ggPSAwOyAvKiBTdG9wIHNlYXJjaGluZyB3aGVuIGN1cnJlbnQgbWF0Y2ggZXhjZWVkcyB0aGlzICovXG5cbiAgICAgICAgICAgICAgLyogdXNlZCBieSB0cmVlcy5jOiAqL1xuXG4gIC8qIERpZG4ndCB1c2UgY3RfZGF0YSB0eXBlZGVmIGJlbG93IHRvIHN1cHByZXNzIGNvbXBpbGVyIHdhcm5pbmcgKi9cblxuICAvLyBzdHJ1Y3QgY3RfZGF0YV9zIGR5bl9sdHJlZVtIRUFQX1NJWkVdOyAgIC8qIGxpdGVyYWwgYW5kIGxlbmd0aCB0cmVlICovXG4gIC8vIHN0cnVjdCBjdF9kYXRhX3MgZHluX2R0cmVlWzIqRF9DT0RFUysxXTsgLyogZGlzdGFuY2UgdHJlZSAqL1xuICAvLyBzdHJ1Y3QgY3RfZGF0YV9zIGJsX3RyZWVbMipCTF9DT0RFUysxXTsgIC8qIEh1ZmZtYW4gdHJlZSBmb3IgYml0IGxlbmd0aHMgKi9cblxuICAvLyBVc2UgZmxhdCBhcnJheSBvZiBET1VCTEUgc2l6ZSwgd2l0aCBpbnRlcmxlYXZlZCBmYXRhLFxuICAvLyBiZWNhdXNlIEpTIGRvZXMgbm90IHN1cHBvcnQgZWZmZWN0aXZlXG4gIHRoaXMuZHluX2x0cmVlICA9IG5ldyB1dGlscy5CdWYxNihIRUFQX1NJWkUgKiAyKTtcbiAgdGhpcy5keW5fZHRyZWUgID0gbmV3IHV0aWxzLkJ1ZjE2KCgyICogRF9DT0RFUyArIDEpICogMik7XG4gIHRoaXMuYmxfdHJlZSAgICA9IG5ldyB1dGlscy5CdWYxNigoMiAqIEJMX0NPREVTICsgMSkgKiAyKTtcbiAgemVybyh0aGlzLmR5bl9sdHJlZSk7XG4gIHplcm8odGhpcy5keW5fZHRyZWUpO1xuICB6ZXJvKHRoaXMuYmxfdHJlZSk7XG5cbiAgdGhpcy5sX2Rlc2MgICA9IG51bGw7ICAgICAgICAgLyogZGVzYy4gZm9yIGxpdGVyYWwgdHJlZSAqL1xuICB0aGlzLmRfZGVzYyAgID0gbnVsbDsgICAgICAgICAvKiBkZXNjLiBmb3IgZGlzdGFuY2UgdHJlZSAqL1xuICB0aGlzLmJsX2Rlc2MgID0gbnVsbDsgICAgICAgICAvKiBkZXNjLiBmb3IgYml0IGxlbmd0aCB0cmVlICovXG5cbiAgLy91c2ggYmxfY291bnRbTUFYX0JJVFMrMV07XG4gIHRoaXMuYmxfY291bnQgPSBuZXcgdXRpbHMuQnVmMTYoTUFYX0JJVFMgKyAxKTtcbiAgLyogbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aCBmb3IgYW4gb3B0aW1hbCB0cmVlICovXG5cbiAgLy9pbnQgaGVhcFsyKkxfQ09ERVMrMV07ICAgICAgLyogaGVhcCB1c2VkIHRvIGJ1aWxkIHRoZSBIdWZmbWFuIHRyZWVzICovXG4gIHRoaXMuaGVhcCA9IG5ldyB1dGlscy5CdWYxNigyICogTF9DT0RFUyArIDEpOyAgLyogaGVhcCB1c2VkIHRvIGJ1aWxkIHRoZSBIdWZmbWFuIHRyZWVzICovXG4gIHplcm8odGhpcy5oZWFwKTtcblxuICB0aGlzLmhlYXBfbGVuID0gMDsgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGhlYXAgKi9cbiAgdGhpcy5oZWFwX21heCA9IDA7ICAgICAgICAgICAgICAgLyogZWxlbWVudCBvZiBsYXJnZXN0IGZyZXF1ZW5jeSAqL1xuICAvKiBUaGUgc29ucyBvZiBoZWFwW25dIGFyZSBoZWFwWzIqbl0gYW5kIGhlYXBbMipuKzFdLiBoZWFwWzBdIGlzIG5vdCB1c2VkLlxuICAgKiBUaGUgc2FtZSBoZWFwIGFycmF5IGlzIHVzZWQgdG8gYnVpbGQgYWxsIHRyZWVzLlxuICAgKi9cblxuICB0aGlzLmRlcHRoID0gbmV3IHV0aWxzLkJ1ZjE2KDIgKiBMX0NPREVTICsgMSk7IC8vdWNoIGRlcHRoWzIqTF9DT0RFUysxXTtcbiAgemVybyh0aGlzLmRlcHRoKTtcbiAgLyogRGVwdGggb2YgZWFjaCBzdWJ0cmVlIHVzZWQgYXMgdGllIGJyZWFrZXIgZm9yIHRyZWVzIG9mIGVxdWFsIGZyZXF1ZW5jeVxuICAgKi9cblxuICB0aGlzLmxfYnVmID0gMDsgICAgICAgICAgLyogYnVmZmVyIGluZGV4IGZvciBsaXRlcmFscyBvciBsZW5ndGhzICovXG5cbiAgdGhpcy5saXRfYnVmc2l6ZSA9IDA7XG4gIC8qIFNpemUgb2YgbWF0Y2ggYnVmZmVyIGZvciBsaXRlcmFscy9sZW5ndGhzLiAgVGhlcmUgYXJlIDQgcmVhc29ucyBmb3JcbiAgICogbGltaXRpbmcgbGl0X2J1ZnNpemUgdG8gNjRLOlxuICAgKiAgIC0gZnJlcXVlbmNpZXMgY2FuIGJlIGtlcHQgaW4gMTYgYml0IGNvdW50ZXJzXG4gICAqICAgLSBpZiBjb21wcmVzc2lvbiBpcyBub3Qgc3VjY2Vzc2Z1bCBmb3IgdGhlIGZpcnN0IGJsb2NrLCBhbGwgaW5wdXRcbiAgICogICAgIGRhdGEgaXMgc3RpbGwgaW4gdGhlIHdpbmRvdyBzbyB3ZSBjYW4gc3RpbGwgZW1pdCBhIHN0b3JlZCBibG9jayBldmVuXG4gICAqICAgICB3aGVuIGlucHV0IGNvbWVzIGZyb20gc3RhbmRhcmQgaW5wdXQuICAoVGhpcyBjYW4gYWxzbyBiZSBkb25lIGZvclxuICAgKiAgICAgYWxsIGJsb2NrcyBpZiBsaXRfYnVmc2l6ZSBpcyBub3QgZ3JlYXRlciB0aGFuIDMySy4pXG4gICAqICAgLSBpZiBjb21wcmVzc2lvbiBpcyBub3Qgc3VjY2Vzc2Z1bCBmb3IgYSBmaWxlIHNtYWxsZXIgdGhhbiA2NEssIHdlIGNhblxuICAgKiAgICAgZXZlbiBlbWl0IGEgc3RvcmVkIGZpbGUgaW5zdGVhZCBvZiBhIHN0b3JlZCBibG9jayAoc2F2aW5nIDUgYnl0ZXMpLlxuICAgKiAgICAgVGhpcyBpcyBhcHBsaWNhYmxlIG9ubHkgZm9yIHppcCAobm90IGd6aXAgb3IgemxpYikuXG4gICAqICAgLSBjcmVhdGluZyBuZXcgSHVmZm1hbiB0cmVlcyBsZXNzIGZyZXF1ZW50bHkgbWF5IG5vdCBwcm92aWRlIGZhc3RcbiAgICogICAgIGFkYXB0YXRpb24gdG8gY2hhbmdlcyBpbiB0aGUgaW5wdXQgZGF0YSBzdGF0aXN0aWNzLiAoVGFrZSBmb3JcbiAgICogICAgIGV4YW1wbGUgYSBiaW5hcnkgZmlsZSB3aXRoIHBvb3JseSBjb21wcmVzc2libGUgY29kZSBmb2xsb3dlZCBieVxuICAgKiAgICAgYSBoaWdobHkgY29tcHJlc3NpYmxlIHN0cmluZyB0YWJsZS4pIFNtYWxsZXIgYnVmZmVyIHNpemVzIGdpdmVcbiAgICogICAgIGZhc3QgYWRhcHRhdGlvbiBidXQgaGF2ZSBvZiBjb3Vyc2UgdGhlIG92ZXJoZWFkIG9mIHRyYW5zbWl0dGluZ1xuICAgKiAgICAgdHJlZXMgbW9yZSBmcmVxdWVudGx5LlxuICAgKiAgIC0gSSBjYW4ndCBjb3VudCBhYm92ZSA0XG4gICAqL1xuXG4gIHRoaXMubGFzdF9saXQgPSAwOyAgICAgIC8qIHJ1bm5pbmcgaW5kZXggaW4gbF9idWYgKi9cblxuICB0aGlzLmRfYnVmID0gMDtcbiAgLyogQnVmZmVyIGluZGV4IGZvciBkaXN0YW5jZXMuIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLCBkX2J1ZiBhbmQgbF9idWYgaGF2ZVxuICAgKiB0aGUgc2FtZSBudW1iZXIgb2YgZWxlbWVudHMuIFRvIHVzZSBkaWZmZXJlbnQgbGVuZ3RocywgYW4gZXh0cmEgZmxhZ1xuICAgKiBhcnJheSB3b3VsZCBiZSBuZWNlc3NhcnkuXG4gICAqL1xuXG4gIHRoaXMub3B0X2xlbiA9IDA7ICAgICAgIC8qIGJpdCBsZW5ndGggb2YgY3VycmVudCBibG9jayB3aXRoIG9wdGltYWwgdHJlZXMgKi9cbiAgdGhpcy5zdGF0aWNfbGVuID0gMDsgICAgLyogYml0IGxlbmd0aCBvZiBjdXJyZW50IGJsb2NrIHdpdGggc3RhdGljIHRyZWVzICovXG4gIHRoaXMubWF0Y2hlcyA9IDA7ICAgICAgIC8qIG51bWJlciBvZiBzdHJpbmcgbWF0Y2hlcyBpbiBjdXJyZW50IGJsb2NrICovXG4gIHRoaXMuaW5zZXJ0ID0gMDsgICAgICAgIC8qIGJ5dGVzIGF0IGVuZCBvZiB3aW5kb3cgbGVmdCB0byBpbnNlcnQgKi9cblxuXG4gIHRoaXMuYmlfYnVmID0gMDtcbiAgLyogT3V0cHV0IGJ1ZmZlci4gYml0cyBhcmUgaW5zZXJ0ZWQgc3RhcnRpbmcgYXQgdGhlIGJvdHRvbSAobGVhc3RcbiAgICogc2lnbmlmaWNhbnQgYml0cykuXG4gICAqL1xuICB0aGlzLmJpX3ZhbGlkID0gMDtcbiAgLyogTnVtYmVyIG9mIHZhbGlkIGJpdHMgaW4gYmlfYnVmLiAgQWxsIGJpdHMgYWJvdmUgdGhlIGxhc3QgdmFsaWQgYml0XG4gICAqIGFyZSBhbHdheXMgemVyby5cbiAgICovXG5cbiAgLy8gVXNlZCBmb3Igd2luZG93IG1lbW9yeSBpbml0LiBXZSBzYWZlbHkgaWdub3JlIGl0IGZvciBKUy4gVGhhdCBtYWtlc1xuICAvLyBzZW5zZSBvbmx5IGZvciBwb2ludGVycyBhbmQgbWVtb3J5IGNoZWNrIHRvb2xzLlxuICAvL3RoaXMuaGlnaF93YXRlciA9IDA7XG4gIC8qIEhpZ2ggd2F0ZXIgbWFyayBvZmZzZXQgaW4gd2luZG93IGZvciBpbml0aWFsaXplZCBieXRlcyAtLSBieXRlcyBhYm92ZVxuICAgKiB0aGlzIGFyZSBzZXQgdG8gemVybyBpbiBvcmRlciB0byBhdm9pZCBtZW1vcnkgY2hlY2sgd2FybmluZ3Mgd2hlblxuICAgKiBsb25nZXN0IG1hdGNoIHJvdXRpbmVzIGFjY2VzcyBieXRlcyBwYXN0IHRoZSBpbnB1dC4gIFRoaXMgaXMgdGhlblxuICAgKiB1cGRhdGVkIHRvIHRoZSBuZXcgaGlnaCB3YXRlciBtYXJrLlxuICAgKi9cbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlUmVzZXRLZWVwKHN0cm0pIHtcbiAgdmFyIHM7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUik7XG4gIH1cblxuICBzdHJtLnRvdGFsX2luID0gc3RybS50b3RhbF9vdXQgPSAwO1xuICBzdHJtLmRhdGFfdHlwZSA9IFpfVU5LTk9XTjtcblxuICBzID0gc3RybS5zdGF0ZTtcbiAgcy5wZW5kaW5nID0gMDtcbiAgcy5wZW5kaW5nX291dCA9IDA7XG5cbiAgaWYgKHMud3JhcCA8IDApIHtcbiAgICBzLndyYXAgPSAtcy53cmFwO1xuICAgIC8qIHdhcyBtYWRlIG5lZ2F0aXZlIGJ5IGRlZmxhdGUoLi4uLCBaX0ZJTklTSCk7ICovXG4gIH1cbiAgcy5zdGF0dXMgPSAocy53cmFwID8gSU5JVF9TVEFURSA6IEJVU1lfU1RBVEUpO1xuICBzdHJtLmFkbGVyID0gKHMud3JhcCA9PT0gMikgP1xuICAgIDAgIC8vIGNyYzMyKDAsIFpfTlVMTCwgMClcbiAgOlxuICAgIDE7IC8vIGFkbGVyMzIoMCwgWl9OVUxMLCAwKVxuICBzLmxhc3RfZmx1c2ggPSBaX05PX0ZMVVNIO1xuICB0cmVlcy5fdHJfaW5pdChzKTtcbiAgcmV0dXJuIFpfT0s7XG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZVJlc2V0KHN0cm0pIHtcbiAgdmFyIHJldCA9IGRlZmxhdGVSZXNldEtlZXAoc3RybSk7XG4gIGlmIChyZXQgPT09IFpfT0spIHtcbiAgICBsbV9pbml0KHN0cm0uc3RhdGUpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZVNldEhlYWRlcihzdHJtLCBoZWFkKSB7XG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgaWYgKHN0cm0uc3RhdGUud3JhcCAhPT0gMikgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RybS5zdGF0ZS5nemhlYWQgPSBoZWFkO1xuICByZXR1cm4gWl9PSztcbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlSW5pdDIoc3RybSwgbGV2ZWwsIG1ldGhvZCwgd2luZG93Qml0cywgbWVtTGV2ZWwsIHN0cmF0ZWd5KSB7XG4gIGlmICghc3RybSkgeyAvLyA9PT0gWl9OVUxMXG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG4gIHZhciB3cmFwID0gMTtcblxuICBpZiAobGV2ZWwgPT09IFpfREVGQVVMVF9DT01QUkVTU0lPTikge1xuICAgIGxldmVsID0gNjtcbiAgfVxuXG4gIGlmICh3aW5kb3dCaXRzIDwgMCkgeyAvKiBzdXBwcmVzcyB6bGliIHdyYXBwZXIgKi9cbiAgICB3cmFwID0gMDtcbiAgICB3aW5kb3dCaXRzID0gLXdpbmRvd0JpdHM7XG4gIH1cblxuICBlbHNlIGlmICh3aW5kb3dCaXRzID4gMTUpIHtcbiAgICB3cmFwID0gMjsgICAgICAgICAgIC8qIHdyaXRlIGd6aXAgd3JhcHBlciBpbnN0ZWFkICovXG4gICAgd2luZG93Qml0cyAtPSAxNjtcbiAgfVxuXG5cbiAgaWYgKG1lbUxldmVsIDwgMSB8fCBtZW1MZXZlbCA+IE1BWF9NRU1fTEVWRUwgfHwgbWV0aG9kICE9PSBaX0RFRkxBVEVEIHx8XG4gICAgd2luZG93Qml0cyA8IDggfHwgd2luZG93Qml0cyA+IDE1IHx8IGxldmVsIDwgMCB8fCBsZXZlbCA+IDkgfHxcbiAgICBzdHJhdGVneSA8IDAgfHwgc3RyYXRlZ3kgPiBaX0ZJWEVEKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUik7XG4gIH1cblxuXG4gIGlmICh3aW5kb3dCaXRzID09PSA4KSB7XG4gICAgd2luZG93Qml0cyA9IDk7XG4gIH1cbiAgLyogdW50aWwgMjU2LWJ5dGUgd2luZG93IGJ1ZyBmaXhlZCAqL1xuXG4gIHZhciBzID0gbmV3IERlZmxhdGVTdGF0ZSgpO1xuXG4gIHN0cm0uc3RhdGUgPSBzO1xuICBzLnN0cm0gPSBzdHJtO1xuXG4gIHMud3JhcCA9IHdyYXA7XG4gIHMuZ3poZWFkID0gbnVsbDtcbiAgcy53X2JpdHMgPSB3aW5kb3dCaXRzO1xuICBzLndfc2l6ZSA9IDEgPDwgcy53X2JpdHM7XG4gIHMud19tYXNrID0gcy53X3NpemUgLSAxO1xuXG4gIHMuaGFzaF9iaXRzID0gbWVtTGV2ZWwgKyA3O1xuICBzLmhhc2hfc2l6ZSA9IDEgPDwgcy5oYXNoX2JpdHM7XG4gIHMuaGFzaF9tYXNrID0gcy5oYXNoX3NpemUgLSAxO1xuICBzLmhhc2hfc2hpZnQgPSB+figocy5oYXNoX2JpdHMgKyBNSU5fTUFUQ0ggLSAxKSAvIE1JTl9NQVRDSCk7XG5cbiAgcy53aW5kb3cgPSBuZXcgdXRpbHMuQnVmOChzLndfc2l6ZSAqIDIpO1xuICBzLmhlYWQgPSBuZXcgdXRpbHMuQnVmMTYocy5oYXNoX3NpemUpO1xuICBzLnByZXYgPSBuZXcgdXRpbHMuQnVmMTYocy53X3NpemUpO1xuXG4gIC8vIERvbid0IG5lZWQgbWVtIGluaXQgbWFnaWMgZm9yIEpTLlxuICAvL3MuaGlnaF93YXRlciA9IDA7ICAvKiBub3RoaW5nIHdyaXR0ZW4gdG8gcy0+d2luZG93IHlldCAqL1xuXG4gIHMubGl0X2J1ZnNpemUgPSAxIDw8IChtZW1MZXZlbCArIDYpOyAvKiAxNksgZWxlbWVudHMgYnkgZGVmYXVsdCAqL1xuXG4gIHMucGVuZGluZ19idWZfc2l6ZSA9IHMubGl0X2J1ZnNpemUgKiA0O1xuXG4gIC8vb3ZlcmxheSA9ICh1c2hmICopIFpBTExPQyhzdHJtLCBzLT5saXRfYnVmc2l6ZSwgc2l6ZW9mKHVzaCkrMik7XG4gIC8vcy0+cGVuZGluZ19idWYgPSAodWNoZiAqKSBvdmVybGF5O1xuICBzLnBlbmRpbmdfYnVmID0gbmV3IHV0aWxzLkJ1Zjgocy5wZW5kaW5nX2J1Zl9zaXplKTtcblxuICAvLyBJdCBpcyBvZmZzZXQgZnJvbSBgcy5wZW5kaW5nX2J1ZmAgKHNpemUgaXMgYHMubGl0X2J1ZnNpemUgKiAyYClcbiAgLy9zLT5kX2J1ZiA9IG92ZXJsYXkgKyBzLT5saXRfYnVmc2l6ZS9zaXplb2YodXNoKTtcbiAgcy5kX2J1ZiA9IDEgKiBzLmxpdF9idWZzaXplO1xuXG4gIC8vcy0+bF9idWYgPSBzLT5wZW5kaW5nX2J1ZiArICgxK3NpemVvZih1c2gpKSpzLT5saXRfYnVmc2l6ZTtcbiAgcy5sX2J1ZiA9ICgxICsgMikgKiBzLmxpdF9idWZzaXplO1xuXG4gIHMubGV2ZWwgPSBsZXZlbDtcbiAgcy5zdHJhdGVneSA9IHN0cmF0ZWd5O1xuICBzLm1ldGhvZCA9IG1ldGhvZDtcblxuICByZXR1cm4gZGVmbGF0ZVJlc2V0KHN0cm0pO1xufVxuXG5mdW5jdGlvbiBkZWZsYXRlSW5pdChzdHJtLCBsZXZlbCkge1xuICByZXR1cm4gZGVmbGF0ZUluaXQyKHN0cm0sIGxldmVsLCBaX0RFRkxBVEVELCBNQVhfV0JJVFMsIERFRl9NRU1fTEVWRUwsIFpfREVGQVVMVF9TVFJBVEVHWSk7XG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZShzdHJtLCBmbHVzaCkge1xuICB2YXIgb2xkX2ZsdXNoLCBzO1xuICB2YXIgYmVnLCB2YWw7IC8vIGZvciBnemlwIGhlYWRlciB3cml0ZSBvbmx5XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlIHx8XG4gICAgZmx1c2ggPiBaX0JMT0NLIHx8IGZsdXNoIDwgMCkge1xuICAgIHJldHVybiBzdHJtID8gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKSA6IFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgcyA9IHN0cm0uc3RhdGU7XG5cbiAgaWYgKCFzdHJtLm91dHB1dCB8fFxuICAgICAgKCFzdHJtLmlucHV0ICYmIHN0cm0uYXZhaWxfaW4gIT09IDApIHx8XG4gICAgICAocy5zdGF0dXMgPT09IEZJTklTSF9TVEFURSAmJiBmbHVzaCAhPT0gWl9GSU5JU0gpKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCAoc3RybS5hdmFpbF9vdXQgPT09IDApID8gWl9CVUZfRVJST1IgOiBaX1NUUkVBTV9FUlJPUik7XG4gIH1cblxuICBzLnN0cm0gPSBzdHJtOyAvKiBqdXN0IGluIGNhc2UgKi9cbiAgb2xkX2ZsdXNoID0gcy5sYXN0X2ZsdXNoO1xuICBzLmxhc3RfZmx1c2ggPSBmbHVzaDtcblxuICAvKiBXcml0ZSB0aGUgaGVhZGVyICovXG4gIGlmIChzLnN0YXR1cyA9PT0gSU5JVF9TVEFURSkge1xuXG4gICAgaWYgKHMud3JhcCA9PT0gMikgeyAvLyBHWklQIGhlYWRlclxuICAgICAgc3RybS5hZGxlciA9IDA7ICAvL2NyYzMyKDBMLCBaX05VTEwsIDApO1xuICAgICAgcHV0X2J5dGUocywgMzEpO1xuICAgICAgcHV0X2J5dGUocywgMTM5KTtcbiAgICAgIHB1dF9ieXRlKHMsIDgpO1xuICAgICAgaWYgKCFzLmd6aGVhZCkgeyAvLyBzLT5nemhlYWQgPT0gWl9OVUxMXG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5sZXZlbCA9PT0gOSA/IDIgOlxuICAgICAgICAgICAgICAgICAgICAocy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSB8fCBzLmxldmVsIDwgMiA/XG4gICAgICAgICAgICAgICAgICAgICA0IDogMCkpO1xuICAgICAgICBwdXRfYnl0ZShzLCBPU19DT0RFKTtcbiAgICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50ZXh0ID8gMSA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKHMuZ3poZWFkLmhjcmMgPyAyIDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAoIXMuZ3poZWFkLmV4dHJhID8gMCA6IDQpICtcbiAgICAgICAgICAgICAgICAgICAgKCFzLmd6aGVhZC5uYW1lID8gMCA6IDgpICtcbiAgICAgICAgICAgICAgICAgICAgKCFzLmd6aGVhZC5jb21tZW50ID8gMCA6IDE2KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLnRpbWUgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRpbWUgPj4gOCkgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRpbWUgPj4gMTYpICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50aW1lID4+IDI0KSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmxldmVsID09PSA5ID8gMiA6XG4gICAgICAgICAgICAgICAgICAgIChzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyID9cbiAgICAgICAgICAgICAgICAgICAgIDQgOiAwKSk7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLm9zICYgMHhmZik7XG4gICAgICAgIGlmIChzLmd6aGVhZC5leHRyYSAmJiBzLmd6aGVhZC5leHRyYS5sZW5ndGgpIHtcbiAgICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5leHRyYS5sZW5ndGggJiAweGZmKTtcbiAgICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQuZXh0cmEubGVuZ3RoID4+IDgpICYgMHhmZik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMpIHtcbiAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBzLmd6aW5kZXggPSAwO1xuICAgICAgICBzLnN0YXR1cyA9IEVYVFJBX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIC8vIERFRkxBVEUgaGVhZGVyXG4gICAge1xuICAgICAgdmFyIGhlYWRlciA9IChaX0RFRkxBVEVEICsgKChzLndfYml0cyAtIDgpIDw8IDQpKSA8PCA4O1xuICAgICAgdmFyIGxldmVsX2ZsYWdzID0gLTE7XG5cbiAgICAgIGlmIChzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyKSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMDtcbiAgICAgIH0gZWxzZSBpZiAocy5sZXZlbCA8IDYpIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAxO1xuICAgICAgfSBlbHNlIGlmIChzLmxldmVsID09PSA2KSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMztcbiAgICAgIH1cbiAgICAgIGhlYWRlciB8PSAobGV2ZWxfZmxhZ3MgPDwgNik7XG4gICAgICBpZiAocy5zdHJzdGFydCAhPT0gMCkgeyBoZWFkZXIgfD0gUFJFU0VUX0RJQ1Q7IH1cbiAgICAgIGhlYWRlciArPSAzMSAtIChoZWFkZXIgJSAzMSk7XG5cbiAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICAgIHB1dFNob3J0TVNCKHMsIGhlYWRlcik7XG5cbiAgICAgIC8qIFNhdmUgdGhlIGFkbGVyMzIgb2YgdGhlIHByZXNldCBkaWN0aW9uYXJ5OiAqL1xuICAgICAgaWYgKHMuc3Ryc3RhcnQgIT09IDApIHtcbiAgICAgICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciA+Pj4gMTYpO1xuICAgICAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyICYgMHhmZmZmKTtcbiAgICAgIH1cbiAgICAgIHN0cm0uYWRsZXIgPSAxOyAvLyBhZGxlcjMyKDBMLCBaX05VTEwsIDApO1xuICAgIH1cbiAgfVxuXG4vLyNpZmRlZiBHWklQXG4gIGlmIChzLnN0YXR1cyA9PT0gRVhUUkFfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQuZXh0cmEvKiAhPSBaX05VTEwqLykge1xuICAgICAgYmVnID0gcy5wZW5kaW5nOyAgLyogc3RhcnQgb2YgYnl0ZXMgdG8gdXBkYXRlIGNyYyAqL1xuXG4gICAgICB3aGlsZSAocy5nemluZGV4IDwgKHMuZ3poZWFkLmV4dHJhLmxlbmd0aCAmIDB4ZmZmZikpIHtcbiAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgICAgIGJlZyA9IHMucGVuZGluZztcbiAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5leHRyYVtzLmd6aW5kZXhdICYgMHhmZik7XG4gICAgICAgIHMuZ3ppbmRleCsrO1xuICAgICAgfVxuICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICB9XG4gICAgICBpZiAocy5nemluZGV4ID09PSBzLmd6aGVhZC5leHRyYS5sZW5ndGgpIHtcbiAgICAgICAgcy5nemluZGV4ID0gMDtcbiAgICAgICAgcy5zdGF0dXMgPSBOQU1FX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gTkFNRV9TVEFURTtcbiAgICB9XG4gIH1cbiAgaWYgKHMuc3RhdHVzID09PSBOQU1FX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLm5hbWUvKiAhPSBaX05VTEwqLykge1xuICAgICAgYmVnID0gcy5wZW5kaW5nOyAgLyogc3RhcnQgb2YgYnl0ZXMgdG8gdXBkYXRlIGNyYyAqL1xuICAgICAgLy9pbnQgdmFsO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7XG4gICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgICB2YWwgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEpTIHNwZWNpZmljOiBsaXR0bGUgbWFnaWMgdG8gYWRkIHplcm8gdGVybWluYXRvciB0byBlbmQgb2Ygc3RyaW5nXG4gICAgICAgIGlmIChzLmd6aW5kZXggPCBzLmd6aGVhZC5uYW1lLmxlbmd0aCkge1xuICAgICAgICAgIHZhbCA9IHMuZ3poZWFkLm5hbWUuY2hhckNvZGVBdChzLmd6aW5kZXgrKykgJiAweGZmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcHV0X2J5dGUocywgdmFsKTtcbiAgICAgIH0gd2hpbGUgKHZhbCAhPT0gMCk7XG5cbiAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbCA9PT0gMCkge1xuICAgICAgICBzLmd6aW5kZXggPSAwO1xuICAgICAgICBzLnN0YXR1cyA9IENPTU1FTlRfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBDT01NRU5UX1NUQVRFO1xuICAgIH1cbiAgfVxuICBpZiAocy5zdGF0dXMgPT09IENPTU1FTlRfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQuY29tbWVudC8qICE9IFpfTlVMTCovKSB7XG4gICAgICBiZWcgPSBzLnBlbmRpbmc7ICAvKiBzdGFydCBvZiBieXRlcyB0byB1cGRhdGUgY3JjICovXG4gICAgICAvL2ludCB2YWw7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgICAgIGJlZyA9IHMucGVuZGluZztcbiAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICAgIHZhbCA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSlMgc3BlY2lmaWM6IGxpdHRsZSBtYWdpYyB0byBhZGQgemVybyB0ZXJtaW5hdG9yIHRvIGVuZCBvZiBzdHJpbmdcbiAgICAgICAgaWYgKHMuZ3ppbmRleCA8IHMuZ3poZWFkLmNvbW1lbnQubGVuZ3RoKSB7XG4gICAgICAgICAgdmFsID0gcy5nemhlYWQuY29tbWVudC5jaGFyQ29kZUF0KHMuZ3ppbmRleCsrKSAmIDB4ZmY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsID0gMDtcbiAgICAgICAgfVxuICAgICAgICBwdXRfYnl0ZShzLCB2YWwpO1xuICAgICAgfSB3aGlsZSAodmFsICE9PSAwKTtcblxuICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICB9XG4gICAgICBpZiAodmFsID09PSAwKSB7XG4gICAgICAgIHMuc3RhdHVzID0gSENSQ19TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IEhDUkNfU1RBVEU7XG4gICAgfVxuICB9XG4gIGlmIChzLnN0YXR1cyA9PT0gSENSQ19TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5oY3JjKSB7XG4gICAgICBpZiAocy5wZW5kaW5nICsgMiA+IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgfVxuICAgICAgaWYgKHMucGVuZGluZyArIDIgPD0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgIHB1dF9ieXRlKHMsIHN0cm0uYWRsZXIgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gOCkgJiAweGZmKTtcbiAgICAgICAgc3RybS5hZGxlciA9IDA7IC8vY3JjMzIoMEwsIFpfTlVMTCwgMCk7XG4gICAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgfVxuICB9XG4vLyNlbmRpZlxuXG4gIC8qIEZsdXNoIGFzIG11Y2ggcGVuZGluZyBvdXRwdXQgYXMgcG9zc2libGUgKi9cbiAgaWYgKHMucGVuZGluZyAhPT0gMCkge1xuICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAvKiBTaW5jZSBhdmFpbF9vdXQgaXMgMCwgZGVmbGF0ZSB3aWxsIGJlIGNhbGxlZCBhZ2FpbiB3aXRoXG4gICAgICAgKiBtb3JlIG91dHB1dCBzcGFjZSwgYnV0IHBvc3NpYmx5IHdpdGggYm90aCBwZW5kaW5nIGFuZFxuICAgICAgICogYXZhaWxfaW4gZXF1YWwgdG8gemVyby4gVGhlcmUgd29uJ3QgYmUgYW55dGhpbmcgdG8gZG8sXG4gICAgICAgKiBidXQgdGhpcyBpcyBub3QgYW4gZXJyb3Igc2l0dWF0aW9uIHNvIG1ha2Ugc3VyZSB3ZVxuICAgICAgICogcmV0dXJuIE9LIGluc3RlYWQgb2YgQlVGX0VSUk9SIGF0IG5leHQgY2FsbCBvZiBkZWZsYXRlOlxuICAgICAgICovXG4gICAgICBzLmxhc3RfZmx1c2ggPSAtMTtcbiAgICAgIHJldHVybiBaX09LO1xuICAgIH1cblxuICAgIC8qIE1ha2Ugc3VyZSB0aGVyZSBpcyBzb21ldGhpbmcgdG8gZG8gYW5kIGF2b2lkIGR1cGxpY2F0ZSBjb25zZWN1dGl2ZVxuICAgICAqIGZsdXNoZXMuIEZvciByZXBlYXRlZCBhbmQgdXNlbGVzcyBjYWxscyB3aXRoIFpfRklOSVNILCB3ZSBrZWVwXG4gICAgICogcmV0dXJuaW5nIFpfU1RSRUFNX0VORCBpbnN0ZWFkIG9mIFpfQlVGX0VSUk9SLlxuICAgICAqL1xuICB9IGVsc2UgaWYgKHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgcmFuayhmbHVzaCkgPD0gcmFuayhvbGRfZmx1c2gpICYmXG4gICAgZmx1c2ggIT09IFpfRklOSVNIKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX0JVRl9FUlJPUik7XG4gIH1cblxuICAvKiBVc2VyIG11c3Qgbm90IHByb3ZpZGUgbW9yZSBpbnB1dCBhZnRlciB0aGUgZmlyc3QgRklOSVNIOiAqL1xuICBpZiAocy5zdGF0dXMgPT09IEZJTklTSF9TVEFURSAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX0JVRl9FUlJPUik7XG4gIH1cblxuICAvKiBTdGFydCBhIG5ldyBibG9jayBvciBjb250aW51ZSB0aGUgY3VycmVudCBvbmUuXG4gICAqL1xuICBpZiAoc3RybS5hdmFpbF9pbiAhPT0gMCB8fCBzLmxvb2thaGVhZCAhPT0gMCB8fFxuICAgIChmbHVzaCAhPT0gWl9OT19GTFVTSCAmJiBzLnN0YXR1cyAhPT0gRklOSVNIX1NUQVRFKSkge1xuICAgIHZhciBic3RhdGUgPSAocy5zdHJhdGVneSA9PT0gWl9IVUZGTUFOX09OTFkpID8gZGVmbGF0ZV9odWZmKHMsIGZsdXNoKSA6XG4gICAgICAocy5zdHJhdGVneSA9PT0gWl9STEUgPyBkZWZsYXRlX3JsZShzLCBmbHVzaCkgOlxuICAgICAgICBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLmZ1bmMocywgZmx1c2gpKTtcblxuICAgIGlmIChic3RhdGUgPT09IEJTX0ZJTklTSF9TVEFSVEVEIHx8IGJzdGF0ZSA9PT0gQlNfRklOSVNIX0RPTkUpIHtcbiAgICAgIHMuc3RhdHVzID0gRklOSVNIX1NUQVRFO1xuICAgIH1cbiAgICBpZiAoYnN0YXRlID09PSBCU19ORUVEX01PUkUgfHwgYnN0YXRlID09PSBCU19GSU5JU0hfU1RBUlRFRCkge1xuICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHMubGFzdF9mbHVzaCA9IC0xO1xuICAgICAgICAvKiBhdm9pZCBCVUZfRVJST1IgbmV4dCBjYWxsLCBzZWUgYWJvdmUgKi9cbiAgICAgIH1cbiAgICAgIHJldHVybiBaX09LO1xuICAgICAgLyogSWYgZmx1c2ggIT0gWl9OT19GTFVTSCAmJiBhdmFpbF9vdXQgPT0gMCwgdGhlIG5leHQgY2FsbFxuICAgICAgICogb2YgZGVmbGF0ZSBzaG91bGQgdXNlIHRoZSBzYW1lIGZsdXNoIHBhcmFtZXRlciB0byBtYWtlIHN1cmVcbiAgICAgICAqIHRoYXQgdGhlIGZsdXNoIGlzIGNvbXBsZXRlLiBTbyB3ZSBkb24ndCBoYXZlIHRvIG91dHB1dCBhblxuICAgICAgICogZW1wdHkgYmxvY2sgaGVyZSwgdGhpcyB3aWxsIGJlIGRvbmUgYXQgbmV4dCBjYWxsLiBUaGlzIGFsc29cbiAgICAgICAqIGVuc3VyZXMgdGhhdCBmb3IgYSB2ZXJ5IHNtYWxsIG91dHB1dCBidWZmZXIsIHdlIGVtaXQgYXQgbW9zdFxuICAgICAgICogb25lIGVtcHR5IGJsb2NrLlxuICAgICAgICovXG4gICAgfVxuICAgIGlmIChic3RhdGUgPT09IEJTX0JMT0NLX0RPTkUpIHtcbiAgICAgIGlmIChmbHVzaCA9PT0gWl9QQVJUSUFMX0ZMVVNIKSB7XG4gICAgICAgIHRyZWVzLl90cl9hbGlnbihzKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGZsdXNoICE9PSBaX0JMT0NLKSB7IC8qIEZVTExfRkxVU0ggb3IgU1lOQ19GTFVTSCAqL1xuXG4gICAgICAgIHRyZWVzLl90cl9zdG9yZWRfYmxvY2socywgMCwgMCwgZmFsc2UpO1xuICAgICAgICAvKiBGb3IgYSBmdWxsIGZsdXNoLCB0aGlzIGVtcHR5IGJsb2NrIHdpbGwgYmUgcmVjb2duaXplZFxuICAgICAgICAgKiBhcyBhIHNwZWNpYWwgbWFya2VyIGJ5IGluZmxhdGVfc3luYygpLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGZsdXNoID09PSBaX0ZVTExfRkxVU0gpIHtcbiAgICAgICAgICAvKioqIENMRUFSX0hBU0gocyk7ICoqKi8gICAgICAgICAgICAgLyogZm9yZ2V0IGhpc3RvcnkgKi9cbiAgICAgICAgICB6ZXJvKHMuaGVhZCk7IC8vIEZpbGwgd2l0aCBOSUwgKD0gMCk7XG5cbiAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgICAgIHMuc3Ryc3RhcnQgPSAwO1xuICAgICAgICAgICAgcy5ibG9ja19zdGFydCA9IDA7XG4gICAgICAgICAgICBzLmluc2VydCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHMubGFzdF9mbHVzaCA9IC0xOyAvKiBhdm9pZCBCVUZfRVJST1IgYXQgbmV4dCBjYWxsLCBzZWUgYWJvdmUgKi9cbiAgICAgICAgcmV0dXJuIFpfT0s7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0KHN0cm0tPmF2YWlsX291dCA+IDAsIFwiYnVnMlwiKTtcbiAgLy9pZiAoc3RybS5hdmFpbF9vdXQgPD0gMCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJidWcyXCIpO31cblxuICBpZiAoZmx1c2ggIT09IFpfRklOSVNIKSB7IHJldHVybiBaX09LOyB9XG4gIGlmIChzLndyYXAgPD0gMCkgeyByZXR1cm4gWl9TVFJFQU1fRU5EOyB9XG5cbiAgLyogV3JpdGUgdGhlIHRyYWlsZXIgKi9cbiAgaWYgKHMud3JhcCA9PT0gMikge1xuICAgIHB1dF9ieXRlKHMsIHN0cm0uYWRsZXIgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiA4KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDE2KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDI0KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIHN0cm0udG90YWxfaW4gJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS50b3RhbF9pbiA+PiA4KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLnRvdGFsX2luID4+IDE2KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLnRvdGFsX2luID4+IDI0KSAmIDB4ZmYpO1xuICB9XG4gIGVsc2VcbiAge1xuICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgPj4+IDE2KTtcbiAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyICYgMHhmZmZmKTtcbiAgfVxuXG4gIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gIC8qIElmIGF2YWlsX291dCBpcyB6ZXJvLCB0aGUgYXBwbGljYXRpb24gd2lsbCBjYWxsIGRlZmxhdGUgYWdhaW5cbiAgICogdG8gZmx1c2ggdGhlIHJlc3QuXG4gICAqL1xuICBpZiAocy53cmFwID4gMCkgeyBzLndyYXAgPSAtcy53cmFwOyB9XG4gIC8qIHdyaXRlIHRoZSB0cmFpbGVyIG9ubHkgb25jZSEgKi9cbiAgcmV0dXJuIHMucGVuZGluZyAhPT0gMCA/IFpfT0sgOiBaX1NUUkVBTV9FTkQ7XG59XG5cbmZ1bmN0aW9uIGRlZmxhdGVFbmQoc3RybSkge1xuICB2YXIgc3RhdHVzO1xuXG4gIGlmICghc3RybS8qPT0gWl9OVUxMKi8gfHwgIXN0cm0uc3RhdGUvKj09IFpfTlVMTCovKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgc3RhdHVzID0gc3RybS5zdGF0ZS5zdGF0dXM7XG4gIGlmIChzdGF0dXMgIT09IElOSVRfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEVYVFJBX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBOQU1FX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBDT01NRU5UX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBIQ1JDX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBCVVNZX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBGSU5JU0hfU1RBVEVcbiAgKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUik7XG4gIH1cblxuICBzdHJtLnN0YXRlID0gbnVsbDtcblxuICByZXR1cm4gc3RhdHVzID09PSBCVVNZX1NUQVRFID8gZXJyKHN0cm0sIFpfREFUQV9FUlJPUikgOiBaX09LO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemVzIHRoZSBjb21wcmVzc2lvbiBkaWN0aW9uYXJ5IGZyb20gdGhlIGdpdmVuIGJ5dGVcbiAqIHNlcXVlbmNlIHdpdGhvdXQgcHJvZHVjaW5nIGFueSBjb21wcmVzc2VkIG91dHB1dC5cbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZVNldERpY3Rpb25hcnkoc3RybSwgZGljdGlvbmFyeSkge1xuICB2YXIgZGljdExlbmd0aCA9IGRpY3Rpb25hcnkubGVuZ3RoO1xuXG4gIHZhciBzO1xuICB2YXIgc3RyLCBuO1xuICB2YXIgd3JhcDtcbiAgdmFyIGF2YWlsO1xuICB2YXIgbmV4dDtcbiAgdmFyIGlucHV0O1xuICB2YXIgdG1wRGljdDtcblxuICBpZiAoIXN0cm0vKj09IFpfTlVMTCovIHx8ICFzdHJtLnN0YXRlLyo9PSBaX05VTEwqLykge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHMgPSBzdHJtLnN0YXRlO1xuICB3cmFwID0gcy53cmFwO1xuXG4gIGlmICh3cmFwID09PSAyIHx8ICh3cmFwID09PSAxICYmIHMuc3RhdHVzICE9PSBJTklUX1NUQVRFKSB8fCBzLmxvb2thaGVhZCkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIC8qIHdoZW4gdXNpbmcgemxpYiB3cmFwcGVycywgY29tcHV0ZSBBZGxlci0zMiBmb3IgcHJvdmlkZWQgZGljdGlvbmFyeSAqL1xuICBpZiAod3JhcCA9PT0gMSkge1xuICAgIC8qIGFkbGVyMzIoc3RybS0+YWRsZXIsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgpOyAqL1xuICAgIHN0cm0uYWRsZXIgPSBhZGxlcjMyKHN0cm0uYWRsZXIsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgsIDApO1xuICB9XG5cbiAgcy53cmFwID0gMDsgICAvKiBhdm9pZCBjb21wdXRpbmcgQWRsZXItMzIgaW4gcmVhZF9idWYgKi9cblxuICAvKiBpZiBkaWN0aW9uYXJ5IHdvdWxkIGZpbGwgd2luZG93LCBqdXN0IHJlcGxhY2UgdGhlIGhpc3RvcnkgKi9cbiAgaWYgKGRpY3RMZW5ndGggPj0gcy53X3NpemUpIHtcbiAgICBpZiAod3JhcCA9PT0gMCkgeyAgICAgICAgICAgIC8qIGFscmVhZHkgZW1wdHkgb3RoZXJ3aXNlICovXG4gICAgICAvKioqIENMRUFSX0hBU0gocyk7ICoqKi9cbiAgICAgIHplcm8ocy5oZWFkKTsgLy8gRmlsbCB3aXRoIE5JTCAoPSAwKTtcbiAgICAgIHMuc3Ryc3RhcnQgPSAwO1xuICAgICAgcy5ibG9ja19zdGFydCA9IDA7XG4gICAgICBzLmluc2VydCA9IDA7XG4gICAgfVxuICAgIC8qIHVzZSB0aGUgdGFpbCAqL1xuICAgIC8vIGRpY3Rpb25hcnkgPSBkaWN0aW9uYXJ5LnNsaWNlKGRpY3RMZW5ndGggLSBzLndfc2l6ZSk7XG4gICAgdG1wRGljdCA9IG5ldyB1dGlscy5CdWY4KHMud19zaXplKTtcbiAgICB1dGlscy5hcnJheVNldCh0bXBEaWN0LCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoIC0gcy53X3NpemUsIHMud19zaXplLCAwKTtcbiAgICBkaWN0aW9uYXJ5ID0gdG1wRGljdDtcbiAgICBkaWN0TGVuZ3RoID0gcy53X3NpemU7XG4gIH1cbiAgLyogaW5zZXJ0IGRpY3Rpb25hcnkgaW50byB3aW5kb3cgYW5kIGhhc2ggKi9cbiAgYXZhaWwgPSBzdHJtLmF2YWlsX2luO1xuICBuZXh0ID0gc3RybS5uZXh0X2luO1xuICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gIHN0cm0uYXZhaWxfaW4gPSBkaWN0TGVuZ3RoO1xuICBzdHJtLm5leHRfaW4gPSAwO1xuICBzdHJtLmlucHV0ID0gZGljdGlvbmFyeTtcbiAgZmlsbF93aW5kb3cocyk7XG4gIHdoaWxlIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICBzdHIgPSBzLnN0cnN0YXJ0O1xuICAgIG4gPSBzLmxvb2thaGVhZCAtIChNSU5fTUFUQ0ggLSAxKTtcbiAgICBkbyB7XG4gICAgICAvKiBVUERBVEVfSEFTSChzLCBzLT5pbnNfaCwgcy0+d2luZG93W3N0ciArIE1JTl9NQVRDSC0xXSk7ICovXG4gICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzdHIgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcblxuICAgICAgcy5wcmV2W3N0ciAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcblxuICAgICAgcy5oZWFkW3MuaW5zX2hdID0gc3RyO1xuICAgICAgc3RyKys7XG4gICAgfSB3aGlsZSAoLS1uKTtcbiAgICBzLnN0cnN0YXJ0ID0gc3RyO1xuICAgIHMubG9va2FoZWFkID0gTUlOX01BVENIIC0gMTtcbiAgICBmaWxsX3dpbmRvdyhzKTtcbiAgfVxuICBzLnN0cnN0YXJ0ICs9IHMubG9va2FoZWFkO1xuICBzLmJsb2NrX3N0YXJ0ID0gcy5zdHJzdGFydDtcbiAgcy5pbnNlcnQgPSBzLmxvb2thaGVhZDtcbiAgcy5sb29rYWhlYWQgPSAwO1xuICBzLm1hdGNoX2xlbmd0aCA9IHMucHJldl9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gIHN0cm0uaW5wdXQgPSBpbnB1dDtcbiAgc3RybS5hdmFpbF9pbiA9IGF2YWlsO1xuICBzLndyYXAgPSB3cmFwO1xuICByZXR1cm4gWl9PSztcbn1cblxuXG5leHBvcnRzLmRlZmxhdGVJbml0ID0gZGVmbGF0ZUluaXQ7XG5leHBvcnRzLmRlZmxhdGVJbml0MiA9IGRlZmxhdGVJbml0MjtcbmV4cG9ydHMuZGVmbGF0ZVJlc2V0ID0gZGVmbGF0ZVJlc2V0O1xuZXhwb3J0cy5kZWZsYXRlUmVzZXRLZWVwID0gZGVmbGF0ZVJlc2V0S2VlcDtcbmV4cG9ydHMuZGVmbGF0ZVNldEhlYWRlciA9IGRlZmxhdGVTZXRIZWFkZXI7XG5leHBvcnRzLmRlZmxhdGUgPSBkZWZsYXRlO1xuZXhwb3J0cy5kZWZsYXRlRW5kID0gZGVmbGF0ZUVuZDtcbmV4cG9ydHMuZGVmbGF0ZVNldERpY3Rpb25hcnkgPSBkZWZsYXRlU2V0RGljdGlvbmFyeTtcbmV4cG9ydHMuZGVmbGF0ZUluZm8gPSAncGFrbyBkZWZsYXRlIChmcm9tIE5vZGVjYSBwcm9qZWN0KSc7XG5cbi8qIE5vdCBpbXBsZW1lbnRlZFxuZXhwb3J0cy5kZWZsYXRlQm91bmQgPSBkZWZsYXRlQm91bmQ7XG5leHBvcnRzLmRlZmxhdGVDb3B5ID0gZGVmbGF0ZUNvcHk7XG5leHBvcnRzLmRlZmxhdGVQYXJhbXMgPSBkZWZsYXRlUGFyYW1zO1xuZXhwb3J0cy5kZWZsYXRlUGVuZGluZyA9IGRlZmxhdGVQZW5kaW5nO1xuZXhwb3J0cy5kZWZsYXRlUHJpbWUgPSBkZWZsYXRlUHJpbWU7XG5leHBvcnRzLmRlZmxhdGVUdW5lID0gZGVmbGF0ZVR1bmU7XG4qL1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2pzemlwL34vcGFrby9saWIvemxpYi9kZWZsYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports,__webpack_require__){"use strict";eval("\n\n\nfunction GZheader() {\n  /* true if compressed data believed to be text */\n  this.text       = 0;\n  /* modification time */\n  this.time       = 0;\n  /* extra flags (not used when writing a gzip file) */\n  this.xflags     = 0;\n  /* operating system */\n  this.os         = 0;\n  /* pointer to extra field or Z_NULL if none */\n  this.extra      = null;\n  /* extra field length (valid if extra != Z_NULL) */\n  this.extra_len  = 0; // Actually, we don't need it in JS,\n                       // but leave for few code modifications\n\n  //\n  // Setup limits is not necessary because in js we should not preallocate memory\n  // for inflate use constant limit in 65536 bytes\n  //\n\n  /* space at extra (only when reading header) */\n  // this.extra_max  = 0;\n  /* pointer to zero-terminated file name or Z_NULL */\n  this.name       = '';\n  /* space at name (only when reading header) */\n  // this.name_max   = 0;\n  /* pointer to zero-terminated comment or Z_NULL */\n  this.comment    = '';\n  /* space at comment (only when reading header) */\n  // this.comm_max   = 0;\n  /* true if there was or will be a header crc */\n  this.hcrc       = 0;\n  /* true when done reading gzip header (not used when writing a gzip file) */\n  this.done       = false;\n}\n\nmodule.exports = GZheader;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2pzemlwL34vcGFrby9saWIvemxpYi9nemhlYWRlci5qcz85OTI4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjExMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuXG5mdW5jdGlvbiBHWmhlYWRlcigpIHtcbiAgLyogdHJ1ZSBpZiBjb21wcmVzc2VkIGRhdGEgYmVsaWV2ZWQgdG8gYmUgdGV4dCAqL1xuICB0aGlzLnRleHQgICAgICAgPSAwO1xuICAvKiBtb2RpZmljYXRpb24gdGltZSAqL1xuICB0aGlzLnRpbWUgICAgICAgPSAwO1xuICAvKiBleHRyYSBmbGFncyAobm90IHVzZWQgd2hlbiB3cml0aW5nIGEgZ3ppcCBmaWxlKSAqL1xuICB0aGlzLnhmbGFncyAgICAgPSAwO1xuICAvKiBvcGVyYXRpbmcgc3lzdGVtICovXG4gIHRoaXMub3MgICAgICAgICA9IDA7XG4gIC8qIHBvaW50ZXIgdG8gZXh0cmEgZmllbGQgb3IgWl9OVUxMIGlmIG5vbmUgKi9cbiAgdGhpcy5leHRyYSAgICAgID0gbnVsbDtcbiAgLyogZXh0cmEgZmllbGQgbGVuZ3RoICh2YWxpZCBpZiBleHRyYSAhPSBaX05VTEwpICovXG4gIHRoaXMuZXh0cmFfbGVuICA9IDA7IC8vIEFjdHVhbGx5LCB3ZSBkb24ndCBuZWVkIGl0IGluIEpTLFxuICAgICAgICAgICAgICAgICAgICAgICAvLyBidXQgbGVhdmUgZm9yIGZldyBjb2RlIG1vZGlmaWNhdGlvbnNcblxuICAvL1xuICAvLyBTZXR1cCBsaW1pdHMgaXMgbm90IG5lY2Vzc2FyeSBiZWNhdXNlIGluIGpzIHdlIHNob3VsZCBub3QgcHJlYWxsb2NhdGUgbWVtb3J5XG4gIC8vIGZvciBpbmZsYXRlIHVzZSBjb25zdGFudCBsaW1pdCBpbiA2NTUzNiBieXRlc1xuICAvL1xuXG4gIC8qIHNwYWNlIGF0IGV4dHJhIChvbmx5IHdoZW4gcmVhZGluZyBoZWFkZXIpICovXG4gIC8vIHRoaXMuZXh0cmFfbWF4ICA9IDA7XG4gIC8qIHBvaW50ZXIgdG8gemVyby10ZXJtaW5hdGVkIGZpbGUgbmFtZSBvciBaX05VTEwgKi9cbiAgdGhpcy5uYW1lICAgICAgID0gJyc7XG4gIC8qIHNwYWNlIGF0IG5hbWUgKG9ubHkgd2hlbiByZWFkaW5nIGhlYWRlcikgKi9cbiAgLy8gdGhpcy5uYW1lX21heCAgID0gMDtcbiAgLyogcG9pbnRlciB0byB6ZXJvLXRlcm1pbmF0ZWQgY29tbWVudCBvciBaX05VTEwgKi9cbiAgdGhpcy5jb21tZW50ICAgID0gJyc7XG4gIC8qIHNwYWNlIGF0IGNvbW1lbnQgKG9ubHkgd2hlbiByZWFkaW5nIGhlYWRlcikgKi9cbiAgLy8gdGhpcy5jb21tX21heCAgID0gMDtcbiAgLyogdHJ1ZSBpZiB0aGVyZSB3YXMgb3Igd2lsbCBiZSBhIGhlYWRlciBjcmMgKi9cbiAgdGhpcy5oY3JjICAgICAgID0gMDtcbiAgLyogdHJ1ZSB3aGVuIGRvbmUgcmVhZGluZyBnemlwIGhlYWRlciAobm90IHVzZWQgd2hlbiB3cml0aW5nIGEgZ3ppcCBmaWxlKSAqL1xuICB0aGlzLmRvbmUgICAgICAgPSBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBHWmhlYWRlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9qc3ppcC9+L3Bha28vbGliL3psaWIvZ3poZWFkZXIuanNcbi8vIG1vZHVsZSBpZCA9IDExMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){"use strict";eval('\n\n// See state defs from inflate.js\nvar BAD = 30;       /* got a data error -- remain here until reset */\nvar TYPE = 12;      /* i: waiting for type bits, including last-flag bit */\n\n/*\n   Decode literal, length, and distance codes and write out the resulting\n   literal and match bytes until either not enough input or output is\n   available, an end-of-block is encountered, or a data error is encountered.\n   When large enough input and output buffers are supplied to inflate(), for\n   example, a 16K input buffer and a 64K output buffer, more than 95% of the\n   inflate execution time is spent in this routine.\n\n   Entry assumptions:\n\n        state.mode === LEN\n        strm.avail_in >= 6\n        strm.avail_out >= 258\n        start >= strm.avail_out\n        state.bits < 8\n\n   On return, state.mode is one of:\n\n        LEN -- ran out of enough output space or enough available input\n        TYPE -- reached end of block code, inflate() to interpret next block\n        BAD -- error in block data\n\n   Notes:\n\n    - The maximum input bits used by a length/distance pair is 15 bits for the\n      length code, 5 bits for the length extra, 15 bits for the distance code,\n      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.\n      Therefore if strm.avail_in >= 6, then there is enough input to avoid\n      checking for available input while decoding.\n\n    - The maximum bytes that a single length/distance pair can output is 258\n      bytes, which is the maximum length that can be coded.  inflate_fast()\n      requires strm.avail_out >= 258 for each loop to avoid checking for\n      output space.\n */\nmodule.exports = function inflate_fast(strm, start) {\n  var state;\n  var _in;                    /* local strm.input */\n  var last;                   /* have enough input while in < last */\n  var _out;                   /* local strm.output */\n  var beg;                    /* inflate()\'s initial strm.output */\n  var end;                    /* while out < end, enough space available */\n//#ifdef INFLATE_STRICT\n  var dmax;                   /* maximum distance from zlib header */\n//#endif\n  var wsize;                  /* window size or zero if not using window */\n  var whave;                  /* valid bytes in the window */\n  var wnext;                  /* window write index */\n  // Use `s_window` instead `window`, avoid conflict with instrumentation tools\n  var s_window;               /* allocated sliding window, if wsize != 0 */\n  var hold;                   /* local strm.hold */\n  var bits;                   /* local strm.bits */\n  var lcode;                  /* local strm.lencode */\n  var dcode;                  /* local strm.distcode */\n  var lmask;                  /* mask for first level of length codes */\n  var dmask;                  /* mask for first level of distance codes */\n  var here;                   /* retrieved table entry */\n  var op;                     /* code bits, operation, extra bits, or */\n                              /*  window position, window bytes to copy */\n  var len;                    /* match length, unused bytes */\n  var dist;                   /* match distance */\n  var from;                   /* where to copy match from */\n  var from_source;\n\n\n  var input, output; // JS specific, because we have no pointers\n\n  /* copy state to local variables */\n  state = strm.state;\n  //here = state.here;\n  _in = strm.next_in;\n  input = strm.input;\n  last = _in + (strm.avail_in - 5);\n  _out = strm.next_out;\n  output = strm.output;\n  beg = _out - (start - strm.avail_out);\n  end = _out + (strm.avail_out - 257);\n//#ifdef INFLATE_STRICT\n  dmax = state.dmax;\n//#endif\n  wsize = state.wsize;\n  whave = state.whave;\n  wnext = state.wnext;\n  s_window = state.window;\n  hold = state.hold;\n  bits = state.bits;\n  lcode = state.lencode;\n  dcode = state.distcode;\n  lmask = (1 << state.lenbits) - 1;\n  dmask = (1 << state.distbits) - 1;\n\n\n  /* decode literals and length/distances until end-of-block or not enough\n     input data or output space */\n\n  top:\n  do {\n    if (bits < 15) {\n      hold += input[_in++] << bits;\n      bits += 8;\n      hold += input[_in++] << bits;\n      bits += 8;\n    }\n\n    here = lcode[hold & lmask];\n\n    dolen:\n    for (;;) { // Goto emulation\n      op = here >>> 24/*here.bits*/;\n      hold >>>= op;\n      bits -= op;\n      op = (here >>> 16) & 0xff/*here.op*/;\n      if (op === 0) {                          /* literal */\n        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n        //        "inflate:         literal \'%c\'\\n" :\n        //        "inflate:         literal 0x%02x\\n", here.val));\n        output[_out++] = here & 0xffff/*here.val*/;\n      }\n      else if (op & 16) {                     /* length base */\n        len = here & 0xffff/*here.val*/;\n        op &= 15;                           /* number of extra bits */\n        if (op) {\n          if (bits < op) {\n            hold += input[_in++] << bits;\n            bits += 8;\n          }\n          len += hold & ((1 << op) - 1);\n          hold >>>= op;\n          bits -= op;\n        }\n        //Tracevv((stderr, "inflate:         length %u\\n", len));\n        if (bits < 15) {\n          hold += input[_in++] << bits;\n          bits += 8;\n          hold += input[_in++] << bits;\n          bits += 8;\n        }\n        here = dcode[hold & dmask];\n\n        dodist:\n        for (;;) { // goto emulation\n          op = here >>> 24/*here.bits*/;\n          hold >>>= op;\n          bits -= op;\n          op = (here >>> 16) & 0xff/*here.op*/;\n\n          if (op & 16) {                      /* distance base */\n            dist = here & 0xffff/*here.val*/;\n            op &= 15;                       /* number of extra bits */\n            if (bits < op) {\n              hold += input[_in++] << bits;\n              bits += 8;\n              if (bits < op) {\n                hold += input[_in++] << bits;\n                bits += 8;\n              }\n            }\n            dist += hold & ((1 << op) - 1);\n//#ifdef INFLATE_STRICT\n            if (dist > dmax) {\n              strm.msg = \'invalid distance too far back\';\n              state.mode = BAD;\n              break top;\n            }\n//#endif\n            hold >>>= op;\n            bits -= op;\n            //Tracevv((stderr, "inflate:         distance %u\\n", dist));\n            op = _out - beg;                /* max distance in output */\n            if (dist > op) {                /* see if copy from window */\n              op = dist - op;               /* distance back in window */\n              if (op > whave) {\n                if (state.sane) {\n                  strm.msg = \'invalid distance too far back\';\n                  state.mode = BAD;\n                  break top;\n                }\n\n// (!) This block is disabled in zlib defailts,\n// don\'t enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//                if (len <= op - whave) {\n//                  do {\n//                    output[_out++] = 0;\n//                  } while (--len);\n//                  continue top;\n//                }\n//                len -= op - whave;\n//                do {\n//                  output[_out++] = 0;\n//                } while (--op > whave);\n//                if (op === 0) {\n//                  from = _out - dist;\n//                  do {\n//                    output[_out++] = output[from++];\n//                  } while (--len);\n//                  continue top;\n//                }\n//#endif\n              }\n              from = 0; // window index\n              from_source = s_window;\n              if (wnext === 0) {           /* very common case */\n                from += wsize - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              else if (wnext < op) {      /* wrap around window */\n                from += wsize + wnext - op;\n                op -= wnext;\n                if (op < len) {         /* some from end of window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = 0;\n                  if (wnext < len) {  /* some from start of window */\n                    op = wnext;\n                    len -= op;\n                    do {\n                      output[_out++] = s_window[from++];\n                    } while (--op);\n                    from = _out - dist;      /* rest from output */\n                    from_source = output;\n                  }\n                }\n              }\n              else {                      /* contiguous in window */\n                from += wnext - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              while (len > 2) {\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                len -= 3;\n              }\n              if (len) {\n                output[_out++] = from_source[from++];\n                if (len > 1) {\n                  output[_out++] = from_source[from++];\n                }\n              }\n            }\n            else {\n              from = _out - dist;          /* copy direct from output */\n              do {                        /* minimum length is three */\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                len -= 3;\n              } while (len > 2);\n              if (len) {\n                output[_out++] = output[from++];\n                if (len > 1) {\n                  output[_out++] = output[from++];\n                }\n              }\n            }\n          }\n          else if ((op & 64) === 0) {          /* 2nd level distance code */\n            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n            continue dodist;\n          }\n          else {\n            strm.msg = \'invalid distance code\';\n            state.mode = BAD;\n            break top;\n          }\n\n          break; // need to emulate goto via "continue"\n        }\n      }\n      else if ((op & 64) === 0) {              /* 2nd level length code */\n        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n        continue dolen;\n      }\n      else if (op & 32) {                     /* end-of-block */\n        //Tracevv((stderr, "inflate:         end of block\\n"));\n        state.mode = TYPE;\n        break top;\n      }\n      else {\n        strm.msg = \'invalid literal/length code\';\n        state.mode = BAD;\n        break top;\n      }\n\n      break; // need to emulate goto via "continue"\n    }\n  } while (_in < last && _out < end);\n\n  /* return unused bytes (on entry, bits < 8, so in won\'t go too far back) */\n  len = bits >> 3;\n  _in -= len;\n  bits -= len << 3;\n  hold &= (1 << bits) - 1;\n\n  /* update state and return */\n  strm.next_in = _in;\n  strm.next_out = _out;\n  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));\n  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));\n  state.hold = hold;\n  state.bits = bits;\n  return;\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2pzemlwL34vcGFrby9saWIvemxpYi9pbmZmYXN0LmpzPzAxMDUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQSxhQUFhO0FBQ2IsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFdBQVc7QUFDWCxXQUFXO0FBQ1gsVUFBVTtBQUNWLFVBQVU7QUFDVjtBQUNBLFdBQVc7QUFDWDtBQUNBLFlBQVk7QUFDWixZQUFZO0FBQ1osWUFBWTtBQUNaO0FBQ0EsZUFBZTtBQUNmLFdBQVc7QUFDWCxXQUFXO0FBQ1gsWUFBWTtBQUNaLFlBQVk7QUFDWixZQUFZO0FBQ1osWUFBWTtBQUNaLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQSxVQUFVO0FBQ1YsV0FBVztBQUNYLFdBQVc7QUFDWDs7O0FBR0Esb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLEdBQUc7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCO0FBQ3hCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLDRCQUE0QjtBQUM1Qiw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVk7QUFDWjtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTExLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vLyBTZWUgc3RhdGUgZGVmcyBmcm9tIGluZmxhdGUuanNcbnZhciBCQUQgPSAzMDsgICAgICAgLyogZ290IGEgZGF0YSBlcnJvciAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xudmFyIFRZUEUgPSAxMjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciB0eXBlIGJpdHMsIGluY2x1ZGluZyBsYXN0LWZsYWcgYml0ICovXG5cbi8qXG4gICBEZWNvZGUgbGl0ZXJhbCwgbGVuZ3RoLCBhbmQgZGlzdGFuY2UgY29kZXMgYW5kIHdyaXRlIG91dCB0aGUgcmVzdWx0aW5nXG4gICBsaXRlcmFsIGFuZCBtYXRjaCBieXRlcyB1bnRpbCBlaXRoZXIgbm90IGVub3VnaCBpbnB1dCBvciBvdXRwdXQgaXNcbiAgIGF2YWlsYWJsZSwgYW4gZW5kLW9mLWJsb2NrIGlzIGVuY291bnRlcmVkLCBvciBhIGRhdGEgZXJyb3IgaXMgZW5jb3VudGVyZWQuXG4gICBXaGVuIGxhcmdlIGVub3VnaCBpbnB1dCBhbmQgb3V0cHV0IGJ1ZmZlcnMgYXJlIHN1cHBsaWVkIHRvIGluZmxhdGUoKSwgZm9yXG4gICBleGFtcGxlLCBhIDE2SyBpbnB1dCBidWZmZXIgYW5kIGEgNjRLIG91dHB1dCBidWZmZXIsIG1vcmUgdGhhbiA5NSUgb2YgdGhlXG4gICBpbmZsYXRlIGV4ZWN1dGlvbiB0aW1lIGlzIHNwZW50IGluIHRoaXMgcm91dGluZS5cblxuICAgRW50cnkgYXNzdW1wdGlvbnM6XG5cbiAgICAgICAgc3RhdGUubW9kZSA9PT0gTEVOXG4gICAgICAgIHN0cm0uYXZhaWxfaW4gPj0gNlxuICAgICAgICBzdHJtLmF2YWlsX291dCA+PSAyNThcbiAgICAgICAgc3RhcnQgPj0gc3RybS5hdmFpbF9vdXRcbiAgICAgICAgc3RhdGUuYml0cyA8IDhcblxuICAgT24gcmV0dXJuLCBzdGF0ZS5tb2RlIGlzIG9uZSBvZjpcblxuICAgICAgICBMRU4gLS0gcmFuIG91dCBvZiBlbm91Z2ggb3V0cHV0IHNwYWNlIG9yIGVub3VnaCBhdmFpbGFibGUgaW5wdXRcbiAgICAgICAgVFlQRSAtLSByZWFjaGVkIGVuZCBvZiBibG9jayBjb2RlLCBpbmZsYXRlKCkgdG8gaW50ZXJwcmV0IG5leHQgYmxvY2tcbiAgICAgICAgQkFEIC0tIGVycm9yIGluIGJsb2NrIGRhdGFcblxuICAgTm90ZXM6XG5cbiAgICAtIFRoZSBtYXhpbXVtIGlucHV0IGJpdHMgdXNlZCBieSBhIGxlbmd0aC9kaXN0YW5jZSBwYWlyIGlzIDE1IGJpdHMgZm9yIHRoZVxuICAgICAgbGVuZ3RoIGNvZGUsIDUgYml0cyBmb3IgdGhlIGxlbmd0aCBleHRyYSwgMTUgYml0cyBmb3IgdGhlIGRpc3RhbmNlIGNvZGUsXG4gICAgICBhbmQgMTMgYml0cyBmb3IgdGhlIGRpc3RhbmNlIGV4dHJhLiAgVGhpcyB0b3RhbHMgNDggYml0cywgb3Igc2l4IGJ5dGVzLlxuICAgICAgVGhlcmVmb3JlIGlmIHN0cm0uYXZhaWxfaW4gPj0gNiwgdGhlbiB0aGVyZSBpcyBlbm91Z2ggaW5wdXQgdG8gYXZvaWRcbiAgICAgIGNoZWNraW5nIGZvciBhdmFpbGFibGUgaW5wdXQgd2hpbGUgZGVjb2RpbmcuXG5cbiAgICAtIFRoZSBtYXhpbXVtIGJ5dGVzIHRoYXQgYSBzaW5nbGUgbGVuZ3RoL2Rpc3RhbmNlIHBhaXIgY2FuIG91dHB1dCBpcyAyNThcbiAgICAgIGJ5dGVzLCB3aGljaCBpcyB0aGUgbWF4aW11bSBsZW5ndGggdGhhdCBjYW4gYmUgY29kZWQuICBpbmZsYXRlX2Zhc3QoKVxuICAgICAgcmVxdWlyZXMgc3RybS5hdmFpbF9vdXQgPj0gMjU4IGZvciBlYWNoIGxvb3AgdG8gYXZvaWQgY2hlY2tpbmcgZm9yXG4gICAgICBvdXRwdXQgc3BhY2UuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5mbGF0ZV9mYXN0KHN0cm0sIHN0YXJ0KSB7XG4gIHZhciBzdGF0ZTtcbiAgdmFyIF9pbjsgICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uaW5wdXQgKi9cbiAgdmFyIGxhc3Q7ICAgICAgICAgICAgICAgICAgIC8qIGhhdmUgZW5vdWdoIGlucHV0IHdoaWxlIGluIDwgbGFzdCAqL1xuICB2YXIgX291dDsgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5vdXRwdXQgKi9cbiAgdmFyIGJlZzsgICAgICAgICAgICAgICAgICAgIC8qIGluZmxhdGUoKSdzIGluaXRpYWwgc3RybS5vdXRwdXQgKi9cbiAgdmFyIGVuZDsgICAgICAgICAgICAgICAgICAgIC8qIHdoaWxlIG91dCA8IGVuZCwgZW5vdWdoIHNwYWNlIGF2YWlsYWJsZSAqL1xuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgdmFyIGRtYXg7ICAgICAgICAgICAgICAgICAgIC8qIG1heGltdW0gZGlzdGFuY2UgZnJvbSB6bGliIGhlYWRlciAqL1xuLy8jZW5kaWZcbiAgdmFyIHdzaXplOyAgICAgICAgICAgICAgICAgIC8qIHdpbmRvdyBzaXplIG9yIHplcm8gaWYgbm90IHVzaW5nIHdpbmRvdyAqL1xuICB2YXIgd2hhdmU7ICAgICAgICAgICAgICAgICAgLyogdmFsaWQgYnl0ZXMgaW4gdGhlIHdpbmRvdyAqL1xuICB2YXIgd25leHQ7ICAgICAgICAgICAgICAgICAgLyogd2luZG93IHdyaXRlIGluZGV4ICovXG4gIC8vIFVzZSBgc193aW5kb3dgIGluc3RlYWQgYHdpbmRvd2AsIGF2b2lkIGNvbmZsaWN0IHdpdGggaW5zdHJ1bWVudGF0aW9uIHRvb2xzXG4gIHZhciBzX3dpbmRvdzsgICAgICAgICAgICAgICAvKiBhbGxvY2F0ZWQgc2xpZGluZyB3aW5kb3csIGlmIHdzaXplICE9IDAgKi9cbiAgdmFyIGhvbGQ7ICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uaG9sZCAqL1xuICB2YXIgYml0czsgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5iaXRzICovXG4gIHZhciBsY29kZTsgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmxlbmNvZGUgKi9cbiAgdmFyIGRjb2RlOyAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uZGlzdGNvZGUgKi9cbiAgdmFyIGxtYXNrOyAgICAgICAgICAgICAgICAgIC8qIG1hc2sgZm9yIGZpcnN0IGxldmVsIG9mIGxlbmd0aCBjb2RlcyAqL1xuICB2YXIgZG1hc2s7ICAgICAgICAgICAgICAgICAgLyogbWFzayBmb3IgZmlyc3QgbGV2ZWwgb2YgZGlzdGFuY2UgY29kZXMgKi9cbiAgdmFyIGhlcmU7ICAgICAgICAgICAgICAgICAgIC8qIHJldHJpZXZlZCB0YWJsZSBlbnRyeSAqL1xuICB2YXIgb3A7ICAgICAgICAgICAgICAgICAgICAgLyogY29kZSBiaXRzLCBvcGVyYXRpb24sIGV4dHJhIGJpdHMsIG9yICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgd2luZG93IHBvc2l0aW9uLCB3aW5kb3cgYnl0ZXMgdG8gY29weSAqL1xuICB2YXIgbGVuOyAgICAgICAgICAgICAgICAgICAgLyogbWF0Y2ggbGVuZ3RoLCB1bnVzZWQgYnl0ZXMgKi9cbiAgdmFyIGRpc3Q7ICAgICAgICAgICAgICAgICAgIC8qIG1hdGNoIGRpc3RhbmNlICovXG4gIHZhciBmcm9tOyAgICAgICAgICAgICAgICAgICAvKiB3aGVyZSB0byBjb3B5IG1hdGNoIGZyb20gKi9cbiAgdmFyIGZyb21fc291cmNlO1xuXG5cbiAgdmFyIGlucHV0LCBvdXRwdXQ7IC8vIEpTIHNwZWNpZmljLCBiZWNhdXNlIHdlIGhhdmUgbm8gcG9pbnRlcnNcblxuICAvKiBjb3B5IHN0YXRlIHRvIGxvY2FsIHZhcmlhYmxlcyAqL1xuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIC8vaGVyZSA9IHN0YXRlLmhlcmU7XG4gIF9pbiA9IHN0cm0ubmV4dF9pbjtcbiAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICBsYXN0ID0gX2luICsgKHN0cm0uYXZhaWxfaW4gLSA1KTtcbiAgX291dCA9IHN0cm0ubmV4dF9vdXQ7XG4gIG91dHB1dCA9IHN0cm0ub3V0cHV0O1xuICBiZWcgPSBfb3V0IC0gKHN0YXJ0IC0gc3RybS5hdmFpbF9vdXQpO1xuICBlbmQgPSBfb3V0ICsgKHN0cm0uYXZhaWxfb3V0IC0gMjU3KTtcbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gIGRtYXggPSBzdGF0ZS5kbWF4O1xuLy8jZW5kaWZcbiAgd3NpemUgPSBzdGF0ZS53c2l6ZTtcbiAgd2hhdmUgPSBzdGF0ZS53aGF2ZTtcbiAgd25leHQgPSBzdGF0ZS53bmV4dDtcbiAgc193aW5kb3cgPSBzdGF0ZS53aW5kb3c7XG4gIGhvbGQgPSBzdGF0ZS5ob2xkO1xuICBiaXRzID0gc3RhdGUuYml0cztcbiAgbGNvZGUgPSBzdGF0ZS5sZW5jb2RlO1xuICBkY29kZSA9IHN0YXRlLmRpc3Rjb2RlO1xuICBsbWFzayA9ICgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMTtcbiAgZG1hc2sgPSAoMSA8PCBzdGF0ZS5kaXN0Yml0cykgLSAxO1xuXG5cbiAgLyogZGVjb2RlIGxpdGVyYWxzIGFuZCBsZW5ndGgvZGlzdGFuY2VzIHVudGlsIGVuZC1vZi1ibG9jayBvciBub3QgZW5vdWdoXG4gICAgIGlucHV0IGRhdGEgb3Igb3V0cHV0IHNwYWNlICovXG5cbiAgdG9wOlxuICBkbyB7XG4gICAgaWYgKGJpdHMgPCAxNSkge1xuICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgIGJpdHMgKz0gODtcbiAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICBiaXRzICs9IDg7XG4gICAgfVxuXG4gICAgaGVyZSA9IGxjb2RlW2hvbGQgJiBsbWFza107XG5cbiAgICBkb2xlbjpcbiAgICBmb3IgKDs7KSB7IC8vIEdvdG8gZW11bGF0aW9uXG4gICAgICBvcCA9IGhlcmUgPj4+IDI0LypoZXJlLmJpdHMqLztcbiAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgIGJpdHMgLT0gb3A7XG4gICAgICBvcCA9IChoZXJlID4+PiAxNikgJiAweGZmLypoZXJlLm9wKi87XG4gICAgICBpZiAob3AgPT09IDApIHsgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGxpdGVyYWwgKi9cbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIGhlcmUudmFsID49IDB4MjAgJiYgaGVyZS52YWwgPCAweDdmID9cbiAgICAgICAgLy8gICAgICAgIFwiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsICclYydcXG5cIiA6XG4gICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAweCUwMnhcXG5cIiwgaGVyZS52YWwpKTtcbiAgICAgICAgb3V0cHV0W19vdXQrK10gPSBoZXJlICYgMHhmZmZmLypoZXJlLnZhbCovO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob3AgJiAxNikgeyAgICAgICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBiYXNlICovXG4gICAgICAgIGxlbiA9IGhlcmUgJiAweGZmZmYvKmhlcmUudmFsKi87XG4gICAgICAgIG9wICY9IDE1OyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBleHRyYSBiaXRzICovXG4gICAgICAgIGlmIChvcCkge1xuICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxlbiArPSBob2xkICYgKCgxIDw8IG9wKSAtIDEpO1xuICAgICAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgICAgICBiaXRzIC09IG9wO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgbGVuZ3RoICV1XFxuXCIsIGxlbikpO1xuICAgICAgICBpZiAoYml0cyA8IDE1KSB7XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgaGVyZSA9IGRjb2RlW2hvbGQgJiBkbWFza107XG5cbiAgICAgICAgZG9kaXN0OlxuICAgICAgICBmb3IgKDs7KSB7IC8vIGdvdG8gZW11bGF0aW9uXG4gICAgICAgICAgb3AgPSBoZXJlID4+PiAyNC8qaGVyZS5iaXRzKi87XG4gICAgICAgICAgaG9sZCA+Pj49IG9wO1xuICAgICAgICAgIGJpdHMgLT0gb3A7XG4gICAgICAgICAgb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZi8qaGVyZS5vcCovO1xuXG4gICAgICAgICAgaWYgKG9wICYgMTYpIHsgICAgICAgICAgICAgICAgICAgICAgLyogZGlzdGFuY2UgYmFzZSAqL1xuICAgICAgICAgICAgZGlzdCA9IGhlcmUgJiAweGZmZmYvKmhlcmUudmFsKi87XG4gICAgICAgICAgICBvcCAmPSAxNTsgICAgICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBleHRyYSBiaXRzICovXG4gICAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7XG4gICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgaWYgKGJpdHMgPCBvcCkge1xuICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXN0ICs9IGhvbGQgJiAoKDEgPDwgb3ApIC0gMSk7XG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICAgICAgICAgICAgaWYgKGRpc3QgPiBkbWF4KSB7XG4gICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgICAgICAgIGJpdHMgLT0gb3A7XG4gICAgICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGRpc3RhbmNlICV1XFxuXCIsIGRpc3QpKTtcbiAgICAgICAgICAgIG9wID0gX291dCAtIGJlZzsgICAgICAgICAgICAgICAgLyogbWF4IGRpc3RhbmNlIGluIG91dHB1dCAqL1xuICAgICAgICAgICAgaWYgKGRpc3QgPiBvcCkgeyAgICAgICAgICAgICAgICAvKiBzZWUgaWYgY29weSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICAgICAgICBvcCA9IGRpc3QgLSBvcDsgICAgICAgICAgICAgICAvKiBkaXN0YW5jZSBiYWNrIGluIHdpbmRvdyAqL1xuICAgICAgICAgICAgICBpZiAob3AgPiB3aGF2ZSkge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5zYW5lKSB7XG4gICAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgICAgICAgICAgIH1cblxuLy8gKCEpIFRoaXMgYmxvY2sgaXMgZGlzYWJsZWQgaW4gemxpYiBkZWZhaWx0cyxcbi8vIGRvbid0IGVuYWJsZSBpdCBmb3IgYmluYXJ5IGNvbXBhdGliaWxpdHlcbi8vI2lmZGVmIElORkxBVEVfQUxMT1dfSU5WQUxJRF9ESVNUQU5DRV9UT09GQVJfQVJSUlxuLy8gICAgICAgICAgICAgICAgaWYgKGxlbiA8PSBvcCAtIHdoYXZlKSB7XG4vLyAgICAgICAgICAgICAgICAgIGRvIHtcbi8vICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IDA7XG4vLyAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tbGVuKTtcbi8vICAgICAgICAgICAgICAgICAgY29udGludWUgdG9wO1xuLy8gICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgbGVuIC09IG9wIC0gd2hhdmU7XG4vLyAgICAgICAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gMDtcbi8vICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3AgPiB3aGF2ZSk7XG4vLyAgICAgICAgICAgICAgICBpZiAob3AgPT09IDApIHtcbi8vICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0O1xuLy8gICAgICAgICAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbi8vICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1sZW4pO1xuLy8gICAgICAgICAgICAgICAgICBjb250aW51ZSB0b3A7XG4vLyAgICAgICAgICAgICAgICB9XG4vLyNlbmRpZlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZyb20gPSAwOyAvLyB3aW5kb3cgaW5kZXhcbiAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBzX3dpbmRvdztcbiAgICAgICAgICAgICAgaWYgKHduZXh0ID09PSAwKSB7ICAgICAgICAgICAvKiB2ZXJ5IGNvbW1vbiBjYXNlICovXG4gICAgICAgICAgICAgICAgZnJvbSArPSB3c2l6ZSAtIG9wO1xuICAgICAgICAgICAgICAgIGlmIChvcCA8IGxlbikgeyAgICAgICAgIC8qIHNvbWUgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdO1xuICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAvKiByZXN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAod25leHQgPCBvcCkgeyAgICAgIC8qIHdyYXAgYXJvdW5kIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgIGZyb20gKz0gd3NpemUgKyB3bmV4dCAtIG9wO1xuICAgICAgICAgICAgICAgIG9wIC09IHduZXh0O1xuICAgICAgICAgICAgICAgIGlmIChvcCA8IGxlbikgeyAgICAgICAgIC8qIHNvbWUgZnJvbSBlbmQgb2Ygd2luZG93ICovXG4gICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgZnJvbSA9IDA7XG4gICAgICAgICAgICAgICAgICBpZiAod25leHQgPCBsZW4pIHsgIC8qIHNvbWUgZnJvbSBzdGFydCBvZiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICAgICAgb3AgPSB3bmV4dDtcbiAgICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdO1xuICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgICAgIC8qIHJlc3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAvKiBjb250aWd1b3VzIGluIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgIGZyb20gKz0gd25leHQgLSBvcDtcbiAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gd2luZG93ICovXG4gICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgLyogcmVzdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdoaWxlIChsZW4gPiAyKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgbGVuIC09IDM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBpZiAobGVuID4gMSkge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgICAgICAgICAgLyogY29weSBkaXJlY3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgZG8geyAgICAgICAgICAgICAgICAgICAgICAgIC8qIG1pbmltdW0gbGVuZ3RoIGlzIHRocmVlICovXG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgbGVuIC09IDM7XG4gICAgICAgICAgICAgIH0gd2hpbGUgKGxlbiA+IDIpO1xuICAgICAgICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBpZiAobGVuID4gMSkge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoKG9wICYgNjQpID09PSAwKSB7ICAgICAgICAgIC8qIDJuZCBsZXZlbCBkaXN0YW5jZSBjb2RlICovXG4gICAgICAgICAgICBoZXJlID0gZGNvZGVbKGhlcmUgJiAweGZmZmYpLypoZXJlLnZhbCovICsgKGhvbGQgJiAoKDEgPDwgb3ApIC0gMSkpXTtcbiAgICAgICAgICAgIGNvbnRpbnVlIGRvZGlzdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIGNvZGUnO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhazsgLy8gbmVlZCB0byBlbXVsYXRlIGdvdG8gdmlhIFwiY29udGludWVcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmICgob3AgJiA2NCkgPT09IDApIHsgICAgICAgICAgICAgIC8qIDJuZCBsZXZlbCBsZW5ndGggY29kZSAqL1xuICAgICAgICBoZXJlID0gbGNvZGVbKGhlcmUgJiAweGZmZmYpLypoZXJlLnZhbCovICsgKGhvbGQgJiAoKDEgPDwgb3ApIC0gMSkpXTtcbiAgICAgICAgY29udGludWUgZG9sZW47XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvcCAmIDMyKSB7ICAgICAgICAgICAgICAgICAgICAgLyogZW5kLW9mLWJsb2NrICovXG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZW5kIG9mIGJsb2NrXFxuXCIpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgIGJyZWFrIHRvcDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGUnO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhayB0b3A7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrOyAvLyBuZWVkIHRvIGVtdWxhdGUgZ290byB2aWEgXCJjb250aW51ZVwiXG4gICAgfVxuICB9IHdoaWxlIChfaW4gPCBsYXN0ICYmIF9vdXQgPCBlbmQpO1xuXG4gIC8qIHJldHVybiB1bnVzZWQgYnl0ZXMgKG9uIGVudHJ5LCBiaXRzIDwgOCwgc28gaW4gd29uJ3QgZ28gdG9vIGZhciBiYWNrKSAqL1xuICBsZW4gPSBiaXRzID4+IDM7XG4gIF9pbiAtPSBsZW47XG4gIGJpdHMgLT0gbGVuIDw8IDM7XG4gIGhvbGQgJj0gKDEgPDwgYml0cykgLSAxO1xuXG4gIC8qIHVwZGF0ZSBzdGF0ZSBhbmQgcmV0dXJuICovXG4gIHN0cm0ubmV4dF9pbiA9IF9pbjtcbiAgc3RybS5uZXh0X291dCA9IF9vdXQ7XG4gIHN0cm0uYXZhaWxfaW4gPSAoX2luIDwgbGFzdCA/IDUgKyAobGFzdCAtIF9pbikgOiA1IC0gKF9pbiAtIGxhc3QpKTtcbiAgc3RybS5hdmFpbF9vdXQgPSAoX291dCA8IGVuZCA/IDI1NyArIChlbmQgLSBfb3V0KSA6IDI1NyAtIChfb3V0IC0gZW5kKSk7XG4gIHN0YXRlLmhvbGQgPSBob2xkO1xuICBzdGF0ZS5iaXRzID0gYml0cztcbiAgcmV0dXJuO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9qc3ppcC9+L3Bha28vbGliL3psaWIvaW5mZmFzdC5qc1xuLy8gbW9kdWxlIGlkID0gMTExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,exports,__webpack_require__){"use strict";eval("\n\n\nvar utils         = __webpack_require__(3);\nvar adler32       = __webpack_require__(50);\nvar crc32         = __webpack_require__(52);\nvar inflate_fast  = __webpack_require__(111);\nvar inflate_table = __webpack_require__(113);\n\nvar CODES = 0;\nvar LENS = 1;\nvar DISTS = 2;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n/* Allowed flush values; see deflate() and inflate() below for details */\n//var Z_NO_FLUSH      = 0;\n//var Z_PARTIAL_FLUSH = 1;\n//var Z_SYNC_FLUSH    = 2;\n//var Z_FULL_FLUSH    = 3;\nvar Z_FINISH        = 4;\nvar Z_BLOCK         = 5;\nvar Z_TREES         = 6;\n\n\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\nvar Z_NEED_DICT     = 2;\n//var Z_ERRNO         = -1;\nvar Z_STREAM_ERROR  = -2;\nvar Z_DATA_ERROR    = -3;\nvar Z_MEM_ERROR     = -4;\nvar Z_BUF_ERROR     = -5;\n//var Z_VERSION_ERROR = -6;\n\n/* The deflate compression method */\nvar Z_DEFLATED  = 8;\n\n\n/* STATES ====================================================================*/\n/* ===========================================================================*/\n\n\nvar    HEAD = 1;       /* i: waiting for magic header */\nvar    FLAGS = 2;      /* i: waiting for method and flags (gzip) */\nvar    TIME = 3;       /* i: waiting for modification time (gzip) */\nvar    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */\nvar    EXLEN = 5;      /* i: waiting for extra length (gzip) */\nvar    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */\nvar    NAME = 7;       /* i: waiting for end of file name (gzip) */\nvar    COMMENT = 8;    /* i: waiting for end of comment (gzip) */\nvar    HCRC = 9;       /* i: waiting for header crc (gzip) */\nvar    DICTID = 10;    /* i: waiting for dictionary check value */\nvar    DICT = 11;      /* waiting for inflateSetDictionary() call */\nvar        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */\nvar        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */\nvar        STORED = 14;    /* i: waiting for stored size (length and complement) */\nvar        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */\nvar        COPY = 16;      /* i/o: waiting for input or output to copy stored block */\nvar        TABLE = 17;     /* i: waiting for dynamic block table lengths */\nvar        LENLENS = 18;   /* i: waiting for code length code lengths */\nvar        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */\nvar            LEN_ = 20;      /* i: same as LEN below, but only first time in */\nvar            LEN = 21;       /* i: waiting for length/lit/eob code */\nvar            LENEXT = 22;    /* i: waiting for length extra bits */\nvar            DIST = 23;      /* i: waiting for distance code */\nvar            DISTEXT = 24;   /* i: waiting for distance extra bits */\nvar            MATCH = 25;     /* o: waiting for output space to copy string */\nvar            LIT = 26;       /* o: waiting for output space to write literal */\nvar    CHECK = 27;     /* i: waiting for 32-bit check value */\nvar    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */\nvar    DONE = 29;      /* finished check, done -- remain here until reset */\nvar    BAD = 30;       /* got a data error -- remain here until reset */\nvar    MEM = 31;       /* got an inflate() memory error -- remain here until reset */\nvar    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */\n\n/* ===========================================================================*/\n\n\n\nvar ENOUGH_LENS = 852;\nvar ENOUGH_DISTS = 592;\n//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);\n\nvar MAX_WBITS = 15;\n/* 32K LZ77 window */\nvar DEF_WBITS = MAX_WBITS;\n\n\nfunction zswap32(q) {\n  return  (((q >>> 24) & 0xff) +\n          ((q >>> 8) & 0xff00) +\n          ((q & 0xff00) << 8) +\n          ((q & 0xff) << 24));\n}\n\n\nfunction InflateState() {\n  this.mode = 0;             /* current inflate mode */\n  this.last = false;          /* true if processing last block */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.havedict = false;      /* true if dictionary provided */\n  this.flags = 0;             /* gzip header method and flags (0 if zlib) */\n  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */\n  this.check = 0;             /* protected copy of check value */\n  this.total = 0;             /* protected copy of output count */\n  // TODO: may be {}\n  this.head = null;           /* where to save gzip header information */\n\n  /* sliding window */\n  this.wbits = 0;             /* log base 2 of requested window size */\n  this.wsize = 0;             /* window size or zero if not using window */\n  this.whave = 0;             /* valid bytes in the window */\n  this.wnext = 0;             /* window write index */\n  this.window = null;         /* allocated sliding window, if needed */\n\n  /* bit accumulator */\n  this.hold = 0;              /* input bit accumulator */\n  this.bits = 0;              /* number of bits in \"in\" */\n\n  /* for string and stored block copying */\n  this.length = 0;            /* literal or length of data to copy */\n  this.offset = 0;            /* distance back to copy string from */\n\n  /* for table and code decoding */\n  this.extra = 0;             /* extra bits needed */\n\n  /* fixed and dynamic code tables */\n  this.lencode = null;          /* starting table for length/literal codes */\n  this.distcode = null;         /* starting table for distance codes */\n  this.lenbits = 0;           /* index bits for lencode */\n  this.distbits = 0;          /* index bits for distcode */\n\n  /* dynamic table building */\n  this.ncode = 0;             /* number of code length code lengths */\n  this.nlen = 0;              /* number of length code lengths */\n  this.ndist = 0;             /* number of distance code lengths */\n  this.have = 0;              /* number of code lengths in lens[] */\n  this.next = null;              /* next available space in codes[] */\n\n  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */\n  this.work = new utils.Buf16(288); /* work area for code table building */\n\n  /*\n   because we don't have pointers in js, we use lencode and distcode directly\n   as buffers so we don't need codes\n  */\n  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */\n  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */\n  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */\n  this.sane = 0;                   /* if false, allow invalid distance too far */\n  this.back = 0;                   /* bits back of last unprocessed length/lit */\n  this.was = 0;                    /* initial length of match */\n}\n\nfunction inflateResetKeep(strm) {\n  var state;\n\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  strm.total_in = strm.total_out = state.total = 0;\n  strm.msg = ''; /*Z_NULL*/\n  if (state.wrap) {       /* to support ill-conceived Java test suite */\n    strm.adler = state.wrap & 1;\n  }\n  state.mode = HEAD;\n  state.last = 0;\n  state.havedict = 0;\n  state.dmax = 32768;\n  state.head = null/*Z_NULL*/;\n  state.hold = 0;\n  state.bits = 0;\n  //state.lencode = state.distcode = state.next = state.codes;\n  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);\n  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);\n\n  state.sane = 1;\n  state.back = -1;\n  //Tracev((stderr, \"inflate: reset\\n\"));\n  return Z_OK;\n}\n\nfunction inflateReset(strm) {\n  var state;\n\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  state.wsize = 0;\n  state.whave = 0;\n  state.wnext = 0;\n  return inflateResetKeep(strm);\n\n}\n\nfunction inflateReset2(strm, windowBits) {\n  var wrap;\n  var state;\n\n  /* get the state */\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n\n  /* extract wrap request from windowBits parameter */\n  if (windowBits < 0) {\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n  else {\n    wrap = (windowBits >> 4) + 1;\n    if (windowBits < 48) {\n      windowBits &= 15;\n    }\n  }\n\n  /* set number of window bits, free window if different */\n  if (windowBits && (windowBits < 8 || windowBits > 15)) {\n    return Z_STREAM_ERROR;\n  }\n  if (state.window !== null && state.wbits !== windowBits) {\n    state.window = null;\n  }\n\n  /* update state and reset the rest of it */\n  state.wrap = wrap;\n  state.wbits = windowBits;\n  return inflateReset(strm);\n}\n\nfunction inflateInit2(strm, windowBits) {\n  var ret;\n  var state;\n\n  if (!strm) { return Z_STREAM_ERROR; }\n  //strm.msg = Z_NULL;                 /* in case we return an error */\n\n  state = new InflateState();\n\n  //if (state === Z_NULL) return Z_MEM_ERROR;\n  //Tracev((stderr, \"inflate: allocated\\n\"));\n  strm.state = state;\n  state.window = null/*Z_NULL*/;\n  ret = inflateReset2(strm, windowBits);\n  if (ret !== Z_OK) {\n    strm.state = null/*Z_NULL*/;\n  }\n  return ret;\n}\n\nfunction inflateInit(strm) {\n  return inflateInit2(strm, DEF_WBITS);\n}\n\n\n/*\n Return state with length and distance decoding tables and index sizes set to\n fixed code decoding.  Normally this returns fixed tables from inffixed.h.\n If BUILDFIXED is defined, then instead this routine builds the tables the\n first time it's called, and returns those tables the first time and\n thereafter.  This reduces the size of the code by about 2K bytes, in\n exchange for a little execution time.  However, BUILDFIXED should not be\n used for threaded applications, since the rewriting of the tables and virgin\n may not be thread-safe.\n */\nvar virgin = true;\n\nvar lenfix, distfix; // We have no pointers in JS, so keep tables separate\n\nfunction fixedtables(state) {\n  /* build fixed huffman tables if first call (may not be thread safe) */\n  if (virgin) {\n    var sym;\n\n    lenfix = new utils.Buf32(512);\n    distfix = new utils.Buf32(32);\n\n    /* literal/length table */\n    sym = 0;\n    while (sym < 144) { state.lens[sym++] = 8; }\n    while (sym < 256) { state.lens[sym++] = 9; }\n    while (sym < 280) { state.lens[sym++] = 7; }\n    while (sym < 288) { state.lens[sym++] = 8; }\n\n    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });\n\n    /* distance table */\n    sym = 0;\n    while (sym < 32) { state.lens[sym++] = 5; }\n\n    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });\n\n    /* do this just once */\n    virgin = false;\n  }\n\n  state.lencode = lenfix;\n  state.lenbits = 9;\n  state.distcode = distfix;\n  state.distbits = 5;\n}\n\n\n/*\n Update the window with the last wsize (normally 32K) bytes written before\n returning.  If window does not exist yet, create it.  This is only called\n when a window is already in use, or when output has been written during this\n inflate call, but the end of the deflate stream has not been reached yet.\n It is also called to create a window for dictionary data when a dictionary\n is loaded.\n\n Providing output buffers larger than 32K to inflate() should provide a speed\n advantage, since only the last 32K of output is copied to the sliding window\n upon return from inflate(), and since all distances after the first 32K of\n output will fall in the output data, making match copies simpler and faster.\n The advantage may be dependent on the size of the processor's data caches.\n */\nfunction updatewindow(strm, src, end, copy) {\n  var dist;\n  var state = strm.state;\n\n  /* if it hasn't been done already, allocate space for the window */\n  if (state.window === null) {\n    state.wsize = 1 << state.wbits;\n    state.wnext = 0;\n    state.whave = 0;\n\n    state.window = new utils.Buf8(state.wsize);\n  }\n\n  /* copy state->wsize or less output bytes into the circular window */\n  if (copy >= state.wsize) {\n    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);\n    state.wnext = 0;\n    state.whave = state.wsize;\n  }\n  else {\n    dist = state.wsize - state.wnext;\n    if (dist > copy) {\n      dist = copy;\n    }\n    //zmemcpy(state->window + state->wnext, end - copy, dist);\n    utils.arraySet(state.window, src, end - copy, dist, state.wnext);\n    copy -= dist;\n    if (copy) {\n      //zmemcpy(state->window, end - copy, copy);\n      utils.arraySet(state.window, src, end - copy, copy, 0);\n      state.wnext = copy;\n      state.whave = state.wsize;\n    }\n    else {\n      state.wnext += dist;\n      if (state.wnext === state.wsize) { state.wnext = 0; }\n      if (state.whave < state.wsize) { state.whave += dist; }\n    }\n  }\n  return 0;\n}\n\nfunction inflate(strm, flush) {\n  var state;\n  var input, output;          // input/output buffers\n  var next;                   /* next input INDEX */\n  var put;                    /* next output INDEX */\n  var have, left;             /* available input and output */\n  var hold;                   /* bit buffer */\n  var bits;                   /* bits in bit buffer */\n  var _in, _out;              /* save starting available input and output */\n  var copy;                   /* number of stored or match bytes to copy */\n  var from;                   /* where to copy match bytes from */\n  var from_source;\n  var here = 0;               /* current decoding table entry */\n  var here_bits, here_op, here_val; // paked \"here\" denormalized (JS specific)\n  //var last;                   /* parent table entry */\n  var last_bits, last_op, last_val; // paked \"last\" denormalized (JS specific)\n  var len;                    /* length to copy for repeats, bits to drop */\n  var ret;                    /* return code */\n  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */\n  var opts;\n\n  var n; // temporary var for NEED_BITS\n\n  var order = /* permutation of code lengths */\n    [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];\n\n\n  if (!strm || !strm.state || !strm.output ||\n      (!strm.input && strm.avail_in !== 0)) {\n    return Z_STREAM_ERROR;\n  }\n\n  state = strm.state;\n  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */\n\n\n  //--- LOAD() ---\n  put = strm.next_out;\n  output = strm.output;\n  left = strm.avail_out;\n  next = strm.next_in;\n  input = strm.input;\n  have = strm.avail_in;\n  hold = state.hold;\n  bits = state.bits;\n  //---\n\n  _in = have;\n  _out = left;\n  ret = Z_OK;\n\n  inf_leave: // goto emulation\n  for (;;) {\n    switch (state.mode) {\n    case HEAD:\n      if (state.wrap === 0) {\n        state.mode = TYPEDO;\n        break;\n      }\n      //=== NEEDBITS(16);\n      while (bits < 16) {\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n      }\n      //===//\n      if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */\n        state.check = 0/*crc32(0L, Z_NULL, 0)*/;\n        //=== CRC2(state.check, hold);\n        hbuf[0] = hold & 0xff;\n        hbuf[1] = (hold >>> 8) & 0xff;\n        state.check = crc32(state.check, hbuf, 2, 0);\n        //===//\n\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = FLAGS;\n        break;\n      }\n      state.flags = 0;           /* expect zlib header */\n      if (state.head) {\n        state.head.done = false;\n      }\n      if (!(state.wrap & 1) ||   /* check if zlib header allowed */\n        (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {\n        strm.msg = 'incorrect header check';\n        state.mode = BAD;\n        break;\n      }\n      if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {\n        strm.msg = 'unknown compression method';\n        state.mode = BAD;\n        break;\n      }\n      //--- DROPBITS(4) ---//\n      hold >>>= 4;\n      bits -= 4;\n      //---//\n      len = (hold & 0x0f)/*BITS(4)*/ + 8;\n      if (state.wbits === 0) {\n        state.wbits = len;\n      }\n      else if (len > state.wbits) {\n        strm.msg = 'invalid window size';\n        state.mode = BAD;\n        break;\n      }\n      state.dmax = 1 << len;\n      //Tracev((stderr, \"inflate:   zlib header ok\\n\"));\n      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n      state.mode = hold & 0x200 ? DICTID : TYPE;\n      //=== INITBITS();\n      hold = 0;\n      bits = 0;\n      //===//\n      break;\n    case FLAGS:\n      //=== NEEDBITS(16); */\n      while (bits < 16) {\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n      }\n      //===//\n      state.flags = hold;\n      if ((state.flags & 0xff) !== Z_DEFLATED) {\n        strm.msg = 'unknown compression method';\n        state.mode = BAD;\n        break;\n      }\n      if (state.flags & 0xe000) {\n        strm.msg = 'unknown header flags set';\n        state.mode = BAD;\n        break;\n      }\n      if (state.head) {\n        state.head.text = ((hold >> 8) & 1);\n      }\n      if (state.flags & 0x0200) {\n        //=== CRC2(state.check, hold);\n        hbuf[0] = hold & 0xff;\n        hbuf[1] = (hold >>> 8) & 0xff;\n        state.check = crc32(state.check, hbuf, 2, 0);\n        //===//\n      }\n      //=== INITBITS();\n      hold = 0;\n      bits = 0;\n      //===//\n      state.mode = TIME;\n      /* falls through */\n    case TIME:\n      //=== NEEDBITS(32); */\n      while (bits < 32) {\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n      }\n      //===//\n      if (state.head) {\n        state.head.time = hold;\n      }\n      if (state.flags & 0x0200) {\n        //=== CRC4(state.check, hold)\n        hbuf[0] = hold & 0xff;\n        hbuf[1] = (hold >>> 8) & 0xff;\n        hbuf[2] = (hold >>> 16) & 0xff;\n        hbuf[3] = (hold >>> 24) & 0xff;\n        state.check = crc32(state.check, hbuf, 4, 0);\n        //===\n      }\n      //=== INITBITS();\n      hold = 0;\n      bits = 0;\n      //===//\n      state.mode = OS;\n      /* falls through */\n    case OS:\n      //=== NEEDBITS(16); */\n      while (bits < 16) {\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n      }\n      //===//\n      if (state.head) {\n        state.head.xflags = (hold & 0xff);\n        state.head.os = (hold >> 8);\n      }\n      if (state.flags & 0x0200) {\n        //=== CRC2(state.check, hold);\n        hbuf[0] = hold & 0xff;\n        hbuf[1] = (hold >>> 8) & 0xff;\n        state.check = crc32(state.check, hbuf, 2, 0);\n        //===//\n      }\n      //=== INITBITS();\n      hold = 0;\n      bits = 0;\n      //===//\n      state.mode = EXLEN;\n      /* falls through */\n    case EXLEN:\n      if (state.flags & 0x0400) {\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.length = hold;\n        if (state.head) {\n          state.head.extra_len = hold;\n        }\n        if (state.flags & 0x0200) {\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32(state.check, hbuf, 2, 0);\n          //===//\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n      }\n      else if (state.head) {\n        state.head.extra = null/*Z_NULL*/;\n      }\n      state.mode = EXTRA;\n      /* falls through */\n    case EXTRA:\n      if (state.flags & 0x0400) {\n        copy = state.length;\n        if (copy > have) { copy = have; }\n        if (copy) {\n          if (state.head) {\n            len = state.head.extra_len - state.length;\n            if (!state.head.extra) {\n              // Use untyped array for more conveniend processing later\n              state.head.extra = new Array(state.head.extra_len);\n            }\n            utils.arraySet(\n              state.head.extra,\n              input,\n              next,\n              // extra field is limited to 65536 bytes\n              // - no need for additional size check\n              copy,\n              /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/\n              len\n            );\n            //zmemcpy(state.head.extra + len, next,\n            //        len + copy > state.head.extra_max ?\n            //        state.head.extra_max - len : copy);\n          }\n          if (state.flags & 0x0200) {\n            state.check = crc32(state.check, input, copy, next);\n          }\n          have -= copy;\n          next += copy;\n          state.length -= copy;\n        }\n        if (state.length) { break inf_leave; }\n      }\n      state.length = 0;\n      state.mode = NAME;\n      /* falls through */\n    case NAME:\n      if (state.flags & 0x0800) {\n        if (have === 0) { break inf_leave; }\n        copy = 0;\n        do {\n          // TODO: 2 or 1 bytes?\n          len = input[next + copy++];\n          /* use constant limit because in js we should not preallocate memory */\n          if (state.head && len &&\n              (state.length < 65536 /*state.head.name_max*/)) {\n            state.head.name += String.fromCharCode(len);\n          }\n        } while (len && copy < have);\n\n        if (state.flags & 0x0200) {\n          state.check = crc32(state.check, input, copy, next);\n        }\n        have -= copy;\n        next += copy;\n        if (len) { break inf_leave; }\n      }\n      else if (state.head) {\n        state.head.name = null;\n      }\n      state.length = 0;\n      state.mode = COMMENT;\n      /* falls through */\n    case COMMENT:\n      if (state.flags & 0x1000) {\n        if (have === 0) { break inf_leave; }\n        copy = 0;\n        do {\n          len = input[next + copy++];\n          /* use constant limit because in js we should not preallocate memory */\n          if (state.head && len &&\n              (state.length < 65536 /*state.head.comm_max*/)) {\n            state.head.comment += String.fromCharCode(len);\n          }\n        } while (len && copy < have);\n        if (state.flags & 0x0200) {\n          state.check = crc32(state.check, input, copy, next);\n        }\n        have -= copy;\n        next += copy;\n        if (len) { break inf_leave; }\n      }\n      else if (state.head) {\n        state.head.comment = null;\n      }\n      state.mode = HCRC;\n      /* falls through */\n    case HCRC:\n      if (state.flags & 0x0200) {\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (hold !== (state.check & 0xffff)) {\n          strm.msg = 'header crc mismatch';\n          state.mode = BAD;\n          break;\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n      }\n      if (state.head) {\n        state.head.hcrc = ((state.flags >> 9) & 1);\n        state.head.done = true;\n      }\n      strm.adler = state.check = 0;\n      state.mode = TYPE;\n      break;\n    case DICTID:\n      //=== NEEDBITS(32); */\n      while (bits < 32) {\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n      }\n      //===//\n      strm.adler = state.check = zswap32(hold);\n      //=== INITBITS();\n      hold = 0;\n      bits = 0;\n      //===//\n      state.mode = DICT;\n      /* falls through */\n    case DICT:\n      if (state.havedict === 0) {\n        //--- RESTORE() ---\n        strm.next_out = put;\n        strm.avail_out = left;\n        strm.next_in = next;\n        strm.avail_in = have;\n        state.hold = hold;\n        state.bits = bits;\n        //---\n        return Z_NEED_DICT;\n      }\n      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n      state.mode = TYPE;\n      /* falls through */\n    case TYPE:\n      if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }\n      /* falls through */\n    case TYPEDO:\n      if (state.last) {\n        //--- BYTEBITS() ---//\n        hold >>>= bits & 7;\n        bits -= bits & 7;\n        //---//\n        state.mode = CHECK;\n        break;\n      }\n      //=== NEEDBITS(3); */\n      while (bits < 3) {\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n      }\n      //===//\n      state.last = (hold & 0x01)/*BITS(1)*/;\n      //--- DROPBITS(1) ---//\n      hold >>>= 1;\n      bits -= 1;\n      //---//\n\n      switch ((hold & 0x03)/*BITS(2)*/) {\n      case 0:                             /* stored block */\n        //Tracev((stderr, \"inflate:     stored block%s\\n\",\n        //        state.last ? \" (last)\" : \"\"));\n        state.mode = STORED;\n        break;\n      case 1:                             /* fixed block */\n        fixedtables(state);\n        //Tracev((stderr, \"inflate:     fixed codes block%s\\n\",\n        //        state.last ? \" (last)\" : \"\"));\n        state.mode = LEN_;             /* decode codes */\n        if (flush === Z_TREES) {\n          //--- DROPBITS(2) ---//\n          hold >>>= 2;\n          bits -= 2;\n          //---//\n          break inf_leave;\n        }\n        break;\n      case 2:                             /* dynamic block */\n        //Tracev((stderr, \"inflate:     dynamic codes block%s\\n\",\n        //        state.last ? \" (last)\" : \"\"));\n        state.mode = TABLE;\n        break;\n      case 3:\n        strm.msg = 'invalid block type';\n        state.mode = BAD;\n      }\n      //--- DROPBITS(2) ---//\n      hold >>>= 2;\n      bits -= 2;\n      //---//\n      break;\n    case STORED:\n      //--- BYTEBITS() ---// /* go to byte boundary */\n      hold >>>= bits & 7;\n      bits -= bits & 7;\n      //---//\n      //=== NEEDBITS(32); */\n      while (bits < 32) {\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n      }\n      //===//\n      if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {\n        strm.msg = 'invalid stored block lengths';\n        state.mode = BAD;\n        break;\n      }\n      state.length = hold & 0xffff;\n      //Tracev((stderr, \"inflate:       stored length %u\\n\",\n      //        state.length));\n      //=== INITBITS();\n      hold = 0;\n      bits = 0;\n      //===//\n      state.mode = COPY_;\n      if (flush === Z_TREES) { break inf_leave; }\n      /* falls through */\n    case COPY_:\n      state.mode = COPY;\n      /* falls through */\n    case COPY:\n      copy = state.length;\n      if (copy) {\n        if (copy > have) { copy = have; }\n        if (copy > left) { copy = left; }\n        if (copy === 0) { break inf_leave; }\n        //--- zmemcpy(put, next, copy); ---\n        utils.arraySet(output, input, next, copy, put);\n        //---//\n        have -= copy;\n        next += copy;\n        left -= copy;\n        put += copy;\n        state.length -= copy;\n        break;\n      }\n      //Tracev((stderr, \"inflate:       stored end\\n\"));\n      state.mode = TYPE;\n      break;\n    case TABLE:\n      //=== NEEDBITS(14); */\n      while (bits < 14) {\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n      }\n      //===//\n      state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;\n      //--- DROPBITS(5) ---//\n      hold >>>= 5;\n      bits -= 5;\n      //---//\n      state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;\n      //--- DROPBITS(5) ---//\n      hold >>>= 5;\n      bits -= 5;\n      //---//\n      state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;\n      //--- DROPBITS(4) ---//\n      hold >>>= 4;\n      bits -= 4;\n      //---//\n//#ifndef PKZIP_BUG_WORKAROUND\n      if (state.nlen > 286 || state.ndist > 30) {\n        strm.msg = 'too many length or distance symbols';\n        state.mode = BAD;\n        break;\n      }\n//#endif\n      //Tracev((stderr, \"inflate:       table sizes ok\\n\"));\n      state.have = 0;\n      state.mode = LENLENS;\n      /* falls through */\n    case LENLENS:\n      while (state.have < state.ncode) {\n        //=== NEEDBITS(3);\n        while (bits < 3) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);\n        //--- DROPBITS(3) ---//\n        hold >>>= 3;\n        bits -= 3;\n        //---//\n      }\n      while (state.have < 19) {\n        state.lens[order[state.have++]] = 0;\n      }\n      // We have separate tables & no pointers. 2 commented lines below not needed.\n      //state.next = state.codes;\n      //state.lencode = state.next;\n      // Switch to use dynamic table\n      state.lencode = state.lendyn;\n      state.lenbits = 7;\n\n      opts = { bits: state.lenbits };\n      ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);\n      state.lenbits = opts.bits;\n\n      if (ret) {\n        strm.msg = 'invalid code lengths set';\n        state.mode = BAD;\n        break;\n      }\n      //Tracev((stderr, \"inflate:       code lengths ok\\n\"));\n      state.have = 0;\n      state.mode = CODELENS;\n      /* falls through */\n    case CODELENS:\n      while (state.have < state.nlen + state.ndist) {\n        for (;;) {\n          here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if ((here_bits) <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        if (here_val < 16) {\n          //--- DROPBITS(here.bits) ---//\n          hold >>>= here_bits;\n          bits -= here_bits;\n          //---//\n          state.lens[state.have++] = here_val;\n        }\n        else {\n          if (here_val === 16) {\n            //=== NEEDBITS(here.bits + 2);\n            n = here_bits + 2;\n            while (bits < n) {\n              if (have === 0) { break inf_leave; }\n              have--;\n              hold += input[next++] << bits;\n              bits += 8;\n            }\n            //===//\n            //--- DROPBITS(here.bits) ---//\n            hold >>>= here_bits;\n            bits -= here_bits;\n            //---//\n            if (state.have === 0) {\n              strm.msg = 'invalid bit length repeat';\n              state.mode = BAD;\n              break;\n            }\n            len = state.lens[state.have - 1];\n            copy = 3 + (hold & 0x03);//BITS(2);\n            //--- DROPBITS(2) ---//\n            hold >>>= 2;\n            bits -= 2;\n            //---//\n          }\n          else if (here_val === 17) {\n            //=== NEEDBITS(here.bits + 3);\n            n = here_bits + 3;\n            while (bits < n) {\n              if (have === 0) { break inf_leave; }\n              have--;\n              hold += input[next++] << bits;\n              bits += 8;\n            }\n            //===//\n            //--- DROPBITS(here.bits) ---//\n            hold >>>= here_bits;\n            bits -= here_bits;\n            //---//\n            len = 0;\n            copy = 3 + (hold & 0x07);//BITS(3);\n            //--- DROPBITS(3) ---//\n            hold >>>= 3;\n            bits -= 3;\n            //---//\n          }\n          else {\n            //=== NEEDBITS(here.bits + 7);\n            n = here_bits + 7;\n            while (bits < n) {\n              if (have === 0) { break inf_leave; }\n              have--;\n              hold += input[next++] << bits;\n              bits += 8;\n            }\n            //===//\n            //--- DROPBITS(here.bits) ---//\n            hold >>>= here_bits;\n            bits -= here_bits;\n            //---//\n            len = 0;\n            copy = 11 + (hold & 0x7f);//BITS(7);\n            //--- DROPBITS(7) ---//\n            hold >>>= 7;\n            bits -= 7;\n            //---//\n          }\n          if (state.have + copy > state.nlen + state.ndist) {\n            strm.msg = 'invalid bit length repeat';\n            state.mode = BAD;\n            break;\n          }\n          while (copy--) {\n            state.lens[state.have++] = len;\n          }\n        }\n      }\n\n      /* handle error breaks in while */\n      if (state.mode === BAD) { break; }\n\n      /* check for end-of-block code (better have one) */\n      if (state.lens[256] === 0) {\n        strm.msg = 'invalid code -- missing end-of-block';\n        state.mode = BAD;\n        break;\n      }\n\n      /* build code tables -- note: do not change the lenbits or distbits\n         values here (9 and 6) without reading the comments in inftrees.h\n         concerning the ENOUGH constants, which depend on those values */\n      state.lenbits = 9;\n\n      opts = { bits: state.lenbits };\n      ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);\n      // We have separate tables & no pointers. 2 commented lines below not needed.\n      // state.next_index = opts.table_index;\n      state.lenbits = opts.bits;\n      // state.lencode = state.next;\n\n      if (ret) {\n        strm.msg = 'invalid literal/lengths set';\n        state.mode = BAD;\n        break;\n      }\n\n      state.distbits = 6;\n      //state.distcode.copy(state.codes);\n      // Switch to use dynamic table\n      state.distcode = state.distdyn;\n      opts = { bits: state.distbits };\n      ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);\n      // We have separate tables & no pointers. 2 commented lines below not needed.\n      // state.next_index = opts.table_index;\n      state.distbits = opts.bits;\n      // state.distcode = state.next;\n\n      if (ret) {\n        strm.msg = 'invalid distances set';\n        state.mode = BAD;\n        break;\n      }\n      //Tracev((stderr, 'inflate:       codes ok\\n'));\n      state.mode = LEN_;\n      if (flush === Z_TREES) { break inf_leave; }\n      /* falls through */\n    case LEN_:\n      state.mode = LEN;\n      /* falls through */\n    case LEN:\n      if (have >= 6 && left >= 258) {\n        //--- RESTORE() ---\n        strm.next_out = put;\n        strm.avail_out = left;\n        strm.next_in = next;\n        strm.avail_in = have;\n        state.hold = hold;\n        state.bits = bits;\n        //---\n        inflate_fast(strm, _out);\n        //--- LOAD() ---\n        put = strm.next_out;\n        output = strm.output;\n        left = strm.avail_out;\n        next = strm.next_in;\n        input = strm.input;\n        have = strm.avail_in;\n        hold = state.hold;\n        bits = state.bits;\n        //---\n\n        if (state.mode === TYPE) {\n          state.back = -1;\n        }\n        break;\n      }\n      state.back = 0;\n      for (;;) {\n        here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/\n        here_bits = here >>> 24;\n        here_op = (here >>> 16) & 0xff;\n        here_val = here & 0xffff;\n\n        if (here_bits <= bits) { break; }\n        //--- PULLBYTE() ---//\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n        //---//\n      }\n      if (here_op && (here_op & 0xf0) === 0) {\n        last_bits = here_bits;\n        last_op = here_op;\n        last_val = here_val;\n        for (;;) {\n          here = state.lencode[last_val +\n                  ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if ((last_bits + here_bits) <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        //--- DROPBITS(last.bits) ---//\n        hold >>>= last_bits;\n        bits -= last_bits;\n        //---//\n        state.back += last_bits;\n      }\n      //--- DROPBITS(here.bits) ---//\n      hold >>>= here_bits;\n      bits -= here_bits;\n      //---//\n      state.back += here_bits;\n      state.length = here_val;\n      if (here_op === 0) {\n        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n        //        \"inflate:         literal '%c'\\n\" :\n        //        \"inflate:         literal 0x%02x\\n\", here.val));\n        state.mode = LIT;\n        break;\n      }\n      if (here_op & 32) {\n        //Tracevv((stderr, \"inflate:         end of block\\n\"));\n        state.back = -1;\n        state.mode = TYPE;\n        break;\n      }\n      if (here_op & 64) {\n        strm.msg = 'invalid literal/length code';\n        state.mode = BAD;\n        break;\n      }\n      state.extra = here_op & 15;\n      state.mode = LENEXT;\n      /* falls through */\n    case LENEXT:\n      if (state.extra) {\n        //=== NEEDBITS(state.extra);\n        n = state.extra;\n        while (bits < n) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n        //--- DROPBITS(state.extra) ---//\n        hold >>>= state.extra;\n        bits -= state.extra;\n        //---//\n        state.back += state.extra;\n      }\n      //Tracevv((stderr, \"inflate:         length %u\\n\", state.length));\n      state.was = state.length;\n      state.mode = DIST;\n      /* falls through */\n    case DIST:\n      for (;;) {\n        here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/\n        here_bits = here >>> 24;\n        here_op = (here >>> 16) & 0xff;\n        here_val = here & 0xffff;\n\n        if ((here_bits) <= bits) { break; }\n        //--- PULLBYTE() ---//\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n        //---//\n      }\n      if ((here_op & 0xf0) === 0) {\n        last_bits = here_bits;\n        last_op = here_op;\n        last_val = here_val;\n        for (;;) {\n          here = state.distcode[last_val +\n                  ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if ((last_bits + here_bits) <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        //--- DROPBITS(last.bits) ---//\n        hold >>>= last_bits;\n        bits -= last_bits;\n        //---//\n        state.back += last_bits;\n      }\n      //--- DROPBITS(here.bits) ---//\n      hold >>>= here_bits;\n      bits -= here_bits;\n      //---//\n      state.back += here_bits;\n      if (here_op & 64) {\n        strm.msg = 'invalid distance code';\n        state.mode = BAD;\n        break;\n      }\n      state.offset = here_val;\n      state.extra = (here_op) & 15;\n      state.mode = DISTEXT;\n      /* falls through */\n    case DISTEXT:\n      if (state.extra) {\n        //=== NEEDBITS(state.extra);\n        n = state.extra;\n        while (bits < n) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n        //--- DROPBITS(state.extra) ---//\n        hold >>>= state.extra;\n        bits -= state.extra;\n        //---//\n        state.back += state.extra;\n      }\n//#ifdef INFLATE_STRICT\n      if (state.offset > state.dmax) {\n        strm.msg = 'invalid distance too far back';\n        state.mode = BAD;\n        break;\n      }\n//#endif\n      //Tracevv((stderr, \"inflate:         distance %u\\n\", state.offset));\n      state.mode = MATCH;\n      /* falls through */\n    case MATCH:\n      if (left === 0) { break inf_leave; }\n      copy = _out - left;\n      if (state.offset > copy) {         /* copy from window */\n        copy = state.offset - copy;\n        if (copy > state.whave) {\n          if (state.sane) {\n            strm.msg = 'invalid distance too far back';\n            state.mode = BAD;\n            break;\n          }\n// (!) This block is disabled in zlib defailts,\n// don't enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//          Trace((stderr, \"inflate.c too far\\n\"));\n//          copy -= state.whave;\n//          if (copy > state.length) { copy = state.length; }\n//          if (copy > left) { copy = left; }\n//          left -= copy;\n//          state.length -= copy;\n//          do {\n//            output[put++] = 0;\n//          } while (--copy);\n//          if (state.length === 0) { state.mode = LEN; }\n//          break;\n//#endif\n        }\n        if (copy > state.wnext) {\n          copy -= state.wnext;\n          from = state.wsize - copy;\n        }\n        else {\n          from = state.wnext - copy;\n        }\n        if (copy > state.length) { copy = state.length; }\n        from_source = state.window;\n      }\n      else {                              /* copy from output */\n        from_source = output;\n        from = put - state.offset;\n        copy = state.length;\n      }\n      if (copy > left) { copy = left; }\n      left -= copy;\n      state.length -= copy;\n      do {\n        output[put++] = from_source[from++];\n      } while (--copy);\n      if (state.length === 0) { state.mode = LEN; }\n      break;\n    case LIT:\n      if (left === 0) { break inf_leave; }\n      output[put++] = state.length;\n      left--;\n      state.mode = LEN;\n      break;\n    case CHECK:\n      if (state.wrap) {\n        //=== NEEDBITS(32);\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          // Use '|' insdead of '+' to make sure that result is signed\n          hold |= input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        _out -= left;\n        strm.total_out += _out;\n        state.total += _out;\n        if (_out) {\n          strm.adler = state.check =\n              /*UPDATE(state.check, put - _out, _out);*/\n              (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));\n\n        }\n        _out = left;\n        // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too\n        if ((state.flags ? hold : zswap32(hold)) !== state.check) {\n          strm.msg = 'incorrect data check';\n          state.mode = BAD;\n          break;\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        //Tracev((stderr, \"inflate:   check matches trailer\\n\"));\n      }\n      state.mode = LENGTH;\n      /* falls through */\n    case LENGTH:\n      if (state.wrap && state.flags) {\n        //=== NEEDBITS(32);\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (hold !== (state.total & 0xffffffff)) {\n          strm.msg = 'incorrect length check';\n          state.mode = BAD;\n          break;\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        //Tracev((stderr, \"inflate:   length matches trailer\\n\"));\n      }\n      state.mode = DONE;\n      /* falls through */\n    case DONE:\n      ret = Z_STREAM_END;\n      break inf_leave;\n    case BAD:\n      ret = Z_DATA_ERROR;\n      break inf_leave;\n    case MEM:\n      return Z_MEM_ERROR;\n    case SYNC:\n      /* falls through */\n    default:\n      return Z_STREAM_ERROR;\n    }\n  }\n\n  // inf_leave <- here is real place for \"goto inf_leave\", emulated via \"break inf_leave\"\n\n  /*\n     Return from inflate(), updating the total counts and the check value.\n     If there was no progress during the inflate() call, return a buffer\n     error.  Call updatewindow() to create and/or update the window state.\n     Note: a memory error from inflate() is non-recoverable.\n   */\n\n  //--- RESTORE() ---\n  strm.next_out = put;\n  strm.avail_out = left;\n  strm.next_in = next;\n  strm.avail_in = have;\n  state.hold = hold;\n  state.bits = bits;\n  //---\n\n  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&\n                      (state.mode < CHECK || flush !== Z_FINISH))) {\n    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {\n      state.mode = MEM;\n      return Z_MEM_ERROR;\n    }\n  }\n  _in -= strm.avail_in;\n  _out -= strm.avail_out;\n  strm.total_in += _in;\n  strm.total_out += _out;\n  state.total += _out;\n  if (state.wrap && _out) {\n    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/\n      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));\n  }\n  strm.data_type = state.bits + (state.last ? 64 : 0) +\n                    (state.mode === TYPE ? 128 : 0) +\n                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);\n  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {\n    ret = Z_BUF_ERROR;\n  }\n  return ret;\n}\n\nfunction inflateEnd(strm) {\n\n  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  var state = strm.state;\n  if (state.window) {\n    state.window = null;\n  }\n  strm.state = null;\n  return Z_OK;\n}\n\nfunction inflateGetHeader(strm, head) {\n  var state;\n\n  /* check state */\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }\n\n  /* save header structure */\n  state.head = head;\n  head.done = false;\n  return Z_OK;\n}\n\nfunction inflateSetDictionary(strm, dictionary) {\n  var dictLength = dictionary.length;\n\n  var state;\n  var dictid;\n  var ret;\n\n  /* check state */\n  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }\n  state = strm.state;\n\n  if (state.wrap !== 0 && state.mode !== DICT) {\n    return Z_STREAM_ERROR;\n  }\n\n  /* check for correct dictionary identifier */\n  if (state.mode === DICT) {\n    dictid = 1; /* adler32(0, null, 0)*/\n    /* dictid = adler32(dictid, dictionary, dictLength); */\n    dictid = adler32(dictid, dictionary, dictLength, 0);\n    if (dictid !== state.check) {\n      return Z_DATA_ERROR;\n    }\n  }\n  /* copy dictionary to window using updatewindow(), which will amend the\n   existing dictionary if appropriate */\n  ret = updatewindow(strm, dictionary, dictLength, dictLength);\n  if (ret) {\n    state.mode = MEM;\n    return Z_MEM_ERROR;\n  }\n  state.havedict = 1;\n  // Tracev((stderr, \"inflate:   dictionary set\\n\"));\n  return Z_OK;\n}\n\nexports.inflateReset = inflateReset;\nexports.inflateReset2 = inflateReset2;\nexports.inflateResetKeep = inflateResetKeep;\nexports.inflateInit = inflateInit;\nexports.inflateInit2 = inflateInit2;\nexports.inflate = inflate;\nexports.inflateEnd = inflateEnd;\nexports.inflateGetHeader = inflateGetHeader;\nexports.inflateSetDictionary = inflateSetDictionary;\nexports.inflateInfo = 'pako inflate (from Nodeca project)';\n\n/* Not implemented\nexports.inflateCopy = inflateCopy;\nexports.inflateGetDictionary = inflateGetDictionary;\nexports.inflateMark = inflateMark;\nexports.inflatePrime = inflatePrime;\nexports.inflateSync = inflateSync;\nexports.inflateSyncPoint = inflateSyncPoint;\nexports.inflateUndermine = inflateUndermine;\n*/\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2pzemlwL34vcGFrby9saWIvemxpYi9pbmZsYXRlLmpzPzgwN2YiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7OztBQUdBLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakIsZ0JBQWdCO0FBQ2hCLGNBQWM7QUFDZCxpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCLGdCQUFnQjtBQUNoQixtQkFBbUI7QUFDbkIsZ0JBQWdCO0FBQ2hCLG1CQUFtQjtBQUNuQixpQkFBaUI7QUFDakIscUJBQXFCO0FBQ3JCLHVCQUF1QjtBQUN2Qix1QkFBdUI7QUFDdkIsc0JBQXNCO0FBQ3RCLHFCQUFxQjtBQUNyQixzQkFBc0I7QUFDdEIsd0JBQXdCO0FBQ3hCLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekIsd0JBQXdCO0FBQ3hCLDJCQUEyQjtBQUMzQix5QkFBeUI7QUFDekIsNEJBQTRCO0FBQzVCLDBCQUEwQjtBQUMxQix3QkFBd0I7QUFDeEIsa0JBQWtCO0FBQ2xCLG1CQUFtQjtBQUNuQixpQkFBaUI7QUFDakIsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixpQkFBaUI7O0FBRWpCOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLGdCQUFnQjtBQUNoQixvQkFBb0I7QUFDcEIsZ0JBQWdCO0FBQ2hCLHdCQUF3QjtBQUN4QixpQkFBaUI7QUFDakIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakI7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QUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZEQUE2RCx1QkFBdUI7QUFDcEY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Ysd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxMTIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cblxudmFyIHV0aWxzICAgICAgICAgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcbnZhciBhZGxlcjMyICAgICAgID0gcmVxdWlyZSgnLi9hZGxlcjMyJyk7XG52YXIgY3JjMzIgICAgICAgICA9IHJlcXVpcmUoJy4vY3JjMzInKTtcbnZhciBpbmZsYXRlX2Zhc3QgID0gcmVxdWlyZSgnLi9pbmZmYXN0Jyk7XG52YXIgaW5mbGF0ZV90YWJsZSA9IHJlcXVpcmUoJy4vaW5mdHJlZXMnKTtcblxudmFyIENPREVTID0gMDtcbnZhciBMRU5TID0gMTtcbnZhciBESVNUUyA9IDI7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8qIEFsbG93ZWQgZmx1c2ggdmFsdWVzOyBzZWUgZGVmbGF0ZSgpIGFuZCBpbmZsYXRlKCkgYmVsb3cgZm9yIGRldGFpbHMgKi9cbi8vdmFyIFpfTk9fRkxVU0ggICAgICA9IDA7XG4vL3ZhciBaX1BBUlRJQUxfRkxVU0ggPSAxO1xuLy92YXIgWl9TWU5DX0ZMVVNIICAgID0gMjtcbi8vdmFyIFpfRlVMTF9GTFVTSCAgICA9IDM7XG52YXIgWl9GSU5JU0ggICAgICAgID0gNDtcbnZhciBaX0JMT0NLICAgICAgICAgPSA1O1xudmFyIFpfVFJFRVMgICAgICAgICA9IDY7XG5cblxuLyogUmV0dXJuIGNvZGVzIGZvciB0aGUgY29tcHJlc3Npb24vZGVjb21wcmVzc2lvbiBmdW5jdGlvbnMuIE5lZ2F0aXZlIHZhbHVlc1xuICogYXJlIGVycm9ycywgcG9zaXRpdmUgdmFsdWVzIGFyZSB1c2VkIGZvciBzcGVjaWFsIGJ1dCBub3JtYWwgZXZlbnRzLlxuICovXG52YXIgWl9PSyAgICAgICAgICAgID0gMDtcbnZhciBaX1NUUkVBTV9FTkQgICAgPSAxO1xudmFyIFpfTkVFRF9ESUNUICAgICA9IDI7XG4vL3ZhciBaX0VSUk5PICAgICAgICAgPSAtMTtcbnZhciBaX1NUUkVBTV9FUlJPUiAgPSAtMjtcbnZhciBaX0RBVEFfRVJST1IgICAgPSAtMztcbnZhciBaX01FTV9FUlJPUiAgICAgPSAtNDtcbnZhciBaX0JVRl9FUlJPUiAgICAgPSAtNTtcbi8vdmFyIFpfVkVSU0lPTl9FUlJPUiA9IC02O1xuXG4vKiBUaGUgZGVmbGF0ZSBjb21wcmVzc2lvbiBtZXRob2QgKi9cbnZhciBaX0RFRkxBVEVEICA9IDg7XG5cblxuLyogU1RBVEVTID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxudmFyICAgIEhFQUQgPSAxOyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBtYWdpYyBoZWFkZXIgKi9cbnZhciAgICBGTEFHUyA9IDI7ICAgICAgLyogaTogd2FpdGluZyBmb3IgbWV0aG9kIGFuZCBmbGFncyAoZ3ppcCkgKi9cbnZhciAgICBUSU1FID0gMzsgICAgICAgLyogaTogd2FpdGluZyBmb3IgbW9kaWZpY2F0aW9uIHRpbWUgKGd6aXApICovXG52YXIgICAgT1MgPSA0OyAgICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGV4dHJhIGZsYWdzIGFuZCBvcGVyYXRpbmcgc3lzdGVtIChnemlwKSAqL1xudmFyICAgIEVYTEVOID0gNTsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBleHRyYSBsZW5ndGggKGd6aXApICovXG52YXIgICAgRVhUUkEgPSA2OyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGV4dHJhIGJ5dGVzIChnemlwKSAqL1xudmFyICAgIE5BTUUgPSA3OyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBlbmQgb2YgZmlsZSBuYW1lIChnemlwKSAqL1xudmFyICAgIENPTU1FTlQgPSA4OyAgICAvKiBpOiB3YWl0aW5nIGZvciBlbmQgb2YgY29tbWVudCAoZ3ppcCkgKi9cbnZhciAgICBIQ1JDID0gOTsgICAgICAgLyogaTogd2FpdGluZyBmb3IgaGVhZGVyIGNyYyAoZ3ppcCkgKi9cbnZhciAgICBESUNUSUQgPSAxMDsgICAgLyogaTogd2FpdGluZyBmb3IgZGljdGlvbmFyeSBjaGVjayB2YWx1ZSAqL1xudmFyICAgIERJQ1QgPSAxMTsgICAgICAvKiB3YWl0aW5nIGZvciBpbmZsYXRlU2V0RGljdGlvbmFyeSgpIGNhbGwgKi9cbnZhciAgICAgICAgVFlQRSA9IDEyOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIHR5cGUgYml0cywgaW5jbHVkaW5nIGxhc3QtZmxhZyBiaXQgKi9cbnZhciAgICAgICAgVFlQRURPID0gMTM7ICAgIC8qIGk6IHNhbWUsIGJ1dCBza2lwIGNoZWNrIHRvIGV4aXQgaW5mbGF0ZSBvbiBuZXcgYmxvY2sgKi9cbnZhciAgICAgICAgU1RPUkVEID0gMTQ7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIHN0b3JlZCBzaXplIChsZW5ndGggYW5kIGNvbXBsZW1lbnQpICovXG52YXIgICAgICAgIENPUFlfID0gMTU7ICAgICAvKiBpL286IHNhbWUgYXMgQ09QWSBiZWxvdywgYnV0IG9ubHkgZmlyc3QgdGltZSBpbiAqL1xudmFyICAgICAgICBDT1BZID0gMTY7ICAgICAgLyogaS9vOiB3YWl0aW5nIGZvciBpbnB1dCBvciBvdXRwdXQgdG8gY29weSBzdG9yZWQgYmxvY2sgKi9cbnZhciAgICAgICAgVEFCTEUgPSAxNzsgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGR5bmFtaWMgYmxvY2sgdGFibGUgbGVuZ3RocyAqL1xudmFyICAgICAgICBMRU5MRU5TID0gMTg7ICAgLyogaTogd2FpdGluZyBmb3IgY29kZSBsZW5ndGggY29kZSBsZW5ndGhzICovXG52YXIgICAgICAgIENPREVMRU5TID0gMTk7ICAvKiBpOiB3YWl0aW5nIGZvciBsZW5ndGgvbGl0IGFuZCBkaXN0YW5jZSBjb2RlIGxlbmd0aHMgKi9cbnZhciAgICAgICAgICAgIExFTl8gPSAyMDsgICAgICAvKiBpOiBzYW1lIGFzIExFTiBiZWxvdywgYnV0IG9ubHkgZmlyc3QgdGltZSBpbiAqL1xudmFyICAgICAgICAgICAgTEVOID0gMjE7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGxlbmd0aC9saXQvZW9iIGNvZGUgKi9cbnZhciAgICAgICAgICAgIExFTkVYVCA9IDIyOyAgICAvKiBpOiB3YWl0aW5nIGZvciBsZW5ndGggZXh0cmEgYml0cyAqL1xudmFyICAgICAgICAgICAgRElTVCA9IDIzOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGRpc3RhbmNlIGNvZGUgKi9cbnZhciAgICAgICAgICAgIERJU1RFWFQgPSAyNDsgICAvKiBpOiB3YWl0aW5nIGZvciBkaXN0YW5jZSBleHRyYSBiaXRzICovXG52YXIgICAgICAgICAgICBNQVRDSCA9IDI1OyAgICAgLyogbzogd2FpdGluZyBmb3Igb3V0cHV0IHNwYWNlIHRvIGNvcHkgc3RyaW5nICovXG52YXIgICAgICAgICAgICBMSVQgPSAyNjsgICAgICAgLyogbzogd2FpdGluZyBmb3Igb3V0cHV0IHNwYWNlIHRvIHdyaXRlIGxpdGVyYWwgKi9cbnZhciAgICBDSEVDSyA9IDI3OyAgICAgLyogaTogd2FpdGluZyBmb3IgMzItYml0IGNoZWNrIHZhbHVlICovXG52YXIgICAgTEVOR1RIID0gMjg7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIDMyLWJpdCBsZW5ndGggKGd6aXApICovXG52YXIgICAgRE9ORSA9IDI5OyAgICAgIC8qIGZpbmlzaGVkIGNoZWNrLCBkb25lIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG52YXIgICAgQkFEID0gMzA7ICAgICAgIC8qIGdvdCBhIGRhdGEgZXJyb3IgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbnZhciAgICBNRU0gPSAzMTsgICAgICAgLyogZ290IGFuIGluZmxhdGUoKSBtZW1vcnkgZXJyb3IgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbnZhciAgICBTWU5DID0gMzI7ICAgICAgLyogbG9va2luZyBmb3Igc3luY2hyb25pemF0aW9uIGJ5dGVzIHRvIHJlc3RhcnQgaW5mbGF0ZSgpICovXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuXG52YXIgRU5PVUdIX0xFTlMgPSA4NTI7XG52YXIgRU5PVUdIX0RJU1RTID0gNTkyO1xuLy92YXIgRU5PVUdIID0gIChFTk9VR0hfTEVOUytFTk9VR0hfRElTVFMpO1xuXG52YXIgTUFYX1dCSVRTID0gMTU7XG4vKiAzMksgTFo3NyB3aW5kb3cgKi9cbnZhciBERUZfV0JJVFMgPSBNQVhfV0JJVFM7XG5cblxuZnVuY3Rpb24genN3YXAzMihxKSB7XG4gIHJldHVybiAgKCgocSA+Pj4gMjQpICYgMHhmZikgK1xuICAgICAgICAgICgocSA+Pj4gOCkgJiAweGZmMDApICtcbiAgICAgICAgICAoKHEgJiAweGZmMDApIDw8IDgpICtcbiAgICAgICAgICAoKHEgJiAweGZmKSA8PCAyNCkpO1xufVxuXG5cbmZ1bmN0aW9uIEluZmxhdGVTdGF0ZSgpIHtcbiAgdGhpcy5tb2RlID0gMDsgICAgICAgICAgICAgLyogY3VycmVudCBpbmZsYXRlIG1vZGUgKi9cbiAgdGhpcy5sYXN0ID0gZmFsc2U7ICAgICAgICAgIC8qIHRydWUgaWYgcHJvY2Vzc2luZyBsYXN0IGJsb2NrICovXG4gIHRoaXMud3JhcCA9IDA7ICAgICAgICAgICAgICAvKiBiaXQgMCB0cnVlIGZvciB6bGliLCBiaXQgMSB0cnVlIGZvciBnemlwICovXG4gIHRoaXMuaGF2ZWRpY3QgPSBmYWxzZTsgICAgICAvKiB0cnVlIGlmIGRpY3Rpb25hcnkgcHJvdmlkZWQgKi9cbiAgdGhpcy5mbGFncyA9IDA7ICAgICAgICAgICAgIC8qIGd6aXAgaGVhZGVyIG1ldGhvZCBhbmQgZmxhZ3MgKDAgaWYgemxpYikgKi9cbiAgdGhpcy5kbWF4ID0gMDsgICAgICAgICAgICAgIC8qIHpsaWIgaGVhZGVyIG1heCBkaXN0YW5jZSAoSU5GTEFURV9TVFJJQ1QpICovXG4gIHRoaXMuY2hlY2sgPSAwOyAgICAgICAgICAgICAvKiBwcm90ZWN0ZWQgY29weSBvZiBjaGVjayB2YWx1ZSAqL1xuICB0aGlzLnRvdGFsID0gMDsgICAgICAgICAgICAgLyogcHJvdGVjdGVkIGNvcHkgb2Ygb3V0cHV0IGNvdW50ICovXG4gIC8vIFRPRE86IG1heSBiZSB7fVxuICB0aGlzLmhlYWQgPSBudWxsOyAgICAgICAgICAgLyogd2hlcmUgdG8gc2F2ZSBnemlwIGhlYWRlciBpbmZvcm1hdGlvbiAqL1xuXG4gIC8qIHNsaWRpbmcgd2luZG93ICovXG4gIHRoaXMud2JpdHMgPSAwOyAgICAgICAgICAgICAvKiBsb2cgYmFzZSAyIG9mIHJlcXVlc3RlZCB3aW5kb3cgc2l6ZSAqL1xuICB0aGlzLndzaXplID0gMDsgICAgICAgICAgICAgLyogd2luZG93IHNpemUgb3IgemVybyBpZiBub3QgdXNpbmcgd2luZG93ICovXG4gIHRoaXMud2hhdmUgPSAwOyAgICAgICAgICAgICAvKiB2YWxpZCBieXRlcyBpbiB0aGUgd2luZG93ICovXG4gIHRoaXMud25leHQgPSAwOyAgICAgICAgICAgICAvKiB3aW5kb3cgd3JpdGUgaW5kZXggKi9cbiAgdGhpcy53aW5kb3cgPSBudWxsOyAgICAgICAgIC8qIGFsbG9jYXRlZCBzbGlkaW5nIHdpbmRvdywgaWYgbmVlZGVkICovXG5cbiAgLyogYml0IGFjY3VtdWxhdG9yICovXG4gIHRoaXMuaG9sZCA9IDA7ICAgICAgICAgICAgICAvKiBpbnB1dCBiaXQgYWNjdW11bGF0b3IgKi9cbiAgdGhpcy5iaXRzID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBiaXRzIGluIFwiaW5cIiAqL1xuXG4gIC8qIGZvciBzdHJpbmcgYW5kIHN0b3JlZCBibG9jayBjb3B5aW5nICovXG4gIHRoaXMubGVuZ3RoID0gMDsgICAgICAgICAgICAvKiBsaXRlcmFsIG9yIGxlbmd0aCBvZiBkYXRhIHRvIGNvcHkgKi9cbiAgdGhpcy5vZmZzZXQgPSAwOyAgICAgICAgICAgIC8qIGRpc3RhbmNlIGJhY2sgdG8gY29weSBzdHJpbmcgZnJvbSAqL1xuXG4gIC8qIGZvciB0YWJsZSBhbmQgY29kZSBkZWNvZGluZyAqL1xuICB0aGlzLmV4dHJhID0gMDsgICAgICAgICAgICAgLyogZXh0cmEgYml0cyBuZWVkZWQgKi9cblxuICAvKiBmaXhlZCBhbmQgZHluYW1pYyBjb2RlIHRhYmxlcyAqL1xuICB0aGlzLmxlbmNvZGUgPSBudWxsOyAgICAgICAgICAvKiBzdGFydGluZyB0YWJsZSBmb3IgbGVuZ3RoL2xpdGVyYWwgY29kZXMgKi9cbiAgdGhpcy5kaXN0Y29kZSA9IG51bGw7ICAgICAgICAgLyogc3RhcnRpbmcgdGFibGUgZm9yIGRpc3RhbmNlIGNvZGVzICovXG4gIHRoaXMubGVuYml0cyA9IDA7ICAgICAgICAgICAvKiBpbmRleCBiaXRzIGZvciBsZW5jb2RlICovXG4gIHRoaXMuZGlzdGJpdHMgPSAwOyAgICAgICAgICAvKiBpbmRleCBiaXRzIGZvciBkaXN0Y29kZSAqL1xuXG4gIC8qIGR5bmFtaWMgdGFibGUgYnVpbGRpbmcgKi9cbiAgdGhpcy5uY29kZSA9IDA7ICAgICAgICAgICAgIC8qIG51bWJlciBvZiBjb2RlIGxlbmd0aCBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy5ubGVuID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBsZW5ndGggY29kZSBsZW5ndGhzICovXG4gIHRoaXMubmRpc3QgPSAwOyAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZGlzdGFuY2UgY29kZSBsZW5ndGhzICovXG4gIHRoaXMuaGF2ZSA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgY29kZSBsZW5ndGhzIGluIGxlbnNbXSAqL1xuICB0aGlzLm5leHQgPSBudWxsOyAgICAgICAgICAgICAgLyogbmV4dCBhdmFpbGFibGUgc3BhY2UgaW4gY29kZXNbXSAqL1xuXG4gIHRoaXMubGVucyA9IG5ldyB1dGlscy5CdWYxNigzMjApOyAvKiB0ZW1wb3Jhcnkgc3RvcmFnZSBmb3IgY29kZSBsZW5ndGhzICovXG4gIHRoaXMud29yayA9IG5ldyB1dGlscy5CdWYxNigyODgpOyAvKiB3b3JrIGFyZWEgZm9yIGNvZGUgdGFibGUgYnVpbGRpbmcgKi9cblxuICAvKlxuICAgYmVjYXVzZSB3ZSBkb24ndCBoYXZlIHBvaW50ZXJzIGluIGpzLCB3ZSB1c2UgbGVuY29kZSBhbmQgZGlzdGNvZGUgZGlyZWN0bHlcbiAgIGFzIGJ1ZmZlcnMgc28gd2UgZG9uJ3QgbmVlZCBjb2Rlc1xuICAqL1xuICAvL3RoaXMuY29kZXMgPSBuZXcgdXRpbHMuQnVmMzIoRU5PVUdIKTsgICAgICAgLyogc3BhY2UgZm9yIGNvZGUgdGFibGVzICovXG4gIHRoaXMubGVuZHluID0gbnVsbDsgICAgICAgICAgICAgIC8qIGR5bmFtaWMgdGFibGUgZm9yIGxlbmd0aC9saXRlcmFsIGNvZGVzIChKUyBzcGVjaWZpYykgKi9cbiAgdGhpcy5kaXN0ZHluID0gbnVsbDsgICAgICAgICAgICAgLyogZHluYW1pYyB0YWJsZSBmb3IgZGlzdGFuY2UgY29kZXMgKEpTIHNwZWNpZmljKSAqL1xuICB0aGlzLnNhbmUgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBpZiBmYWxzZSwgYWxsb3cgaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyICovXG4gIHRoaXMuYmFjayA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIGJpdHMgYmFjayBvZiBsYXN0IHVucHJvY2Vzc2VkIGxlbmd0aC9saXQgKi9cbiAgdGhpcy53YXMgPSAwOyAgICAgICAgICAgICAgICAgICAgLyogaW5pdGlhbCBsZW5ndGggb2YgbWF0Y2ggKi9cbn1cblxuZnVuY3Rpb24gaW5mbGF0ZVJlc2V0S2VlcChzdHJtKSB7XG4gIHZhciBzdGF0ZTtcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgc3RybS50b3RhbF9pbiA9IHN0cm0udG90YWxfb3V0ID0gc3RhdGUudG90YWwgPSAwO1xuICBzdHJtLm1zZyA9ICcnOyAvKlpfTlVMTCovXG4gIGlmIChzdGF0ZS53cmFwKSB7ICAgICAgIC8qIHRvIHN1cHBvcnQgaWxsLWNvbmNlaXZlZCBKYXZhIHRlc3Qgc3VpdGUgKi9cbiAgICBzdHJtLmFkbGVyID0gc3RhdGUud3JhcCAmIDE7XG4gIH1cbiAgc3RhdGUubW9kZSA9IEhFQUQ7XG4gIHN0YXRlLmxhc3QgPSAwO1xuICBzdGF0ZS5oYXZlZGljdCA9IDA7XG4gIHN0YXRlLmRtYXggPSAzMjc2ODtcbiAgc3RhdGUuaGVhZCA9IG51bGwvKlpfTlVMTCovO1xuICBzdGF0ZS5ob2xkID0gMDtcbiAgc3RhdGUuYml0cyA9IDA7XG4gIC8vc3RhdGUubGVuY29kZSA9IHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUubmV4dCA9IHN0YXRlLmNvZGVzO1xuICBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubGVuZHluID0gbmV3IHV0aWxzLkJ1ZjMyKEVOT1VHSF9MRU5TKTtcbiAgc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5kaXN0ZHluID0gbmV3IHV0aWxzLkJ1ZjMyKEVOT1VHSF9ESVNUUyk7XG5cbiAgc3RhdGUuc2FuZSA9IDE7XG4gIHN0YXRlLmJhY2sgPSAtMTtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiByZXNldFxcblwiKSk7XG4gIHJldHVybiBaX09LO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlUmVzZXQoc3RybSkge1xuICB2YXIgc3RhdGU7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIHN0YXRlLndzaXplID0gMDtcbiAgc3RhdGUud2hhdmUgPSAwO1xuICBzdGF0ZS53bmV4dCA9IDA7XG4gIHJldHVybiBpbmZsYXRlUmVzZXRLZWVwKHN0cm0pO1xuXG59XG5cbmZ1bmN0aW9uIGluZmxhdGVSZXNldDIoc3RybSwgd2luZG93Qml0cykge1xuICB2YXIgd3JhcDtcbiAgdmFyIHN0YXRlO1xuXG4gIC8qIGdldCB0aGUgc3RhdGUgKi9cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG5cbiAgLyogZXh0cmFjdCB3cmFwIHJlcXVlc3QgZnJvbSB3aW5kb3dCaXRzIHBhcmFtZXRlciAqL1xuICBpZiAod2luZG93Qml0cyA8IDApIHtcbiAgICB3cmFwID0gMDtcbiAgICB3aW5kb3dCaXRzID0gLXdpbmRvd0JpdHM7XG4gIH1cbiAgZWxzZSB7XG4gICAgd3JhcCA9ICh3aW5kb3dCaXRzID4+IDQpICsgMTtcbiAgICBpZiAod2luZG93Qml0cyA8IDQ4KSB7XG4gICAgICB3aW5kb3dCaXRzICY9IDE1O1xuICAgIH1cbiAgfVxuXG4gIC8qIHNldCBudW1iZXIgb2Ygd2luZG93IGJpdHMsIGZyZWUgd2luZG93IGlmIGRpZmZlcmVudCAqL1xuICBpZiAod2luZG93Qml0cyAmJiAod2luZG93Qml0cyA8IDggfHwgd2luZG93Qml0cyA+IDE1KSkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuICBpZiAoc3RhdGUud2luZG93ICE9PSBudWxsICYmIHN0YXRlLndiaXRzICE9PSB3aW5kb3dCaXRzKSB7XG4gICAgc3RhdGUud2luZG93ID0gbnVsbDtcbiAgfVxuXG4gIC8qIHVwZGF0ZSBzdGF0ZSBhbmQgcmVzZXQgdGhlIHJlc3Qgb2YgaXQgKi9cbiAgc3RhdGUud3JhcCA9IHdyYXA7XG4gIHN0YXRlLndiaXRzID0gd2luZG93Qml0cztcbiAgcmV0dXJuIGluZmxhdGVSZXNldChzdHJtKTtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZUluaXQyKHN0cm0sIHdpbmRvd0JpdHMpIHtcbiAgdmFyIHJldDtcbiAgdmFyIHN0YXRlO1xuXG4gIGlmICghc3RybSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgLy9zdHJtLm1zZyA9IFpfTlVMTDsgICAgICAgICAgICAgICAgIC8qIGluIGNhc2Ugd2UgcmV0dXJuIGFuIGVycm9yICovXG5cbiAgc3RhdGUgPSBuZXcgSW5mbGF0ZVN0YXRlKCk7XG5cbiAgLy9pZiAoc3RhdGUgPT09IFpfTlVMTCkgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6IGFsbG9jYXRlZFxcblwiKSk7XG4gIHN0cm0uc3RhdGUgPSBzdGF0ZTtcbiAgc3RhdGUud2luZG93ID0gbnVsbC8qWl9OVUxMKi87XG4gIHJldCA9IGluZmxhdGVSZXNldDIoc3RybSwgd2luZG93Qml0cyk7XG4gIGlmIChyZXQgIT09IFpfT0spIHtcbiAgICBzdHJtLnN0YXRlID0gbnVsbC8qWl9OVUxMKi87XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZUluaXQoc3RybSkge1xuICByZXR1cm4gaW5mbGF0ZUluaXQyKHN0cm0sIERFRl9XQklUUyk7XG59XG5cblxuLypcbiBSZXR1cm4gc3RhdGUgd2l0aCBsZW5ndGggYW5kIGRpc3RhbmNlIGRlY29kaW5nIHRhYmxlcyBhbmQgaW5kZXggc2l6ZXMgc2V0IHRvXG4gZml4ZWQgY29kZSBkZWNvZGluZy4gIE5vcm1hbGx5IHRoaXMgcmV0dXJucyBmaXhlZCB0YWJsZXMgZnJvbSBpbmZmaXhlZC5oLlxuIElmIEJVSUxERklYRUQgaXMgZGVmaW5lZCwgdGhlbiBpbnN0ZWFkIHRoaXMgcm91dGluZSBidWlsZHMgdGhlIHRhYmxlcyB0aGVcbiBmaXJzdCB0aW1lIGl0J3MgY2FsbGVkLCBhbmQgcmV0dXJucyB0aG9zZSB0YWJsZXMgdGhlIGZpcnN0IHRpbWUgYW5kXG4gdGhlcmVhZnRlci4gIFRoaXMgcmVkdWNlcyB0aGUgc2l6ZSBvZiB0aGUgY29kZSBieSBhYm91dCAySyBieXRlcywgaW5cbiBleGNoYW5nZSBmb3IgYSBsaXR0bGUgZXhlY3V0aW9uIHRpbWUuICBIb3dldmVyLCBCVUlMREZJWEVEIHNob3VsZCBub3QgYmVcbiB1c2VkIGZvciB0aHJlYWRlZCBhcHBsaWNhdGlvbnMsIHNpbmNlIHRoZSByZXdyaXRpbmcgb2YgdGhlIHRhYmxlcyBhbmQgdmlyZ2luXG4gbWF5IG5vdCBiZSB0aHJlYWQtc2FmZS5cbiAqL1xudmFyIHZpcmdpbiA9IHRydWU7XG5cbnZhciBsZW5maXgsIGRpc3RmaXg7IC8vIFdlIGhhdmUgbm8gcG9pbnRlcnMgaW4gSlMsIHNvIGtlZXAgdGFibGVzIHNlcGFyYXRlXG5cbmZ1bmN0aW9uIGZpeGVkdGFibGVzKHN0YXRlKSB7XG4gIC8qIGJ1aWxkIGZpeGVkIGh1ZmZtYW4gdGFibGVzIGlmIGZpcnN0IGNhbGwgKG1heSBub3QgYmUgdGhyZWFkIHNhZmUpICovXG4gIGlmICh2aXJnaW4pIHtcbiAgICB2YXIgc3ltO1xuXG4gICAgbGVuZml4ID0gbmV3IHV0aWxzLkJ1ZjMyKDUxMik7XG4gICAgZGlzdGZpeCA9IG5ldyB1dGlscy5CdWYzMigzMik7XG5cbiAgICAvKiBsaXRlcmFsL2xlbmd0aCB0YWJsZSAqL1xuICAgIHN5bSA9IDA7XG4gICAgd2hpbGUgKHN5bSA8IDE0NCkgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDg7IH1cbiAgICB3aGlsZSAoc3ltIDwgMjU2KSB7IHN0YXRlLmxlbnNbc3ltKytdID0gOTsgfVxuICAgIHdoaWxlIChzeW0gPCAyODApIHsgc3RhdGUubGVuc1tzeW0rK10gPSA3OyB9XG4gICAgd2hpbGUgKHN5bSA8IDI4OCkgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDg7IH1cblxuICAgIGluZmxhdGVfdGFibGUoTEVOUywgIHN0YXRlLmxlbnMsIDAsIDI4OCwgbGVuZml4LCAgIDAsIHN0YXRlLndvcmssIHsgYml0czogOSB9KTtcblxuICAgIC8qIGRpc3RhbmNlIHRhYmxlICovXG4gICAgc3ltID0gMDtcbiAgICB3aGlsZSAoc3ltIDwgMzIpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA1OyB9XG5cbiAgICBpbmZsYXRlX3RhYmxlKERJU1RTLCBzdGF0ZS5sZW5zLCAwLCAzMiwgICBkaXN0Zml4LCAwLCBzdGF0ZS53b3JrLCB7IGJpdHM6IDUgfSk7XG5cbiAgICAvKiBkbyB0aGlzIGp1c3Qgb25jZSAqL1xuICAgIHZpcmdpbiA9IGZhbHNlO1xuICB9XG5cbiAgc3RhdGUubGVuY29kZSA9IGxlbmZpeDtcbiAgc3RhdGUubGVuYml0cyA9IDk7XG4gIHN0YXRlLmRpc3Rjb2RlID0gZGlzdGZpeDtcbiAgc3RhdGUuZGlzdGJpdHMgPSA1O1xufVxuXG5cbi8qXG4gVXBkYXRlIHRoZSB3aW5kb3cgd2l0aCB0aGUgbGFzdCB3c2l6ZSAobm9ybWFsbHkgMzJLKSBieXRlcyB3cml0dGVuIGJlZm9yZVxuIHJldHVybmluZy4gIElmIHdpbmRvdyBkb2VzIG5vdCBleGlzdCB5ZXQsIGNyZWF0ZSBpdC4gIFRoaXMgaXMgb25seSBjYWxsZWRcbiB3aGVuIGEgd2luZG93IGlzIGFscmVhZHkgaW4gdXNlLCBvciB3aGVuIG91dHB1dCBoYXMgYmVlbiB3cml0dGVuIGR1cmluZyB0aGlzXG4gaW5mbGF0ZSBjYWxsLCBidXQgdGhlIGVuZCBvZiB0aGUgZGVmbGF0ZSBzdHJlYW0gaGFzIG5vdCBiZWVuIHJlYWNoZWQgeWV0LlxuIEl0IGlzIGFsc28gY2FsbGVkIHRvIGNyZWF0ZSBhIHdpbmRvdyBmb3IgZGljdGlvbmFyeSBkYXRhIHdoZW4gYSBkaWN0aW9uYXJ5XG4gaXMgbG9hZGVkLlxuXG4gUHJvdmlkaW5nIG91dHB1dCBidWZmZXJzIGxhcmdlciB0aGFuIDMySyB0byBpbmZsYXRlKCkgc2hvdWxkIHByb3ZpZGUgYSBzcGVlZFxuIGFkdmFudGFnZSwgc2luY2Ugb25seSB0aGUgbGFzdCAzMksgb2Ygb3V0cHV0IGlzIGNvcGllZCB0byB0aGUgc2xpZGluZyB3aW5kb3dcbiB1cG9uIHJldHVybiBmcm9tIGluZmxhdGUoKSwgYW5kIHNpbmNlIGFsbCBkaXN0YW5jZXMgYWZ0ZXIgdGhlIGZpcnN0IDMySyBvZlxuIG91dHB1dCB3aWxsIGZhbGwgaW4gdGhlIG91dHB1dCBkYXRhLCBtYWtpbmcgbWF0Y2ggY29waWVzIHNpbXBsZXIgYW5kIGZhc3Rlci5cbiBUaGUgYWR2YW50YWdlIG1heSBiZSBkZXBlbmRlbnQgb24gdGhlIHNpemUgb2YgdGhlIHByb2Nlc3NvcidzIGRhdGEgY2FjaGVzLlxuICovXG5mdW5jdGlvbiB1cGRhdGV3aW5kb3coc3RybSwgc3JjLCBlbmQsIGNvcHkpIHtcbiAgdmFyIGRpc3Q7XG4gIHZhciBzdGF0ZSA9IHN0cm0uc3RhdGU7XG5cbiAgLyogaWYgaXQgaGFzbid0IGJlZW4gZG9uZSBhbHJlYWR5LCBhbGxvY2F0ZSBzcGFjZSBmb3IgdGhlIHdpbmRvdyAqL1xuICBpZiAoc3RhdGUud2luZG93ID09PSBudWxsKSB7XG4gICAgc3RhdGUud3NpemUgPSAxIDw8IHN0YXRlLndiaXRzO1xuICAgIHN0YXRlLnduZXh0ID0gMDtcbiAgICBzdGF0ZS53aGF2ZSA9IDA7XG5cbiAgICBzdGF0ZS53aW5kb3cgPSBuZXcgdXRpbHMuQnVmOChzdGF0ZS53c2l6ZSk7XG4gIH1cblxuICAvKiBjb3B5IHN0YXRlLT53c2l6ZSBvciBsZXNzIG91dHB1dCBieXRlcyBpbnRvIHRoZSBjaXJjdWxhciB3aW5kb3cgKi9cbiAgaWYgKGNvcHkgPj0gc3RhdGUud3NpemUpIHtcbiAgICB1dGlscy5hcnJheVNldChzdGF0ZS53aW5kb3csIHNyYywgZW5kIC0gc3RhdGUud3NpemUsIHN0YXRlLndzaXplLCAwKTtcbiAgICBzdGF0ZS53bmV4dCA9IDA7XG4gICAgc3RhdGUud2hhdmUgPSBzdGF0ZS53c2l6ZTtcbiAgfVxuICBlbHNlIHtcbiAgICBkaXN0ID0gc3RhdGUud3NpemUgLSBzdGF0ZS53bmV4dDtcbiAgICBpZiAoZGlzdCA+IGNvcHkpIHtcbiAgICAgIGRpc3QgPSBjb3B5O1xuICAgIH1cbiAgICAvL3ptZW1jcHkoc3RhdGUtPndpbmRvdyArIHN0YXRlLT53bmV4dCwgZW5kIC0gY29weSwgZGlzdCk7XG4gICAgdXRpbHMuYXJyYXlTZXQoc3RhdGUud2luZG93LCBzcmMsIGVuZCAtIGNvcHksIGRpc3QsIHN0YXRlLnduZXh0KTtcbiAgICBjb3B5IC09IGRpc3Q7XG4gICAgaWYgKGNvcHkpIHtcbiAgICAgIC8vem1lbWNweShzdGF0ZS0+d2luZG93LCBlbmQgLSBjb3B5LCBjb3B5KTtcbiAgICAgIHV0aWxzLmFycmF5U2V0KHN0YXRlLndpbmRvdywgc3JjLCBlbmQgLSBjb3B5LCBjb3B5LCAwKTtcbiAgICAgIHN0YXRlLnduZXh0ID0gY29weTtcbiAgICAgIHN0YXRlLndoYXZlID0gc3RhdGUud3NpemU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgc3RhdGUud25leHQgKz0gZGlzdDtcbiAgICAgIGlmIChzdGF0ZS53bmV4dCA9PT0gc3RhdGUud3NpemUpIHsgc3RhdGUud25leHQgPSAwOyB9XG4gICAgICBpZiAoc3RhdGUud2hhdmUgPCBzdGF0ZS53c2l6ZSkgeyBzdGF0ZS53aGF2ZSArPSBkaXN0OyB9XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlKHN0cm0sIGZsdXNoKSB7XG4gIHZhciBzdGF0ZTtcbiAgdmFyIGlucHV0LCBvdXRwdXQ7ICAgICAgICAgIC8vIGlucHV0L291dHB1dCBidWZmZXJzXG4gIHZhciBuZXh0OyAgICAgICAgICAgICAgICAgICAvKiBuZXh0IGlucHV0IElOREVYICovXG4gIHZhciBwdXQ7ICAgICAgICAgICAgICAgICAgICAvKiBuZXh0IG91dHB1dCBJTkRFWCAqL1xuICB2YXIgaGF2ZSwgbGVmdDsgICAgICAgICAgICAgLyogYXZhaWxhYmxlIGlucHV0IGFuZCBvdXRwdXQgKi9cbiAgdmFyIGhvbGQ7ICAgICAgICAgICAgICAgICAgIC8qIGJpdCBidWZmZXIgKi9cbiAgdmFyIGJpdHM7ICAgICAgICAgICAgICAgICAgIC8qIGJpdHMgaW4gYml0IGJ1ZmZlciAqL1xuICB2YXIgX2luLCBfb3V0OyAgICAgICAgICAgICAgLyogc2F2ZSBzdGFydGluZyBhdmFpbGFibGUgaW5wdXQgYW5kIG91dHB1dCAqL1xuICB2YXIgY29weTsgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIHN0b3JlZCBvciBtYXRjaCBieXRlcyB0byBjb3B5ICovXG4gIHZhciBmcm9tOyAgICAgICAgICAgICAgICAgICAvKiB3aGVyZSB0byBjb3B5IG1hdGNoIGJ5dGVzIGZyb20gKi9cbiAgdmFyIGZyb21fc291cmNlO1xuICB2YXIgaGVyZSA9IDA7ICAgICAgICAgICAgICAgLyogY3VycmVudCBkZWNvZGluZyB0YWJsZSBlbnRyeSAqL1xuICB2YXIgaGVyZV9iaXRzLCBoZXJlX29wLCBoZXJlX3ZhbDsgLy8gcGFrZWQgXCJoZXJlXCIgZGVub3JtYWxpemVkIChKUyBzcGVjaWZpYylcbiAgLy92YXIgbGFzdDsgICAgICAgICAgICAgICAgICAgLyogcGFyZW50IHRhYmxlIGVudHJ5ICovXG4gIHZhciBsYXN0X2JpdHMsIGxhc3Rfb3AsIGxhc3RfdmFsOyAvLyBwYWtlZCBcImxhc3RcIiBkZW5vcm1hbGl6ZWQgKEpTIHNwZWNpZmljKVxuICB2YXIgbGVuOyAgICAgICAgICAgICAgICAgICAgLyogbGVuZ3RoIHRvIGNvcHkgZm9yIHJlcGVhdHMsIGJpdHMgdG8gZHJvcCAqL1xuICB2YXIgcmV0OyAgICAgICAgICAgICAgICAgICAgLyogcmV0dXJuIGNvZGUgKi9cbiAgdmFyIGhidWYgPSBuZXcgdXRpbHMuQnVmOCg0KTsgICAgLyogYnVmZmVyIGZvciBnemlwIGhlYWRlciBjcmMgY2FsY3VsYXRpb24gKi9cbiAgdmFyIG9wdHM7XG5cbiAgdmFyIG47IC8vIHRlbXBvcmFyeSB2YXIgZm9yIE5FRURfQklUU1xuXG4gIHZhciBvcmRlciA9IC8qIHBlcm11dGF0aW9uIG9mIGNvZGUgbGVuZ3RocyAqL1xuICAgIFsgMTYsIDE3LCAxOCwgMCwgOCwgNywgOSwgNiwgMTAsIDUsIDExLCA0LCAxMiwgMywgMTMsIDIsIDE0LCAxLCAxNSBdO1xuXG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlIHx8ICFzdHJtLm91dHB1dCB8fFxuICAgICAgKCFzdHJtLmlucHV0ICYmIHN0cm0uYXZhaWxfaW4gIT09IDApKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBpZiAoc3RhdGUubW9kZSA9PT0gVFlQRSkgeyBzdGF0ZS5tb2RlID0gVFlQRURPOyB9ICAgIC8qIHNraXAgY2hlY2sgKi9cblxuXG4gIC8vLS0tIExPQUQoKSAtLS1cbiAgcHV0ID0gc3RybS5uZXh0X291dDtcbiAgb3V0cHV0ID0gc3RybS5vdXRwdXQ7XG4gIGxlZnQgPSBzdHJtLmF2YWlsX291dDtcbiAgbmV4dCA9IHN0cm0ubmV4dF9pbjtcbiAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICBoYXZlID0gc3RybS5hdmFpbF9pbjtcbiAgaG9sZCA9IHN0YXRlLmhvbGQ7XG4gIGJpdHMgPSBzdGF0ZS5iaXRzO1xuICAvLy0tLVxuXG4gIF9pbiA9IGhhdmU7XG4gIF9vdXQgPSBsZWZ0O1xuICByZXQgPSBaX09LO1xuXG4gIGluZl9sZWF2ZTogLy8gZ290byBlbXVsYXRpb25cbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoc3RhdGUubW9kZSkge1xuICAgIGNhc2UgSEVBRDpcbiAgICAgIGlmIChzdGF0ZS53cmFwID09PSAwKSB7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFRE87XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy89PT0gTkVFREJJVFMoMTYpO1xuICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgaGF2ZS0tO1xuICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgYml0cyArPSA4O1xuICAgICAgfVxuICAgICAgLy89PT0vL1xuICAgICAgaWYgKChzdGF0ZS53cmFwICYgMikgJiYgaG9sZCA9PT0gMHg4YjFmKSB7ICAvKiBnemlwIGhlYWRlciAqL1xuICAgICAgICBzdGF0ZS5jaGVjayA9IDAvKmNyYzMyKDBMLCBaX05VTEwsIDApKi87XG4gICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgLy89PT0vL1xuXG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gRkxBR1M7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc3RhdGUuZmxhZ3MgPSAwOyAgICAgICAgICAgLyogZXhwZWN0IHpsaWIgaGVhZGVyICovXG4gICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICBzdGF0ZS5oZWFkLmRvbmUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICghKHN0YXRlLndyYXAgJiAxKSB8fCAgIC8qIGNoZWNrIGlmIHpsaWIgaGVhZGVyIGFsbG93ZWQgKi9cbiAgICAgICAgKCgoaG9sZCAmIDB4ZmYpLypCSVRTKDgpKi8gPDwgOCkgKyAoaG9sZCA+PiA4KSkgJSAzMSkge1xuICAgICAgICBzdHJtLm1zZyA9ICdpbmNvcnJlY3QgaGVhZGVyIGNoZWNrJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoKGhvbGQgJiAweDBmKS8qQklUUyg0KSovICE9PSBaX0RFRkxBVEVEKSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ3Vua25vd24gY29tcHJlc3Npb24gbWV0aG9kJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLy0tLSBEUk9QQklUUyg0KSAtLS0vL1xuICAgICAgaG9sZCA+Pj49IDQ7XG4gICAgICBiaXRzIC09IDQ7XG4gICAgICAvLy0tLS8vXG4gICAgICBsZW4gPSAoaG9sZCAmIDB4MGYpLypCSVRTKDQpKi8gKyA4O1xuICAgICAgaWYgKHN0YXRlLndiaXRzID09PSAwKSB7XG4gICAgICAgIHN0YXRlLndiaXRzID0gbGVuO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAobGVuID4gc3RhdGUud2JpdHMpIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCB3aW5kb3cgc2l6ZSc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc3RhdGUuZG1heCA9IDEgPDwgbGVuO1xuICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIHpsaWIgaGVhZGVyIG9rXFxuXCIpKTtcbiAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDEvKmFkbGVyMzIoMEwsIFpfTlVMTCwgMCkqLztcbiAgICAgIHN0YXRlLm1vZGUgPSBob2xkICYgMHgyMDAgPyBESUNUSUQgOiBUWVBFO1xuICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgIGhvbGQgPSAwO1xuICAgICAgYml0cyA9IDA7XG4gICAgICAvLz09PS8vXG4gICAgICBicmVhaztcbiAgICBjYXNlIEZMQUdTOlxuICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgaGF2ZS0tO1xuICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgYml0cyArPSA4O1xuICAgICAgfVxuICAgICAgLy89PT0vL1xuICAgICAgc3RhdGUuZmxhZ3MgPSBob2xkO1xuICAgICAgaWYgKChzdGF0ZS5mbGFncyAmIDB4ZmYpICE9PSBaX0RFRkxBVEVEKSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ3Vua25vd24gY29tcHJlc3Npb24gbWV0aG9kJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweGUwMDApIHtcbiAgICAgICAgc3RybS5tc2cgPSAndW5rbm93biBoZWFkZXIgZmxhZ3Mgc2V0JztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICBzdGF0ZS5oZWFkLnRleHQgPSAoKGhvbGQgPj4gOCkgJiAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgIH1cbiAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICBob2xkID0gMDtcbiAgICAgIGJpdHMgPSAwO1xuICAgICAgLy89PT0vL1xuICAgICAgc3RhdGUubW9kZSA9IFRJTUU7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBUSU1FOlxuICAgICAgLy89PT0gTkVFREJJVFMoMzIpOyAqL1xuICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgaGF2ZS0tO1xuICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgYml0cyArPSA4O1xuICAgICAgfVxuICAgICAgLy89PT0vL1xuICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgc3RhdGUuaGVhZC50aW1lID0gaG9sZDtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAvLz09PSBDUkM0KHN0YXRlLmNoZWNrLCBob2xkKVxuICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICBoYnVmWzJdID0gKGhvbGQgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgIGhidWZbM10gPSAoaG9sZCA+Pj4gMjQpICYgMHhmZjtcbiAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgNCwgMCk7XG4gICAgICAgIC8vPT09XG4gICAgICB9XG4gICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgaG9sZCA9IDA7XG4gICAgICBiaXRzID0gMDtcbiAgICAgIC8vPT09Ly9cbiAgICAgIHN0YXRlLm1vZGUgPSBPUztcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIE9TOlxuICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgaGF2ZS0tO1xuICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgYml0cyArPSA4O1xuICAgICAgfVxuICAgICAgLy89PT0vL1xuICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgc3RhdGUuaGVhZC54ZmxhZ3MgPSAoaG9sZCAmIDB4ZmYpO1xuICAgICAgICBzdGF0ZS5oZWFkLm9zID0gKGhvbGQgPj4gOCk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAvLz09PS8vXG4gICAgICB9XG4gICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgaG9sZCA9IDA7XG4gICAgICBiaXRzID0gMDtcbiAgICAgIC8vPT09Ly9cbiAgICAgIHN0YXRlLm1vZGUgPSBFWExFTjtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIEVYTEVOOlxuICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwNDAwKSB7XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5sZW5ndGggPSBob2xkO1xuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmFfbGVuID0gaG9sZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhID0gbnVsbC8qWl9OVUxMKi87XG4gICAgICB9XG4gICAgICBzdGF0ZS5tb2RlID0gRVhUUkE7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBFWFRSQTpcbiAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDQwMCkge1xuICAgICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICBpZiAoY29weSA+IGhhdmUpIHsgY29weSA9IGhhdmU7IH1cbiAgICAgICAgaWYgKGNvcHkpIHtcbiAgICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgICAgbGVuID0gc3RhdGUuaGVhZC5leHRyYV9sZW4gLSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoIXN0YXRlLmhlYWQuZXh0cmEpIHtcbiAgICAgICAgICAgICAgLy8gVXNlIHVudHlwZWQgYXJyYXkgZm9yIG1vcmUgY29udmVuaWVuZCBwcm9jZXNzaW5nIGxhdGVyXG4gICAgICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmEgPSBuZXcgQXJyYXkoc3RhdGUuaGVhZC5leHRyYV9sZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXRpbHMuYXJyYXlTZXQoXG4gICAgICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmEsXG4gICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICBuZXh0LFxuICAgICAgICAgICAgICAvLyBleHRyYSBmaWVsZCBpcyBsaW1pdGVkIHRvIDY1NTM2IGJ5dGVzXG4gICAgICAgICAgICAgIC8vIC0gbm8gbmVlZCBmb3IgYWRkaXRpb25hbCBzaXplIGNoZWNrXG4gICAgICAgICAgICAgIGNvcHksXG4gICAgICAgICAgICAgIC8qbGVuICsgY29weSA+IHN0YXRlLmhlYWQuZXh0cmFfbWF4IC0gbGVuID8gc3RhdGUuaGVhZC5leHRyYV9tYXggOiBjb3B5LCovXG4gICAgICAgICAgICAgIGxlblxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIC8vem1lbWNweShzdGF0ZS5oZWFkLmV4dHJhICsgbGVuLCBuZXh0LFxuICAgICAgICAgICAgLy8gICAgICAgIGxlbiArIGNvcHkgPiBzdGF0ZS5oZWFkLmV4dHJhX21heCA/XG4gICAgICAgICAgICAvLyAgICAgICAgc3RhdGUuaGVhZC5leHRyYV9tYXggLSBsZW4gOiBjb3B5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBpbnB1dCwgY29weSwgbmV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgIH1cbiAgICAgIHN0YXRlLmxlbmd0aCA9IDA7XG4gICAgICBzdGF0ZS5tb2RlID0gTkFNRTtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIE5BTUU6XG4gICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDA4MDApIHtcbiAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGNvcHkgPSAwO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgLy8gVE9ETzogMiBvciAxIGJ5dGVzP1xuICAgICAgICAgIGxlbiA9IGlucHV0W25leHQgKyBjb3B5KytdO1xuICAgICAgICAgIC8qIHVzZSBjb25zdGFudCBsaW1pdCBiZWNhdXNlIGluIGpzIHdlIHNob3VsZCBub3QgcHJlYWxsb2NhdGUgbWVtb3J5ICovXG4gICAgICAgICAgaWYgKHN0YXRlLmhlYWQgJiYgbGVuICYmXG4gICAgICAgICAgICAgIChzdGF0ZS5sZW5ndGggPCA2NTUzNiAvKnN0YXRlLmhlYWQubmFtZV9tYXgqLykpIHtcbiAgICAgICAgICAgIHN0YXRlLmhlYWQubmFtZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxlbik7XG4gICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChsZW4gJiYgY29weSA8IGhhdmUpO1xuXG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgaWYgKGxlbikgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgc3RhdGUuaGVhZC5uYW1lID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHN0YXRlLmxlbmd0aCA9IDA7XG4gICAgICBzdGF0ZS5tb2RlID0gQ09NTUVOVDtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIENPTU1FTlQ6XG4gICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDEwMDApIHtcbiAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGNvcHkgPSAwO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgbGVuID0gaW5wdXRbbmV4dCArIGNvcHkrK107XG4gICAgICAgICAgLyogdXNlIGNvbnN0YW50IGxpbWl0IGJlY2F1c2UgaW4ganMgd2Ugc2hvdWxkIG5vdCBwcmVhbGxvY2F0ZSBtZW1vcnkgKi9cbiAgICAgICAgICBpZiAoc3RhdGUuaGVhZCAmJiBsZW4gJiZcbiAgICAgICAgICAgICAgKHN0YXRlLmxlbmd0aCA8IDY1NTM2IC8qc3RhdGUuaGVhZC5jb21tX21heCovKSkge1xuICAgICAgICAgICAgc3RhdGUuaGVhZC5jb21tZW50ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGVuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKGxlbiAmJiBjb3B5IDwgaGF2ZSk7XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgaWYgKGxlbikgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgc3RhdGUuaGVhZC5jb21tZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHN0YXRlLm1vZGUgPSBIQ1JDO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgSENSQzpcbiAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKGhvbGQgIT09IChzdGF0ZS5jaGVjayAmIDB4ZmZmZikpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdoZWFkZXIgY3JjIG1pc21hdGNoJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgc3RhdGUuaGVhZC5oY3JjID0gKChzdGF0ZS5mbGFncyA+PiA5KSAmIDEpO1xuICAgICAgICBzdGF0ZS5oZWFkLmRvbmUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMDtcbiAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBESUNUSUQ6XG4gICAgICAvLz09PSBORUVEQklUUygzMik7ICovXG4gICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBoYXZlLS07XG4gICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICBiaXRzICs9IDg7XG4gICAgICB9XG4gICAgICAvLz09PS8vXG4gICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSB6c3dhcDMyKGhvbGQpO1xuICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgIGhvbGQgPSAwO1xuICAgICAgYml0cyA9IDA7XG4gICAgICAvLz09PS8vXG4gICAgICBzdGF0ZS5tb2RlID0gRElDVDtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIERJQ1Q6XG4gICAgICBpZiAoc3RhdGUuaGF2ZWRpY3QgPT09IDApIHtcbiAgICAgICAgLy8tLS0gUkVTVE9SRSgpIC0tLVxuICAgICAgICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICAgICAgICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gICAgICAgIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gICAgICAgIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICAgICAgICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgICAgICAgc3RhdGUuYml0cyA9IGJpdHM7XG4gICAgICAgIC8vLS0tXG4gICAgICAgIHJldHVybiBaX05FRURfRElDVDtcbiAgICAgIH1cbiAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDEvKmFkbGVyMzIoMEwsIFpfTlVMTCwgMCkqLztcbiAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgVFlQRTpcbiAgICAgIGlmIChmbHVzaCA9PT0gWl9CTE9DSyB8fCBmbHVzaCA9PT0gWl9UUkVFUykgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIFRZUEVETzpcbiAgICAgIGlmIChzdGF0ZS5sYXN0KSB7XG4gICAgICAgIC8vLS0tIEJZVEVCSVRTKCkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IGJpdHMgJiA3O1xuICAgICAgICBiaXRzIC09IGJpdHMgJiA3O1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBDSEVDSztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLz09PSBORUVEQklUUygzKTsgKi9cbiAgICAgIHdoaWxlIChiaXRzIDwgMykge1xuICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgaGF2ZS0tO1xuICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgYml0cyArPSA4O1xuICAgICAgfVxuICAgICAgLy89PT0vL1xuICAgICAgc3RhdGUubGFzdCA9IChob2xkICYgMHgwMSkvKkJJVFMoMSkqLztcbiAgICAgIC8vLS0tIERST1BCSVRTKDEpIC0tLS8vXG4gICAgICBob2xkID4+Pj0gMTtcbiAgICAgIGJpdHMgLT0gMTtcbiAgICAgIC8vLS0tLy9cblxuICAgICAgc3dpdGNoICgoaG9sZCAmIDB4MDMpLypCSVRTKDIpKi8pIHtcbiAgICAgIGNhc2UgMDogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIHN0b3JlZCBibG9jayAqL1xuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICBzdG9yZWQgYmxvY2slc1xcblwiLFxuICAgICAgICAvLyAgICAgICAgc3RhdGUubGFzdCA/IFwiIChsYXN0KVwiIDogXCJcIikpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gU1RPUkVEO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGZpeGVkIGJsb2NrICovXG4gICAgICAgIGZpeGVkdGFibGVzKHN0YXRlKTtcbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgZml4ZWQgY29kZXMgYmxvY2slc1xcblwiLFxuICAgICAgICAvLyAgICAgICAgc3RhdGUubGFzdCA/IFwiIChsYXN0KVwiIDogXCJcIikpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOXzsgICAgICAgICAgICAgLyogZGVjb2RlIGNvZGVzICovXG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykge1xuICAgICAgICAgIC8vLS0tIERST1BCSVRTKDIpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IDI7XG4gICAgICAgICAgYml0cyAtPSAyO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBicmVhayBpbmZfbGVhdmU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBkeW5hbWljIGJsb2NrICovXG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgIGR5bmFtaWMgY29kZXMgYmxvY2slc1xcblwiLFxuICAgICAgICAvLyAgICAgICAgc3RhdGUubGFzdCA/IFwiIChsYXN0KVwiIDogXCJcIikpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gVEFCTEU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGJsb2NrIHR5cGUnO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgfVxuICAgICAgLy8tLS0gRFJPUEJJVFMoMikgLS0tLy9cbiAgICAgIGhvbGQgPj4+PSAyO1xuICAgICAgYml0cyAtPSAyO1xuICAgICAgLy8tLS0vL1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTVE9SRUQ6XG4gICAgICAvLy0tLSBCWVRFQklUUygpIC0tLS8vIC8qIGdvIHRvIGJ5dGUgYm91bmRhcnkgKi9cbiAgICAgIGhvbGQgPj4+PSBiaXRzICYgNztcbiAgICAgIGJpdHMgLT0gYml0cyAmIDc7XG4gICAgICAvLy0tLS8vXG4gICAgICAvLz09PSBORUVEQklUUygzMik7ICovXG4gICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBoYXZlLS07XG4gICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICBiaXRzICs9IDg7XG4gICAgICB9XG4gICAgICAvLz09PS8vXG4gICAgICBpZiAoKGhvbGQgJiAweGZmZmYpICE9PSAoKGhvbGQgPj4+IDE2KSBeIDB4ZmZmZikpIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBzdG9yZWQgYmxvY2sgbGVuZ3Rocyc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc3RhdGUubGVuZ3RoID0gaG9sZCAmIDB4ZmZmZjtcbiAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgc3RvcmVkIGxlbmd0aCAldVxcblwiLFxuICAgICAgLy8gICAgICAgIHN0YXRlLmxlbmd0aCkpO1xuICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgIGhvbGQgPSAwO1xuICAgICAgYml0cyA9IDA7XG4gICAgICAvLz09PS8vXG4gICAgICBzdGF0ZS5tb2RlID0gQ09QWV87XG4gICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBDT1BZXzpcbiAgICAgIHN0YXRlLm1vZGUgPSBDT1BZO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgQ09QWTpcbiAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICBpZiAoY29weSkge1xuICAgICAgICBpZiAoY29weSA+IGhhdmUpIHsgY29weSA9IGhhdmU7IH1cbiAgICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7IGNvcHkgPSBsZWZ0OyB9XG4gICAgICAgIGlmIChjb3B5ID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAvLy0tLSB6bWVtY3B5KHB1dCwgbmV4dCwgY29weSk7IC0tLVxuICAgICAgICB1dGlscy5hcnJheVNldChvdXRwdXQsIGlucHV0LCBuZXh0LCBjb3B5LCBwdXQpO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICBsZWZ0IC09IGNvcHk7XG4gICAgICAgIHB1dCArPSBjb3B5O1xuICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIHN0b3JlZCBlbmRcXG5cIikpO1xuICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFRBQkxFOlxuICAgICAgLy89PT0gTkVFREJJVFMoMTQpOyAqL1xuICAgICAgd2hpbGUgKGJpdHMgPCAxNCkge1xuICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgaGF2ZS0tO1xuICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgYml0cyArPSA4O1xuICAgICAgfVxuICAgICAgLy89PT0vL1xuICAgICAgc3RhdGUubmxlbiA9IChob2xkICYgMHgxZikvKkJJVFMoNSkqLyArIDI1NztcbiAgICAgIC8vLS0tIERST1BCSVRTKDUpIC0tLS8vXG4gICAgICBob2xkID4+Pj0gNTtcbiAgICAgIGJpdHMgLT0gNTtcbiAgICAgIC8vLS0tLy9cbiAgICAgIHN0YXRlLm5kaXN0ID0gKGhvbGQgJiAweDFmKS8qQklUUyg1KSovICsgMTtcbiAgICAgIC8vLS0tIERST1BCSVRTKDUpIC0tLS8vXG4gICAgICBob2xkID4+Pj0gNTtcbiAgICAgIGJpdHMgLT0gNTtcbiAgICAgIC8vLS0tLy9cbiAgICAgIHN0YXRlLm5jb2RlID0gKGhvbGQgJiAweDBmKS8qQklUUyg0KSovICsgNDtcbiAgICAgIC8vLS0tIERST1BCSVRTKDQpIC0tLS8vXG4gICAgICBob2xkID4+Pj0gNDtcbiAgICAgIGJpdHMgLT0gNDtcbiAgICAgIC8vLS0tLy9cbi8vI2lmbmRlZiBQS1pJUF9CVUdfV09SS0FST1VORFxuICAgICAgaWYgKHN0YXRlLm5sZW4gPiAyODYgfHwgc3RhdGUubmRpc3QgPiAzMCkge1xuICAgICAgICBzdHJtLm1zZyA9ICd0b28gbWFueSBsZW5ndGggb3IgZGlzdGFuY2Ugc3ltYm9scyc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuLy8jZW5kaWZcbiAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgdGFibGUgc2l6ZXMgb2tcXG5cIikpO1xuICAgICAgc3RhdGUuaGF2ZSA9IDA7XG4gICAgICBzdGF0ZS5tb2RlID0gTEVOTEVOUztcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIExFTkxFTlM6XG4gICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IHN0YXRlLm5jb2RlKSB7XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDMpO1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubGVuc1tvcmRlcltzdGF0ZS5oYXZlKytdXSA9IChob2xkICYgMHgwNyk7Ly9CSVRTKDMpO1xuICAgICAgICAvLy0tLSBEUk9QQklUUygzKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gMztcbiAgICAgICAgYml0cyAtPSAzO1xuICAgICAgICAvLy0tLS8vXG4gICAgICB9XG4gICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IDE5KSB7XG4gICAgICAgIHN0YXRlLmxlbnNbb3JkZXJbc3RhdGUuaGF2ZSsrXV0gPSAwO1xuICAgICAgfVxuICAgICAgLy8gV2UgaGF2ZSBzZXBhcmF0ZSB0YWJsZXMgJiBubyBwb2ludGVycy4gMiBjb21tZW50ZWQgbGluZXMgYmVsb3cgbm90IG5lZWRlZC5cbiAgICAgIC8vc3RhdGUubmV4dCA9IHN0YXRlLmNvZGVzO1xuICAgICAgLy9zdGF0ZS5sZW5jb2RlID0gc3RhdGUubmV4dDtcbiAgICAgIC8vIFN3aXRjaCB0byB1c2UgZHluYW1pYyB0YWJsZVxuICAgICAgc3RhdGUubGVuY29kZSA9IHN0YXRlLmxlbmR5bjtcbiAgICAgIHN0YXRlLmxlbmJpdHMgPSA3O1xuXG4gICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5sZW5iaXRzIH07XG4gICAgICByZXQgPSBpbmZsYXRlX3RhYmxlKENPREVTLCBzdGF0ZS5sZW5zLCAwLCAxOSwgc3RhdGUubGVuY29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7XG4gICAgICBzdGF0ZS5sZW5iaXRzID0gb3B0cy5iaXRzO1xuXG4gICAgICBpZiAocmV0KSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgY29kZSBsZW5ndGhzIHNldCc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICBjb2RlIGxlbmd0aHMgb2tcXG5cIikpO1xuICAgICAgc3RhdGUuaGF2ZSA9IDA7XG4gICAgICBzdGF0ZS5tb2RlID0gQ09ERUxFTlM7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBDT0RFTEVOUzpcbiAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgc3RhdGUubmxlbiArIHN0YXRlLm5kaXN0KSB7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtob2xkICYgKCgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMSldOy8qQklUUyhzdGF0ZS5sZW5iaXRzKSovXG4gICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgIGlmICgoaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZXJlX3ZhbCA8IDE2KSB7XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSsrXSA9IGhlcmVfdmFsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmIChoZXJlX3ZhbCA9PT0gMTYpIHtcbiAgICAgICAgICAgIC8vPT09IE5FRURCSVRTKGhlcmUuYml0cyArIDIpO1xuICAgICAgICAgICAgbiA9IGhlcmVfYml0cyArIDI7XG4gICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIGlmIChzdGF0ZS5oYXZlID09PSAwKSB7XG4gICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgYml0IGxlbmd0aCByZXBlYXQnO1xuICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxlbiA9IHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSAtIDFdO1xuICAgICAgICAgICAgY29weSA9IDMgKyAoaG9sZCAmIDB4MDMpOy8vQklUUygyKTtcbiAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDIpIC0tLS8vXG4gICAgICAgICAgICBob2xkID4+Pj0gMjtcbiAgICAgICAgICAgIGJpdHMgLT0gMjtcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoaGVyZV92YWwgPT09IDE3KSB7XG4gICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyAzKTtcbiAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyAzO1xuICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICBsZW4gPSAwO1xuICAgICAgICAgICAgY29weSA9IDMgKyAoaG9sZCAmIDB4MDcpOy8vQklUUygzKTtcbiAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDMpIC0tLS8vXG4gICAgICAgICAgICBob2xkID4+Pj0gMztcbiAgICAgICAgICAgIGJpdHMgLT0gMztcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyA3KTtcbiAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyA3O1xuICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICBsZW4gPSAwO1xuICAgICAgICAgICAgY29weSA9IDExICsgKGhvbGQgJiAweDdmKTsvL0JJVFMoNyk7XG4gICAgICAgICAgICAvLy0tLSBEUk9QQklUUyg3KSAtLS0vL1xuICAgICAgICAgICAgaG9sZCA+Pj49IDc7XG4gICAgICAgICAgICBiaXRzIC09IDc7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGF0ZS5oYXZlICsgY29weSA+IHN0YXRlLm5sZW4gKyBzdGF0ZS5uZGlzdCkge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBiaXQgbGVuZ3RoIHJlcGVhdCc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdoaWxlIChjb3B5LS0pIHtcbiAgICAgICAgICAgIHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSsrXSA9IGxlbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyogaGFuZGxlIGVycm9yIGJyZWFrcyBpbiB3aGlsZSAqL1xuICAgICAgaWYgKHN0YXRlLm1vZGUgPT09IEJBRCkgeyBicmVhazsgfVxuXG4gICAgICAvKiBjaGVjayBmb3IgZW5kLW9mLWJsb2NrIGNvZGUgKGJldHRlciBoYXZlIG9uZSkgKi9cbiAgICAgIGlmIChzdGF0ZS5sZW5zWzI1Nl0gPT09IDApIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBjb2RlIC0tIG1pc3NpbmcgZW5kLW9mLWJsb2NrJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIC8qIGJ1aWxkIGNvZGUgdGFibGVzIC0tIG5vdGU6IGRvIG5vdCBjaGFuZ2UgdGhlIGxlbmJpdHMgb3IgZGlzdGJpdHNcbiAgICAgICAgIHZhbHVlcyBoZXJlICg5IGFuZCA2KSB3aXRob3V0IHJlYWRpbmcgdGhlIGNvbW1lbnRzIGluIGluZnRyZWVzLmhcbiAgICAgICAgIGNvbmNlcm5pbmcgdGhlIEVOT1VHSCBjb25zdGFudHMsIHdoaWNoIGRlcGVuZCBvbiB0aG9zZSB2YWx1ZXMgKi9cbiAgICAgIHN0YXRlLmxlbmJpdHMgPSA5O1xuXG4gICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5sZW5iaXRzIH07XG4gICAgICByZXQgPSBpbmZsYXRlX3RhYmxlKExFTlMsIHN0YXRlLmxlbnMsIDAsIHN0YXRlLm5sZW4sIHN0YXRlLmxlbmNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpO1xuICAgICAgLy8gV2UgaGF2ZSBzZXBhcmF0ZSB0YWJsZXMgJiBubyBwb2ludGVycy4gMiBjb21tZW50ZWQgbGluZXMgYmVsb3cgbm90IG5lZWRlZC5cbiAgICAgIC8vIHN0YXRlLm5leHRfaW5kZXggPSBvcHRzLnRhYmxlX2luZGV4O1xuICAgICAgc3RhdGUubGVuYml0cyA9IG9wdHMuYml0cztcbiAgICAgIC8vIHN0YXRlLmxlbmNvZGUgPSBzdGF0ZS5uZXh0O1xuXG4gICAgICBpZiAocmV0KSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgbGl0ZXJhbC9sZW5ndGhzIHNldCc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBzdGF0ZS5kaXN0Yml0cyA9IDY7XG4gICAgICAvL3N0YXRlLmRpc3Rjb2RlLmNvcHkoc3RhdGUuY29kZXMpO1xuICAgICAgLy8gU3dpdGNoIHRvIHVzZSBkeW5hbWljIHRhYmxlXG4gICAgICBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLmRpc3RkeW47XG4gICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5kaXN0Yml0cyB9O1xuICAgICAgcmV0ID0gaW5mbGF0ZV90YWJsZShESVNUUywgc3RhdGUubGVucywgc3RhdGUubmxlbiwgc3RhdGUubmRpc3QsIHN0YXRlLmRpc3Rjb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTtcbiAgICAgIC8vIFdlIGhhdmUgc2VwYXJhdGUgdGFibGVzICYgbm8gcG9pbnRlcnMuIDIgY29tbWVudGVkIGxpbmVzIGJlbG93IG5vdCBuZWVkZWQuXG4gICAgICAvLyBzdGF0ZS5uZXh0X2luZGV4ID0gb3B0cy50YWJsZV9pbmRleDtcbiAgICAgIHN0YXRlLmRpc3RiaXRzID0gb3B0cy5iaXRzO1xuICAgICAgLy8gc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5uZXh0O1xuXG4gICAgICBpZiAocmV0KSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2VzIHNldCc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgJ2luZmxhdGU6ICAgICAgIGNvZGVzIG9rXFxuJykpO1xuICAgICAgc3RhdGUubW9kZSA9IExFTl87XG4gICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBMRU5fOlxuICAgICAgc3RhdGUubW9kZSA9IExFTjtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIExFTjpcbiAgICAgIGlmIChoYXZlID49IDYgJiYgbGVmdCA+PSAyNTgpIHtcbiAgICAgICAgLy8tLS0gUkVTVE9SRSgpIC0tLVxuICAgICAgICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICAgICAgICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gICAgICAgIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gICAgICAgIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICAgICAgICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgICAgICAgc3RhdGUuYml0cyA9IGJpdHM7XG4gICAgICAgIC8vLS0tXG4gICAgICAgIGluZmxhdGVfZmFzdChzdHJtLCBfb3V0KTtcbiAgICAgICAgLy8tLS0gTE9BRCgpIC0tLVxuICAgICAgICBwdXQgPSBzdHJtLm5leHRfb3V0O1xuICAgICAgICBvdXRwdXQgPSBzdHJtLm91dHB1dDtcbiAgICAgICAgbGVmdCA9IHN0cm0uYXZhaWxfb3V0O1xuICAgICAgICBuZXh0ID0gc3RybS5uZXh0X2luO1xuICAgICAgICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gICAgICAgIGhhdmUgPSBzdHJtLmF2YWlsX2luO1xuICAgICAgICBob2xkID0gc3RhdGUuaG9sZDtcbiAgICAgICAgYml0cyA9IHN0YXRlLmJpdHM7XG4gICAgICAgIC8vLS0tXG5cbiAgICAgICAgaWYgKHN0YXRlLm1vZGUgPT09IFRZUEUpIHtcbiAgICAgICAgICBzdGF0ZS5iYWNrID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzdGF0ZS5iYWNrID0gMDtcbiAgICAgIGZvciAoOzspIHtcbiAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbaG9sZCAmICgoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDEpXTsgIC8qQklUUyhzdGF0ZS5sZW5iaXRzKSovXG4gICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICBpZiAoaGVyZV9iaXRzIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgaGF2ZS0tO1xuICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAvLy0tLS8vXG4gICAgICB9XG4gICAgICBpZiAoaGVyZV9vcCAmJiAoaGVyZV9vcCAmIDB4ZjApID09PSAwKSB7XG4gICAgICAgIGxhc3RfYml0cyA9IGhlcmVfYml0cztcbiAgICAgICAgbGFzdF9vcCA9IGhlcmVfb3A7XG4gICAgICAgIGxhc3RfdmFsID0gaGVyZV92YWw7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtsYXN0X3ZhbCArXG4gICAgICAgICAgICAgICAgICAoKGhvbGQgJiAoKDEgPDwgKGxhc3RfYml0cyArIGxhc3Rfb3ApKSAtIDEpKS8qQklUUyhsYXN0LmJpdHMgKyBsYXN0Lm9wKSovID4+IGxhc3RfYml0cyldO1xuICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICBpZiAoKGxhc3RfYml0cyArIGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgfVxuICAgICAgICAvLy0tLSBEUk9QQklUUyhsYXN0LmJpdHMpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSBsYXN0X2JpdHM7XG4gICAgICAgIGJpdHMgLT0gbGFzdF9iaXRzO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLmJhY2sgKz0gbGFzdF9iaXRzO1xuICAgICAgfVxuICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgLy8tLS0vL1xuICAgICAgc3RhdGUuYmFjayArPSBoZXJlX2JpdHM7XG4gICAgICBzdGF0ZS5sZW5ndGggPSBoZXJlX3ZhbDtcbiAgICAgIGlmIChoZXJlX29wID09PSAwKSB7XG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBoZXJlLnZhbCA+PSAweDIwICYmIGhlcmUudmFsIDwgMHg3ZiA/XG4gICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAnJWMnXFxuXCIgOlxuICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgMHglMDJ4XFxuXCIsIGhlcmUudmFsKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMSVQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGhlcmVfb3AgJiAzMikge1xuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGVuZCBvZiBibG9ja1xcblwiKSk7XG4gICAgICAgIHN0YXRlLmJhY2sgPSAtMTtcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGhlcmVfb3AgJiA2NCkge1xuICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGUnO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHN0YXRlLmV4dHJhID0gaGVyZV9vcCAmIDE1O1xuICAgICAgc3RhdGUubW9kZSA9IExFTkVYVDtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIExFTkVYVDpcbiAgICAgIGlmIChzdGF0ZS5leHRyYSkge1xuICAgICAgICAvLz09PSBORUVEQklUUyhzdGF0ZS5leHRyYSk7XG4gICAgICAgIG4gPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLmxlbmd0aCArPSBob2xkICYgKCgxIDw8IHN0YXRlLmV4dHJhKSAtIDEpLypCSVRTKHN0YXRlLmV4dHJhKSovO1xuICAgICAgICAvLy0tLSBEUk9QQklUUyhzdGF0ZS5leHRyYSkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IHN0YXRlLmV4dHJhO1xuICAgICAgICBiaXRzIC09IHN0YXRlLmV4dHJhO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLmJhY2sgKz0gc3RhdGUuZXh0cmE7XG4gICAgICB9XG4gICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGxlbmd0aCAldVxcblwiLCBzdGF0ZS5sZW5ndGgpKTtcbiAgICAgIHN0YXRlLndhcyA9IHN0YXRlLmxlbmd0aDtcbiAgICAgIHN0YXRlLm1vZGUgPSBESVNUO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgRElTVDpcbiAgICAgIGZvciAoOzspIHtcbiAgICAgICAgaGVyZSA9IHN0YXRlLmRpc3Rjb2RlW2hvbGQgJiAoKDEgPDwgc3RhdGUuZGlzdGJpdHMpIC0gMSldOy8qQklUUyhzdGF0ZS5kaXN0Yml0cykqL1xuICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgaWYgKChoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgaGF2ZS0tO1xuICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAvLy0tLS8vXG4gICAgICB9XG4gICAgICBpZiAoKGhlcmVfb3AgJiAweGYwKSA9PT0gMCkge1xuICAgICAgICBsYXN0X2JpdHMgPSBoZXJlX2JpdHM7XG4gICAgICAgIGxhc3Rfb3AgPSBoZXJlX29wO1xuICAgICAgICBsYXN0X3ZhbCA9IGhlcmVfdmFsO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgaGVyZSA9IHN0YXRlLmRpc3Rjb2RlW2xhc3RfdmFsICtcbiAgICAgICAgICAgICAgICAgICgoaG9sZCAmICgoMSA8PCAobGFzdF9iaXRzICsgbGFzdF9vcCkpIC0gMSkpLypCSVRTKGxhc3QuYml0cyArIGxhc3Qub3ApKi8gPj4gbGFzdF9iaXRzKV07XG4gICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgIGlmICgobGFzdF9iaXRzICsgaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKGxhc3QuYml0cykgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IGxhc3RfYml0cztcbiAgICAgICAgYml0cyAtPSBsYXN0X2JpdHM7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUuYmFjayArPSBsYXN0X2JpdHM7XG4gICAgICB9XG4gICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAvLy0tLS8vXG4gICAgICBzdGF0ZS5iYWNrICs9IGhlcmVfYml0cztcbiAgICAgIGlmIChoZXJlX29wICYgNjQpIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSBjb2RlJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzdGF0ZS5vZmZzZXQgPSBoZXJlX3ZhbDtcbiAgICAgIHN0YXRlLmV4dHJhID0gKGhlcmVfb3ApICYgMTU7XG4gICAgICBzdGF0ZS5tb2RlID0gRElTVEVYVDtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIERJU1RFWFQ6XG4gICAgICBpZiAoc3RhdGUuZXh0cmEpIHtcbiAgICAgICAgLy89PT0gTkVFREJJVFMoc3RhdGUuZXh0cmEpO1xuICAgICAgICBuID0gc3RhdGUuZXh0cmE7XG4gICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5vZmZzZXQgKz0gaG9sZCAmICgoMSA8PCBzdGF0ZS5leHRyYSkgLSAxKS8qQklUUyhzdGF0ZS5leHRyYSkqLztcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoc3RhdGUuZXh0cmEpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSBzdGF0ZS5leHRyYTtcbiAgICAgICAgYml0cyAtPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5iYWNrICs9IHN0YXRlLmV4dHJhO1xuICAgICAgfVxuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgICAgIGlmIChzdGF0ZS5vZmZzZXQgPiBzdGF0ZS5kbWF4KSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4vLyNlbmRpZlxuICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBkaXN0YW5jZSAldVxcblwiLCBzdGF0ZS5vZmZzZXQpKTtcbiAgICAgIHN0YXRlLm1vZGUgPSBNQVRDSDtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIE1BVENIOlxuICAgICAgaWYgKGxlZnQgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICBjb3B5ID0gX291dCAtIGxlZnQ7XG4gICAgICBpZiAoc3RhdGUub2Zmc2V0ID4gY29weSkgeyAgICAgICAgIC8qIGNvcHkgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgY29weSA9IHN0YXRlLm9mZnNldCAtIGNvcHk7XG4gICAgICAgIGlmIChjb3B5ID4gc3RhdGUud2hhdmUpIHtcbiAgICAgICAgICBpZiAoc3RhdGUuc2FuZSkge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbi8vICghKSBUaGlzIGJsb2NrIGlzIGRpc2FibGVkIGluIHpsaWIgZGVmYWlsdHMsXG4vLyBkb24ndCBlbmFibGUgaXQgZm9yIGJpbmFyeSBjb21wYXRpYmlsaXR5XG4vLyNpZmRlZiBJTkZMQVRFX0FMTE9XX0lOVkFMSURfRElTVEFOQ0VfVE9PRkFSX0FSUlJcbi8vICAgICAgICAgIFRyYWNlKChzdGRlcnIsIFwiaW5mbGF0ZS5jIHRvbyBmYXJcXG5cIikpO1xuLy8gICAgICAgICAgY29weSAtPSBzdGF0ZS53aGF2ZTtcbi8vICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUubGVuZ3RoKSB7IGNvcHkgPSBzdGF0ZS5sZW5ndGg7IH1cbi8vICAgICAgICAgIGlmIChjb3B5ID4gbGVmdCkgeyBjb3B5ID0gbGVmdDsgfVxuLy8gICAgICAgICAgbGVmdCAtPSBjb3B5O1xuLy8gICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4vLyAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgIG91dHB1dFtwdXQrK10gPSAwO1xuLy8gICAgICAgICAgfSB3aGlsZSAoLS1jb3B5KTtcbi8vICAgICAgICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHsgc3RhdGUubW9kZSA9IExFTjsgfVxuLy8gICAgICAgICAgYnJlYWs7XG4vLyNlbmRpZlxuICAgICAgICB9XG4gICAgICAgIGlmIChjb3B5ID4gc3RhdGUud25leHQpIHtcbiAgICAgICAgICBjb3B5IC09IHN0YXRlLnduZXh0O1xuICAgICAgICAgIGZyb20gPSBzdGF0ZS53c2l6ZSAtIGNvcHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZnJvbSA9IHN0YXRlLnduZXh0IC0gY29weTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29weSA+IHN0YXRlLmxlbmd0aCkgeyBjb3B5ID0gc3RhdGUubGVuZ3RoOyB9XG4gICAgICAgIGZyb21fc291cmNlID0gc3RhdGUud2luZG93O1xuICAgICAgfVxuICAgICAgZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogY29weSBmcm9tIG91dHB1dCAqL1xuICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgZnJvbSA9IHB1dCAtIHN0YXRlLm9mZnNldDtcbiAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGlmIChjb3B5ID4gbGVmdCkgeyBjb3B5ID0gbGVmdDsgfVxuICAgICAgbGVmdCAtPSBjb3B5O1xuICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4gICAgICBkbyB7XG4gICAgICAgIG91dHB1dFtwdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgfSB3aGlsZSAoLS1jb3B5KTtcbiAgICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHsgc3RhdGUubW9kZSA9IExFTjsgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBMSVQ6XG4gICAgICBpZiAobGVmdCA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgIG91dHB1dFtwdXQrK10gPSBzdGF0ZS5sZW5ndGg7XG4gICAgICBsZWZ0LS07XG4gICAgICBzdGF0ZS5tb2RlID0gTEVOO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBDSEVDSzpcbiAgICAgIGlmIChzdGF0ZS53cmFwKSB7XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTtcbiAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAvLyBVc2UgJ3wnIGluc2RlYWQgb2YgJysnIHRvIG1ha2Ugc3VyZSB0aGF0IHJlc3VsdCBpcyBzaWduZWRcbiAgICAgICAgICBob2xkIHw9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBfb3V0IC09IGxlZnQ7XG4gICAgICAgIHN0cm0udG90YWxfb3V0ICs9IF9vdXQ7XG4gICAgICAgIHN0YXRlLnRvdGFsICs9IF9vdXQ7XG4gICAgICAgIGlmIChfb3V0KSB7XG4gICAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID1cbiAgICAgICAgICAgICAgLypVUERBVEUoc3RhdGUuY2hlY2ssIHB1dCAtIF9vdXQsIF9vdXQpOyovXG4gICAgICAgICAgICAgIChzdGF0ZS5mbGFncyA/IGNyYzMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHB1dCAtIF9vdXQpIDogYWRsZXIzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBwdXQgLSBfb3V0KSk7XG5cbiAgICAgICAgfVxuICAgICAgICBfb3V0ID0gbGVmdDtcbiAgICAgICAgLy8gTkI6IGNyYzMyIHN0b3JlZCBhcyBzaWduZWQgMzItYml0IGludCwgenN3YXAzMiByZXR1cm5zIHNpZ25lZCB0b29cbiAgICAgICAgaWYgKChzdGF0ZS5mbGFncyA/IGhvbGQgOiB6c3dhcDMyKGhvbGQpKSAhPT0gc3RhdGUuY2hlY2spIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbmNvcnJlY3QgZGF0YSBjaGVjayc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIGNoZWNrIG1hdGNoZXMgdHJhaWxlclxcblwiKSk7XG4gICAgICB9XG4gICAgICBzdGF0ZS5tb2RlID0gTEVOR1RIO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgTEVOR1RIOlxuICAgICAgaWYgKHN0YXRlLndyYXAgJiYgc3RhdGUuZmxhZ3MpIHtcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpO1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmIChob2xkICE9PSAoc3RhdGUudG90YWwgJiAweGZmZmZmZmZmKSkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2luY29ycmVjdCBsZW5ndGggY2hlY2snO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICBsZW5ndGggbWF0Y2hlcyB0cmFpbGVyXFxuXCIpKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLm1vZGUgPSBET05FO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgRE9ORTpcbiAgICAgIHJldCA9IFpfU1RSRUFNX0VORDtcbiAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICBjYXNlIEJBRDpcbiAgICAgIHJldCA9IFpfREFUQV9FUlJPUjtcbiAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICBjYXNlIE1FTTpcbiAgICAgIHJldHVybiBaX01FTV9FUlJPUjtcbiAgICBjYXNlIFNZTkM6XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgICB9XG4gIH1cblxuICAvLyBpbmZfbGVhdmUgPC0gaGVyZSBpcyByZWFsIHBsYWNlIGZvciBcImdvdG8gaW5mX2xlYXZlXCIsIGVtdWxhdGVkIHZpYSBcImJyZWFrIGluZl9sZWF2ZVwiXG5cbiAgLypcbiAgICAgUmV0dXJuIGZyb20gaW5mbGF0ZSgpLCB1cGRhdGluZyB0aGUgdG90YWwgY291bnRzIGFuZCB0aGUgY2hlY2sgdmFsdWUuXG4gICAgIElmIHRoZXJlIHdhcyBubyBwcm9ncmVzcyBkdXJpbmcgdGhlIGluZmxhdGUoKSBjYWxsLCByZXR1cm4gYSBidWZmZXJcbiAgICAgZXJyb3IuICBDYWxsIHVwZGF0ZXdpbmRvdygpIHRvIGNyZWF0ZSBhbmQvb3IgdXBkYXRlIHRoZSB3aW5kb3cgc3RhdGUuXG4gICAgIE5vdGU6IGEgbWVtb3J5IGVycm9yIGZyb20gaW5mbGF0ZSgpIGlzIG5vbi1yZWNvdmVyYWJsZS5cbiAgICovXG5cbiAgLy8tLS0gUkVTVE9SRSgpIC0tLVxuICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgc3RhdGUuYml0cyA9IGJpdHM7XG4gIC8vLS0tXG5cbiAgaWYgKHN0YXRlLndzaXplIHx8IChfb3V0ICE9PSBzdHJtLmF2YWlsX291dCAmJiBzdGF0ZS5tb2RlIDwgQkFEICYmXG4gICAgICAgICAgICAgICAgICAgICAgKHN0YXRlLm1vZGUgPCBDSEVDSyB8fCBmbHVzaCAhPT0gWl9GSU5JU0gpKSkge1xuICAgIGlmICh1cGRhdGV3aW5kb3coc3RybSwgc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQsIF9vdXQgLSBzdHJtLmF2YWlsX291dCkpIHtcbiAgICAgIHN0YXRlLm1vZGUgPSBNRU07XG4gICAgICByZXR1cm4gWl9NRU1fRVJST1I7XG4gICAgfVxuICB9XG4gIF9pbiAtPSBzdHJtLmF2YWlsX2luO1xuICBfb3V0IC09IHN0cm0uYXZhaWxfb3V0O1xuICBzdHJtLnRvdGFsX2luICs9IF9pbjtcbiAgc3RybS50b3RhbF9vdXQgKz0gX291dDtcbiAgc3RhdGUudG90YWwgKz0gX291dDtcbiAgaWYgKHN0YXRlLndyYXAgJiYgX291dCkge1xuICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IC8qVVBEQVRFKHN0YXRlLmNoZWNrLCBzdHJtLm5leHRfb3V0IC0gX291dCwgX291dCk7Ki9cbiAgICAgIChzdGF0ZS5mbGFncyA/IGNyYzMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHN0cm0ubmV4dF9vdXQgLSBfb3V0KSA6IGFkbGVyMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgc3RybS5uZXh0X291dCAtIF9vdXQpKTtcbiAgfVxuICBzdHJtLmRhdGFfdHlwZSA9IHN0YXRlLmJpdHMgKyAoc3RhdGUubGFzdCA/IDY0IDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAoc3RhdGUubW9kZSA9PT0gVFlQRSA/IDEyOCA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKHN0YXRlLm1vZGUgPT09IExFTl8gfHwgc3RhdGUubW9kZSA9PT0gQ09QWV8gPyAyNTYgOiAwKTtcbiAgaWYgKCgoX2luID09PSAwICYmIF9vdXQgPT09IDApIHx8IGZsdXNoID09PSBaX0ZJTklTSCkgJiYgcmV0ID09PSBaX09LKSB7XG4gICAgcmV0ID0gWl9CVUZfRVJST1I7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZUVuZChzdHJtKSB7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlIC8qfHwgc3RybS0+emZyZWUgPT0gKGZyZWVfZnVuYykwKi8pIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICB2YXIgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBpZiAoc3RhdGUud2luZG93KSB7XG4gICAgc3RhdGUud2luZG93ID0gbnVsbDtcbiAgfVxuICBzdHJtLnN0YXRlID0gbnVsbDtcbiAgcmV0dXJuIFpfT0s7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVHZXRIZWFkZXIoc3RybSwgaGVhZCkge1xuICB2YXIgc3RhdGU7XG5cbiAgLyogY2hlY2sgc3RhdGUgKi9cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIGlmICgoc3RhdGUud3JhcCAmIDIpID09PSAwKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuXG4gIC8qIHNhdmUgaGVhZGVyIHN0cnVjdHVyZSAqL1xuICBzdGF0ZS5oZWFkID0gaGVhZDtcbiAgaGVhZC5kb25lID0gZmFsc2U7XG4gIHJldHVybiBaX09LO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlU2V0RGljdGlvbmFyeShzdHJtLCBkaWN0aW9uYXJ5KSB7XG4gIHZhciBkaWN0TGVuZ3RoID0gZGljdGlvbmFyeS5sZW5ndGg7XG5cbiAgdmFyIHN0YXRlO1xuICB2YXIgZGljdGlkO1xuICB2YXIgcmV0O1xuXG4gIC8qIGNoZWNrIHN0YXRlICovXG4gIGlmICghc3RybSAvKiA9PSBaX05VTEwgKi8gfHwgIXN0cm0uc3RhdGUgLyogPT0gWl9OVUxMICovKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG5cbiAgaWYgKHN0YXRlLndyYXAgIT09IDAgJiYgc3RhdGUubW9kZSAhPT0gRElDVCkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIC8qIGNoZWNrIGZvciBjb3JyZWN0IGRpY3Rpb25hcnkgaWRlbnRpZmllciAqL1xuICBpZiAoc3RhdGUubW9kZSA9PT0gRElDVCkge1xuICAgIGRpY3RpZCA9IDE7IC8qIGFkbGVyMzIoMCwgbnVsbCwgMCkqL1xuICAgIC8qIGRpY3RpZCA9IGFkbGVyMzIoZGljdGlkLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoKTsgKi9cbiAgICBkaWN0aWQgPSBhZGxlcjMyKGRpY3RpZCwgZGljdGlvbmFyeSwgZGljdExlbmd0aCwgMCk7XG4gICAgaWYgKGRpY3RpZCAhPT0gc3RhdGUuY2hlY2spIHtcbiAgICAgIHJldHVybiBaX0RBVEFfRVJST1I7XG4gICAgfVxuICB9XG4gIC8qIGNvcHkgZGljdGlvbmFyeSB0byB3aW5kb3cgdXNpbmcgdXBkYXRld2luZG93KCksIHdoaWNoIHdpbGwgYW1lbmQgdGhlXG4gICBleGlzdGluZyBkaWN0aW9uYXJ5IGlmIGFwcHJvcHJpYXRlICovXG4gIHJldCA9IHVwZGF0ZXdpbmRvdyhzdHJtLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCBkaWN0TGVuZ3RoKTtcbiAgaWYgKHJldCkge1xuICAgIHN0YXRlLm1vZGUgPSBNRU07XG4gICAgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICB9XG4gIHN0YXRlLmhhdmVkaWN0ID0gMTtcbiAgLy8gVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICBkaWN0aW9uYXJ5IHNldFxcblwiKSk7XG4gIHJldHVybiBaX09LO1xufVxuXG5leHBvcnRzLmluZmxhdGVSZXNldCA9IGluZmxhdGVSZXNldDtcbmV4cG9ydHMuaW5mbGF0ZVJlc2V0MiA9IGluZmxhdGVSZXNldDI7XG5leHBvcnRzLmluZmxhdGVSZXNldEtlZXAgPSBpbmZsYXRlUmVzZXRLZWVwO1xuZXhwb3J0cy5pbmZsYXRlSW5pdCA9IGluZmxhdGVJbml0O1xuZXhwb3J0cy5pbmZsYXRlSW5pdDIgPSBpbmZsYXRlSW5pdDI7XG5leHBvcnRzLmluZmxhdGUgPSBpbmZsYXRlO1xuZXhwb3J0cy5pbmZsYXRlRW5kID0gaW5mbGF0ZUVuZDtcbmV4cG9ydHMuaW5mbGF0ZUdldEhlYWRlciA9IGluZmxhdGVHZXRIZWFkZXI7XG5leHBvcnRzLmluZmxhdGVTZXREaWN0aW9uYXJ5ID0gaW5mbGF0ZVNldERpY3Rpb25hcnk7XG5leHBvcnRzLmluZmxhdGVJbmZvID0gJ3Bha28gaW5mbGF0ZSAoZnJvbSBOb2RlY2EgcHJvamVjdCknO1xuXG4vKiBOb3QgaW1wbGVtZW50ZWRcbmV4cG9ydHMuaW5mbGF0ZUNvcHkgPSBpbmZsYXRlQ29weTtcbmV4cG9ydHMuaW5mbGF0ZUdldERpY3Rpb25hcnkgPSBpbmZsYXRlR2V0RGljdGlvbmFyeTtcbmV4cG9ydHMuaW5mbGF0ZU1hcmsgPSBpbmZsYXRlTWFyaztcbmV4cG9ydHMuaW5mbGF0ZVByaW1lID0gaW5mbGF0ZVByaW1lO1xuZXhwb3J0cy5pbmZsYXRlU3luYyA9IGluZmxhdGVTeW5jO1xuZXhwb3J0cy5pbmZsYXRlU3luY1BvaW50ID0gaW5mbGF0ZVN5bmNQb2ludDtcbmV4cG9ydHMuaW5mbGF0ZVVuZGVybWluZSA9IGluZmxhdGVVbmRlcm1pbmU7XG4qL1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2pzemlwL34vcGFrby9saWIvemxpYi9pbmZsYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){"use strict";eval("\n\n\nvar utils = __webpack_require__(3);\n\nvar MAXBITS = 15;\nvar ENOUGH_LENS = 852;\nvar ENOUGH_DISTS = 592;\n//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);\n\nvar CODES = 0;\nvar LENS = 1;\nvar DISTS = 2;\n\nvar lbase = [ /* Length codes 257..285 base */\n  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0\n];\n\nvar lext = [ /* Length codes 257..285 extra */\n  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,\n  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78\n];\n\nvar dbase = [ /* Distance codes 0..29 base */\n  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n  8193, 12289, 16385, 24577, 0, 0\n];\n\nvar dext = [ /* Distance codes 0..29 extra */\n  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,\n  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,\n  28, 28, 29, 29, 64, 64\n];\n\nmodule.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)\n{\n  var bits = opts.bits;\n      //here = opts.here; /* table entry for duplication */\n\n  var len = 0;               /* a code's length in bits */\n  var sym = 0;               /* index of code symbols */\n  var min = 0, max = 0;          /* minimum and maximum code lengths */\n  var root = 0;              /* number of index bits for root table */\n  var curr = 0;              /* number of index bits for current table */\n  var drop = 0;              /* code bits to drop for sub-table */\n  var left = 0;                   /* number of prefix codes available */\n  var used = 0;              /* code entries in table used */\n  var huff = 0;              /* Huffman code */\n  var incr;              /* for incrementing code, index */\n  var fill;              /* index for replicating entries */\n  var low;               /* low bits for current root entry */\n  var mask;              /* mask for low root bits */\n  var next;             /* next available space in table */\n  var base = null;     /* base value table to use */\n  var base_index = 0;\n//  var shoextra;    /* extra bits table to use */\n  var end;                    /* use base and extra for symbol > end */\n  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */\n  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */\n  var extra = null;\n  var extra_index = 0;\n\n  var here_bits, here_op, here_val;\n\n  /*\n   Process a set of code lengths to create a canonical Huffman code.  The\n   code lengths are lens[0..codes-1].  Each length corresponds to the\n   symbols 0..codes-1.  The Huffman code is generated by first sorting the\n   symbols by length from short to long, and retaining the symbol order\n   for codes with equal lengths.  Then the code starts with all zero bits\n   for the first code of the shortest length, and the codes are integer\n   increments for the same length, and zeros are appended as the length\n   increases.  For the deflate format, these bits are stored backwards\n   from their more natural integer increment ordering, and so when the\n   decoding tables are built in the large loop below, the integer codes\n   are incremented backwards.\n\n   This routine assumes, but does not check, that all of the entries in\n   lens[] are in the range 0..MAXBITS.  The caller must assure this.\n   1..MAXBITS is interpreted as that code length.  zero means that that\n   symbol does not occur in this code.\n\n   The codes are sorted by computing a count of codes for each length,\n   creating from that a table of starting indices for each length in the\n   sorted table, and then entering the symbols in order in the sorted\n   table.  The sorted table is work[], with that space being provided by\n   the caller.\n\n   The length counts are used for other purposes as well, i.e. finding\n   the minimum and maximum length codes, determining if there are any\n   codes at all, checking for a valid set of lengths, and looking ahead\n   at length counts to determine sub-table sizes when building the\n   decoding tables.\n   */\n\n  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */\n  for (len = 0; len <= MAXBITS; len++) {\n    count[len] = 0;\n  }\n  for (sym = 0; sym < codes; sym++) {\n    count[lens[lens_index + sym]]++;\n  }\n\n  /* bound code lengths, force root to be within code lengths */\n  root = bits;\n  for (max = MAXBITS; max >= 1; max--) {\n    if (count[max] !== 0) { break; }\n  }\n  if (root > max) {\n    root = max;\n  }\n  if (max === 0) {                     /* no symbols to code at all */\n    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */\n    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;\n    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\n\n    //table.op[opts.table_index] = 64;\n    //table.bits[opts.table_index] = 1;\n    //table.val[opts.table_index++] = 0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\n    opts.bits = 1;\n    return 0;     /* no symbols, but wait for decoding to report error */\n  }\n  for (min = 1; min < max; min++) {\n    if (count[min] !== 0) { break; }\n  }\n  if (root < min) {\n    root = min;\n  }\n\n  /* check for an over-subscribed or incomplete set of lengths */\n  left = 1;\n  for (len = 1; len <= MAXBITS; len++) {\n    left <<= 1;\n    left -= count[len];\n    if (left < 0) {\n      return -1;\n    }        /* over-subscribed */\n  }\n  if (left > 0 && (type === CODES || max !== 1)) {\n    return -1;                      /* incomplete set */\n  }\n\n  /* generate offsets into symbol table for each length for sorting */\n  offs[1] = 0;\n  for (len = 1; len < MAXBITS; len++) {\n    offs[len + 1] = offs[len] + count[len];\n  }\n\n  /* sort symbols by length, by symbol order within each length */\n  for (sym = 0; sym < codes; sym++) {\n    if (lens[lens_index + sym] !== 0) {\n      work[offs[lens[lens_index + sym]]++] = sym;\n    }\n  }\n\n  /*\n   Create and fill in decoding tables.  In this loop, the table being\n   filled is at next and has curr index bits.  The code being used is huff\n   with length len.  That code is converted to an index by dropping drop\n   bits off of the bottom.  For codes where len is less than drop + curr,\n   those top drop + curr - len bits are incremented through all values to\n   fill the table with replicated entries.\n\n   root is the number of index bits for the root table.  When len exceeds\n   root, sub-tables are created pointed to by the root entry with an index\n   of the low root bits of huff.  This is saved in low to check for when a\n   new sub-table should be started.  drop is zero when the root table is\n   being filled, and drop is root when sub-tables are being filled.\n\n   When a new sub-table is needed, it is necessary to look ahead in the\n   code lengths to determine what size sub-table is needed.  The length\n   counts are used for this, and so count[] is decremented as codes are\n   entered in the tables.\n\n   used keeps track of how many table entries have been allocated from the\n   provided *table space.  It is checked for LENS and DIST tables against\n   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in\n   the initial root table size constants.  See the comments in inftrees.h\n   for more information.\n\n   sym increments through all symbols, and the loop terminates when\n   all codes of length max, i.e. all codes, have been processed.  This\n   routine permits incomplete codes, so another loop after this one fills\n   in the rest of the decoding tables with invalid code markers.\n   */\n\n  /* set up for code type */\n  // poor man optimization - use if-else instead of switch,\n  // to avoid deopts in old v8\n  if (type === CODES) {\n    base = extra = work;    /* dummy value--not used */\n    end = 19;\n\n  } else if (type === LENS) {\n    base = lbase;\n    base_index -= 257;\n    extra = lext;\n    extra_index -= 257;\n    end = 256;\n\n  } else {                    /* DISTS */\n    base = dbase;\n    extra = dext;\n    end = -1;\n  }\n\n  /* initialize opts for loop */\n  huff = 0;                   /* starting code */\n  sym = 0;                    /* starting code symbol */\n  len = min;                  /* starting code length */\n  next = table_index;              /* current table to fill in */\n  curr = root;                /* current table index bits */\n  drop = 0;                   /* current bits to drop from code for index */\n  low = -1;                   /* trigger new sub-table when len > root */\n  used = 1 << root;          /* use root table entries */\n  mask = used - 1;            /* mask for comparing low */\n\n  /* check available table space */\n  if ((type === LENS && used > ENOUGH_LENS) ||\n    (type === DISTS && used > ENOUGH_DISTS)) {\n    return 1;\n  }\n\n  /* process all codes and make table entries */\n  for (;;) {\n    /* create table entry */\n    here_bits = len - drop;\n    if (work[sym] < end) {\n      here_op = 0;\n      here_val = work[sym];\n    }\n    else if (work[sym] > end) {\n      here_op = extra[extra_index + work[sym]];\n      here_val = base[base_index + work[sym]];\n    }\n    else {\n      here_op = 32 + 64;         /* end of block */\n      here_val = 0;\n    }\n\n    /* replicate for those indices with low len bits equal to huff */\n    incr = 1 << (len - drop);\n    fill = 1 << curr;\n    min = fill;                 /* save offset to next table */\n    do {\n      fill -= incr;\n      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;\n    } while (fill !== 0);\n\n    /* backwards increment the len-bit code huff */\n    incr = 1 << (len - 1);\n    while (huff & incr) {\n      incr >>= 1;\n    }\n    if (incr !== 0) {\n      huff &= incr - 1;\n      huff += incr;\n    } else {\n      huff = 0;\n    }\n\n    /* go to next symbol, update count, len */\n    sym++;\n    if (--count[len] === 0) {\n      if (len === max) { break; }\n      len = lens[lens_index + work[sym]];\n    }\n\n    /* create new sub-table if needed */\n    if (len > root && (huff & mask) !== low) {\n      /* if first time, transition to sub-tables */\n      if (drop === 0) {\n        drop = root;\n      }\n\n      /* increment past last table */\n      next += min;            /* here min is 1 << curr */\n\n      /* determine length of next table */\n      curr = len - drop;\n      left = 1 << curr;\n      while (curr + drop < max) {\n        left -= count[curr + drop];\n        if (left <= 0) { break; }\n        curr++;\n        left <<= 1;\n      }\n\n      /* check for enough space */\n      used += 1 << curr;\n      if ((type === LENS && used > ENOUGH_LENS) ||\n        (type === DISTS && used > ENOUGH_DISTS)) {\n        return 1;\n      }\n\n      /* point entry in root table to sub-table */\n      low = huff & mask;\n      /*table.op[low] = curr;\n      table.bits[low] = root;\n      table.val[low] = next - opts.table_index;*/\n      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;\n    }\n  }\n\n  /* fill in remaining table entry if code is incomplete (guaranteed to have\n   at most one remaining entry, since if the code is incomplete, the\n   maximum code length that was allowed to get this far is one bit) */\n  if (huff !== 0) {\n    //table.op[next + huff] = 64;            /* invalid code marker */\n    //table.bits[next + huff] = len - drop;\n    //table.val[next + huff] = 0;\n    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;\n  }\n\n  /* set return parameters */\n  //opts.table_index += used;\n  opts.bits = root;\n  return 0;\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2pzemlwL34vcGFrby9saWIvemxpYi9pbmZ0cmVlcy5qcz9mMTdkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekIsY0FBYztBQUNkLGNBQWM7QUFDZCx1QkFBdUI7QUFDdkIsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsV0FBVztBQUNYLFdBQVc7QUFDWCxVQUFVO0FBQ1YsV0FBVztBQUNYLFdBQVc7QUFDWCxrQkFBa0I7QUFDbEI7QUFDQSxpQkFBaUI7QUFDakIsVUFBVTtBQUNWLDJDQUEyQyxlQUFlO0FBQzFELDBDQUEwQyxlQUFlO0FBQ3pEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsVUFBVTtBQUMvQiwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixzQ0FBc0MsMkJBQTJCO0FBQ2pFLHVDQUF1QztBQUN2Qyx3Q0FBd0M7QUFDeEM7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsZUFBZSxXQUFXO0FBQzFCLDJCQUEyQixPQUFPO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQTs7QUFFQTtBQUNBLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHLE9BQU87QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1YsWUFBWTtBQUNaLHFCQUFxQjtBQUNyQixjQUFjO0FBQ2QsV0FBVztBQUNYLFdBQVc7QUFDWCxtQkFBbUI7QUFDbkIsa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjExMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcblxudmFyIE1BWEJJVFMgPSAxNTtcbnZhciBFTk9VR0hfTEVOUyA9IDg1MjtcbnZhciBFTk9VR0hfRElTVFMgPSA1OTI7XG4vL3ZhciBFTk9VR0ggPSAoRU5PVUdIX0xFTlMrRU5PVUdIX0RJU1RTKTtcblxudmFyIENPREVTID0gMDtcbnZhciBMRU5TID0gMTtcbnZhciBESVNUUyA9IDI7XG5cbnZhciBsYmFzZSA9IFsgLyogTGVuZ3RoIGNvZGVzIDI1Ny4uMjg1IGJhc2UgKi9cbiAgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMywgMTUsIDE3LCAxOSwgMjMsIDI3LCAzMSxcbiAgMzUsIDQzLCA1MSwgNTksIDY3LCA4MywgOTksIDExNSwgMTMxLCAxNjMsIDE5NSwgMjI3LCAyNTgsIDAsIDBcbl07XG5cbnZhciBsZXh0ID0gWyAvKiBMZW5ndGggY29kZXMgMjU3Li4yODUgZXh0cmEgKi9cbiAgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNywgMTcsIDE3LCAxNywgMTgsIDE4LCAxOCwgMTgsXG4gIDE5LCAxOSwgMTksIDE5LCAyMCwgMjAsIDIwLCAyMCwgMjEsIDIxLCAyMSwgMjEsIDE2LCA3MiwgNzhcbl07XG5cbnZhciBkYmFzZSA9IFsgLyogRGlzdGFuY2UgY29kZXMgMC4uMjkgYmFzZSAqL1xuICAxLCAyLCAzLCA0LCA1LCA3LCA5LCAxMywgMTcsIDI1LCAzMywgNDksIDY1LCA5NywgMTI5LCAxOTMsXG4gIDI1NywgMzg1LCA1MTMsIDc2OSwgMTAyNSwgMTUzNywgMjA0OSwgMzA3MywgNDA5NywgNjE0NSxcbiAgODE5MywgMTIyODksIDE2Mzg1LCAyNDU3NywgMCwgMFxuXTtcblxudmFyIGRleHQgPSBbIC8qIERpc3RhbmNlIGNvZGVzIDAuLjI5IGV4dHJhICovXG4gIDE2LCAxNiwgMTYsIDE2LCAxNywgMTcsIDE4LCAxOCwgMTksIDE5LCAyMCwgMjAsIDIxLCAyMSwgMjIsIDIyLFxuICAyMywgMjMsIDI0LCAyNCwgMjUsIDI1LCAyNiwgMjYsIDI3LCAyNyxcbiAgMjgsIDI4LCAyOSwgMjksIDY0LCA2NFxuXTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmZsYXRlX3RhYmxlKHR5cGUsIGxlbnMsIGxlbnNfaW5kZXgsIGNvZGVzLCB0YWJsZSwgdGFibGVfaW5kZXgsIHdvcmssIG9wdHMpXG57XG4gIHZhciBiaXRzID0gb3B0cy5iaXRzO1xuICAgICAgLy9oZXJlID0gb3B0cy5oZXJlOyAvKiB0YWJsZSBlbnRyeSBmb3IgZHVwbGljYXRpb24gKi9cblxuICB2YXIgbGVuID0gMDsgICAgICAgICAgICAgICAvKiBhIGNvZGUncyBsZW5ndGggaW4gYml0cyAqL1xuICB2YXIgc3ltID0gMDsgICAgICAgICAgICAgICAvKiBpbmRleCBvZiBjb2RlIHN5bWJvbHMgKi9cbiAgdmFyIG1pbiA9IDAsIG1heCA9IDA7ICAgICAgICAgIC8qIG1pbmltdW0gYW5kIG1heGltdW0gY29kZSBsZW5ndGhzICovXG4gIHZhciByb290ID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBpbmRleCBiaXRzIGZvciByb290IHRhYmxlICovXG4gIHZhciBjdXJyID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBpbmRleCBiaXRzIGZvciBjdXJyZW50IHRhYmxlICovXG4gIHZhciBkcm9wID0gMDsgICAgICAgICAgICAgIC8qIGNvZGUgYml0cyB0byBkcm9wIGZvciBzdWItdGFibGUgKi9cbiAgdmFyIGxlZnQgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgcHJlZml4IGNvZGVzIGF2YWlsYWJsZSAqL1xuICB2YXIgdXNlZCA9IDA7ICAgICAgICAgICAgICAvKiBjb2RlIGVudHJpZXMgaW4gdGFibGUgdXNlZCAqL1xuICB2YXIgaHVmZiA9IDA7ICAgICAgICAgICAgICAvKiBIdWZmbWFuIGNvZGUgKi9cbiAgdmFyIGluY3I7ICAgICAgICAgICAgICAvKiBmb3IgaW5jcmVtZW50aW5nIGNvZGUsIGluZGV4ICovXG4gIHZhciBmaWxsOyAgICAgICAgICAgICAgLyogaW5kZXggZm9yIHJlcGxpY2F0aW5nIGVudHJpZXMgKi9cbiAgdmFyIGxvdzsgICAgICAgICAgICAgICAvKiBsb3cgYml0cyBmb3IgY3VycmVudCByb290IGVudHJ5ICovXG4gIHZhciBtYXNrOyAgICAgICAgICAgICAgLyogbWFzayBmb3IgbG93IHJvb3QgYml0cyAqL1xuICB2YXIgbmV4dDsgICAgICAgICAgICAgLyogbmV4dCBhdmFpbGFibGUgc3BhY2UgaW4gdGFibGUgKi9cbiAgdmFyIGJhc2UgPSBudWxsOyAgICAgLyogYmFzZSB2YWx1ZSB0YWJsZSB0byB1c2UgKi9cbiAgdmFyIGJhc2VfaW5kZXggPSAwO1xuLy8gIHZhciBzaG9leHRyYTsgICAgLyogZXh0cmEgYml0cyB0YWJsZSB0byB1c2UgKi9cbiAgdmFyIGVuZDsgICAgICAgICAgICAgICAgICAgIC8qIHVzZSBiYXNlIGFuZCBleHRyYSBmb3Igc3ltYm9sID4gZW5kICovXG4gIHZhciBjb3VudCA9IG5ldyB1dGlscy5CdWYxNihNQVhCSVRTICsgMSk7IC8vW01BWEJJVFMrMV07ICAgIC8qIG51bWJlciBvZiBjb2RlcyBvZiBlYWNoIGxlbmd0aCAqL1xuICB2YXIgb2ZmcyA9IG5ldyB1dGlscy5CdWYxNihNQVhCSVRTICsgMSk7IC8vW01BWEJJVFMrMV07ICAgICAvKiBvZmZzZXRzIGluIHRhYmxlIGZvciBlYWNoIGxlbmd0aCAqL1xuICB2YXIgZXh0cmEgPSBudWxsO1xuICB2YXIgZXh0cmFfaW5kZXggPSAwO1xuXG4gIHZhciBoZXJlX2JpdHMsIGhlcmVfb3AsIGhlcmVfdmFsO1xuXG4gIC8qXG4gICBQcm9jZXNzIGEgc2V0IG9mIGNvZGUgbGVuZ3RocyB0byBjcmVhdGUgYSBjYW5vbmljYWwgSHVmZm1hbiBjb2RlLiAgVGhlXG4gICBjb2RlIGxlbmd0aHMgYXJlIGxlbnNbMC4uY29kZXMtMV0uICBFYWNoIGxlbmd0aCBjb3JyZXNwb25kcyB0byB0aGVcbiAgIHN5bWJvbHMgMC4uY29kZXMtMS4gIFRoZSBIdWZmbWFuIGNvZGUgaXMgZ2VuZXJhdGVkIGJ5IGZpcnN0IHNvcnRpbmcgdGhlXG4gICBzeW1ib2xzIGJ5IGxlbmd0aCBmcm9tIHNob3J0IHRvIGxvbmcsIGFuZCByZXRhaW5pbmcgdGhlIHN5bWJvbCBvcmRlclxuICAgZm9yIGNvZGVzIHdpdGggZXF1YWwgbGVuZ3Rocy4gIFRoZW4gdGhlIGNvZGUgc3RhcnRzIHdpdGggYWxsIHplcm8gYml0c1xuICAgZm9yIHRoZSBmaXJzdCBjb2RlIG9mIHRoZSBzaG9ydGVzdCBsZW5ndGgsIGFuZCB0aGUgY29kZXMgYXJlIGludGVnZXJcbiAgIGluY3JlbWVudHMgZm9yIHRoZSBzYW1lIGxlbmd0aCwgYW5kIHplcm9zIGFyZSBhcHBlbmRlZCBhcyB0aGUgbGVuZ3RoXG4gICBpbmNyZWFzZXMuICBGb3IgdGhlIGRlZmxhdGUgZm9ybWF0LCB0aGVzZSBiaXRzIGFyZSBzdG9yZWQgYmFja3dhcmRzXG4gICBmcm9tIHRoZWlyIG1vcmUgbmF0dXJhbCBpbnRlZ2VyIGluY3JlbWVudCBvcmRlcmluZywgYW5kIHNvIHdoZW4gdGhlXG4gICBkZWNvZGluZyB0YWJsZXMgYXJlIGJ1aWx0IGluIHRoZSBsYXJnZSBsb29wIGJlbG93LCB0aGUgaW50ZWdlciBjb2Rlc1xuICAgYXJlIGluY3JlbWVudGVkIGJhY2t3YXJkcy5cblxuICAgVGhpcyByb3V0aW5lIGFzc3VtZXMsIGJ1dCBkb2VzIG5vdCBjaGVjaywgdGhhdCBhbGwgb2YgdGhlIGVudHJpZXMgaW5cbiAgIGxlbnNbXSBhcmUgaW4gdGhlIHJhbmdlIDAuLk1BWEJJVFMuICBUaGUgY2FsbGVyIG11c3QgYXNzdXJlIHRoaXMuXG4gICAxLi5NQVhCSVRTIGlzIGludGVycHJldGVkIGFzIHRoYXQgY29kZSBsZW5ndGguICB6ZXJvIG1lYW5zIHRoYXQgdGhhdFxuICAgc3ltYm9sIGRvZXMgbm90IG9jY3VyIGluIHRoaXMgY29kZS5cblxuICAgVGhlIGNvZGVzIGFyZSBzb3J0ZWQgYnkgY29tcHV0aW5nIGEgY291bnQgb2YgY29kZXMgZm9yIGVhY2ggbGVuZ3RoLFxuICAgY3JlYXRpbmcgZnJvbSB0aGF0IGEgdGFibGUgb2Ygc3RhcnRpbmcgaW5kaWNlcyBmb3IgZWFjaCBsZW5ndGggaW4gdGhlXG4gICBzb3J0ZWQgdGFibGUsIGFuZCB0aGVuIGVudGVyaW5nIHRoZSBzeW1ib2xzIGluIG9yZGVyIGluIHRoZSBzb3J0ZWRcbiAgIHRhYmxlLiAgVGhlIHNvcnRlZCB0YWJsZSBpcyB3b3JrW10sIHdpdGggdGhhdCBzcGFjZSBiZWluZyBwcm92aWRlZCBieVxuICAgdGhlIGNhbGxlci5cblxuICAgVGhlIGxlbmd0aCBjb3VudHMgYXJlIHVzZWQgZm9yIG90aGVyIHB1cnBvc2VzIGFzIHdlbGwsIGkuZS4gZmluZGluZ1xuICAgdGhlIG1pbmltdW0gYW5kIG1heGltdW0gbGVuZ3RoIGNvZGVzLCBkZXRlcm1pbmluZyBpZiB0aGVyZSBhcmUgYW55XG4gICBjb2RlcyBhdCBhbGwsIGNoZWNraW5nIGZvciBhIHZhbGlkIHNldCBvZiBsZW5ndGhzLCBhbmQgbG9va2luZyBhaGVhZFxuICAgYXQgbGVuZ3RoIGNvdW50cyB0byBkZXRlcm1pbmUgc3ViLXRhYmxlIHNpemVzIHdoZW4gYnVpbGRpbmcgdGhlXG4gICBkZWNvZGluZyB0YWJsZXMuXG4gICAqL1xuXG4gIC8qIGFjY3VtdWxhdGUgbGVuZ3RocyBmb3IgY29kZXMgKGFzc3VtZXMgbGVuc1tdIGFsbCBpbiAwLi5NQVhCSVRTKSAqL1xuICBmb3IgKGxlbiA9IDA7IGxlbiA8PSBNQVhCSVRTOyBsZW4rKykge1xuICAgIGNvdW50W2xlbl0gPSAwO1xuICB9XG4gIGZvciAoc3ltID0gMDsgc3ltIDwgY29kZXM7IHN5bSsrKSB7XG4gICAgY291bnRbbGVuc1tsZW5zX2luZGV4ICsgc3ltXV0rKztcbiAgfVxuXG4gIC8qIGJvdW5kIGNvZGUgbGVuZ3RocywgZm9yY2Ugcm9vdCB0byBiZSB3aXRoaW4gY29kZSBsZW5ndGhzICovXG4gIHJvb3QgPSBiaXRzO1xuICBmb3IgKG1heCA9IE1BWEJJVFM7IG1heCA+PSAxOyBtYXgtLSkge1xuICAgIGlmIChjb3VudFttYXhdICE9PSAwKSB7IGJyZWFrOyB9XG4gIH1cbiAgaWYgKHJvb3QgPiBtYXgpIHtcbiAgICByb290ID0gbWF4O1xuICB9XG4gIGlmIChtYXggPT09IDApIHsgICAgICAgICAgICAgICAgICAgICAvKiBubyBzeW1ib2xzIHRvIGNvZGUgYXQgYWxsICovXG4gICAgLy90YWJsZS5vcFtvcHRzLnRhYmxlX2luZGV4XSA9IDY0OyAgLy9oZXJlLm9wID0gKHZhciBjaGFyKTY0OyAgICAvKiBpbnZhbGlkIGNvZGUgbWFya2VyICovXG4gICAgLy90YWJsZS5iaXRzW29wdHMudGFibGVfaW5kZXhdID0gMTsgICAvL2hlcmUuYml0cyA9ICh2YXIgY2hhcikxO1xuICAgIC8vdGFibGUudmFsW29wdHMudGFibGVfaW5kZXgrK10gPSAwOyAgIC8vaGVyZS52YWwgPSAodmFyIHNob3J0KTA7XG4gICAgdGFibGVbdGFibGVfaW5kZXgrK10gPSAoMSA8PCAyNCkgfCAoNjQgPDwgMTYpIHwgMDtcblxuXG4gICAgLy90YWJsZS5vcFtvcHRzLnRhYmxlX2luZGV4XSA9IDY0O1xuICAgIC8vdGFibGUuYml0c1tvcHRzLnRhYmxlX2luZGV4XSA9IDE7XG4gICAgLy90YWJsZS52YWxbb3B0cy50YWJsZV9pbmRleCsrXSA9IDA7XG4gICAgdGFibGVbdGFibGVfaW5kZXgrK10gPSAoMSA8PCAyNCkgfCAoNjQgPDwgMTYpIHwgMDtcblxuICAgIG9wdHMuYml0cyA9IDE7XG4gICAgcmV0dXJuIDA7ICAgICAvKiBubyBzeW1ib2xzLCBidXQgd2FpdCBmb3IgZGVjb2RpbmcgdG8gcmVwb3J0IGVycm9yICovXG4gIH1cbiAgZm9yIChtaW4gPSAxOyBtaW4gPCBtYXg7IG1pbisrKSB7XG4gICAgaWYgKGNvdW50W21pbl0gIT09IDApIHsgYnJlYWs7IH1cbiAgfVxuICBpZiAocm9vdCA8IG1pbikge1xuICAgIHJvb3QgPSBtaW47XG4gIH1cblxuICAvKiBjaGVjayBmb3IgYW4gb3Zlci1zdWJzY3JpYmVkIG9yIGluY29tcGxldGUgc2V0IG9mIGxlbmd0aHMgKi9cbiAgbGVmdCA9IDE7XG4gIGZvciAobGVuID0gMTsgbGVuIDw9IE1BWEJJVFM7IGxlbisrKSB7XG4gICAgbGVmdCA8PD0gMTtcbiAgICBsZWZ0IC09IGNvdW50W2xlbl07XG4gICAgaWYgKGxlZnQgPCAwKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfSAgICAgICAgLyogb3Zlci1zdWJzY3JpYmVkICovXG4gIH1cbiAgaWYgKGxlZnQgPiAwICYmICh0eXBlID09PSBDT0RFUyB8fCBtYXggIT09IDEpKSB7XG4gICAgcmV0dXJuIC0xOyAgICAgICAgICAgICAgICAgICAgICAvKiBpbmNvbXBsZXRlIHNldCAqL1xuICB9XG5cbiAgLyogZ2VuZXJhdGUgb2Zmc2V0cyBpbnRvIHN5bWJvbCB0YWJsZSBmb3IgZWFjaCBsZW5ndGggZm9yIHNvcnRpbmcgKi9cbiAgb2Zmc1sxXSA9IDA7XG4gIGZvciAobGVuID0gMTsgbGVuIDwgTUFYQklUUzsgbGVuKyspIHtcbiAgICBvZmZzW2xlbiArIDFdID0gb2Zmc1tsZW5dICsgY291bnRbbGVuXTtcbiAgfVxuXG4gIC8qIHNvcnQgc3ltYm9scyBieSBsZW5ndGgsIGJ5IHN5bWJvbCBvcmRlciB3aXRoaW4gZWFjaCBsZW5ndGggKi9cbiAgZm9yIChzeW0gPSAwOyBzeW0gPCBjb2Rlczsgc3ltKyspIHtcbiAgICBpZiAobGVuc1tsZW5zX2luZGV4ICsgc3ltXSAhPT0gMCkge1xuICAgICAgd29ya1tvZmZzW2xlbnNbbGVuc19pbmRleCArIHN5bV1dKytdID0gc3ltO1xuICAgIH1cbiAgfVxuXG4gIC8qXG4gICBDcmVhdGUgYW5kIGZpbGwgaW4gZGVjb2RpbmcgdGFibGVzLiAgSW4gdGhpcyBsb29wLCB0aGUgdGFibGUgYmVpbmdcbiAgIGZpbGxlZCBpcyBhdCBuZXh0IGFuZCBoYXMgY3VyciBpbmRleCBiaXRzLiAgVGhlIGNvZGUgYmVpbmcgdXNlZCBpcyBodWZmXG4gICB3aXRoIGxlbmd0aCBsZW4uICBUaGF0IGNvZGUgaXMgY29udmVydGVkIHRvIGFuIGluZGV4IGJ5IGRyb3BwaW5nIGRyb3BcbiAgIGJpdHMgb2ZmIG9mIHRoZSBib3R0b20uICBGb3IgY29kZXMgd2hlcmUgbGVuIGlzIGxlc3MgdGhhbiBkcm9wICsgY3VycixcbiAgIHRob3NlIHRvcCBkcm9wICsgY3VyciAtIGxlbiBiaXRzIGFyZSBpbmNyZW1lbnRlZCB0aHJvdWdoIGFsbCB2YWx1ZXMgdG9cbiAgIGZpbGwgdGhlIHRhYmxlIHdpdGggcmVwbGljYXRlZCBlbnRyaWVzLlxuXG4gICByb290IGlzIHRoZSBudW1iZXIgb2YgaW5kZXggYml0cyBmb3IgdGhlIHJvb3QgdGFibGUuICBXaGVuIGxlbiBleGNlZWRzXG4gICByb290LCBzdWItdGFibGVzIGFyZSBjcmVhdGVkIHBvaW50ZWQgdG8gYnkgdGhlIHJvb3QgZW50cnkgd2l0aCBhbiBpbmRleFxuICAgb2YgdGhlIGxvdyByb290IGJpdHMgb2YgaHVmZi4gIFRoaXMgaXMgc2F2ZWQgaW4gbG93IHRvIGNoZWNrIGZvciB3aGVuIGFcbiAgIG5ldyBzdWItdGFibGUgc2hvdWxkIGJlIHN0YXJ0ZWQuICBkcm9wIGlzIHplcm8gd2hlbiB0aGUgcm9vdCB0YWJsZSBpc1xuICAgYmVpbmcgZmlsbGVkLCBhbmQgZHJvcCBpcyByb290IHdoZW4gc3ViLXRhYmxlcyBhcmUgYmVpbmcgZmlsbGVkLlxuXG4gICBXaGVuIGEgbmV3IHN1Yi10YWJsZSBpcyBuZWVkZWQsIGl0IGlzIG5lY2Vzc2FyeSB0byBsb29rIGFoZWFkIGluIHRoZVxuICAgY29kZSBsZW5ndGhzIHRvIGRldGVybWluZSB3aGF0IHNpemUgc3ViLXRhYmxlIGlzIG5lZWRlZC4gIFRoZSBsZW5ndGhcbiAgIGNvdW50cyBhcmUgdXNlZCBmb3IgdGhpcywgYW5kIHNvIGNvdW50W10gaXMgZGVjcmVtZW50ZWQgYXMgY29kZXMgYXJlXG4gICBlbnRlcmVkIGluIHRoZSB0YWJsZXMuXG5cbiAgIHVzZWQga2VlcHMgdHJhY2sgb2YgaG93IG1hbnkgdGFibGUgZW50cmllcyBoYXZlIGJlZW4gYWxsb2NhdGVkIGZyb20gdGhlXG4gICBwcm92aWRlZCAqdGFibGUgc3BhY2UuICBJdCBpcyBjaGVja2VkIGZvciBMRU5TIGFuZCBESVNUIHRhYmxlcyBhZ2FpbnN0XG4gICB0aGUgY29uc3RhbnRzIEVOT1VHSF9MRU5TIGFuZCBFTk9VR0hfRElTVFMgdG8gZ3VhcmQgYWdhaW5zdCBjaGFuZ2VzIGluXG4gICB0aGUgaW5pdGlhbCByb290IHRhYmxlIHNpemUgY29uc3RhbnRzLiAgU2VlIHRoZSBjb21tZW50cyBpbiBpbmZ0cmVlcy5oXG4gICBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblxuICAgc3ltIGluY3JlbWVudHMgdGhyb3VnaCBhbGwgc3ltYm9scywgYW5kIHRoZSBsb29wIHRlcm1pbmF0ZXMgd2hlblxuICAgYWxsIGNvZGVzIG9mIGxlbmd0aCBtYXgsIGkuZS4gYWxsIGNvZGVzLCBoYXZlIGJlZW4gcHJvY2Vzc2VkLiAgVGhpc1xuICAgcm91dGluZSBwZXJtaXRzIGluY29tcGxldGUgY29kZXMsIHNvIGFub3RoZXIgbG9vcCBhZnRlciB0aGlzIG9uZSBmaWxsc1xuICAgaW4gdGhlIHJlc3Qgb2YgdGhlIGRlY29kaW5nIHRhYmxlcyB3aXRoIGludmFsaWQgY29kZSBtYXJrZXJzLlxuICAgKi9cblxuICAvKiBzZXQgdXAgZm9yIGNvZGUgdHlwZSAqL1xuICAvLyBwb29yIG1hbiBvcHRpbWl6YXRpb24gLSB1c2UgaWYtZWxzZSBpbnN0ZWFkIG9mIHN3aXRjaCxcbiAgLy8gdG8gYXZvaWQgZGVvcHRzIGluIG9sZCB2OFxuICBpZiAodHlwZSA9PT0gQ09ERVMpIHtcbiAgICBiYXNlID0gZXh0cmEgPSB3b3JrOyAgICAvKiBkdW1teSB2YWx1ZS0tbm90IHVzZWQgKi9cbiAgICBlbmQgPSAxOTtcblxuICB9IGVsc2UgaWYgKHR5cGUgPT09IExFTlMpIHtcbiAgICBiYXNlID0gbGJhc2U7XG4gICAgYmFzZV9pbmRleCAtPSAyNTc7XG4gICAgZXh0cmEgPSBsZXh0O1xuICAgIGV4dHJhX2luZGV4IC09IDI1NztcbiAgICBlbmQgPSAyNTY7XG5cbiAgfSBlbHNlIHsgICAgICAgICAgICAgICAgICAgIC8qIERJU1RTICovXG4gICAgYmFzZSA9IGRiYXNlO1xuICAgIGV4dHJhID0gZGV4dDtcbiAgICBlbmQgPSAtMTtcbiAgfVxuXG4gIC8qIGluaXRpYWxpemUgb3B0cyBmb3IgbG9vcCAqL1xuICBodWZmID0gMDsgICAgICAgICAgICAgICAgICAgLyogc3RhcnRpbmcgY29kZSAqL1xuICBzeW0gPSAwOyAgICAgICAgICAgICAgICAgICAgLyogc3RhcnRpbmcgY29kZSBzeW1ib2wgKi9cbiAgbGVuID0gbWluOyAgICAgICAgICAgICAgICAgIC8qIHN0YXJ0aW5nIGNvZGUgbGVuZ3RoICovXG4gIG5leHQgPSB0YWJsZV9pbmRleDsgICAgICAgICAgICAgIC8qIGN1cnJlbnQgdGFibGUgdG8gZmlsbCBpbiAqL1xuICBjdXJyID0gcm9vdDsgICAgICAgICAgICAgICAgLyogY3VycmVudCB0YWJsZSBpbmRleCBiaXRzICovXG4gIGRyb3AgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBjdXJyZW50IGJpdHMgdG8gZHJvcCBmcm9tIGNvZGUgZm9yIGluZGV4ICovXG4gIGxvdyA9IC0xOyAgICAgICAgICAgICAgICAgICAvKiB0cmlnZ2VyIG5ldyBzdWItdGFibGUgd2hlbiBsZW4gPiByb290ICovXG4gIHVzZWQgPSAxIDw8IHJvb3Q7ICAgICAgICAgIC8qIHVzZSByb290IHRhYmxlIGVudHJpZXMgKi9cbiAgbWFzayA9IHVzZWQgLSAxOyAgICAgICAgICAgIC8qIG1hc2sgZm9yIGNvbXBhcmluZyBsb3cgKi9cblxuICAvKiBjaGVjayBhdmFpbGFibGUgdGFibGUgc3BhY2UgKi9cbiAgaWYgKCh0eXBlID09PSBMRU5TICYmIHVzZWQgPiBFTk9VR0hfTEVOUykgfHxcbiAgICAodHlwZSA9PT0gRElTVFMgJiYgdXNlZCA+IEVOT1VHSF9ESVNUUykpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIC8qIHByb2Nlc3MgYWxsIGNvZGVzIGFuZCBtYWtlIHRhYmxlIGVudHJpZXMgKi9cbiAgZm9yICg7Oykge1xuICAgIC8qIGNyZWF0ZSB0YWJsZSBlbnRyeSAqL1xuICAgIGhlcmVfYml0cyA9IGxlbiAtIGRyb3A7XG4gICAgaWYgKHdvcmtbc3ltXSA8IGVuZCkge1xuICAgICAgaGVyZV9vcCA9IDA7XG4gICAgICBoZXJlX3ZhbCA9IHdvcmtbc3ltXTtcbiAgICB9XG4gICAgZWxzZSBpZiAod29ya1tzeW1dID4gZW5kKSB7XG4gICAgICBoZXJlX29wID0gZXh0cmFbZXh0cmFfaW5kZXggKyB3b3JrW3N5bV1dO1xuICAgICAgaGVyZV92YWwgPSBiYXNlW2Jhc2VfaW5kZXggKyB3b3JrW3N5bV1dO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGhlcmVfb3AgPSAzMiArIDY0OyAgICAgICAgIC8qIGVuZCBvZiBibG9jayAqL1xuICAgICAgaGVyZV92YWwgPSAwO1xuICAgIH1cblxuICAgIC8qIHJlcGxpY2F0ZSBmb3IgdGhvc2UgaW5kaWNlcyB3aXRoIGxvdyBsZW4gYml0cyBlcXVhbCB0byBodWZmICovXG4gICAgaW5jciA9IDEgPDwgKGxlbiAtIGRyb3ApO1xuICAgIGZpbGwgPSAxIDw8IGN1cnI7XG4gICAgbWluID0gZmlsbDsgICAgICAgICAgICAgICAgIC8qIHNhdmUgb2Zmc2V0IHRvIG5leHQgdGFibGUgKi9cbiAgICBkbyB7XG4gICAgICBmaWxsIC09IGluY3I7XG4gICAgICB0YWJsZVtuZXh0ICsgKGh1ZmYgPj4gZHJvcCkgKyBmaWxsXSA9IChoZXJlX2JpdHMgPDwgMjQpIHwgKGhlcmVfb3AgPDwgMTYpIHwgaGVyZV92YWwgfDA7XG4gICAgfSB3aGlsZSAoZmlsbCAhPT0gMCk7XG5cbiAgICAvKiBiYWNrd2FyZHMgaW5jcmVtZW50IHRoZSBsZW4tYml0IGNvZGUgaHVmZiAqL1xuICAgIGluY3IgPSAxIDw8IChsZW4gLSAxKTtcbiAgICB3aGlsZSAoaHVmZiAmIGluY3IpIHtcbiAgICAgIGluY3IgPj49IDE7XG4gICAgfVxuICAgIGlmIChpbmNyICE9PSAwKSB7XG4gICAgICBodWZmICY9IGluY3IgLSAxO1xuICAgICAgaHVmZiArPSBpbmNyO1xuICAgIH0gZWxzZSB7XG4gICAgICBodWZmID0gMDtcbiAgICB9XG5cbiAgICAvKiBnbyB0byBuZXh0IHN5bWJvbCwgdXBkYXRlIGNvdW50LCBsZW4gKi9cbiAgICBzeW0rKztcbiAgICBpZiAoLS1jb3VudFtsZW5dID09PSAwKSB7XG4gICAgICBpZiAobGVuID09PSBtYXgpIHsgYnJlYWs7IH1cbiAgICAgIGxlbiA9IGxlbnNbbGVuc19pbmRleCArIHdvcmtbc3ltXV07XG4gICAgfVxuXG4gICAgLyogY3JlYXRlIG5ldyBzdWItdGFibGUgaWYgbmVlZGVkICovXG4gICAgaWYgKGxlbiA+IHJvb3QgJiYgKGh1ZmYgJiBtYXNrKSAhPT0gbG93KSB7XG4gICAgICAvKiBpZiBmaXJzdCB0aW1lLCB0cmFuc2l0aW9uIHRvIHN1Yi10YWJsZXMgKi9cbiAgICAgIGlmIChkcm9wID09PSAwKSB7XG4gICAgICAgIGRyb3AgPSByb290O1xuICAgICAgfVxuXG4gICAgICAvKiBpbmNyZW1lbnQgcGFzdCBsYXN0IHRhYmxlICovXG4gICAgICBuZXh0ICs9IG1pbjsgICAgICAgICAgICAvKiBoZXJlIG1pbiBpcyAxIDw8IGN1cnIgKi9cblxuICAgICAgLyogZGV0ZXJtaW5lIGxlbmd0aCBvZiBuZXh0IHRhYmxlICovXG4gICAgICBjdXJyID0gbGVuIC0gZHJvcDtcbiAgICAgIGxlZnQgPSAxIDw8IGN1cnI7XG4gICAgICB3aGlsZSAoY3VyciArIGRyb3AgPCBtYXgpIHtcbiAgICAgICAgbGVmdCAtPSBjb3VudFtjdXJyICsgZHJvcF07XG4gICAgICAgIGlmIChsZWZ0IDw9IDApIHsgYnJlYWs7IH1cbiAgICAgICAgY3VycisrO1xuICAgICAgICBsZWZ0IDw8PSAxO1xuICAgICAgfVxuXG4gICAgICAvKiBjaGVjayBmb3IgZW5vdWdoIHNwYWNlICovXG4gICAgICB1c2VkICs9IDEgPDwgY3VycjtcbiAgICAgIGlmICgodHlwZSA9PT0gTEVOUyAmJiB1c2VkID4gRU5PVUdIX0xFTlMpIHx8XG4gICAgICAgICh0eXBlID09PSBESVNUUyAmJiB1c2VkID4gRU5PVUdIX0RJU1RTKSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cblxuICAgICAgLyogcG9pbnQgZW50cnkgaW4gcm9vdCB0YWJsZSB0byBzdWItdGFibGUgKi9cbiAgICAgIGxvdyA9IGh1ZmYgJiBtYXNrO1xuICAgICAgLyp0YWJsZS5vcFtsb3ddID0gY3VycjtcbiAgICAgIHRhYmxlLmJpdHNbbG93XSA9IHJvb3Q7XG4gICAgICB0YWJsZS52YWxbbG93XSA9IG5leHQgLSBvcHRzLnRhYmxlX2luZGV4OyovXG4gICAgICB0YWJsZVtsb3ddID0gKHJvb3QgPDwgMjQpIHwgKGN1cnIgPDwgMTYpIHwgKG5leHQgLSB0YWJsZV9pbmRleCkgfDA7XG4gICAgfVxuICB9XG5cbiAgLyogZmlsbCBpbiByZW1haW5pbmcgdGFibGUgZW50cnkgaWYgY29kZSBpcyBpbmNvbXBsZXRlIChndWFyYW50ZWVkIHRvIGhhdmVcbiAgIGF0IG1vc3Qgb25lIHJlbWFpbmluZyBlbnRyeSwgc2luY2UgaWYgdGhlIGNvZGUgaXMgaW5jb21wbGV0ZSwgdGhlXG4gICBtYXhpbXVtIGNvZGUgbGVuZ3RoIHRoYXQgd2FzIGFsbG93ZWQgdG8gZ2V0IHRoaXMgZmFyIGlzIG9uZSBiaXQpICovXG4gIGlmIChodWZmICE9PSAwKSB7XG4gICAgLy90YWJsZS5vcFtuZXh0ICsgaHVmZl0gPSA2NDsgICAgICAgICAgICAvKiBpbnZhbGlkIGNvZGUgbWFya2VyICovXG4gICAgLy90YWJsZS5iaXRzW25leHQgKyBodWZmXSA9IGxlbiAtIGRyb3A7XG4gICAgLy90YWJsZS52YWxbbmV4dCArIGh1ZmZdID0gMDtcbiAgICB0YWJsZVtuZXh0ICsgaHVmZl0gPSAoKGxlbiAtIGRyb3ApIDw8IDI0KSB8ICg2NCA8PCAxNikgfDA7XG4gIH1cblxuICAvKiBzZXQgcmV0dXJuIHBhcmFtZXRlcnMgKi9cbiAgLy9vcHRzLnRhYmxlX2luZGV4ICs9IHVzZWQ7XG4gIG9wdHMuYml0cyA9IHJvb3Q7XG4gIHJldHVybiAwO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9qc3ppcC9+L3Bha28vbGliL3psaWIvaW5mdHJlZXMuanNcbi8vIG1vZHVsZSBpZCA9IDExM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){"use strict";eval('\n\n\nvar utils = __webpack_require__(3);\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n//var Z_FILTERED          = 1;\n//var Z_HUFFMAN_ONLY      = 2;\n//var Z_RLE               = 3;\nvar Z_FIXED               = 4;\n//var Z_DEFAULT_STRATEGY  = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\nvar Z_BINARY              = 0;\nvar Z_TEXT                = 1;\n//var Z_ASCII             = 1; // = Z_TEXT\nvar Z_UNKNOWN             = 2;\n\n/*============================================================================*/\n\n\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n// From zutil.h\n\nvar STORED_BLOCK = 0;\nvar STATIC_TREES = 1;\nvar DYN_TREES    = 2;\n/* The three kinds of block type */\n\nvar MIN_MATCH    = 3;\nvar MAX_MATCH    = 258;\n/* The minimum and maximum match lengths */\n\n// From deflate.h\n/* ===========================================================================\n * Internal compression state.\n */\n\nvar LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\n\nvar LITERALS      = 256;\n/* number of literal bytes 0..255 */\n\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\n\nvar D_CODES       = 30;\n/* number of distance codes */\n\nvar BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\n\nvar HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\n\nvar MAX_BITS      = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nvar Buf_size      = 16;\n/* size of bit buffer in bi_buf */\n\n\n/* ===========================================================================\n * Constants\n */\n\nvar MAX_BL_BITS = 7;\n/* Bit length codes must not exceed MAX_BL_BITS bits */\n\nvar END_BLOCK   = 256;\n/* end of block literal code */\n\nvar REP_3_6     = 16;\n/* repeat previous bit length 3-6 times (2 bits of repeat count) */\n\nvar REPZ_3_10   = 17;\n/* repeat a zero length 3-10 times  (3 bits of repeat count) */\n\nvar REPZ_11_138 = 18;\n/* repeat a zero length 11-138 times  (7 bits of repeat count) */\n\n/* eslint-disable comma-spacing,array-bracket-spacing */\nvar extra_lbits =   /* extra bits for each length code */\n  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];\n\nvar extra_dbits =   /* extra bits for each distance code */\n  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];\n\nvar extra_blbits =  /* extra bits for each bit length code */\n  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];\n\nvar bl_order =\n  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];\n/* eslint-enable comma-spacing,array-bracket-spacing */\n\n/* The lengths of the bit length codes are sent in order of decreasing\n * probability, to avoid transmitting the lengths for unused bit length codes.\n */\n\n/* ===========================================================================\n * Local data. These are initialized only once.\n */\n\n// We pre-fill arrays with 0 to avoid uninitialized gaps\n\nvar DIST_CODE_LEN = 512; /* see definition of array dist_code below */\n\n// !!!! Use flat array insdead of structure, Freq = i*2, Len = i*2+1\nvar static_ltree  = new Array((L_CODES + 2) * 2);\nzero(static_ltree);\n/* The static literal tree. Since the bit lengths are imposed, there is no\n * need for the L_CODES extra codes used during heap construction. However\n * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n * below).\n */\n\nvar static_dtree  = new Array(D_CODES * 2);\nzero(static_dtree);\n/* The static distance tree. (Actually a trivial tree since all codes use\n * 5 bits.)\n */\n\nvar _dist_code    = new Array(DIST_CODE_LEN);\nzero(_dist_code);\n/* Distance codes. The first 256 values correspond to the distances\n * 3 .. 258, the last 256 values correspond to the top 8 bits of\n * the 15 bit distances.\n */\n\nvar _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);\nzero(_length_code);\n/* length code for each normalized match length (0 == MIN_MATCH) */\n\nvar base_length   = new Array(LENGTH_CODES);\nzero(base_length);\n/* First normalized length for each code (0 = MIN_MATCH) */\n\nvar base_dist     = new Array(D_CODES);\nzero(base_dist);\n/* First normalized distance for each code (0 = distance of 1) */\n\n\nfunction StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n\n  this.static_tree  = static_tree;  /* static tree or NULL */\n  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */\n  this.extra_base   = extra_base;   /* base index for extra_bits */\n  this.elems        = elems;        /* max number of elements in the tree */\n  this.max_length   = max_length;   /* max bit length for the codes */\n\n  // show if `static_tree` has data or dummy - needed for monomorphic objects\n  this.has_stree    = static_tree && static_tree.length;\n}\n\n\nvar static_l_desc;\nvar static_d_desc;\nvar static_bl_desc;\n\n\nfunction TreeDesc(dyn_tree, stat_desc) {\n  this.dyn_tree = dyn_tree;     /* the dynamic tree */\n  this.max_code = 0;            /* largest code with non zero frequency */\n  this.stat_desc = stat_desc;   /* the corresponding static tree */\n}\n\n\n\nfunction d_code(dist) {\n  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n}\n\n\n/* ===========================================================================\n * Output a short LSB first on the stream.\n * IN assertion: there is enough room in pendingBuf.\n */\nfunction put_short(s, w) {\n//    put_byte(s, (uch)((w) & 0xff));\n//    put_byte(s, (uch)((ush)(w) >> 8));\n  s.pending_buf[s.pending++] = (w) & 0xff;\n  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;\n}\n\n\n/* ===========================================================================\n * Send a value on a given number of bits.\n * IN assertion: length <= 16 and value fits in length bits.\n */\nfunction send_bits(s, value, length) {\n  if (s.bi_valid > (Buf_size - length)) {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    put_short(s, s.bi_buf);\n    s.bi_buf = value >> (Buf_size - s.bi_valid);\n    s.bi_valid += length - Buf_size;\n  } else {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    s.bi_valid += length;\n  }\n}\n\n\nfunction send_code(s, c, tree) {\n  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);\n}\n\n\n/* ===========================================================================\n * Reverse the first len bits of a code, using straightforward code (a faster\n * method would use a table)\n * IN assertion: 1 <= len <= 15\n */\nfunction bi_reverse(code, len) {\n  var res = 0;\n  do {\n    res |= code & 1;\n    code >>>= 1;\n    res <<= 1;\n  } while (--len > 0);\n  return res >>> 1;\n}\n\n\n/* ===========================================================================\n * Flush the bit buffer, keeping at most 7 bits in it.\n */\nfunction bi_flush(s) {\n  if (s.bi_valid === 16) {\n    put_short(s, s.bi_buf);\n    s.bi_buf = 0;\n    s.bi_valid = 0;\n\n  } else if (s.bi_valid >= 8) {\n    s.pending_buf[s.pending++] = s.bi_buf & 0xff;\n    s.bi_buf >>= 8;\n    s.bi_valid -= 8;\n  }\n}\n\n\n/* ===========================================================================\n * Compute the optimal bit lengths for a tree and update the total bit length\n * for the current block.\n * IN assertion: the fields freq and dad are set, heap[heap_max] and\n *    above are the tree nodes sorted by increasing frequency.\n * OUT assertions: the field len is set to the optimal bit length, the\n *     array bl_count contains the frequencies for each bit length.\n *     The length opt_len is updated; static_len is also updated if stree is\n *     not null.\n */\nfunction gen_bitlen(s, desc)\n//    deflate_state *s;\n//    tree_desc *desc;    /* the tree descriptor */\n{\n  var tree            = desc.dyn_tree;\n  var max_code        = desc.max_code;\n  var stree           = desc.stat_desc.static_tree;\n  var has_stree       = desc.stat_desc.has_stree;\n  var extra           = desc.stat_desc.extra_bits;\n  var base            = desc.stat_desc.extra_base;\n  var max_length      = desc.stat_desc.max_length;\n  var h;              /* heap index */\n  var n, m;           /* iterate over the tree elements */\n  var bits;           /* bit length */\n  var xbits;          /* extra bits */\n  var f;              /* frequency */\n  var overflow = 0;   /* number of elements with bit length too large */\n\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    s.bl_count[bits] = 0;\n  }\n\n  /* In a first pass, compute the optimal bit lengths (which may\n   * overflow in the case of the bit length tree).\n   */\n  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */\n\n  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {\n    n = s.heap[h];\n    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;\n    if (bits > max_length) {\n      bits = max_length;\n      overflow++;\n    }\n    tree[n * 2 + 1]/*.Len*/ = bits;\n    /* We overwrite tree[n].Dad which is no longer needed */\n\n    if (n > max_code) { continue; } /* not a leaf node */\n\n    s.bl_count[bits]++;\n    xbits = 0;\n    if (n >= base) {\n      xbits = extra[n - base];\n    }\n    f = tree[n * 2]/*.Freq*/;\n    s.opt_len += f * (bits + xbits);\n    if (has_stree) {\n      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);\n    }\n  }\n  if (overflow === 0) { return; }\n\n  // Trace((stderr,"\\nbit length overflow\\n"));\n  /* This happens for example on obj2 and pic of the Calgary corpus */\n\n  /* Find the first bit length which could increase: */\n  do {\n    bits = max_length - 1;\n    while (s.bl_count[bits] === 0) { bits--; }\n    s.bl_count[bits]--;      /* move one leaf down the tree */\n    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */\n    s.bl_count[max_length]--;\n    /* The brother of the overflow item also moves one step up,\n     * but this does not affect bl_count[max_length]\n     */\n    overflow -= 2;\n  } while (overflow > 0);\n\n  /* Now recompute all bit lengths, scanning in increasing frequency.\n   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n   * lengths instead of fixing only the wrong ones. This idea is taken\n   * from \'ar\' written by Haruhiko Okumura.)\n   */\n  for (bits = max_length; bits !== 0; bits--) {\n    n = s.bl_count[bits];\n    while (n !== 0) {\n      m = s.heap[--h];\n      if (m > max_code) { continue; }\n      if (tree[m * 2 + 1]/*.Len*/ !== bits) {\n        // Trace((stderr,"code %d bits %d->%d\\n", m, tree[m].Len, bits));\n        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;\n        tree[m * 2 + 1]/*.Len*/ = bits;\n      }\n      n--;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Generate the codes for a given tree and bit counts (which need not be\n * optimal).\n * IN assertion: the array bl_count contains the bit length statistics for\n * the given tree and the field len is set for all tree elements.\n * OUT assertion: the field code is set for all tree elements of non\n *     zero code length.\n */\nfunction gen_codes(tree, max_code, bl_count)\n//    ct_data *tree;             /* the tree to decorate */\n//    int max_code;              /* largest code with non zero frequency */\n//    ushf *bl_count;            /* number of codes at each bit length */\n{\n  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */\n  var code = 0;              /* running code value */\n  var bits;                  /* bit index */\n  var n;                     /* code index */\n\n  /* The distribution counts are first used to generate the code values\n   * without bit reversal.\n   */\n  for (bits = 1; bits <= MAX_BITS; bits++) {\n    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;\n  }\n  /* Check that the bit counts in bl_count are consistent. The last code\n   * must be all ones.\n   */\n  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n  //        "inconsistent bit counts");\n  //Tracev((stderr,"\\ngen_codes: max_code %d ", max_code));\n\n  for (n = 0;  n <= max_code; n++) {\n    var len = tree[n * 2 + 1]/*.Len*/;\n    if (len === 0) { continue; }\n    /* Now reverse the bits */\n    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);\n\n    //Tracecv(tree != static_ltree, (stderr,"\\nn %3d %c l %2d c %4x (%x) ",\n    //     n, (isgraph(n) ? n : \' \'), len, tree[n].Code, next_code[len]-1));\n  }\n}\n\n\n/* ===========================================================================\n * Initialize the various \'constant\' tables.\n */\nfunction tr_static_init() {\n  var n;        /* iterates over tree elements */\n  var bits;     /* bit counter */\n  var length;   /* length value */\n  var code;     /* code value */\n  var dist;     /* distance index */\n  var bl_count = new Array(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  // do check in _tr_init()\n  //if (static_init_done) return;\n\n  /* For some embedded targets, global variables are not initialized: */\n/*#ifdef NO_INIT_GLOBAL_POINTERS\n  static_l_desc.static_tree = static_ltree;\n  static_l_desc.extra_bits = extra_lbits;\n  static_d_desc.static_tree = static_dtree;\n  static_d_desc.extra_bits = extra_dbits;\n  static_bl_desc.extra_bits = extra_blbits;\n#endif*/\n\n  /* Initialize the mapping length (0..255) -> length code (0..28) */\n  length = 0;\n  for (code = 0; code < LENGTH_CODES - 1; code++) {\n    base_length[code] = length;\n    for (n = 0; n < (1 << extra_lbits[code]); n++) {\n      _length_code[length++] = code;\n    }\n  }\n  //Assert (length == 256, "tr_static_init: length != 256");\n  /* Note that the length 255 (match length 258) can be represented\n   * in two different ways: code 284 + 5 bits or code 285, so we\n   * overwrite length_code[255] to use the best encoding:\n   */\n  _length_code[length - 1] = code;\n\n  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n  dist = 0;\n  for (code = 0; code < 16; code++) {\n    base_dist[code] = dist;\n    for (n = 0; n < (1 << extra_dbits[code]); n++) {\n      _dist_code[dist++] = code;\n    }\n  }\n  //Assert (dist == 256, "tr_static_init: dist != 256");\n  dist >>= 7; /* from now on, all distances are divided by 128 */\n  for (; code < D_CODES; code++) {\n    base_dist[code] = dist << 7;\n    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {\n      _dist_code[256 + dist++] = code;\n    }\n  }\n  //Assert (dist == 256, "tr_static_init: 256+dist != 512");\n\n  /* Construct the codes of the static literal tree */\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    bl_count[bits] = 0;\n  }\n\n  n = 0;\n  while (n <= 143) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  while (n <= 255) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 9;\n    n++;\n    bl_count[9]++;\n  }\n  while (n <= 279) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 7;\n    n++;\n    bl_count[7]++;\n  }\n  while (n <= 287) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  /* Codes 286 and 287 do not exist, but we must include them in the\n   * tree construction to get a canonical Huffman tree (longest code\n   * all ones)\n   */\n  gen_codes(static_ltree, L_CODES + 1, bl_count);\n\n  /* The static distance tree is trivial: */\n  for (n = 0; n < D_CODES; n++) {\n    static_dtree[n * 2 + 1]/*.Len*/ = 5;\n    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);\n  }\n\n  // Now data ready and we can init static trees\n  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);\n  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);\n  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);\n\n  //static_init_done = true;\n}\n\n\n/* ===========================================================================\n * Initialize a new block.\n */\nfunction init_block(s) {\n  var n; /* iterates over tree elements */\n\n  /* Initialize the trees. */\n  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }\n\n  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;\n  s.opt_len = s.static_len = 0;\n  s.last_lit = s.matches = 0;\n}\n\n\n/* ===========================================================================\n * Flush the bit buffer and align the output on a byte boundary\n */\nfunction bi_windup(s)\n{\n  if (s.bi_valid > 8) {\n    put_short(s, s.bi_buf);\n  } else if (s.bi_valid > 0) {\n    //put_byte(s, (Byte)s->bi_buf);\n    s.pending_buf[s.pending++] = s.bi_buf;\n  }\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n}\n\n/* ===========================================================================\n * Copy a stored block, storing first the length and its\n * one\'s complement if requested.\n */\nfunction copy_block(s, buf, len, header)\n//DeflateState *s;\n//charf    *buf;    /* the input data */\n//unsigned len;     /* its length */\n//int      header;  /* true if block header must be written */\n{\n  bi_windup(s);        /* align on byte boundary */\n\n  if (header) {\n    put_short(s, len);\n    put_short(s, ~len);\n  }\n//  while (len--) {\n//    put_byte(s, *buf++);\n//  }\n  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);\n  s.pending += len;\n}\n\n/* ===========================================================================\n * Compares to subtrees, using the tree depth as tie breaker when\n * the subtrees have equal frequency. This minimizes the worst case length.\n */\nfunction smaller(tree, n, m, depth) {\n  var _n2 = n * 2;\n  var _m2 = m * 2;\n  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||\n         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));\n}\n\n/* ===========================================================================\n * Restore the heap property by moving down the tree starting at node k,\n * exchanging a node with the smallest of its two sons if necessary, stopping\n * when the heap property is re-established (each father smaller than its\n * two sons).\n */\nfunction pqdownheap(s, tree, k)\n//    deflate_state *s;\n//    ct_data *tree;  /* the tree to restore */\n//    int k;               /* node to move down */\n{\n  var v = s.heap[k];\n  var j = k << 1;  /* left son of k */\n  while (j <= s.heap_len) {\n    /* Set j to the smallest of the two sons: */\n    if (j < s.heap_len &&\n      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n      j++;\n    }\n    /* Exit if v is smaller than both sons */\n    if (smaller(tree, v, s.heap[j], s.depth)) { break; }\n\n    /* Exchange v with the smallest son */\n    s.heap[k] = s.heap[j];\n    k = j;\n\n    /* And continue down the tree, setting j to the left son of k */\n    j <<= 1;\n  }\n  s.heap[k] = v;\n}\n\n\n// inlined manually\n// var SMALLEST = 1;\n\n/* ===========================================================================\n * Send the block data compressed using the given Huffman trees\n */\nfunction compress_block(s, ltree, dtree)\n//    deflate_state *s;\n//    const ct_data *ltree; /* literal tree */\n//    const ct_data *dtree; /* distance tree */\n{\n  var dist;           /* distance of matched string */\n  var lc;             /* match length or unmatched char (if dist == 0) */\n  var lx = 0;         /* running index in l_buf */\n  var code;           /* the code to send */\n  var extra;          /* number of extra bits to send */\n\n  if (s.last_lit !== 0) {\n    do {\n      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);\n      lc = s.pending_buf[s.l_buf + lx];\n      lx++;\n\n      if (dist === 0) {\n        send_code(s, lc, ltree); /* send a literal byte */\n        //Tracecv(isgraph(lc), (stderr," \'%c\' ", lc));\n      } else {\n        /* Here, lc is the match length - MIN_MATCH */\n        code = _length_code[lc];\n        send_code(s, code + LITERALS + 1, ltree); /* send the length code */\n        extra = extra_lbits[code];\n        if (extra !== 0) {\n          lc -= base_length[code];\n          send_bits(s, lc, extra);       /* send the extra length bits */\n        }\n        dist--; /* dist is now the match distance - 1 */\n        code = d_code(dist);\n        //Assert (code < D_CODES, "bad d_code");\n\n        send_code(s, code, dtree);       /* send the distance code */\n        extra = extra_dbits[code];\n        if (extra !== 0) {\n          dist -= base_dist[code];\n          send_bits(s, dist, extra);   /* send the extra distance bits */\n        }\n      } /* literal or match pair ? */\n\n      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */\n      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,\n      //       "pendingBuf overflow");\n\n    } while (lx < s.last_lit);\n  }\n\n  send_code(s, END_BLOCK, ltree);\n}\n\n\n/* ===========================================================================\n * Construct one Huffman tree and assigns the code bit strings and lengths.\n * Update the total bit length for the current block.\n * IN assertion: the field freq is set for all tree elements.\n * OUT assertions: the fields len and code are set to the optimal bit length\n *     and corresponding code. The length opt_len is updated; static_len is\n *     also updated if stree is not null. The field max_code is set.\n */\nfunction build_tree(s, desc)\n//    deflate_state *s;\n//    tree_desc *desc; /* the tree descriptor */\n{\n  var tree     = desc.dyn_tree;\n  var stree    = desc.stat_desc.static_tree;\n  var has_stree = desc.stat_desc.has_stree;\n  var elems    = desc.stat_desc.elems;\n  var n, m;          /* iterate over heap elements */\n  var max_code = -1; /* largest code with non zero frequency */\n  var node;          /* new node being created */\n\n  /* Construct the initial heap, with least frequent element in\n   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n   * heap[0] is not used.\n   */\n  s.heap_len = 0;\n  s.heap_max = HEAP_SIZE;\n\n  for (n = 0; n < elems; n++) {\n    if (tree[n * 2]/*.Freq*/ !== 0) {\n      s.heap[++s.heap_len] = max_code = n;\n      s.depth[n] = 0;\n\n    } else {\n      tree[n * 2 + 1]/*.Len*/ = 0;\n    }\n  }\n\n  /* The pkzip format requires that at least one distance code exists,\n   * and that at least one bit should be sent even if there is only one\n   * possible code. So to avoid special checks later on we force at least\n   * two codes of non zero frequency.\n   */\n  while (s.heap_len < 2) {\n    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);\n    tree[node * 2]/*.Freq*/ = 1;\n    s.depth[node] = 0;\n    s.opt_len--;\n\n    if (has_stree) {\n      s.static_len -= stree[node * 2 + 1]/*.Len*/;\n    }\n    /* node is 0 or 1 so it does not have extra bits */\n  }\n  desc.max_code = max_code;\n\n  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n   * establish sub-heaps of increasing lengths:\n   */\n  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }\n\n  /* Construct the Huffman tree by repeatedly combining the least two\n   * frequent nodes.\n   */\n  node = elems;              /* next internal node of the tree */\n  do {\n    //pqremove(s, tree, n);  /* n = node of least frequency */\n    /*** pqremove ***/\n    n = s.heap[1/*SMALLEST*/];\n    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n    /***/\n\n    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */\n\n    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */\n    s.heap[--s.heap_max] = m;\n\n    /* Create a new node father of n and m */\n    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;\n    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;\n\n    /* and insert the new node in the heap */\n    s.heap[1/*SMALLEST*/] = node++;\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n\n  } while (s.heap_len >= 2);\n\n  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];\n\n  /* At this point, the fields freq and dad are set. We can now\n   * generate the bit lengths.\n   */\n  gen_bitlen(s, desc);\n\n  /* The field len is now set, we can generate the bit codes */\n  gen_codes(tree, max_code, s.bl_count);\n}\n\n\n/* ===========================================================================\n * Scan a literal or distance tree to determine the frequencies of the codes\n * in the bit length tree.\n */\nfunction scan_tree(s, tree, max_code)\n//    deflate_state *s;\n//    ct_data *tree;   /* the tree to be scanned */\n//    int max_code;    /* and its largest code of non zero frequency */\n{\n  var n;                     /* iterates over all tree elements */\n  var prevlen = -1;          /* last emitted length */\n  var curlen;                /* length of current code */\n\n  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  var count = 0;             /* repeat count of the current code */\n  var max_count = 7;         /* max repeat count */\n  var min_count = 4;         /* min repeat count */\n\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      s.bl_tree[curlen * 2]/*.Freq*/ += count;\n\n    } else if (curlen !== 0) {\n\n      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }\n      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;\n\n    } else if (count <= 10) {\n      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;\n\n    } else {\n      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;\n    }\n\n    count = 0;\n    prevlen = curlen;\n\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Send a literal or distance tree in compressed form, using the codes in\n * bl_tree.\n */\nfunction send_tree(s, tree, max_code)\n//    deflate_state *s;\n//    ct_data *tree; /* the tree to be scanned */\n//    int max_code;       /* and its largest code of non zero frequency */\n{\n  var n;                     /* iterates over all tree elements */\n  var prevlen = -1;          /* last emitted length */\n  var curlen;                /* length of current code */\n\n  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  var count = 0;             /* repeat count of the current code */\n  var max_count = 7;         /* max repeat count */\n  var min_count = 4;         /* min repeat count */\n\n  /* tree[max_code+1].Len = -1; */  /* guard already set */\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);\n\n    } else if (curlen !== 0) {\n      if (curlen !== prevlen) {\n        send_code(s, curlen, s.bl_tree);\n        count--;\n      }\n      //Assert(count >= 3 && count <= 6, " 3_6?");\n      send_code(s, REP_3_6, s.bl_tree);\n      send_bits(s, count - 3, 2);\n\n    } else if (count <= 10) {\n      send_code(s, REPZ_3_10, s.bl_tree);\n      send_bits(s, count - 3, 3);\n\n    } else {\n      send_code(s, REPZ_11_138, s.bl_tree);\n      send_bits(s, count - 11, 7);\n    }\n\n    count = 0;\n    prevlen = curlen;\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Construct the Huffman tree for the bit lengths and return the index in\n * bl_order of the last bit length code to send.\n */\nfunction build_bl_tree(s) {\n  var max_blindex;  /* index of last bit length code of non zero freq */\n\n  /* Determine the bit length frequencies for literal and distance trees */\n  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n\n  /* Build the bit length tree: */\n  build_tree(s, s.bl_desc);\n  /* opt_len now includes the length of the tree representations, except\n   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n   */\n\n  /* Determine the number of bit length codes to send. The pkzip format\n   * requires that at least 4 bit length codes be sent. (appnote.txt says\n   * 3 but the actual value used is 4.)\n   */\n  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {\n    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {\n      break;\n    }\n  }\n  /* Update opt_len to include the bit length tree and counts */\n  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n  //Tracev((stderr, "\\ndyn trees: dyn %ld, stat %ld",\n  //        s->opt_len, s->static_len));\n\n  return max_blindex;\n}\n\n\n/* ===========================================================================\n * Send the header for a block using dynamic Huffman trees: the counts, the\n * lengths of the bit length codes, the literal tree and the distance tree.\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n */\nfunction send_all_trees(s, lcodes, dcodes, blcodes)\n//    deflate_state *s;\n//    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n{\n  var rank;                    /* index in bl_order */\n\n  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");\n  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n  //        "too many codes");\n  //Tracev((stderr, "\\nbl counts: "));\n  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */\n  send_bits(s, dcodes - 1,   5);\n  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */\n  for (rank = 0; rank < blcodes; rank++) {\n    //Tracev((stderr, "\\nbl code %2d ", bl_order[rank]));\n    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);\n  }\n  //Tracev((stderr, "\\nbl tree: sent %ld", s->bits_sent));\n\n  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */\n  //Tracev((stderr, "\\nlit tree: sent %ld", s->bits_sent));\n\n  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */\n  //Tracev((stderr, "\\ndist tree: sent %ld", s->bits_sent));\n}\n\n\n/* ===========================================================================\n * Check if the data type is TEXT or BINARY, using the following algorithm:\n * - TEXT if the two conditions below are satisfied:\n *    a) There are no non-portable control characters belonging to the\n *       "black list" (0..6, 14..25, 28..31).\n *    b) There is at least one printable character belonging to the\n *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n * - BINARY otherwise.\n * - The following partially-portable control characters form a\n *   "gray list" that is ignored in this detection algorithm:\n *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n * IN assertion: the fields Freq of dyn_ltree are set.\n */\nfunction detect_data_type(s) {\n  /* black_mask is the bit mask of black-listed bytes\n   * set bits 0..6, 14..25, and 28..31\n   * 0xf3ffc07f = binary 11110011111111111100000001111111\n   */\n  var black_mask = 0xf3ffc07f;\n  var n;\n\n  /* Check for non-textual ("black-listed") bytes. */\n  for (n = 0; n <= 31; n++, black_mask >>>= 1) {\n    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {\n      return Z_BINARY;\n    }\n  }\n\n  /* Check for textual ("white-listed") bytes. */\n  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||\n      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {\n    return Z_TEXT;\n  }\n  for (n = 32; n < LITERALS; n++) {\n    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {\n      return Z_TEXT;\n    }\n  }\n\n  /* There are no "black-listed" or "white-listed" bytes:\n   * this stream either is empty or has tolerated ("gray-listed") bytes only.\n   */\n  return Z_BINARY;\n}\n\n\nvar static_init_done = false;\n\n/* ===========================================================================\n * Initialize the tree data structures for a new zlib stream.\n */\nfunction _tr_init(s)\n{\n\n  if (!static_init_done) {\n    tr_static_init();\n    static_init_done = true;\n  }\n\n  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);\n  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);\n  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n\n  /* Initialize the first block of the first file: */\n  init_block(s);\n}\n\n\n/* ===========================================================================\n * Send a stored block\n */\nfunction _tr_stored_block(s, buf, stored_len, last)\n//DeflateState *s;\n//charf *buf;       /* input block */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */\n  copy_block(s, buf, stored_len, true); /* with header */\n}\n\n\n/* ===========================================================================\n * Send one empty static block to give enough lookahead for inflate.\n * This takes 10 bits, of which 7 may remain in the bit buffer.\n */\nfunction _tr_align(s) {\n  send_bits(s, STATIC_TREES << 1, 3);\n  send_code(s, END_BLOCK, static_ltree);\n  bi_flush(s);\n}\n\n\n/* ===========================================================================\n * Determine the best encoding for the current block: dynamic trees, static\n * trees or store, and output the encoded block to the zip file.\n */\nfunction _tr_flush_block(s, buf, stored_len, last)\n//DeflateState *s;\n//charf *buf;       /* input block, or NULL if too old */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */\n  var max_blindex = 0;        /* index of last bit length code of non zero freq */\n\n  /* Build the Huffman trees unless a stored block is forced */\n  if (s.level > 0) {\n\n    /* Check if the file is binary or text */\n    if (s.strm.data_type === Z_UNKNOWN) {\n      s.strm.data_type = detect_data_type(s);\n    }\n\n    /* Construct the literal and distance trees */\n    build_tree(s, s.l_desc);\n    // Tracev((stderr, "\\nlit data: dyn %ld, stat %ld", s->opt_len,\n    //        s->static_len));\n\n    build_tree(s, s.d_desc);\n    // Tracev((stderr, "\\ndist data: dyn %ld, stat %ld", s->opt_len,\n    //        s->static_len));\n    /* At this point, opt_len and static_len are the total bit lengths of\n     * the compressed block data, excluding the tree representations.\n     */\n\n    /* Build the bit length tree for the above two trees, and get the index\n     * in bl_order of the last bit length code to send.\n     */\n    max_blindex = build_bl_tree(s);\n\n    /* Determine the best encoding. Compute the block lengths in bytes. */\n    opt_lenb = (s.opt_len + 3 + 7) >>> 3;\n    static_lenb = (s.static_len + 3 + 7) >>> 3;\n\n    // Tracev((stderr, "\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",\n    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n    //        s->last_lit));\n\n    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }\n\n  } else {\n    // Assert(buf != (char*)0, "lost buf");\n    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */\n  }\n\n  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {\n    /* 4: two words for the lengths */\n\n    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n     * Otherwise we can\'t have processed more than WSIZE input bytes since\n     * the last block flush, because compression would have been\n     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n     * transform a block into a stored block.\n     */\n    _tr_stored_block(s, buf, stored_len, last);\n\n  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {\n\n    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n    compress_block(s, static_ltree, static_dtree);\n\n  } else {\n    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n    compress_block(s, s.dyn_ltree, s.dyn_dtree);\n  }\n  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");\n  /* The above check is made mod 2^32, for files larger than 512 MB\n   * and uLong implemented on 32 bits.\n   */\n  init_block(s);\n\n  if (last) {\n    bi_windup(s);\n  }\n  // Tracev((stderr,"\\ncomprlen %lu(%lu) ", s->compressed_len>>3,\n  //       s->compressed_len-7*last));\n}\n\n/* ===========================================================================\n * Save the match info and tally the frequency counts. Return true if\n * the current block must be flushed.\n */\nfunction _tr_tally(s, dist, lc)\n//    deflate_state *s;\n//    unsigned dist;  /* distance of matched string */\n//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n{\n  //var out_length, in_length, dcode;\n\n  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;\n  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;\n\n  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;\n  s.last_lit++;\n\n  if (dist === 0) {\n    /* lc is the unmatched char */\n    s.dyn_ltree[lc * 2]/*.Freq*/++;\n  } else {\n    s.matches++;\n    /* Here, lc is the match length - MIN_MATCH */\n    dist--;             /* dist = match distance - 1 */\n    //Assert((ush)dist < (ush)MAX_DIST(s) &&\n    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");\n\n    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;\n    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;\n  }\n\n// (!) This block is disabled in zlib defailts,\n// don\'t enable it for binary compatibility\n\n//#ifdef TRUNCATE_BLOCK\n//  /* Try to guess if it is profitable to stop the current block here */\n//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {\n//    /* Compute an upper bound for the compressed length */\n//    out_length = s.last_lit*8;\n//    in_length = s.strstart - s.block_start;\n//\n//    for (dcode = 0; dcode < D_CODES; dcode++) {\n//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);\n//    }\n//    out_length >>>= 3;\n//    //Tracev((stderr,"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",\n//    //       s->last_lit, in_length, out_length,\n//    //       100L - out_length*100L/in_length));\n//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {\n//      return true;\n//    }\n//  }\n//#endif\n\n  return (s.last_lit === s.lit_bufsize - 1);\n  /* We avoid equality with lit_bufsize because of wraparound at 64K\n   * on 16 bit machines and because stored blocks are restricted to\n   * 64K-1 bytes.\n   */\n}\n\nexports._tr_init  = _tr_init;\nexports._tr_stored_block = _tr_stored_block;\nexports._tr_flush_block  = _tr_flush_block;\nexports._tr_tally = _tr_tally;\nexports._tr_align = _tr_align;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2pzemlwL34vcGFrby9saWIvemxpYi90cmVlcy5qcz9kN2M0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7QUFHQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5Qjs7QUFFQTs7O0FBR0Esb0JBQW9CLHNCQUFzQixxQkFBcUIsY0FBYyxFQUFFOztBQUUvRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQSxrQ0FBa0M7QUFDbEMsaUNBQWlDO0FBQ2pDLGlDQUFpQztBQUNqQyw0QkFBNEI7QUFDNUIsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSwyQkFBMkI7QUFDM0Isb0JBQW9CO0FBQ3BCLDZCQUE2QjtBQUM3Qjs7OztBQUlBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FB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QUVBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxMTQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvY29tbW9uJyk7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8vdmFyIFpfRklMVEVSRUQgICAgICAgICAgPSAxO1xuLy92YXIgWl9IVUZGTUFOX09OTFkgICAgICA9IDI7XG4vL3ZhciBaX1JMRSAgICAgICAgICAgICAgID0gMztcbnZhciBaX0ZJWEVEICAgICAgICAgICAgICAgPSA0O1xuLy92YXIgWl9ERUZBVUxUX1NUUkFURUdZICA9IDA7XG5cbi8qIFBvc3NpYmxlIHZhbHVlcyBvZiB0aGUgZGF0YV90eXBlIGZpZWxkICh0aG91Z2ggc2VlIGluZmxhdGUoKSkgKi9cbnZhciBaX0JJTkFSWSAgICAgICAgICAgICAgPSAwO1xudmFyIFpfVEVYVCAgICAgICAgICAgICAgICA9IDE7XG4vL3ZhciBaX0FTQ0lJICAgICAgICAgICAgID0gMTsgLy8gPSBaX1RFWFRcbnZhciBaX1VOS05PV04gICAgICAgICAgICAgPSAyO1xuXG4vKj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbmZ1bmN0aW9uIHplcm8oYnVmKSB7IHZhciBsZW4gPSBidWYubGVuZ3RoOyB3aGlsZSAoLS1sZW4gPj0gMCkgeyBidWZbbGVuXSA9IDA7IH0gfVxuXG4vLyBGcm9tIHp1dGlsLmhcblxudmFyIFNUT1JFRF9CTE9DSyA9IDA7XG52YXIgU1RBVElDX1RSRUVTID0gMTtcbnZhciBEWU5fVFJFRVMgICAgPSAyO1xuLyogVGhlIHRocmVlIGtpbmRzIG9mIGJsb2NrIHR5cGUgKi9cblxudmFyIE1JTl9NQVRDSCAgICA9IDM7XG52YXIgTUFYX01BVENIICAgID0gMjU4O1xuLyogVGhlIG1pbmltdW0gYW5kIG1heGltdW0gbWF0Y2ggbGVuZ3RocyAqL1xuXG4vLyBGcm9tIGRlZmxhdGUuaFxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbnRlcm5hbCBjb21wcmVzc2lvbiBzdGF0ZS5cbiAqL1xuXG52YXIgTEVOR1RIX0NPREVTICA9IDI5O1xuLyogbnVtYmVyIG9mIGxlbmd0aCBjb2Rlcywgbm90IGNvdW50aW5nIHRoZSBzcGVjaWFsIEVORF9CTE9DSyBjb2RlICovXG5cbnZhciBMSVRFUkFMUyAgICAgID0gMjU2O1xuLyogbnVtYmVyIG9mIGxpdGVyYWwgYnl0ZXMgMC4uMjU1ICovXG5cbnZhciBMX0NPREVTICAgICAgID0gTElURVJBTFMgKyAxICsgTEVOR1RIX0NPREVTO1xuLyogbnVtYmVyIG9mIExpdGVyYWwgb3IgTGVuZ3RoIGNvZGVzLCBpbmNsdWRpbmcgdGhlIEVORF9CTE9DSyBjb2RlICovXG5cbnZhciBEX0NPREVTICAgICAgID0gMzA7XG4vKiBudW1iZXIgb2YgZGlzdGFuY2UgY29kZXMgKi9cblxudmFyIEJMX0NPREVTICAgICAgPSAxOTtcbi8qIG51bWJlciBvZiBjb2RlcyB1c2VkIHRvIHRyYW5zZmVyIHRoZSBiaXQgbGVuZ3RocyAqL1xuXG52YXIgSEVBUF9TSVpFICAgICA9IDIgKiBMX0NPREVTICsgMTtcbi8qIG1heGltdW0gaGVhcCBzaXplICovXG5cbnZhciBNQVhfQklUUyAgICAgID0gMTU7XG4vKiBBbGwgY29kZXMgbXVzdCBub3QgZXhjZWVkIE1BWF9CSVRTIGJpdHMgKi9cblxudmFyIEJ1Zl9zaXplICAgICAgPSAxNjtcbi8qIHNpemUgb2YgYml0IGJ1ZmZlciBpbiBiaV9idWYgKi9cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbnN0YW50c1xuICovXG5cbnZhciBNQVhfQkxfQklUUyA9IDc7XG4vKiBCaXQgbGVuZ3RoIGNvZGVzIG11c3Qgbm90IGV4Y2VlZCBNQVhfQkxfQklUUyBiaXRzICovXG5cbnZhciBFTkRfQkxPQ0sgICA9IDI1Njtcbi8qIGVuZCBvZiBibG9jayBsaXRlcmFsIGNvZGUgKi9cblxudmFyIFJFUF8zXzYgICAgID0gMTY7XG4vKiByZXBlYXQgcHJldmlvdXMgYml0IGxlbmd0aCAzLTYgdGltZXMgKDIgYml0cyBvZiByZXBlYXQgY291bnQpICovXG5cbnZhciBSRVBaXzNfMTAgICA9IDE3O1xuLyogcmVwZWF0IGEgemVybyBsZW5ndGggMy0xMCB0aW1lcyAgKDMgYml0cyBvZiByZXBlYXQgY291bnQpICovXG5cbnZhciBSRVBaXzExXzEzOCA9IDE4O1xuLyogcmVwZWF0IGEgemVybyBsZW5ndGggMTEtMTM4IHRpbWVzICAoNyBiaXRzIG9mIHJlcGVhdCBjb3VudCkgKi9cblxuLyogZXNsaW50LWRpc2FibGUgY29tbWEtc3BhY2luZyxhcnJheS1icmFja2V0LXNwYWNpbmcgKi9cbnZhciBleHRyYV9sYml0cyA9ICAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBsZW5ndGggY29kZSAqL1xuICBbMCwwLDAsMCwwLDAsMCwwLDEsMSwxLDEsMiwyLDIsMiwzLDMsMywzLDQsNCw0LDQsNSw1LDUsNSwwXTtcblxudmFyIGV4dHJhX2RiaXRzID0gICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGRpc3RhbmNlIGNvZGUgKi9cbiAgWzAsMCwwLDAsMSwxLDIsMiwzLDMsNCw0LDUsNSw2LDYsNyw3LDgsOCw5LDksMTAsMTAsMTEsMTEsMTIsMTIsMTMsMTNdO1xuXG52YXIgZXh0cmFfYmxiaXRzID0gIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggYml0IGxlbmd0aCBjb2RlICovXG4gIFswLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDIsMyw3XTtcblxudmFyIGJsX29yZGVyID1cbiAgWzE2LDE3LDE4LDAsOCw3LDksNiwxMCw1LDExLDQsMTIsMywxMywyLDE0LDEsMTVdO1xuLyogZXNsaW50LWVuYWJsZSBjb21tYS1zcGFjaW5nLGFycmF5LWJyYWNrZXQtc3BhY2luZyAqL1xuXG4vKiBUaGUgbGVuZ3RocyBvZiB0aGUgYml0IGxlbmd0aCBjb2RlcyBhcmUgc2VudCBpbiBvcmRlciBvZiBkZWNyZWFzaW5nXG4gKiBwcm9iYWJpbGl0eSwgdG8gYXZvaWQgdHJhbnNtaXR0aW5nIHRoZSBsZW5ndGhzIGZvciB1bnVzZWQgYml0IGxlbmd0aCBjb2Rlcy5cbiAqL1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIExvY2FsIGRhdGEuIFRoZXNlIGFyZSBpbml0aWFsaXplZCBvbmx5IG9uY2UuXG4gKi9cblxuLy8gV2UgcHJlLWZpbGwgYXJyYXlzIHdpdGggMCB0byBhdm9pZCB1bmluaXRpYWxpemVkIGdhcHNcblxudmFyIERJU1RfQ09ERV9MRU4gPSA1MTI7IC8qIHNlZSBkZWZpbml0aW9uIG9mIGFycmF5IGRpc3RfY29kZSBiZWxvdyAqL1xuXG4vLyAhISEhIFVzZSBmbGF0IGFycmF5IGluc2RlYWQgb2Ygc3RydWN0dXJlLCBGcmVxID0gaSoyLCBMZW4gPSBpKjIrMVxudmFyIHN0YXRpY19sdHJlZSAgPSBuZXcgQXJyYXkoKExfQ09ERVMgKyAyKSAqIDIpO1xuemVybyhzdGF0aWNfbHRyZWUpO1xuLyogVGhlIHN0YXRpYyBsaXRlcmFsIHRyZWUuIFNpbmNlIHRoZSBiaXQgbGVuZ3RocyBhcmUgaW1wb3NlZCwgdGhlcmUgaXMgbm9cbiAqIG5lZWQgZm9yIHRoZSBMX0NPREVTIGV4dHJhIGNvZGVzIHVzZWQgZHVyaW5nIGhlYXAgY29uc3RydWN0aW9uLiBIb3dldmVyXG4gKiBUaGUgY29kZXMgMjg2IGFuZCAyODcgYXJlIG5lZWRlZCB0byBidWlsZCBhIGNhbm9uaWNhbCB0cmVlIChzZWUgX3RyX2luaXRcbiAqIGJlbG93KS5cbiAqL1xuXG52YXIgc3RhdGljX2R0cmVlICA9IG5ldyBBcnJheShEX0NPREVTICogMik7XG56ZXJvKHN0YXRpY19kdHJlZSk7XG4vKiBUaGUgc3RhdGljIGRpc3RhbmNlIHRyZWUuIChBY3R1YWxseSBhIHRyaXZpYWwgdHJlZSBzaW5jZSBhbGwgY29kZXMgdXNlXG4gKiA1IGJpdHMuKVxuICovXG5cbnZhciBfZGlzdF9jb2RlICAgID0gbmV3IEFycmF5KERJU1RfQ09ERV9MRU4pO1xuemVybyhfZGlzdF9jb2RlKTtcbi8qIERpc3RhbmNlIGNvZGVzLiBUaGUgZmlyc3QgMjU2IHZhbHVlcyBjb3JyZXNwb25kIHRvIHRoZSBkaXN0YW5jZXNcbiAqIDMgLi4gMjU4LCB0aGUgbGFzdCAyNTYgdmFsdWVzIGNvcnJlc3BvbmQgdG8gdGhlIHRvcCA4IGJpdHMgb2ZcbiAqIHRoZSAxNSBiaXQgZGlzdGFuY2VzLlxuICovXG5cbnZhciBfbGVuZ3RoX2NvZGUgID0gbmV3IEFycmF5KE1BWF9NQVRDSCAtIE1JTl9NQVRDSCArIDEpO1xuemVybyhfbGVuZ3RoX2NvZGUpO1xuLyogbGVuZ3RoIGNvZGUgZm9yIGVhY2ggbm9ybWFsaXplZCBtYXRjaCBsZW5ndGggKDAgPT0gTUlOX01BVENIKSAqL1xuXG52YXIgYmFzZV9sZW5ndGggICA9IG5ldyBBcnJheShMRU5HVEhfQ09ERVMpO1xuemVybyhiYXNlX2xlbmd0aCk7XG4vKiBGaXJzdCBub3JtYWxpemVkIGxlbmd0aCBmb3IgZWFjaCBjb2RlICgwID0gTUlOX01BVENIKSAqL1xuXG52YXIgYmFzZV9kaXN0ICAgICA9IG5ldyBBcnJheShEX0NPREVTKTtcbnplcm8oYmFzZV9kaXN0KTtcbi8qIEZpcnN0IG5vcm1hbGl6ZWQgZGlzdGFuY2UgZm9yIGVhY2ggY29kZSAoMCA9IGRpc3RhbmNlIG9mIDEpICovXG5cblxuZnVuY3Rpb24gU3RhdGljVHJlZURlc2Moc3RhdGljX3RyZWUsIGV4dHJhX2JpdHMsIGV4dHJhX2Jhc2UsIGVsZW1zLCBtYXhfbGVuZ3RoKSB7XG5cbiAgdGhpcy5zdGF0aWNfdHJlZSAgPSBzdGF0aWNfdHJlZTsgIC8qIHN0YXRpYyB0cmVlIG9yIE5VTEwgKi9cbiAgdGhpcy5leHRyYV9iaXRzICAgPSBleHRyYV9iaXRzOyAgIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggY29kZSBvciBOVUxMICovXG4gIHRoaXMuZXh0cmFfYmFzZSAgID0gZXh0cmFfYmFzZTsgICAvKiBiYXNlIGluZGV4IGZvciBleHRyYV9iaXRzICovXG4gIHRoaXMuZWxlbXMgICAgICAgID0gZWxlbXM7ICAgICAgICAvKiBtYXggbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSB0cmVlICovXG4gIHRoaXMubWF4X2xlbmd0aCAgID0gbWF4X2xlbmd0aDsgICAvKiBtYXggYml0IGxlbmd0aCBmb3IgdGhlIGNvZGVzICovXG5cbiAgLy8gc2hvdyBpZiBgc3RhdGljX3RyZWVgIGhhcyBkYXRhIG9yIGR1bW15IC0gbmVlZGVkIGZvciBtb25vbW9ycGhpYyBvYmplY3RzXG4gIHRoaXMuaGFzX3N0cmVlICAgID0gc3RhdGljX3RyZWUgJiYgc3RhdGljX3RyZWUubGVuZ3RoO1xufVxuXG5cbnZhciBzdGF0aWNfbF9kZXNjO1xudmFyIHN0YXRpY19kX2Rlc2M7XG52YXIgc3RhdGljX2JsX2Rlc2M7XG5cblxuZnVuY3Rpb24gVHJlZURlc2MoZHluX3RyZWUsIHN0YXRfZGVzYykge1xuICB0aGlzLmR5bl90cmVlID0gZHluX3RyZWU7ICAgICAvKiB0aGUgZHluYW1pYyB0cmVlICovXG4gIHRoaXMubWF4X2NvZGUgPSAwOyAgICAgICAgICAgIC8qIGxhcmdlc3QgY29kZSB3aXRoIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xuICB0aGlzLnN0YXRfZGVzYyA9IHN0YXRfZGVzYzsgICAvKiB0aGUgY29ycmVzcG9uZGluZyBzdGF0aWMgdHJlZSAqL1xufVxuXG5cblxuZnVuY3Rpb24gZF9jb2RlKGRpc3QpIHtcbiAgcmV0dXJuIGRpc3QgPCAyNTYgPyBfZGlzdF9jb2RlW2Rpc3RdIDogX2Rpc3RfY29kZVsyNTYgKyAoZGlzdCA+Pj4gNyldO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogT3V0cHV0IGEgc2hvcnQgTFNCIGZpcnN0IG9uIHRoZSBzdHJlYW0uXG4gKiBJTiBhc3NlcnRpb246IHRoZXJlIGlzIGVub3VnaCByb29tIGluIHBlbmRpbmdCdWYuXG4gKi9cbmZ1bmN0aW9uIHB1dF9zaG9ydChzLCB3KSB7XG4vLyAgICBwdXRfYnl0ZShzLCAodWNoKSgodykgJiAweGZmKSk7XG4vLyAgICBwdXRfYnl0ZShzLCAodWNoKSgodXNoKSh3KSA+PiA4KSk7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gKHcpICYgMHhmZjtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSAodyA+Pj4gOCkgJiAweGZmO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBhIHZhbHVlIG9uIGEgZ2l2ZW4gbnVtYmVyIG9mIGJpdHMuXG4gKiBJTiBhc3NlcnRpb246IGxlbmd0aCA8PSAxNiBhbmQgdmFsdWUgZml0cyBpbiBsZW5ndGggYml0cy5cbiAqL1xuZnVuY3Rpb24gc2VuZF9iaXRzKHMsIHZhbHVlLCBsZW5ndGgpIHtcbiAgaWYgKHMuYmlfdmFsaWQgPiAoQnVmX3NpemUgLSBsZW5ndGgpKSB7XG4gICAgcy5iaV9idWYgfD0gKHZhbHVlIDw8IHMuYmlfdmFsaWQpICYgMHhmZmZmO1xuICAgIHB1dF9zaG9ydChzLCBzLmJpX2J1Zik7XG4gICAgcy5iaV9idWYgPSB2YWx1ZSA+PiAoQnVmX3NpemUgLSBzLmJpX3ZhbGlkKTtcbiAgICBzLmJpX3ZhbGlkICs9IGxlbmd0aCAtIEJ1Zl9zaXplO1xuICB9IGVsc2Uge1xuICAgIHMuYmlfYnVmIHw9ICh2YWx1ZSA8PCBzLmJpX3ZhbGlkKSAmIDB4ZmZmZjtcbiAgICBzLmJpX3ZhbGlkICs9IGxlbmd0aDtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHNlbmRfY29kZShzLCBjLCB0cmVlKSB7XG4gIHNlbmRfYml0cyhzLCB0cmVlW2MgKiAyXS8qLkNvZGUqLywgdHJlZVtjICogMiArIDFdLyouTGVuKi8pO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUmV2ZXJzZSB0aGUgZmlyc3QgbGVuIGJpdHMgb2YgYSBjb2RlLCB1c2luZyBzdHJhaWdodGZvcndhcmQgY29kZSAoYSBmYXN0ZXJcbiAqIG1ldGhvZCB3b3VsZCB1c2UgYSB0YWJsZSlcbiAqIElOIGFzc2VydGlvbjogMSA8PSBsZW4gPD0gMTVcbiAqL1xuZnVuY3Rpb24gYmlfcmV2ZXJzZShjb2RlLCBsZW4pIHtcbiAgdmFyIHJlcyA9IDA7XG4gIGRvIHtcbiAgICByZXMgfD0gY29kZSAmIDE7XG4gICAgY29kZSA+Pj49IDE7XG4gICAgcmVzIDw8PSAxO1xuICB9IHdoaWxlICgtLWxlbiA+IDApO1xuICByZXR1cm4gcmVzID4+PiAxO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmx1c2ggdGhlIGJpdCBidWZmZXIsIGtlZXBpbmcgYXQgbW9zdCA3IGJpdHMgaW4gaXQuXG4gKi9cbmZ1bmN0aW9uIGJpX2ZsdXNoKHMpIHtcbiAgaWYgKHMuYmlfdmFsaWQgPT09IDE2KSB7XG4gICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTtcbiAgICBzLmJpX2J1ZiA9IDA7XG4gICAgcy5iaV92YWxpZCA9IDA7XG5cbiAgfSBlbHNlIGlmIChzLmJpX3ZhbGlkID49IDgpIHtcbiAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IHMuYmlfYnVmICYgMHhmZjtcbiAgICBzLmJpX2J1ZiA+Pj0gODtcbiAgICBzLmJpX3ZhbGlkIC09IDg7XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbXB1dGUgdGhlIG9wdGltYWwgYml0IGxlbmd0aHMgZm9yIGEgdHJlZSBhbmQgdXBkYXRlIHRoZSB0b3RhbCBiaXQgbGVuZ3RoXG4gKiBmb3IgdGhlIGN1cnJlbnQgYmxvY2suXG4gKiBJTiBhc3NlcnRpb246IHRoZSBmaWVsZHMgZnJlcSBhbmQgZGFkIGFyZSBzZXQsIGhlYXBbaGVhcF9tYXhdIGFuZFxuICogICAgYWJvdmUgYXJlIHRoZSB0cmVlIG5vZGVzIHNvcnRlZCBieSBpbmNyZWFzaW5nIGZyZXF1ZW5jeS5cbiAqIE9VVCBhc3NlcnRpb25zOiB0aGUgZmllbGQgbGVuIGlzIHNldCB0byB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RoLCB0aGVcbiAqICAgICBhcnJheSBibF9jb3VudCBjb250YWlucyB0aGUgZnJlcXVlbmNpZXMgZm9yIGVhY2ggYml0IGxlbmd0aC5cbiAqICAgICBUaGUgbGVuZ3RoIG9wdF9sZW4gaXMgdXBkYXRlZDsgc3RhdGljX2xlbiBpcyBhbHNvIHVwZGF0ZWQgaWYgc3RyZWUgaXNcbiAqICAgICBub3QgbnVsbC5cbiAqL1xuZnVuY3Rpb24gZ2VuX2JpdGxlbihzLCBkZXNjKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIHRyZWVfZGVzYyAqZGVzYzsgICAgLyogdGhlIHRyZWUgZGVzY3JpcHRvciAqL1xue1xuICB2YXIgdHJlZSAgICAgICAgICAgID0gZGVzYy5keW5fdHJlZTtcbiAgdmFyIG1heF9jb2RlICAgICAgICA9IGRlc2MubWF4X2NvZGU7XG4gIHZhciBzdHJlZSAgICAgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5zdGF0aWNfdHJlZTtcbiAgdmFyIGhhc19zdHJlZSAgICAgICA9IGRlc2Muc3RhdF9kZXNjLmhhc19zdHJlZTtcbiAgdmFyIGV4dHJhICAgICAgICAgICA9IGRlc2Muc3RhdF9kZXNjLmV4dHJhX2JpdHM7XG4gIHZhciBiYXNlICAgICAgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5leHRyYV9iYXNlO1xuICB2YXIgbWF4X2xlbmd0aCAgICAgID0gZGVzYy5zdGF0X2Rlc2MubWF4X2xlbmd0aDtcbiAgdmFyIGg7ICAgICAgICAgICAgICAvKiBoZWFwIGluZGV4ICovXG4gIHZhciBuLCBtOyAgICAgICAgICAgLyogaXRlcmF0ZSBvdmVyIHRoZSB0cmVlIGVsZW1lbnRzICovXG4gIHZhciBiaXRzOyAgICAgICAgICAgLyogYml0IGxlbmd0aCAqL1xuICB2YXIgeGJpdHM7ICAgICAgICAgIC8qIGV4dHJhIGJpdHMgKi9cbiAgdmFyIGY7ICAgICAgICAgICAgICAvKiBmcmVxdWVuY3kgKi9cbiAgdmFyIG92ZXJmbG93ID0gMDsgICAvKiBudW1iZXIgb2YgZWxlbWVudHMgd2l0aCBiaXQgbGVuZ3RoIHRvbyBsYXJnZSAqL1xuXG4gIGZvciAoYml0cyA9IDA7IGJpdHMgPD0gTUFYX0JJVFM7IGJpdHMrKykge1xuICAgIHMuYmxfY291bnRbYml0c10gPSAwO1xuICB9XG5cbiAgLyogSW4gYSBmaXJzdCBwYXNzLCBjb21wdXRlIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGhzICh3aGljaCBtYXlcbiAgICogb3ZlcmZsb3cgaW4gdGhlIGNhc2Ugb2YgdGhlIGJpdCBsZW5ndGggdHJlZSkuXG4gICAqL1xuICB0cmVlW3MuaGVhcFtzLmhlYXBfbWF4XSAqIDIgKyAxXS8qLkxlbiovID0gMDsgLyogcm9vdCBvZiB0aGUgaGVhcCAqL1xuXG4gIGZvciAoaCA9IHMuaGVhcF9tYXggKyAxOyBoIDwgSEVBUF9TSVpFOyBoKyspIHtcbiAgICBuID0gcy5oZWFwW2hdO1xuICAgIGJpdHMgPSB0cmVlW3RyZWVbbiAqIDIgKyAxXS8qLkRhZCovICogMiArIDFdLyouTGVuKi8gKyAxO1xuICAgIGlmIChiaXRzID4gbWF4X2xlbmd0aCkge1xuICAgICAgYml0cyA9IG1heF9sZW5ndGg7XG4gICAgICBvdmVyZmxvdysrO1xuICAgIH1cbiAgICB0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IGJpdHM7XG4gICAgLyogV2Ugb3ZlcndyaXRlIHRyZWVbbl0uRGFkIHdoaWNoIGlzIG5vIGxvbmdlciBuZWVkZWQgKi9cblxuICAgIGlmIChuID4gbWF4X2NvZGUpIHsgY29udGludWU7IH0gLyogbm90IGEgbGVhZiBub2RlICovXG5cbiAgICBzLmJsX2NvdW50W2JpdHNdKys7XG4gICAgeGJpdHMgPSAwO1xuICAgIGlmIChuID49IGJhc2UpIHtcbiAgICAgIHhiaXRzID0gZXh0cmFbbiAtIGJhc2VdO1xuICAgIH1cbiAgICBmID0gdHJlZVtuICogMl0vKi5GcmVxKi87XG4gICAgcy5vcHRfbGVuICs9IGYgKiAoYml0cyArIHhiaXRzKTtcbiAgICBpZiAoaGFzX3N0cmVlKSB7XG4gICAgICBzLnN0YXRpY19sZW4gKz0gZiAqIChzdHJlZVtuICogMiArIDFdLyouTGVuKi8gKyB4Yml0cyk7XG4gICAgfVxuICB9XG4gIGlmIChvdmVyZmxvdyA9PT0gMCkgeyByZXR1cm47IH1cblxuICAvLyBUcmFjZSgoc3RkZXJyLFwiXFxuYml0IGxlbmd0aCBvdmVyZmxvd1xcblwiKSk7XG4gIC8qIFRoaXMgaGFwcGVucyBmb3IgZXhhbXBsZSBvbiBvYmoyIGFuZCBwaWMgb2YgdGhlIENhbGdhcnkgY29ycHVzICovXG5cbiAgLyogRmluZCB0aGUgZmlyc3QgYml0IGxlbmd0aCB3aGljaCBjb3VsZCBpbmNyZWFzZTogKi9cbiAgZG8ge1xuICAgIGJpdHMgPSBtYXhfbGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAocy5ibF9jb3VudFtiaXRzXSA9PT0gMCkgeyBiaXRzLS07IH1cbiAgICBzLmJsX2NvdW50W2JpdHNdLS07ICAgICAgLyogbW92ZSBvbmUgbGVhZiBkb3duIHRoZSB0cmVlICovXG4gICAgcy5ibF9jb3VudFtiaXRzICsgMV0gKz0gMjsgLyogbW92ZSBvbmUgb3ZlcmZsb3cgaXRlbSBhcyBpdHMgYnJvdGhlciAqL1xuICAgIHMuYmxfY291bnRbbWF4X2xlbmd0aF0tLTtcbiAgICAvKiBUaGUgYnJvdGhlciBvZiB0aGUgb3ZlcmZsb3cgaXRlbSBhbHNvIG1vdmVzIG9uZSBzdGVwIHVwLFxuICAgICAqIGJ1dCB0aGlzIGRvZXMgbm90IGFmZmVjdCBibF9jb3VudFttYXhfbGVuZ3RoXVxuICAgICAqL1xuICAgIG92ZXJmbG93IC09IDI7XG4gIH0gd2hpbGUgKG92ZXJmbG93ID4gMCk7XG5cbiAgLyogTm93IHJlY29tcHV0ZSBhbGwgYml0IGxlbmd0aHMsIHNjYW5uaW5nIGluIGluY3JlYXNpbmcgZnJlcXVlbmN5LlxuICAgKiBoIGlzIHN0aWxsIGVxdWFsIHRvIEhFQVBfU0laRS4gKEl0IGlzIHNpbXBsZXIgdG8gcmVjb25zdHJ1Y3QgYWxsXG4gICAqIGxlbmd0aHMgaW5zdGVhZCBvZiBmaXhpbmcgb25seSB0aGUgd3Jvbmcgb25lcy4gVGhpcyBpZGVhIGlzIHRha2VuXG4gICAqIGZyb20gJ2FyJyB3cml0dGVuIGJ5IEhhcnVoaWtvIE9rdW11cmEuKVxuICAgKi9cbiAgZm9yIChiaXRzID0gbWF4X2xlbmd0aDsgYml0cyAhPT0gMDsgYml0cy0tKSB7XG4gICAgbiA9IHMuYmxfY291bnRbYml0c107XG4gICAgd2hpbGUgKG4gIT09IDApIHtcbiAgICAgIG0gPSBzLmhlYXBbLS1oXTtcbiAgICAgIGlmIChtID4gbWF4X2NvZGUpIHsgY29udGludWU7IH1cbiAgICAgIGlmICh0cmVlW20gKiAyICsgMV0vKi5MZW4qLyAhPT0gYml0cykge1xuICAgICAgICAvLyBUcmFjZSgoc3RkZXJyLFwiY29kZSAlZCBiaXRzICVkLT4lZFxcblwiLCBtLCB0cmVlW21dLkxlbiwgYml0cykpO1xuICAgICAgICBzLm9wdF9sZW4gKz0gKGJpdHMgLSB0cmVlW20gKiAyICsgMV0vKi5MZW4qLykgKiB0cmVlW20gKiAyXS8qLkZyZXEqLztcbiAgICAgICAgdHJlZVttICogMiArIDFdLyouTGVuKi8gPSBiaXRzO1xuICAgICAgfVxuICAgICAgbi0tO1xuICAgIH1cbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogR2VuZXJhdGUgdGhlIGNvZGVzIGZvciBhIGdpdmVuIHRyZWUgYW5kIGJpdCBjb3VudHMgKHdoaWNoIG5lZWQgbm90IGJlXG4gKiBvcHRpbWFsKS5cbiAqIElOIGFzc2VydGlvbjogdGhlIGFycmF5IGJsX2NvdW50IGNvbnRhaW5zIHRoZSBiaXQgbGVuZ3RoIHN0YXRpc3RpY3MgZm9yXG4gKiB0aGUgZ2l2ZW4gdHJlZSBhbmQgdGhlIGZpZWxkIGxlbiBpcyBzZXQgZm9yIGFsbCB0cmVlIGVsZW1lbnRzLlxuICogT1VUIGFzc2VydGlvbjogdGhlIGZpZWxkIGNvZGUgaXMgc2V0IGZvciBhbGwgdHJlZSBlbGVtZW50cyBvZiBub25cbiAqICAgICB6ZXJvIGNvZGUgbGVuZ3RoLlxuICovXG5mdW5jdGlvbiBnZW5fY29kZXModHJlZSwgbWF4X2NvZGUsIGJsX2NvdW50KVxuLy8gICAgY3RfZGF0YSAqdHJlZTsgICAgICAgICAgICAgLyogdGhlIHRyZWUgdG8gZGVjb3JhdGUgKi9cbi8vICAgIGludCBtYXhfY29kZTsgICAgICAgICAgICAgIC8qIGxhcmdlc3QgY29kZSB3aXRoIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xuLy8gICAgdXNoZiAqYmxfY291bnQ7ICAgICAgICAgICAgLyogbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aCAqL1xue1xuICB2YXIgbmV4dF9jb2RlID0gbmV3IEFycmF5KE1BWF9CSVRTICsgMSk7IC8qIG5leHQgY29kZSB2YWx1ZSBmb3IgZWFjaCBiaXQgbGVuZ3RoICovXG4gIHZhciBjb2RlID0gMDsgICAgICAgICAgICAgIC8qIHJ1bm5pbmcgY29kZSB2YWx1ZSAqL1xuICB2YXIgYml0czsgICAgICAgICAgICAgICAgICAvKiBiaXQgaW5kZXggKi9cbiAgdmFyIG47ICAgICAgICAgICAgICAgICAgICAgLyogY29kZSBpbmRleCAqL1xuXG4gIC8qIFRoZSBkaXN0cmlidXRpb24gY291bnRzIGFyZSBmaXJzdCB1c2VkIHRvIGdlbmVyYXRlIHRoZSBjb2RlIHZhbHVlc1xuICAgKiB3aXRob3V0IGJpdCByZXZlcnNhbC5cbiAgICovXG4gIGZvciAoYml0cyA9IDE7IGJpdHMgPD0gTUFYX0JJVFM7IGJpdHMrKykge1xuICAgIG5leHRfY29kZVtiaXRzXSA9IGNvZGUgPSAoY29kZSArIGJsX2NvdW50W2JpdHMgLSAxXSkgPDwgMTtcbiAgfVxuICAvKiBDaGVjayB0aGF0IHRoZSBiaXQgY291bnRzIGluIGJsX2NvdW50IGFyZSBjb25zaXN0ZW50LiBUaGUgbGFzdCBjb2RlXG4gICAqIG11c3QgYmUgYWxsIG9uZXMuXG4gICAqL1xuICAvL0Fzc2VydCAoY29kZSArIGJsX2NvdW50W01BWF9CSVRTXS0xID09ICgxPDxNQVhfQklUUyktMSxcbiAgLy8gICAgICAgIFwiaW5jb25zaXN0ZW50IGJpdCBjb3VudHNcIik7XG4gIC8vVHJhY2V2KChzdGRlcnIsXCJcXG5nZW5fY29kZXM6IG1heF9jb2RlICVkIFwiLCBtYXhfY29kZSkpO1xuXG4gIGZvciAobiA9IDA7ICBuIDw9IG1heF9jb2RlOyBuKyspIHtcbiAgICB2YXIgbGVuID0gdHJlZVtuICogMiArIDFdLyouTGVuKi87XG4gICAgaWYgKGxlbiA9PT0gMCkgeyBjb250aW51ZTsgfVxuICAgIC8qIE5vdyByZXZlcnNlIHRoZSBiaXRzICovXG4gICAgdHJlZVtuICogMl0vKi5Db2RlKi8gPSBiaV9yZXZlcnNlKG5leHRfY29kZVtsZW5dKyssIGxlbik7XG5cbiAgICAvL1RyYWNlY3YodHJlZSAhPSBzdGF0aWNfbHRyZWUsIChzdGRlcnIsXCJcXG5uICUzZCAlYyBsICUyZCBjICU0eCAoJXgpIFwiLFxuICAgIC8vICAgICBuLCAoaXNncmFwaChuKSA/IG4gOiAnICcpLCBsZW4sIHRyZWVbbl0uQ29kZSwgbmV4dF9jb2RlW2xlbl0tMSkpO1xuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIHRoZSB2YXJpb3VzICdjb25zdGFudCcgdGFibGVzLlxuICovXG5mdW5jdGlvbiB0cl9zdGF0aWNfaW5pdCgpIHtcbiAgdmFyIG47ICAgICAgICAvKiBpdGVyYXRlcyBvdmVyIHRyZWUgZWxlbWVudHMgKi9cbiAgdmFyIGJpdHM7ICAgICAvKiBiaXQgY291bnRlciAqL1xuICB2YXIgbGVuZ3RoOyAgIC8qIGxlbmd0aCB2YWx1ZSAqL1xuICB2YXIgY29kZTsgICAgIC8qIGNvZGUgdmFsdWUgKi9cbiAgdmFyIGRpc3Q7ICAgICAvKiBkaXN0YW5jZSBpbmRleCAqL1xuICB2YXIgYmxfY291bnQgPSBuZXcgQXJyYXkoTUFYX0JJVFMgKyAxKTtcbiAgLyogbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aCBmb3IgYW4gb3B0aW1hbCB0cmVlICovXG5cbiAgLy8gZG8gY2hlY2sgaW4gX3RyX2luaXQoKVxuICAvL2lmIChzdGF0aWNfaW5pdF9kb25lKSByZXR1cm47XG5cbiAgLyogRm9yIHNvbWUgZW1iZWRkZWQgdGFyZ2V0cywgZ2xvYmFsIHZhcmlhYmxlcyBhcmUgbm90IGluaXRpYWxpemVkOiAqL1xuLyojaWZkZWYgTk9fSU5JVF9HTE9CQUxfUE9JTlRFUlNcbiAgc3RhdGljX2xfZGVzYy5zdGF0aWNfdHJlZSA9IHN0YXRpY19sdHJlZTtcbiAgc3RhdGljX2xfZGVzYy5leHRyYV9iaXRzID0gZXh0cmFfbGJpdHM7XG4gIHN0YXRpY19kX2Rlc2Muc3RhdGljX3RyZWUgPSBzdGF0aWNfZHRyZWU7XG4gIHN0YXRpY19kX2Rlc2MuZXh0cmFfYml0cyA9IGV4dHJhX2RiaXRzO1xuICBzdGF0aWNfYmxfZGVzYy5leHRyYV9iaXRzID0gZXh0cmFfYmxiaXRzO1xuI2VuZGlmKi9cblxuICAvKiBJbml0aWFsaXplIHRoZSBtYXBwaW5nIGxlbmd0aCAoMC4uMjU1KSAtPiBsZW5ndGggY29kZSAoMC4uMjgpICovXG4gIGxlbmd0aCA9IDA7XG4gIGZvciAoY29kZSA9IDA7IGNvZGUgPCBMRU5HVEhfQ09ERVMgLSAxOyBjb2RlKyspIHtcbiAgICBiYXNlX2xlbmd0aFtjb2RlXSA9IGxlbmd0aDtcbiAgICBmb3IgKG4gPSAwOyBuIDwgKDEgPDwgZXh0cmFfbGJpdHNbY29kZV0pOyBuKyspIHtcbiAgICAgIF9sZW5ndGhfY29kZVtsZW5ndGgrK10gPSBjb2RlO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAobGVuZ3RoID09IDI1NiwgXCJ0cl9zdGF0aWNfaW5pdDogbGVuZ3RoICE9IDI1NlwiKTtcbiAgLyogTm90ZSB0aGF0IHRoZSBsZW5ndGggMjU1IChtYXRjaCBsZW5ndGggMjU4KSBjYW4gYmUgcmVwcmVzZW50ZWRcbiAgICogaW4gdHdvIGRpZmZlcmVudCB3YXlzOiBjb2RlIDI4NCArIDUgYml0cyBvciBjb2RlIDI4NSwgc28gd2VcbiAgICogb3ZlcndyaXRlIGxlbmd0aF9jb2RlWzI1NV0gdG8gdXNlIHRoZSBiZXN0IGVuY29kaW5nOlxuICAgKi9cbiAgX2xlbmd0aF9jb2RlW2xlbmd0aCAtIDFdID0gY29kZTtcblxuICAvKiBJbml0aWFsaXplIHRoZSBtYXBwaW5nIGRpc3QgKDAuLjMySykgLT4gZGlzdCBjb2RlICgwLi4yOSkgKi9cbiAgZGlzdCA9IDA7XG4gIGZvciAoY29kZSA9IDA7IGNvZGUgPCAxNjsgY29kZSsrKSB7XG4gICAgYmFzZV9kaXN0W2NvZGVdID0gZGlzdDtcbiAgICBmb3IgKG4gPSAwOyBuIDwgKDEgPDwgZXh0cmFfZGJpdHNbY29kZV0pOyBuKyspIHtcbiAgICAgIF9kaXN0X2NvZGVbZGlzdCsrXSA9IGNvZGU7XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChkaXN0ID09IDI1NiwgXCJ0cl9zdGF0aWNfaW5pdDogZGlzdCAhPSAyNTZcIik7XG4gIGRpc3QgPj49IDc7IC8qIGZyb20gbm93IG9uLCBhbGwgZGlzdGFuY2VzIGFyZSBkaXZpZGVkIGJ5IDEyOCAqL1xuICBmb3IgKDsgY29kZSA8IERfQ09ERVM7IGNvZGUrKykge1xuICAgIGJhc2VfZGlzdFtjb2RlXSA9IGRpc3QgPDwgNztcbiAgICBmb3IgKG4gPSAwOyBuIDwgKDEgPDwgKGV4dHJhX2RiaXRzW2NvZGVdIC0gNykpOyBuKyspIHtcbiAgICAgIF9kaXN0X2NvZGVbMjU2ICsgZGlzdCsrXSA9IGNvZGU7XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChkaXN0ID09IDI1NiwgXCJ0cl9zdGF0aWNfaW5pdDogMjU2K2Rpc3QgIT0gNTEyXCIpO1xuXG4gIC8qIENvbnN0cnVjdCB0aGUgY29kZXMgb2YgdGhlIHN0YXRpYyBsaXRlcmFsIHRyZWUgKi9cbiAgZm9yIChiaXRzID0gMDsgYml0cyA8PSBNQVhfQklUUzsgYml0cysrKSB7XG4gICAgYmxfY291bnRbYml0c10gPSAwO1xuICB9XG5cbiAgbiA9IDA7XG4gIHdoaWxlIChuIDw9IDE0Mykge1xuICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA4O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs4XSsrO1xuICB9XG4gIHdoaWxlIChuIDw9IDI1NSkge1xuICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA5O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs5XSsrO1xuICB9XG4gIHdoaWxlIChuIDw9IDI3OSkge1xuICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA3O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs3XSsrO1xuICB9XG4gIHdoaWxlIChuIDw9IDI4Nykge1xuICAgIHN0YXRpY19sdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA4O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs4XSsrO1xuICB9XG4gIC8qIENvZGVzIDI4NiBhbmQgMjg3IGRvIG5vdCBleGlzdCwgYnV0IHdlIG11c3QgaW5jbHVkZSB0aGVtIGluIHRoZVxuICAgKiB0cmVlIGNvbnN0cnVjdGlvbiB0byBnZXQgYSBjYW5vbmljYWwgSHVmZm1hbiB0cmVlIChsb25nZXN0IGNvZGVcbiAgICogYWxsIG9uZXMpXG4gICAqL1xuICBnZW5fY29kZXMoc3RhdGljX2x0cmVlLCBMX0NPREVTICsgMSwgYmxfY291bnQpO1xuXG4gIC8qIFRoZSBzdGF0aWMgZGlzdGFuY2UgdHJlZSBpcyB0cml2aWFsOiAqL1xuICBmb3IgKG4gPSAwOyBuIDwgRF9DT0RFUzsgbisrKSB7XG4gICAgc3RhdGljX2R0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDU7XG4gICAgc3RhdGljX2R0cmVlW24gKiAyXS8qLkNvZGUqLyA9IGJpX3JldmVyc2UobiwgNSk7XG4gIH1cblxuICAvLyBOb3cgZGF0YSByZWFkeSBhbmQgd2UgY2FuIGluaXQgc3RhdGljIHRyZWVzXG4gIHN0YXRpY19sX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2Moc3RhdGljX2x0cmVlLCBleHRyYV9sYml0cywgTElURVJBTFMgKyAxLCBMX0NPREVTLCBNQVhfQklUUyk7XG4gIHN0YXRpY19kX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2Moc3RhdGljX2R0cmVlLCBleHRyYV9kYml0cywgMCwgICAgICAgICAgRF9DT0RFUywgTUFYX0JJVFMpO1xuICBzdGF0aWNfYmxfZGVzYyA9IG5ldyBTdGF0aWNUcmVlRGVzYyhuZXcgQXJyYXkoMCksIGV4dHJhX2JsYml0cywgMCwgICAgICAgICBCTF9DT0RFUywgTUFYX0JMX0JJVFMpO1xuXG4gIC8vc3RhdGljX2luaXRfZG9uZSA9IHRydWU7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIGEgbmV3IGJsb2NrLlxuICovXG5mdW5jdGlvbiBpbml0X2Jsb2NrKHMpIHtcbiAgdmFyIG47IC8qIGl0ZXJhdGVzIG92ZXIgdHJlZSBlbGVtZW50cyAqL1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIHRyZWVzLiAqL1xuICBmb3IgKG4gPSAwOyBuIDwgTF9DT0RFUzsgIG4rKykgeyBzLmR5bl9sdHJlZVtuICogMl0vKi5GcmVxKi8gPSAwOyB9XG4gIGZvciAobiA9IDA7IG4gPCBEX0NPREVTOyAgbisrKSB7IHMuZHluX2R0cmVlW24gKiAyXS8qLkZyZXEqLyA9IDA7IH1cbiAgZm9yIChuID0gMDsgbiA8IEJMX0NPREVTOyBuKyspIHsgcy5ibF90cmVlW24gKiAyXS8qLkZyZXEqLyA9IDA7IH1cblxuICBzLmR5bl9sdHJlZVtFTkRfQkxPQ0sgKiAyXS8qLkZyZXEqLyA9IDE7XG4gIHMub3B0X2xlbiA9IHMuc3RhdGljX2xlbiA9IDA7XG4gIHMubGFzdF9saXQgPSBzLm1hdGNoZXMgPSAwO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmx1c2ggdGhlIGJpdCBidWZmZXIgYW5kIGFsaWduIHRoZSBvdXRwdXQgb24gYSBieXRlIGJvdW5kYXJ5XG4gKi9cbmZ1bmN0aW9uIGJpX3dpbmR1cChzKVxue1xuICBpZiAocy5iaV92YWxpZCA+IDgpIHtcbiAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpO1xuICB9IGVsc2UgaWYgKHMuYmlfdmFsaWQgPiAwKSB7XG4gICAgLy9wdXRfYnl0ZShzLCAoQnl0ZSlzLT5iaV9idWYpO1xuICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gcy5iaV9idWY7XG4gIH1cbiAgcy5iaV9idWYgPSAwO1xuICBzLmJpX3ZhbGlkID0gMDtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5IGEgc3RvcmVkIGJsb2NrLCBzdG9yaW5nIGZpcnN0IHRoZSBsZW5ndGggYW5kIGl0c1xuICogb25lJ3MgY29tcGxlbWVudCBpZiByZXF1ZXN0ZWQuXG4gKi9cbmZ1bmN0aW9uIGNvcHlfYmxvY2socywgYnVmLCBsZW4sIGhlYWRlcilcbi8vRGVmbGF0ZVN0YXRlICpzO1xuLy9jaGFyZiAgICAqYnVmOyAgICAvKiB0aGUgaW5wdXQgZGF0YSAqL1xuLy91bnNpZ25lZCBsZW47ICAgICAvKiBpdHMgbGVuZ3RoICovXG4vL2ludCAgICAgIGhlYWRlcjsgIC8qIHRydWUgaWYgYmxvY2sgaGVhZGVyIG11c3QgYmUgd3JpdHRlbiAqL1xue1xuICBiaV93aW5kdXAocyk7ICAgICAgICAvKiBhbGlnbiBvbiBieXRlIGJvdW5kYXJ5ICovXG5cbiAgaWYgKGhlYWRlcikge1xuICAgIHB1dF9zaG9ydChzLCBsZW4pO1xuICAgIHB1dF9zaG9ydChzLCB+bGVuKTtcbiAgfVxuLy8gIHdoaWxlIChsZW4tLSkge1xuLy8gICAgcHV0X2J5dGUocywgKmJ1ZisrKTtcbi8vICB9XG4gIHV0aWxzLmFycmF5U2V0KHMucGVuZGluZ19idWYsIHMud2luZG93LCBidWYsIGxlbiwgcy5wZW5kaW5nKTtcbiAgcy5wZW5kaW5nICs9IGxlbjtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb21wYXJlcyB0byBzdWJ0cmVlcywgdXNpbmcgdGhlIHRyZWUgZGVwdGggYXMgdGllIGJyZWFrZXIgd2hlblxuICogdGhlIHN1YnRyZWVzIGhhdmUgZXF1YWwgZnJlcXVlbmN5LiBUaGlzIG1pbmltaXplcyB0aGUgd29yc3QgY2FzZSBsZW5ndGguXG4gKi9cbmZ1bmN0aW9uIHNtYWxsZXIodHJlZSwgbiwgbSwgZGVwdGgpIHtcbiAgdmFyIF9uMiA9IG4gKiAyO1xuICB2YXIgX20yID0gbSAqIDI7XG4gIHJldHVybiAodHJlZVtfbjJdLyouRnJlcSovIDwgdHJlZVtfbTJdLyouRnJlcSovIHx8XG4gICAgICAgICAodHJlZVtfbjJdLyouRnJlcSovID09PSB0cmVlW19tMl0vKi5GcmVxKi8gJiYgZGVwdGhbbl0gPD0gZGVwdGhbbV0pKTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBSZXN0b3JlIHRoZSBoZWFwIHByb3BlcnR5IGJ5IG1vdmluZyBkb3duIHRoZSB0cmVlIHN0YXJ0aW5nIGF0IG5vZGUgayxcbiAqIGV4Y2hhbmdpbmcgYSBub2RlIHdpdGggdGhlIHNtYWxsZXN0IG9mIGl0cyB0d28gc29ucyBpZiBuZWNlc3NhcnksIHN0b3BwaW5nXG4gKiB3aGVuIHRoZSBoZWFwIHByb3BlcnR5IGlzIHJlLWVzdGFibGlzaGVkIChlYWNoIGZhdGhlciBzbWFsbGVyIHRoYW4gaXRzXG4gKiB0d28gc29ucykuXG4gKi9cbmZ1bmN0aW9uIHBxZG93bmhlYXAocywgdHJlZSwgaylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjdF9kYXRhICp0cmVlOyAgLyogdGhlIHRyZWUgdG8gcmVzdG9yZSAqL1xuLy8gICAgaW50IGs7ICAgICAgICAgICAgICAgLyogbm9kZSB0byBtb3ZlIGRvd24gKi9cbntcbiAgdmFyIHYgPSBzLmhlYXBba107XG4gIHZhciBqID0gayA8PCAxOyAgLyogbGVmdCBzb24gb2YgayAqL1xuICB3aGlsZSAoaiA8PSBzLmhlYXBfbGVuKSB7XG4gICAgLyogU2V0IGogdG8gdGhlIHNtYWxsZXN0IG9mIHRoZSB0d28gc29uczogKi9cbiAgICBpZiAoaiA8IHMuaGVhcF9sZW4gJiZcbiAgICAgIHNtYWxsZXIodHJlZSwgcy5oZWFwW2ogKyAxXSwgcy5oZWFwW2pdLCBzLmRlcHRoKSkge1xuICAgICAgaisrO1xuICAgIH1cbiAgICAvKiBFeGl0IGlmIHYgaXMgc21hbGxlciB0aGFuIGJvdGggc29ucyAqL1xuICAgIGlmIChzbWFsbGVyKHRyZWUsIHYsIHMuaGVhcFtqXSwgcy5kZXB0aCkpIHsgYnJlYWs7IH1cblxuICAgIC8qIEV4Y2hhbmdlIHYgd2l0aCB0aGUgc21hbGxlc3Qgc29uICovXG4gICAgcy5oZWFwW2tdID0gcy5oZWFwW2pdO1xuICAgIGsgPSBqO1xuXG4gICAgLyogQW5kIGNvbnRpbnVlIGRvd24gdGhlIHRyZWUsIHNldHRpbmcgaiB0byB0aGUgbGVmdCBzb24gb2YgayAqL1xuICAgIGogPDw9IDE7XG4gIH1cbiAgcy5oZWFwW2tdID0gdjtcbn1cblxuXG4vLyBpbmxpbmVkIG1hbnVhbGx5XG4vLyB2YXIgU01BTExFU1QgPSAxO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgdGhlIGJsb2NrIGRhdGEgY29tcHJlc3NlZCB1c2luZyB0aGUgZ2l2ZW4gSHVmZm1hbiB0cmVlc1xuICovXG5mdW5jdGlvbiBjb21wcmVzc19ibG9jayhzLCBsdHJlZSwgZHRyZWUpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY29uc3QgY3RfZGF0YSAqbHRyZWU7IC8qIGxpdGVyYWwgdHJlZSAqL1xuLy8gICAgY29uc3QgY3RfZGF0YSAqZHRyZWU7IC8qIGRpc3RhbmNlIHRyZWUgKi9cbntcbiAgdmFyIGRpc3Q7ICAgICAgICAgICAvKiBkaXN0YW5jZSBvZiBtYXRjaGVkIHN0cmluZyAqL1xuICB2YXIgbGM7ICAgICAgICAgICAgIC8qIG1hdGNoIGxlbmd0aCBvciB1bm1hdGNoZWQgY2hhciAoaWYgZGlzdCA9PSAwKSAqL1xuICB2YXIgbHggPSAwOyAgICAgICAgIC8qIHJ1bm5pbmcgaW5kZXggaW4gbF9idWYgKi9cbiAgdmFyIGNvZGU7ICAgICAgICAgICAvKiB0aGUgY29kZSB0byBzZW5kICovXG4gIHZhciBleHRyYTsgICAgICAgICAgLyogbnVtYmVyIG9mIGV4dHJhIGJpdHMgdG8gc2VuZCAqL1xuXG4gIGlmIChzLmxhc3RfbGl0ICE9PSAwKSB7XG4gICAgZG8ge1xuICAgICAgZGlzdCA9IChzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBseCAqIDJdIDw8IDgpIHwgKHMucGVuZGluZ19idWZbcy5kX2J1ZiArIGx4ICogMiArIDFdKTtcbiAgICAgIGxjID0gcy5wZW5kaW5nX2J1ZltzLmxfYnVmICsgbHhdO1xuICAgICAgbHgrKztcblxuICAgICAgaWYgKGRpc3QgPT09IDApIHtcbiAgICAgICAgc2VuZF9jb2RlKHMsIGxjLCBsdHJlZSk7IC8qIHNlbmQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICAgICAgLy9UcmFjZWN2KGlzZ3JhcGgobGMpLCAoc3RkZXJyLFwiICclYycgXCIsIGxjKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBIZXJlLCBsYyBpcyB0aGUgbWF0Y2ggbGVuZ3RoIC0gTUlOX01BVENIICovXG4gICAgICAgIGNvZGUgPSBfbGVuZ3RoX2NvZGVbbGNdO1xuICAgICAgICBzZW5kX2NvZGUocywgY29kZSArIExJVEVSQUxTICsgMSwgbHRyZWUpOyAvKiBzZW5kIHRoZSBsZW5ndGggY29kZSAqL1xuICAgICAgICBleHRyYSA9IGV4dHJhX2xiaXRzW2NvZGVdO1xuICAgICAgICBpZiAoZXh0cmEgIT09IDApIHtcbiAgICAgICAgICBsYyAtPSBiYXNlX2xlbmd0aFtjb2RlXTtcbiAgICAgICAgICBzZW5kX2JpdHMocywgbGMsIGV4dHJhKTsgICAgICAgLyogc2VuZCB0aGUgZXh0cmEgbGVuZ3RoIGJpdHMgKi9cbiAgICAgICAgfVxuICAgICAgICBkaXN0LS07IC8qIGRpc3QgaXMgbm93IHRoZSBtYXRjaCBkaXN0YW5jZSAtIDEgKi9cbiAgICAgICAgY29kZSA9IGRfY29kZShkaXN0KTtcbiAgICAgICAgLy9Bc3NlcnQgKGNvZGUgPCBEX0NPREVTLCBcImJhZCBkX2NvZGVcIik7XG5cbiAgICAgICAgc2VuZF9jb2RlKHMsIGNvZGUsIGR0cmVlKTsgICAgICAgLyogc2VuZCB0aGUgZGlzdGFuY2UgY29kZSAqL1xuICAgICAgICBleHRyYSA9IGV4dHJhX2RiaXRzW2NvZGVdO1xuICAgICAgICBpZiAoZXh0cmEgIT09IDApIHtcbiAgICAgICAgICBkaXN0IC09IGJhc2VfZGlzdFtjb2RlXTtcbiAgICAgICAgICBzZW5kX2JpdHMocywgZGlzdCwgZXh0cmEpOyAgIC8qIHNlbmQgdGhlIGV4dHJhIGRpc3RhbmNlIGJpdHMgKi9cbiAgICAgICAgfVxuICAgICAgfSAvKiBsaXRlcmFsIG9yIG1hdGNoIHBhaXIgPyAqL1xuXG4gICAgICAvKiBDaGVjayB0aGF0IHRoZSBvdmVybGF5IGJldHdlZW4gcGVuZGluZ19idWYgYW5kIGRfYnVmK2xfYnVmIGlzIG9rOiAqL1xuICAgICAgLy9Bc3NlcnQoKHVJbnQpKHMtPnBlbmRpbmcpIDwgcy0+bGl0X2J1ZnNpemUgKyAyKmx4LFxuICAgICAgLy8gICAgICAgXCJwZW5kaW5nQnVmIG92ZXJmbG93XCIpO1xuXG4gICAgfSB3aGlsZSAobHggPCBzLmxhc3RfbGl0KTtcbiAgfVxuXG4gIHNlbmRfY29kZShzLCBFTkRfQkxPQ0ssIGx0cmVlKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbnN0cnVjdCBvbmUgSHVmZm1hbiB0cmVlIGFuZCBhc3NpZ25zIHRoZSBjb2RlIGJpdCBzdHJpbmdzIGFuZCBsZW5ndGhzLlxuICogVXBkYXRlIHRoZSB0b3RhbCBiaXQgbGVuZ3RoIGZvciB0aGUgY3VycmVudCBibG9jay5cbiAqIElOIGFzc2VydGlvbjogdGhlIGZpZWxkIGZyZXEgaXMgc2V0IGZvciBhbGwgdHJlZSBlbGVtZW50cy5cbiAqIE9VVCBhc3NlcnRpb25zOiB0aGUgZmllbGRzIGxlbiBhbmQgY29kZSBhcmUgc2V0IHRvIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGhcbiAqICAgICBhbmQgY29ycmVzcG9uZGluZyBjb2RlLiBUaGUgbGVuZ3RoIG9wdF9sZW4gaXMgdXBkYXRlZDsgc3RhdGljX2xlbiBpc1xuICogICAgIGFsc28gdXBkYXRlZCBpZiBzdHJlZSBpcyBub3QgbnVsbC4gVGhlIGZpZWxkIG1heF9jb2RlIGlzIHNldC5cbiAqL1xuZnVuY3Rpb24gYnVpbGRfdHJlZShzLCBkZXNjKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIHRyZWVfZGVzYyAqZGVzYzsgLyogdGhlIHRyZWUgZGVzY3JpcHRvciAqL1xue1xuICB2YXIgdHJlZSAgICAgPSBkZXNjLmR5bl90cmVlO1xuICB2YXIgc3RyZWUgICAgPSBkZXNjLnN0YXRfZGVzYy5zdGF0aWNfdHJlZTtcbiAgdmFyIGhhc19zdHJlZSA9IGRlc2Muc3RhdF9kZXNjLmhhc19zdHJlZTtcbiAgdmFyIGVsZW1zICAgID0gZGVzYy5zdGF0X2Rlc2MuZWxlbXM7XG4gIHZhciBuLCBtOyAgICAgICAgICAvKiBpdGVyYXRlIG92ZXIgaGVhcCBlbGVtZW50cyAqL1xuICB2YXIgbWF4X2NvZGUgPSAtMTsgLyogbGFyZ2VzdCBjb2RlIHdpdGggbm9uIHplcm8gZnJlcXVlbmN5ICovXG4gIHZhciBub2RlOyAgICAgICAgICAvKiBuZXcgbm9kZSBiZWluZyBjcmVhdGVkICovXG5cbiAgLyogQ29uc3RydWN0IHRoZSBpbml0aWFsIGhlYXAsIHdpdGggbGVhc3QgZnJlcXVlbnQgZWxlbWVudCBpblxuICAgKiBoZWFwW1NNQUxMRVNUXS4gVGhlIHNvbnMgb2YgaGVhcFtuXSBhcmUgaGVhcFsyKm5dIGFuZCBoZWFwWzIqbisxXS5cbiAgICogaGVhcFswXSBpcyBub3QgdXNlZC5cbiAgICovXG4gIHMuaGVhcF9sZW4gPSAwO1xuICBzLmhlYXBfbWF4ID0gSEVBUF9TSVpFO1xuXG4gIGZvciAobiA9IDA7IG4gPCBlbGVtczsgbisrKSB7XG4gICAgaWYgKHRyZWVbbiAqIDJdLyouRnJlcSovICE9PSAwKSB7XG4gICAgICBzLmhlYXBbKytzLmhlYXBfbGVuXSA9IG1heF9jb2RlID0gbjtcbiAgICAgIHMuZGVwdGhbbl0gPSAwO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gMDtcbiAgICB9XG4gIH1cblxuICAvKiBUaGUgcGt6aXAgZm9ybWF0IHJlcXVpcmVzIHRoYXQgYXQgbGVhc3Qgb25lIGRpc3RhbmNlIGNvZGUgZXhpc3RzLFxuICAgKiBhbmQgdGhhdCBhdCBsZWFzdCBvbmUgYml0IHNob3VsZCBiZSBzZW50IGV2ZW4gaWYgdGhlcmUgaXMgb25seSBvbmVcbiAgICogcG9zc2libGUgY29kZS4gU28gdG8gYXZvaWQgc3BlY2lhbCBjaGVja3MgbGF0ZXIgb24gd2UgZm9yY2UgYXQgbGVhc3RcbiAgICogdHdvIGNvZGVzIG9mIG5vbiB6ZXJvIGZyZXF1ZW5jeS5cbiAgICovXG4gIHdoaWxlIChzLmhlYXBfbGVuIDwgMikge1xuICAgIG5vZGUgPSBzLmhlYXBbKytzLmhlYXBfbGVuXSA9IChtYXhfY29kZSA8IDIgPyArK21heF9jb2RlIDogMCk7XG4gICAgdHJlZVtub2RlICogMl0vKi5GcmVxKi8gPSAxO1xuICAgIHMuZGVwdGhbbm9kZV0gPSAwO1xuICAgIHMub3B0X2xlbi0tO1xuXG4gICAgaWYgKGhhc19zdHJlZSkge1xuICAgICAgcy5zdGF0aWNfbGVuIC09IHN0cmVlW25vZGUgKiAyICsgMV0vKi5MZW4qLztcbiAgICB9XG4gICAgLyogbm9kZSBpcyAwIG9yIDEgc28gaXQgZG9lcyBub3QgaGF2ZSBleHRyYSBiaXRzICovXG4gIH1cbiAgZGVzYy5tYXhfY29kZSA9IG1heF9jb2RlO1xuXG4gIC8qIFRoZSBlbGVtZW50cyBoZWFwW2hlYXBfbGVuLzIrMSAuLiBoZWFwX2xlbl0gYXJlIGxlYXZlcyBvZiB0aGUgdHJlZSxcbiAgICogZXN0YWJsaXNoIHN1Yi1oZWFwcyBvZiBpbmNyZWFzaW5nIGxlbmd0aHM6XG4gICAqL1xuICBmb3IgKG4gPSAocy5oZWFwX2xlbiA+PiAxLyppbnQgLzIqLyk7IG4gPj0gMTsgbi0tKSB7IHBxZG93bmhlYXAocywgdHJlZSwgbik7IH1cblxuICAvKiBDb25zdHJ1Y3QgdGhlIEh1ZmZtYW4gdHJlZSBieSByZXBlYXRlZGx5IGNvbWJpbmluZyB0aGUgbGVhc3QgdHdvXG4gICAqIGZyZXF1ZW50IG5vZGVzLlxuICAgKi9cbiAgbm9kZSA9IGVsZW1zOyAgICAgICAgICAgICAgLyogbmV4dCBpbnRlcm5hbCBub2RlIG9mIHRoZSB0cmVlICovXG4gIGRvIHtcbiAgICAvL3BxcmVtb3ZlKHMsIHRyZWUsIG4pOyAgLyogbiA9IG5vZGUgb2YgbGVhc3QgZnJlcXVlbmN5ICovXG4gICAgLyoqKiBwcXJlbW92ZSAqKiovXG4gICAgbiA9IHMuaGVhcFsxLypTTUFMTEVTVCovXTtcbiAgICBzLmhlYXBbMS8qU01BTExFU1QqL10gPSBzLmhlYXBbcy5oZWFwX2xlbi0tXTtcbiAgICBwcWRvd25oZWFwKHMsIHRyZWUsIDEvKlNNQUxMRVNUKi8pO1xuICAgIC8qKiovXG5cbiAgICBtID0gcy5oZWFwWzEvKlNNQUxMRVNUKi9dOyAvKiBtID0gbm9kZSBvZiBuZXh0IGxlYXN0IGZyZXF1ZW5jeSAqL1xuXG4gICAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBuOyAvKiBrZWVwIHRoZSBub2RlcyBzb3J0ZWQgYnkgZnJlcXVlbmN5ICovXG4gICAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBtO1xuXG4gICAgLyogQ3JlYXRlIGEgbmV3IG5vZGUgZmF0aGVyIG9mIG4gYW5kIG0gKi9cbiAgICB0cmVlW25vZGUgKiAyXS8qLkZyZXEqLyA9IHRyZWVbbiAqIDJdLyouRnJlcSovICsgdHJlZVttICogMl0vKi5GcmVxKi87XG4gICAgcy5kZXB0aFtub2RlXSA9IChzLmRlcHRoW25dID49IHMuZGVwdGhbbV0gPyBzLmRlcHRoW25dIDogcy5kZXB0aFttXSkgKyAxO1xuICAgIHRyZWVbbiAqIDIgKyAxXS8qLkRhZCovID0gdHJlZVttICogMiArIDFdLyouRGFkKi8gPSBub2RlO1xuXG4gICAgLyogYW5kIGluc2VydCB0aGUgbmV3IG5vZGUgaW4gdGhlIGhlYXAgKi9cbiAgICBzLmhlYXBbMS8qU01BTExFU1QqL10gPSBub2RlKys7XG4gICAgcHFkb3duaGVhcChzLCB0cmVlLCAxLypTTUFMTEVTVCovKTtcblxuICB9IHdoaWxlIChzLmhlYXBfbGVuID49IDIpO1xuXG4gIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gcy5oZWFwWzEvKlNNQUxMRVNUKi9dO1xuXG4gIC8qIEF0IHRoaXMgcG9pbnQsIHRoZSBmaWVsZHMgZnJlcSBhbmQgZGFkIGFyZSBzZXQuIFdlIGNhbiBub3dcbiAgICogZ2VuZXJhdGUgdGhlIGJpdCBsZW5ndGhzLlxuICAgKi9cbiAgZ2VuX2JpdGxlbihzLCBkZXNjKTtcblxuICAvKiBUaGUgZmllbGQgbGVuIGlzIG5vdyBzZXQsIHdlIGNhbiBnZW5lcmF0ZSB0aGUgYml0IGNvZGVzICovXG4gIGdlbl9jb2Rlcyh0cmVlLCBtYXhfY29kZSwgcy5ibF9jb3VudCk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTY2FuIGEgbGl0ZXJhbCBvciBkaXN0YW5jZSB0cmVlIHRvIGRldGVybWluZSB0aGUgZnJlcXVlbmNpZXMgb2YgdGhlIGNvZGVzXG4gKiBpbiB0aGUgYml0IGxlbmd0aCB0cmVlLlxuICovXG5mdW5jdGlvbiBzY2FuX3RyZWUocywgdHJlZSwgbWF4X2NvZGUpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY3RfZGF0YSAqdHJlZTsgICAvKiB0aGUgdHJlZSB0byBiZSBzY2FubmVkICovXG4vLyAgICBpbnQgbWF4X2NvZGU7ICAgIC8qIGFuZCBpdHMgbGFyZ2VzdCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xue1xuICB2YXIgbjsgICAgICAgICAgICAgICAgICAgICAvKiBpdGVyYXRlcyBvdmVyIGFsbCB0cmVlIGVsZW1lbnRzICovXG4gIHZhciBwcmV2bGVuID0gLTE7ICAgICAgICAgIC8qIGxhc3QgZW1pdHRlZCBsZW5ndGggKi9cbiAgdmFyIGN1cmxlbjsgICAgICAgICAgICAgICAgLyogbGVuZ3RoIG9mIGN1cnJlbnQgY29kZSAqL1xuXG4gIHZhciBuZXh0bGVuID0gdHJlZVswICogMiArIDFdLyouTGVuKi87IC8qIGxlbmd0aCBvZiBuZXh0IGNvZGUgKi9cblxuICB2YXIgY291bnQgPSAwOyAgICAgICAgICAgICAvKiByZXBlYXQgY291bnQgb2YgdGhlIGN1cnJlbnQgY29kZSAqL1xuICB2YXIgbWF4X2NvdW50ID0gNzsgICAgICAgICAvKiBtYXggcmVwZWF0IGNvdW50ICovXG4gIHZhciBtaW5fY291bnQgPSA0OyAgICAgICAgIC8qIG1pbiByZXBlYXQgY291bnQgKi9cblxuICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgIG1heF9jb3VudCA9IDEzODtcbiAgICBtaW5fY291bnQgPSAzO1xuICB9XG4gIHRyZWVbKG1heF9jb2RlICsgMSkgKiAyICsgMV0vKi5MZW4qLyA9IDB4ZmZmZjsgLyogZ3VhcmQgKi9cblxuICBmb3IgKG4gPSAwOyBuIDw9IG1heF9jb2RlOyBuKyspIHtcbiAgICBjdXJsZW4gPSBuZXh0bGVuO1xuICAgIG5leHRsZW4gPSB0cmVlWyhuICsgMSkgKiAyICsgMV0vKi5MZW4qLztcblxuICAgIGlmICgrK2NvdW50IDwgbWF4X2NvdW50ICYmIGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgY29udGludWU7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDwgbWluX2NvdW50KSB7XG4gICAgICBzLmJsX3RyZWVbY3VybGVuICogMl0vKi5GcmVxKi8gKz0gY291bnQ7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiAhPT0gMCkge1xuXG4gICAgICBpZiAoY3VybGVuICE9PSBwcmV2bGVuKSB7IHMuYmxfdHJlZVtjdXJsZW4gKiAyXS8qLkZyZXEqLysrOyB9XG4gICAgICBzLmJsX3RyZWVbUkVQXzNfNiAqIDJdLyouRnJlcSovKys7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDw9IDEwKSB7XG4gICAgICBzLmJsX3RyZWVbUkVQWl8zXzEwICogMl0vKi5GcmVxKi8rKztcblxuICAgIH0gZWxzZSB7XG4gICAgICBzLmJsX3RyZWVbUkVQWl8xMV8xMzggKiAyXS8qLkZyZXEqLysrO1xuICAgIH1cblxuICAgIGNvdW50ID0gMDtcbiAgICBwcmV2bGVuID0gY3VybGVuO1xuXG4gICAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICAgIG1heF9jb3VudCA9IDEzODtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgbWF4X2NvdW50ID0gNjtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgbWF4X2NvdW50ID0gNztcbiAgICAgIG1pbl9jb3VudCA9IDQ7XG4gICAgfVxuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIGEgbGl0ZXJhbCBvciBkaXN0YW5jZSB0cmVlIGluIGNvbXByZXNzZWQgZm9ybSwgdXNpbmcgdGhlIGNvZGVzIGluXG4gKiBibF90cmVlLlxuICovXG5mdW5jdGlvbiBzZW5kX3RyZWUocywgdHJlZSwgbWF4X2NvZGUpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY3RfZGF0YSAqdHJlZTsgLyogdGhlIHRyZWUgdG8gYmUgc2Nhbm5lZCAqL1xuLy8gICAgaW50IG1heF9jb2RlOyAgICAgICAvKiBhbmQgaXRzIGxhcmdlc3QgY29kZSBvZiBub24gemVybyBmcmVxdWVuY3kgKi9cbntcbiAgdmFyIG47ICAgICAgICAgICAgICAgICAgICAgLyogaXRlcmF0ZXMgb3ZlciBhbGwgdHJlZSBlbGVtZW50cyAqL1xuICB2YXIgcHJldmxlbiA9IC0xOyAgICAgICAgICAvKiBsYXN0IGVtaXR0ZWQgbGVuZ3RoICovXG4gIHZhciBjdXJsZW47ICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBvZiBjdXJyZW50IGNvZGUgKi9cblxuICB2YXIgbmV4dGxlbiA9IHRyZWVbMCAqIDIgKyAxXS8qLkxlbiovOyAvKiBsZW5ndGggb2YgbmV4dCBjb2RlICovXG5cbiAgdmFyIGNvdW50ID0gMDsgICAgICAgICAgICAgLyogcmVwZWF0IGNvdW50IG9mIHRoZSBjdXJyZW50IGNvZGUgKi9cbiAgdmFyIG1heF9jb3VudCA9IDc7ICAgICAgICAgLyogbWF4IHJlcGVhdCBjb3VudCAqL1xuICB2YXIgbWluX2NvdW50ID0gNDsgICAgICAgICAvKiBtaW4gcmVwZWF0IGNvdW50ICovXG5cbiAgLyogdHJlZVttYXhfY29kZSsxXS5MZW4gPSAtMTsgKi8gIC8qIGd1YXJkIGFscmVhZHkgc2V0ICovXG4gIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgbWF4X2NvdW50ID0gMTM4O1xuICAgIG1pbl9jb3VudCA9IDM7XG4gIH1cblxuICBmb3IgKG4gPSAwOyBuIDw9IG1heF9jb2RlOyBuKyspIHtcbiAgICBjdXJsZW4gPSBuZXh0bGVuO1xuICAgIG5leHRsZW4gPSB0cmVlWyhuICsgMSkgKiAyICsgMV0vKi5MZW4qLztcblxuICAgIGlmICgrK2NvdW50IDwgbWF4X2NvdW50ICYmIGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgY29udGludWU7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDwgbWluX2NvdW50KSB7XG4gICAgICBkbyB7IHNlbmRfY29kZShzLCBjdXJsZW4sIHMuYmxfdHJlZSk7IH0gd2hpbGUgKC0tY291bnQgIT09IDApO1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gIT09IDApIHtcbiAgICAgIGlmIChjdXJsZW4gIT09IHByZXZsZW4pIHtcbiAgICAgICAgc2VuZF9jb2RlKHMsIGN1cmxlbiwgcy5ibF90cmVlKTtcbiAgICAgICAgY291bnQtLTtcbiAgICAgIH1cbiAgICAgIC8vQXNzZXJ0KGNvdW50ID49IDMgJiYgY291bnQgPD0gNiwgXCIgM182P1wiKTtcbiAgICAgIHNlbmRfY29kZShzLCBSRVBfM182LCBzLmJsX3RyZWUpO1xuICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMywgMik7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDw9IDEwKSB7XG4gICAgICBzZW5kX2NvZGUocywgUkVQWl8zXzEwLCBzLmJsX3RyZWUpO1xuICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMywgMyk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgc2VuZF9jb2RlKHMsIFJFUFpfMTFfMTM4LCBzLmJsX3RyZWUpO1xuICAgICAgc2VuZF9iaXRzKHMsIGNvdW50IC0gMTEsIDcpO1xuICAgIH1cblxuICAgIGNvdW50ID0gMDtcbiAgICBwcmV2bGVuID0gY3VybGVuO1xuICAgIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIG1heF9jb3VudCA9IDY7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIG1heF9jb3VudCA9IDc7XG4gICAgICBtaW5fY291bnQgPSA0O1xuICAgIH1cbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29uc3RydWN0IHRoZSBIdWZmbWFuIHRyZWUgZm9yIHRoZSBiaXQgbGVuZ3RocyBhbmQgcmV0dXJuIHRoZSBpbmRleCBpblxuICogYmxfb3JkZXIgb2YgdGhlIGxhc3QgYml0IGxlbmd0aCBjb2RlIHRvIHNlbmQuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkX2JsX3RyZWUocykge1xuICB2YXIgbWF4X2JsaW5kZXg7ICAvKiBpbmRleCBvZiBsYXN0IGJpdCBsZW5ndGggY29kZSBvZiBub24gemVybyBmcmVxICovXG5cbiAgLyogRGV0ZXJtaW5lIHRoZSBiaXQgbGVuZ3RoIGZyZXF1ZW5jaWVzIGZvciBsaXRlcmFsIGFuZCBkaXN0YW5jZSB0cmVlcyAqL1xuICBzY2FuX3RyZWUocywgcy5keW5fbHRyZWUsIHMubF9kZXNjLm1heF9jb2RlKTtcbiAgc2Nhbl90cmVlKHMsIHMuZHluX2R0cmVlLCBzLmRfZGVzYy5tYXhfY29kZSk7XG5cbiAgLyogQnVpbGQgdGhlIGJpdCBsZW5ndGggdHJlZTogKi9cbiAgYnVpbGRfdHJlZShzLCBzLmJsX2Rlc2MpO1xuICAvKiBvcHRfbGVuIG5vdyBpbmNsdWRlcyB0aGUgbGVuZ3RoIG9mIHRoZSB0cmVlIHJlcHJlc2VudGF0aW9ucywgZXhjZXB0XG4gICAqIHRoZSBsZW5ndGhzIG9mIHRoZSBiaXQgbGVuZ3RocyBjb2RlcyBhbmQgdGhlIDUrNSs0IGJpdHMgZm9yIHRoZSBjb3VudHMuXG4gICAqL1xuXG4gIC8qIERldGVybWluZSB0aGUgbnVtYmVyIG9mIGJpdCBsZW5ndGggY29kZXMgdG8gc2VuZC4gVGhlIHBremlwIGZvcm1hdFxuICAgKiByZXF1aXJlcyB0aGF0IGF0IGxlYXN0IDQgYml0IGxlbmd0aCBjb2RlcyBiZSBzZW50LiAoYXBwbm90ZS50eHQgc2F5c1xuICAgKiAzIGJ1dCB0aGUgYWN0dWFsIHZhbHVlIHVzZWQgaXMgNC4pXG4gICAqL1xuICBmb3IgKG1heF9ibGluZGV4ID0gQkxfQ09ERVMgLSAxOyBtYXhfYmxpbmRleCA+PSAzOyBtYXhfYmxpbmRleC0tKSB7XG4gICAgaWYgKHMuYmxfdHJlZVtibF9vcmRlclttYXhfYmxpbmRleF0gKiAyICsgMV0vKi5MZW4qLyAhPT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIC8qIFVwZGF0ZSBvcHRfbGVuIHRvIGluY2x1ZGUgdGhlIGJpdCBsZW5ndGggdHJlZSBhbmQgY291bnRzICovXG4gIHMub3B0X2xlbiArPSAzICogKG1heF9ibGluZGV4ICsgMSkgKyA1ICsgNSArIDQ7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuZHluIHRyZWVzOiBkeW4gJWxkLCBzdGF0ICVsZFwiLFxuICAvLyAgICAgICAgcy0+b3B0X2xlbiwgcy0+c3RhdGljX2xlbikpO1xuXG4gIHJldHVybiBtYXhfYmxpbmRleDtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgdGhlIGhlYWRlciBmb3IgYSBibG9jayB1c2luZyBkeW5hbWljIEh1ZmZtYW4gdHJlZXM6IHRoZSBjb3VudHMsIHRoZVxuICogbGVuZ3RocyBvZiB0aGUgYml0IGxlbmd0aCBjb2RlcywgdGhlIGxpdGVyYWwgdHJlZSBhbmQgdGhlIGRpc3RhbmNlIHRyZWUuXG4gKiBJTiBhc3NlcnRpb246IGxjb2RlcyA+PSAyNTcsIGRjb2RlcyA+PSAxLCBibGNvZGVzID49IDQuXG4gKi9cbmZ1bmN0aW9uIHNlbmRfYWxsX3RyZWVzKHMsIGxjb2RlcywgZGNvZGVzLCBibGNvZGVzKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGludCBsY29kZXMsIGRjb2RlcywgYmxjb2RlczsgLyogbnVtYmVyIG9mIGNvZGVzIGZvciBlYWNoIHRyZWUgKi9cbntcbiAgdmFyIHJhbms7ICAgICAgICAgICAgICAgICAgICAvKiBpbmRleCBpbiBibF9vcmRlciAqL1xuXG4gIC8vQXNzZXJ0IChsY29kZXMgPj0gMjU3ICYmIGRjb2RlcyA+PSAxICYmIGJsY29kZXMgPj0gNCwgXCJub3QgZW5vdWdoIGNvZGVzXCIpO1xuICAvL0Fzc2VydCAobGNvZGVzIDw9IExfQ09ERVMgJiYgZGNvZGVzIDw9IERfQ09ERVMgJiYgYmxjb2RlcyA8PSBCTF9DT0RFUyxcbiAgLy8gICAgICAgIFwidG9vIG1hbnkgY29kZXNcIik7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuYmwgY291bnRzOiBcIikpO1xuICBzZW5kX2JpdHMocywgbGNvZGVzIC0gMjU3LCA1KTsgLyogbm90ICsyNTUgYXMgc3RhdGVkIGluIGFwcG5vdGUudHh0ICovXG4gIHNlbmRfYml0cyhzLCBkY29kZXMgLSAxLCAgIDUpO1xuICBzZW5kX2JpdHMocywgYmxjb2RlcyAtIDQsICA0KTsgLyogbm90IC0zIGFzIHN0YXRlZCBpbiBhcHBub3RlLnR4dCAqL1xuICBmb3IgKHJhbmsgPSAwOyByYW5rIDwgYmxjb2RlczsgcmFuaysrKSB7XG4gICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5ibCBjb2RlICUyZCBcIiwgYmxfb3JkZXJbcmFua10pKTtcbiAgICBzZW5kX2JpdHMocywgcy5ibF90cmVlW2JsX29yZGVyW3JhbmtdICogMiArIDFdLyouTGVuKi8sIDMpO1xuICB9XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuYmwgdHJlZTogc2VudCAlbGRcIiwgcy0+Yml0c19zZW50KSk7XG5cbiAgc2VuZF90cmVlKHMsIHMuZHluX2x0cmVlLCBsY29kZXMgLSAxKTsgLyogbGl0ZXJhbCB0cmVlICovXG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxubGl0IHRyZWU6IHNlbnQgJWxkXCIsIHMtPmJpdHNfc2VudCkpO1xuXG4gIHNlbmRfdHJlZShzLCBzLmR5bl9kdHJlZSwgZGNvZGVzIC0gMSk7IC8qIGRpc3RhbmNlIHRyZWUgKi9cbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5kaXN0IHRyZWU6IHNlbnQgJWxkXCIsIHMtPmJpdHNfc2VudCkpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ2hlY2sgaWYgdGhlIGRhdGEgdHlwZSBpcyBURVhUIG9yIEJJTkFSWSwgdXNpbmcgdGhlIGZvbGxvd2luZyBhbGdvcml0aG06XG4gKiAtIFRFWFQgaWYgdGhlIHR3byBjb25kaXRpb25zIGJlbG93IGFyZSBzYXRpc2ZpZWQ6XG4gKiAgICBhKSBUaGVyZSBhcmUgbm8gbm9uLXBvcnRhYmxlIGNvbnRyb2wgY2hhcmFjdGVycyBiZWxvbmdpbmcgdG8gdGhlXG4gKiAgICAgICBcImJsYWNrIGxpc3RcIiAoMC4uNiwgMTQuLjI1LCAyOC4uMzEpLlxuICogICAgYikgVGhlcmUgaXMgYXQgbGVhc3Qgb25lIHByaW50YWJsZSBjaGFyYWN0ZXIgYmVsb25naW5nIHRvIHRoZVxuICogICAgICAgXCJ3aGl0ZSBsaXN0XCIgKDkge1RBQn0sIDEwIHtMRn0sIDEzIHtDUn0sIDMyLi4yNTUpLlxuICogLSBCSU5BUlkgb3RoZXJ3aXNlLlxuICogLSBUaGUgZm9sbG93aW5nIHBhcnRpYWxseS1wb3J0YWJsZSBjb250cm9sIGNoYXJhY3RlcnMgZm9ybSBhXG4gKiAgIFwiZ3JheSBsaXN0XCIgdGhhdCBpcyBpZ25vcmVkIGluIHRoaXMgZGV0ZWN0aW9uIGFsZ29yaXRobTpcbiAqICAgKDcge0JFTH0sIDgge0JTfSwgMTEge1ZUfSwgMTIge0ZGfSwgMjYge1NVQn0sIDI3IHtFU0N9KS5cbiAqIElOIGFzc2VydGlvbjogdGhlIGZpZWxkcyBGcmVxIG9mIGR5bl9sdHJlZSBhcmUgc2V0LlxuICovXG5mdW5jdGlvbiBkZXRlY3RfZGF0YV90eXBlKHMpIHtcbiAgLyogYmxhY2tfbWFzayBpcyB0aGUgYml0IG1hc2sgb2YgYmxhY2stbGlzdGVkIGJ5dGVzXG4gICAqIHNldCBiaXRzIDAuLjYsIDE0Li4yNSwgYW5kIDI4Li4zMVxuICAgKiAweGYzZmZjMDdmID0gYmluYXJ5IDExMTEwMDExMTExMTExMTExMTAwMDAwMDAxMTExMTExXG4gICAqL1xuICB2YXIgYmxhY2tfbWFzayA9IDB4ZjNmZmMwN2Y7XG4gIHZhciBuO1xuXG4gIC8qIENoZWNrIGZvciBub24tdGV4dHVhbCAoXCJibGFjay1saXN0ZWRcIikgYnl0ZXMuICovXG4gIGZvciAobiA9IDA7IG4gPD0gMzE7IG4rKywgYmxhY2tfbWFzayA+Pj49IDEpIHtcbiAgICBpZiAoKGJsYWNrX21hc2sgJiAxKSAmJiAocy5keW5fbHRyZWVbbiAqIDJdLyouRnJlcSovICE9PSAwKSkge1xuICAgICAgcmV0dXJuIFpfQklOQVJZO1xuICAgIH1cbiAgfVxuXG4gIC8qIENoZWNrIGZvciB0ZXh0dWFsIChcIndoaXRlLWxpc3RlZFwiKSBieXRlcy4gKi9cbiAgaWYgKHMuZHluX2x0cmVlWzkgKiAyXS8qLkZyZXEqLyAhPT0gMCB8fCBzLmR5bl9sdHJlZVsxMCAqIDJdLyouRnJlcSovICE9PSAwIHx8XG4gICAgICBzLmR5bl9sdHJlZVsxMyAqIDJdLyouRnJlcSovICE9PSAwKSB7XG4gICAgcmV0dXJuIFpfVEVYVDtcbiAgfVxuICBmb3IgKG4gPSAzMjsgbiA8IExJVEVSQUxTOyBuKyspIHtcbiAgICBpZiAocy5keW5fbHRyZWVbbiAqIDJdLyouRnJlcSovICE9PSAwKSB7XG4gICAgICByZXR1cm4gWl9URVhUO1xuICAgIH1cbiAgfVxuXG4gIC8qIFRoZXJlIGFyZSBubyBcImJsYWNrLWxpc3RlZFwiIG9yIFwid2hpdGUtbGlzdGVkXCIgYnl0ZXM6XG4gICAqIHRoaXMgc3RyZWFtIGVpdGhlciBpcyBlbXB0eSBvciBoYXMgdG9sZXJhdGVkIChcImdyYXktbGlzdGVkXCIpIGJ5dGVzIG9ubHkuXG4gICAqL1xuICByZXR1cm4gWl9CSU5BUlk7XG59XG5cblxudmFyIHN0YXRpY19pbml0X2RvbmUgPSBmYWxzZTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIHRoZSB0cmVlIGRhdGEgc3RydWN0dXJlcyBmb3IgYSBuZXcgemxpYiBzdHJlYW0uXG4gKi9cbmZ1bmN0aW9uIF90cl9pbml0KHMpXG57XG5cbiAgaWYgKCFzdGF0aWNfaW5pdF9kb25lKSB7XG4gICAgdHJfc3RhdGljX2luaXQoKTtcbiAgICBzdGF0aWNfaW5pdF9kb25lID0gdHJ1ZTtcbiAgfVxuXG4gIHMubF9kZXNjICA9IG5ldyBUcmVlRGVzYyhzLmR5bl9sdHJlZSwgc3RhdGljX2xfZGVzYyk7XG4gIHMuZF9kZXNjICA9IG5ldyBUcmVlRGVzYyhzLmR5bl9kdHJlZSwgc3RhdGljX2RfZGVzYyk7XG4gIHMuYmxfZGVzYyA9IG5ldyBUcmVlRGVzYyhzLmJsX3RyZWUsIHN0YXRpY19ibF9kZXNjKTtcblxuICBzLmJpX2J1ZiA9IDA7XG4gIHMuYmlfdmFsaWQgPSAwO1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIGZpcnN0IGJsb2NrIG9mIHRoZSBmaXJzdCBmaWxlOiAqL1xuICBpbml0X2Jsb2NrKHMpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBhIHN0b3JlZCBibG9ja1xuICovXG5mdW5jdGlvbiBfdHJfc3RvcmVkX2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdClcbi8vRGVmbGF0ZVN0YXRlICpzO1xuLy9jaGFyZiAqYnVmOyAgICAgICAvKiBpbnB1dCBibG9jayAqL1xuLy91bGcgc3RvcmVkX2xlbjsgICAvKiBsZW5ndGggb2YgaW5wdXQgYmxvY2sgKi9cbi8vaW50IGxhc3Q7ICAgICAgICAgLyogb25lIGlmIHRoaXMgaXMgdGhlIGxhc3QgYmxvY2sgZm9yIGEgZmlsZSAqL1xue1xuICBzZW5kX2JpdHMocywgKFNUT1JFRF9CTE9DSyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTsgICAgLyogc2VuZCBibG9jayB0eXBlICovXG4gIGNvcHlfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCB0cnVlKTsgLyogd2l0aCBoZWFkZXIgKi9cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgb25lIGVtcHR5IHN0YXRpYyBibG9jayB0byBnaXZlIGVub3VnaCBsb29rYWhlYWQgZm9yIGluZmxhdGUuXG4gKiBUaGlzIHRha2VzIDEwIGJpdHMsIG9mIHdoaWNoIDcgbWF5IHJlbWFpbiBpbiB0aGUgYml0IGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gX3RyX2FsaWduKHMpIHtcbiAgc2VuZF9iaXRzKHMsIFNUQVRJQ19UUkVFUyA8PCAxLCAzKTtcbiAgc2VuZF9jb2RlKHMsIEVORF9CTE9DSywgc3RhdGljX2x0cmVlKTtcbiAgYmlfZmx1c2gocyk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBEZXRlcm1pbmUgdGhlIGJlc3QgZW5jb2RpbmcgZm9yIHRoZSBjdXJyZW50IGJsb2NrOiBkeW5hbWljIHRyZWVzLCBzdGF0aWNcbiAqIHRyZWVzIG9yIHN0b3JlLCBhbmQgb3V0cHV0IHRoZSBlbmNvZGVkIGJsb2NrIHRvIHRoZSB6aXAgZmlsZS5cbiAqL1xuZnVuY3Rpb24gX3RyX2ZsdXNoX2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdClcbi8vRGVmbGF0ZVN0YXRlICpzO1xuLy9jaGFyZiAqYnVmOyAgICAgICAvKiBpbnB1dCBibG9jaywgb3IgTlVMTCBpZiB0b28gb2xkICovXG4vL3VsZyBzdG9yZWRfbGVuOyAgIC8qIGxlbmd0aCBvZiBpbnB1dCBibG9jayAqL1xuLy9pbnQgbGFzdDsgICAgICAgICAvKiBvbmUgaWYgdGhpcyBpcyB0aGUgbGFzdCBibG9jayBmb3IgYSBmaWxlICovXG57XG4gIHZhciBvcHRfbGVuYiwgc3RhdGljX2xlbmI7ICAvKiBvcHRfbGVuIGFuZCBzdGF0aWNfbGVuIGluIGJ5dGVzICovXG4gIHZhciBtYXhfYmxpbmRleCA9IDA7ICAgICAgICAvKiBpbmRleCBvZiBsYXN0IGJpdCBsZW5ndGggY29kZSBvZiBub24gemVybyBmcmVxICovXG5cbiAgLyogQnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgdW5sZXNzIGEgc3RvcmVkIGJsb2NrIGlzIGZvcmNlZCAqL1xuICBpZiAocy5sZXZlbCA+IDApIHtcblxuICAgIC8qIENoZWNrIGlmIHRoZSBmaWxlIGlzIGJpbmFyeSBvciB0ZXh0ICovXG4gICAgaWYgKHMuc3RybS5kYXRhX3R5cGUgPT09IFpfVU5LTk9XTikge1xuICAgICAgcy5zdHJtLmRhdGFfdHlwZSA9IGRldGVjdF9kYXRhX3R5cGUocyk7XG4gICAgfVxuXG4gICAgLyogQ29uc3RydWN0IHRoZSBsaXRlcmFsIGFuZCBkaXN0YW5jZSB0cmVlcyAqL1xuICAgIGJ1aWxkX3RyZWUocywgcy5sX2Rlc2MpO1xuICAgIC8vIFRyYWNldigoc3RkZXJyLCBcIlxcbmxpdCBkYXRhOiBkeW4gJWxkLCBzdGF0ICVsZFwiLCBzLT5vcHRfbGVuLFxuICAgIC8vICAgICAgICBzLT5zdGF0aWNfbGVuKSk7XG5cbiAgICBidWlsZF90cmVlKHMsIHMuZF9kZXNjKTtcbiAgICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJcXG5kaXN0IGRhdGE6IGR5biAlbGQsIHN0YXQgJWxkXCIsIHMtPm9wdF9sZW4sXG4gICAgLy8gICAgICAgIHMtPnN0YXRpY19sZW4pKTtcbiAgICAvKiBBdCB0aGlzIHBvaW50LCBvcHRfbGVuIGFuZCBzdGF0aWNfbGVuIGFyZSB0aGUgdG90YWwgYml0IGxlbmd0aHMgb2ZcbiAgICAgKiB0aGUgY29tcHJlc3NlZCBibG9jayBkYXRhLCBleGNsdWRpbmcgdGhlIHRyZWUgcmVwcmVzZW50YXRpb25zLlxuICAgICAqL1xuXG4gICAgLyogQnVpbGQgdGhlIGJpdCBsZW5ndGggdHJlZSBmb3IgdGhlIGFib3ZlIHR3byB0cmVlcywgYW5kIGdldCB0aGUgaW5kZXhcbiAgICAgKiBpbiBibF9vcmRlciBvZiB0aGUgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgdG8gc2VuZC5cbiAgICAgKi9cbiAgICBtYXhfYmxpbmRleCA9IGJ1aWxkX2JsX3RyZWUocyk7XG5cbiAgICAvKiBEZXRlcm1pbmUgdGhlIGJlc3QgZW5jb2RpbmcuIENvbXB1dGUgdGhlIGJsb2NrIGxlbmd0aHMgaW4gYnl0ZXMuICovXG4gICAgb3B0X2xlbmIgPSAocy5vcHRfbGVuICsgMyArIDcpID4+PiAzO1xuICAgIHN0YXRpY19sZW5iID0gKHMuc3RhdGljX2xlbiArIDMgKyA3KSA+Pj4gMztcblxuICAgIC8vIFRyYWNldigoc3RkZXJyLCBcIlxcbm9wdCAlbHUoJWx1KSBzdGF0ICVsdSglbHUpIHN0b3JlZCAlbHUgbGl0ICV1IFwiLFxuICAgIC8vICAgICAgICBvcHRfbGVuYiwgcy0+b3B0X2xlbiwgc3RhdGljX2xlbmIsIHMtPnN0YXRpY19sZW4sIHN0b3JlZF9sZW4sXG4gICAgLy8gICAgICAgIHMtPmxhc3RfbGl0KSk7XG5cbiAgICBpZiAoc3RhdGljX2xlbmIgPD0gb3B0X2xlbmIpIHsgb3B0X2xlbmIgPSBzdGF0aWNfbGVuYjsgfVxuXG4gIH0gZWxzZSB7XG4gICAgLy8gQXNzZXJ0KGJ1ZiAhPSAoY2hhciopMCwgXCJsb3N0IGJ1ZlwiKTtcbiAgICBvcHRfbGVuYiA9IHN0YXRpY19sZW5iID0gc3RvcmVkX2xlbiArIDU7IC8qIGZvcmNlIGEgc3RvcmVkIGJsb2NrICovXG4gIH1cblxuICBpZiAoKHN0b3JlZF9sZW4gKyA0IDw9IG9wdF9sZW5iKSAmJiAoYnVmICE9PSAtMSkpIHtcbiAgICAvKiA0OiB0d28gd29yZHMgZm9yIHRoZSBsZW5ndGhzICovXG5cbiAgICAvKiBUaGUgdGVzdCBidWYgIT0gTlVMTCBpcyBvbmx5IG5lY2Vzc2FyeSBpZiBMSVRfQlVGU0laRSA+IFdTSVpFLlxuICAgICAqIE90aGVyd2lzZSB3ZSBjYW4ndCBoYXZlIHByb2Nlc3NlZCBtb3JlIHRoYW4gV1NJWkUgaW5wdXQgYnl0ZXMgc2luY2VcbiAgICAgKiB0aGUgbGFzdCBibG9jayBmbHVzaCwgYmVjYXVzZSBjb21wcmVzc2lvbiB3b3VsZCBoYXZlIGJlZW5cbiAgICAgKiBzdWNjZXNzZnVsLiBJZiBMSVRfQlVGU0laRSA8PSBXU0laRSwgaXQgaXMgbmV2ZXIgdG9vIGxhdGUgdG9cbiAgICAgKiB0cmFuc2Zvcm0gYSBibG9jayBpbnRvIGEgc3RvcmVkIGJsb2NrLlxuICAgICAqL1xuICAgIF90cl9zdG9yZWRfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KTtcblxuICB9IGVsc2UgaWYgKHMuc3RyYXRlZ3kgPT09IFpfRklYRUQgfHwgc3RhdGljX2xlbmIgPT09IG9wdF9sZW5iKSB7XG5cbiAgICBzZW5kX2JpdHMocywgKFNUQVRJQ19UUkVFUyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTtcbiAgICBjb21wcmVzc19ibG9jayhzLCBzdGF0aWNfbHRyZWUsIHN0YXRpY19kdHJlZSk7XG5cbiAgfSBlbHNlIHtcbiAgICBzZW5kX2JpdHMocywgKERZTl9UUkVFUyA8PCAxKSArIChsYXN0ID8gMSA6IDApLCAzKTtcbiAgICBzZW5kX2FsbF90cmVlcyhzLCBzLmxfZGVzYy5tYXhfY29kZSArIDEsIHMuZF9kZXNjLm1heF9jb2RlICsgMSwgbWF4X2JsaW5kZXggKyAxKTtcbiAgICBjb21wcmVzc19ibG9jayhzLCBzLmR5bl9sdHJlZSwgcy5keW5fZHRyZWUpO1xuICB9XG4gIC8vIEFzc2VydCAocy0+Y29tcHJlc3NlZF9sZW4gPT0gcy0+Yml0c19zZW50LCBcImJhZCBjb21wcmVzc2VkIHNpemVcIik7XG4gIC8qIFRoZSBhYm92ZSBjaGVjayBpcyBtYWRlIG1vZCAyXjMyLCBmb3IgZmlsZXMgbGFyZ2VyIHRoYW4gNTEyIE1CXG4gICAqIGFuZCB1TG9uZyBpbXBsZW1lbnRlZCBvbiAzMiBiaXRzLlxuICAgKi9cbiAgaW5pdF9ibG9jayhzKTtcblxuICBpZiAobGFzdCkge1xuICAgIGJpX3dpbmR1cChzKTtcbiAgfVxuICAvLyBUcmFjZXYoKHN0ZGVycixcIlxcbmNvbXBybGVuICVsdSglbHUpIFwiLCBzLT5jb21wcmVzc2VkX2xlbj4+MyxcbiAgLy8gICAgICAgcy0+Y29tcHJlc3NlZF9sZW4tNypsYXN0KSk7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2F2ZSB0aGUgbWF0Y2ggaW5mbyBhbmQgdGFsbHkgdGhlIGZyZXF1ZW5jeSBjb3VudHMuIFJldHVybiB0cnVlIGlmXG4gKiB0aGUgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQuXG4gKi9cbmZ1bmN0aW9uIF90cl90YWxseShzLCBkaXN0LCBsYylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICB1bnNpZ25lZCBkaXN0OyAgLyogZGlzdGFuY2Ugb2YgbWF0Y2hlZCBzdHJpbmcgKi9cbi8vICAgIHVuc2lnbmVkIGxjOyAgICAvKiBtYXRjaCBsZW5ndGgtTUlOX01BVENIIG9yIHVubWF0Y2hlZCBjaGFyIChpZiBkaXN0PT0wKSAqL1xue1xuICAvL3ZhciBvdXRfbGVuZ3RoLCBpbl9sZW5ndGgsIGRjb2RlO1xuXG4gIHMucGVuZGluZ19idWZbcy5kX2J1ZiArIHMubGFzdF9saXQgKiAyXSAgICAgPSAoZGlzdCA+Pj4gOCkgJiAweGZmO1xuICBzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBzLmxhc3RfbGl0ICogMiArIDFdID0gZGlzdCAmIDB4ZmY7XG5cbiAgcy5wZW5kaW5nX2J1ZltzLmxfYnVmICsgcy5sYXN0X2xpdF0gPSBsYyAmIDB4ZmY7XG4gIHMubGFzdF9saXQrKztcblxuICBpZiAoZGlzdCA9PT0gMCkge1xuICAgIC8qIGxjIGlzIHRoZSB1bm1hdGNoZWQgY2hhciAqL1xuICAgIHMuZHluX2x0cmVlW2xjICogMl0vKi5GcmVxKi8rKztcbiAgfSBlbHNlIHtcbiAgICBzLm1hdGNoZXMrKztcbiAgICAvKiBIZXJlLCBsYyBpcyB0aGUgbWF0Y2ggbGVuZ3RoIC0gTUlOX01BVENIICovXG4gICAgZGlzdC0tOyAgICAgICAgICAgICAvKiBkaXN0ID0gbWF0Y2ggZGlzdGFuY2UgLSAxICovXG4gICAgLy9Bc3NlcnQoKHVzaClkaXN0IDwgKHVzaClNQVhfRElTVChzKSAmJlxuICAgIC8vICAgICAgICh1c2gpbGMgPD0gKHVzaCkoTUFYX01BVENILU1JTl9NQVRDSCkgJiZcbiAgICAvLyAgICAgICAodXNoKWRfY29kZShkaXN0KSA8ICh1c2gpRF9DT0RFUywgIFwiX3RyX3RhbGx5OiBiYWQgbWF0Y2hcIik7XG5cbiAgICBzLmR5bl9sdHJlZVsoX2xlbmd0aF9jb2RlW2xjXSArIExJVEVSQUxTICsgMSkgKiAyXS8qLkZyZXEqLysrO1xuICAgIHMuZHluX2R0cmVlW2RfY29kZShkaXN0KSAqIDJdLyouRnJlcSovKys7XG4gIH1cblxuLy8gKCEpIFRoaXMgYmxvY2sgaXMgZGlzYWJsZWQgaW4gemxpYiBkZWZhaWx0cyxcbi8vIGRvbid0IGVuYWJsZSBpdCBmb3IgYmluYXJ5IGNvbXBhdGliaWxpdHlcblxuLy8jaWZkZWYgVFJVTkNBVEVfQkxPQ0tcbi8vICAvKiBUcnkgdG8gZ3Vlc3MgaWYgaXQgaXMgcHJvZml0YWJsZSB0byBzdG9wIHRoZSBjdXJyZW50IGJsb2NrIGhlcmUgKi9cbi8vICBpZiAoKHMubGFzdF9saXQgJiAweDFmZmYpID09PSAwICYmIHMubGV2ZWwgPiAyKSB7XG4vLyAgICAvKiBDb21wdXRlIGFuIHVwcGVyIGJvdW5kIGZvciB0aGUgY29tcHJlc3NlZCBsZW5ndGggKi9cbi8vICAgIG91dF9sZW5ndGggPSBzLmxhc3RfbGl0Kjg7XG4vLyAgICBpbl9sZW5ndGggPSBzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydDtcbi8vXG4vLyAgICBmb3IgKGRjb2RlID0gMDsgZGNvZGUgPCBEX0NPREVTOyBkY29kZSsrKSB7XG4vLyAgICAgIG91dF9sZW5ndGggKz0gcy5keW5fZHRyZWVbZGNvZGUqMl0vKi5GcmVxKi8gKiAoNSArIGV4dHJhX2RiaXRzW2Rjb2RlXSk7XG4vLyAgICB9XG4vLyAgICBvdXRfbGVuZ3RoID4+Pj0gMztcbi8vICAgIC8vVHJhY2V2KChzdGRlcnIsXCJcXG5sYXN0X2xpdCAldSwgaW4gJWxkLCBvdXQgfiVsZCglbGQlJSkgXCIsXG4vLyAgICAvLyAgICAgICBzLT5sYXN0X2xpdCwgaW5fbGVuZ3RoLCBvdXRfbGVuZ3RoLFxuLy8gICAgLy8gICAgICAgMTAwTCAtIG91dF9sZW5ndGgqMTAwTC9pbl9sZW5ndGgpKTtcbi8vICAgIGlmIChzLm1hdGNoZXMgPCAocy5sYXN0X2xpdD4+MSkvKmludCAvMiovICYmIG91dF9sZW5ndGggPCAoaW5fbGVuZ3RoPj4xKS8qaW50IC8yKi8pIHtcbi8vICAgICAgcmV0dXJuIHRydWU7XG4vLyAgICB9XG4vLyAgfVxuLy8jZW5kaWZcblxuICByZXR1cm4gKHMubGFzdF9saXQgPT09IHMubGl0X2J1ZnNpemUgLSAxKTtcbiAgLyogV2UgYXZvaWQgZXF1YWxpdHkgd2l0aCBsaXRfYnVmc2l6ZSBiZWNhdXNlIG9mIHdyYXBhcm91bmQgYXQgNjRLXG4gICAqIG9uIDE2IGJpdCBtYWNoaW5lcyBhbmQgYmVjYXVzZSBzdG9yZWQgYmxvY2tzIGFyZSByZXN0cmljdGVkIHRvXG4gICAqIDY0Sy0xIGJ5dGVzLlxuICAgKi9cbn1cblxuZXhwb3J0cy5fdHJfaW5pdCAgPSBfdHJfaW5pdDtcbmV4cG9ydHMuX3RyX3N0b3JlZF9ibG9jayA9IF90cl9zdG9yZWRfYmxvY2s7XG5leHBvcnRzLl90cl9mbHVzaF9ibG9jayAgPSBfdHJfZmx1c2hfYmxvY2s7XG5leHBvcnRzLl90cl90YWxseSA9IF90cl90YWxseTtcbmV4cG9ydHMuX3RyX2FsaWduID0gX3RyX2FsaWduO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2pzemlwL34vcGFrby9saWIvemxpYi90cmVlcy5qc1xuLy8gbW9kdWxlIGlkID0gMTE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,exports,__webpack_require__){"use strict";eval("\nvar Promise = __webpack_require__(10);\nvar reject = __webpack_require__(30);\nvar resolve = __webpack_require__(31);\nvar INTERNAL = __webpack_require__(9);\nvar handlers = __webpack_require__(4);\nmodule.exports = all;\nfunction all(iterable) {\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return resolve([]);\n  }\n\n  var values = new Array(len);\n  var resolved = 0;\n  var i = -1;\n  var promise = new Promise(INTERNAL);\n  \n  while (++i < len) {\n    allResolver(iterable[i], i);\n  }\n  return promise;\n  function allResolver(value, i) {\n    resolve(value).then(resolveFromAll, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n    function resolveFromAll(outValue) {\n      values[i] = outValue;\n      if (++resolved === len & !called) {\n        called = true;\n        handlers.resolve(promise, values);\n      }\n    }\n  }\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2xpZS9saWIvYWxsLmpzP2Q5YzAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxMTUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgUHJvbWlzZSA9IHJlcXVpcmUoJy4vcHJvbWlzZScpO1xudmFyIHJlamVjdCA9IHJlcXVpcmUoJy4vcmVqZWN0Jyk7XG52YXIgcmVzb2x2ZSA9IHJlcXVpcmUoJy4vcmVzb2x2ZScpO1xudmFyIElOVEVSTkFMID0gcmVxdWlyZSgnLi9JTlRFUk5BTCcpO1xudmFyIGhhbmRsZXJzID0gcmVxdWlyZSgnLi9oYW5kbGVycycpO1xubW9kdWxlLmV4cG9ydHMgPSBhbGw7XG5mdW5jdGlvbiBhbGwoaXRlcmFibGUpIHtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpdGVyYWJsZSkgIT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICByZXR1cm4gcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ211c3QgYmUgYW4gYXJyYXknKSk7XG4gIH1cblxuICB2YXIgbGVuID0gaXRlcmFibGUubGVuZ3RoO1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIGlmICghbGVuKSB7XG4gICAgcmV0dXJuIHJlc29sdmUoW10pO1xuICB9XG5cbiAgdmFyIHZhbHVlcyA9IG5ldyBBcnJheShsZW4pO1xuICB2YXIgcmVzb2x2ZWQgPSAwO1xuICB2YXIgaSA9IC0xO1xuICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKElOVEVSTkFMKTtcbiAgXG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICBhbGxSZXNvbHZlcihpdGVyYWJsZVtpXSwgaSk7XG4gIH1cbiAgcmV0dXJuIHByb21pc2U7XG4gIGZ1bmN0aW9uIGFsbFJlc29sdmVyKHZhbHVlLCBpKSB7XG4gICAgcmVzb2x2ZSh2YWx1ZSkudGhlbihyZXNvbHZlRnJvbUFsbCwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICBoYW5kbGVycy5yZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIHJlc29sdmVGcm9tQWxsKG91dFZhbHVlKSB7XG4gICAgICB2YWx1ZXNbaV0gPSBvdXRWYWx1ZTtcbiAgICAgIGlmICgrK3Jlc29sdmVkID09PSBsZW4gJiAhY2FsbGVkKSB7XG4gICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgIGhhbmRsZXJzLnJlc29sdmUocHJvbWlzZSwgdmFsdWVzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbGllL2xpYi9hbGwuanNcbi8vIG1vZHVsZSBpZCA9IDExNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){"use strict";eval("\nvar handlers = __webpack_require__(4);\nvar unwrap = __webpack_require__(58);\n\nmodule.exports = QueueItem;\nfunction QueueItem(promise, onFulfilled, onRejected) {\n  this.promise = promise;\n  if (typeof onFulfilled === 'function') {\n    this.onFulfilled = onFulfilled;\n    this.callFulfilled = this.otherCallFulfilled;\n  }\n  if (typeof onRejected === 'function') {\n    this.onRejected = onRejected;\n    this.callRejected = this.otherCallRejected;\n  }\n}\nQueueItem.prototype.callFulfilled = function (value) {\n  handlers.resolve(this.promise, value);\n};\nQueueItem.prototype.otherCallFulfilled = function (value) {\n  unwrap(this.promise, this.onFulfilled, value);\n};\nQueueItem.prototype.callRejected = function (value) {\n  handlers.reject(this.promise, value);\n};\nQueueItem.prototype.otherCallRejected = function (value) {\n  unwrap(this.promise, this.onRejected, value);\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2xpZS9saWIvcXVldWVJdGVtLmpzP2Y2YTMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxMTYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgaGFuZGxlcnMgPSByZXF1aXJlKCcuL2hhbmRsZXJzJyk7XG52YXIgdW53cmFwID0gcmVxdWlyZSgnLi91bndyYXAnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBRdWV1ZUl0ZW07XG5mdW5jdGlvbiBRdWV1ZUl0ZW0ocHJvbWlzZSwgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgaWYgKHR5cGVvZiBvbkZ1bGZpbGxlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMub25GdWxmaWxsZWQgPSBvbkZ1bGZpbGxlZDtcbiAgICB0aGlzLmNhbGxGdWxmaWxsZWQgPSB0aGlzLm90aGVyQ2FsbEZ1bGZpbGxlZDtcbiAgfVxuICBpZiAodHlwZW9mIG9uUmVqZWN0ZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLm9uUmVqZWN0ZWQgPSBvblJlamVjdGVkO1xuICAgIHRoaXMuY2FsbFJlamVjdGVkID0gdGhpcy5vdGhlckNhbGxSZWplY3RlZDtcbiAgfVxufVxuUXVldWVJdGVtLnByb3RvdHlwZS5jYWxsRnVsZmlsbGVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIGhhbmRsZXJzLnJlc29sdmUodGhpcy5wcm9taXNlLCB2YWx1ZSk7XG59O1xuUXVldWVJdGVtLnByb3RvdHlwZS5vdGhlckNhbGxGdWxmaWxsZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgdW53cmFwKHRoaXMucHJvbWlzZSwgdGhpcy5vbkZ1bGZpbGxlZCwgdmFsdWUpO1xufTtcblF1ZXVlSXRlbS5wcm90b3R5cGUuY2FsbFJlamVjdGVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIGhhbmRsZXJzLnJlamVjdCh0aGlzLnByb21pc2UsIHZhbHVlKTtcbn07XG5RdWV1ZUl0ZW0ucHJvdG90eXBlLm90aGVyQ2FsbFJlamVjdGVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHVud3JhcCh0aGlzLnByb21pc2UsIHRoaXMub25SZWplY3RlZCwgdmFsdWUpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9saWUvbGliL3F1ZXVlSXRlbS5qc1xuLy8gbW9kdWxlIGlkID0gMTE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){"use strict";eval("\nvar Promise = __webpack_require__(10);\nvar reject = __webpack_require__(30);\nvar resolve = __webpack_require__(31);\nvar INTERNAL = __webpack_require__(9);\nvar handlers = __webpack_require__(4);\nmodule.exports = race;\nfunction race(iterable) {\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return resolve([]);\n  }\n\n  var i = -1;\n  var promise = new Promise(INTERNAL);\n\n  while (++i < len) {\n    resolver(iterable[i]);\n  }\n  return promise;\n  function resolver(value) {\n    resolve(value).then(function (response) {\n      if (!called) {\n        called = true;\n        handlers.resolve(promise, response);\n      }\n    }, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n  }\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2xpZS9saWIvcmFjZS5qcz9mMTkxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJmaWxlIjoiMTE3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xudmFyIFByb21pc2UgPSByZXF1aXJlKCcuL3Byb21pc2UnKTtcbnZhciByZWplY3QgPSByZXF1aXJlKCcuL3JlamVjdCcpO1xudmFyIHJlc29sdmUgPSByZXF1aXJlKCcuL3Jlc29sdmUnKTtcbnZhciBJTlRFUk5BTCA9IHJlcXVpcmUoJy4vSU5URVJOQUwnKTtcbnZhciBoYW5kbGVycyA9IHJlcXVpcmUoJy4vaGFuZGxlcnMnKTtcbm1vZHVsZS5leHBvcnRzID0gcmFjZTtcbmZ1bmN0aW9uIHJhY2UoaXRlcmFibGUpIHtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpdGVyYWJsZSkgIT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICByZXR1cm4gcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ211c3QgYmUgYW4gYXJyYXknKSk7XG4gIH1cblxuICB2YXIgbGVuID0gaXRlcmFibGUubGVuZ3RoO1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIGlmICghbGVuKSB7XG4gICAgcmV0dXJuIHJlc29sdmUoW10pO1xuICB9XG5cbiAgdmFyIGkgPSAtMTtcbiAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShJTlRFUk5BTCk7XG5cbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIHJlc29sdmVyKGl0ZXJhYmxlW2ldKTtcbiAgfVxuICByZXR1cm4gcHJvbWlzZTtcbiAgZnVuY3Rpb24gcmVzb2x2ZXIodmFsdWUpIHtcbiAgICByZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgaGFuZGxlcnMucmVzb2x2ZShwcm9taXNlLCByZXNwb25zZSk7XG4gICAgICB9XG4gICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICBoYW5kbGVycy5yZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbGllL2xpYi9yYWNlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports){eval(';(function () { // closure for web browsers\n\nif (typeof module === \'object\' && module.exports) {\n  module.exports = LRUCache\n} else {\n  // just set the global for non-node platforms.\n  this.LRUCache = LRUCache\n}\n\nfunction hOP (obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key)\n}\n\nfunction naiveLength () { return 1 }\n\nvar didTypeWarning = false\nfunction typeCheckKey(key) {\n  if (!didTypeWarning && typeof key !== \'string\' && typeof key !== \'number\') {\n    didTypeWarning = true\n    console.error(new TypeError("LRU: key must be a string or number. Almost certainly a bug! " + typeof key).stack)\n  }\n}\n\nfunction LRUCache (options) {\n  if (!(this instanceof LRUCache))\n    return new LRUCache(options)\n\n  if (typeof options === \'number\')\n    options = { max: options }\n\n  if (!options)\n    options = {}\n\n  this._max = options.max\n  // Kind of weird to have a default max of Infinity, but oh well.\n  if (!this._max || !(typeof this._max === "number") || this._max <= 0 )\n    this._max = Infinity\n\n  this._lengthCalculator = options.length || naiveLength\n  if (typeof this._lengthCalculator !== "function")\n    this._lengthCalculator = naiveLength\n\n  this._allowStale = options.stale || false\n  this._maxAge = options.maxAge || null\n  this._dispose = options.dispose\n  this.reset()\n}\n\n// resize the cache when the max changes.\nObject.defineProperty(LRUCache.prototype, "max",\n  { set : function (mL) {\n      if (!mL || !(typeof mL === "number") || mL <= 0 ) mL = Infinity\n      this._max = mL\n      if (this._length > this._max) trim(this)\n    }\n  , get : function () { return this._max }\n  , enumerable : true\n  })\n\n// resize the cache when the lengthCalculator changes.\nObject.defineProperty(LRUCache.prototype, "lengthCalculator",\n  { set : function (lC) {\n      if (typeof lC !== "function") {\n        this._lengthCalculator = naiveLength\n        this._length = this._itemCount\n        for (var key in this._cache) {\n          this._cache[key].length = 1\n        }\n      } else {\n        this._lengthCalculator = lC\n        this._length = 0\n        for (var key in this._cache) {\n          this._cache[key].length = this._lengthCalculator(this._cache[key].value)\n          this._length += this._cache[key].length\n        }\n      }\n\n      if (this._length > this._max) trim(this)\n    }\n  , get : function () { return this._lengthCalculator }\n  , enumerable : true\n  })\n\nObject.defineProperty(LRUCache.prototype, "length",\n  { get : function () { return this._length }\n  , enumerable : true\n  })\n\n\nObject.defineProperty(LRUCache.prototype, "itemCount",\n  { get : function () { return this._itemCount }\n  , enumerable : true\n  })\n\nLRUCache.prototype.forEach = function (fn, thisp) {\n  thisp = thisp || this\n  var i = 0\n  var itemCount = this._itemCount\n\n  for (var k = this._mru - 1; k >= 0 && i < itemCount; k--) if (this._lruList[k]) {\n    i++\n    var hit = this._lruList[k]\n    if (isStale(this, hit)) {\n      del(this, hit)\n      if (!this._allowStale) hit = undefined\n    }\n    if (hit) {\n      fn.call(thisp, hit.value, hit.key, this)\n    }\n  }\n}\n\nLRUCache.prototype.keys = function () {\n  var keys = new Array(this._itemCount)\n  var i = 0\n  for (var k = this._mru - 1; k >= 0 && i < this._itemCount; k--) if (this._lruList[k]) {\n    var hit = this._lruList[k]\n    keys[i++] = hit.key\n  }\n  return keys\n}\n\nLRUCache.prototype.values = function () {\n  var values = new Array(this._itemCount)\n  var i = 0\n  for (var k = this._mru - 1; k >= 0 && i < this._itemCount; k--) if (this._lruList[k]) {\n    var hit = this._lruList[k]\n    values[i++] = hit.value\n  }\n  return values\n}\n\nLRUCache.prototype.reset = function () {\n  if (this._dispose && this._cache) {\n    for (var k in this._cache) {\n      this._dispose(k, this._cache[k].value)\n    }\n  }\n\n  this._cache = Object.create(null) // hash of items by key\n  this._lruList = Object.create(null) // list of items in order of use recency\n  this._mru = 0 // most recently used\n  this._lru = 0 // least recently used\n  this._length = 0 // number of items in the list\n  this._itemCount = 0\n}\n\nLRUCache.prototype.dump = function () {\n  var arr = []\n  var i = 0\n\n  for (var k = this._mru - 1; k >= 0 && i < this._itemCount; k--) if (this._lruList[k]) {\n    var hit = this._lruList[k]\n    if (!isStale(this, hit)) {\n      //Do not store staled hits\n      ++i\n      arr.push({\n        k: hit.key,\n        v: hit.value,\n        e: hit.now + (hit.maxAge || 0)\n      });\n    }\n  }\n  //arr has the most read first\n  return arr\n}\n\nLRUCache.prototype.dumpLru = function () {\n  return this._lruList\n}\n\nLRUCache.prototype.set = function (key, value, maxAge) {\n  maxAge = maxAge || this._maxAge\n  typeCheckKey(key)\n\n  var now = maxAge ? Date.now() : 0\n  var len = this._lengthCalculator(value)\n\n  if (hOP(this._cache, key)) {\n    if (len > this._max) {\n      del(this, this._cache[key])\n      return false\n    }\n    // dispose of the old one before overwriting\n    if (this._dispose)\n      this._dispose(key, this._cache[key].value)\n\n    this._cache[key].now = now\n    this._cache[key].maxAge = maxAge\n    this._cache[key].value = value\n    this._length += (len - this._cache[key].length)\n    this._cache[key].length = len\n    this.get(key)\n\n    if (this._length > this._max)\n      trim(this)\n\n    return true\n  }\n\n  var hit = new Entry(key, value, this._mru++, len, now, maxAge)\n\n  // oversized objects fall out of cache automatically.\n  if (hit.length > this._max) {\n    if (this._dispose) this._dispose(key, value)\n    return false\n  }\n\n  this._length += hit.length\n  this._lruList[hit.lu] = this._cache[key] = hit\n  this._itemCount ++\n\n  if (this._length > this._max)\n    trim(this)\n\n  return true\n}\n\nLRUCache.prototype.has = function (key) {\n  typeCheckKey(key)\n  if (!hOP(this._cache, key)) return false\n  var hit = this._cache[key]\n  if (isStale(this, hit)) {\n    return false\n  }\n  return true\n}\n\nLRUCache.prototype.get = function (key) {\n  typeCheckKey(key)\n  return get(this, key, true)\n}\n\nLRUCache.prototype.peek = function (key) {\n  typeCheckKey(key)\n  return get(this, key, false)\n}\n\nLRUCache.prototype.pop = function () {\n  var hit = this._lruList[this._lru]\n  del(this, hit)\n  return hit || null\n}\n\nLRUCache.prototype.del = function (key) {\n  typeCheckKey(key)\n  del(this, this._cache[key])\n}\n\nLRUCache.prototype.load = function (arr) {\n  //reset the cache\n  this.reset();\n\n  var now = Date.now()\n  //A previous serialized cache has the most recent items first\n  for (var l = arr.length - 1; l >= 0; l-- ) {\n    var hit = arr[l]\n    typeCheckKey(hit.k)\n    var expiresAt = hit.e || 0\n    if (expiresAt === 0) {\n      //the item was created without expiration in a non aged cache\n      this.set(hit.k, hit.v)\n    } else {\n      var maxAge = expiresAt - now\n      //dont add already expired items\n      if (maxAge > 0) this.set(hit.k, hit.v, maxAge)\n    }\n  }\n}\n\nfunction get (self, key, doUse) {\n  typeCheckKey(key)\n  var hit = self._cache[key]\n  if (hit) {\n    if (isStale(self, hit)) {\n      del(self, hit)\n      if (!self._allowStale) hit = undefined\n    } else {\n      if (doUse) use(self, hit)\n    }\n    if (hit) hit = hit.value\n  }\n  return hit\n}\n\nfunction isStale(self, hit) {\n  if (!hit || (!hit.maxAge && !self._maxAge)) return false\n  var stale = false;\n  var diff = Date.now() - hit.now\n  if (hit.maxAge) {\n    stale = diff > hit.maxAge\n  } else {\n    stale = self._maxAge && (diff > self._maxAge)\n  }\n  return stale;\n}\n\nfunction use (self, hit) {\n  shiftLU(self, hit)\n  hit.lu = self._mru ++\n  self._lruList[hit.lu] = hit\n}\n\nfunction trim (self) {\n  while (self._lru < self._mru && self._length > self._max)\n    del(self, self._lruList[self._lru])\n}\n\nfunction shiftLU (self, hit) {\n  delete self._lruList[ hit.lu ]\n  while (self._lru < self._mru && !self._lruList[self._lru]) self._lru ++\n}\n\nfunction del (self, hit) {\n  if (hit) {\n    if (self._dispose) self._dispose(hit.key, hit.value)\n    self._length -= hit.length\n    self._itemCount --\n    delete self._cache[ hit.key ]\n    shiftLU(self, hit)\n  }\n}\n\n// classy, since V8 prefers predictable objects.\nfunction Entry (key, value, lu, length, now, maxAge) {\n  this.key = key\n  this.value = value\n  this.lu = lu\n  this.length = length\n  this.now = now\n  if (maxAge) this.maxAge = maxAge\n}\n\n})()\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2xydS1jYWNoZS9saWIvbHJ1LWNhY2hlLmpzPzEwMDUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsQ0FBQyxjQUFjOztBQUVmO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWU7O0FBRWY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLEdBQUcsb0JBQW9CO0FBQ3ZCO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQSxHQUFHLG9CQUFvQjtBQUN2QjtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCLHlCQUF5QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwrQkFBK0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsK0JBQStCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkIsK0JBQStCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QixRQUFRO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyIsImZpbGUiOiIxMTguanMiLCJzb3VyY2VzQ29udGVudCI6WyI7KGZ1bmN0aW9uICgpIHsgLy8gY2xvc3VyZSBmb3Igd2ViIGJyb3dzZXJzXG5cbmlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cyA9IExSVUNhY2hlXG59IGVsc2Uge1xuICAvLyBqdXN0IHNldCB0aGUgZ2xvYmFsIGZvciBub24tbm9kZSBwbGF0Zm9ybXMuXG4gIHRoaXMuTFJVQ2FjaGUgPSBMUlVDYWNoZVxufVxuXG5mdW5jdGlvbiBoT1AgKG9iaiwga2V5KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpXG59XG5cbmZ1bmN0aW9uIG5haXZlTGVuZ3RoICgpIHsgcmV0dXJuIDEgfVxuXG52YXIgZGlkVHlwZVdhcm5pbmcgPSBmYWxzZVxuZnVuY3Rpb24gdHlwZUNoZWNrS2V5KGtleSkge1xuICBpZiAoIWRpZFR5cGVXYXJuaW5nICYmIHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnICYmIHR5cGVvZiBrZXkgIT09ICdudW1iZXInKSB7XG4gICAgZGlkVHlwZVdhcm5pbmcgPSB0cnVlXG4gICAgY29uc29sZS5lcnJvcihuZXcgVHlwZUVycm9yKFwiTFJVOiBrZXkgbXVzdCBiZSBhIHN0cmluZyBvciBudW1iZXIuIEFsbW9zdCBjZXJ0YWlubHkgYSBidWchIFwiICsgdHlwZW9mIGtleSkuc3RhY2spXG4gIH1cbn1cblxuZnVuY3Rpb24gTFJVQ2FjaGUgKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIExSVUNhY2hlKSlcbiAgICByZXR1cm4gbmV3IExSVUNhY2hlKG9wdGlvbnMpXG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnbnVtYmVyJylcbiAgICBvcHRpb25zID0geyBtYXg6IG9wdGlvbnMgfVxuXG4gIGlmICghb3B0aW9ucylcbiAgICBvcHRpb25zID0ge31cblxuICB0aGlzLl9tYXggPSBvcHRpb25zLm1heFxuICAvLyBLaW5kIG9mIHdlaXJkIHRvIGhhdmUgYSBkZWZhdWx0IG1heCBvZiBJbmZpbml0eSwgYnV0IG9oIHdlbGwuXG4gIGlmICghdGhpcy5fbWF4IHx8ICEodHlwZW9mIHRoaXMuX21heCA9PT0gXCJudW1iZXJcIikgfHwgdGhpcy5fbWF4IDw9IDAgKVxuICAgIHRoaXMuX21heCA9IEluZmluaXR5XG5cbiAgdGhpcy5fbGVuZ3RoQ2FsY3VsYXRvciA9IG9wdGlvbnMubGVuZ3RoIHx8IG5haXZlTGVuZ3RoXG4gIGlmICh0eXBlb2YgdGhpcy5fbGVuZ3RoQ2FsY3VsYXRvciAhPT0gXCJmdW5jdGlvblwiKVxuICAgIHRoaXMuX2xlbmd0aENhbGN1bGF0b3IgPSBuYWl2ZUxlbmd0aFxuXG4gIHRoaXMuX2FsbG93U3RhbGUgPSBvcHRpb25zLnN0YWxlIHx8IGZhbHNlXG4gIHRoaXMuX21heEFnZSA9IG9wdGlvbnMubWF4QWdlIHx8IG51bGxcbiAgdGhpcy5fZGlzcG9zZSA9IG9wdGlvbnMuZGlzcG9zZVxuICB0aGlzLnJlc2V0KClcbn1cblxuLy8gcmVzaXplIHRoZSBjYWNoZSB3aGVuIHRoZSBtYXggY2hhbmdlcy5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShMUlVDYWNoZS5wcm90b3R5cGUsIFwibWF4XCIsXG4gIHsgc2V0IDogZnVuY3Rpb24gKG1MKSB7XG4gICAgICBpZiAoIW1MIHx8ICEodHlwZW9mIG1MID09PSBcIm51bWJlclwiKSB8fCBtTCA8PSAwICkgbUwgPSBJbmZpbml0eVxuICAgICAgdGhpcy5fbWF4ID0gbUxcbiAgICAgIGlmICh0aGlzLl9sZW5ndGggPiB0aGlzLl9tYXgpIHRyaW0odGhpcylcbiAgICB9XG4gICwgZ2V0IDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbWF4IH1cbiAgLCBlbnVtZXJhYmxlIDogdHJ1ZVxuICB9KVxuXG4vLyByZXNpemUgdGhlIGNhY2hlIHdoZW4gdGhlIGxlbmd0aENhbGN1bGF0b3IgY2hhbmdlcy5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShMUlVDYWNoZS5wcm90b3R5cGUsIFwibGVuZ3RoQ2FsY3VsYXRvclwiLFxuICB7IHNldCA6IGZ1bmN0aW9uIChsQykge1xuICAgICAgaWYgKHR5cGVvZiBsQyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRoaXMuX2xlbmd0aENhbGN1bGF0b3IgPSBuYWl2ZUxlbmd0aFxuICAgICAgICB0aGlzLl9sZW5ndGggPSB0aGlzLl9pdGVtQ291bnRcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuX2NhY2hlKSB7XG4gICAgICAgICAgdGhpcy5fY2FjaGVba2V5XS5sZW5ndGggPSAxXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2xlbmd0aENhbGN1bGF0b3IgPSBsQ1xuICAgICAgICB0aGlzLl9sZW5ndGggPSAwXG4gICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLl9jYWNoZSkge1xuICAgICAgICAgIHRoaXMuX2NhY2hlW2tleV0ubGVuZ3RoID0gdGhpcy5fbGVuZ3RoQ2FsY3VsYXRvcih0aGlzLl9jYWNoZVtrZXldLnZhbHVlKVxuICAgICAgICAgIHRoaXMuX2xlbmd0aCArPSB0aGlzLl9jYWNoZVtrZXldLmxlbmd0aFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9sZW5ndGggPiB0aGlzLl9tYXgpIHRyaW0odGhpcylcbiAgICB9XG4gICwgZ2V0IDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fbGVuZ3RoQ2FsY3VsYXRvciB9XG4gICwgZW51bWVyYWJsZSA6IHRydWVcbiAgfSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KExSVUNhY2hlLnByb3RvdHlwZSwgXCJsZW5ndGhcIixcbiAgeyBnZXQgOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9sZW5ndGggfVxuICAsIGVudW1lcmFibGUgOiB0cnVlXG4gIH0pXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KExSVUNhY2hlLnByb3RvdHlwZSwgXCJpdGVtQ291bnRcIixcbiAgeyBnZXQgOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9pdGVtQ291bnQgfVxuICAsIGVudW1lcmFibGUgOiB0cnVlXG4gIH0pXG5cbkxSVUNhY2hlLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGZuLCB0aGlzcCkge1xuICB0aGlzcCA9IHRoaXNwIHx8IHRoaXNcbiAgdmFyIGkgPSAwXG4gIHZhciBpdGVtQ291bnQgPSB0aGlzLl9pdGVtQ291bnRcblxuICBmb3IgKHZhciBrID0gdGhpcy5fbXJ1IC0gMTsgayA+PSAwICYmIGkgPCBpdGVtQ291bnQ7IGstLSkgaWYgKHRoaXMuX2xydUxpc3Rba10pIHtcbiAgICBpKytcbiAgICB2YXIgaGl0ID0gdGhpcy5fbHJ1TGlzdFtrXVxuICAgIGlmIChpc1N0YWxlKHRoaXMsIGhpdCkpIHtcbiAgICAgIGRlbCh0aGlzLCBoaXQpXG4gICAgICBpZiAoIXRoaXMuX2FsbG93U3RhbGUpIGhpdCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgICBpZiAoaGl0KSB7XG4gICAgICBmbi5jYWxsKHRoaXNwLCBoaXQudmFsdWUsIGhpdC5rZXksIHRoaXMpXG4gICAgfVxuICB9XG59XG5cbkxSVUNhY2hlLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24gKCkge1xuICB2YXIga2V5cyA9IG5ldyBBcnJheSh0aGlzLl9pdGVtQ291bnQpXG4gIHZhciBpID0gMFxuICBmb3IgKHZhciBrID0gdGhpcy5fbXJ1IC0gMTsgayA+PSAwICYmIGkgPCB0aGlzLl9pdGVtQ291bnQ7IGstLSkgaWYgKHRoaXMuX2xydUxpc3Rba10pIHtcbiAgICB2YXIgaGl0ID0gdGhpcy5fbHJ1TGlzdFtrXVxuICAgIGtleXNbaSsrXSA9IGhpdC5rZXlcbiAgfVxuICByZXR1cm4ga2V5c1xufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdmFsdWVzID0gbmV3IEFycmF5KHRoaXMuX2l0ZW1Db3VudClcbiAgdmFyIGkgPSAwXG4gIGZvciAodmFyIGsgPSB0aGlzLl9tcnUgLSAxOyBrID49IDAgJiYgaSA8IHRoaXMuX2l0ZW1Db3VudDsgay0tKSBpZiAodGhpcy5fbHJ1TGlzdFtrXSkge1xuICAgIHZhciBoaXQgPSB0aGlzLl9scnVMaXN0W2tdXG4gICAgdmFsdWVzW2krK10gPSBoaXQudmFsdWVcbiAgfVxuICByZXR1cm4gdmFsdWVzXG59XG5cbkxSVUNhY2hlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuX2Rpc3Bvc2UgJiYgdGhpcy5fY2FjaGUpIHtcbiAgICBmb3IgKHZhciBrIGluIHRoaXMuX2NhY2hlKSB7XG4gICAgICB0aGlzLl9kaXNwb3NlKGssIHRoaXMuX2NhY2hlW2tdLnZhbHVlKVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuX2NhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKSAvLyBoYXNoIG9mIGl0ZW1zIGJ5IGtleVxuICB0aGlzLl9scnVMaXN0ID0gT2JqZWN0LmNyZWF0ZShudWxsKSAvLyBsaXN0IG9mIGl0ZW1zIGluIG9yZGVyIG9mIHVzZSByZWNlbmN5XG4gIHRoaXMuX21ydSA9IDAgLy8gbW9zdCByZWNlbnRseSB1c2VkXG4gIHRoaXMuX2xydSA9IDAgLy8gbGVhc3QgcmVjZW50bHkgdXNlZFxuICB0aGlzLl9sZW5ndGggPSAwIC8vIG51bWJlciBvZiBpdGVtcyBpbiB0aGUgbGlzdFxuICB0aGlzLl9pdGVtQ291bnQgPSAwXG59XG5cbkxSVUNhY2hlLnByb3RvdHlwZS5kdW1wID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYXJyID0gW11cbiAgdmFyIGkgPSAwXG5cbiAgZm9yICh2YXIgayA9IHRoaXMuX21ydSAtIDE7IGsgPj0gMCAmJiBpIDwgdGhpcy5faXRlbUNvdW50OyBrLS0pIGlmICh0aGlzLl9scnVMaXN0W2tdKSB7XG4gICAgdmFyIGhpdCA9IHRoaXMuX2xydUxpc3Rba11cbiAgICBpZiAoIWlzU3RhbGUodGhpcywgaGl0KSkge1xuICAgICAgLy9EbyBub3Qgc3RvcmUgc3RhbGVkIGhpdHNcbiAgICAgICsraVxuICAgICAgYXJyLnB1c2goe1xuICAgICAgICBrOiBoaXQua2V5LFxuICAgICAgICB2OiBoaXQudmFsdWUsXG4gICAgICAgIGU6IGhpdC5ub3cgKyAoaGl0Lm1heEFnZSB8fCAwKVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8vYXJyIGhhcyB0aGUgbW9zdCByZWFkIGZpcnN0XG4gIHJldHVybiBhcnJcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLmR1bXBMcnUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9scnVMaXN0XG59XG5cbkxSVUNhY2hlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgbWF4QWdlKSB7XG4gIG1heEFnZSA9IG1heEFnZSB8fCB0aGlzLl9tYXhBZ2VcbiAgdHlwZUNoZWNrS2V5KGtleSlcblxuICB2YXIgbm93ID0gbWF4QWdlID8gRGF0ZS5ub3coKSA6IDBcbiAgdmFyIGxlbiA9IHRoaXMuX2xlbmd0aENhbGN1bGF0b3IodmFsdWUpXG5cbiAgaWYgKGhPUCh0aGlzLl9jYWNoZSwga2V5KSkge1xuICAgIGlmIChsZW4gPiB0aGlzLl9tYXgpIHtcbiAgICAgIGRlbCh0aGlzLCB0aGlzLl9jYWNoZVtrZXldKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIC8vIGRpc3Bvc2Ugb2YgdGhlIG9sZCBvbmUgYmVmb3JlIG92ZXJ3cml0aW5nXG4gICAgaWYgKHRoaXMuX2Rpc3Bvc2UpXG4gICAgICB0aGlzLl9kaXNwb3NlKGtleSwgdGhpcy5fY2FjaGVba2V5XS52YWx1ZSlcblxuICAgIHRoaXMuX2NhY2hlW2tleV0ubm93ID0gbm93XG4gICAgdGhpcy5fY2FjaGVba2V5XS5tYXhBZ2UgPSBtYXhBZ2VcbiAgICB0aGlzLl9jYWNoZVtrZXldLnZhbHVlID0gdmFsdWVcbiAgICB0aGlzLl9sZW5ndGggKz0gKGxlbiAtIHRoaXMuX2NhY2hlW2tleV0ubGVuZ3RoKVxuICAgIHRoaXMuX2NhY2hlW2tleV0ubGVuZ3RoID0gbGVuXG4gICAgdGhpcy5nZXQoa2V5KVxuXG4gICAgaWYgKHRoaXMuX2xlbmd0aCA+IHRoaXMuX21heClcbiAgICAgIHRyaW0odGhpcylcblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICB2YXIgaGl0ID0gbmV3IEVudHJ5KGtleSwgdmFsdWUsIHRoaXMuX21ydSsrLCBsZW4sIG5vdywgbWF4QWdlKVxuXG4gIC8vIG92ZXJzaXplZCBvYmplY3RzIGZhbGwgb3V0IG9mIGNhY2hlIGF1dG9tYXRpY2FsbHkuXG4gIGlmIChoaXQubGVuZ3RoID4gdGhpcy5fbWF4KSB7XG4gICAgaWYgKHRoaXMuX2Rpc3Bvc2UpIHRoaXMuX2Rpc3Bvc2Uoa2V5LCB2YWx1ZSlcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHRoaXMuX2xlbmd0aCArPSBoaXQubGVuZ3RoXG4gIHRoaXMuX2xydUxpc3RbaGl0Lmx1XSA9IHRoaXMuX2NhY2hlW2tleV0gPSBoaXRcbiAgdGhpcy5faXRlbUNvdW50ICsrXG5cbiAgaWYgKHRoaXMuX2xlbmd0aCA+IHRoaXMuX21heClcbiAgICB0cmltKHRoaXMpXG5cbiAgcmV0dXJuIHRydWVcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgdHlwZUNoZWNrS2V5KGtleSlcbiAgaWYgKCFoT1AodGhpcy5fY2FjaGUsIGtleSkpIHJldHVybiBmYWxzZVxuICB2YXIgaGl0ID0gdGhpcy5fY2FjaGVba2V5XVxuICBpZiAoaXNTdGFsZSh0aGlzLCBoaXQpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgdHlwZUNoZWNrS2V5KGtleSlcbiAgcmV0dXJuIGdldCh0aGlzLCBrZXksIHRydWUpXG59XG5cbkxSVUNhY2hlLnByb3RvdHlwZS5wZWVrID0gZnVuY3Rpb24gKGtleSkge1xuICB0eXBlQ2hlY2tLZXkoa2V5KVxuICByZXR1cm4gZ2V0KHRoaXMsIGtleSwgZmFsc2UpXG59XG5cbkxSVUNhY2hlLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBoaXQgPSB0aGlzLl9scnVMaXN0W3RoaXMuX2xydV1cbiAgZGVsKHRoaXMsIGhpdClcbiAgcmV0dXJuIGhpdCB8fCBudWxsXG59XG5cbkxSVUNhY2hlLnByb3RvdHlwZS5kZWwgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHR5cGVDaGVja0tleShrZXkpXG4gIGRlbCh0aGlzLCB0aGlzLl9jYWNoZVtrZXldKVxufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgLy9yZXNldCB0aGUgY2FjaGVcbiAgdGhpcy5yZXNldCgpO1xuXG4gIHZhciBub3cgPSBEYXRlLm5vdygpXG4gIC8vQSBwcmV2aW91cyBzZXJpYWxpemVkIGNhY2hlIGhhcyB0aGUgbW9zdCByZWNlbnQgaXRlbXMgZmlyc3RcbiAgZm9yICh2YXIgbCA9IGFyci5sZW5ndGggLSAxOyBsID49IDA7IGwtLSApIHtcbiAgICB2YXIgaGl0ID0gYXJyW2xdXG4gICAgdHlwZUNoZWNrS2V5KGhpdC5rKVxuICAgIHZhciBleHBpcmVzQXQgPSBoaXQuZSB8fCAwXG4gICAgaWYgKGV4cGlyZXNBdCA9PT0gMCkge1xuICAgICAgLy90aGUgaXRlbSB3YXMgY3JlYXRlZCB3aXRob3V0IGV4cGlyYXRpb24gaW4gYSBub24gYWdlZCBjYWNoZVxuICAgICAgdGhpcy5zZXQoaGl0LmssIGhpdC52KVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbWF4QWdlID0gZXhwaXJlc0F0IC0gbm93XG4gICAgICAvL2RvbnQgYWRkIGFscmVhZHkgZXhwaXJlZCBpdGVtc1xuICAgICAgaWYgKG1heEFnZSA+IDApIHRoaXMuc2V0KGhpdC5rLCBoaXQudiwgbWF4QWdlKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXQgKHNlbGYsIGtleSwgZG9Vc2UpIHtcbiAgdHlwZUNoZWNrS2V5KGtleSlcbiAgdmFyIGhpdCA9IHNlbGYuX2NhY2hlW2tleV1cbiAgaWYgKGhpdCkge1xuICAgIGlmIChpc1N0YWxlKHNlbGYsIGhpdCkpIHtcbiAgICAgIGRlbChzZWxmLCBoaXQpXG4gICAgICBpZiAoIXNlbGYuX2FsbG93U3RhbGUpIGhpdCA9IHVuZGVmaW5lZFxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZG9Vc2UpIHVzZShzZWxmLCBoaXQpXG4gICAgfVxuICAgIGlmIChoaXQpIGhpdCA9IGhpdC52YWx1ZVxuICB9XG4gIHJldHVybiBoaXRcbn1cblxuZnVuY3Rpb24gaXNTdGFsZShzZWxmLCBoaXQpIHtcbiAgaWYgKCFoaXQgfHwgKCFoaXQubWF4QWdlICYmICFzZWxmLl9tYXhBZ2UpKSByZXR1cm4gZmFsc2VcbiAgdmFyIHN0YWxlID0gZmFsc2U7XG4gIHZhciBkaWZmID0gRGF0ZS5ub3coKSAtIGhpdC5ub3dcbiAgaWYgKGhpdC5tYXhBZ2UpIHtcbiAgICBzdGFsZSA9IGRpZmYgPiBoaXQubWF4QWdlXG4gIH0gZWxzZSB7XG4gICAgc3RhbGUgPSBzZWxmLl9tYXhBZ2UgJiYgKGRpZmYgPiBzZWxmLl9tYXhBZ2UpXG4gIH1cbiAgcmV0dXJuIHN0YWxlO1xufVxuXG5mdW5jdGlvbiB1c2UgKHNlbGYsIGhpdCkge1xuICBzaGlmdExVKHNlbGYsIGhpdClcbiAgaGl0Lmx1ID0gc2VsZi5fbXJ1ICsrXG4gIHNlbGYuX2xydUxpc3RbaGl0Lmx1XSA9IGhpdFxufVxuXG5mdW5jdGlvbiB0cmltIChzZWxmKSB7XG4gIHdoaWxlIChzZWxmLl9scnUgPCBzZWxmLl9tcnUgJiYgc2VsZi5fbGVuZ3RoID4gc2VsZi5fbWF4KVxuICAgIGRlbChzZWxmLCBzZWxmLl9scnVMaXN0W3NlbGYuX2xydV0pXG59XG5cbmZ1bmN0aW9uIHNoaWZ0TFUgKHNlbGYsIGhpdCkge1xuICBkZWxldGUgc2VsZi5fbHJ1TGlzdFsgaGl0Lmx1IF1cbiAgd2hpbGUgKHNlbGYuX2xydSA8IHNlbGYuX21ydSAmJiAhc2VsZi5fbHJ1TGlzdFtzZWxmLl9scnVdKSBzZWxmLl9scnUgKytcbn1cblxuZnVuY3Rpb24gZGVsIChzZWxmLCBoaXQpIHtcbiAgaWYgKGhpdCkge1xuICAgIGlmIChzZWxmLl9kaXNwb3NlKSBzZWxmLl9kaXNwb3NlKGhpdC5rZXksIGhpdC52YWx1ZSlcbiAgICBzZWxmLl9sZW5ndGggLT0gaGl0Lmxlbmd0aFxuICAgIHNlbGYuX2l0ZW1Db3VudCAtLVxuICAgIGRlbGV0ZSBzZWxmLl9jYWNoZVsgaGl0LmtleSBdXG4gICAgc2hpZnRMVShzZWxmLCBoaXQpXG4gIH1cbn1cblxuLy8gY2xhc3N5LCBzaW5jZSBWOCBwcmVmZXJzIHByZWRpY3RhYmxlIG9iamVjdHMuXG5mdW5jdGlvbiBFbnRyeSAoa2V5LCB2YWx1ZSwgbHUsIGxlbmd0aCwgbm93LCBtYXhBZ2UpIHtcbiAgdGhpcy5rZXkgPSBrZXlcbiAgdGhpcy52YWx1ZSA9IHZhbHVlXG4gIHRoaXMubHUgPSBsdVxuICB0aGlzLmxlbmd0aCA9IGxlbmd0aFxuICB0aGlzLm5vdyA9IG5vd1xuICBpZiAobWF4QWdlKSB0aGlzLm1heEFnZSA9IG1heEFnZVxufVxuXG59KSgpXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbHJ1LWNhY2hlL2xpYi9scnUtY2FjaGUuanNcbi8vIG1vZHVsZSBpZCA9IDExOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9')},function(module,exports){eval("function dbfHeader(buffer){\n\tvar data = new DataView(buffer);\n\tvar out = {};\n\tout.lastUpdated = new Date(data.getUint8(1,true)+1900,data.getUint8(2,true),data.getUint8(3,true));\n\tout.records = data.getUint32(4,true);\n\tout.headerLen = data.getUint16(8,true);\n\tout.recLen = data.getUint16(10,true);\n\treturn out;\n}\n\nfunction dbfRowHeader(buffer){\n\tvar data = new DataView(buffer);\n\tvar out = [];\n\tvar offset = 32;\n\twhile(true){\n\t\tout.push({\n\t\t\tname : String.fromCharCode.apply(this,(new Uint8Array(buffer,offset,10))).replace(/\\0|\\s+$/g,''),\n\t\t\tdataType : String.fromCharCode(data.getUint8(offset+11)),\n\t\t\tlen : data.getUint8(offset+16),\n\t\t\tdecimal : data.getUint8(offset+17)\n\t\t});\n\t\tif(data.getUint8(offset+32)===13){\n\t\t\tbreak;\n\t\t}else{\n\t\t\toffset+=32;\n\t\t}\n\t}\n\treturn out;\n}\nfunction rowFuncs(buffer,offset,len,type){\n\tvar data = (new Uint8Array(buffer,offset,len));\n\tvar textData = String.fromCharCode.apply(this,data).replace(/\\0|\\s+$/g,'');\n\tswitch(type){\n\t\tcase 'N':\n\t\tcase 'F':\n\t\tcase 'O':\n\t\t\treturn parseFloat(textData,10);\n\t\tcase 'D':\n\t\t\treturn new Date(textData.slice(0,4), parseInt(textData.slice(4,6),10)-1, textData.slice(6,8));\n\t\tcase 'L':\n\t\t\treturn textData.toLowerCase() === 'y' || textData.toLowerCase() === 't';\n\t\tdefault:\n\t\t\treturn textData;\n\t}\n}\nfunction parseRow(buffer,offset,rowHeaders){\n\tvar out={};\n\tvar i = 0;\n\tvar len = rowHeaders.length;\n\tvar field;\n\tvar header;\n\twhile(i<len){\n\t\theader = rowHeaders[i];\n\t\tfield = rowFuncs(buffer,offset,header.len,header.dataType);\n\t\toffset += header.len;\n\t\tif(typeof field !== 'undefined'){\n\t\t\tout[header.name]=field;\n\t\t}\n\t\ti++;\n\t}\n\treturn out;\n}\nmodule.exports = function(buffer){\n\tvar rowHeaders = dbfRowHeader(buffer);\n\tvar header = dbfHeader(buffer);\n\tvar offset = ((rowHeaders.length+1)<<5)+2;\n\tvar recLen = header.recLen;\n\tvar records = header.records;\n\tvar out = [];\n\twhile(records){\n\t\tout.push(parseRow(buffer,offset,rowHeaders));\n\t\toffset += recLen;\n\t\trecords--;\n\t}\n\treturn out;\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3BhcnNlZGJmL2luZGV4LmpzP2RiYjgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTE5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gZGJmSGVhZGVyKGJ1ZmZlcil7XG5cdHZhciBkYXRhID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG5cdHZhciBvdXQgPSB7fTtcblx0b3V0Lmxhc3RVcGRhdGVkID0gbmV3IERhdGUoZGF0YS5nZXRVaW50OCgxLHRydWUpKzE5MDAsZGF0YS5nZXRVaW50OCgyLHRydWUpLGRhdGEuZ2V0VWludDgoMyx0cnVlKSk7XG5cdG91dC5yZWNvcmRzID0gZGF0YS5nZXRVaW50MzIoNCx0cnVlKTtcblx0b3V0LmhlYWRlckxlbiA9IGRhdGEuZ2V0VWludDE2KDgsdHJ1ZSk7XG5cdG91dC5yZWNMZW4gPSBkYXRhLmdldFVpbnQxNigxMCx0cnVlKTtcblx0cmV0dXJuIG91dDtcbn1cblxuZnVuY3Rpb24gZGJmUm93SGVhZGVyKGJ1ZmZlcil7XG5cdHZhciBkYXRhID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG5cdHZhciBvdXQgPSBbXTtcblx0dmFyIG9mZnNldCA9IDMyO1xuXHR3aGlsZSh0cnVlKXtcblx0XHRvdXQucHVzaCh7XG5cdFx0XHRuYW1lIDogU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseSh0aGlzLChuZXcgVWludDhBcnJheShidWZmZXIsb2Zmc2V0LDEwKSkpLnJlcGxhY2UoL1xcMHxcXHMrJC9nLCcnKSxcblx0XHRcdGRhdGFUeXBlIDogU3RyaW5nLmZyb21DaGFyQ29kZShkYXRhLmdldFVpbnQ4KG9mZnNldCsxMSkpLFxuXHRcdFx0bGVuIDogZGF0YS5nZXRVaW50OChvZmZzZXQrMTYpLFxuXHRcdFx0ZGVjaW1hbCA6IGRhdGEuZ2V0VWludDgob2Zmc2V0KzE3KVxuXHRcdH0pO1xuXHRcdGlmKGRhdGEuZ2V0VWludDgob2Zmc2V0KzMyKT09PTEzKXtcblx0XHRcdGJyZWFrO1xuXHRcdH1lbHNle1xuXHRcdFx0b2Zmc2V0Kz0zMjtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG91dDtcbn1cbmZ1bmN0aW9uIHJvd0Z1bmNzKGJ1ZmZlcixvZmZzZXQsbGVuLHR5cGUpe1xuXHR2YXIgZGF0YSA9IChuZXcgVWludDhBcnJheShidWZmZXIsb2Zmc2V0LGxlbikpO1xuXHR2YXIgdGV4dERhdGEgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KHRoaXMsZGF0YSkucmVwbGFjZSgvXFwwfFxccyskL2csJycpO1xuXHRzd2l0Y2godHlwZSl7XG5cdFx0Y2FzZSAnTic6XG5cdFx0Y2FzZSAnRic6XG5cdFx0Y2FzZSAnTyc6XG5cdFx0XHRyZXR1cm4gcGFyc2VGbG9hdCh0ZXh0RGF0YSwxMCk7XG5cdFx0Y2FzZSAnRCc6XG5cdFx0XHRyZXR1cm4gbmV3IERhdGUodGV4dERhdGEuc2xpY2UoMCw0KSwgcGFyc2VJbnQodGV4dERhdGEuc2xpY2UoNCw2KSwxMCktMSwgdGV4dERhdGEuc2xpY2UoNiw4KSk7XG5cdFx0Y2FzZSAnTCc6XG5cdFx0XHRyZXR1cm4gdGV4dERhdGEudG9Mb3dlckNhc2UoKSA9PT0gJ3knIHx8IHRleHREYXRhLnRvTG93ZXJDYXNlKCkgPT09ICd0Jztcblx0XHRkZWZhdWx0OlxuXHRcdFx0cmV0dXJuIHRleHREYXRhO1xuXHR9XG59XG5mdW5jdGlvbiBwYXJzZVJvdyhidWZmZXIsb2Zmc2V0LHJvd0hlYWRlcnMpe1xuXHR2YXIgb3V0PXt9O1xuXHR2YXIgaSA9IDA7XG5cdHZhciBsZW4gPSByb3dIZWFkZXJzLmxlbmd0aDtcblx0dmFyIGZpZWxkO1xuXHR2YXIgaGVhZGVyO1xuXHR3aGlsZShpPGxlbil7XG5cdFx0aGVhZGVyID0gcm93SGVhZGVyc1tpXTtcblx0XHRmaWVsZCA9IHJvd0Z1bmNzKGJ1ZmZlcixvZmZzZXQsaGVhZGVyLmxlbixoZWFkZXIuZGF0YVR5cGUpO1xuXHRcdG9mZnNldCArPSBoZWFkZXIubGVuO1xuXHRcdGlmKHR5cGVvZiBmaWVsZCAhPT0gJ3VuZGVmaW5lZCcpe1xuXHRcdFx0b3V0W2hlYWRlci5uYW1lXT1maWVsZDtcblx0XHR9XG5cdFx0aSsrO1xuXHR9XG5cdHJldHVybiBvdXQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGJ1ZmZlcil7XG5cdHZhciByb3dIZWFkZXJzID0gZGJmUm93SGVhZGVyKGJ1ZmZlcik7XG5cdHZhciBoZWFkZXIgPSBkYmZIZWFkZXIoYnVmZmVyKTtcblx0dmFyIG9mZnNldCA9ICgocm93SGVhZGVycy5sZW5ndGgrMSk8PDUpKzI7XG5cdHZhciByZWNMZW4gPSBoZWFkZXIucmVjTGVuO1xuXHR2YXIgcmVjb3JkcyA9IGhlYWRlci5yZWNvcmRzO1xuXHR2YXIgb3V0ID0gW107XG5cdHdoaWxlKHJlY29yZHMpe1xuXHRcdG91dC5wdXNoKHBhcnNlUm93KGJ1ZmZlcixvZmZzZXQscm93SGVhZGVycykpO1xuXHRcdG9mZnNldCArPSByZWNMZW47XG5cdFx0cmVjb3Jkcy0tO1xuXHR9XG5cdHJldHVybiBvdXQ7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3BhcnNlZGJmL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("var mgrs = __webpack_require__(59);\n\nfunction Point(x, y, z) {\n  if (!(this instanceof Point)) {\n    return new Point(x, y, z);\n  }\n  if (Array.isArray(x)) {\n    this.x = x[0];\n    this.y = x[1];\n    this.z = x[2] || 0.0;\n  } else if(typeof x === 'object') {\n    this.x = x.x;\n    this.y = x.y;\n    this.z = x.z || 0.0;\n  } else if (typeof x === 'string' && typeof y === 'undefined') {\n    var coords = x.split(',');\n    this.x = parseFloat(coords[0], 10);\n    this.y = parseFloat(coords[1], 10);\n    this.z = parseFloat(coords[2], 10) || 0.0;\n  } else {\n    this.x = x;\n    this.y = y;\n    this.z = z || 0.0;\n  }\n  console.warn('proj4.Point will be removed in version 3, use proj4.toPoint');\n}\n\nPoint.fromMGRS = function(mgrsStr) {\n  return new Point(mgrs.toPoint(mgrsStr));\n};\nPoint.prototype.toMGRS = function(accuracy) {\n  return mgrs.forward([this.x, this.y], accuracy);\n};\nmodule.exports = Point;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9Qb2ludC5qcz8xYjA4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxMjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgbWdycyA9IHJlcXVpcmUoJ21ncnMnKTtcblxuZnVuY3Rpb24gUG9pbnQoeCwgeSwgeikge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUG9pbnQpKSB7XG4gICAgcmV0dXJuIG5ldyBQb2ludCh4LCB5LCB6KTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh4KSkge1xuICAgIHRoaXMueCA9IHhbMF07XG4gICAgdGhpcy55ID0geFsxXTtcbiAgICB0aGlzLnogPSB4WzJdIHx8IDAuMDtcbiAgfSBlbHNlIGlmKHR5cGVvZiB4ID09PSAnb2JqZWN0Jykge1xuICAgIHRoaXMueCA9IHgueDtcbiAgICB0aGlzLnkgPSB4Lnk7XG4gICAgdGhpcy56ID0geC56IHx8IDAuMDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgeCA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIHkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIGNvb3JkcyA9IHguc3BsaXQoJywnKTtcbiAgICB0aGlzLnggPSBwYXJzZUZsb2F0KGNvb3Jkc1swXSwgMTApO1xuICAgIHRoaXMueSA9IHBhcnNlRmxvYXQoY29vcmRzWzFdLCAxMCk7XG4gICAgdGhpcy56ID0gcGFyc2VGbG9hdChjb29yZHNbMl0sIDEwKSB8fCAwLjA7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHRoaXMueiA9IHogfHwgMC4wO1xuICB9XG4gIGNvbnNvbGUud2FybigncHJvajQuUG9pbnQgd2lsbCBiZSByZW1vdmVkIGluIHZlcnNpb24gMywgdXNlIHByb2o0LnRvUG9pbnQnKTtcbn1cblxuUG9pbnQuZnJvbU1HUlMgPSBmdW5jdGlvbihtZ3JzU3RyKSB7XG4gIHJldHVybiBuZXcgUG9pbnQobWdycy50b1BvaW50KG1ncnNTdHIpKTtcbn07XG5Qb2ludC5wcm90b3R5cGUudG9NR1JTID0gZnVuY3Rpb24oYWNjdXJhY3kpIHtcbiAgcmV0dXJuIG1ncnMuZm9yd2FyZChbdGhpcy54LCB0aGlzLnldLCBhY2N1cmFjeSk7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBQb2ludDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcm9qNC9saWIvUG9pbnQuanNcbi8vIG1vZHVsZSBpZCA9IDEyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports){eval("module.exports = function(crs, denorm, point) {\n  var xin = point.x,\n    yin = point.y,\n    zin = point.z || 0.0;\n  var v, t, i;\n  for (i = 0; i < 3; i++) {\n    if (denorm && i === 2 && point.z === undefined) {\n      continue;\n    }\n    if (i === 0) {\n      v = xin;\n      t = 'x';\n    }\n    else if (i === 1) {\n      v = yin;\n      t = 'y';\n    }\n    else {\n      v = zin;\n      t = 'z';\n    }\n    switch (crs.axis[i]) {\n    case 'e':\n      point[t] = v;\n      break;\n    case 'w':\n      point[t] = -v;\n      break;\n    case 'n':\n      point[t] = v;\n      break;\n    case 's':\n      point[t] = -v;\n      break;\n    case 'u':\n      if (point[t] !== undefined) {\n        point.z = v;\n      }\n      break;\n    case 'd':\n      if (point[t] !== undefined) {\n        point.z = -v;\n      }\n      break;\n    default:\n      //console.log(\"ERROR: unknow axis (\"+crs.axis[i]+\") - check definition of \"+crs.projName);\n      return null;\n    }\n  }\n  return point;\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9hZGp1c3RfYXhpcy5qcz8wY2Q4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjEyMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY3JzLCBkZW5vcm0sIHBvaW50KSB7XG4gIHZhciB4aW4gPSBwb2ludC54LFxuICAgIHlpbiA9IHBvaW50LnksXG4gICAgemluID0gcG9pbnQueiB8fCAwLjA7XG4gIHZhciB2LCB0LCBpO1xuICBmb3IgKGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgaWYgKGRlbm9ybSAmJiBpID09PSAyICYmIHBvaW50LnogPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChpID09PSAwKSB7XG4gICAgICB2ID0geGluO1xuICAgICAgdCA9ICd4JztcbiAgICB9XG4gICAgZWxzZSBpZiAoaSA9PT0gMSkge1xuICAgICAgdiA9IHlpbjtcbiAgICAgIHQgPSAneSc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdiA9IHppbjtcbiAgICAgIHQgPSAneic7XG4gICAgfVxuICAgIHN3aXRjaCAoY3JzLmF4aXNbaV0pIHtcbiAgICBjYXNlICdlJzpcbiAgICAgIHBvaW50W3RdID0gdjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3cnOlxuICAgICAgcG9pbnRbdF0gPSAtdjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ24nOlxuICAgICAgcG9pbnRbdF0gPSB2O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncyc6XG4gICAgICBwb2ludFt0XSA9IC12O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndSc6XG4gICAgICBpZiAocG9pbnRbdF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwb2ludC56ID0gdjtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2QnOlxuICAgICAgaWYgKHBvaW50W3RdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcG9pbnQueiA9IC12O1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIC8vY29uc29sZS5sb2coXCJFUlJPUjogdW5rbm93IGF4aXMgKFwiK2Nycy5heGlzW2ldK1wiKSAtIGNoZWNrIGRlZmluaXRpb24gb2YgXCIrY3JzLnByb2pOYW1lKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcG9pbnQ7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Byb2o0L2xpYi9hZGp1c3RfYXhpcy5qc1xuLy8gbW9kdWxlIGlkID0gMTIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports){eval('var HALF_PI = Math.PI/2;\n\nmodule.exports = function(eccent, q) {\n  var temp = 1 - (1 - eccent * eccent) / (2 * eccent) * Math.log((1 - eccent) / (1 + eccent));\n  if (Math.abs(Math.abs(q) - temp) < 1.0E-6) {\n    if (q < 0) {\n      return (-1 * HALF_PI);\n    }\n    else {\n      return HALF_PI;\n    }\n  }\n  //var phi = 0.5* q/(1-eccent*eccent);\n  var phi = Math.asin(0.5 * q);\n  var dphi;\n  var sin_phi;\n  var cos_phi;\n  var con;\n  for (var i = 0; i < 30; i++) {\n    sin_phi = Math.sin(phi);\n    cos_phi = Math.cos(phi);\n    con = eccent * sin_phi;\n    dphi = Math.pow(1 - con * con, 2) / (2 * cos_phi) * (q / (1 - eccent * eccent) - sin_phi / (1 - con * con) + 0.5 / eccent * Math.log((1 - con) / (1 + con)));\n    phi += dphi;\n    if (Math.abs(dphi) <= 0.0000000001) {\n      return phi;\n    }\n  }\n\n  //console.log("IQSFN-CONV:Latitude failed to converge after 30 iterations");\n  return NaN;\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9jb21tb24vaXFzZm56LmpzP2M5MDAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwiZmlsZSI6IjEyMi5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBIQUxGX1BJID0gTWF0aC5QSS8yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGVjY2VudCwgcSkge1xuICB2YXIgdGVtcCA9IDEgLSAoMSAtIGVjY2VudCAqIGVjY2VudCkgLyAoMiAqIGVjY2VudCkgKiBNYXRoLmxvZygoMSAtIGVjY2VudCkgLyAoMSArIGVjY2VudCkpO1xuICBpZiAoTWF0aC5hYnMoTWF0aC5hYnMocSkgLSB0ZW1wKSA8IDEuMEUtNikge1xuICAgIGlmIChxIDwgMCkge1xuICAgICAgcmV0dXJuICgtMSAqIEhBTEZfUEkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBIQUxGX1BJO1xuICAgIH1cbiAgfVxuICAvL3ZhciBwaGkgPSAwLjUqIHEvKDEtZWNjZW50KmVjY2VudCk7XG4gIHZhciBwaGkgPSBNYXRoLmFzaW4oMC41ICogcSk7XG4gIHZhciBkcGhpO1xuICB2YXIgc2luX3BoaTtcbiAgdmFyIGNvc19waGk7XG4gIHZhciBjb247XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMzA7IGkrKykge1xuICAgIHNpbl9waGkgPSBNYXRoLnNpbihwaGkpO1xuICAgIGNvc19waGkgPSBNYXRoLmNvcyhwaGkpO1xuICAgIGNvbiA9IGVjY2VudCAqIHNpbl9waGk7XG4gICAgZHBoaSA9IE1hdGgucG93KDEgLSBjb24gKiBjb24sIDIpIC8gKDIgKiBjb3NfcGhpKSAqIChxIC8gKDEgLSBlY2NlbnQgKiBlY2NlbnQpIC0gc2luX3BoaSAvICgxIC0gY29uICogY29uKSArIDAuNSAvIGVjY2VudCAqIE1hdGgubG9nKCgxIC0gY29uKSAvICgxICsgY29uKSkpO1xuICAgIHBoaSArPSBkcGhpO1xuICAgIGlmIChNYXRoLmFicyhkcGhpKSA8PSAwLjAwMDAwMDAwMDEpIHtcbiAgICAgIHJldHVybiBwaGk7XG4gICAgfVxuICB9XG5cbiAgLy9jb25zb2xlLmxvZyhcIklRU0ZOLUNPTlY6TGF0aXR1ZGUgZmFpbGVkIHRvIGNvbnZlcmdlIGFmdGVyIDMwIGl0ZXJhdGlvbnNcIik7XG4gIHJldHVybiBOYU47XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcm9qNC9saWIvY29tbW9uL2lxc2Zuei5qc1xuLy8gbW9kdWxlIGlkID0gMTIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,exports){eval("var C00 = 1;\nvar C02 = 0.25;\nvar C04 = 0.046875;\nvar C06 = 0.01953125;\nvar C08 = 0.01068115234375;\nvar C22 = 0.75;\nvar C44 = 0.46875;\nvar C46 = 0.01302083333333333333;\nvar C48 = 0.00712076822916666666;\nvar C66 = 0.36458333333333333333;\nvar C68 = 0.00569661458333333333;\nvar C88 = 0.3076171875;\n\nmodule.exports = function(es) {\n  var en = [];\n  en[0] = C00 - es * (C02 + es * (C04 + es * (C06 + es * C08)));\n  en[1] = es * (C22 - es * (C04 + es * (C06 + es * C08)));\n  var t = es * es;\n  en[2] = t * (C44 - es * (C46 + es * C48));\n  t *= es;\n  en[3] = t * (C66 - es * C68);\n  en[4] = t * es * C88;\n  return en;\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9jb21tb24vcGpfZW5mbi5qcz9lMzM2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjEyMy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBDMDAgPSAxO1xudmFyIEMwMiA9IDAuMjU7XG52YXIgQzA0ID0gMC4wNDY4NzU7XG52YXIgQzA2ID0gMC4wMTk1MzEyNTtcbnZhciBDMDggPSAwLjAxMDY4MTE1MjM0Mzc1O1xudmFyIEMyMiA9IDAuNzU7XG52YXIgQzQ0ID0gMC40Njg3NTtcbnZhciBDNDYgPSAwLjAxMzAyMDgzMzMzMzMzMzMzMzMzO1xudmFyIEM0OCA9IDAuMDA3MTIwNzY4MjI5MTY2NjY2NjY7XG52YXIgQzY2ID0gMC4zNjQ1ODMzMzMzMzMzMzMzMzMzMztcbnZhciBDNjggPSAwLjAwNTY5NjYxNDU4MzMzMzMzMzMzO1xudmFyIEM4OCA9IDAuMzA3NjE3MTg3NTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihlcykge1xuICB2YXIgZW4gPSBbXTtcbiAgZW5bMF0gPSBDMDAgLSBlcyAqIChDMDIgKyBlcyAqIChDMDQgKyBlcyAqIChDMDYgKyBlcyAqIEMwOCkpKTtcbiAgZW5bMV0gPSBlcyAqIChDMjIgLSBlcyAqIChDMDQgKyBlcyAqIChDMDYgKyBlcyAqIEMwOCkpKTtcbiAgdmFyIHQgPSBlcyAqIGVzO1xuICBlblsyXSA9IHQgKiAoQzQ0IC0gZXMgKiAoQzQ2ICsgZXMgKiBDNDgpKTtcbiAgdCAqPSBlcztcbiAgZW5bM10gPSB0ICogKEM2NiAtIGVzICogQzY4KTtcbiAgZW5bNF0gPSB0ICogZXMgKiBDODg7XG4gIHJldHVybiBlbjtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Byb2o0L2xpYi9jb21tb24vcGpfZW5mbi5qc1xuLy8gbW9kdWxlIGlkID0gMTIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval('var pj_mlfn = __webpack_require__(60);\nvar EPSLN = 1.0e-10;\nvar MAX_ITER = 20;\nmodule.exports = function(arg, es, en) {\n  var k = 1 / (1 - es);\n  var phi = arg;\n  for (var i = MAX_ITER; i; --i) { /* rarely goes over 2 iterations */\n    var s = Math.sin(phi);\n    var t = 1 - es * s * s;\n    //t = this.pj_mlfn(phi, s, Math.cos(phi), en) - arg;\n    //phi -= t * (t * Math.sqrt(t)) * k;\n    t = (pj_mlfn(phi, s, Math.cos(phi), en) - arg) * (t * Math.sqrt(t)) * k;\n    phi -= t;\n    if (Math.abs(t) < EPSLN) {\n      return phi;\n    }\n  }\n  //..reportError("cass:pj_inv_mlfn: Convergence error");\n  return phi;\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9jb21tb24vcGpfaW52X21sZm4uanM/NzA5NyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsR0FBRyxPQUFPO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjEyNC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBwal9tbGZuID0gcmVxdWlyZShcIi4vcGpfbWxmblwiKTtcbnZhciBFUFNMTiA9IDEuMGUtMTA7XG52YXIgTUFYX0lURVIgPSAyMDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXJnLCBlcywgZW4pIHtcbiAgdmFyIGsgPSAxIC8gKDEgLSBlcyk7XG4gIHZhciBwaGkgPSBhcmc7XG4gIGZvciAodmFyIGkgPSBNQVhfSVRFUjsgaTsgLS1pKSB7IC8qIHJhcmVseSBnb2VzIG92ZXIgMiBpdGVyYXRpb25zICovXG4gICAgdmFyIHMgPSBNYXRoLnNpbihwaGkpO1xuICAgIHZhciB0ID0gMSAtIGVzICogcyAqIHM7XG4gICAgLy90ID0gdGhpcy5wal9tbGZuKHBoaSwgcywgTWF0aC5jb3MocGhpKSwgZW4pIC0gYXJnO1xuICAgIC8vcGhpIC09IHQgKiAodCAqIE1hdGguc3FydCh0KSkgKiBrO1xuICAgIHQgPSAocGpfbWxmbihwaGksIHMsIE1hdGguY29zKHBoaSksIGVuKSAtIGFyZykgKiAodCAqIE1hdGguc3FydCh0KSkgKiBrO1xuICAgIHBoaSAtPSB0O1xuICAgIGlmIChNYXRoLmFicyh0KSA8IEVQU0xOKSB7XG4gICAgICByZXR1cm4gcGhpO1xuICAgIH1cbiAgfVxuICAvLy4ucmVwb3J0RXJyb3IoXCJjYXNzOnBqX2ludl9tbGZuOiBDb252ZXJnZW5jZSBlcnJvclwiKTtcbiAgcmV0dXJuIHBoaTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Byb2o0L2xpYi9jb21tb24vcGpfaW52X21sZm4uanNcbi8vIG1vZHVsZSBpZCA9IDEyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9')},function(module,exports){eval("module.exports = function(esinp, exp) {\n  return (Math.pow((1 - esinp) / (1 + esinp), exp));\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9jb21tb24vc3JhdC5qcz84NzM0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSIsImZpbGUiOiIxMjUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGVzaW5wLCBleHApIHtcbiAgcmV0dXJuIChNYXRoLnBvdygoMSAtIGVzaW5wKSAvICgxICsgZXNpbnApLCBleHApKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Byb2o0L2xpYi9jb21tb24vc3JhdC5qc1xuLy8gbW9kdWxlIGlkID0gMTI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports){eval('exports.wgs84 = {\n  towgs84: "0,0,0",\n  ellipse: "WGS84",\n  datumName: "WGS84"\n};\nexports.ch1903 = {\n  towgs84: "674.374,15.056,405.346",\n  ellipse: "bessel",\n  datumName: "swiss"\n};\nexports.ggrs87 = {\n  towgs84: "-199.87,74.79,246.62",\n  ellipse: "GRS80",\n  datumName: "Greek_Geodetic_Reference_System_1987"\n};\nexports.nad83 = {\n  towgs84: "0,0,0",\n  ellipse: "GRS80",\n  datumName: "North_American_Datum_1983"\n};\nexports.nad27 = {\n  nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",\n  ellipse: "clrk66",\n  datumName: "North_American_Datum_1927"\n};\nexports.potsdam = {\n  towgs84: "606.0,23.0,413.0",\n  ellipse: "bessel",\n  datumName: "Potsdam Rauenberg 1950 DHDN"\n};\nexports.carthage = {\n  towgs84: "-263.0,6.0,431.0",\n  ellipse: "clark80",\n  datumName: "Carthage 1934 Tunisia"\n};\nexports.hermannskogel = {\n  towgs84: "653.0,-212.0,449.0",\n  ellipse: "bessel",\n  datumName: "Hermannskogel"\n};\nexports.ire65 = {\n  towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",\n  ellipse: "mod_airy",\n  datumName: "Ireland 1965"\n};\nexports.rassadiran = {\n  towgs84: "-133.63,-157.5,-158.62",\n  ellipse: "intl",\n  datumName: "Rassadiran"\n};\nexports.nzgd49 = {\n  towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",\n  ellipse: "intl",\n  datumName: "New Zealand Geodetic Datum 1949"\n};\nexports.osgb36 = {\n  towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",\n  ellipse: "airy",\n  datumName: "Airy 1830"\n};\nexports.s_jtsk = {\n  towgs84: "589,76,480",\n  ellipse: \'bessel\',\n  datumName: \'S-JTSK (Ferro)\'\n};\nexports.beduaram = {\n  towgs84: \'-106,-87,188\',\n  ellipse: \'clrk80\',\n  datumName: \'Beduaram\'\n};\nexports.gunung_segara = {\n  towgs84: \'-403,684,41\',\n  ellipse: \'bessel\',\n  datumName: \'Gunung Segara Jakarta\'\n};\nexports.rnb72 = {\n  towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",\n  ellipse: "intl",\n  datumName: "Reseau National Belge 1972"\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9jb25zdGFudHMvRGF0dW0uanM/NjVhNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjEyNi5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMud2dzODQgPSB7XG4gIHRvd2dzODQ6IFwiMCwwLDBcIixcbiAgZWxsaXBzZTogXCJXR1M4NFwiLFxuICBkYXR1bU5hbWU6IFwiV0dTODRcIlxufTtcbmV4cG9ydHMuY2gxOTAzID0ge1xuICB0b3dnczg0OiBcIjY3NC4zNzQsMTUuMDU2LDQwNS4zNDZcIixcbiAgZWxsaXBzZTogXCJiZXNzZWxcIixcbiAgZGF0dW1OYW1lOiBcInN3aXNzXCJcbn07XG5leHBvcnRzLmdncnM4NyA9IHtcbiAgdG93Z3M4NDogXCItMTk5Ljg3LDc0Ljc5LDI0Ni42MlwiLFxuICBlbGxpcHNlOiBcIkdSUzgwXCIsXG4gIGRhdHVtTmFtZTogXCJHcmVla19HZW9kZXRpY19SZWZlcmVuY2VfU3lzdGVtXzE5ODdcIlxufTtcbmV4cG9ydHMubmFkODMgPSB7XG4gIHRvd2dzODQ6IFwiMCwwLDBcIixcbiAgZWxsaXBzZTogXCJHUlM4MFwiLFxuICBkYXR1bU5hbWU6IFwiTm9ydGhfQW1lcmljYW5fRGF0dW1fMTk4M1wiXG59O1xuZXhwb3J0cy5uYWQyNyA9IHtcbiAgbmFkZ3JpZHM6IFwiQGNvbnVzLEBhbGFza2EsQG50djJfMC5nc2IsQG50djFfY2FuLmRhdFwiLFxuICBlbGxpcHNlOiBcImNscms2NlwiLFxuICBkYXR1bU5hbWU6IFwiTm9ydGhfQW1lcmljYW5fRGF0dW1fMTkyN1wiXG59O1xuZXhwb3J0cy5wb3RzZGFtID0ge1xuICB0b3dnczg0OiBcIjYwNi4wLDIzLjAsNDEzLjBcIixcbiAgZWxsaXBzZTogXCJiZXNzZWxcIixcbiAgZGF0dW1OYW1lOiBcIlBvdHNkYW0gUmF1ZW5iZXJnIDE5NTAgREhETlwiXG59O1xuZXhwb3J0cy5jYXJ0aGFnZSA9IHtcbiAgdG93Z3M4NDogXCItMjYzLjAsNi4wLDQzMS4wXCIsXG4gIGVsbGlwc2U6IFwiY2xhcms4MFwiLFxuICBkYXR1bU5hbWU6IFwiQ2FydGhhZ2UgMTkzNCBUdW5pc2lhXCJcbn07XG5leHBvcnRzLmhlcm1hbm5za29nZWwgPSB7XG4gIHRvd2dzODQ6IFwiNjUzLjAsLTIxMi4wLDQ0OS4wXCIsXG4gIGVsbGlwc2U6IFwiYmVzc2VsXCIsXG4gIGRhdHVtTmFtZTogXCJIZXJtYW5uc2tvZ2VsXCJcbn07XG5leHBvcnRzLmlyZTY1ID0ge1xuICB0b3dnczg0OiBcIjQ4Mi41MzAsLTEzMC41OTYsNTY0LjU1NywtMS4wNDIsLTAuMjE0LC0wLjYzMSw4LjE1XCIsXG4gIGVsbGlwc2U6IFwibW9kX2FpcnlcIixcbiAgZGF0dW1OYW1lOiBcIklyZWxhbmQgMTk2NVwiXG59O1xuZXhwb3J0cy5yYXNzYWRpcmFuID0ge1xuICB0b3dnczg0OiBcIi0xMzMuNjMsLTE1Ny41LC0xNTguNjJcIixcbiAgZWxsaXBzZTogXCJpbnRsXCIsXG4gIGRhdHVtTmFtZTogXCJSYXNzYWRpcmFuXCJcbn07XG5leHBvcnRzLm56Z2Q0OSA9IHtcbiAgdG93Z3M4NDogXCI1OS40NywtNS4wNCwxODcuNDQsMC40NywtMC4xLDEuMDI0LC00LjU5OTNcIixcbiAgZWxsaXBzZTogXCJpbnRsXCIsXG4gIGRhdHVtTmFtZTogXCJOZXcgWmVhbGFuZCBHZW9kZXRpYyBEYXR1bSAxOTQ5XCJcbn07XG5leHBvcnRzLm9zZ2IzNiA9IHtcbiAgdG93Z3M4NDogXCI0NDYuNDQ4LC0xMjUuMTU3LDU0Mi4wNjAsMC4xNTAyLDAuMjQ3MCwwLjg0MjEsLTIwLjQ4OTRcIixcbiAgZWxsaXBzZTogXCJhaXJ5XCIsXG4gIGRhdHVtTmFtZTogXCJBaXJ5IDE4MzBcIlxufTtcbmV4cG9ydHMuc19qdHNrID0ge1xuICB0b3dnczg0OiBcIjU4OSw3Niw0ODBcIixcbiAgZWxsaXBzZTogJ2Jlc3NlbCcsXG4gIGRhdHVtTmFtZTogJ1MtSlRTSyAoRmVycm8pJ1xufTtcbmV4cG9ydHMuYmVkdWFyYW0gPSB7XG4gIHRvd2dzODQ6ICctMTA2LC04NywxODgnLFxuICBlbGxpcHNlOiAnY2xyazgwJyxcbiAgZGF0dW1OYW1lOiAnQmVkdWFyYW0nXG59O1xuZXhwb3J0cy5ndW51bmdfc2VnYXJhID0ge1xuICB0b3dnczg0OiAnLTQwMyw2ODQsNDEnLFxuICBlbGxpcHNlOiAnYmVzc2VsJyxcbiAgZGF0dW1OYW1lOiAnR3VudW5nIFNlZ2FyYSBKYWthcnRhJ1xufTtcbmV4cG9ydHMucm5iNzIgPSB7XG4gIHRvd2dzODQ6IFwiMTA2Ljg2OSwtNTIuMjk3OCwxMDMuNzI0LC0wLjMzNjU3LDAuNDU2OTU1LC0xLjg0MjE4LDFcIixcbiAgZWxsaXBzZTogXCJpbnRsXCIsXG4gIGRhdHVtTmFtZTogXCJSZXNlYXUgTmF0aW9uYWwgQmVsZ2UgMTk3MlwiXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcm9qNC9saWIvY29uc3RhbnRzL0RhdHVtLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports){eval('exports.MERIT = {\n  a: 6378137.0,\n  rf: 298.257,\n  ellipseName: "MERIT 1983"\n};\nexports.SGS85 = {\n  a: 6378136.0,\n  rf: 298.257,\n  ellipseName: "Soviet Geodetic System 85"\n};\nexports.GRS80 = {\n  a: 6378137.0,\n  rf: 298.257222101,\n  ellipseName: "GRS 1980(IUGG, 1980)"\n};\nexports.IAU76 = {\n  a: 6378140.0,\n  rf: 298.257,\n  ellipseName: "IAU 1976"\n};\nexports.airy = {\n  a: 6377563.396,\n  b: 6356256.910,\n  ellipseName: "Airy 1830"\n};\nexports.APL4 = {\n  a: 6378137,\n  rf: 298.25,\n  ellipseName: "Appl. Physics. 1965"\n};\nexports.NWL9D = {\n  a: 6378145.0,\n  rf: 298.25,\n  ellipseName: "Naval Weapons Lab., 1965"\n};\nexports.mod_airy = {\n  a: 6377340.189,\n  b: 6356034.446,\n  ellipseName: "Modified Airy"\n};\nexports.andrae = {\n  a: 6377104.43,\n  rf: 300.0,\n  ellipseName: "Andrae 1876 (Den., Iclnd.)"\n};\nexports.aust_SA = {\n  a: 6378160.0,\n  rf: 298.25,\n  ellipseName: "Australian Natl & S. Amer. 1969"\n};\nexports.GRS67 = {\n  a: 6378160.0,\n  rf: 298.2471674270,\n  ellipseName: "GRS 67(IUGG 1967)"\n};\nexports.bessel = {\n  a: 6377397.155,\n  rf: 299.1528128,\n  ellipseName: "Bessel 1841"\n};\nexports.bess_nam = {\n  a: 6377483.865,\n  rf: 299.1528128,\n  ellipseName: "Bessel 1841 (Namibia)"\n};\nexports.clrk66 = {\n  a: 6378206.4,\n  b: 6356583.8,\n  ellipseName: "Clarke 1866"\n};\nexports.clrk80 = {\n  a: 6378249.145,\n  rf: 293.4663,\n  ellipseName: "Clarke 1880 mod."\n};\nexports.clrk58 = {\n  a: 6378293.645208759,\n  rf: 294.2606763692654,\n  ellipseName: "Clarke 1858"\n};\nexports.CPM = {\n  a: 6375738.7,\n  rf: 334.29,\n  ellipseName: "Comm. des Poids et Mesures 1799"\n};\nexports.delmbr = {\n  a: 6376428.0,\n  rf: 311.5,\n  ellipseName: "Delambre 1810 (Belgium)"\n};\nexports.engelis = {\n  a: 6378136.05,\n  rf: 298.2566,\n  ellipseName: "Engelis 1985"\n};\nexports.evrst30 = {\n  a: 6377276.345,\n  rf: 300.8017,\n  ellipseName: "Everest 1830"\n};\nexports.evrst48 = {\n  a: 6377304.063,\n  rf: 300.8017,\n  ellipseName: "Everest 1948"\n};\nexports.evrst56 = {\n  a: 6377301.243,\n  rf: 300.8017,\n  ellipseName: "Everest 1956"\n};\nexports.evrst69 = {\n  a: 6377295.664,\n  rf: 300.8017,\n  ellipseName: "Everest 1969"\n};\nexports.evrstSS = {\n  a: 6377298.556,\n  rf: 300.8017,\n  ellipseName: "Everest (Sabah & Sarawak)"\n};\nexports.fschr60 = {\n  a: 6378166.0,\n  rf: 298.3,\n  ellipseName: "Fischer (Mercury Datum) 1960"\n};\nexports.fschr60m = {\n  a: 6378155.0,\n  rf: 298.3,\n  ellipseName: "Fischer 1960"\n};\nexports.fschr68 = {\n  a: 6378150.0,\n  rf: 298.3,\n  ellipseName: "Fischer 1968"\n};\nexports.helmert = {\n  a: 6378200.0,\n  rf: 298.3,\n  ellipseName: "Helmert 1906"\n};\nexports.hough = {\n  a: 6378270.0,\n  rf: 297.0,\n  ellipseName: "Hough"\n};\nexports.intl = {\n  a: 6378388.0,\n  rf: 297.0,\n  ellipseName: "International 1909 (Hayford)"\n};\nexports.kaula = {\n  a: 6378163.0,\n  rf: 298.24,\n  ellipseName: "Kaula 1961"\n};\nexports.lerch = {\n  a: 6378139.0,\n  rf: 298.257,\n  ellipseName: "Lerch 1979"\n};\nexports.mprts = {\n  a: 6397300.0,\n  rf: 191.0,\n  ellipseName: "Maupertius 1738"\n};\nexports.new_intl = {\n  a: 6378157.5,\n  b: 6356772.2,\n  ellipseName: "New International 1967"\n};\nexports.plessis = {\n  a: 6376523.0,\n  rf: 6355863.0,\n  ellipseName: "Plessis 1817 (France)"\n};\nexports.krass = {\n  a: 6378245.0,\n  rf: 298.3,\n  ellipseName: "Krassovsky, 1942"\n};\nexports.SEasia = {\n  a: 6378155.0,\n  b: 6356773.3205,\n  ellipseName: "Southeast Asia"\n};\nexports.walbeck = {\n  a: 6376896.0,\n  b: 6355834.8467,\n  ellipseName: "Walbeck"\n};\nexports.WGS60 = {\n  a: 6378165.0,\n  rf: 298.3,\n  ellipseName: "WGS 60"\n};\nexports.WGS66 = {\n  a: 6378145.0,\n  rf: 298.25,\n  ellipseName: "WGS 66"\n};\nexports.WGS7 = {\n  a: 6378135.0,\n  rf: 298.26,\n  ellipseName: "WGS 72"\n};\nexports.WGS84 = {\n  a: 6378137.0,\n  rf: 298.257223563,\n  ellipseName: "WGS 84"\n};\nexports.sphere = {\n  a: 6370997.0,\n  b: 6370997.0,\n  ellipseName: "Normal Sphere (r=6370997)"\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9jb25zdGFudHMvRWxsaXBzb2lkLmpzP2RhYWEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxMjcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzLk1FUklUID0ge1xuICBhOiA2Mzc4MTM3LjAsXG4gIHJmOiAyOTguMjU3LFxuICBlbGxpcHNlTmFtZTogXCJNRVJJVCAxOTgzXCJcbn07XG5leHBvcnRzLlNHUzg1ID0ge1xuICBhOiA2Mzc4MTM2LjAsXG4gIHJmOiAyOTguMjU3LFxuICBlbGxpcHNlTmFtZTogXCJTb3ZpZXQgR2VvZGV0aWMgU3lzdGVtIDg1XCJcbn07XG5leHBvcnRzLkdSUzgwID0ge1xuICBhOiA2Mzc4MTM3LjAsXG4gIHJmOiAyOTguMjU3MjIyMTAxLFxuICBlbGxpcHNlTmFtZTogXCJHUlMgMTk4MChJVUdHLCAxOTgwKVwiXG59O1xuZXhwb3J0cy5JQVU3NiA9IHtcbiAgYTogNjM3ODE0MC4wLFxuICByZjogMjk4LjI1NyxcbiAgZWxsaXBzZU5hbWU6IFwiSUFVIDE5NzZcIlxufTtcbmV4cG9ydHMuYWlyeSA9IHtcbiAgYTogNjM3NzU2My4zOTYsXG4gIGI6IDYzNTYyNTYuOTEwLFxuICBlbGxpcHNlTmFtZTogXCJBaXJ5IDE4MzBcIlxufTtcbmV4cG9ydHMuQVBMNCA9IHtcbiAgYTogNjM3ODEzNyxcbiAgcmY6IDI5OC4yNSxcbiAgZWxsaXBzZU5hbWU6IFwiQXBwbC4gUGh5c2ljcy4gMTk2NVwiXG59O1xuZXhwb3J0cy5OV0w5RCA9IHtcbiAgYTogNjM3ODE0NS4wLFxuICByZjogMjk4LjI1LFxuICBlbGxpcHNlTmFtZTogXCJOYXZhbCBXZWFwb25zIExhYi4sIDE5NjVcIlxufTtcbmV4cG9ydHMubW9kX2FpcnkgPSB7XG4gIGE6IDYzNzczNDAuMTg5LFxuICBiOiA2MzU2MDM0LjQ0NixcbiAgZWxsaXBzZU5hbWU6IFwiTW9kaWZpZWQgQWlyeVwiXG59O1xuZXhwb3J0cy5hbmRyYWUgPSB7XG4gIGE6IDYzNzcxMDQuNDMsXG4gIHJmOiAzMDAuMCxcbiAgZWxsaXBzZU5hbWU6IFwiQW5kcmFlIDE4NzYgKERlbi4sIEljbG5kLilcIlxufTtcbmV4cG9ydHMuYXVzdF9TQSA9IHtcbiAgYTogNjM3ODE2MC4wLFxuICByZjogMjk4LjI1LFxuICBlbGxpcHNlTmFtZTogXCJBdXN0cmFsaWFuIE5hdGwgJiBTLiBBbWVyLiAxOTY5XCJcbn07XG5leHBvcnRzLkdSUzY3ID0ge1xuICBhOiA2Mzc4MTYwLjAsXG4gIHJmOiAyOTguMjQ3MTY3NDI3MCxcbiAgZWxsaXBzZU5hbWU6IFwiR1JTIDY3KElVR0cgMTk2NylcIlxufTtcbmV4cG9ydHMuYmVzc2VsID0ge1xuICBhOiA2Mzc3Mzk3LjE1NSxcbiAgcmY6IDI5OS4xNTI4MTI4LFxuICBlbGxpcHNlTmFtZTogXCJCZXNzZWwgMTg0MVwiXG59O1xuZXhwb3J0cy5iZXNzX25hbSA9IHtcbiAgYTogNjM3NzQ4My44NjUsXG4gIHJmOiAyOTkuMTUyODEyOCxcbiAgZWxsaXBzZU5hbWU6IFwiQmVzc2VsIDE4NDEgKE5hbWliaWEpXCJcbn07XG5leHBvcnRzLmNscms2NiA9IHtcbiAgYTogNjM3ODIwNi40LFxuICBiOiA2MzU2NTgzLjgsXG4gIGVsbGlwc2VOYW1lOiBcIkNsYXJrZSAxODY2XCJcbn07XG5leHBvcnRzLmNscms4MCA9IHtcbiAgYTogNjM3ODI0OS4xNDUsXG4gIHJmOiAyOTMuNDY2MyxcbiAgZWxsaXBzZU5hbWU6IFwiQ2xhcmtlIDE4ODAgbW9kLlwiXG59O1xuZXhwb3J0cy5jbHJrNTggPSB7XG4gIGE6IDYzNzgyOTMuNjQ1MjA4NzU5LFxuICByZjogMjk0LjI2MDY3NjM2OTI2NTQsXG4gIGVsbGlwc2VOYW1lOiBcIkNsYXJrZSAxODU4XCJcbn07XG5leHBvcnRzLkNQTSA9IHtcbiAgYTogNjM3NTczOC43LFxuICByZjogMzM0LjI5LFxuICBlbGxpcHNlTmFtZTogXCJDb21tLiBkZXMgUG9pZHMgZXQgTWVzdXJlcyAxNzk5XCJcbn07XG5leHBvcnRzLmRlbG1iciA9IHtcbiAgYTogNjM3NjQyOC4wLFxuICByZjogMzExLjUsXG4gIGVsbGlwc2VOYW1lOiBcIkRlbGFtYnJlIDE4MTAgKEJlbGdpdW0pXCJcbn07XG5leHBvcnRzLmVuZ2VsaXMgPSB7XG4gIGE6IDYzNzgxMzYuMDUsXG4gIHJmOiAyOTguMjU2NixcbiAgZWxsaXBzZU5hbWU6IFwiRW5nZWxpcyAxOTg1XCJcbn07XG5leHBvcnRzLmV2cnN0MzAgPSB7XG4gIGE6IDYzNzcyNzYuMzQ1LFxuICByZjogMzAwLjgwMTcsXG4gIGVsbGlwc2VOYW1lOiBcIkV2ZXJlc3QgMTgzMFwiXG59O1xuZXhwb3J0cy5ldnJzdDQ4ID0ge1xuICBhOiA2Mzc3MzA0LjA2MyxcbiAgcmY6IDMwMC44MDE3LFxuICBlbGxpcHNlTmFtZTogXCJFdmVyZXN0IDE5NDhcIlxufTtcbmV4cG9ydHMuZXZyc3Q1NiA9IHtcbiAgYTogNjM3NzMwMS4yNDMsXG4gIHJmOiAzMDAuODAxNyxcbiAgZWxsaXBzZU5hbWU6IFwiRXZlcmVzdCAxOTU2XCJcbn07XG5leHBvcnRzLmV2cnN0NjkgPSB7XG4gIGE6IDYzNzcyOTUuNjY0LFxuICByZjogMzAwLjgwMTcsXG4gIGVsbGlwc2VOYW1lOiBcIkV2ZXJlc3QgMTk2OVwiXG59O1xuZXhwb3J0cy5ldnJzdFNTID0ge1xuICBhOiA2Mzc3Mjk4LjU1NixcbiAgcmY6IDMwMC44MDE3LFxuICBlbGxpcHNlTmFtZTogXCJFdmVyZXN0IChTYWJhaCAmIFNhcmF3YWspXCJcbn07XG5leHBvcnRzLmZzY2hyNjAgPSB7XG4gIGE6IDYzNzgxNjYuMCxcbiAgcmY6IDI5OC4zLFxuICBlbGxpcHNlTmFtZTogXCJGaXNjaGVyIChNZXJjdXJ5IERhdHVtKSAxOTYwXCJcbn07XG5leHBvcnRzLmZzY2hyNjBtID0ge1xuICBhOiA2Mzc4MTU1LjAsXG4gIHJmOiAyOTguMyxcbiAgZWxsaXBzZU5hbWU6IFwiRmlzY2hlciAxOTYwXCJcbn07XG5leHBvcnRzLmZzY2hyNjggPSB7XG4gIGE6IDYzNzgxNTAuMCxcbiAgcmY6IDI5OC4zLFxuICBlbGxpcHNlTmFtZTogXCJGaXNjaGVyIDE5NjhcIlxufTtcbmV4cG9ydHMuaGVsbWVydCA9IHtcbiAgYTogNjM3ODIwMC4wLFxuICByZjogMjk4LjMsXG4gIGVsbGlwc2VOYW1lOiBcIkhlbG1lcnQgMTkwNlwiXG59O1xuZXhwb3J0cy5ob3VnaCA9IHtcbiAgYTogNjM3ODI3MC4wLFxuICByZjogMjk3LjAsXG4gIGVsbGlwc2VOYW1lOiBcIkhvdWdoXCJcbn07XG5leHBvcnRzLmludGwgPSB7XG4gIGE6IDYzNzgzODguMCxcbiAgcmY6IDI5Ny4wLFxuICBlbGxpcHNlTmFtZTogXCJJbnRlcm5hdGlvbmFsIDE5MDkgKEhheWZvcmQpXCJcbn07XG5leHBvcnRzLmthdWxhID0ge1xuICBhOiA2Mzc4MTYzLjAsXG4gIHJmOiAyOTguMjQsXG4gIGVsbGlwc2VOYW1lOiBcIkthdWxhIDE5NjFcIlxufTtcbmV4cG9ydHMubGVyY2ggPSB7XG4gIGE6IDYzNzgxMzkuMCxcbiAgcmY6IDI5OC4yNTcsXG4gIGVsbGlwc2VOYW1lOiBcIkxlcmNoIDE5NzlcIlxufTtcbmV4cG9ydHMubXBydHMgPSB7XG4gIGE6IDYzOTczMDAuMCxcbiAgcmY6IDE5MS4wLFxuICBlbGxpcHNlTmFtZTogXCJNYXVwZXJ0aXVzIDE3MzhcIlxufTtcbmV4cG9ydHMubmV3X2ludGwgPSB7XG4gIGE6IDYzNzgxNTcuNSxcbiAgYjogNjM1Njc3Mi4yLFxuICBlbGxpcHNlTmFtZTogXCJOZXcgSW50ZXJuYXRpb25hbCAxOTY3XCJcbn07XG5leHBvcnRzLnBsZXNzaXMgPSB7XG4gIGE6IDYzNzY1MjMuMCxcbiAgcmY6IDYzNTU4NjMuMCxcbiAgZWxsaXBzZU5hbWU6IFwiUGxlc3NpcyAxODE3IChGcmFuY2UpXCJcbn07XG5leHBvcnRzLmtyYXNzID0ge1xuICBhOiA2Mzc4MjQ1LjAsXG4gIHJmOiAyOTguMyxcbiAgZWxsaXBzZU5hbWU6IFwiS3Jhc3NvdnNreSwgMTk0MlwiXG59O1xuZXhwb3J0cy5TRWFzaWEgPSB7XG4gIGE6IDYzNzgxNTUuMCxcbiAgYjogNjM1Njc3My4zMjA1LFxuICBlbGxpcHNlTmFtZTogXCJTb3V0aGVhc3QgQXNpYVwiXG59O1xuZXhwb3J0cy53YWxiZWNrID0ge1xuICBhOiA2Mzc2ODk2LjAsXG4gIGI6IDYzNTU4MzQuODQ2NyxcbiAgZWxsaXBzZU5hbWU6IFwiV2FsYmVja1wiXG59O1xuZXhwb3J0cy5XR1M2MCA9IHtcbiAgYTogNjM3ODE2NS4wLFxuICByZjogMjk4LjMsXG4gIGVsbGlwc2VOYW1lOiBcIldHUyA2MFwiXG59O1xuZXhwb3J0cy5XR1M2NiA9IHtcbiAgYTogNjM3ODE0NS4wLFxuICByZjogMjk4LjI1LFxuICBlbGxpcHNlTmFtZTogXCJXR1MgNjZcIlxufTtcbmV4cG9ydHMuV0dTNyA9IHtcbiAgYTogNjM3ODEzNS4wLFxuICByZjogMjk4LjI2LFxuICBlbGxpcHNlTmFtZTogXCJXR1MgNzJcIlxufTtcbmV4cG9ydHMuV0dTODQgPSB7XG4gIGE6IDYzNzgxMzcuMCxcbiAgcmY6IDI5OC4yNTcyMjM1NjMsXG4gIGVsbGlwc2VOYW1lOiBcIldHUyA4NFwiXG59O1xuZXhwb3J0cy5zcGhlcmUgPSB7XG4gIGE6IDYzNzA5OTcuMCxcbiAgYjogNjM3MDk5Ny4wLFxuICBlbGxpcHNlTmFtZTogXCJOb3JtYWwgU3BoZXJlIChyPTYzNzA5OTcpXCJcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Byb2o0L2xpYi9jb25zdGFudHMvRWxsaXBzb2lkLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports){eval('exports.greenwich = 0.0; //"0dE",\nexports.lisbon = -9.131906111111; //"9d07\'54.862\\"W",\nexports.paris = 2.337229166667; //"2d20\'14.025\\"E",\nexports.bogota = -74.080916666667; //"74d04\'51.3\\"W",\nexports.madrid = -3.687938888889; //"3d41\'16.58\\"W",\nexports.rome = 12.452333333333; //"12d27\'8.4\\"E",\nexports.bern = 7.439583333333; //"7d26\'22.5\\"E",\nexports.jakarta = 106.807719444444; //"106d48\'27.79\\"E",\nexports.ferro = -17.666666666667; //"17d40\'W",\nexports.brussels = 4.367975; //"4d22\'4.71\\"E",\nexports.stockholm = 18.058277777778; //"18d3\'29.8\\"E",\nexports.athens = 23.7163375; //"23d42\'58.815\\"E",\nexports.oslo = 10.722916666667; //"10d43\'22.5\\"E"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9jb25zdGFudHMvUHJpbWVNZXJpZGlhbi5qcz8xMWI5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLHdCQUF3QjtBQUN4QixpQ0FBaUM7QUFDakMsK0JBQStCO0FBQy9CLGtDQUFrQztBQUNsQyxpQ0FBaUM7QUFDakMsK0JBQStCO0FBQy9CLDhCQUE4QjtBQUM5QixtQ0FBbUM7QUFDbkMsaUNBQWlDO0FBQ2pDLDRCQUE0QjtBQUM1QixvQ0FBb0M7QUFDcEMsNEJBQTRCO0FBQzVCLCtCQUErQiIsImZpbGUiOiIxMjguanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzLmdyZWVud2ljaCA9IDAuMDsgLy9cIjBkRVwiLFxuZXhwb3J0cy5saXNib24gPSAtOS4xMzE5MDYxMTExMTE7IC8vXCI5ZDA3JzU0Ljg2MlxcXCJXXCIsXG5leHBvcnRzLnBhcmlzID0gMi4zMzcyMjkxNjY2Njc7IC8vXCIyZDIwJzE0LjAyNVxcXCJFXCIsXG5leHBvcnRzLmJvZ290YSA9IC03NC4wODA5MTY2NjY2Njc7IC8vXCI3NGQwNCc1MS4zXFxcIldcIixcbmV4cG9ydHMubWFkcmlkID0gLTMuNjg3OTM4ODg4ODg5OyAvL1wiM2Q0MScxNi41OFxcXCJXXCIsXG5leHBvcnRzLnJvbWUgPSAxMi40NTIzMzMzMzMzMzM7IC8vXCIxMmQyNyc4LjRcXFwiRVwiLFxuZXhwb3J0cy5iZXJuID0gNy40Mzk1ODMzMzMzMzM7IC8vXCI3ZDI2JzIyLjVcXFwiRVwiLFxuZXhwb3J0cy5qYWthcnRhID0gMTA2LjgwNzcxOTQ0NDQ0NDsgLy9cIjEwNmQ0OCcyNy43OVxcXCJFXCIsXG5leHBvcnRzLmZlcnJvID0gLTE3LjY2NjY2NjY2NjY2NzsgLy9cIjE3ZDQwJ1dcIixcbmV4cG9ydHMuYnJ1c3NlbHMgPSA0LjM2Nzk3NTsgLy9cIjRkMjInNC43MVxcXCJFXCIsXG5leHBvcnRzLnN0b2NraG9sbSA9IDE4LjA1ODI3Nzc3Nzc3ODsgLy9cIjE4ZDMnMjkuOFxcXCJFXCIsXG5leHBvcnRzLmF0aGVucyA9IDIzLjcxNjMzNzU7IC8vXCIyM2Q0Mic1OC44MTVcXFwiRVwiLFxuZXhwb3J0cy5vc2xvID0gMTAuNzIyOTE2NjY2NjY3OyAvL1wiMTBkNDMnMjIuNVxcXCJFXCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHJvajQvbGliL2NvbnN0YW50cy9QcmltZU1lcmlkaWFuLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports){eval("exports.ft = {to_meter: 0.3048};\nexports['us-ft'] = {to_meter: 1200 / 3937};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9jb25zdGFudHMvdW5pdHMuanM/ODA0YyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxjQUFjO0FBQ2Qsb0JBQW9CIiwiZmlsZSI6IjEyOS5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMuZnQgPSB7dG9fbWV0ZXI6IDAuMzA0OH07XG5leHBvcnRzWyd1cy1mdCddID0ge3RvX21ldGVyOiAxMjAwIC8gMzkzN307XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHJvajQvbGliL2NvbnN0YW50cy91bml0cy5qc1xuLy8gbW9kdWxlIGlkID0gMTI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("var proj = __webpack_require__(32);\nvar transform = __webpack_require__(66);\nvar wgs84 = proj('WGS84');\n\nfunction transformer(from, to, coords) {\n  var transformedArray;\n  if (Array.isArray(coords)) {\n    transformedArray = transform(from, to, coords);\n    if (coords.length === 3) {\n      return [transformedArray.x, transformedArray.y, transformedArray.z];\n    }\n    else {\n      return [transformedArray.x, transformedArray.y];\n    }\n  }\n  else {\n    return transform(from, to, coords);\n  }\n}\n\nfunction checkProj(item) {\n  if (item instanceof proj) {\n    return item;\n  }\n  if (item.oProj) {\n    return item.oProj;\n  }\n  return proj(item);\n}\nfunction proj4(fromProj, toProj, coord) {\n  fromProj = checkProj(fromProj);\n  var single = false;\n  var obj;\n  if (typeof toProj === 'undefined') {\n    toProj = fromProj;\n    fromProj = wgs84;\n    single = true;\n  }\n  else if (typeof toProj.x !== 'undefined' || Array.isArray(toProj)) {\n    coord = toProj;\n    toProj = fromProj;\n    fromProj = wgs84;\n    single = true;\n  }\n  toProj = checkProj(toProj);\n  if (coord) {\n    return transformer(fromProj, toProj, coord);\n  }\n  else {\n    obj = {\n      forward: function(coords) {\n        return transformer(fromProj, toProj, coords);\n      },\n      inverse: function(coords) {\n        return transformer(toProj, fromProj, coords);\n      }\n    };\n    if (single) {\n      obj.oProj = toProj;\n    }\n    return obj;\n  }\n}\nmodule.exports = proj4;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9jb3JlLmpzP2FiYTMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTMwLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIHByb2ogPSByZXF1aXJlKCcuL1Byb2onKTtcbnZhciB0cmFuc2Zvcm0gPSByZXF1aXJlKCcuL3RyYW5zZm9ybScpO1xudmFyIHdnczg0ID0gcHJvaignV0dTODQnKTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtZXIoZnJvbSwgdG8sIGNvb3Jkcykge1xuICB2YXIgdHJhbnNmb3JtZWRBcnJheTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoY29vcmRzKSkge1xuICAgIHRyYW5zZm9ybWVkQXJyYXkgPSB0cmFuc2Zvcm0oZnJvbSwgdG8sIGNvb3Jkcyk7XG4gICAgaWYgKGNvb3Jkcy5sZW5ndGggPT09IDMpIHtcbiAgICAgIHJldHVybiBbdHJhbnNmb3JtZWRBcnJheS54LCB0cmFuc2Zvcm1lZEFycmF5LnksIHRyYW5zZm9ybWVkQXJyYXkuel07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIFt0cmFuc2Zvcm1lZEFycmF5LngsIHRyYW5zZm9ybWVkQXJyYXkueV07XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiB0cmFuc2Zvcm0oZnJvbSwgdG8sIGNvb3Jkcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9qKGl0ZW0pIHtcbiAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBwcm9qKSB7XG4gICAgcmV0dXJuIGl0ZW07XG4gIH1cbiAgaWYgKGl0ZW0ub1Byb2opIHtcbiAgICByZXR1cm4gaXRlbS5vUHJvajtcbiAgfVxuICByZXR1cm4gcHJvaihpdGVtKTtcbn1cbmZ1bmN0aW9uIHByb2o0KGZyb21Qcm9qLCB0b1Byb2osIGNvb3JkKSB7XG4gIGZyb21Qcm9qID0gY2hlY2tQcm9qKGZyb21Qcm9qKTtcbiAgdmFyIHNpbmdsZSA9IGZhbHNlO1xuICB2YXIgb2JqO1xuICBpZiAodHlwZW9mIHRvUHJvaiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0b1Byb2ogPSBmcm9tUHJvajtcbiAgICBmcm9tUHJvaiA9IHdnczg0O1xuICAgIHNpbmdsZSA9IHRydWU7XG4gIH1cbiAgZWxzZSBpZiAodHlwZW9mIHRvUHJvai54ICE9PSAndW5kZWZpbmVkJyB8fCBBcnJheS5pc0FycmF5KHRvUHJvaikpIHtcbiAgICBjb29yZCA9IHRvUHJvajtcbiAgICB0b1Byb2ogPSBmcm9tUHJvajtcbiAgICBmcm9tUHJvaiA9IHdnczg0O1xuICAgIHNpbmdsZSA9IHRydWU7XG4gIH1cbiAgdG9Qcm9qID0gY2hlY2tQcm9qKHRvUHJvaik7XG4gIGlmIChjb29yZCkge1xuICAgIHJldHVybiB0cmFuc2Zvcm1lcihmcm9tUHJvaiwgdG9Qcm9qLCBjb29yZCk7XG4gIH1cbiAgZWxzZSB7XG4gICAgb2JqID0ge1xuICAgICAgZm9yd2FyZDogZnVuY3Rpb24oY29vcmRzKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lcihmcm9tUHJvaiwgdG9Qcm9qLCBjb29yZHMpO1xuICAgICAgfSxcbiAgICAgIGludmVyc2U6IGZ1bmN0aW9uKGNvb3Jkcykge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZXIodG9Qcm9qLCBmcm9tUHJvaiwgY29vcmRzKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChzaW5nbGUpIHtcbiAgICAgIG9iai5vUHJvaiA9IHRvUHJvajtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBwcm9qNDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHJvajQvbGliL2NvcmUuanNcbi8vIG1vZHVsZSBpZCA9IDEzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports){eval("var HALF_PI = Math.PI/2;\nvar PJD_3PARAM = 1;\nvar PJD_7PARAM = 2;\nvar PJD_GRIDSHIFT = 3;\nvar PJD_WGS84 = 4; // WGS84 or equivalent\nvar PJD_NODATUM = 5; // WGS84 or equivalent\nvar SEC_TO_RAD = 4.84813681109535993589914102357e-6;\nvar AD_C = 1.0026000;\nvar COS_67P5 = 0.38268343236508977;\nvar datum = function(proj) {\n  if (!(this instanceof datum)) {\n    return new datum(proj);\n  }\n  this.datum_type = PJD_WGS84; //default setting\n  if (!proj) {\n    return;\n  }\n  if (proj.datumCode && proj.datumCode === 'none') {\n    this.datum_type = PJD_NODATUM;\n  }\n\n  if (proj.datum_params) {\n    this.datum_params = proj.datum_params.map(parseFloat);\n    if (this.datum_params[0] !== 0 || this.datum_params[1] !== 0 || this.datum_params[2] !== 0) {\n      this.datum_type = PJD_3PARAM;\n    }\n    if (this.datum_params.length > 3) {\n      if (this.datum_params[3] !== 0 || this.datum_params[4] !== 0 || this.datum_params[5] !== 0 || this.datum_params[6] !== 0) {\n        this.datum_type = PJD_7PARAM;\n        this.datum_params[3] *= SEC_TO_RAD;\n        this.datum_params[4] *= SEC_TO_RAD;\n        this.datum_params[5] *= SEC_TO_RAD;\n        this.datum_params[6] = (this.datum_params[6] / 1000000.0) + 1.0;\n      }\n    }\n  }\n\n  // DGR 2011-03-21 : nadgrids support\n  this.datum_type = proj.grids ? PJD_GRIDSHIFT : this.datum_type;\n\n  this.a = proj.a; //datum object also uses these values\n  this.b = proj.b;\n  this.es = proj.es;\n  this.ep2 = proj.ep2;\n  if (this.datum_type === PJD_GRIDSHIFT) {\n    this.grids = proj.grids;\n  }\n};\ndatum.prototype = {\n\n\n  /****************************************************************/\n  // cs_compare_datums()\n  //   Returns TRUE if the two datums match, otherwise FALSE.\n  compare_datums: function(dest) {\n    if (this.datum_type !== dest.datum_type) {\n      return false; // false, datums are not equal\n    }\n    else if (this.a !== dest.a || Math.abs(this.es - dest.es) > 0.000000000050) {\n      // the tolerence for es is to ensure that GRS80 and WGS84\n      // are considered identical\n      return false;\n    }\n    else if (this.datum_type === PJD_3PARAM) {\n      return (this.datum_params[0] === dest.datum_params[0] && this.datum_params[1] === dest.datum_params[1] && this.datum_params[2] === dest.datum_params[2]);\n    }\n    else if (this.datum_type === PJD_7PARAM) {\n      return (this.datum_params[0] === dest.datum_params[0] && this.datum_params[1] === dest.datum_params[1] && this.datum_params[2] === dest.datum_params[2] && this.datum_params[3] === dest.datum_params[3] && this.datum_params[4] === dest.datum_params[4] && this.datum_params[5] === dest.datum_params[5] && this.datum_params[6] === dest.datum_params[6]);\n    }\n    else if (this.datum_type === PJD_GRIDSHIFT || dest.datum_type === PJD_GRIDSHIFT) {\n      //alert(\"ERROR: Grid shift transformations are not implemented.\");\n      //return false\n      //DGR 2012-07-29 lazy ...\n      return this.nadgrids === dest.nadgrids;\n    }\n    else {\n      return true; // datums are equal\n    }\n  }, // cs_compare_datums()\n\n  /*\n   * The function Convert_Geodetic_To_Geocentric converts geodetic coordinates\n   * (latitude, longitude, and height) to geocentric coordinates (X, Y, Z),\n   * according to the current ellipsoid parameters.\n   *\n   *    Latitude  : Geodetic latitude in radians                     (input)\n   *    Longitude : Geodetic longitude in radians                    (input)\n   *    Height    : Geodetic height, in meters                       (input)\n   *    X         : Calculated Geocentric X coordinate, in meters    (output)\n   *    Y         : Calculated Geocentric Y coordinate, in meters    (output)\n   *    Z         : Calculated Geocentric Z coordinate, in meters    (output)\n   *\n   */\n  geodetic_to_geocentric: function(p) {\n    var Longitude = p.x;\n    var Latitude = p.y;\n    var Height = p.z ? p.z : 0; //Z value not always supplied\n    var X; // output\n    var Y;\n    var Z;\n\n    var Error_Code = 0; //  GEOCENT_NO_ERROR;\n    var Rn; /*  Earth radius at location  */\n    var Sin_Lat; /*  Math.sin(Latitude)  */\n    var Sin2_Lat; /*  Square of Math.sin(Latitude)  */\n    var Cos_Lat; /*  Math.cos(Latitude)  */\n\n    /*\n     ** Don't blow up if Latitude is just a little out of the value\n     ** range as it may just be a rounding issue.  Also removed longitude\n     ** test, it should be wrapped by Math.cos() and Math.sin().  NFW for PROJ.4, Sep/2001.\n     */\n    if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI) {\n      Latitude = -HALF_PI;\n    }\n    else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI) {\n      Latitude = HALF_PI;\n    }\n    else if ((Latitude < -HALF_PI) || (Latitude > HALF_PI)) {\n      /* Latitude out of range */\n      //..reportError('geocent:lat out of range:' + Latitude);\n      return null;\n    }\n\n    if (Longitude > Math.PI) {\n      Longitude -= (2 * Math.PI);\n    }\n    Sin_Lat = Math.sin(Latitude);\n    Cos_Lat = Math.cos(Latitude);\n    Sin2_Lat = Sin_Lat * Sin_Lat;\n    Rn = this.a / (Math.sqrt(1.0e0 - this.es * Sin2_Lat));\n    X = (Rn + Height) * Cos_Lat * Math.cos(Longitude);\n    Y = (Rn + Height) * Cos_Lat * Math.sin(Longitude);\n    Z = ((Rn * (1 - this.es)) + Height) * Sin_Lat;\n\n    p.x = X;\n    p.y = Y;\n    p.z = Z;\n    return Error_Code;\n  }, // cs_geodetic_to_geocentric()\n\n\n  geocentric_to_geodetic: function(p) {\n    /* local defintions and variables */\n    /* end-criterium of loop, accuracy of sin(Latitude) */\n    var genau = 1e-12;\n    var genau2 = (genau * genau);\n    var maxiter = 30;\n\n    var P; /* distance between semi-minor axis and location */\n    var RR; /* distance between center and location */\n    var CT; /* sin of geocentric latitude */\n    var ST; /* cos of geocentric latitude */\n    var RX;\n    var RK;\n    var RN; /* Earth radius at location */\n    var CPHI0; /* cos of start or old geodetic latitude in iterations */\n    var SPHI0; /* sin of start or old geodetic latitude in iterations */\n    var CPHI; /* cos of searched geodetic latitude */\n    var SPHI; /* sin of searched geodetic latitude */\n    var SDPHI; /* end-criterium: addition-theorem of sin(Latitude(iter)-Latitude(iter-1)) */\n    var At_Pole; /* indicates location is in polar region */\n    var iter; /* # of continous iteration, max. 30 is always enough (s.a.) */\n\n    var X = p.x;\n    var Y = p.y;\n    var Z = p.z ? p.z : 0.0; //Z value not always supplied\n    var Longitude;\n    var Latitude;\n    var Height;\n\n    At_Pole = false;\n    P = Math.sqrt(X * X + Y * Y);\n    RR = Math.sqrt(X * X + Y * Y + Z * Z);\n\n    /*      special cases for latitude and longitude */\n    if (P / this.a < genau) {\n\n      /*  special case, if P=0. (X=0., Y=0.) */\n      At_Pole = true;\n      Longitude = 0.0;\n\n      /*  if (X,Y,Z)=(0.,0.,0.) then Height becomes semi-minor axis\n       *  of ellipsoid (=center of mass), Latitude becomes PI/2 */\n      if (RR / this.a < genau) {\n        Latitude = HALF_PI;\n        Height = -this.b;\n        return;\n      }\n    }\n    else {\n      /*  ellipsoidal (geodetic) longitude\n       *  interval: -PI < Longitude <= +PI */\n      Longitude = Math.atan2(Y, X);\n    }\n\n    /* --------------------------------------------------------------\n     * Following iterative algorithm was developped by\n     * \"Institut for Erdmessung\", University of Hannover, July 1988.\n     * Internet: www.ife.uni-hannover.de\n     * Iterative computation of CPHI,SPHI and Height.\n     * Iteration of CPHI and SPHI to 10**-12 radian resp.\n     * 2*10**-7 arcsec.\n     * --------------------------------------------------------------\n     */\n    CT = Z / RR;\n    ST = P / RR;\n    RX = 1.0 / Math.sqrt(1.0 - this.es * (2.0 - this.es) * ST * ST);\n    CPHI0 = ST * (1.0 - this.es) * RX;\n    SPHI0 = CT * RX;\n    iter = 0;\n\n    /* loop to find sin(Latitude) resp. Latitude\n     * until |sin(Latitude(iter)-Latitude(iter-1))| < genau */\n    do {\n      iter++;\n      RN = this.a / Math.sqrt(1.0 - this.es * SPHI0 * SPHI0);\n\n      /*  ellipsoidal (geodetic) height */\n      Height = P * CPHI0 + Z * SPHI0 - RN * (1.0 - this.es * SPHI0 * SPHI0);\n\n      RK = this.es * RN / (RN + Height);\n      RX = 1.0 / Math.sqrt(1.0 - RK * (2.0 - RK) * ST * ST);\n      CPHI = ST * (1.0 - RK) * RX;\n      SPHI = CT * RX;\n      SDPHI = SPHI * CPHI0 - CPHI * SPHI0;\n      CPHI0 = CPHI;\n      SPHI0 = SPHI;\n    }\n    while (SDPHI * SDPHI > genau2 && iter < maxiter);\n\n    /*      ellipsoidal (geodetic) latitude */\n    Latitude = Math.atan(SPHI / Math.abs(CPHI));\n\n    p.x = Longitude;\n    p.y = Latitude;\n    p.z = Height;\n    return p;\n  }, // cs_geocentric_to_geodetic()\n\n  /** Convert_Geocentric_To_Geodetic\n   * The method used here is derived from 'An Improved Algorithm for\n   * Geocentric to Geodetic Coordinate Conversion', by Ralph Toms, Feb 1996\n   */\n  geocentric_to_geodetic_noniter: function(p) {\n    var X = p.x;\n    var Y = p.y;\n    var Z = p.z ? p.z : 0; //Z value not always supplied\n    var Longitude;\n    var Latitude;\n    var Height;\n\n    var W; /* distance from Z axis */\n    var W2; /* square of distance from Z axis */\n    var T0; /* initial estimate of vertical component */\n    var T1; /* corrected estimate of vertical component */\n    var S0; /* initial estimate of horizontal component */\n    var S1; /* corrected estimate of horizontal component */\n    var Sin_B0; /* Math.sin(B0), B0 is estimate of Bowring aux variable */\n    var Sin3_B0; /* cube of Math.sin(B0) */\n    var Cos_B0; /* Math.cos(B0) */\n    var Sin_p1; /* Math.sin(phi1), phi1 is estimated latitude */\n    var Cos_p1; /* Math.cos(phi1) */\n    var Rn; /* Earth radius at location */\n    var Sum; /* numerator of Math.cos(phi1) */\n    var At_Pole; /* indicates location is in polar region */\n\n    X = parseFloat(X); // cast from string to float\n    Y = parseFloat(Y);\n    Z = parseFloat(Z);\n\n    At_Pole = false;\n    if (X !== 0.0) {\n      Longitude = Math.atan2(Y, X);\n    }\n    else {\n      if (Y > 0) {\n        Longitude = HALF_PI;\n      }\n      else if (Y < 0) {\n        Longitude = -HALF_PI;\n      }\n      else {\n        At_Pole = true;\n        Longitude = 0.0;\n        if (Z > 0.0) { /* north pole */\n          Latitude = HALF_PI;\n        }\n        else if (Z < 0.0) { /* south pole */\n          Latitude = -HALF_PI;\n        }\n        else { /* center of earth */\n          Latitude = HALF_PI;\n          Height = -this.b;\n          return;\n        }\n      }\n    }\n    W2 = X * X + Y * Y;\n    W = Math.sqrt(W2);\n    T0 = Z * AD_C;\n    S0 = Math.sqrt(T0 * T0 + W2);\n    Sin_B0 = T0 / S0;\n    Cos_B0 = W / S0;\n    Sin3_B0 = Sin_B0 * Sin_B0 * Sin_B0;\n    T1 = Z + this.b * this.ep2 * Sin3_B0;\n    Sum = W - this.a * this.es * Cos_B0 * Cos_B0 * Cos_B0;\n    S1 = Math.sqrt(T1 * T1 + Sum * Sum);\n    Sin_p1 = T1 / S1;\n    Cos_p1 = Sum / S1;\n    Rn = this.a / Math.sqrt(1.0 - this.es * Sin_p1 * Sin_p1);\n    if (Cos_p1 >= COS_67P5) {\n      Height = W / Cos_p1 - Rn;\n    }\n    else if (Cos_p1 <= -COS_67P5) {\n      Height = W / -Cos_p1 - Rn;\n    }\n    else {\n      Height = Z / Sin_p1 + Rn * (this.es - 1.0);\n    }\n    if (At_Pole === false) {\n      Latitude = Math.atan(Sin_p1 / Cos_p1);\n    }\n\n    p.x = Longitude;\n    p.y = Latitude;\n    p.z = Height;\n    return p;\n  }, // geocentric_to_geodetic_noniter()\n\n  /****************************************************************/\n  // pj_geocentic_to_wgs84( p )\n  //  p = point to transform in geocentric coordinates (x,y,z)\n  geocentric_to_wgs84: function(p) {\n\n    if (this.datum_type === PJD_3PARAM) {\n      // if( x[io] === HUGE_VAL )\n      //    continue;\n      p.x += this.datum_params[0];\n      p.y += this.datum_params[1];\n      p.z += this.datum_params[2];\n\n    }\n    else if (this.datum_type === PJD_7PARAM) {\n      var Dx_BF = this.datum_params[0];\n      var Dy_BF = this.datum_params[1];\n      var Dz_BF = this.datum_params[2];\n      var Rx_BF = this.datum_params[3];\n      var Ry_BF = this.datum_params[4];\n      var Rz_BF = this.datum_params[5];\n      var M_BF = this.datum_params[6];\n      // if( x[io] === HUGE_VAL )\n      //    continue;\n      var x_out = M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF;\n      var y_out = M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF;\n      var z_out = M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF;\n      p.x = x_out;\n      p.y = y_out;\n      p.z = z_out;\n    }\n  }, // cs_geocentric_to_wgs84\n\n  /****************************************************************/\n  // pj_geocentic_from_wgs84()\n  //  coordinate system definition,\n  //  point to transform in geocentric coordinates (x,y,z)\n  geocentric_from_wgs84: function(p) {\n\n    if (this.datum_type === PJD_3PARAM) {\n      //if( x[io] === HUGE_VAL )\n      //    continue;\n      p.x -= this.datum_params[0];\n      p.y -= this.datum_params[1];\n      p.z -= this.datum_params[2];\n\n    }\n    else if (this.datum_type === PJD_7PARAM) {\n      var Dx_BF = this.datum_params[0];\n      var Dy_BF = this.datum_params[1];\n      var Dz_BF = this.datum_params[2];\n      var Rx_BF = this.datum_params[3];\n      var Ry_BF = this.datum_params[4];\n      var Rz_BF = this.datum_params[5];\n      var M_BF = this.datum_params[6];\n      var x_tmp = (p.x - Dx_BF) / M_BF;\n      var y_tmp = (p.y - Dy_BF) / M_BF;\n      var z_tmp = (p.z - Dz_BF) / M_BF;\n      //if( x[io] === HUGE_VAL )\n      //    continue;\n\n      p.x = x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp;\n      p.y = -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp;\n      p.z = Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp;\n    } //cs_geocentric_from_wgs84()\n  }\n};\n\n/** point object, nothing fancy, just allows values to be\n    passed back and forth by reference rather than by value.\n    Other point classes may be used as long as they have\n    x and y properties, which will get modified in the transform method.\n*/\nmodule.exports = datum;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9kYXR1bS5qcz85NDY5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLFVBQVU7QUFDVjtBQUNBOztBQUVBLHVCQUF1QjtBQUN2QixXQUFXO0FBQ1gsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQixnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVU7QUFDVixXQUFXO0FBQ1gsV0FBVztBQUNYLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYLGNBQWM7QUFDZCxjQUFjO0FBQ2QsYUFBYTtBQUNiLGFBQWE7QUFDYixjQUFjO0FBQ2QsZ0JBQWdCO0FBQ2hCLGFBQWE7O0FBRWI7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQSxVQUFVO0FBQ1YsV0FBVztBQUNYLFdBQVc7QUFDWCxXQUFXO0FBQ1gsV0FBVztBQUNYLFdBQVc7QUFDWCxlQUFlO0FBQ2YsZ0JBQWdCO0FBQ2hCLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLFdBQVc7QUFDWCxZQUFZO0FBQ1osZ0JBQWdCOztBQUVoQixzQkFBc0I7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTMxLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIEhBTEZfUEkgPSBNYXRoLlBJLzI7XG52YXIgUEpEXzNQQVJBTSA9IDE7XG52YXIgUEpEXzdQQVJBTSA9IDI7XG52YXIgUEpEX0dSSURTSElGVCA9IDM7XG52YXIgUEpEX1dHUzg0ID0gNDsgLy8gV0dTODQgb3IgZXF1aXZhbGVudFxudmFyIFBKRF9OT0RBVFVNID0gNTsgLy8gV0dTODQgb3IgZXF1aXZhbGVudFxudmFyIFNFQ19UT19SQUQgPSA0Ljg0ODEzNjgxMTA5NTM1OTkzNTg5OTE0MTAyMzU3ZS02O1xudmFyIEFEX0MgPSAxLjAwMjYwMDA7XG52YXIgQ09TXzY3UDUgPSAwLjM4MjY4MzQzMjM2NTA4OTc3O1xudmFyIGRhdHVtID0gZnVuY3Rpb24ocHJvaikge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgZGF0dW0pKSB7XG4gICAgcmV0dXJuIG5ldyBkYXR1bShwcm9qKTtcbiAgfVxuICB0aGlzLmRhdHVtX3R5cGUgPSBQSkRfV0dTODQ7IC8vZGVmYXVsdCBzZXR0aW5nXG4gIGlmICghcHJvaikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocHJvai5kYXR1bUNvZGUgJiYgcHJvai5kYXR1bUNvZGUgPT09ICdub25lJykge1xuICAgIHRoaXMuZGF0dW1fdHlwZSA9IFBKRF9OT0RBVFVNO1xuICB9XG5cbiAgaWYgKHByb2ouZGF0dW1fcGFyYW1zKSB7XG4gICAgdGhpcy5kYXR1bV9wYXJhbXMgPSBwcm9qLmRhdHVtX3BhcmFtcy5tYXAocGFyc2VGbG9hdCk7XG4gICAgaWYgKHRoaXMuZGF0dW1fcGFyYW1zWzBdICE9PSAwIHx8IHRoaXMuZGF0dW1fcGFyYW1zWzFdICE9PSAwIHx8IHRoaXMuZGF0dW1fcGFyYW1zWzJdICE9PSAwKSB7XG4gICAgICB0aGlzLmRhdHVtX3R5cGUgPSBQSkRfM1BBUkFNO1xuICAgIH1cbiAgICBpZiAodGhpcy5kYXR1bV9wYXJhbXMubGVuZ3RoID4gMykge1xuICAgICAgaWYgKHRoaXMuZGF0dW1fcGFyYW1zWzNdICE9PSAwIHx8IHRoaXMuZGF0dW1fcGFyYW1zWzRdICE9PSAwIHx8IHRoaXMuZGF0dW1fcGFyYW1zWzVdICE9PSAwIHx8IHRoaXMuZGF0dW1fcGFyYW1zWzZdICE9PSAwKSB7XG4gICAgICAgIHRoaXMuZGF0dW1fdHlwZSA9IFBKRF83UEFSQU07XG4gICAgICAgIHRoaXMuZGF0dW1fcGFyYW1zWzNdICo9IFNFQ19UT19SQUQ7XG4gICAgICAgIHRoaXMuZGF0dW1fcGFyYW1zWzRdICo9IFNFQ19UT19SQUQ7XG4gICAgICAgIHRoaXMuZGF0dW1fcGFyYW1zWzVdICo9IFNFQ19UT19SQUQ7XG4gICAgICAgIHRoaXMuZGF0dW1fcGFyYW1zWzZdID0gKHRoaXMuZGF0dW1fcGFyYW1zWzZdIC8gMTAwMDAwMC4wKSArIDEuMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBER1IgMjAxMS0wMy0yMSA6IG5hZGdyaWRzIHN1cHBvcnRcbiAgdGhpcy5kYXR1bV90eXBlID0gcHJvai5ncmlkcyA/IFBKRF9HUklEU0hJRlQgOiB0aGlzLmRhdHVtX3R5cGU7XG5cbiAgdGhpcy5hID0gcHJvai5hOyAvL2RhdHVtIG9iamVjdCBhbHNvIHVzZXMgdGhlc2UgdmFsdWVzXG4gIHRoaXMuYiA9IHByb2ouYjtcbiAgdGhpcy5lcyA9IHByb2ouZXM7XG4gIHRoaXMuZXAyID0gcHJvai5lcDI7XG4gIGlmICh0aGlzLmRhdHVtX3R5cGUgPT09IFBKRF9HUklEU0hJRlQpIHtcbiAgICB0aGlzLmdyaWRzID0gcHJvai5ncmlkcztcbiAgfVxufTtcbmRhdHVtLnByb3RvdHlwZSA9IHtcblxuXG4gIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvLyBjc19jb21wYXJlX2RhdHVtcygpXG4gIC8vICAgUmV0dXJucyBUUlVFIGlmIHRoZSB0d28gZGF0dW1zIG1hdGNoLCBvdGhlcndpc2UgRkFMU0UuXG4gIGNvbXBhcmVfZGF0dW1zOiBmdW5jdGlvbihkZXN0KSB7XG4gICAgaWYgKHRoaXMuZGF0dW1fdHlwZSAhPT0gZGVzdC5kYXR1bV90eXBlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7IC8vIGZhbHNlLCBkYXR1bXMgYXJlIG5vdCBlcXVhbFxuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLmEgIT09IGRlc3QuYSB8fCBNYXRoLmFicyh0aGlzLmVzIC0gZGVzdC5lcykgPiAwLjAwMDAwMDAwMDA1MCkge1xuICAgICAgLy8gdGhlIHRvbGVyZW5jZSBmb3IgZXMgaXMgdG8gZW5zdXJlIHRoYXQgR1JTODAgYW5kIFdHUzg0XG4gICAgICAvLyBhcmUgY29uc2lkZXJlZCBpZGVudGljYWxcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5kYXR1bV90eXBlID09PSBQSkRfM1BBUkFNKSB7XG4gICAgICByZXR1cm4gKHRoaXMuZGF0dW1fcGFyYW1zWzBdID09PSBkZXN0LmRhdHVtX3BhcmFtc1swXSAmJiB0aGlzLmRhdHVtX3BhcmFtc1sxXSA9PT0gZGVzdC5kYXR1bV9wYXJhbXNbMV0gJiYgdGhpcy5kYXR1bV9wYXJhbXNbMl0gPT09IGRlc3QuZGF0dW1fcGFyYW1zWzJdKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5kYXR1bV90eXBlID09PSBQSkRfN1BBUkFNKSB7XG4gICAgICByZXR1cm4gKHRoaXMuZGF0dW1fcGFyYW1zWzBdID09PSBkZXN0LmRhdHVtX3BhcmFtc1swXSAmJiB0aGlzLmRhdHVtX3BhcmFtc1sxXSA9PT0gZGVzdC5kYXR1bV9wYXJhbXNbMV0gJiYgdGhpcy5kYXR1bV9wYXJhbXNbMl0gPT09IGRlc3QuZGF0dW1fcGFyYW1zWzJdICYmIHRoaXMuZGF0dW1fcGFyYW1zWzNdID09PSBkZXN0LmRhdHVtX3BhcmFtc1szXSAmJiB0aGlzLmRhdHVtX3BhcmFtc1s0XSA9PT0gZGVzdC5kYXR1bV9wYXJhbXNbNF0gJiYgdGhpcy5kYXR1bV9wYXJhbXNbNV0gPT09IGRlc3QuZGF0dW1fcGFyYW1zWzVdICYmIHRoaXMuZGF0dW1fcGFyYW1zWzZdID09PSBkZXN0LmRhdHVtX3BhcmFtc1s2XSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuZGF0dW1fdHlwZSA9PT0gUEpEX0dSSURTSElGVCB8fCBkZXN0LmRhdHVtX3R5cGUgPT09IFBKRF9HUklEU0hJRlQpIHtcbiAgICAgIC8vYWxlcnQoXCJFUlJPUjogR3JpZCBzaGlmdCB0cmFuc2Zvcm1hdGlvbnMgYXJlIG5vdCBpbXBsZW1lbnRlZC5cIik7XG4gICAgICAvL3JldHVybiBmYWxzZVxuICAgICAgLy9ER1IgMjAxMi0wNy0yOSBsYXp5IC4uLlxuICAgICAgcmV0dXJuIHRoaXMubmFkZ3JpZHMgPT09IGRlc3QubmFkZ3JpZHM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIHRydWU7IC8vIGRhdHVtcyBhcmUgZXF1YWxcbiAgICB9XG4gIH0sIC8vIGNzX2NvbXBhcmVfZGF0dW1zKClcblxuICAvKlxuICAgKiBUaGUgZnVuY3Rpb24gQ29udmVydF9HZW9kZXRpY19Ub19HZW9jZW50cmljIGNvbnZlcnRzIGdlb2RldGljIGNvb3JkaW5hdGVzXG4gICAqIChsYXRpdHVkZSwgbG9uZ2l0dWRlLCBhbmQgaGVpZ2h0KSB0byBnZW9jZW50cmljIGNvb3JkaW5hdGVzIChYLCBZLCBaKSxcbiAgICogYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IGVsbGlwc29pZCBwYXJhbWV0ZXJzLlxuICAgKlxuICAgKiAgICBMYXRpdHVkZSAgOiBHZW9kZXRpYyBsYXRpdHVkZSBpbiByYWRpYW5zICAgICAgICAgICAgICAgICAgICAgKGlucHV0KVxuICAgKiAgICBMb25naXR1ZGUgOiBHZW9kZXRpYyBsb25naXR1ZGUgaW4gcmFkaWFucyAgICAgICAgICAgICAgICAgICAgKGlucHV0KVxuICAgKiAgICBIZWlnaHQgICAgOiBHZW9kZXRpYyBoZWlnaHQsIGluIG1ldGVycyAgICAgICAgICAgICAgICAgICAgICAgKGlucHV0KVxuICAgKiAgICBYICAgICAgICAgOiBDYWxjdWxhdGVkIEdlb2NlbnRyaWMgWCBjb29yZGluYXRlLCBpbiBtZXRlcnMgICAgKG91dHB1dClcbiAgICogICAgWSAgICAgICAgIDogQ2FsY3VsYXRlZCBHZW9jZW50cmljIFkgY29vcmRpbmF0ZSwgaW4gbWV0ZXJzICAgIChvdXRwdXQpXG4gICAqICAgIFogICAgICAgICA6IENhbGN1bGF0ZWQgR2VvY2VudHJpYyBaIGNvb3JkaW5hdGUsIGluIG1ldGVycyAgICAob3V0cHV0KVxuICAgKlxuICAgKi9cbiAgZ2VvZGV0aWNfdG9fZ2VvY2VudHJpYzogZnVuY3Rpb24ocCkge1xuICAgIHZhciBMb25naXR1ZGUgPSBwLng7XG4gICAgdmFyIExhdGl0dWRlID0gcC55O1xuICAgIHZhciBIZWlnaHQgPSBwLnogPyBwLnogOiAwOyAvL1ogdmFsdWUgbm90IGFsd2F5cyBzdXBwbGllZFxuICAgIHZhciBYOyAvLyBvdXRwdXRcbiAgICB2YXIgWTtcbiAgICB2YXIgWjtcblxuICAgIHZhciBFcnJvcl9Db2RlID0gMDsgLy8gIEdFT0NFTlRfTk9fRVJST1I7XG4gICAgdmFyIFJuOyAvKiAgRWFydGggcmFkaXVzIGF0IGxvY2F0aW9uICAqL1xuICAgIHZhciBTaW5fTGF0OyAvKiAgTWF0aC5zaW4oTGF0aXR1ZGUpICAqL1xuICAgIHZhciBTaW4yX0xhdDsgLyogIFNxdWFyZSBvZiBNYXRoLnNpbihMYXRpdHVkZSkgICovXG4gICAgdmFyIENvc19MYXQ7IC8qICBNYXRoLmNvcyhMYXRpdHVkZSkgICovXG5cbiAgICAvKlxuICAgICAqKiBEb24ndCBibG93IHVwIGlmIExhdGl0dWRlIGlzIGp1c3QgYSBsaXR0bGUgb3V0IG9mIHRoZSB2YWx1ZVxuICAgICAqKiByYW5nZSBhcyBpdCBtYXkganVzdCBiZSBhIHJvdW5kaW5nIGlzc3VlLiAgQWxzbyByZW1vdmVkIGxvbmdpdHVkZVxuICAgICAqKiB0ZXN0LCBpdCBzaG91bGQgYmUgd3JhcHBlZCBieSBNYXRoLmNvcygpIGFuZCBNYXRoLnNpbigpLiAgTkZXIGZvciBQUk9KLjQsIFNlcC8yMDAxLlxuICAgICAqL1xuICAgIGlmIChMYXRpdHVkZSA8IC1IQUxGX1BJICYmIExhdGl0dWRlID4gLTEuMDAxICogSEFMRl9QSSkge1xuICAgICAgTGF0aXR1ZGUgPSAtSEFMRl9QSTtcbiAgICB9XG4gICAgZWxzZSBpZiAoTGF0aXR1ZGUgPiBIQUxGX1BJICYmIExhdGl0dWRlIDwgMS4wMDEgKiBIQUxGX1BJKSB7XG4gICAgICBMYXRpdHVkZSA9IEhBTEZfUEk7XG4gICAgfVxuICAgIGVsc2UgaWYgKChMYXRpdHVkZSA8IC1IQUxGX1BJKSB8fCAoTGF0aXR1ZGUgPiBIQUxGX1BJKSkge1xuICAgICAgLyogTGF0aXR1ZGUgb3V0IG9mIHJhbmdlICovXG4gICAgICAvLy4ucmVwb3J0RXJyb3IoJ2dlb2NlbnQ6bGF0IG91dCBvZiByYW5nZTonICsgTGF0aXR1ZGUpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKExvbmdpdHVkZSA+IE1hdGguUEkpIHtcbiAgICAgIExvbmdpdHVkZSAtPSAoMiAqIE1hdGguUEkpO1xuICAgIH1cbiAgICBTaW5fTGF0ID0gTWF0aC5zaW4oTGF0aXR1ZGUpO1xuICAgIENvc19MYXQgPSBNYXRoLmNvcyhMYXRpdHVkZSk7XG4gICAgU2luMl9MYXQgPSBTaW5fTGF0ICogU2luX0xhdDtcbiAgICBSbiA9IHRoaXMuYSAvIChNYXRoLnNxcnQoMS4wZTAgLSB0aGlzLmVzICogU2luMl9MYXQpKTtcbiAgICBYID0gKFJuICsgSGVpZ2h0KSAqIENvc19MYXQgKiBNYXRoLmNvcyhMb25naXR1ZGUpO1xuICAgIFkgPSAoUm4gKyBIZWlnaHQpICogQ29zX0xhdCAqIE1hdGguc2luKExvbmdpdHVkZSk7XG4gICAgWiA9ICgoUm4gKiAoMSAtIHRoaXMuZXMpKSArIEhlaWdodCkgKiBTaW5fTGF0O1xuXG4gICAgcC54ID0gWDtcbiAgICBwLnkgPSBZO1xuICAgIHAueiA9IFo7XG4gICAgcmV0dXJuIEVycm9yX0NvZGU7XG4gIH0sIC8vIGNzX2dlb2RldGljX3RvX2dlb2NlbnRyaWMoKVxuXG5cbiAgZ2VvY2VudHJpY190b19nZW9kZXRpYzogZnVuY3Rpb24ocCkge1xuICAgIC8qIGxvY2FsIGRlZmludGlvbnMgYW5kIHZhcmlhYmxlcyAqL1xuICAgIC8qIGVuZC1jcml0ZXJpdW0gb2YgbG9vcCwgYWNjdXJhY3kgb2Ygc2luKExhdGl0dWRlKSAqL1xuICAgIHZhciBnZW5hdSA9IDFlLTEyO1xuICAgIHZhciBnZW5hdTIgPSAoZ2VuYXUgKiBnZW5hdSk7XG4gICAgdmFyIG1heGl0ZXIgPSAzMDtcblxuICAgIHZhciBQOyAvKiBkaXN0YW5jZSBiZXR3ZWVuIHNlbWktbWlub3IgYXhpcyBhbmQgbG9jYXRpb24gKi9cbiAgICB2YXIgUlI7IC8qIGRpc3RhbmNlIGJldHdlZW4gY2VudGVyIGFuZCBsb2NhdGlvbiAqL1xuICAgIHZhciBDVDsgLyogc2luIG9mIGdlb2NlbnRyaWMgbGF0aXR1ZGUgKi9cbiAgICB2YXIgU1Q7IC8qIGNvcyBvZiBnZW9jZW50cmljIGxhdGl0dWRlICovXG4gICAgdmFyIFJYO1xuICAgIHZhciBSSztcbiAgICB2YXIgUk47IC8qIEVhcnRoIHJhZGl1cyBhdCBsb2NhdGlvbiAqL1xuICAgIHZhciBDUEhJMDsgLyogY29zIG9mIHN0YXJ0IG9yIG9sZCBnZW9kZXRpYyBsYXRpdHVkZSBpbiBpdGVyYXRpb25zICovXG4gICAgdmFyIFNQSEkwOyAvKiBzaW4gb2Ygc3RhcnQgb3Igb2xkIGdlb2RldGljIGxhdGl0dWRlIGluIGl0ZXJhdGlvbnMgKi9cbiAgICB2YXIgQ1BISTsgLyogY29zIG9mIHNlYXJjaGVkIGdlb2RldGljIGxhdGl0dWRlICovXG4gICAgdmFyIFNQSEk7IC8qIHNpbiBvZiBzZWFyY2hlZCBnZW9kZXRpYyBsYXRpdHVkZSAqL1xuICAgIHZhciBTRFBISTsgLyogZW5kLWNyaXRlcml1bTogYWRkaXRpb24tdGhlb3JlbSBvZiBzaW4oTGF0aXR1ZGUoaXRlciktTGF0aXR1ZGUoaXRlci0xKSkgKi9cbiAgICB2YXIgQXRfUG9sZTsgLyogaW5kaWNhdGVzIGxvY2F0aW9uIGlzIGluIHBvbGFyIHJlZ2lvbiAqL1xuICAgIHZhciBpdGVyOyAvKiAjIG9mIGNvbnRpbm91cyBpdGVyYXRpb24sIG1heC4gMzAgaXMgYWx3YXlzIGVub3VnaCAocy5hLikgKi9cblxuICAgIHZhciBYID0gcC54O1xuICAgIHZhciBZID0gcC55O1xuICAgIHZhciBaID0gcC56ID8gcC56IDogMC4wOyAvL1ogdmFsdWUgbm90IGFsd2F5cyBzdXBwbGllZFxuICAgIHZhciBMb25naXR1ZGU7XG4gICAgdmFyIExhdGl0dWRlO1xuICAgIHZhciBIZWlnaHQ7XG5cbiAgICBBdF9Qb2xlID0gZmFsc2U7XG4gICAgUCA9IE1hdGguc3FydChYICogWCArIFkgKiBZKTtcbiAgICBSUiA9IE1hdGguc3FydChYICogWCArIFkgKiBZICsgWiAqIFopO1xuXG4gICAgLyogICAgICBzcGVjaWFsIGNhc2VzIGZvciBsYXRpdHVkZSBhbmQgbG9uZ2l0dWRlICovXG4gICAgaWYgKFAgLyB0aGlzLmEgPCBnZW5hdSkge1xuXG4gICAgICAvKiAgc3BlY2lhbCBjYXNlLCBpZiBQPTAuIChYPTAuLCBZPTAuKSAqL1xuICAgICAgQXRfUG9sZSA9IHRydWU7XG4gICAgICBMb25naXR1ZGUgPSAwLjA7XG5cbiAgICAgIC8qICBpZiAoWCxZLFopPSgwLiwwLiwwLikgdGhlbiBIZWlnaHQgYmVjb21lcyBzZW1pLW1pbm9yIGF4aXNcbiAgICAgICAqICBvZiBlbGxpcHNvaWQgKD1jZW50ZXIgb2YgbWFzcyksIExhdGl0dWRlIGJlY29tZXMgUEkvMiAqL1xuICAgICAgaWYgKFJSIC8gdGhpcy5hIDwgZ2VuYXUpIHtcbiAgICAgICAgTGF0aXR1ZGUgPSBIQUxGX1BJO1xuICAgICAgICBIZWlnaHQgPSAtdGhpcy5iO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLyogIGVsbGlwc29pZGFsIChnZW9kZXRpYykgbG9uZ2l0dWRlXG4gICAgICAgKiAgaW50ZXJ2YWw6IC1QSSA8IExvbmdpdHVkZSA8PSArUEkgKi9cbiAgICAgIExvbmdpdHVkZSA9IE1hdGguYXRhbjIoWSwgWCk7XG4gICAgfVxuXG4gICAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKiBGb2xsb3dpbmcgaXRlcmF0aXZlIGFsZ29yaXRobSB3YXMgZGV2ZWxvcHBlZCBieVxuICAgICAqIFwiSW5zdGl0dXQgZm9yIEVyZG1lc3N1bmdcIiwgVW5pdmVyc2l0eSBvZiBIYW5ub3ZlciwgSnVseSAxOTg4LlxuICAgICAqIEludGVybmV0OiB3d3cuaWZlLnVuaS1oYW5ub3Zlci5kZVxuICAgICAqIEl0ZXJhdGl2ZSBjb21wdXRhdGlvbiBvZiBDUEhJLFNQSEkgYW5kIEhlaWdodC5cbiAgICAgKiBJdGVyYXRpb24gb2YgQ1BISSBhbmQgU1BISSB0byAxMCoqLTEyIHJhZGlhbiByZXNwLlxuICAgICAqIDIqMTAqKi03IGFyY3NlYy5cbiAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqL1xuICAgIENUID0gWiAvIFJSO1xuICAgIFNUID0gUCAvIFJSO1xuICAgIFJYID0gMS4wIC8gTWF0aC5zcXJ0KDEuMCAtIHRoaXMuZXMgKiAoMi4wIC0gdGhpcy5lcykgKiBTVCAqIFNUKTtcbiAgICBDUEhJMCA9IFNUICogKDEuMCAtIHRoaXMuZXMpICogUlg7XG4gICAgU1BISTAgPSBDVCAqIFJYO1xuICAgIGl0ZXIgPSAwO1xuXG4gICAgLyogbG9vcCB0byBmaW5kIHNpbihMYXRpdHVkZSkgcmVzcC4gTGF0aXR1ZGVcbiAgICAgKiB1bnRpbCB8c2luKExhdGl0dWRlKGl0ZXIpLUxhdGl0dWRlKGl0ZXItMSkpfCA8IGdlbmF1ICovXG4gICAgZG8ge1xuICAgICAgaXRlcisrO1xuICAgICAgUk4gPSB0aGlzLmEgLyBNYXRoLnNxcnQoMS4wIC0gdGhpcy5lcyAqIFNQSEkwICogU1BISTApO1xuXG4gICAgICAvKiAgZWxsaXBzb2lkYWwgKGdlb2RldGljKSBoZWlnaHQgKi9cbiAgICAgIEhlaWdodCA9IFAgKiBDUEhJMCArIFogKiBTUEhJMCAtIFJOICogKDEuMCAtIHRoaXMuZXMgKiBTUEhJMCAqIFNQSEkwKTtcblxuICAgICAgUksgPSB0aGlzLmVzICogUk4gLyAoUk4gKyBIZWlnaHQpO1xuICAgICAgUlggPSAxLjAgLyBNYXRoLnNxcnQoMS4wIC0gUksgKiAoMi4wIC0gUkspICogU1QgKiBTVCk7XG4gICAgICBDUEhJID0gU1QgKiAoMS4wIC0gUkspICogUlg7XG4gICAgICBTUEhJID0gQ1QgKiBSWDtcbiAgICAgIFNEUEhJID0gU1BISSAqIENQSEkwIC0gQ1BISSAqIFNQSEkwO1xuICAgICAgQ1BISTAgPSBDUEhJO1xuICAgICAgU1BISTAgPSBTUEhJO1xuICAgIH1cbiAgICB3aGlsZSAoU0RQSEkgKiBTRFBISSA+IGdlbmF1MiAmJiBpdGVyIDwgbWF4aXRlcik7XG5cbiAgICAvKiAgICAgIGVsbGlwc29pZGFsIChnZW9kZXRpYykgbGF0aXR1ZGUgKi9cbiAgICBMYXRpdHVkZSA9IE1hdGguYXRhbihTUEhJIC8gTWF0aC5hYnMoQ1BISSkpO1xuXG4gICAgcC54ID0gTG9uZ2l0dWRlO1xuICAgIHAueSA9IExhdGl0dWRlO1xuICAgIHAueiA9IEhlaWdodDtcbiAgICByZXR1cm4gcDtcbiAgfSwgLy8gY3NfZ2VvY2VudHJpY190b19nZW9kZXRpYygpXG5cbiAgLyoqIENvbnZlcnRfR2VvY2VudHJpY19Ub19HZW9kZXRpY1xuICAgKiBUaGUgbWV0aG9kIHVzZWQgaGVyZSBpcyBkZXJpdmVkIGZyb20gJ0FuIEltcHJvdmVkIEFsZ29yaXRobSBmb3JcbiAgICogR2VvY2VudHJpYyB0byBHZW9kZXRpYyBDb29yZGluYXRlIENvbnZlcnNpb24nLCBieSBSYWxwaCBUb21zLCBGZWIgMTk5NlxuICAgKi9cbiAgZ2VvY2VudHJpY190b19nZW9kZXRpY19ub25pdGVyOiBmdW5jdGlvbihwKSB7XG4gICAgdmFyIFggPSBwLng7XG4gICAgdmFyIFkgPSBwLnk7XG4gICAgdmFyIFogPSBwLnogPyBwLnogOiAwOyAvL1ogdmFsdWUgbm90IGFsd2F5cyBzdXBwbGllZFxuICAgIHZhciBMb25naXR1ZGU7XG4gICAgdmFyIExhdGl0dWRlO1xuICAgIHZhciBIZWlnaHQ7XG5cbiAgICB2YXIgVzsgLyogZGlzdGFuY2UgZnJvbSBaIGF4aXMgKi9cbiAgICB2YXIgVzI7IC8qIHNxdWFyZSBvZiBkaXN0YW5jZSBmcm9tIFogYXhpcyAqL1xuICAgIHZhciBUMDsgLyogaW5pdGlhbCBlc3RpbWF0ZSBvZiB2ZXJ0aWNhbCBjb21wb25lbnQgKi9cbiAgICB2YXIgVDE7IC8qIGNvcnJlY3RlZCBlc3RpbWF0ZSBvZiB2ZXJ0aWNhbCBjb21wb25lbnQgKi9cbiAgICB2YXIgUzA7IC8qIGluaXRpYWwgZXN0aW1hdGUgb2YgaG9yaXpvbnRhbCBjb21wb25lbnQgKi9cbiAgICB2YXIgUzE7IC8qIGNvcnJlY3RlZCBlc3RpbWF0ZSBvZiBob3Jpem9udGFsIGNvbXBvbmVudCAqL1xuICAgIHZhciBTaW5fQjA7IC8qIE1hdGguc2luKEIwKSwgQjAgaXMgZXN0aW1hdGUgb2YgQm93cmluZyBhdXggdmFyaWFibGUgKi9cbiAgICB2YXIgU2luM19CMDsgLyogY3ViZSBvZiBNYXRoLnNpbihCMCkgKi9cbiAgICB2YXIgQ29zX0IwOyAvKiBNYXRoLmNvcyhCMCkgKi9cbiAgICB2YXIgU2luX3AxOyAvKiBNYXRoLnNpbihwaGkxKSwgcGhpMSBpcyBlc3RpbWF0ZWQgbGF0aXR1ZGUgKi9cbiAgICB2YXIgQ29zX3AxOyAvKiBNYXRoLmNvcyhwaGkxKSAqL1xuICAgIHZhciBSbjsgLyogRWFydGggcmFkaXVzIGF0IGxvY2F0aW9uICovXG4gICAgdmFyIFN1bTsgLyogbnVtZXJhdG9yIG9mIE1hdGguY29zKHBoaTEpICovXG4gICAgdmFyIEF0X1BvbGU7IC8qIGluZGljYXRlcyBsb2NhdGlvbiBpcyBpbiBwb2xhciByZWdpb24gKi9cblxuICAgIFggPSBwYXJzZUZsb2F0KFgpOyAvLyBjYXN0IGZyb20gc3RyaW5nIHRvIGZsb2F0XG4gICAgWSA9IHBhcnNlRmxvYXQoWSk7XG4gICAgWiA9IHBhcnNlRmxvYXQoWik7XG5cbiAgICBBdF9Qb2xlID0gZmFsc2U7XG4gICAgaWYgKFggIT09IDAuMCkge1xuICAgICAgTG9uZ2l0dWRlID0gTWF0aC5hdGFuMihZLCBYKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAoWSA+IDApIHtcbiAgICAgICAgTG9uZ2l0dWRlID0gSEFMRl9QSTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKFkgPCAwKSB7XG4gICAgICAgIExvbmdpdHVkZSA9IC1IQUxGX1BJO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIEF0X1BvbGUgPSB0cnVlO1xuICAgICAgICBMb25naXR1ZGUgPSAwLjA7XG4gICAgICAgIGlmIChaID4gMC4wKSB7IC8qIG5vcnRoIHBvbGUgKi9cbiAgICAgICAgICBMYXRpdHVkZSA9IEhBTEZfUEk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoWiA8IDAuMCkgeyAvKiBzb3V0aCBwb2xlICovXG4gICAgICAgICAgTGF0aXR1ZGUgPSAtSEFMRl9QSTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLyogY2VudGVyIG9mIGVhcnRoICovXG4gICAgICAgICAgTGF0aXR1ZGUgPSBIQUxGX1BJO1xuICAgICAgICAgIEhlaWdodCA9IC10aGlzLmI7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIFcyID0gWCAqIFggKyBZICogWTtcbiAgICBXID0gTWF0aC5zcXJ0KFcyKTtcbiAgICBUMCA9IFogKiBBRF9DO1xuICAgIFMwID0gTWF0aC5zcXJ0KFQwICogVDAgKyBXMik7XG4gICAgU2luX0IwID0gVDAgLyBTMDtcbiAgICBDb3NfQjAgPSBXIC8gUzA7XG4gICAgU2luM19CMCA9IFNpbl9CMCAqIFNpbl9CMCAqIFNpbl9CMDtcbiAgICBUMSA9IFogKyB0aGlzLmIgKiB0aGlzLmVwMiAqIFNpbjNfQjA7XG4gICAgU3VtID0gVyAtIHRoaXMuYSAqIHRoaXMuZXMgKiBDb3NfQjAgKiBDb3NfQjAgKiBDb3NfQjA7XG4gICAgUzEgPSBNYXRoLnNxcnQoVDEgKiBUMSArIFN1bSAqIFN1bSk7XG4gICAgU2luX3AxID0gVDEgLyBTMTtcbiAgICBDb3NfcDEgPSBTdW0gLyBTMTtcbiAgICBSbiA9IHRoaXMuYSAvIE1hdGguc3FydCgxLjAgLSB0aGlzLmVzICogU2luX3AxICogU2luX3AxKTtcbiAgICBpZiAoQ29zX3AxID49IENPU182N1A1KSB7XG4gICAgICBIZWlnaHQgPSBXIC8gQ29zX3AxIC0gUm47XG4gICAgfVxuICAgIGVsc2UgaWYgKENvc19wMSA8PSAtQ09TXzY3UDUpIHtcbiAgICAgIEhlaWdodCA9IFcgLyAtQ29zX3AxIC0gUm47XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgSGVpZ2h0ID0gWiAvIFNpbl9wMSArIFJuICogKHRoaXMuZXMgLSAxLjApO1xuICAgIH1cbiAgICBpZiAoQXRfUG9sZSA9PT0gZmFsc2UpIHtcbiAgICAgIExhdGl0dWRlID0gTWF0aC5hdGFuKFNpbl9wMSAvIENvc19wMSk7XG4gICAgfVxuXG4gICAgcC54ID0gTG9uZ2l0dWRlO1xuICAgIHAueSA9IExhdGl0dWRlO1xuICAgIHAueiA9IEhlaWdodDtcbiAgICByZXR1cm4gcDtcbiAgfSwgLy8gZ2VvY2VudHJpY190b19nZW9kZXRpY19ub25pdGVyKClcblxuICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLy8gcGpfZ2VvY2VudGljX3RvX3dnczg0KCBwIClcbiAgLy8gIHAgPSBwb2ludCB0byB0cmFuc2Zvcm0gaW4gZ2VvY2VudHJpYyBjb29yZGluYXRlcyAoeCx5LHopXG4gIGdlb2NlbnRyaWNfdG9fd2dzODQ6IGZ1bmN0aW9uKHApIHtcblxuICAgIGlmICh0aGlzLmRhdHVtX3R5cGUgPT09IFBKRF8zUEFSQU0pIHtcbiAgICAgIC8vIGlmKCB4W2lvXSA9PT0gSFVHRV9WQUwgKVxuICAgICAgLy8gICAgY29udGludWU7XG4gICAgICBwLnggKz0gdGhpcy5kYXR1bV9wYXJhbXNbMF07XG4gICAgICBwLnkgKz0gdGhpcy5kYXR1bV9wYXJhbXNbMV07XG4gICAgICBwLnogKz0gdGhpcy5kYXR1bV9wYXJhbXNbMl07XG5cbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5kYXR1bV90eXBlID09PSBQSkRfN1BBUkFNKSB7XG4gICAgICB2YXIgRHhfQkYgPSB0aGlzLmRhdHVtX3BhcmFtc1swXTtcbiAgICAgIHZhciBEeV9CRiA9IHRoaXMuZGF0dW1fcGFyYW1zWzFdO1xuICAgICAgdmFyIER6X0JGID0gdGhpcy5kYXR1bV9wYXJhbXNbMl07XG4gICAgICB2YXIgUnhfQkYgPSB0aGlzLmRhdHVtX3BhcmFtc1szXTtcbiAgICAgIHZhciBSeV9CRiA9IHRoaXMuZGF0dW1fcGFyYW1zWzRdO1xuICAgICAgdmFyIFJ6X0JGID0gdGhpcy5kYXR1bV9wYXJhbXNbNV07XG4gICAgICB2YXIgTV9CRiA9IHRoaXMuZGF0dW1fcGFyYW1zWzZdO1xuICAgICAgLy8gaWYoIHhbaW9dID09PSBIVUdFX1ZBTCApXG4gICAgICAvLyAgICBjb250aW51ZTtcbiAgICAgIHZhciB4X291dCA9IE1fQkYgKiAocC54IC0gUnpfQkYgKiBwLnkgKyBSeV9CRiAqIHAueikgKyBEeF9CRjtcbiAgICAgIHZhciB5X291dCA9IE1fQkYgKiAoUnpfQkYgKiBwLnggKyBwLnkgLSBSeF9CRiAqIHAueikgKyBEeV9CRjtcbiAgICAgIHZhciB6X291dCA9IE1fQkYgKiAoLVJ5X0JGICogcC54ICsgUnhfQkYgKiBwLnkgKyBwLnopICsgRHpfQkY7XG4gICAgICBwLnggPSB4X291dDtcbiAgICAgIHAueSA9IHlfb3V0O1xuICAgICAgcC56ID0gel9vdXQ7XG4gICAgfVxuICB9LCAvLyBjc19nZW9jZW50cmljX3RvX3dnczg0XG5cbiAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gIC8vIHBqX2dlb2NlbnRpY19mcm9tX3dnczg0KClcbiAgLy8gIGNvb3JkaW5hdGUgc3lzdGVtIGRlZmluaXRpb24sXG4gIC8vICBwb2ludCB0byB0cmFuc2Zvcm0gaW4gZ2VvY2VudHJpYyBjb29yZGluYXRlcyAoeCx5LHopXG4gIGdlb2NlbnRyaWNfZnJvbV93Z3M4NDogZnVuY3Rpb24ocCkge1xuXG4gICAgaWYgKHRoaXMuZGF0dW1fdHlwZSA9PT0gUEpEXzNQQVJBTSkge1xuICAgICAgLy9pZiggeFtpb10gPT09IEhVR0VfVkFMIClcbiAgICAgIC8vICAgIGNvbnRpbnVlO1xuICAgICAgcC54IC09IHRoaXMuZGF0dW1fcGFyYW1zWzBdO1xuICAgICAgcC55IC09IHRoaXMuZGF0dW1fcGFyYW1zWzFdO1xuICAgICAgcC56IC09IHRoaXMuZGF0dW1fcGFyYW1zWzJdO1xuXG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuZGF0dW1fdHlwZSA9PT0gUEpEXzdQQVJBTSkge1xuICAgICAgdmFyIER4X0JGID0gdGhpcy5kYXR1bV9wYXJhbXNbMF07XG4gICAgICB2YXIgRHlfQkYgPSB0aGlzLmRhdHVtX3BhcmFtc1sxXTtcbiAgICAgIHZhciBEel9CRiA9IHRoaXMuZGF0dW1fcGFyYW1zWzJdO1xuICAgICAgdmFyIFJ4X0JGID0gdGhpcy5kYXR1bV9wYXJhbXNbM107XG4gICAgICB2YXIgUnlfQkYgPSB0aGlzLmRhdHVtX3BhcmFtc1s0XTtcbiAgICAgIHZhciBSel9CRiA9IHRoaXMuZGF0dW1fcGFyYW1zWzVdO1xuICAgICAgdmFyIE1fQkYgPSB0aGlzLmRhdHVtX3BhcmFtc1s2XTtcbiAgICAgIHZhciB4X3RtcCA9IChwLnggLSBEeF9CRikgLyBNX0JGO1xuICAgICAgdmFyIHlfdG1wID0gKHAueSAtIER5X0JGKSAvIE1fQkY7XG4gICAgICB2YXIgel90bXAgPSAocC56IC0gRHpfQkYpIC8gTV9CRjtcbiAgICAgIC8vaWYoIHhbaW9dID09PSBIVUdFX1ZBTCApXG4gICAgICAvLyAgICBjb250aW51ZTtcblxuICAgICAgcC54ID0geF90bXAgKyBSel9CRiAqIHlfdG1wIC0gUnlfQkYgKiB6X3RtcDtcbiAgICAgIHAueSA9IC1Sel9CRiAqIHhfdG1wICsgeV90bXAgKyBSeF9CRiAqIHpfdG1wO1xuICAgICAgcC56ID0gUnlfQkYgKiB4X3RtcCAtIFJ4X0JGICogeV90bXAgKyB6X3RtcDtcbiAgICB9IC8vY3NfZ2VvY2VudHJpY19mcm9tX3dnczg0KClcbiAgfVxufTtcblxuLyoqIHBvaW50IG9iamVjdCwgbm90aGluZyBmYW5jeSwganVzdCBhbGxvd3MgdmFsdWVzIHRvIGJlXG4gICAgcGFzc2VkIGJhY2sgYW5kIGZvcnRoIGJ5IHJlZmVyZW5jZSByYXRoZXIgdGhhbiBieSB2YWx1ZS5cbiAgICBPdGhlciBwb2ludCBjbGFzc2VzIG1heSBiZSB1c2VkIGFzIGxvbmcgYXMgdGhleSBoYXZlXG4gICAgeCBhbmQgeSBwcm9wZXJ0aWVzLCB3aGljaCB3aWxsIGdldCBtb2RpZmllZCBpbiB0aGUgdHJhbnNmb3JtIG1ldGhvZC5cbiovXG5tb2R1bGUuZXhwb3J0cyA9IGRhdHVtO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Byb2o0L2xpYi9kYXR1bS5qc1xuLy8gbW9kdWxlIGlkID0gMTMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports){eval("var PJD_3PARAM = 1;\nvar PJD_7PARAM = 2;\nvar PJD_GRIDSHIFT = 3;\nvar PJD_NODATUM = 5; // WGS84 or equivalent\nvar SRS_WGS84_SEMIMAJOR = 6378137; // only used in grid shift transforms\nvar SRS_WGS84_ESQUARED = 0.006694379990141316; //DGR: 2012-07-29\nmodule.exports = function(source, dest, point) {\n  var wp, i, l;\n\n  function checkParams(fallback) {\n    return (fallback === PJD_3PARAM || fallback === PJD_7PARAM);\n  }\n  // Short cut if the datums are identical.\n  if (source.compare_datums(dest)) {\n    return point; // in this case, zero is sucess,\n    // whereas cs_compare_datums returns 1 to indicate TRUE\n    // confusing, should fix this\n  }\n\n  // Explicitly skip datum transform by setting 'datum=none' as parameter for either source or dest\n  if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {\n    return point;\n  }\n\n  //DGR: 2012-07-29 : add nadgrids support (begin)\n  var src_a = source.a;\n  var src_es = source.es;\n\n  var dst_a = dest.a;\n  var dst_es = dest.es;\n\n  var fallback = source.datum_type;\n  // If this datum requires grid shifts, then apply it to geodetic coordinates.\n  if (fallback === PJD_GRIDSHIFT) {\n    if (this.apply_gridshift(source, 0, point) === 0) {\n      source.a = SRS_WGS84_SEMIMAJOR;\n      source.es = SRS_WGS84_ESQUARED;\n    }\n    else {\n      // try 3 or 7 params transformation or nothing ?\n      if (!source.datum_params) {\n        source.a = src_a;\n        source.es = source.es;\n        return point;\n      }\n      wp = 1;\n      for (i = 0, l = source.datum_params.length; i < l; i++) {\n        wp *= source.datum_params[i];\n      }\n      if (wp === 0) {\n        source.a = src_a;\n        source.es = source.es;\n        return point;\n      }\n      if (source.datum_params.length > 3) {\n        fallback = PJD_7PARAM;\n      }\n      else {\n        fallback = PJD_3PARAM;\n      }\n    }\n  }\n  if (dest.datum_type === PJD_GRIDSHIFT) {\n    dest.a = SRS_WGS84_SEMIMAJOR;\n    dest.es = SRS_WGS84_ESQUARED;\n  }\n  // Do we need to go through geocentric coordinates?\n  if (source.es !== dest.es || source.a !== dest.a || checkParams(fallback) || checkParams(dest.datum_type)) {\n    //DGR: 2012-07-29 : add nadgrids support (end)\n    // Convert to geocentric coordinates.\n    source.geodetic_to_geocentric(point);\n    // CHECK_RETURN;\n    // Convert between datums\n    if (checkParams(source.datum_type)) {\n      source.geocentric_to_wgs84(point);\n      // CHECK_RETURN;\n    }\n    if (checkParams(dest.datum_type)) {\n      dest.geocentric_from_wgs84(point);\n      // CHECK_RETURN;\n    }\n    // Convert back to geodetic coordinates\n    dest.geocentric_to_geodetic(point);\n    // CHECK_RETURN;\n  }\n  // Apply grid shift to destination if required\n  if (dest.datum_type === PJD_GRIDSHIFT) {\n    this.apply_gridshift(dest, 1, point);\n    // CHECK_RETURN;\n  }\n\n  source.a = src_a;\n  source.es = src_es;\n  dest.a = dst_a;\n  dest.es = dst_es;\n\n  return point;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9kYXR1bV90cmFuc2Zvcm0uanM/ODQ1MiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsa0NBQWtDO0FBQ2xDLDhDQUE4QztBQUM5QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJmaWxlIjoiMTMyLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIFBKRF8zUEFSQU0gPSAxO1xudmFyIFBKRF83UEFSQU0gPSAyO1xudmFyIFBKRF9HUklEU0hJRlQgPSAzO1xudmFyIFBKRF9OT0RBVFVNID0gNTsgLy8gV0dTODQgb3IgZXF1aXZhbGVudFxudmFyIFNSU19XR1M4NF9TRU1JTUFKT1IgPSA2Mzc4MTM3OyAvLyBvbmx5IHVzZWQgaW4gZ3JpZCBzaGlmdCB0cmFuc2Zvcm1zXG52YXIgU1JTX1dHUzg0X0VTUVVBUkVEID0gMC4wMDY2OTQzNzk5OTAxNDEzMTY7IC8vREdSOiAyMDEyLTA3LTI5XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHNvdXJjZSwgZGVzdCwgcG9pbnQpIHtcbiAgdmFyIHdwLCBpLCBsO1xuXG4gIGZ1bmN0aW9uIGNoZWNrUGFyYW1zKGZhbGxiYWNrKSB7XG4gICAgcmV0dXJuIChmYWxsYmFjayA9PT0gUEpEXzNQQVJBTSB8fCBmYWxsYmFjayA9PT0gUEpEXzdQQVJBTSk7XG4gIH1cbiAgLy8gU2hvcnQgY3V0IGlmIHRoZSBkYXR1bXMgYXJlIGlkZW50aWNhbC5cbiAgaWYgKHNvdXJjZS5jb21wYXJlX2RhdHVtcyhkZXN0KSkge1xuICAgIHJldHVybiBwb2ludDsgLy8gaW4gdGhpcyBjYXNlLCB6ZXJvIGlzIHN1Y2VzcyxcbiAgICAvLyB3aGVyZWFzIGNzX2NvbXBhcmVfZGF0dW1zIHJldHVybnMgMSB0byBpbmRpY2F0ZSBUUlVFXG4gICAgLy8gY29uZnVzaW5nLCBzaG91bGQgZml4IHRoaXNcbiAgfVxuXG4gIC8vIEV4cGxpY2l0bHkgc2tpcCBkYXR1bSB0cmFuc2Zvcm0gYnkgc2V0dGluZyAnZGF0dW09bm9uZScgYXMgcGFyYW1ldGVyIGZvciBlaXRoZXIgc291cmNlIG9yIGRlc3RcbiAgaWYgKHNvdXJjZS5kYXR1bV90eXBlID09PSBQSkRfTk9EQVRVTSB8fCBkZXN0LmRhdHVtX3R5cGUgPT09IFBKRF9OT0RBVFVNKSB7XG4gICAgcmV0dXJuIHBvaW50O1xuICB9XG5cbiAgLy9ER1I6IDIwMTItMDctMjkgOiBhZGQgbmFkZ3JpZHMgc3VwcG9ydCAoYmVnaW4pXG4gIHZhciBzcmNfYSA9IHNvdXJjZS5hO1xuICB2YXIgc3JjX2VzID0gc291cmNlLmVzO1xuXG4gIHZhciBkc3RfYSA9IGRlc3QuYTtcbiAgdmFyIGRzdF9lcyA9IGRlc3QuZXM7XG5cbiAgdmFyIGZhbGxiYWNrID0gc291cmNlLmRhdHVtX3R5cGU7XG4gIC8vIElmIHRoaXMgZGF0dW0gcmVxdWlyZXMgZ3JpZCBzaGlmdHMsIHRoZW4gYXBwbHkgaXQgdG8gZ2VvZGV0aWMgY29vcmRpbmF0ZXMuXG4gIGlmIChmYWxsYmFjayA9PT0gUEpEX0dSSURTSElGVCkge1xuICAgIGlmICh0aGlzLmFwcGx5X2dyaWRzaGlmdChzb3VyY2UsIDAsIHBvaW50KSA9PT0gMCkge1xuICAgICAgc291cmNlLmEgPSBTUlNfV0dTODRfU0VNSU1BSk9SO1xuICAgICAgc291cmNlLmVzID0gU1JTX1dHUzg0X0VTUVVBUkVEO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIHRyeSAzIG9yIDcgcGFyYW1zIHRyYW5zZm9ybWF0aW9uIG9yIG5vdGhpbmcgP1xuICAgICAgaWYgKCFzb3VyY2UuZGF0dW1fcGFyYW1zKSB7XG4gICAgICAgIHNvdXJjZS5hID0gc3JjX2E7XG4gICAgICAgIHNvdXJjZS5lcyA9IHNvdXJjZS5lcztcbiAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgICAgfVxuICAgICAgd3AgPSAxO1xuICAgICAgZm9yIChpID0gMCwgbCA9IHNvdXJjZS5kYXR1bV9wYXJhbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHdwICo9IHNvdXJjZS5kYXR1bV9wYXJhbXNbaV07XG4gICAgICB9XG4gICAgICBpZiAod3AgPT09IDApIHtcbiAgICAgICAgc291cmNlLmEgPSBzcmNfYTtcbiAgICAgICAgc291cmNlLmVzID0gc291cmNlLmVzO1xuICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgICB9XG4gICAgICBpZiAoc291cmNlLmRhdHVtX3BhcmFtcy5sZW5ndGggPiAzKSB7XG4gICAgICAgIGZhbGxiYWNrID0gUEpEXzdQQVJBTTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBmYWxsYmFjayA9IFBKRF8zUEFSQU07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChkZXN0LmRhdHVtX3R5cGUgPT09IFBKRF9HUklEU0hJRlQpIHtcbiAgICBkZXN0LmEgPSBTUlNfV0dTODRfU0VNSU1BSk9SO1xuICAgIGRlc3QuZXMgPSBTUlNfV0dTODRfRVNRVUFSRUQ7XG4gIH1cbiAgLy8gRG8gd2UgbmVlZCB0byBnbyB0aHJvdWdoIGdlb2NlbnRyaWMgY29vcmRpbmF0ZXM/XG4gIGlmIChzb3VyY2UuZXMgIT09IGRlc3QuZXMgfHwgc291cmNlLmEgIT09IGRlc3QuYSB8fCBjaGVja1BhcmFtcyhmYWxsYmFjaykgfHwgY2hlY2tQYXJhbXMoZGVzdC5kYXR1bV90eXBlKSkge1xuICAgIC8vREdSOiAyMDEyLTA3LTI5IDogYWRkIG5hZGdyaWRzIHN1cHBvcnQgKGVuZClcbiAgICAvLyBDb252ZXJ0IHRvIGdlb2NlbnRyaWMgY29vcmRpbmF0ZXMuXG4gICAgc291cmNlLmdlb2RldGljX3RvX2dlb2NlbnRyaWMocG9pbnQpO1xuICAgIC8vIENIRUNLX1JFVFVSTjtcbiAgICAvLyBDb252ZXJ0IGJldHdlZW4gZGF0dW1zXG4gICAgaWYgKGNoZWNrUGFyYW1zKHNvdXJjZS5kYXR1bV90eXBlKSkge1xuICAgICAgc291cmNlLmdlb2NlbnRyaWNfdG9fd2dzODQocG9pbnQpO1xuICAgICAgLy8gQ0hFQ0tfUkVUVVJOO1xuICAgIH1cbiAgICBpZiAoY2hlY2tQYXJhbXMoZGVzdC5kYXR1bV90eXBlKSkge1xuICAgICAgZGVzdC5nZW9jZW50cmljX2Zyb21fd2dzODQocG9pbnQpO1xuICAgICAgLy8gQ0hFQ0tfUkVUVVJOO1xuICAgIH1cbiAgICAvLyBDb252ZXJ0IGJhY2sgdG8gZ2VvZGV0aWMgY29vcmRpbmF0ZXNcbiAgICBkZXN0Lmdlb2NlbnRyaWNfdG9fZ2VvZGV0aWMocG9pbnQpO1xuICAgIC8vIENIRUNLX1JFVFVSTjtcbiAgfVxuICAvLyBBcHBseSBncmlkIHNoaWZ0IHRvIGRlc3RpbmF0aW9uIGlmIHJlcXVpcmVkXG4gIGlmIChkZXN0LmRhdHVtX3R5cGUgPT09IFBKRF9HUklEU0hJRlQpIHtcbiAgICB0aGlzLmFwcGx5X2dyaWRzaGlmdChkZXN0LCAxLCBwb2ludCk7XG4gICAgLy8gQ0hFQ0tfUkVUVVJOO1xuICB9XG5cbiAgc291cmNlLmEgPSBzcmNfYTtcbiAgc291cmNlLmVzID0gc3JjX2VzO1xuICBkZXN0LmEgPSBkc3RfYTtcbiAgZGVzdC5lcyA9IGRzdF9lcztcblxuICByZXR1cm4gcG9pbnQ7XG59O1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHJvajQvbGliL2RhdHVtX3RyYW5zZm9ybS5qc1xuLy8gbW9kdWxlIGlkID0gMTMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("var Datum = __webpack_require__(126);\nvar Ellipsoid = __webpack_require__(127);\nvar extend = __webpack_require__(36);\nvar datum = __webpack_require__(131);\nvar EPSLN = 1.0e-10;\n// ellipoid pj_set_ell.c\nvar SIXTH = 0.1666666666666666667;\n/* 1/6 */\nvar RA4 = 0.04722222222222222222;\n/* 17/360 */\nvar RA6 = 0.02215608465608465608;\nmodule.exports = function(json) {\n  // DGR 2011-03-20 : nagrids -> nadgrids\n  if (json.datumCode && json.datumCode !== 'none') {\n    var datumDef = Datum[json.datumCode];\n    if (datumDef) {\n      json.datum_params = datumDef.towgs84 ? datumDef.towgs84.split(',') : null;\n      json.ellps = datumDef.ellipse;\n      json.datumName = datumDef.datumName ? datumDef.datumName : json.datumCode;\n    }\n  }\n  if (!json.a) { // do we have an ellipsoid?\n    var ellipse = Ellipsoid[json.ellps] ? Ellipsoid[json.ellps] : Ellipsoid.WGS84;\n    extend(json, ellipse);\n  }\n  if (json.rf && !json.b) {\n    json.b = (1.0 - 1.0 / json.rf) * json.a;\n  }\n  if (json.rf === 0 || Math.abs(json.a - json.b) < EPSLN) {\n    json.sphere = true;\n    json.b = json.a;\n  }\n  json.a2 = json.a * json.a; // used in geocentric\n  json.b2 = json.b * json.b; // used in geocentric\n  json.es = (json.a2 - json.b2) / json.a2; // e ^ 2\n  json.e = Math.sqrt(json.es); // eccentricity\n  if (json.R_A) {\n    json.a *= 1 - json.es * (SIXTH + json.es * (RA4 + json.es * RA6));\n    json.a2 = json.a * json.a;\n    json.b2 = json.b * json.b;\n    json.es = 0;\n  }\n  json.ep2 = (json.a2 - json.b2) / json.b2; // used in geocentric\n  if (!json.k0) {\n    json.k0 = 1.0; //default value\n  }\n  //DGR 2010-11-12: axis\n  if (!json.axis) {\n    json.axis = \"enu\";\n  }\n\n  if (!json.datum) {\n    json.datum = datum(json);\n  }\n  return json;\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9kZXJpdmVDb25zdGFudHMuanM/YTI0MiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsNEJBQTRCO0FBQzVCLDBDQUEwQztBQUMxQyw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxMzMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgRGF0dW0gPSByZXF1aXJlKCcuL2NvbnN0YW50cy9EYXR1bScpO1xudmFyIEVsbGlwc29pZCA9IHJlcXVpcmUoJy4vY29uc3RhbnRzL0VsbGlwc29pZCcpO1xudmFyIGV4dGVuZCA9IHJlcXVpcmUoJy4vZXh0ZW5kJyk7XG52YXIgZGF0dW0gPSByZXF1aXJlKCcuL2RhdHVtJyk7XG52YXIgRVBTTE4gPSAxLjBlLTEwO1xuLy8gZWxsaXBvaWQgcGpfc2V0X2VsbC5jXG52YXIgU0lYVEggPSAwLjE2NjY2NjY2NjY2NjY2NjY2Njc7XG4vKiAxLzYgKi9cbnZhciBSQTQgPSAwLjA0NzIyMjIyMjIyMjIyMjIyMjIyO1xuLyogMTcvMzYwICovXG52YXIgUkE2ID0gMC4wMjIxNTYwODQ2NTYwODQ2NTYwODtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oanNvbikge1xuICAvLyBER1IgMjAxMS0wMy0yMCA6IG5hZ3JpZHMgLT4gbmFkZ3JpZHNcbiAgaWYgKGpzb24uZGF0dW1Db2RlICYmIGpzb24uZGF0dW1Db2RlICE9PSAnbm9uZScpIHtcbiAgICB2YXIgZGF0dW1EZWYgPSBEYXR1bVtqc29uLmRhdHVtQ29kZV07XG4gICAgaWYgKGRhdHVtRGVmKSB7XG4gICAgICBqc29uLmRhdHVtX3BhcmFtcyA9IGRhdHVtRGVmLnRvd2dzODQgPyBkYXR1bURlZi50b3dnczg0LnNwbGl0KCcsJykgOiBudWxsO1xuICAgICAganNvbi5lbGxwcyA9IGRhdHVtRGVmLmVsbGlwc2U7XG4gICAgICBqc29uLmRhdHVtTmFtZSA9IGRhdHVtRGVmLmRhdHVtTmFtZSA/IGRhdHVtRGVmLmRhdHVtTmFtZSA6IGpzb24uZGF0dW1Db2RlO1xuICAgIH1cbiAgfVxuICBpZiAoIWpzb24uYSkgeyAvLyBkbyB3ZSBoYXZlIGFuIGVsbGlwc29pZD9cbiAgICB2YXIgZWxsaXBzZSA9IEVsbGlwc29pZFtqc29uLmVsbHBzXSA/IEVsbGlwc29pZFtqc29uLmVsbHBzXSA6IEVsbGlwc29pZC5XR1M4NDtcbiAgICBleHRlbmQoanNvbiwgZWxsaXBzZSk7XG4gIH1cbiAgaWYgKGpzb24ucmYgJiYgIWpzb24uYikge1xuICAgIGpzb24uYiA9ICgxLjAgLSAxLjAgLyBqc29uLnJmKSAqIGpzb24uYTtcbiAgfVxuICBpZiAoanNvbi5yZiA9PT0gMCB8fCBNYXRoLmFicyhqc29uLmEgLSBqc29uLmIpIDwgRVBTTE4pIHtcbiAgICBqc29uLnNwaGVyZSA9IHRydWU7XG4gICAganNvbi5iID0ganNvbi5hO1xuICB9XG4gIGpzb24uYTIgPSBqc29uLmEgKiBqc29uLmE7IC8vIHVzZWQgaW4gZ2VvY2VudHJpY1xuICBqc29uLmIyID0ganNvbi5iICoganNvbi5iOyAvLyB1c2VkIGluIGdlb2NlbnRyaWNcbiAganNvbi5lcyA9IChqc29uLmEyIC0ganNvbi5iMikgLyBqc29uLmEyOyAvLyBlIF4gMlxuICBqc29uLmUgPSBNYXRoLnNxcnQoanNvbi5lcyk7IC8vIGVjY2VudHJpY2l0eVxuICBpZiAoanNvbi5SX0EpIHtcbiAgICBqc29uLmEgKj0gMSAtIGpzb24uZXMgKiAoU0lYVEggKyBqc29uLmVzICogKFJBNCArIGpzb24uZXMgKiBSQTYpKTtcbiAgICBqc29uLmEyID0ganNvbi5hICoganNvbi5hO1xuICAgIGpzb24uYjIgPSBqc29uLmIgKiBqc29uLmI7XG4gICAganNvbi5lcyA9IDA7XG4gIH1cbiAganNvbi5lcDIgPSAoanNvbi5hMiAtIGpzb24uYjIpIC8ganNvbi5iMjsgLy8gdXNlZCBpbiBnZW9jZW50cmljXG4gIGlmICghanNvbi5rMCkge1xuICAgIGpzb24uazAgPSAxLjA7IC8vZGVmYXVsdCB2YWx1ZVxuICB9XG4gIC8vREdSIDIwMTAtMTEtMTI6IGF4aXNcbiAgaWYgKCFqc29uLmF4aXMpIHtcbiAgICBqc29uLmF4aXMgPSBcImVudVwiO1xuICB9XG5cbiAgaWYgKCFqc29uLmRhdHVtKSB7XG4gICAganNvbi5kYXR1bSA9IGRhdHVtKGpzb24pO1xuICB9XG4gIHJldHVybiBqc29uO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcm9qNC9saWIvZGVyaXZlQ29uc3RhbnRzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports){eval("module.exports = function(defs) {\n  defs('EPSG:4326', \"+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees\");\n  defs('EPSG:4269', \"+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees\");\n  defs('EPSG:3857', \"+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs\");\n\n  defs.WGS84 = defs['EPSG:4326'];\n  defs['EPSG:3785'] = defs['EPSG:3857']; // maintain backward compat, official code is 3857\n  defs.GOOGLE = defs['EPSG:3857'];\n  defs['EPSG:900913'] = defs['EPSG:3857'];\n  defs['EPSG:102113'] = defs['EPSG:3857'];\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9nbG9iYWwuanM/NTFhYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxMzQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGRlZnMpIHtcbiAgZGVmcygnRVBTRzo0MzI2JywgXCIrdGl0bGU9V0dTIDg0IChsb25nL2xhdCkgK3Byb2o9bG9uZ2xhdCArZWxscHM9V0dTODQgK2RhdHVtPVdHUzg0ICt1bml0cz1kZWdyZWVzXCIpO1xuICBkZWZzKCdFUFNHOjQyNjknLCBcIit0aXRsZT1OQUQ4MyAobG9uZy9sYXQpICtwcm9qPWxvbmdsYXQgK2E9NjM3ODEzNy4wICtiPTYzNTY3NTIuMzE0MTQwMzYgK2VsbHBzPUdSUzgwICtkYXR1bT1OQUQ4MyArdW5pdHM9ZGVncmVlc1wiKTtcbiAgZGVmcygnRVBTRzozODU3JywgXCIrdGl0bGU9V0dTIDg0IC8gUHNldWRvLU1lcmNhdG9yICtwcm9qPW1lcmMgK2E9NjM3ODEzNyArYj02Mzc4MTM3ICtsYXRfdHM9MC4wICtsb25fMD0wLjAgK3hfMD0wLjAgK3lfMD0wICtrPTEuMCArdW5pdHM9bSArbmFkZ3JpZHM9QG51bGwgK25vX2RlZnNcIik7XG5cbiAgZGVmcy5XR1M4NCA9IGRlZnNbJ0VQU0c6NDMyNiddO1xuICBkZWZzWydFUFNHOjM3ODUnXSA9IGRlZnNbJ0VQU0c6Mzg1NyddOyAvLyBtYWludGFpbiBiYWNrd2FyZCBjb21wYXQsIG9mZmljaWFsIGNvZGUgaXMgMzg1N1xuICBkZWZzLkdPT0dMRSA9IGRlZnNbJ0VQU0c6Mzg1NyddO1xuICBkZWZzWydFUFNHOjkwMDkxMyddID0gZGVmc1snRVBTRzozODU3J107XG4gIGRlZnNbJ0VQU0c6MTAyMTEzJ10gPSBkZWZzWydFUFNHOjM4NTcnXTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHJvajQvbGliL2dsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gMTM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=")},function(module,exports,__webpack_require__){eval("var projs = [\n  __webpack_require__(65),\n  __webpack_require__(160),\n  __webpack_require__(159),\n  __webpack_require__(158),\n  __webpack_require__(157),\n  __webpack_require__(154),\n  __webpack_require__(148),\n  __webpack_require__(146),\n  __webpack_require__(140),\n  __webpack_require__(147),\n  __webpack_require__(138),\n  __webpack_require__(145),\n  __webpack_require__(141),\n  __webpack_require__(142),\n  __webpack_require__(155),\n  __webpack_require__(153),\n  __webpack_require__(151),\n  __webpack_require__(156),\n  __webpack_require__(152),\n  __webpack_require__(143),\n  __webpack_require__(161),\n  __webpack_require__(139)\n];\nmodule.exports = function(proj4){\n  projs.forEach(function(proj){\n    proj4.Proj.projections.add(proj);\n  });\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9pbmNsdWRlZFByb2plY3Rpb25zLmpzP2YwZmIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIIiwiZmlsZSI6IjEzNS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBwcm9qcyA9IFtcbiAgcmVxdWlyZSgnLi9wcm9qZWN0aW9ucy90bWVyYycpLFxuICByZXF1aXJlKCcuL3Byb2plY3Rpb25zL3V0bScpLFxuICByZXF1aXJlKCcuL3Byb2plY3Rpb25zL3N0ZXJlYScpLFxuICByZXF1aXJlKCcuL3Byb2plY3Rpb25zL3N0ZXJlJyksXG4gIHJlcXVpcmUoJy4vcHJvamVjdGlvbnMvc29tZXJjJyksXG4gIHJlcXVpcmUoJy4vcHJvamVjdGlvbnMvb21lcmMnKSxcbiAgcmVxdWlyZSgnLi9wcm9qZWN0aW9ucy9sY2MnKSxcbiAgcmVxdWlyZSgnLi9wcm9qZWN0aW9ucy9rcm92YWsnKSxcbiAgcmVxdWlyZSgnLi9wcm9qZWN0aW9ucy9jYXNzJyksXG4gIHJlcXVpcmUoJy4vcHJvamVjdGlvbnMvbGFlYScpLFxuICByZXF1aXJlKCcuL3Byb2plY3Rpb25zL2FlYScpLFxuICByZXF1aXJlKCcuL3Byb2plY3Rpb25zL2dub20nKSxcbiAgcmVxdWlyZSgnLi9wcm9qZWN0aW9ucy9jZWEnKSxcbiAgcmVxdWlyZSgnLi9wcm9qZWN0aW9ucy9lcWMnKSxcbiAgcmVxdWlyZSgnLi9wcm9qZWN0aW9ucy9wb2x5JyksXG4gIHJlcXVpcmUoJy4vcHJvamVjdGlvbnMvbnptZycpLFxuICByZXF1aXJlKCcuL3Byb2plY3Rpb25zL21pbGwnKSxcbiAgcmVxdWlyZSgnLi9wcm9qZWN0aW9ucy9zaW51JyksXG4gIHJlcXVpcmUoJy4vcHJvamVjdGlvbnMvbW9sbCcpLFxuICByZXF1aXJlKCcuL3Byb2plY3Rpb25zL2VxZGMnKSxcbiAgcmVxdWlyZSgnLi9wcm9qZWN0aW9ucy92YW5kZycpLFxuICByZXF1aXJlKCcuL3Byb2plY3Rpb25zL2FlcWQnKVxuXTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocHJvajQpe1xuICBwcm9qcy5mb3JFYWNoKGZ1bmN0aW9uKHByb2ope1xuICAgIHByb2o0LlByb2oucHJvamVjdGlvbnMuYWRkKHByb2opO1xuICB9KTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Byb2o0L2xpYi9pbmNsdWRlZFByb2plY3Rpb25zLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval("var defs = __webpack_require__(62);\nvar wkt = __webpack_require__(67);\nvar projStr = __webpack_require__(64);\nfunction testObj(code){\n  return typeof code === 'string';\n}\nfunction testDef(code){\n  return code in defs;\n}\nfunction testWKT(code){\n  var codeWords = ['GEOGCS','GEOCCS','PROJCS','LOCAL_CS'];\n  return codeWords.reduce(function(a,b){\n    return a+1+code.indexOf(b);\n  },0);\n}\nfunction testProj(code){\n  return code[0] === '+';\n}\nfunction parse(code){\n  if (testObj(code)) {\n    //check to see if this is a WKT string\n    if (testDef(code)) {\n      return defs[code];\n    }\n    else if (testWKT(code)) {\n      return wkt(code);\n    }\n    else if (testProj(code)) {\n      return projStr(code);\n    }\n  }else{\n    return code;\n  }\n}\n\nmodule.exports = parse;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9wYXJzZUNvZGUuanM/MGUwMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMTM2LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGRlZnMgPSByZXF1aXJlKCcuL2RlZnMnKTtcbnZhciB3a3QgPSByZXF1aXJlKCcuL3drdCcpO1xudmFyIHByb2pTdHIgPSByZXF1aXJlKCcuL3Byb2pTdHJpbmcnKTtcbmZ1bmN0aW9uIHRlc3RPYmooY29kZSl7XG4gIHJldHVybiB0eXBlb2YgY29kZSA9PT0gJ3N0cmluZyc7XG59XG5mdW5jdGlvbiB0ZXN0RGVmKGNvZGUpe1xuICByZXR1cm4gY29kZSBpbiBkZWZzO1xufVxuZnVuY3Rpb24gdGVzdFdLVChjb2RlKXtcbiAgdmFyIGNvZGVXb3JkcyA9IFsnR0VPR0NTJywnR0VPQ0NTJywnUFJPSkNTJywnTE9DQUxfQ1MnXTtcbiAgcmV0dXJuIGNvZGVXb3Jkcy5yZWR1Y2UoZnVuY3Rpb24oYSxiKXtcbiAgICByZXR1cm4gYSsxK2NvZGUuaW5kZXhPZihiKTtcbiAgfSwwKTtcbn1cbmZ1bmN0aW9uIHRlc3RQcm9qKGNvZGUpe1xuICByZXR1cm4gY29kZVswXSA9PT0gJysnO1xufVxuZnVuY3Rpb24gcGFyc2UoY29kZSl7XG4gIGlmICh0ZXN0T2JqKGNvZGUpKSB7XG4gICAgLy9jaGVjayB0byBzZWUgaWYgdGhpcyBpcyBhIFdLVCBzdHJpbmdcbiAgICBpZiAodGVzdERlZihjb2RlKSkge1xuICAgICAgcmV0dXJuIGRlZnNbY29kZV07XG4gICAgfVxuICAgIGVsc2UgaWYgKHRlc3RXS1QoY29kZSkpIHtcbiAgICAgIHJldHVybiB3a3QoY29kZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRlc3RQcm9qKGNvZGUpKSB7XG4gICAgICByZXR1cm4gcHJvalN0cihjb2RlKTtcbiAgICB9XG4gIH1lbHNle1xuICAgIHJldHVybiBjb2RlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2U7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Byb2o0L2xpYi9wYXJzZUNvZGUuanNcbi8vIG1vZHVsZSBpZCA9IDEzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval("var projs = [\n  __webpack_require__(150),\n  __webpack_require__(149)\n];\nvar names = {};\nvar projStore = [];\n\nfunction add(proj, i) {\n  var len = projStore.length;\n  if (!proj.names) {\n    console.log(i);\n    return true;\n  }\n  projStore[len] = proj;\n  proj.names.forEach(function(n) {\n    names[n.toLowerCase()] = len;\n  });\n  return this;\n}\n\nexports.add = add;\n\nexports.get = function(name) {\n  if (!name) {\n    return false;\n  }\n  var n = name.toLowerCase();\n  if (typeof names[n] !== 'undefined' && projStore[names[n]]) {\n    return projStore[names[n]];\n  }\n};\nexports.start = function() {\n  projs.forEach(add);\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9wcm9qZWN0aW9ucy5qcz9lNWMxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTM3LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIHByb2pzID0gW1xuICByZXF1aXJlKCcuL3Byb2plY3Rpb25zL21lcmMnKSxcbiAgcmVxdWlyZSgnLi9wcm9qZWN0aW9ucy9sb25nbGF0Jylcbl07XG52YXIgbmFtZXMgPSB7fTtcbnZhciBwcm9qU3RvcmUgPSBbXTtcblxuZnVuY3Rpb24gYWRkKHByb2osIGkpIHtcbiAgdmFyIGxlbiA9IHByb2pTdG9yZS5sZW5ndGg7XG4gIGlmICghcHJvai5uYW1lcykge1xuICAgIGNvbnNvbGUubG9nKGkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHByb2pTdG9yZVtsZW5dID0gcHJvajtcbiAgcHJvai5uYW1lcy5mb3JFYWNoKGZ1bmN0aW9uKG4pIHtcbiAgICBuYW1lc1tuLnRvTG93ZXJDYXNlKCldID0gbGVuO1xuICB9KTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbmV4cG9ydHMuYWRkID0gYWRkO1xuXG5leHBvcnRzLmdldCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgaWYgKCFuYW1lKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBuID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICBpZiAodHlwZW9mIG5hbWVzW25dICE9PSAndW5kZWZpbmVkJyAmJiBwcm9qU3RvcmVbbmFtZXNbbl1dKSB7XG4gICAgcmV0dXJuIHByb2pTdG9yZVtuYW1lc1tuXV07XG4gIH1cbn07XG5leHBvcnRzLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gIHByb2pzLmZvckVhY2goYWRkKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHJvajQvbGliL3Byb2plY3Rpb25zLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval('var EPSLN = 1.0e-10;\nvar msfnz = __webpack_require__(8);\nvar qsfnz = __webpack_require__(35);\nvar adjust_lon = __webpack_require__(0);\nvar asinz = __webpack_require__(7);\nexports.init = function() {\n\n  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {\n    return;\n  }\n  this.temp = this.b / this.a;\n  this.es = 1 - Math.pow(this.temp, 2);\n  this.e3 = Math.sqrt(this.es);\n\n  this.sin_po = Math.sin(this.lat1);\n  this.cos_po = Math.cos(this.lat1);\n  this.t1 = this.sin_po;\n  this.con = this.sin_po;\n  this.ms1 = msfnz(this.e3, this.sin_po, this.cos_po);\n  this.qs1 = qsfnz(this.e3, this.sin_po, this.cos_po);\n\n  this.sin_po = Math.sin(this.lat2);\n  this.cos_po = Math.cos(this.lat2);\n  this.t2 = this.sin_po;\n  this.ms2 = msfnz(this.e3, this.sin_po, this.cos_po);\n  this.qs2 = qsfnz(this.e3, this.sin_po, this.cos_po);\n\n  this.sin_po = Math.sin(this.lat0);\n  this.cos_po = Math.cos(this.lat0);\n  this.t3 = this.sin_po;\n  this.qs0 = qsfnz(this.e3, this.sin_po, this.cos_po);\n\n  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {\n    this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1);\n  }\n  else {\n    this.ns0 = this.con;\n  }\n  this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1;\n  this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0;\n};\n\n/* Albers Conical Equal Area forward equations--mapping lat,long to x,y\n  -------------------------------------------------------------------*/\nexports.forward = function(p) {\n\n  var lon = p.x;\n  var lat = p.y;\n\n  this.sin_phi = Math.sin(lat);\n  this.cos_phi = Math.cos(lat);\n\n  var qs = qsfnz(this.e3, this.sin_phi, this.cos_phi);\n  var rh1 = this.a * Math.sqrt(this.c - this.ns0 * qs) / this.ns0;\n  var theta = this.ns0 * adjust_lon(lon - this.long0);\n  var x = rh1 * Math.sin(theta) + this.x0;\n  var y = this.rh - rh1 * Math.cos(theta) + this.y0;\n\n  p.x = x;\n  p.y = y;\n  return p;\n};\n\n\nexports.inverse = function(p) {\n  var rh1, qs, con, theta, lon, lat;\n\n  p.x -= this.x0;\n  p.y = this.rh - p.y + this.y0;\n  if (this.ns0 >= 0) {\n    rh1 = Math.sqrt(p.x * p.x + p.y * p.y);\n    con = 1;\n  }\n  else {\n    rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);\n    con = -1;\n  }\n  theta = 0;\n  if (rh1 !== 0) {\n    theta = Math.atan2(con * p.x, con * p.y);\n  }\n  con = rh1 * this.ns0 / this.a;\n  if (this.sphere) {\n    lat = Math.asin((this.c - con * con) / (2 * this.ns0));\n  }\n  else {\n    qs = (this.c - con * con) / this.ns0;\n    lat = this.phi1z(this.e3, qs);\n  }\n\n  lon = adjust_lon(theta / this.ns0 + this.long0);\n  p.x = lon;\n  p.y = lat;\n  return p;\n};\n\n/* Function to compute phi1, the latitude for the inverse of the\n   Albers Conical Equal-Area projection.\n-------------------------------------------*/\nexports.phi1z = function(eccent, qs) {\n  var sinphi, cosphi, con, com, dphi;\n  var phi = asinz(0.5 * qs);\n  if (eccent < EPSLN) {\n    return phi;\n  }\n\n  var eccnts = eccent * eccent;\n  for (var i = 1; i <= 25; i++) {\n    sinphi = Math.sin(phi);\n    cosphi = Math.cos(phi);\n    con = eccent * sinphi;\n    com = 1 - con * con;\n    dphi = 0.5 * com * com / cosphi * (qs / (1 - eccnts) - sinphi / com + 0.5 / eccent * Math.log((1 - con) / (1 + con)));\n    phi = phi + dphi;\n    if (Math.abs(dphi) <= 1e-7) {\n      return phi;\n    }\n  }\n  return null;\n};\nexports.names = ["Albers_Conic_Equal_Area", "Albers", "aea"];\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9hZWEuanM/NWJkNCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxMzguanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgRVBTTE4gPSAxLjBlLTEwO1xudmFyIG1zZm56ID0gcmVxdWlyZSgnLi4vY29tbW9uL21zZm56Jyk7XG52YXIgcXNmbnogPSByZXF1aXJlKCcuLi9jb21tb24vcXNmbnonKTtcbnZhciBhZGp1c3RfbG9uID0gcmVxdWlyZSgnLi4vY29tbW9uL2FkanVzdF9sb24nKTtcbnZhciBhc2lueiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9hc2lueicpO1xuZXhwb3J0cy5pbml0ID0gZnVuY3Rpb24oKSB7XG5cbiAgaWYgKE1hdGguYWJzKHRoaXMubGF0MSArIHRoaXMubGF0MikgPCBFUFNMTikge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLnRlbXAgPSB0aGlzLmIgLyB0aGlzLmE7XG4gIHRoaXMuZXMgPSAxIC0gTWF0aC5wb3codGhpcy50ZW1wLCAyKTtcbiAgdGhpcy5lMyA9IE1hdGguc3FydCh0aGlzLmVzKTtcblxuICB0aGlzLnNpbl9wbyA9IE1hdGguc2luKHRoaXMubGF0MSk7XG4gIHRoaXMuY29zX3BvID0gTWF0aC5jb3ModGhpcy5sYXQxKTtcbiAgdGhpcy50MSA9IHRoaXMuc2luX3BvO1xuICB0aGlzLmNvbiA9IHRoaXMuc2luX3BvO1xuICB0aGlzLm1zMSA9IG1zZm56KHRoaXMuZTMsIHRoaXMuc2luX3BvLCB0aGlzLmNvc19wbyk7XG4gIHRoaXMucXMxID0gcXNmbnoodGhpcy5lMywgdGhpcy5zaW5fcG8sIHRoaXMuY29zX3BvKTtcblxuICB0aGlzLnNpbl9wbyA9IE1hdGguc2luKHRoaXMubGF0Mik7XG4gIHRoaXMuY29zX3BvID0gTWF0aC5jb3ModGhpcy5sYXQyKTtcbiAgdGhpcy50MiA9IHRoaXMuc2luX3BvO1xuICB0aGlzLm1zMiA9IG1zZm56KHRoaXMuZTMsIHRoaXMuc2luX3BvLCB0aGlzLmNvc19wbyk7XG4gIHRoaXMucXMyID0gcXNmbnoodGhpcy5lMywgdGhpcy5zaW5fcG8sIHRoaXMuY29zX3BvKTtcblxuICB0aGlzLnNpbl9wbyA9IE1hdGguc2luKHRoaXMubGF0MCk7XG4gIHRoaXMuY29zX3BvID0gTWF0aC5jb3ModGhpcy5sYXQwKTtcbiAgdGhpcy50MyA9IHRoaXMuc2luX3BvO1xuICB0aGlzLnFzMCA9IHFzZm56KHRoaXMuZTMsIHRoaXMuc2luX3BvLCB0aGlzLmNvc19wbyk7XG5cbiAgaWYgKE1hdGguYWJzKHRoaXMubGF0MSAtIHRoaXMubGF0MikgPiBFUFNMTikge1xuICAgIHRoaXMubnMwID0gKHRoaXMubXMxICogdGhpcy5tczEgLSB0aGlzLm1zMiAqIHRoaXMubXMyKSAvICh0aGlzLnFzMiAtIHRoaXMucXMxKTtcbiAgfVxuICBlbHNlIHtcbiAgICB0aGlzLm5zMCA9IHRoaXMuY29uO1xuICB9XG4gIHRoaXMuYyA9IHRoaXMubXMxICogdGhpcy5tczEgKyB0aGlzLm5zMCAqIHRoaXMucXMxO1xuICB0aGlzLnJoID0gdGhpcy5hICogTWF0aC5zcXJ0KHRoaXMuYyAtIHRoaXMubnMwICogdGhpcy5xczApIC8gdGhpcy5uczA7XG59O1xuXG4vKiBBbGJlcnMgQ29uaWNhbCBFcXVhbCBBcmVhIGZvcndhcmQgZXF1YXRpb25zLS1tYXBwaW5nIGxhdCxsb25nIHRvIHgseVxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmV4cG9ydHMuZm9yd2FyZCA9IGZ1bmN0aW9uKHApIHtcblxuICB2YXIgbG9uID0gcC54O1xuICB2YXIgbGF0ID0gcC55O1xuXG4gIHRoaXMuc2luX3BoaSA9IE1hdGguc2luKGxhdCk7XG4gIHRoaXMuY29zX3BoaSA9IE1hdGguY29zKGxhdCk7XG5cbiAgdmFyIHFzID0gcXNmbnoodGhpcy5lMywgdGhpcy5zaW5fcGhpLCB0aGlzLmNvc19waGkpO1xuICB2YXIgcmgxID0gdGhpcy5hICogTWF0aC5zcXJ0KHRoaXMuYyAtIHRoaXMubnMwICogcXMpIC8gdGhpcy5uczA7XG4gIHZhciB0aGV0YSA9IHRoaXMubnMwICogYWRqdXN0X2xvbihsb24gLSB0aGlzLmxvbmcwKTtcbiAgdmFyIHggPSByaDEgKiBNYXRoLnNpbih0aGV0YSkgKyB0aGlzLngwO1xuICB2YXIgeSA9IHRoaXMucmggLSByaDEgKiBNYXRoLmNvcyh0aGV0YSkgKyB0aGlzLnkwO1xuXG4gIHAueCA9IHg7XG4gIHAueSA9IHk7XG4gIHJldHVybiBwO1xufTtcblxuXG5leHBvcnRzLmludmVyc2UgPSBmdW5jdGlvbihwKSB7XG4gIHZhciByaDEsIHFzLCBjb24sIHRoZXRhLCBsb24sIGxhdDtcblxuICBwLnggLT0gdGhpcy54MDtcbiAgcC55ID0gdGhpcy5yaCAtIHAueSArIHRoaXMueTA7XG4gIGlmICh0aGlzLm5zMCA+PSAwKSB7XG4gICAgcmgxID0gTWF0aC5zcXJ0KHAueCAqIHAueCArIHAueSAqIHAueSk7XG4gICAgY29uID0gMTtcbiAgfVxuICBlbHNlIHtcbiAgICByaDEgPSAtTWF0aC5zcXJ0KHAueCAqIHAueCArIHAueSAqIHAueSk7XG4gICAgY29uID0gLTE7XG4gIH1cbiAgdGhldGEgPSAwO1xuICBpZiAocmgxICE9PSAwKSB7XG4gICAgdGhldGEgPSBNYXRoLmF0YW4yKGNvbiAqIHAueCwgY29uICogcC55KTtcbiAgfVxuICBjb24gPSByaDEgKiB0aGlzLm5zMCAvIHRoaXMuYTtcbiAgaWYgKHRoaXMuc3BoZXJlKSB7XG4gICAgbGF0ID0gTWF0aC5hc2luKCh0aGlzLmMgLSBjb24gKiBjb24pIC8gKDIgKiB0aGlzLm5zMCkpO1xuICB9XG4gIGVsc2Uge1xuICAgIHFzID0gKHRoaXMuYyAtIGNvbiAqIGNvbikgLyB0aGlzLm5zMDtcbiAgICBsYXQgPSB0aGlzLnBoaTF6KHRoaXMuZTMsIHFzKTtcbiAgfVxuXG4gIGxvbiA9IGFkanVzdF9sb24odGhldGEgLyB0aGlzLm5zMCArIHRoaXMubG9uZzApO1xuICBwLnggPSBsb247XG4gIHAueSA9IGxhdDtcbiAgcmV0dXJuIHA7XG59O1xuXG4vKiBGdW5jdGlvbiB0byBjb21wdXRlIHBoaTEsIHRoZSBsYXRpdHVkZSBmb3IgdGhlIGludmVyc2Ugb2YgdGhlXG4gICBBbGJlcnMgQ29uaWNhbCBFcXVhbC1BcmVhIHByb2plY3Rpb24uXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmV4cG9ydHMucGhpMXogPSBmdW5jdGlvbihlY2NlbnQsIHFzKSB7XG4gIHZhciBzaW5waGksIGNvc3BoaSwgY29uLCBjb20sIGRwaGk7XG4gIHZhciBwaGkgPSBhc2lueigwLjUgKiBxcyk7XG4gIGlmIChlY2NlbnQgPCBFUFNMTikge1xuICAgIHJldHVybiBwaGk7XG4gIH1cblxuICB2YXIgZWNjbnRzID0gZWNjZW50ICogZWNjZW50O1xuICBmb3IgKHZhciBpID0gMTsgaSA8PSAyNTsgaSsrKSB7XG4gICAgc2lucGhpID0gTWF0aC5zaW4ocGhpKTtcbiAgICBjb3NwaGkgPSBNYXRoLmNvcyhwaGkpO1xuICAgIGNvbiA9IGVjY2VudCAqIHNpbnBoaTtcbiAgICBjb20gPSAxIC0gY29uICogY29uO1xuICAgIGRwaGkgPSAwLjUgKiBjb20gKiBjb20gLyBjb3NwaGkgKiAocXMgLyAoMSAtIGVjY250cykgLSBzaW5waGkgLyBjb20gKyAwLjUgLyBlY2NlbnQgKiBNYXRoLmxvZygoMSAtIGNvbikgLyAoMSArIGNvbikpKTtcbiAgICBwaGkgPSBwaGkgKyBkcGhpO1xuICAgIGlmIChNYXRoLmFicyhkcGhpKSA8PSAxZS03KSB7XG4gICAgICByZXR1cm4gcGhpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5leHBvcnRzLm5hbWVzID0gW1wiQWxiZXJzX0NvbmljX0VxdWFsX0FyZWFcIiwgXCJBbGJlcnNcIiwgXCJhZWFcIl07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHJvajQvbGliL3Byb2plY3Rpb25zL2FlYS5qc1xuLy8gbW9kdWxlIGlkID0gMTM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,exports,__webpack_require__){eval('var adjust_lon = __webpack_require__(0);\nvar HALF_PI = Math.PI/2;\nvar EPSLN = 1.0e-10;\nvar mlfn = __webpack_require__(16);\nvar e0fn = __webpack_require__(12);\nvar e1fn = __webpack_require__(13);\nvar e2fn = __webpack_require__(14);\nvar e3fn = __webpack_require__(15);\nvar gN = __webpack_require__(33);\nvar asinz = __webpack_require__(7);\nvar imlfn = __webpack_require__(34);\nexports.init = function() {\n  this.sin_p12 = Math.sin(this.lat0);\n  this.cos_p12 = Math.cos(this.lat0);\n};\n\nexports.forward = function(p) {\n  var lon = p.x;\n  var lat = p.y;\n  var sinphi = Math.sin(p.y);\n  var cosphi = Math.cos(p.y);\n  var dlon = adjust_lon(lon - this.long0);\n  var e0, e1, e2, e3, Mlp, Ml, tanphi, Nl1, Nl, psi, Az, G, H, GH, Hs, c, kp, cos_c, s, s2, s3, s4, s5;\n  if (this.sphere) {\n    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {\n      //North Pole case\n      p.x = this.x0 + this.a * (HALF_PI - lat) * Math.sin(dlon);\n      p.y = this.y0 - this.a * (HALF_PI - lat) * Math.cos(dlon);\n      return p;\n    }\n    else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {\n      //South Pole case\n      p.x = this.x0 + this.a * (HALF_PI + lat) * Math.sin(dlon);\n      p.y = this.y0 + this.a * (HALF_PI + lat) * Math.cos(dlon);\n      return p;\n    }\n    else {\n      //default case\n      cos_c = this.sin_p12 * sinphi + this.cos_p12 * cosphi * Math.cos(dlon);\n      c = Math.acos(cos_c);\n      kp = c / Math.sin(c);\n      p.x = this.x0 + this.a * kp * cosphi * Math.sin(dlon);\n      p.y = this.y0 + this.a * kp * (this.cos_p12 * sinphi - this.sin_p12 * cosphi * Math.cos(dlon));\n      return p;\n    }\n  }\n  else {\n    e0 = e0fn(this.es);\n    e1 = e1fn(this.es);\n    e2 = e2fn(this.es);\n    e3 = e3fn(this.es);\n    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {\n      //North Pole case\n      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);\n      Ml = this.a * mlfn(e0, e1, e2, e3, lat);\n      p.x = this.x0 + (Mlp - Ml) * Math.sin(dlon);\n      p.y = this.y0 - (Mlp - Ml) * Math.cos(dlon);\n      return p;\n    }\n    else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {\n      //South Pole case\n      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);\n      Ml = this.a * mlfn(e0, e1, e2, e3, lat);\n      p.x = this.x0 + (Mlp + Ml) * Math.sin(dlon);\n      p.y = this.y0 + (Mlp + Ml) * Math.cos(dlon);\n      return p;\n    }\n    else {\n      //Default case\n      tanphi = sinphi / cosphi;\n      Nl1 = gN(this.a, this.e, this.sin_p12);\n      Nl = gN(this.a, this.e, sinphi);\n      psi = Math.atan((1 - this.es) * tanphi + this.es * Nl1 * this.sin_p12 / (Nl * cosphi));\n      Az = Math.atan2(Math.sin(dlon), this.cos_p12 * Math.tan(psi) - this.sin_p12 * Math.cos(dlon));\n      if (Az === 0) {\n        s = Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));\n      }\n      else if (Math.abs(Math.abs(Az) - Math.PI) <= EPSLN) {\n        s = -Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));\n      }\n      else {\n        s = Math.asin(Math.sin(dlon) * Math.cos(psi) / Math.sin(Az));\n      }\n      G = this.e * this.sin_p12 / Math.sqrt(1 - this.es);\n      H = this.e * this.cos_p12 * Math.cos(Az) / Math.sqrt(1 - this.es);\n      GH = G * H;\n      Hs = H * H;\n      s2 = s * s;\n      s3 = s2 * s;\n      s4 = s3 * s;\n      s5 = s4 * s;\n      c = Nl1 * s * (1 - s2 * Hs * (1 - Hs) / 6 + s3 / 8 * GH * (1 - 2 * Hs) + s4 / 120 * (Hs * (4 - 7 * Hs) - 3 * G * G * (1 - 7 * Hs)) - s5 / 48 * GH);\n      p.x = this.x0 + c * Math.sin(Az);\n      p.y = this.y0 + c * Math.cos(Az);\n      return p;\n    }\n  }\n\n\n};\n\nexports.inverse = function(p) {\n  p.x -= this.x0;\n  p.y -= this.y0;\n  var rh, z, sinz, cosz, lon, lat, con, e0, e1, e2, e3, Mlp, M, N1, psi, Az, cosAz, tmp, A, B, D, Ee, F;\n  if (this.sphere) {\n    rh = Math.sqrt(p.x * p.x + p.y * p.y);\n    if (rh > (2 * HALF_PI * this.a)) {\n      return;\n    }\n    z = rh / this.a;\n\n    sinz = Math.sin(z);\n    cosz = Math.cos(z);\n\n    lon = this.long0;\n    if (Math.abs(rh) <= EPSLN) {\n      lat = this.lat0;\n    }\n    else {\n      lat = asinz(cosz * this.sin_p12 + (p.y * sinz * this.cos_p12) / rh);\n      con = Math.abs(this.lat0) - HALF_PI;\n      if (Math.abs(con) <= EPSLN) {\n        if (this.lat0 >= 0) {\n          lon = adjust_lon(this.long0 + Math.atan2(p.x, - p.y));\n        }\n        else {\n          lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));\n        }\n      }\n      else {\n        /*con = cosz - this.sin_p12 * Math.sin(lat);\n        if ((Math.abs(con) < EPSLN) && (Math.abs(p.x) < EPSLN)) {\n          //no-op, just keep the lon value as is\n        } else {\n          var temp = Math.atan2((p.x * sinz * this.cos_p12), (con * rh));\n          lon = adjust_lon(this.long0 + Math.atan2((p.x * sinz * this.cos_p12), (con * rh)));\n        }*/\n        lon = adjust_lon(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p12 * cosz - p.y * this.sin_p12 * sinz));\n      }\n    }\n\n    p.x = lon;\n    p.y = lat;\n    return p;\n  }\n  else {\n    e0 = e0fn(this.es);\n    e1 = e1fn(this.es);\n    e2 = e2fn(this.es);\n    e3 = e3fn(this.es);\n    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {\n      //North pole case\n      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);\n      rh = Math.sqrt(p.x * p.x + p.y * p.y);\n      M = Mlp - rh;\n      lat = imlfn(M / this.a, e0, e1, e2, e3);\n      lon = adjust_lon(this.long0 + Math.atan2(p.x, - 1 * p.y));\n      p.x = lon;\n      p.y = lat;\n      return p;\n    }\n    else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {\n      //South pole case\n      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);\n      rh = Math.sqrt(p.x * p.x + p.y * p.y);\n      M = rh - Mlp;\n\n      lat = imlfn(M / this.a, e0, e1, e2, e3);\n      lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));\n      p.x = lon;\n      p.y = lat;\n      return p;\n    }\n    else {\n      //default case\n      rh = Math.sqrt(p.x * p.x + p.y * p.y);\n      Az = Math.atan2(p.x, p.y);\n      N1 = gN(this.a, this.e, this.sin_p12);\n      cosAz = Math.cos(Az);\n      tmp = this.e * this.cos_p12 * cosAz;\n      A = -tmp * tmp / (1 - this.es);\n      B = 3 * this.es * (1 - A) * this.sin_p12 * this.cos_p12 * cosAz / (1 - this.es);\n      D = rh / N1;\n      Ee = D - A * (1 + A) * Math.pow(D, 3) / 6 - B * (1 + 3 * A) * Math.pow(D, 4) / 24;\n      F = 1 - A * Ee * Ee / 2 - D * Ee * Ee * Ee / 6;\n      psi = Math.asin(this.sin_p12 * Math.cos(Ee) + this.cos_p12 * Math.sin(Ee) * cosAz);\n      lon = adjust_lon(this.long0 + Math.asin(Math.sin(Az) * Math.sin(Ee) / Math.cos(psi)));\n      lat = Math.atan((1 - this.es * F * this.sin_p12 / Math.sin(psi)) * Math.tan(psi) / (1 - this.es));\n      p.x = lon;\n      p.y = lat;\n      return p;\n    }\n  }\n\n};\nexports.names = ["Azimuthal_Equidistant", "aeqd"];\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9hZXFkLmpzPzBmYzIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJmaWxlIjoiMTM5LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGFkanVzdF9sb24gPSByZXF1aXJlKCcuLi9jb21tb24vYWRqdXN0X2xvbicpO1xudmFyIEhBTEZfUEkgPSBNYXRoLlBJLzI7XG52YXIgRVBTTE4gPSAxLjBlLTEwO1xudmFyIG1sZm4gPSByZXF1aXJlKCcuLi9jb21tb24vbWxmbicpO1xudmFyIGUwZm4gPSByZXF1aXJlKCcuLi9jb21tb24vZTBmbicpO1xudmFyIGUxZm4gPSByZXF1aXJlKCcuLi9jb21tb24vZTFmbicpO1xudmFyIGUyZm4gPSByZXF1aXJlKCcuLi9jb21tb24vZTJmbicpO1xudmFyIGUzZm4gPSByZXF1aXJlKCcuLi9jb21tb24vZTNmbicpO1xudmFyIGdOID0gcmVxdWlyZSgnLi4vY29tbW9uL2dOJyk7XG52YXIgYXNpbnogPSByZXF1aXJlKCcuLi9jb21tb24vYXNpbnonKTtcbnZhciBpbWxmbiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9pbWxmbicpO1xuZXhwb3J0cy5pbml0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuc2luX3AxMiA9IE1hdGguc2luKHRoaXMubGF0MCk7XG4gIHRoaXMuY29zX3AxMiA9IE1hdGguY29zKHRoaXMubGF0MCk7XG59O1xuXG5leHBvcnRzLmZvcndhcmQgPSBmdW5jdGlvbihwKSB7XG4gIHZhciBsb24gPSBwLng7XG4gIHZhciBsYXQgPSBwLnk7XG4gIHZhciBzaW5waGkgPSBNYXRoLnNpbihwLnkpO1xuICB2YXIgY29zcGhpID0gTWF0aC5jb3MocC55KTtcbiAgdmFyIGRsb24gPSBhZGp1c3RfbG9uKGxvbiAtIHRoaXMubG9uZzApO1xuICB2YXIgZTAsIGUxLCBlMiwgZTMsIE1scCwgTWwsIHRhbnBoaSwgTmwxLCBObCwgcHNpLCBBeiwgRywgSCwgR0gsIEhzLCBjLCBrcCwgY29zX2MsIHMsIHMyLCBzMywgczQsIHM1O1xuICBpZiAodGhpcy5zcGhlcmUpIHtcbiAgICBpZiAoTWF0aC5hYnModGhpcy5zaW5fcDEyIC0gMSkgPD0gRVBTTE4pIHtcbiAgICAgIC8vTm9ydGggUG9sZSBjYXNlXG4gICAgICBwLnggPSB0aGlzLngwICsgdGhpcy5hICogKEhBTEZfUEkgLSBsYXQpICogTWF0aC5zaW4oZGxvbik7XG4gICAgICBwLnkgPSB0aGlzLnkwIC0gdGhpcy5hICogKEhBTEZfUEkgLSBsYXQpICogTWF0aC5jb3MoZGxvbik7XG4gICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgZWxzZSBpZiAoTWF0aC5hYnModGhpcy5zaW5fcDEyICsgMSkgPD0gRVBTTE4pIHtcbiAgICAgIC8vU291dGggUG9sZSBjYXNlXG4gICAgICBwLnggPSB0aGlzLngwICsgdGhpcy5hICogKEhBTEZfUEkgKyBsYXQpICogTWF0aC5zaW4oZGxvbik7XG4gICAgICBwLnkgPSB0aGlzLnkwICsgdGhpcy5hICogKEhBTEZfUEkgKyBsYXQpICogTWF0aC5jb3MoZGxvbik7XG4gICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvL2RlZmF1bHQgY2FzZVxuICAgICAgY29zX2MgPSB0aGlzLnNpbl9wMTIgKiBzaW5waGkgKyB0aGlzLmNvc19wMTIgKiBjb3NwaGkgKiBNYXRoLmNvcyhkbG9uKTtcbiAgICAgIGMgPSBNYXRoLmFjb3MoY29zX2MpO1xuICAgICAga3AgPSBjIC8gTWF0aC5zaW4oYyk7XG4gICAgICBwLnggPSB0aGlzLngwICsgdGhpcy5hICoga3AgKiBjb3NwaGkgKiBNYXRoLnNpbihkbG9uKTtcbiAgICAgIHAueSA9IHRoaXMueTAgKyB0aGlzLmEgKiBrcCAqICh0aGlzLmNvc19wMTIgKiBzaW5waGkgLSB0aGlzLnNpbl9wMTIgKiBjb3NwaGkgKiBNYXRoLmNvcyhkbG9uKSk7XG4gICAgICByZXR1cm4gcDtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgZTAgPSBlMGZuKHRoaXMuZXMpO1xuICAgIGUxID0gZTFmbih0aGlzLmVzKTtcbiAgICBlMiA9IGUyZm4odGhpcy5lcyk7XG4gICAgZTMgPSBlM2ZuKHRoaXMuZXMpO1xuICAgIGlmIChNYXRoLmFicyh0aGlzLnNpbl9wMTIgLSAxKSA8PSBFUFNMTikge1xuICAgICAgLy9Ob3J0aCBQb2xlIGNhc2VcbiAgICAgIE1scCA9IHRoaXMuYSAqIG1sZm4oZTAsIGUxLCBlMiwgZTMsIEhBTEZfUEkpO1xuICAgICAgTWwgPSB0aGlzLmEgKiBtbGZuKGUwLCBlMSwgZTIsIGUzLCBsYXQpO1xuICAgICAgcC54ID0gdGhpcy54MCArIChNbHAgLSBNbCkgKiBNYXRoLnNpbihkbG9uKTtcbiAgICAgIHAueSA9IHRoaXMueTAgLSAoTWxwIC0gTWwpICogTWF0aC5jb3MoZGxvbik7XG4gICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgZWxzZSBpZiAoTWF0aC5hYnModGhpcy5zaW5fcDEyICsgMSkgPD0gRVBTTE4pIHtcbiAgICAgIC8vU291dGggUG9sZSBjYXNlXG4gICAgICBNbHAgPSB0aGlzLmEgKiBtbGZuKGUwLCBlMSwgZTIsIGUzLCBIQUxGX1BJKTtcbiAgICAgIE1sID0gdGhpcy5hICogbWxmbihlMCwgZTEsIGUyLCBlMywgbGF0KTtcbiAgICAgIHAueCA9IHRoaXMueDAgKyAoTWxwICsgTWwpICogTWF0aC5zaW4oZGxvbik7XG4gICAgICBwLnkgPSB0aGlzLnkwICsgKE1scCArIE1sKSAqIE1hdGguY29zKGRsb24pO1xuICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy9EZWZhdWx0IGNhc2VcbiAgICAgIHRhbnBoaSA9IHNpbnBoaSAvIGNvc3BoaTtcbiAgICAgIE5sMSA9IGdOKHRoaXMuYSwgdGhpcy5lLCB0aGlzLnNpbl9wMTIpO1xuICAgICAgTmwgPSBnTih0aGlzLmEsIHRoaXMuZSwgc2lucGhpKTtcbiAgICAgIHBzaSA9IE1hdGguYXRhbigoMSAtIHRoaXMuZXMpICogdGFucGhpICsgdGhpcy5lcyAqIE5sMSAqIHRoaXMuc2luX3AxMiAvIChObCAqIGNvc3BoaSkpO1xuICAgICAgQXogPSBNYXRoLmF0YW4yKE1hdGguc2luKGRsb24pLCB0aGlzLmNvc19wMTIgKiBNYXRoLnRhbihwc2kpIC0gdGhpcy5zaW5fcDEyICogTWF0aC5jb3MoZGxvbikpO1xuICAgICAgaWYgKEF6ID09PSAwKSB7XG4gICAgICAgIHMgPSBNYXRoLmFzaW4odGhpcy5jb3NfcDEyICogTWF0aC5zaW4ocHNpKSAtIHRoaXMuc2luX3AxMiAqIE1hdGguY29zKHBzaSkpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoTWF0aC5hYnMoTWF0aC5hYnMoQXopIC0gTWF0aC5QSSkgPD0gRVBTTE4pIHtcbiAgICAgICAgcyA9IC1NYXRoLmFzaW4odGhpcy5jb3NfcDEyICogTWF0aC5zaW4ocHNpKSAtIHRoaXMuc2luX3AxMiAqIE1hdGguY29zKHBzaSkpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHMgPSBNYXRoLmFzaW4oTWF0aC5zaW4oZGxvbikgKiBNYXRoLmNvcyhwc2kpIC8gTWF0aC5zaW4oQXopKTtcbiAgICAgIH1cbiAgICAgIEcgPSB0aGlzLmUgKiB0aGlzLnNpbl9wMTIgLyBNYXRoLnNxcnQoMSAtIHRoaXMuZXMpO1xuICAgICAgSCA9IHRoaXMuZSAqIHRoaXMuY29zX3AxMiAqIE1hdGguY29zKEF6KSAvIE1hdGguc3FydCgxIC0gdGhpcy5lcyk7XG4gICAgICBHSCA9IEcgKiBIO1xuICAgICAgSHMgPSBIICogSDtcbiAgICAgIHMyID0gcyAqIHM7XG4gICAgICBzMyA9IHMyICogcztcbiAgICAgIHM0ID0gczMgKiBzO1xuICAgICAgczUgPSBzNCAqIHM7XG4gICAgICBjID0gTmwxICogcyAqICgxIC0gczIgKiBIcyAqICgxIC0gSHMpIC8gNiArIHMzIC8gOCAqIEdIICogKDEgLSAyICogSHMpICsgczQgLyAxMjAgKiAoSHMgKiAoNCAtIDcgKiBIcykgLSAzICogRyAqIEcgKiAoMSAtIDcgKiBIcykpIC0gczUgLyA0OCAqIEdIKTtcbiAgICAgIHAueCA9IHRoaXMueDAgKyBjICogTWF0aC5zaW4oQXopO1xuICAgICAgcC55ID0gdGhpcy55MCArIGMgKiBNYXRoLmNvcyhBeik7XG4gICAgICByZXR1cm4gcDtcbiAgICB9XG4gIH1cblxuXG59O1xuXG5leHBvcnRzLmludmVyc2UgPSBmdW5jdGlvbihwKSB7XG4gIHAueCAtPSB0aGlzLngwO1xuICBwLnkgLT0gdGhpcy55MDtcbiAgdmFyIHJoLCB6LCBzaW56LCBjb3N6LCBsb24sIGxhdCwgY29uLCBlMCwgZTEsIGUyLCBlMywgTWxwLCBNLCBOMSwgcHNpLCBBeiwgY29zQXosIHRtcCwgQSwgQiwgRCwgRWUsIEY7XG4gIGlmICh0aGlzLnNwaGVyZSkge1xuICAgIHJoID0gTWF0aC5zcXJ0KHAueCAqIHAueCArIHAueSAqIHAueSk7XG4gICAgaWYgKHJoID4gKDIgKiBIQUxGX1BJICogdGhpcy5hKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB6ID0gcmggLyB0aGlzLmE7XG5cbiAgICBzaW56ID0gTWF0aC5zaW4oeik7XG4gICAgY29zeiA9IE1hdGguY29zKHopO1xuXG4gICAgbG9uID0gdGhpcy5sb25nMDtcbiAgICBpZiAoTWF0aC5hYnMocmgpIDw9IEVQU0xOKSB7XG4gICAgICBsYXQgPSB0aGlzLmxhdDA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgbGF0ID0gYXNpbnooY29zeiAqIHRoaXMuc2luX3AxMiArIChwLnkgKiBzaW56ICogdGhpcy5jb3NfcDEyKSAvIHJoKTtcbiAgICAgIGNvbiA9IE1hdGguYWJzKHRoaXMubGF0MCkgLSBIQUxGX1BJO1xuICAgICAgaWYgKE1hdGguYWJzKGNvbikgPD0gRVBTTE4pIHtcbiAgICAgICAgaWYgKHRoaXMubGF0MCA+PSAwKSB7XG4gICAgICAgICAgbG9uID0gYWRqdXN0X2xvbih0aGlzLmxvbmcwICsgTWF0aC5hdGFuMihwLngsIC0gcC55KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgbG9uID0gYWRqdXN0X2xvbih0aGlzLmxvbmcwIC0gTWF0aC5hdGFuMigtcC54LCBwLnkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8qY29uID0gY29zeiAtIHRoaXMuc2luX3AxMiAqIE1hdGguc2luKGxhdCk7XG4gICAgICAgIGlmICgoTWF0aC5hYnMoY29uKSA8IEVQU0xOKSAmJiAoTWF0aC5hYnMocC54KSA8IEVQU0xOKSkge1xuICAgICAgICAgIC8vbm8tb3AsIGp1c3Qga2VlcCB0aGUgbG9uIHZhbHVlIGFzIGlzXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHRlbXAgPSBNYXRoLmF0YW4yKChwLnggKiBzaW56ICogdGhpcy5jb3NfcDEyKSwgKGNvbiAqIHJoKSk7XG4gICAgICAgICAgbG9uID0gYWRqdXN0X2xvbih0aGlzLmxvbmcwICsgTWF0aC5hdGFuMigocC54ICogc2lueiAqIHRoaXMuY29zX3AxMiksIChjb24gKiByaCkpKTtcbiAgICAgICAgfSovXG4gICAgICAgIGxvbiA9IGFkanVzdF9sb24odGhpcy5sb25nMCArIE1hdGguYXRhbjIocC54ICogc2lueiwgcmggKiB0aGlzLmNvc19wMTIgKiBjb3N6IC0gcC55ICogdGhpcy5zaW5fcDEyICogc2lueikpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHAueCA9IGxvbjtcbiAgICBwLnkgPSBsYXQ7XG4gICAgcmV0dXJuIHA7XG4gIH1cbiAgZWxzZSB7XG4gICAgZTAgPSBlMGZuKHRoaXMuZXMpO1xuICAgIGUxID0gZTFmbih0aGlzLmVzKTtcbiAgICBlMiA9IGUyZm4odGhpcy5lcyk7XG4gICAgZTMgPSBlM2ZuKHRoaXMuZXMpO1xuICAgIGlmIChNYXRoLmFicyh0aGlzLnNpbl9wMTIgLSAxKSA8PSBFUFNMTikge1xuICAgICAgLy9Ob3J0aCBwb2xlIGNhc2VcbiAgICAgIE1scCA9IHRoaXMuYSAqIG1sZm4oZTAsIGUxLCBlMiwgZTMsIEhBTEZfUEkpO1xuICAgICAgcmggPSBNYXRoLnNxcnQocC54ICogcC54ICsgcC55ICogcC55KTtcbiAgICAgIE0gPSBNbHAgLSByaDtcbiAgICAgIGxhdCA9IGltbGZuKE0gLyB0aGlzLmEsIGUwLCBlMSwgZTIsIGUzKTtcbiAgICAgIGxvbiA9IGFkanVzdF9sb24odGhpcy5sb25nMCArIE1hdGguYXRhbjIocC54LCAtIDEgKiBwLnkpKTtcbiAgICAgIHAueCA9IGxvbjtcbiAgICAgIHAueSA9IGxhdDtcbiAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICBlbHNlIGlmIChNYXRoLmFicyh0aGlzLnNpbl9wMTIgKyAxKSA8PSBFUFNMTikge1xuICAgICAgLy9Tb3V0aCBwb2xlIGNhc2VcbiAgICAgIE1scCA9IHRoaXMuYSAqIG1sZm4oZTAsIGUxLCBlMiwgZTMsIEhBTEZfUEkpO1xuICAgICAgcmggPSBNYXRoLnNxcnQocC54ICogcC54ICsgcC55ICogcC55KTtcbiAgICAgIE0gPSByaCAtIE1scDtcblxuICAgICAgbGF0ID0gaW1sZm4oTSAvIHRoaXMuYSwgZTAsIGUxLCBlMiwgZTMpO1xuICAgICAgbG9uID0gYWRqdXN0X2xvbih0aGlzLmxvbmcwICsgTWF0aC5hdGFuMihwLngsIHAueSkpO1xuICAgICAgcC54ID0gbG9uO1xuICAgICAgcC55ID0gbGF0O1xuICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy9kZWZhdWx0IGNhc2VcbiAgICAgIHJoID0gTWF0aC5zcXJ0KHAueCAqIHAueCArIHAueSAqIHAueSk7XG4gICAgICBBeiA9IE1hdGguYXRhbjIocC54LCBwLnkpO1xuICAgICAgTjEgPSBnTih0aGlzLmEsIHRoaXMuZSwgdGhpcy5zaW5fcDEyKTtcbiAgICAgIGNvc0F6ID0gTWF0aC5jb3MoQXopO1xuICAgICAgdG1wID0gdGhpcy5lICogdGhpcy5jb3NfcDEyICogY29zQXo7XG4gICAgICBBID0gLXRtcCAqIHRtcCAvICgxIC0gdGhpcy5lcyk7XG4gICAgICBCID0gMyAqIHRoaXMuZXMgKiAoMSAtIEEpICogdGhpcy5zaW5fcDEyICogdGhpcy5jb3NfcDEyICogY29zQXogLyAoMSAtIHRoaXMuZXMpO1xuICAgICAgRCA9IHJoIC8gTjE7XG4gICAgICBFZSA9IEQgLSBBICogKDEgKyBBKSAqIE1hdGgucG93KEQsIDMpIC8gNiAtIEIgKiAoMSArIDMgKiBBKSAqIE1hdGgucG93KEQsIDQpIC8gMjQ7XG4gICAgICBGID0gMSAtIEEgKiBFZSAqIEVlIC8gMiAtIEQgKiBFZSAqIEVlICogRWUgLyA2O1xuICAgICAgcHNpID0gTWF0aC5hc2luKHRoaXMuc2luX3AxMiAqIE1hdGguY29zKEVlKSArIHRoaXMuY29zX3AxMiAqIE1hdGguc2luKEVlKSAqIGNvc0F6KTtcbiAgICAgIGxvbiA9IGFkanVzdF9sb24odGhpcy5sb25nMCArIE1hdGguYXNpbihNYXRoLnNpbihBeikgKiBNYXRoLnNpbihFZSkgLyBNYXRoLmNvcyhwc2kpKSk7XG4gICAgICBsYXQgPSBNYXRoLmF0YW4oKDEgLSB0aGlzLmVzICogRiAqIHRoaXMuc2luX3AxMiAvIE1hdGguc2luKHBzaSkpICogTWF0aC50YW4ocHNpKSAvICgxIC0gdGhpcy5lcykpO1xuICAgICAgcC54ID0gbG9uO1xuICAgICAgcC55ID0gbGF0O1xuICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICB9XG5cbn07XG5leHBvcnRzLm5hbWVzID0gW1wiQXppbXV0aGFsX0VxdWlkaXN0YW50XCIsIFwiYWVxZFwiXTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcm9qNC9saWIvcHJvamVjdGlvbnMvYWVxZC5qc1xuLy8gbW9kdWxlIGlkID0gMTM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,exports,__webpack_require__){eval('var mlfn = __webpack_require__(16);\nvar e0fn = __webpack_require__(12);\nvar e1fn = __webpack_require__(13);\nvar e2fn = __webpack_require__(14);\nvar e3fn = __webpack_require__(15);\nvar gN = __webpack_require__(33);\nvar adjust_lon = __webpack_require__(0);\nvar adjust_lat = __webpack_require__(11);\nvar imlfn = __webpack_require__(34);\nvar HALF_PI = Math.PI/2;\nvar EPSLN = 1.0e-10;\nexports.init = function() {\n  if (!this.sphere) {\n    this.e0 = e0fn(this.es);\n    this.e1 = e1fn(this.es);\n    this.e2 = e2fn(this.es);\n    this.e3 = e3fn(this.es);\n    this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);\n  }\n};\n\n\n\n/* Cassini forward equations--mapping lat,long to x,y\n  -----------------------------------------------------------------------*/\nexports.forward = function(p) {\n\n  /* Forward equations\n      -----------------*/\n  var x, y;\n  var lam = p.x;\n  var phi = p.y;\n  lam = adjust_lon(lam - this.long0);\n\n  if (this.sphere) {\n    x = this.a * Math.asin(Math.cos(phi) * Math.sin(lam));\n    y = this.a * (Math.atan2(Math.tan(phi), Math.cos(lam)) - this.lat0);\n  }\n  else {\n    //ellipsoid\n    var sinphi = Math.sin(phi);\n    var cosphi = Math.cos(phi);\n    var nl = gN(this.a, this.e, sinphi);\n    var tl = Math.tan(phi) * Math.tan(phi);\n    var al = lam * Math.cos(phi);\n    var asq = al * al;\n    var cl = this.es * cosphi * cosphi / (1 - this.es);\n    var ml = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);\n\n    x = nl * al * (1 - asq * tl * (1 / 6 - (8 - tl + 8 * cl) * asq / 120));\n    y = ml - this.ml0 + nl * sinphi / cosphi * asq * (0.5 + (5 - tl + 6 * cl) * asq / 24);\n\n\n  }\n\n  p.x = x + this.x0;\n  p.y = y + this.y0;\n  return p;\n};\n\n/* Inverse equations\n  -----------------*/\nexports.inverse = function(p) {\n  p.x -= this.x0;\n  p.y -= this.y0;\n  var x = p.x / this.a;\n  var y = p.y / this.a;\n  var phi, lam;\n\n  if (this.sphere) {\n    var dd = y + this.lat0;\n    phi = Math.asin(Math.sin(dd) * Math.cos(x));\n    lam = Math.atan2(Math.tan(x), Math.cos(dd));\n  }\n  else {\n    /* ellipsoid */\n    var ml1 = this.ml0 / this.a + y;\n    var phi1 = imlfn(ml1, this.e0, this.e1, this.e2, this.e3);\n    if (Math.abs(Math.abs(phi1) - HALF_PI) <= EPSLN) {\n      p.x = this.long0;\n      p.y = HALF_PI;\n      if (y < 0) {\n        p.y *= -1;\n      }\n      return p;\n    }\n    var nl1 = gN(this.a, this.e, Math.sin(phi1));\n\n    var rl1 = nl1 * nl1 * nl1 / this.a / this.a * (1 - this.es);\n    var tl1 = Math.pow(Math.tan(phi1), 2);\n    var dl = x * this.a / nl1;\n    var dsq = dl * dl;\n    phi = phi1 - nl1 * Math.tan(phi1) / rl1 * dl * dl * (0.5 - (1 + 3 * tl1) * dl * dl / 24);\n    lam = dl * (1 - dsq * (tl1 / 3 + (1 + 3 * tl1) * tl1 * dsq / 15)) / Math.cos(phi1);\n\n  }\n\n  p.x = adjust_lon(lam + this.long0);\n  p.y = adjust_lat(phi);\n  return p;\n\n};\nexports.names = ["Cassini", "Cassini_Soldner", "cass"];//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9jYXNzLmpzP2NiNzYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJmaWxlIjoiMTQwLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIG1sZm4gPSByZXF1aXJlKCcuLi9jb21tb24vbWxmbicpO1xudmFyIGUwZm4gPSByZXF1aXJlKCcuLi9jb21tb24vZTBmbicpO1xudmFyIGUxZm4gPSByZXF1aXJlKCcuLi9jb21tb24vZTFmbicpO1xudmFyIGUyZm4gPSByZXF1aXJlKCcuLi9jb21tb24vZTJmbicpO1xudmFyIGUzZm4gPSByZXF1aXJlKCcuLi9jb21tb24vZTNmbicpO1xudmFyIGdOID0gcmVxdWlyZSgnLi4vY29tbW9uL2dOJyk7XG52YXIgYWRqdXN0X2xvbiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9hZGp1c3RfbG9uJyk7XG52YXIgYWRqdXN0X2xhdCA9IHJlcXVpcmUoJy4uL2NvbW1vbi9hZGp1c3RfbGF0Jyk7XG52YXIgaW1sZm4gPSByZXF1aXJlKCcuLi9jb21tb24vaW1sZm4nKTtcbnZhciBIQUxGX1BJID0gTWF0aC5QSS8yO1xudmFyIEVQU0xOID0gMS4wZS0xMDtcbmV4cG9ydHMuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuc3BoZXJlKSB7XG4gICAgdGhpcy5lMCA9IGUwZm4odGhpcy5lcyk7XG4gICAgdGhpcy5lMSA9IGUxZm4odGhpcy5lcyk7XG4gICAgdGhpcy5lMiA9IGUyZm4odGhpcy5lcyk7XG4gICAgdGhpcy5lMyA9IGUzZm4odGhpcy5lcyk7XG4gICAgdGhpcy5tbDAgPSB0aGlzLmEgKiBtbGZuKHRoaXMuZTAsIHRoaXMuZTEsIHRoaXMuZTIsIHRoaXMuZTMsIHRoaXMubGF0MCk7XG4gIH1cbn07XG5cblxuXG4vKiBDYXNzaW5pIGZvcndhcmQgZXF1YXRpb25zLS1tYXBwaW5nIGxhdCxsb25nIHRvIHgseVxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnRzLmZvcndhcmQgPSBmdW5jdGlvbihwKSB7XG5cbiAgLyogRm9yd2FyZCBlcXVhdGlvbnNcbiAgICAgIC0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgdmFyIHgsIHk7XG4gIHZhciBsYW0gPSBwLng7XG4gIHZhciBwaGkgPSBwLnk7XG4gIGxhbSA9IGFkanVzdF9sb24obGFtIC0gdGhpcy5sb25nMCk7XG5cbiAgaWYgKHRoaXMuc3BoZXJlKSB7XG4gICAgeCA9IHRoaXMuYSAqIE1hdGguYXNpbihNYXRoLmNvcyhwaGkpICogTWF0aC5zaW4obGFtKSk7XG4gICAgeSA9IHRoaXMuYSAqIChNYXRoLmF0YW4yKE1hdGgudGFuKHBoaSksIE1hdGguY29zKGxhbSkpIC0gdGhpcy5sYXQwKTtcbiAgfVxuICBlbHNlIHtcbiAgICAvL2VsbGlwc29pZFxuICAgIHZhciBzaW5waGkgPSBNYXRoLnNpbihwaGkpO1xuICAgIHZhciBjb3NwaGkgPSBNYXRoLmNvcyhwaGkpO1xuICAgIHZhciBubCA9IGdOKHRoaXMuYSwgdGhpcy5lLCBzaW5waGkpO1xuICAgIHZhciB0bCA9IE1hdGgudGFuKHBoaSkgKiBNYXRoLnRhbihwaGkpO1xuICAgIHZhciBhbCA9IGxhbSAqIE1hdGguY29zKHBoaSk7XG4gICAgdmFyIGFzcSA9IGFsICogYWw7XG4gICAgdmFyIGNsID0gdGhpcy5lcyAqIGNvc3BoaSAqIGNvc3BoaSAvICgxIC0gdGhpcy5lcyk7XG4gICAgdmFyIG1sID0gdGhpcy5hICogbWxmbih0aGlzLmUwLCB0aGlzLmUxLCB0aGlzLmUyLCB0aGlzLmUzLCBwaGkpO1xuXG4gICAgeCA9IG5sICogYWwgKiAoMSAtIGFzcSAqIHRsICogKDEgLyA2IC0gKDggLSB0bCArIDggKiBjbCkgKiBhc3EgLyAxMjApKTtcbiAgICB5ID0gbWwgLSB0aGlzLm1sMCArIG5sICogc2lucGhpIC8gY29zcGhpICogYXNxICogKDAuNSArICg1IC0gdGwgKyA2ICogY2wpICogYXNxIC8gMjQpO1xuXG5cbiAgfVxuXG4gIHAueCA9IHggKyB0aGlzLngwO1xuICBwLnkgPSB5ICsgdGhpcy55MDtcbiAgcmV0dXJuIHA7XG59O1xuXG4vKiBJbnZlcnNlIGVxdWF0aW9uc1xuICAtLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnRzLmludmVyc2UgPSBmdW5jdGlvbihwKSB7XG4gIHAueCAtPSB0aGlzLngwO1xuICBwLnkgLT0gdGhpcy55MDtcbiAgdmFyIHggPSBwLnggLyB0aGlzLmE7XG4gIHZhciB5ID0gcC55IC8gdGhpcy5hO1xuICB2YXIgcGhpLCBsYW07XG5cbiAgaWYgKHRoaXMuc3BoZXJlKSB7XG4gICAgdmFyIGRkID0geSArIHRoaXMubGF0MDtcbiAgICBwaGkgPSBNYXRoLmFzaW4oTWF0aC5zaW4oZGQpICogTWF0aC5jb3MoeCkpO1xuICAgIGxhbSA9IE1hdGguYXRhbjIoTWF0aC50YW4oeCksIE1hdGguY29zKGRkKSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgLyogZWxsaXBzb2lkICovXG4gICAgdmFyIG1sMSA9IHRoaXMubWwwIC8gdGhpcy5hICsgeTtcbiAgICB2YXIgcGhpMSA9IGltbGZuKG1sMSwgdGhpcy5lMCwgdGhpcy5lMSwgdGhpcy5lMiwgdGhpcy5lMyk7XG4gICAgaWYgKE1hdGguYWJzKE1hdGguYWJzKHBoaTEpIC0gSEFMRl9QSSkgPD0gRVBTTE4pIHtcbiAgICAgIHAueCA9IHRoaXMubG9uZzA7XG4gICAgICBwLnkgPSBIQUxGX1BJO1xuICAgICAgaWYgKHkgPCAwKSB7XG4gICAgICAgIHAueSAqPSAtMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICB2YXIgbmwxID0gZ04odGhpcy5hLCB0aGlzLmUsIE1hdGguc2luKHBoaTEpKTtcblxuICAgIHZhciBybDEgPSBubDEgKiBubDEgKiBubDEgLyB0aGlzLmEgLyB0aGlzLmEgKiAoMSAtIHRoaXMuZXMpO1xuICAgIHZhciB0bDEgPSBNYXRoLnBvdyhNYXRoLnRhbihwaGkxKSwgMik7XG4gICAgdmFyIGRsID0geCAqIHRoaXMuYSAvIG5sMTtcbiAgICB2YXIgZHNxID0gZGwgKiBkbDtcbiAgICBwaGkgPSBwaGkxIC0gbmwxICogTWF0aC50YW4ocGhpMSkgLyBybDEgKiBkbCAqIGRsICogKDAuNSAtICgxICsgMyAqIHRsMSkgKiBkbCAqIGRsIC8gMjQpO1xuICAgIGxhbSA9IGRsICogKDEgLSBkc3EgKiAodGwxIC8gMyArICgxICsgMyAqIHRsMSkgKiB0bDEgKiBkc3EgLyAxNSkpIC8gTWF0aC5jb3MocGhpMSk7XG5cbiAgfVxuXG4gIHAueCA9IGFkanVzdF9sb24obGFtICsgdGhpcy5sb25nMCk7XG4gIHAueSA9IGFkanVzdF9sYXQocGhpKTtcbiAgcmV0dXJuIHA7XG5cbn07XG5leHBvcnRzLm5hbWVzID0gW1wiQ2Fzc2luaVwiLCBcIkNhc3NpbmlfU29sZG5lclwiLCBcImNhc3NcIl07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9jYXNzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports,__webpack_require__){eval('var adjust_lon = __webpack_require__(0);\nvar qsfnz = __webpack_require__(35);\nvar msfnz = __webpack_require__(8);\nvar iqsfnz = __webpack_require__(122);\n/*\n  reference:  \n    "Cartographic Projection Procedures for the UNIX Environment-\n    A User\'s Manual" by Gerald I. Evenden,\n    USGS Open File Report 90-284and Release 4 Interim Reports (2003)\n*/\nexports.init = function() {\n  //no-op\n  if (!this.sphere) {\n    this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));\n  }\n};\n\n\n/* Cylindrical Equal Area forward equations--mapping lat,long to x,y\n    ------------------------------------------------------------*/\nexports.forward = function(p) {\n  var lon = p.x;\n  var lat = p.y;\n  var x, y;\n  /* Forward equations\n      -----------------*/\n  var dlon = adjust_lon(lon - this.long0);\n  if (this.sphere) {\n    x = this.x0 + this.a * dlon * Math.cos(this.lat_ts);\n    y = this.y0 + this.a * Math.sin(lat) / Math.cos(this.lat_ts);\n  }\n  else {\n    var qs = qsfnz(this.e, Math.sin(lat));\n    x = this.x0 + this.a * this.k0 * dlon;\n    y = this.y0 + this.a * qs * 0.5 / this.k0;\n  }\n\n  p.x = x;\n  p.y = y;\n  return p;\n};\n\n/* Cylindrical Equal Area inverse equations--mapping x,y to lat/long\n    ------------------------------------------------------------*/\nexports.inverse = function(p) {\n  p.x -= this.x0;\n  p.y -= this.y0;\n  var lon, lat;\n\n  if (this.sphere) {\n    lon = adjust_lon(this.long0 + (p.x / this.a) / Math.cos(this.lat_ts));\n    lat = Math.asin((p.y / this.a) * Math.cos(this.lat_ts));\n  }\n  else {\n    lat = iqsfnz(this.e, 2 * p.y * this.k0 / this.a);\n    lon = adjust_lon(this.long0 + p.x / (this.a * this.k0));\n  }\n\n  p.x = lon;\n  p.y = lat;\n  return p;\n};\nexports.names = ["cea"];\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9jZWEuanM/ZGQyYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTQxLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGFkanVzdF9sb24gPSByZXF1aXJlKCcuLi9jb21tb24vYWRqdXN0X2xvbicpO1xudmFyIHFzZm56ID0gcmVxdWlyZSgnLi4vY29tbW9uL3FzZm56Jyk7XG52YXIgbXNmbnogPSByZXF1aXJlKCcuLi9jb21tb24vbXNmbnonKTtcbnZhciBpcXNmbnogPSByZXF1aXJlKCcuLi9jb21tb24vaXFzZm56Jyk7XG4vKlxuICByZWZlcmVuY2U6ICBcbiAgICBcIkNhcnRvZ3JhcGhpYyBQcm9qZWN0aW9uIFByb2NlZHVyZXMgZm9yIHRoZSBVTklYIEVudmlyb25tZW50LVxuICAgIEEgVXNlcidzIE1hbnVhbFwiIGJ5IEdlcmFsZCBJLiBFdmVuZGVuLFxuICAgIFVTR1MgT3BlbiBGaWxlIFJlcG9ydCA5MC0yODRhbmQgUmVsZWFzZSA0IEludGVyaW0gUmVwb3J0cyAoMjAwMylcbiovXG5leHBvcnRzLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgLy9uby1vcFxuICBpZiAoIXRoaXMuc3BoZXJlKSB7XG4gICAgdGhpcy5rMCA9IG1zZm56KHRoaXMuZSwgTWF0aC5zaW4odGhpcy5sYXRfdHMpLCBNYXRoLmNvcyh0aGlzLmxhdF90cykpO1xuICB9XG59O1xuXG5cbi8qIEN5bGluZHJpY2FsIEVxdWFsIEFyZWEgZm9yd2FyZCBlcXVhdGlvbnMtLW1hcHBpbmcgbGF0LGxvbmcgdG8geCx5XG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmV4cG9ydHMuZm9yd2FyZCA9IGZ1bmN0aW9uKHApIHtcbiAgdmFyIGxvbiA9IHAueDtcbiAgdmFyIGxhdCA9IHAueTtcbiAgdmFyIHgsIHk7XG4gIC8qIEZvcndhcmQgZXF1YXRpb25zXG4gICAgICAtLS0tLS0tLS0tLS0tLS0tLSovXG4gIHZhciBkbG9uID0gYWRqdXN0X2xvbihsb24gLSB0aGlzLmxvbmcwKTtcbiAgaWYgKHRoaXMuc3BoZXJlKSB7XG4gICAgeCA9IHRoaXMueDAgKyB0aGlzLmEgKiBkbG9uICogTWF0aC5jb3ModGhpcy5sYXRfdHMpO1xuICAgIHkgPSB0aGlzLnkwICsgdGhpcy5hICogTWF0aC5zaW4obGF0KSAvIE1hdGguY29zKHRoaXMubGF0X3RzKTtcbiAgfVxuICBlbHNlIHtcbiAgICB2YXIgcXMgPSBxc2Zueih0aGlzLmUsIE1hdGguc2luKGxhdCkpO1xuICAgIHggPSB0aGlzLngwICsgdGhpcy5hICogdGhpcy5rMCAqIGRsb247XG4gICAgeSA9IHRoaXMueTAgKyB0aGlzLmEgKiBxcyAqIDAuNSAvIHRoaXMuazA7XG4gIH1cblxuICBwLnggPSB4O1xuICBwLnkgPSB5O1xuICByZXR1cm4gcDtcbn07XG5cbi8qIEN5bGluZHJpY2FsIEVxdWFsIEFyZWEgaW52ZXJzZSBlcXVhdGlvbnMtLW1hcHBpbmcgeCx5IHRvIGxhdC9sb25nXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmV4cG9ydHMuaW52ZXJzZSA9IGZ1bmN0aW9uKHApIHtcbiAgcC54IC09IHRoaXMueDA7XG4gIHAueSAtPSB0aGlzLnkwO1xuICB2YXIgbG9uLCBsYXQ7XG5cbiAgaWYgKHRoaXMuc3BoZXJlKSB7XG4gICAgbG9uID0gYWRqdXN0X2xvbih0aGlzLmxvbmcwICsgKHAueCAvIHRoaXMuYSkgLyBNYXRoLmNvcyh0aGlzLmxhdF90cykpO1xuICAgIGxhdCA9IE1hdGguYXNpbigocC55IC8gdGhpcy5hKSAqIE1hdGguY29zKHRoaXMubGF0X3RzKSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgbGF0ID0gaXFzZm56KHRoaXMuZSwgMiAqIHAueSAqIHRoaXMuazAgLyB0aGlzLmEpO1xuICAgIGxvbiA9IGFkanVzdF9sb24odGhpcy5sb25nMCArIHAueCAvICh0aGlzLmEgKiB0aGlzLmswKSk7XG4gIH1cblxuICBwLnggPSBsb247XG4gIHAueSA9IGxhdDtcbiAgcmV0dXJuIHA7XG59O1xuZXhwb3J0cy5uYW1lcyA9IFtcImNlYVwiXTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcm9qNC9saWIvcHJvamVjdGlvbnMvY2VhLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports,__webpack_require__){eval('var adjust_lon = __webpack_require__(0);\nvar adjust_lat = __webpack_require__(11);\nexports.init = function() {\n\n  this.x0 = this.x0 || 0;\n  this.y0 = this.y0 || 0;\n  this.lat0 = this.lat0 || 0;\n  this.long0 = this.long0 || 0;\n  this.lat_ts = this.lat_ts || 0;\n  this.title = this.title || "Equidistant Cylindrical (Plate Carre)";\n\n  this.rc = Math.cos(this.lat_ts);\n};\n\n\n// forward equations--mapping lat,long to x,y\n// -----------------------------------------------------------------\nexports.forward = function(p) {\n\n  var lon = p.x;\n  var lat = p.y;\n\n  var dlon = adjust_lon(lon - this.long0);\n  var dlat = adjust_lat(lat - this.lat0);\n  p.x = this.x0 + (this.a * dlon * this.rc);\n  p.y = this.y0 + (this.a * dlat);\n  return p;\n};\n\n// inverse equations--mapping x,y to lat/long\n// -----------------------------------------------------------------\nexports.inverse = function(p) {\n\n  var x = p.x;\n  var y = p.y;\n\n  p.x = adjust_lon(this.long0 + ((x - this.x0) / (this.a * this.rc)));\n  p.y = adjust_lat(this.lat0 + ((y - this.y0) / (this.a)));\n  return p;\n};\nexports.names = ["Equirectangular", "Equidistant_Cylindrical", "eqc"];\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9lcWMuanM/MDFjOSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjE0Mi5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBhZGp1c3RfbG9uID0gcmVxdWlyZSgnLi4vY29tbW9uL2FkanVzdF9sb24nKTtcbnZhciBhZGp1c3RfbGF0ID0gcmVxdWlyZSgnLi4vY29tbW9uL2FkanVzdF9sYXQnKTtcbmV4cG9ydHMuaW5pdCA9IGZ1bmN0aW9uKCkge1xuXG4gIHRoaXMueDAgPSB0aGlzLngwIHx8IDA7XG4gIHRoaXMueTAgPSB0aGlzLnkwIHx8IDA7XG4gIHRoaXMubGF0MCA9IHRoaXMubGF0MCB8fCAwO1xuICB0aGlzLmxvbmcwID0gdGhpcy5sb25nMCB8fCAwO1xuICB0aGlzLmxhdF90cyA9IHRoaXMubGF0X3RzIHx8IDA7XG4gIHRoaXMudGl0bGUgPSB0aGlzLnRpdGxlIHx8IFwiRXF1aWRpc3RhbnQgQ3lsaW5kcmljYWwgKFBsYXRlIENhcnJlKVwiO1xuXG4gIHRoaXMucmMgPSBNYXRoLmNvcyh0aGlzLmxhdF90cyk7XG59O1xuXG5cbi8vIGZvcndhcmQgZXF1YXRpb25zLS1tYXBwaW5nIGxhdCxsb25nIHRvIHgseVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmV4cG9ydHMuZm9yd2FyZCA9IGZ1bmN0aW9uKHApIHtcblxuICB2YXIgbG9uID0gcC54O1xuICB2YXIgbGF0ID0gcC55O1xuXG4gIHZhciBkbG9uID0gYWRqdXN0X2xvbihsb24gLSB0aGlzLmxvbmcwKTtcbiAgdmFyIGRsYXQgPSBhZGp1c3RfbGF0KGxhdCAtIHRoaXMubGF0MCk7XG4gIHAueCA9IHRoaXMueDAgKyAodGhpcy5hICogZGxvbiAqIHRoaXMucmMpO1xuICBwLnkgPSB0aGlzLnkwICsgKHRoaXMuYSAqIGRsYXQpO1xuICByZXR1cm4gcDtcbn07XG5cbi8vIGludmVyc2UgZXF1YXRpb25zLS1tYXBwaW5nIHgseSB0byBsYXQvbG9uZ1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmV4cG9ydHMuaW52ZXJzZSA9IGZ1bmN0aW9uKHApIHtcblxuICB2YXIgeCA9IHAueDtcbiAgdmFyIHkgPSBwLnk7XG5cbiAgcC54ID0gYWRqdXN0X2xvbih0aGlzLmxvbmcwICsgKCh4IC0gdGhpcy54MCkgLyAodGhpcy5hICogdGhpcy5yYykpKTtcbiAgcC55ID0gYWRqdXN0X2xhdCh0aGlzLmxhdDAgKyAoKHkgLSB0aGlzLnkwKSAvICh0aGlzLmEpKSk7XG4gIHJldHVybiBwO1xufTtcbmV4cG9ydHMubmFtZXMgPSBbXCJFcXVpcmVjdGFuZ3VsYXJcIiwgXCJFcXVpZGlzdGFudF9DeWxpbmRyaWNhbFwiLCBcImVxY1wiXTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcm9qNC9saWIvcHJvamVjdGlvbnMvZXFjLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports,__webpack_require__){eval('var e0fn = __webpack_require__(12);\nvar e1fn = __webpack_require__(13);\nvar e2fn = __webpack_require__(14);\nvar e3fn = __webpack_require__(15);\nvar msfnz = __webpack_require__(8);\nvar mlfn = __webpack_require__(16);\nvar adjust_lon = __webpack_require__(0);\nvar adjust_lat = __webpack_require__(11);\nvar imlfn = __webpack_require__(34);\nvar EPSLN = 1.0e-10;\nexports.init = function() {\n\n  /* Place parameters in static storage for common use\n      -------------------------------------------------*/\n  // Standard Parallels cannot be equal and on opposite sides of the equator\n  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {\n    return;\n  }\n  this.lat2 = this.lat2 || this.lat1;\n  this.temp = this.b / this.a;\n  this.es = 1 - Math.pow(this.temp, 2);\n  this.e = Math.sqrt(this.es);\n  this.e0 = e0fn(this.es);\n  this.e1 = e1fn(this.es);\n  this.e2 = e2fn(this.es);\n  this.e3 = e3fn(this.es);\n\n  this.sinphi = Math.sin(this.lat1);\n  this.cosphi = Math.cos(this.lat1);\n\n  this.ms1 = msfnz(this.e, this.sinphi, this.cosphi);\n  this.ml1 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat1);\n\n  if (Math.abs(this.lat1 - this.lat2) < EPSLN) {\n    this.ns = this.sinphi;\n  }\n  else {\n    this.sinphi = Math.sin(this.lat2);\n    this.cosphi = Math.cos(this.lat2);\n    this.ms2 = msfnz(this.e, this.sinphi, this.cosphi);\n    this.ml2 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat2);\n    this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1);\n  }\n  this.g = this.ml1 + this.ms1 / this.ns;\n  this.ml0 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);\n  this.rh = this.a * (this.g - this.ml0);\n};\n\n\n/* Equidistant Conic forward equations--mapping lat,long to x,y\n  -----------------------------------------------------------*/\nexports.forward = function(p) {\n  var lon = p.x;\n  var lat = p.y;\n  var rh1;\n\n  /* Forward equations\n      -----------------*/\n  if (this.sphere) {\n    rh1 = this.a * (this.g - lat);\n  }\n  else {\n    var ml = mlfn(this.e0, this.e1, this.e2, this.e3, lat);\n    rh1 = this.a * (this.g - ml);\n  }\n  var theta = this.ns * adjust_lon(lon - this.long0);\n  var x = this.x0 + rh1 * Math.sin(theta);\n  var y = this.y0 + this.rh - rh1 * Math.cos(theta);\n  p.x = x;\n  p.y = y;\n  return p;\n};\n\n/* Inverse equations\n  -----------------*/\nexports.inverse = function(p) {\n  p.x -= this.x0;\n  p.y = this.rh - p.y + this.y0;\n  var con, rh1, lat, lon;\n  if (this.ns >= 0) {\n    rh1 = Math.sqrt(p.x * p.x + p.y * p.y);\n    con = 1;\n  }\n  else {\n    rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);\n    con = -1;\n  }\n  var theta = 0;\n  if (rh1 !== 0) {\n    theta = Math.atan2(con * p.x, con * p.y);\n  }\n\n  if (this.sphere) {\n    lon = adjust_lon(this.long0 + theta / this.ns);\n    lat = adjust_lat(this.g - rh1 / this.a);\n    p.x = lon;\n    p.y = lat;\n    return p;\n  }\n  else {\n    var ml = this.g - rh1 / this.a;\n    lat = imlfn(ml, this.e0, this.e1, this.e2, this.e3);\n    lon = adjust_lon(this.long0 + theta / this.ns);\n    p.x = lon;\n    p.y = lat;\n    return p;\n  }\n\n};\nexports.names = ["Equidistant_Conic", "eqdc"];\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9lcWRjLmpzPzllM2QiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwiZmlsZSI6IjE0My5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBlMGZuID0gcmVxdWlyZSgnLi4vY29tbW9uL2UwZm4nKTtcbnZhciBlMWZuID0gcmVxdWlyZSgnLi4vY29tbW9uL2UxZm4nKTtcbnZhciBlMmZuID0gcmVxdWlyZSgnLi4vY29tbW9uL2UyZm4nKTtcbnZhciBlM2ZuID0gcmVxdWlyZSgnLi4vY29tbW9uL2UzZm4nKTtcbnZhciBtc2ZueiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9tc2ZueicpO1xudmFyIG1sZm4gPSByZXF1aXJlKCcuLi9jb21tb24vbWxmbicpO1xudmFyIGFkanVzdF9sb24gPSByZXF1aXJlKCcuLi9jb21tb24vYWRqdXN0X2xvbicpO1xudmFyIGFkanVzdF9sYXQgPSByZXF1aXJlKCcuLi9jb21tb24vYWRqdXN0X2xhdCcpO1xudmFyIGltbGZuID0gcmVxdWlyZSgnLi4vY29tbW9uL2ltbGZuJyk7XG52YXIgRVBTTE4gPSAxLjBlLTEwO1xuZXhwb3J0cy5pbml0ID0gZnVuY3Rpb24oKSB7XG5cbiAgLyogUGxhY2UgcGFyYW1ldGVycyBpbiBzdGF0aWMgc3RvcmFnZSBmb3IgY29tbW9uIHVzZVxuICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4gIC8vIFN0YW5kYXJkIFBhcmFsbGVscyBjYW5ub3QgYmUgZXF1YWwgYW5kIG9uIG9wcG9zaXRlIHNpZGVzIG9mIHRoZSBlcXVhdG9yXG4gIGlmIChNYXRoLmFicyh0aGlzLmxhdDEgKyB0aGlzLmxhdDIpIDwgRVBTTE4pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5sYXQyID0gdGhpcy5sYXQyIHx8IHRoaXMubGF0MTtcbiAgdGhpcy50ZW1wID0gdGhpcy5iIC8gdGhpcy5hO1xuICB0aGlzLmVzID0gMSAtIE1hdGgucG93KHRoaXMudGVtcCwgMik7XG4gIHRoaXMuZSA9IE1hdGguc3FydCh0aGlzLmVzKTtcbiAgdGhpcy5lMCA9IGUwZm4odGhpcy5lcyk7XG4gIHRoaXMuZTEgPSBlMWZuKHRoaXMuZXMpO1xuICB0aGlzLmUyID0gZTJmbih0aGlzLmVzKTtcbiAgdGhpcy5lMyA9IGUzZm4odGhpcy5lcyk7XG5cbiAgdGhpcy5zaW5waGkgPSBNYXRoLnNpbih0aGlzLmxhdDEpO1xuICB0aGlzLmNvc3BoaSA9IE1hdGguY29zKHRoaXMubGF0MSk7XG5cbiAgdGhpcy5tczEgPSBtc2Zueih0aGlzLmUsIHRoaXMuc2lucGhpLCB0aGlzLmNvc3BoaSk7XG4gIHRoaXMubWwxID0gbWxmbih0aGlzLmUwLCB0aGlzLmUxLCB0aGlzLmUyLCB0aGlzLmUzLCB0aGlzLmxhdDEpO1xuXG4gIGlmIChNYXRoLmFicyh0aGlzLmxhdDEgLSB0aGlzLmxhdDIpIDwgRVBTTE4pIHtcbiAgICB0aGlzLm5zID0gdGhpcy5zaW5waGk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhpcy5zaW5waGkgPSBNYXRoLnNpbih0aGlzLmxhdDIpO1xuICAgIHRoaXMuY29zcGhpID0gTWF0aC5jb3ModGhpcy5sYXQyKTtcbiAgICB0aGlzLm1zMiA9IG1zZm56KHRoaXMuZSwgdGhpcy5zaW5waGksIHRoaXMuY29zcGhpKTtcbiAgICB0aGlzLm1sMiA9IG1sZm4odGhpcy5lMCwgdGhpcy5lMSwgdGhpcy5lMiwgdGhpcy5lMywgdGhpcy5sYXQyKTtcbiAgICB0aGlzLm5zID0gKHRoaXMubXMxIC0gdGhpcy5tczIpIC8gKHRoaXMubWwyIC0gdGhpcy5tbDEpO1xuICB9XG4gIHRoaXMuZyA9IHRoaXMubWwxICsgdGhpcy5tczEgLyB0aGlzLm5zO1xuICB0aGlzLm1sMCA9IG1sZm4odGhpcy5lMCwgdGhpcy5lMSwgdGhpcy5lMiwgdGhpcy5lMywgdGhpcy5sYXQwKTtcbiAgdGhpcy5yaCA9IHRoaXMuYSAqICh0aGlzLmcgLSB0aGlzLm1sMCk7XG59O1xuXG5cbi8qIEVxdWlkaXN0YW50IENvbmljIGZvcndhcmQgZXF1YXRpb25zLS1tYXBwaW5nIGxhdCxsb25nIHRvIHgseVxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnRzLmZvcndhcmQgPSBmdW5jdGlvbihwKSB7XG4gIHZhciBsb24gPSBwLng7XG4gIHZhciBsYXQgPSBwLnk7XG4gIHZhciByaDE7XG5cbiAgLyogRm9yd2FyZCBlcXVhdGlvbnNcbiAgICAgIC0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgaWYgKHRoaXMuc3BoZXJlKSB7XG4gICAgcmgxID0gdGhpcy5hICogKHRoaXMuZyAtIGxhdCk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdmFyIG1sID0gbWxmbih0aGlzLmUwLCB0aGlzLmUxLCB0aGlzLmUyLCB0aGlzLmUzLCBsYXQpO1xuICAgIHJoMSA9IHRoaXMuYSAqICh0aGlzLmcgLSBtbCk7XG4gIH1cbiAgdmFyIHRoZXRhID0gdGhpcy5ucyAqIGFkanVzdF9sb24obG9uIC0gdGhpcy5sb25nMCk7XG4gIHZhciB4ID0gdGhpcy54MCArIHJoMSAqIE1hdGguc2luKHRoZXRhKTtcbiAgdmFyIHkgPSB0aGlzLnkwICsgdGhpcy5yaCAtIHJoMSAqIE1hdGguY29zKHRoZXRhKTtcbiAgcC54ID0geDtcbiAgcC55ID0geTtcbiAgcmV0dXJuIHA7XG59O1xuXG4vKiBJbnZlcnNlIGVxdWF0aW9uc1xuICAtLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnRzLmludmVyc2UgPSBmdW5jdGlvbihwKSB7XG4gIHAueCAtPSB0aGlzLngwO1xuICBwLnkgPSB0aGlzLnJoIC0gcC55ICsgdGhpcy55MDtcbiAgdmFyIGNvbiwgcmgxLCBsYXQsIGxvbjtcbiAgaWYgKHRoaXMubnMgPj0gMCkge1xuICAgIHJoMSA9IE1hdGguc3FydChwLnggKiBwLnggKyBwLnkgKiBwLnkpO1xuICAgIGNvbiA9IDE7XG4gIH1cbiAgZWxzZSB7XG4gICAgcmgxID0gLU1hdGguc3FydChwLnggKiBwLnggKyBwLnkgKiBwLnkpO1xuICAgIGNvbiA9IC0xO1xuICB9XG4gIHZhciB0aGV0YSA9IDA7XG4gIGlmIChyaDEgIT09IDApIHtcbiAgICB0aGV0YSA9IE1hdGguYXRhbjIoY29uICogcC54LCBjb24gKiBwLnkpO1xuICB9XG5cbiAgaWYgKHRoaXMuc3BoZXJlKSB7XG4gICAgbG9uID0gYWRqdXN0X2xvbih0aGlzLmxvbmcwICsgdGhldGEgLyB0aGlzLm5zKTtcbiAgICBsYXQgPSBhZGp1c3RfbGF0KHRoaXMuZyAtIHJoMSAvIHRoaXMuYSk7XG4gICAgcC54ID0gbG9uO1xuICAgIHAueSA9IGxhdDtcbiAgICByZXR1cm4gcDtcbiAgfVxuICBlbHNlIHtcbiAgICB2YXIgbWwgPSB0aGlzLmcgLSByaDEgLyB0aGlzLmE7XG4gICAgbGF0ID0gaW1sZm4obWwsIHRoaXMuZTAsIHRoaXMuZTEsIHRoaXMuZTIsIHRoaXMuZTMpO1xuICAgIGxvbiA9IGFkanVzdF9sb24odGhpcy5sb25nMCArIHRoZXRhIC8gdGhpcy5ucyk7XG4gICAgcC54ID0gbG9uO1xuICAgIHAueSA9IGxhdDtcbiAgICByZXR1cm4gcDtcbiAgfVxuXG59O1xuZXhwb3J0cy5uYW1lcyA9IFtcIkVxdWlkaXN0YW50X0NvbmljXCIsIFwiZXFkY1wiXTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcm9qNC9saWIvcHJvamVjdGlvbnMvZXFkYy5qc1xuLy8gbW9kdWxlIGlkID0gMTQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,exports,__webpack_require__){eval('var FORTPI = Math.PI/4;\nvar srat = __webpack_require__(125);\nvar HALF_PI = Math.PI/2;\nvar MAX_ITER = 20;\nexports.init = function() {\n  var sphi = Math.sin(this.lat0);\n  var cphi = Math.cos(this.lat0);\n  cphi *= cphi;\n  this.rc = Math.sqrt(1 - this.es) / (1 - this.es * sphi * sphi);\n  this.C = Math.sqrt(1 + this.es * cphi * cphi / (1 - this.es));\n  this.phic0 = Math.asin(sphi / this.C);\n  this.ratexp = 0.5 * this.C * this.e;\n  this.K = Math.tan(0.5 * this.phic0 + FORTPI) / (Math.pow(Math.tan(0.5 * this.lat0 + FORTPI), this.C) * srat(this.e * sphi, this.ratexp));\n};\n\nexports.forward = function(p) {\n  var lon = p.x;\n  var lat = p.y;\n\n  p.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * lat + FORTPI), this.C) * srat(this.e * Math.sin(lat), this.ratexp)) - HALF_PI;\n  p.x = this.C * lon;\n  return p;\n};\n\nexports.inverse = function(p) {\n  var DEL_TOL = 1e-14;\n  var lon = p.x / this.C;\n  var lat = p.y;\n  var num = Math.pow(Math.tan(0.5 * lat + FORTPI) / this.K, 1 / this.C);\n  for (var i = MAX_ITER; i > 0; --i) {\n    lat = 2 * Math.atan(num * srat(this.e * Math.sin(p.y), - 0.5 * this.e)) - HALF_PI;\n    if (Math.abs(lat - p.y) < DEL_TOL) {\n      break;\n    }\n    p.y = lat;\n  }\n  /* convergence failed */\n  if (!i) {\n    return null;\n  }\n  p.x = lon;\n  p.y = lat;\n  return p;\n};\nexports.names = ["gauss"];\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9nYXVzcy5qcz85YWY3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTQ0LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIEZPUlRQSSA9IE1hdGguUEkvNDtcbnZhciBzcmF0ID0gcmVxdWlyZSgnLi4vY29tbW9uL3NyYXQnKTtcbnZhciBIQUxGX1BJID0gTWF0aC5QSS8yO1xudmFyIE1BWF9JVEVSID0gMjA7XG5leHBvcnRzLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNwaGkgPSBNYXRoLnNpbih0aGlzLmxhdDApO1xuICB2YXIgY3BoaSA9IE1hdGguY29zKHRoaXMubGF0MCk7XG4gIGNwaGkgKj0gY3BoaTtcbiAgdGhpcy5yYyA9IE1hdGguc3FydCgxIC0gdGhpcy5lcykgLyAoMSAtIHRoaXMuZXMgKiBzcGhpICogc3BoaSk7XG4gIHRoaXMuQyA9IE1hdGguc3FydCgxICsgdGhpcy5lcyAqIGNwaGkgKiBjcGhpIC8gKDEgLSB0aGlzLmVzKSk7XG4gIHRoaXMucGhpYzAgPSBNYXRoLmFzaW4oc3BoaSAvIHRoaXMuQyk7XG4gIHRoaXMucmF0ZXhwID0gMC41ICogdGhpcy5DICogdGhpcy5lO1xuICB0aGlzLksgPSBNYXRoLnRhbigwLjUgKiB0aGlzLnBoaWMwICsgRk9SVFBJKSAvIChNYXRoLnBvdyhNYXRoLnRhbigwLjUgKiB0aGlzLmxhdDAgKyBGT1JUUEkpLCB0aGlzLkMpICogc3JhdCh0aGlzLmUgKiBzcGhpLCB0aGlzLnJhdGV4cCkpO1xufTtcblxuZXhwb3J0cy5mb3J3YXJkID0gZnVuY3Rpb24ocCkge1xuICB2YXIgbG9uID0gcC54O1xuICB2YXIgbGF0ID0gcC55O1xuXG4gIHAueSA9IDIgKiBNYXRoLmF0YW4odGhpcy5LICogTWF0aC5wb3coTWF0aC50YW4oMC41ICogbGF0ICsgRk9SVFBJKSwgdGhpcy5DKSAqIHNyYXQodGhpcy5lICogTWF0aC5zaW4obGF0KSwgdGhpcy5yYXRleHApKSAtIEhBTEZfUEk7XG4gIHAueCA9IHRoaXMuQyAqIGxvbjtcbiAgcmV0dXJuIHA7XG59O1xuXG5leHBvcnRzLmludmVyc2UgPSBmdW5jdGlvbihwKSB7XG4gIHZhciBERUxfVE9MID0gMWUtMTQ7XG4gIHZhciBsb24gPSBwLnggLyB0aGlzLkM7XG4gIHZhciBsYXQgPSBwLnk7XG4gIHZhciBudW0gPSBNYXRoLnBvdyhNYXRoLnRhbigwLjUgKiBsYXQgKyBGT1JUUEkpIC8gdGhpcy5LLCAxIC8gdGhpcy5DKTtcbiAgZm9yICh2YXIgaSA9IE1BWF9JVEVSOyBpID4gMDsgLS1pKSB7XG4gICAgbGF0ID0gMiAqIE1hdGguYXRhbihudW0gKiBzcmF0KHRoaXMuZSAqIE1hdGguc2luKHAueSksIC0gMC41ICogdGhpcy5lKSkgLSBIQUxGX1BJO1xuICAgIGlmIChNYXRoLmFicyhsYXQgLSBwLnkpIDwgREVMX1RPTCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHAueSA9IGxhdDtcbiAgfVxuICAvKiBjb252ZXJnZW5jZSBmYWlsZWQgKi9cbiAgaWYgKCFpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcC54ID0gbG9uO1xuICBwLnkgPSBsYXQ7XG4gIHJldHVybiBwO1xufTtcbmV4cG9ydHMubmFtZXMgPSBbXCJnYXVzc1wiXTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcm9qNC9saWIvcHJvamVjdGlvbnMvZ2F1c3MuanNcbi8vIG1vZHVsZSBpZCA9IDE0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9')},function(module,exports,__webpack_require__){eval('var adjust_lon = __webpack_require__(0);\nvar EPSLN = 1.0e-10;\nvar asinz = __webpack_require__(7);\n\n/*\n  reference:\n    Wolfram Mathworld "Gnomonic Projection"\n    http://mathworld.wolfram.com/GnomonicProjection.html\n    Accessed: 12th November 2009\n  */\nexports.init = function() {\n\n  /* Place parameters in static storage for common use\n      -------------------------------------------------*/\n  this.sin_p14 = Math.sin(this.lat0);\n  this.cos_p14 = Math.cos(this.lat0);\n  // Approximation for projecting points to the horizon (infinity)\n  this.infinity_dist = 1000 * this.a;\n  this.rc = 1;\n};\n\n\n/* Gnomonic forward equations--mapping lat,long to x,y\n    ---------------------------------------------------*/\nexports.forward = function(p) {\n  var sinphi, cosphi; /* sin and cos value        */\n  var dlon; /* delta longitude value      */\n  var coslon; /* cos of longitude        */\n  var ksp; /* scale factor          */\n  var g;\n  var x, y;\n  var lon = p.x;\n  var lat = p.y;\n  /* Forward equations\n      -----------------*/\n  dlon = adjust_lon(lon - this.long0);\n\n  sinphi = Math.sin(lat);\n  cosphi = Math.cos(lat);\n\n  coslon = Math.cos(dlon);\n  g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;\n  ksp = 1;\n  if ((g > 0) || (Math.abs(g) <= EPSLN)) {\n    x = this.x0 + this.a * ksp * cosphi * Math.sin(dlon) / g;\n    y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon) / g;\n  }\n  else {\n\n    // Point is in the opposing hemisphere and is unprojectable\n    // We still need to return a reasonable point, so we project \n    // to infinity, on a bearing \n    // equivalent to the northern hemisphere equivalent\n    // This is a reasonable approximation for short shapes and lines that \n    // straddle the horizon.\n\n    x = this.x0 + this.infinity_dist * cosphi * Math.sin(dlon);\n    y = this.y0 + this.infinity_dist * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);\n\n  }\n  p.x = x;\n  p.y = y;\n  return p;\n};\n\n\nexports.inverse = function(p) {\n  var rh; /* Rho */\n  var sinc, cosc;\n  var c;\n  var lon, lat;\n\n  /* Inverse equations\n      -----------------*/\n  p.x = (p.x - this.x0) / this.a;\n  p.y = (p.y - this.y0) / this.a;\n\n  p.x /= this.k0;\n  p.y /= this.k0;\n\n  if ((rh = Math.sqrt(p.x * p.x + p.y * p.y))) {\n    c = Math.atan2(rh, this.rc);\n    sinc = Math.sin(c);\n    cosc = Math.cos(c);\n\n    lat = asinz(cosc * this.sin_p14 + (p.y * sinc * this.cos_p14) / rh);\n    lon = Math.atan2(p.x * sinc, rh * this.cos_p14 * cosc - p.y * this.sin_p14 * sinc);\n    lon = adjust_lon(this.long0 + lon);\n  }\n  else {\n    lat = this.phic0;\n    lon = 0;\n  }\n\n  p.x = lon;\n  p.y = lat;\n  return p;\n};\nexports.names = ["gnom"];\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9nbm9tLmpzPzFjODMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixXQUFXO0FBQ1gsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjE0NS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBhZGp1c3RfbG9uID0gcmVxdWlyZSgnLi4vY29tbW9uL2FkanVzdF9sb24nKTtcbnZhciBFUFNMTiA9IDEuMGUtMTA7XG52YXIgYXNpbnogPSByZXF1aXJlKCcuLi9jb21tb24vYXNpbnonKTtcblxuLypcbiAgcmVmZXJlbmNlOlxuICAgIFdvbGZyYW0gTWF0aHdvcmxkIFwiR25vbW9uaWMgUHJvamVjdGlvblwiXG4gICAgaHR0cDovL21hdGh3b3JsZC53b2xmcmFtLmNvbS9Hbm9tb25pY1Byb2plY3Rpb24uaHRtbFxuICAgIEFjY2Vzc2VkOiAxMnRoIE5vdmVtYmVyIDIwMDlcbiAgKi9cbmV4cG9ydHMuaW5pdCA9IGZ1bmN0aW9uKCkge1xuXG4gIC8qIFBsYWNlIHBhcmFtZXRlcnMgaW4gc3RhdGljIHN0b3JhZ2UgZm9yIGNvbW1vbiB1c2VcbiAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuICB0aGlzLnNpbl9wMTQgPSBNYXRoLnNpbih0aGlzLmxhdDApO1xuICB0aGlzLmNvc19wMTQgPSBNYXRoLmNvcyh0aGlzLmxhdDApO1xuICAvLyBBcHByb3hpbWF0aW9uIGZvciBwcm9qZWN0aW5nIHBvaW50cyB0byB0aGUgaG9yaXpvbiAoaW5maW5pdHkpXG4gIHRoaXMuaW5maW5pdHlfZGlzdCA9IDEwMDAgKiB0aGlzLmE7XG4gIHRoaXMucmMgPSAxO1xufTtcblxuXG4vKiBHbm9tb25pYyBmb3J3YXJkIGVxdWF0aW9ucy0tbWFwcGluZyBsYXQsbG9uZyB0byB4LHlcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZXhwb3J0cy5mb3J3YXJkID0gZnVuY3Rpb24ocCkge1xuICB2YXIgc2lucGhpLCBjb3NwaGk7IC8qIHNpbiBhbmQgY29zIHZhbHVlICAgICAgICAqL1xuICB2YXIgZGxvbjsgLyogZGVsdGEgbG9uZ2l0dWRlIHZhbHVlICAgICAgKi9cbiAgdmFyIGNvc2xvbjsgLyogY29zIG9mIGxvbmdpdHVkZSAgICAgICAgKi9cbiAgdmFyIGtzcDsgLyogc2NhbGUgZmFjdG9yICAgICAgICAgICovXG4gIHZhciBnO1xuICB2YXIgeCwgeTtcbiAgdmFyIGxvbiA9IHAueDtcbiAgdmFyIGxhdCA9IHAueTtcbiAgLyogRm9yd2FyZCBlcXVhdGlvbnNcbiAgICAgIC0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgZGxvbiA9IGFkanVzdF9sb24obG9uIC0gdGhpcy5sb25nMCk7XG5cbiAgc2lucGhpID0gTWF0aC5zaW4obGF0KTtcbiAgY29zcGhpID0gTWF0aC5jb3MobGF0KTtcblxuICBjb3Nsb24gPSBNYXRoLmNvcyhkbG9uKTtcbiAgZyA9IHRoaXMuc2luX3AxNCAqIHNpbnBoaSArIHRoaXMuY29zX3AxNCAqIGNvc3BoaSAqIGNvc2xvbjtcbiAga3NwID0gMTtcbiAgaWYgKChnID4gMCkgfHwgKE1hdGguYWJzKGcpIDw9IEVQU0xOKSkge1xuICAgIHggPSB0aGlzLngwICsgdGhpcy5hICoga3NwICogY29zcGhpICogTWF0aC5zaW4oZGxvbikgLyBnO1xuICAgIHkgPSB0aGlzLnkwICsgdGhpcy5hICoga3NwICogKHRoaXMuY29zX3AxNCAqIHNpbnBoaSAtIHRoaXMuc2luX3AxNCAqIGNvc3BoaSAqIGNvc2xvbikgLyBnO1xuICB9XG4gIGVsc2Uge1xuXG4gICAgLy8gUG9pbnQgaXMgaW4gdGhlIG9wcG9zaW5nIGhlbWlzcGhlcmUgYW5kIGlzIHVucHJvamVjdGFibGVcbiAgICAvLyBXZSBzdGlsbCBuZWVkIHRvIHJldHVybiBhIHJlYXNvbmFibGUgcG9pbnQsIHNvIHdlIHByb2plY3QgXG4gICAgLy8gdG8gaW5maW5pdHksIG9uIGEgYmVhcmluZyBcbiAgICAvLyBlcXVpdmFsZW50IHRvIHRoZSBub3J0aGVybiBoZW1pc3BoZXJlIGVxdWl2YWxlbnRcbiAgICAvLyBUaGlzIGlzIGEgcmVhc29uYWJsZSBhcHByb3hpbWF0aW9uIGZvciBzaG9ydCBzaGFwZXMgYW5kIGxpbmVzIHRoYXQgXG4gICAgLy8gc3RyYWRkbGUgdGhlIGhvcml6b24uXG5cbiAgICB4ID0gdGhpcy54MCArIHRoaXMuaW5maW5pdHlfZGlzdCAqIGNvc3BoaSAqIE1hdGguc2luKGRsb24pO1xuICAgIHkgPSB0aGlzLnkwICsgdGhpcy5pbmZpbml0eV9kaXN0ICogKHRoaXMuY29zX3AxNCAqIHNpbnBoaSAtIHRoaXMuc2luX3AxNCAqIGNvc3BoaSAqIGNvc2xvbik7XG5cbiAgfVxuICBwLnggPSB4O1xuICBwLnkgPSB5O1xuICByZXR1cm4gcDtcbn07XG5cblxuZXhwb3J0cy5pbnZlcnNlID0gZnVuY3Rpb24ocCkge1xuICB2YXIgcmg7IC8qIFJobyAqL1xuICB2YXIgc2luYywgY29zYztcbiAgdmFyIGM7XG4gIHZhciBsb24sIGxhdDtcblxuICAvKiBJbnZlcnNlIGVxdWF0aW9uc1xuICAgICAgLS0tLS0tLS0tLS0tLS0tLS0qL1xuICBwLnggPSAocC54IC0gdGhpcy54MCkgLyB0aGlzLmE7XG4gIHAueSA9IChwLnkgLSB0aGlzLnkwKSAvIHRoaXMuYTtcblxuICBwLnggLz0gdGhpcy5rMDtcbiAgcC55IC89IHRoaXMuazA7XG5cbiAgaWYgKChyaCA9IE1hdGguc3FydChwLnggKiBwLnggKyBwLnkgKiBwLnkpKSkge1xuICAgIGMgPSBNYXRoLmF0YW4yKHJoLCB0aGlzLnJjKTtcbiAgICBzaW5jID0gTWF0aC5zaW4oYyk7XG4gICAgY29zYyA9IE1hdGguY29zKGMpO1xuXG4gICAgbGF0ID0gYXNpbnooY29zYyAqIHRoaXMuc2luX3AxNCArIChwLnkgKiBzaW5jICogdGhpcy5jb3NfcDE0KSAvIHJoKTtcbiAgICBsb24gPSBNYXRoLmF0YW4yKHAueCAqIHNpbmMsIHJoICogdGhpcy5jb3NfcDE0ICogY29zYyAtIHAueSAqIHRoaXMuc2luX3AxNCAqIHNpbmMpO1xuICAgIGxvbiA9IGFkanVzdF9sb24odGhpcy5sb25nMCArIGxvbik7XG4gIH1cbiAgZWxzZSB7XG4gICAgbGF0ID0gdGhpcy5waGljMDtcbiAgICBsb24gPSAwO1xuICB9XG5cbiAgcC54ID0gbG9uO1xuICBwLnkgPSBsYXQ7XG4gIHJldHVybiBwO1xufTtcbmV4cG9ydHMubmFtZXMgPSBbXCJnbm9tXCJdO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9nbm9tLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports,__webpack_require__){eval('var adjust_lon = __webpack_require__(0);\nexports.init = function() {\n  this.a = 6377397.155;\n  this.es = 0.006674372230614;\n  this.e = Math.sqrt(this.es);\n  if (!this.lat0) {\n    this.lat0 = 0.863937979737193;\n  }\n  if (!this.long0) {\n    this.long0 = 0.7417649320975901 - 0.308341501185665;\n  }\n  /* if scale not set default to 0.9999 */\n  if (!this.k0) {\n    this.k0 = 0.9999;\n  }\n  this.s45 = 0.785398163397448; /* 45 */\n  this.s90 = 2 * this.s45;\n  this.fi0 = this.lat0;\n  this.e2 = this.es;\n  this.e = Math.sqrt(this.e2);\n  this.alfa = Math.sqrt(1 + (this.e2 * Math.pow(Math.cos(this.fi0), 4)) / (1 - this.e2));\n  this.uq = 1.04216856380474;\n  this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa);\n  this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2);\n  this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g;\n  this.k1 = this.k0;\n  this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2));\n  this.s0 = 1.37008346281555;\n  this.n = Math.sin(this.s0);\n  this.ro0 = this.k1 * this.n0 / Math.tan(this.s0);\n  this.ad = this.s90 - this.uq;\n};\n\n/* ellipsoid */\n/* calculate xy from lat/lon */\n/* Constants, identical to inverse transform function */\nexports.forward = function(p) {\n  var gfi, u, deltav, s, d, eps, ro;\n  var lon = p.x;\n  var lat = p.y;\n  var delta_lon = adjust_lon(lon - this.long0);\n  /* Transformation */\n  gfi = Math.pow(((1 + this.e * Math.sin(lat)) / (1 - this.e * Math.sin(lat))), (this.alfa * this.e / 2));\n  u = 2 * (Math.atan(this.k * Math.pow(Math.tan(lat / 2 + this.s45), this.alfa) / gfi) - this.s45);\n  deltav = -delta_lon * this.alfa;\n  s = Math.asin(Math.cos(this.ad) * Math.sin(u) + Math.sin(this.ad) * Math.cos(u) * Math.cos(deltav));\n  d = Math.asin(Math.cos(u) * Math.sin(deltav) / Math.cos(s));\n  eps = this.n * d;\n  ro = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s / 2 + this.s45), this.n);\n  p.y = ro * Math.cos(eps) / 1;\n  p.x = ro * Math.sin(eps) / 1;\n\n  if (!this.czech) {\n    p.y *= -1;\n    p.x *= -1;\n  }\n  return (p);\n};\n\n/* calculate lat/lon from xy */\nexports.inverse = function(p) {\n  var u, deltav, s, d, eps, ro, fi1;\n  var ok;\n\n  /* Transformation */\n  /* revert y, x*/\n  var tmp = p.x;\n  p.x = p.y;\n  p.y = tmp;\n  if (!this.czech) {\n    p.y *= -1;\n    p.x *= -1;\n  }\n  ro = Math.sqrt(p.x * p.x + p.y * p.y);\n  eps = Math.atan2(p.y, p.x);\n  d = eps / Math.sin(this.s0);\n  s = 2 * (Math.atan(Math.pow(this.ro0 / ro, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45);\n  u = Math.asin(Math.cos(this.ad) * Math.sin(s) - Math.sin(this.ad) * Math.cos(s) * Math.cos(d));\n  deltav = Math.asin(Math.cos(s) * Math.sin(d) / Math.cos(u));\n  p.x = this.long0 - deltav / this.alfa;\n  fi1 = u;\n  ok = 0;\n  var iter = 0;\n  do {\n    p.y = 2 * (Math.atan(Math.pow(this.k, - 1 / this.alfa) * Math.pow(Math.tan(u / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(fi1)) / (1 - this.e * Math.sin(fi1)), this.e / 2)) - this.s45);\n    if (Math.abs(fi1 - p.y) < 0.0000000001) {\n      ok = 1;\n    }\n    fi1 = p.y;\n    iter += 1;\n  } while (ok === 0 && iter < 15);\n  if (iter >= 15) {\n    return null;\n  }\n\n  return (p);\n};\nexports.names = ["Krovak", "krovak"];\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9rcm92YWsuanM/ZjBjNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTQ2LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGFkanVzdF9sb24gPSByZXF1aXJlKCcuLi9jb21tb24vYWRqdXN0X2xvbicpO1xuZXhwb3J0cy5pbml0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuYSA9IDYzNzczOTcuMTU1O1xuICB0aGlzLmVzID0gMC4wMDY2NzQzNzIyMzA2MTQ7XG4gIHRoaXMuZSA9IE1hdGguc3FydCh0aGlzLmVzKTtcbiAgaWYgKCF0aGlzLmxhdDApIHtcbiAgICB0aGlzLmxhdDAgPSAwLjg2MzkzNzk3OTczNzE5MztcbiAgfVxuICBpZiAoIXRoaXMubG9uZzApIHtcbiAgICB0aGlzLmxvbmcwID0gMC43NDE3NjQ5MzIwOTc1OTAxIC0gMC4zMDgzNDE1MDExODU2NjU7XG4gIH1cbiAgLyogaWYgc2NhbGUgbm90IHNldCBkZWZhdWx0IHRvIDAuOTk5OSAqL1xuICBpZiAoIXRoaXMuazApIHtcbiAgICB0aGlzLmswID0gMC45OTk5O1xuICB9XG4gIHRoaXMuczQ1ID0gMC43ODUzOTgxNjMzOTc0NDg7IC8qIDQ1ICovXG4gIHRoaXMuczkwID0gMiAqIHRoaXMuczQ1O1xuICB0aGlzLmZpMCA9IHRoaXMubGF0MDtcbiAgdGhpcy5lMiA9IHRoaXMuZXM7XG4gIHRoaXMuZSA9IE1hdGguc3FydCh0aGlzLmUyKTtcbiAgdGhpcy5hbGZhID0gTWF0aC5zcXJ0KDEgKyAodGhpcy5lMiAqIE1hdGgucG93KE1hdGguY29zKHRoaXMuZmkwKSwgNCkpIC8gKDEgLSB0aGlzLmUyKSk7XG4gIHRoaXMudXEgPSAxLjA0MjE2ODU2MzgwNDc0O1xuICB0aGlzLnUwID0gTWF0aC5hc2luKE1hdGguc2luKHRoaXMuZmkwKSAvIHRoaXMuYWxmYSk7XG4gIHRoaXMuZyA9IE1hdGgucG93KCgxICsgdGhpcy5lICogTWF0aC5zaW4odGhpcy5maTApKSAvICgxIC0gdGhpcy5lICogTWF0aC5zaW4odGhpcy5maTApKSwgdGhpcy5hbGZhICogdGhpcy5lIC8gMik7XG4gIHRoaXMuayA9IE1hdGgudGFuKHRoaXMudTAgLyAyICsgdGhpcy5zNDUpIC8gTWF0aC5wb3coTWF0aC50YW4odGhpcy5maTAgLyAyICsgdGhpcy5zNDUpLCB0aGlzLmFsZmEpICogdGhpcy5nO1xuICB0aGlzLmsxID0gdGhpcy5rMDtcbiAgdGhpcy5uMCA9IHRoaXMuYSAqIE1hdGguc3FydCgxIC0gdGhpcy5lMikgLyAoMSAtIHRoaXMuZTIgKiBNYXRoLnBvdyhNYXRoLnNpbih0aGlzLmZpMCksIDIpKTtcbiAgdGhpcy5zMCA9IDEuMzcwMDgzNDYyODE1NTU7XG4gIHRoaXMubiA9IE1hdGguc2luKHRoaXMuczApO1xuICB0aGlzLnJvMCA9IHRoaXMuazEgKiB0aGlzLm4wIC8gTWF0aC50YW4odGhpcy5zMCk7XG4gIHRoaXMuYWQgPSB0aGlzLnM5MCAtIHRoaXMudXE7XG59O1xuXG4vKiBlbGxpcHNvaWQgKi9cbi8qIGNhbGN1bGF0ZSB4eSBmcm9tIGxhdC9sb24gKi9cbi8qIENvbnN0YW50cywgaWRlbnRpY2FsIHRvIGludmVyc2UgdHJhbnNmb3JtIGZ1bmN0aW9uICovXG5leHBvcnRzLmZvcndhcmQgPSBmdW5jdGlvbihwKSB7XG4gIHZhciBnZmksIHUsIGRlbHRhdiwgcywgZCwgZXBzLCBybztcbiAgdmFyIGxvbiA9IHAueDtcbiAgdmFyIGxhdCA9IHAueTtcbiAgdmFyIGRlbHRhX2xvbiA9IGFkanVzdF9sb24obG9uIC0gdGhpcy5sb25nMCk7XG4gIC8qIFRyYW5zZm9ybWF0aW9uICovXG4gIGdmaSA9IE1hdGgucG93KCgoMSArIHRoaXMuZSAqIE1hdGguc2luKGxhdCkpIC8gKDEgLSB0aGlzLmUgKiBNYXRoLnNpbihsYXQpKSksICh0aGlzLmFsZmEgKiB0aGlzLmUgLyAyKSk7XG4gIHUgPSAyICogKE1hdGguYXRhbih0aGlzLmsgKiBNYXRoLnBvdyhNYXRoLnRhbihsYXQgLyAyICsgdGhpcy5zNDUpLCB0aGlzLmFsZmEpIC8gZ2ZpKSAtIHRoaXMuczQ1KTtcbiAgZGVsdGF2ID0gLWRlbHRhX2xvbiAqIHRoaXMuYWxmYTtcbiAgcyA9IE1hdGguYXNpbihNYXRoLmNvcyh0aGlzLmFkKSAqIE1hdGguc2luKHUpICsgTWF0aC5zaW4odGhpcy5hZCkgKiBNYXRoLmNvcyh1KSAqIE1hdGguY29zKGRlbHRhdikpO1xuICBkID0gTWF0aC5hc2luKE1hdGguY29zKHUpICogTWF0aC5zaW4oZGVsdGF2KSAvIE1hdGguY29zKHMpKTtcbiAgZXBzID0gdGhpcy5uICogZDtcbiAgcm8gPSB0aGlzLnJvMCAqIE1hdGgucG93KE1hdGgudGFuKHRoaXMuczAgLyAyICsgdGhpcy5zNDUpLCB0aGlzLm4pIC8gTWF0aC5wb3coTWF0aC50YW4ocyAvIDIgKyB0aGlzLnM0NSksIHRoaXMubik7XG4gIHAueSA9IHJvICogTWF0aC5jb3MoZXBzKSAvIDE7XG4gIHAueCA9IHJvICogTWF0aC5zaW4oZXBzKSAvIDE7XG5cbiAgaWYgKCF0aGlzLmN6ZWNoKSB7XG4gICAgcC55ICo9IC0xO1xuICAgIHAueCAqPSAtMTtcbiAgfVxuICByZXR1cm4gKHApO1xufTtcblxuLyogY2FsY3VsYXRlIGxhdC9sb24gZnJvbSB4eSAqL1xuZXhwb3J0cy5pbnZlcnNlID0gZnVuY3Rpb24ocCkge1xuICB2YXIgdSwgZGVsdGF2LCBzLCBkLCBlcHMsIHJvLCBmaTE7XG4gIHZhciBvaztcblxuICAvKiBUcmFuc2Zvcm1hdGlvbiAqL1xuICAvKiByZXZlcnQgeSwgeCovXG4gIHZhciB0bXAgPSBwLng7XG4gIHAueCA9IHAueTtcbiAgcC55ID0gdG1wO1xuICBpZiAoIXRoaXMuY3plY2gpIHtcbiAgICBwLnkgKj0gLTE7XG4gICAgcC54ICo9IC0xO1xuICB9XG4gIHJvID0gTWF0aC5zcXJ0KHAueCAqIHAueCArIHAueSAqIHAueSk7XG4gIGVwcyA9IE1hdGguYXRhbjIocC55LCBwLngpO1xuICBkID0gZXBzIC8gTWF0aC5zaW4odGhpcy5zMCk7XG4gIHMgPSAyICogKE1hdGguYXRhbihNYXRoLnBvdyh0aGlzLnJvMCAvIHJvLCAxIC8gdGhpcy5uKSAqIE1hdGgudGFuKHRoaXMuczAgLyAyICsgdGhpcy5zNDUpKSAtIHRoaXMuczQ1KTtcbiAgdSA9IE1hdGguYXNpbihNYXRoLmNvcyh0aGlzLmFkKSAqIE1hdGguc2luKHMpIC0gTWF0aC5zaW4odGhpcy5hZCkgKiBNYXRoLmNvcyhzKSAqIE1hdGguY29zKGQpKTtcbiAgZGVsdGF2ID0gTWF0aC5hc2luKE1hdGguY29zKHMpICogTWF0aC5zaW4oZCkgLyBNYXRoLmNvcyh1KSk7XG4gIHAueCA9IHRoaXMubG9uZzAgLSBkZWx0YXYgLyB0aGlzLmFsZmE7XG4gIGZpMSA9IHU7XG4gIG9rID0gMDtcbiAgdmFyIGl0ZXIgPSAwO1xuICBkbyB7XG4gICAgcC55ID0gMiAqIChNYXRoLmF0YW4oTWF0aC5wb3codGhpcy5rLCAtIDEgLyB0aGlzLmFsZmEpICogTWF0aC5wb3coTWF0aC50YW4odSAvIDIgKyB0aGlzLnM0NSksIDEgLyB0aGlzLmFsZmEpICogTWF0aC5wb3coKDEgKyB0aGlzLmUgKiBNYXRoLnNpbihmaTEpKSAvICgxIC0gdGhpcy5lICogTWF0aC5zaW4oZmkxKSksIHRoaXMuZSAvIDIpKSAtIHRoaXMuczQ1KTtcbiAgICBpZiAoTWF0aC5hYnMoZmkxIC0gcC55KSA8IDAuMDAwMDAwMDAwMSkge1xuICAgICAgb2sgPSAxO1xuICAgIH1cbiAgICBmaTEgPSBwLnk7XG4gICAgaXRlciArPSAxO1xuICB9IHdoaWxlIChvayA9PT0gMCAmJiBpdGVyIDwgMTUpO1xuICBpZiAoaXRlciA+PSAxNSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIChwKTtcbn07XG5leHBvcnRzLm5hbWVzID0gW1wiS3JvdmFrXCIsIFwia3JvdmFrXCJdO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9rcm92YWsuanNcbi8vIG1vZHVsZSBpZCA9IDE0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9')},function(module,exports,__webpack_require__){eval('var HALF_PI = Math.PI/2;\nvar FORTPI = Math.PI/4;\nvar EPSLN = 1.0e-10;\nvar qsfnz = __webpack_require__(35);\nvar adjust_lon = __webpack_require__(0);\n/*\n  reference\n    "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,\n    The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.\n  */\n\nexports.S_POLE = 1;\nexports.N_POLE = 2;\nexports.EQUIT = 3;\nexports.OBLIQ = 4;\n\n\n/* Initialize the Lambert Azimuthal Equal Area projection\n  ------------------------------------------------------*/\nexports.init = function() {\n  var t = Math.abs(this.lat0);\n  if (Math.abs(t - HALF_PI) < EPSLN) {\n    this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE;\n  }\n  else if (Math.abs(t) < EPSLN) {\n    this.mode = this.EQUIT;\n  }\n  else {\n    this.mode = this.OBLIQ;\n  }\n  if (this.es > 0) {\n    var sinphi;\n\n    this.qp = qsfnz(this.e, 1);\n    this.mmf = 0.5 / (1 - this.es);\n    this.apa = this.authset(this.es);\n    switch (this.mode) {\n    case this.N_POLE:\n      this.dd = 1;\n      break;\n    case this.S_POLE:\n      this.dd = 1;\n      break;\n    case this.EQUIT:\n      this.rq = Math.sqrt(0.5 * this.qp);\n      this.dd = 1 / this.rq;\n      this.xmf = 1;\n      this.ymf = 0.5 * this.qp;\n      break;\n    case this.OBLIQ:\n      this.rq = Math.sqrt(0.5 * this.qp);\n      sinphi = Math.sin(this.lat0);\n      this.sinb1 = qsfnz(this.e, sinphi) / this.qp;\n      this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1);\n      this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * sinphi * sinphi) * this.rq * this.cosb1);\n      this.ymf = (this.xmf = this.rq) / this.dd;\n      this.xmf *= this.dd;\n      break;\n    }\n  }\n  else {\n    if (this.mode === this.OBLIQ) {\n      this.sinph0 = Math.sin(this.lat0);\n      this.cosph0 = Math.cos(this.lat0);\n    }\n  }\n};\n\n/* Lambert Azimuthal Equal Area forward equations--mapping lat,long to x,y\n  -----------------------------------------------------------------------*/\nexports.forward = function(p) {\n\n  /* Forward equations\n      -----------------*/\n  var x, y, coslam, sinlam, sinphi, q, sinb, cosb, b, cosphi;\n  var lam = p.x;\n  var phi = p.y;\n\n  lam = adjust_lon(lam - this.long0);\n\n  if (this.sphere) {\n    sinphi = Math.sin(phi);\n    cosphi = Math.cos(phi);\n    coslam = Math.cos(lam);\n    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {\n      y = (this.mode === this.EQUIT) ? 1 + cosphi * coslam : 1 + this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;\n      if (y <= EPSLN) {\n        return null;\n      }\n      y = Math.sqrt(2 / y);\n      x = y * cosphi * Math.sin(lam);\n      y *= (this.mode === this.EQUIT) ? sinphi : this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;\n    }\n    else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {\n      if (this.mode === this.N_POLE) {\n        coslam = -coslam;\n      }\n      if (Math.abs(phi + this.phi0) < EPSLN) {\n        return null;\n      }\n      y = FORTPI - phi * 0.5;\n      y = 2 * ((this.mode === this.S_POLE) ? Math.cos(y) : Math.sin(y));\n      x = y * Math.sin(lam);\n      y *= coslam;\n    }\n  }\n  else {\n    sinb = 0;\n    cosb = 0;\n    b = 0;\n    coslam = Math.cos(lam);\n    sinlam = Math.sin(lam);\n    sinphi = Math.sin(phi);\n    q = qsfnz(this.e, sinphi);\n    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {\n      sinb = q / this.qp;\n      cosb = Math.sqrt(1 - sinb * sinb);\n    }\n    switch (this.mode) {\n    case this.OBLIQ:\n      b = 1 + this.sinb1 * sinb + this.cosb1 * cosb * coslam;\n      break;\n    case this.EQUIT:\n      b = 1 + cosb * coslam;\n      break;\n    case this.N_POLE:\n      b = HALF_PI + phi;\n      q = this.qp - q;\n      break;\n    case this.S_POLE:\n      b = phi - HALF_PI;\n      q = this.qp + q;\n      break;\n    }\n    if (Math.abs(b) < EPSLN) {\n      return null;\n    }\n    switch (this.mode) {\n    case this.OBLIQ:\n    case this.EQUIT:\n      b = Math.sqrt(2 / b);\n      if (this.mode === this.OBLIQ) {\n        y = this.ymf * b * (this.cosb1 * sinb - this.sinb1 * cosb * coslam);\n      }\n      else {\n        y = (b = Math.sqrt(2 / (1 + cosb * coslam))) * sinb * this.ymf;\n      }\n      x = this.xmf * b * cosb * sinlam;\n      break;\n    case this.N_POLE:\n    case this.S_POLE:\n      if (q >= 0) {\n        x = (b = Math.sqrt(q)) * sinlam;\n        y = coslam * ((this.mode === this.S_POLE) ? b : -b);\n      }\n      else {\n        x = y = 0;\n      }\n      break;\n    }\n  }\n\n  p.x = this.a * x + this.x0;\n  p.y = this.a * y + this.y0;\n  return p;\n};\n\n/* Inverse equations\n  -----------------*/\nexports.inverse = function(p) {\n  p.x -= this.x0;\n  p.y -= this.y0;\n  var x = p.x / this.a;\n  var y = p.y / this.a;\n  var lam, phi, cCe, sCe, q, rho, ab;\n\n  if (this.sphere) {\n    var cosz = 0,\n      rh, sinz = 0;\n\n    rh = Math.sqrt(x * x + y * y);\n    phi = rh * 0.5;\n    if (phi > 1) {\n      return null;\n    }\n    phi = 2 * Math.asin(phi);\n    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {\n      sinz = Math.sin(phi);\n      cosz = Math.cos(phi);\n    }\n    switch (this.mode) {\n    case this.EQUIT:\n      phi = (Math.abs(rh) <= EPSLN) ? 0 : Math.asin(y * sinz / rh);\n      x *= sinz;\n      y = cosz * rh;\n      break;\n    case this.OBLIQ:\n      phi = (Math.abs(rh) <= EPSLN) ? this.phi0 : Math.asin(cosz * this.sinph0 + y * sinz * this.cosph0 / rh);\n      x *= sinz * this.cosph0;\n      y = (cosz - Math.sin(phi) * this.sinph0) * rh;\n      break;\n    case this.N_POLE:\n      y = -y;\n      phi = HALF_PI - phi;\n      break;\n    case this.S_POLE:\n      phi -= HALF_PI;\n      break;\n    }\n    lam = (y === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ)) ? 0 : Math.atan2(x, y);\n  }\n  else {\n    ab = 0;\n    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {\n      x /= this.dd;\n      y *= this.dd;\n      rho = Math.sqrt(x * x + y * y);\n      if (rho < EPSLN) {\n        p.x = 0;\n        p.y = this.phi0;\n        return p;\n      }\n      sCe = 2 * Math.asin(0.5 * rho / this.rq);\n      cCe = Math.cos(sCe);\n      x *= (sCe = Math.sin(sCe));\n      if (this.mode === this.OBLIQ) {\n        ab = cCe * this.sinb1 + y * sCe * this.cosb1 / rho;\n        q = this.qp * ab;\n        y = rho * this.cosb1 * cCe - y * this.sinb1 * sCe;\n      }\n      else {\n        ab = y * sCe / rho;\n        q = this.qp * ab;\n        y = rho * cCe;\n      }\n    }\n    else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {\n      if (this.mode === this.N_POLE) {\n        y = -y;\n      }\n      q = (x * x + y * y);\n      if (!q) {\n        p.x = 0;\n        p.y = this.phi0;\n        return p;\n      }\n      ab = 1 - q / this.qp;\n      if (this.mode === this.S_POLE) {\n        ab = -ab;\n      }\n    }\n    lam = Math.atan2(x, y);\n    phi = this.authlat(Math.asin(ab), this.apa);\n  }\n\n\n  p.x = adjust_lon(this.long0 + lam);\n  p.y = phi;\n  return p;\n};\n\n/* determine latitude from authalic latitude */\nexports.P00 = 0.33333333333333333333;\nexports.P01 = 0.17222222222222222222;\nexports.P02 = 0.10257936507936507936;\nexports.P10 = 0.06388888888888888888;\nexports.P11 = 0.06640211640211640211;\nexports.P20 = 0.01641501294219154443;\n\nexports.authset = function(es) {\n  var t;\n  var APA = [];\n  APA[0] = es * this.P00;\n  t = es * es;\n  APA[0] += t * this.P01;\n  APA[1] = t * this.P10;\n  t *= es;\n  APA[0] += t * this.P02;\n  APA[1] += t * this.P11;\n  APA[2] = t * this.P20;\n  return APA;\n};\n\nexports.authlat = function(beta, APA) {\n  var t = beta + beta;\n  return (beta + APA[0] * Math.sin(t) + APA[1] * Math.sin(t + t) + APA[2] * Math.sin(t + t + t));\n};\nexports.names = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9sYWVhLmpzPzA5NzQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxNDcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgSEFMRl9QSSA9IE1hdGguUEkvMjtcbnZhciBGT1JUUEkgPSBNYXRoLlBJLzQ7XG52YXIgRVBTTE4gPSAxLjBlLTEwO1xudmFyIHFzZm56ID0gcmVxdWlyZSgnLi4vY29tbW9uL3FzZm56Jyk7XG52YXIgYWRqdXN0X2xvbiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9hZGp1c3RfbG9uJyk7XG4vKlxuICByZWZlcmVuY2VcbiAgICBcIk5ldyBFcXVhbC1BcmVhIE1hcCBQcm9qZWN0aW9ucyBmb3IgTm9uY2lyY3VsYXIgUmVnaW9uc1wiLCBKb2huIFAuIFNueWRlcixcbiAgICBUaGUgQW1lcmljYW4gQ2FydG9ncmFwaGVyLCBWb2wgMTUsIE5vLiA0LCBPY3RvYmVyIDE5ODgsIHBwLiAzNDEtMzU1LlxuICAqL1xuXG5leHBvcnRzLlNfUE9MRSA9IDE7XG5leHBvcnRzLk5fUE9MRSA9IDI7XG5leHBvcnRzLkVRVUlUID0gMztcbmV4cG9ydHMuT0JMSVEgPSA0O1xuXG5cbi8qIEluaXRpYWxpemUgdGhlIExhbWJlcnQgQXppbXV0aGFsIEVxdWFsIEFyZWEgcHJvamVjdGlvblxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZXhwb3J0cy5pbml0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciB0ID0gTWF0aC5hYnModGhpcy5sYXQwKTtcbiAgaWYgKE1hdGguYWJzKHQgLSBIQUxGX1BJKSA8IEVQU0xOKSB7XG4gICAgdGhpcy5tb2RlID0gdGhpcy5sYXQwIDwgMCA/IHRoaXMuU19QT0xFIDogdGhpcy5OX1BPTEU7XG4gIH1cbiAgZWxzZSBpZiAoTWF0aC5hYnModCkgPCBFUFNMTikge1xuICAgIHRoaXMubW9kZSA9IHRoaXMuRVFVSVQ7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhpcy5tb2RlID0gdGhpcy5PQkxJUTtcbiAgfVxuICBpZiAodGhpcy5lcyA+IDApIHtcbiAgICB2YXIgc2lucGhpO1xuXG4gICAgdGhpcy5xcCA9IHFzZm56KHRoaXMuZSwgMSk7XG4gICAgdGhpcy5tbWYgPSAwLjUgLyAoMSAtIHRoaXMuZXMpO1xuICAgIHRoaXMuYXBhID0gdGhpcy5hdXRoc2V0KHRoaXMuZXMpO1xuICAgIHN3aXRjaCAodGhpcy5tb2RlKSB7XG4gICAgY2FzZSB0aGlzLk5fUE9MRTpcbiAgICAgIHRoaXMuZGQgPSAxO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSB0aGlzLlNfUE9MRTpcbiAgICAgIHRoaXMuZGQgPSAxO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSB0aGlzLkVRVUlUOlxuICAgICAgdGhpcy5ycSA9IE1hdGguc3FydCgwLjUgKiB0aGlzLnFwKTtcbiAgICAgIHRoaXMuZGQgPSAxIC8gdGhpcy5ycTtcbiAgICAgIHRoaXMueG1mID0gMTtcbiAgICAgIHRoaXMueW1mID0gMC41ICogdGhpcy5xcDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgdGhpcy5PQkxJUTpcbiAgICAgIHRoaXMucnEgPSBNYXRoLnNxcnQoMC41ICogdGhpcy5xcCk7XG4gICAgICBzaW5waGkgPSBNYXRoLnNpbih0aGlzLmxhdDApO1xuICAgICAgdGhpcy5zaW5iMSA9IHFzZm56KHRoaXMuZSwgc2lucGhpKSAvIHRoaXMucXA7XG4gICAgICB0aGlzLmNvc2IxID0gTWF0aC5zcXJ0KDEgLSB0aGlzLnNpbmIxICogdGhpcy5zaW5iMSk7XG4gICAgICB0aGlzLmRkID0gTWF0aC5jb3ModGhpcy5sYXQwKSAvIChNYXRoLnNxcnQoMSAtIHRoaXMuZXMgKiBzaW5waGkgKiBzaW5waGkpICogdGhpcy5ycSAqIHRoaXMuY29zYjEpO1xuICAgICAgdGhpcy55bWYgPSAodGhpcy54bWYgPSB0aGlzLnJxKSAvIHRoaXMuZGQ7XG4gICAgICB0aGlzLnhtZiAqPSB0aGlzLmRkO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIGlmICh0aGlzLm1vZGUgPT09IHRoaXMuT0JMSVEpIHtcbiAgICAgIHRoaXMuc2lucGgwID0gTWF0aC5zaW4odGhpcy5sYXQwKTtcbiAgICAgIHRoaXMuY29zcGgwID0gTWF0aC5jb3ModGhpcy5sYXQwKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qIExhbWJlcnQgQXppbXV0aGFsIEVxdWFsIEFyZWEgZm9yd2FyZCBlcXVhdGlvbnMtLW1hcHBpbmcgbGF0LGxvbmcgdG8geCx5XG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmV4cG9ydHMuZm9yd2FyZCA9IGZ1bmN0aW9uKHApIHtcblxuICAvKiBGb3J3YXJkIGVxdWF0aW9uc1xuICAgICAgLS0tLS0tLS0tLS0tLS0tLS0qL1xuICB2YXIgeCwgeSwgY29zbGFtLCBzaW5sYW0sIHNpbnBoaSwgcSwgc2luYiwgY29zYiwgYiwgY29zcGhpO1xuICB2YXIgbGFtID0gcC54O1xuICB2YXIgcGhpID0gcC55O1xuXG4gIGxhbSA9IGFkanVzdF9sb24obGFtIC0gdGhpcy5sb25nMCk7XG5cbiAgaWYgKHRoaXMuc3BoZXJlKSB7XG4gICAgc2lucGhpID0gTWF0aC5zaW4ocGhpKTtcbiAgICBjb3NwaGkgPSBNYXRoLmNvcyhwaGkpO1xuICAgIGNvc2xhbSA9IE1hdGguY29zKGxhbSk7XG4gICAgaWYgKHRoaXMubW9kZSA9PT0gdGhpcy5PQkxJUSB8fCB0aGlzLm1vZGUgPT09IHRoaXMuRVFVSVQpIHtcbiAgICAgIHkgPSAodGhpcy5tb2RlID09PSB0aGlzLkVRVUlUKSA/IDEgKyBjb3NwaGkgKiBjb3NsYW0gOiAxICsgdGhpcy5zaW5waDAgKiBzaW5waGkgKyB0aGlzLmNvc3BoMCAqIGNvc3BoaSAqIGNvc2xhbTtcbiAgICAgIGlmICh5IDw9IEVQU0xOKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgeSA9IE1hdGguc3FydCgyIC8geSk7XG4gICAgICB4ID0geSAqIGNvc3BoaSAqIE1hdGguc2luKGxhbSk7XG4gICAgICB5ICo9ICh0aGlzLm1vZGUgPT09IHRoaXMuRVFVSVQpID8gc2lucGhpIDogdGhpcy5jb3NwaDAgKiBzaW5waGkgLSB0aGlzLnNpbnBoMCAqIGNvc3BoaSAqIGNvc2xhbTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5tb2RlID09PSB0aGlzLk5fUE9MRSB8fCB0aGlzLm1vZGUgPT09IHRoaXMuU19QT0xFKSB7XG4gICAgICBpZiAodGhpcy5tb2RlID09PSB0aGlzLk5fUE9MRSkge1xuICAgICAgICBjb3NsYW0gPSAtY29zbGFtO1xuICAgICAgfVxuICAgICAgaWYgKE1hdGguYWJzKHBoaSArIHRoaXMucGhpMCkgPCBFUFNMTikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHkgPSBGT1JUUEkgLSBwaGkgKiAwLjU7XG4gICAgICB5ID0gMiAqICgodGhpcy5tb2RlID09PSB0aGlzLlNfUE9MRSkgPyBNYXRoLmNvcyh5KSA6IE1hdGguc2luKHkpKTtcbiAgICAgIHggPSB5ICogTWF0aC5zaW4obGFtKTtcbiAgICAgIHkgKj0gY29zbGFtO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICBzaW5iID0gMDtcbiAgICBjb3NiID0gMDtcbiAgICBiID0gMDtcbiAgICBjb3NsYW0gPSBNYXRoLmNvcyhsYW0pO1xuICAgIHNpbmxhbSA9IE1hdGguc2luKGxhbSk7XG4gICAgc2lucGhpID0gTWF0aC5zaW4ocGhpKTtcbiAgICBxID0gcXNmbnoodGhpcy5lLCBzaW5waGkpO1xuICAgIGlmICh0aGlzLm1vZGUgPT09IHRoaXMuT0JMSVEgfHwgdGhpcy5tb2RlID09PSB0aGlzLkVRVUlUKSB7XG4gICAgICBzaW5iID0gcSAvIHRoaXMucXA7XG4gICAgICBjb3NiID0gTWF0aC5zcXJ0KDEgLSBzaW5iICogc2luYik7XG4gICAgfVxuICAgIHN3aXRjaCAodGhpcy5tb2RlKSB7XG4gICAgY2FzZSB0aGlzLk9CTElROlxuICAgICAgYiA9IDEgKyB0aGlzLnNpbmIxICogc2luYiArIHRoaXMuY29zYjEgKiBjb3NiICogY29zbGFtO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSB0aGlzLkVRVUlUOlxuICAgICAgYiA9IDEgKyBjb3NiICogY29zbGFtO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSB0aGlzLk5fUE9MRTpcbiAgICAgIGIgPSBIQUxGX1BJICsgcGhpO1xuICAgICAgcSA9IHRoaXMucXAgLSBxO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSB0aGlzLlNfUE9MRTpcbiAgICAgIGIgPSBwaGkgLSBIQUxGX1BJO1xuICAgICAgcSA9IHRoaXMucXAgKyBxO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChNYXRoLmFicyhiKSA8IEVQU0xOKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc3dpdGNoICh0aGlzLm1vZGUpIHtcbiAgICBjYXNlIHRoaXMuT0JMSVE6XG4gICAgY2FzZSB0aGlzLkVRVUlUOlxuICAgICAgYiA9IE1hdGguc3FydCgyIC8gYik7XG4gICAgICBpZiAodGhpcy5tb2RlID09PSB0aGlzLk9CTElRKSB7XG4gICAgICAgIHkgPSB0aGlzLnltZiAqIGIgKiAodGhpcy5jb3NiMSAqIHNpbmIgLSB0aGlzLnNpbmIxICogY29zYiAqIGNvc2xhbSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgeSA9IChiID0gTWF0aC5zcXJ0KDIgLyAoMSArIGNvc2IgKiBjb3NsYW0pKSkgKiBzaW5iICogdGhpcy55bWY7XG4gICAgICB9XG4gICAgICB4ID0gdGhpcy54bWYgKiBiICogY29zYiAqIHNpbmxhbTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgdGhpcy5OX1BPTEU6XG4gICAgY2FzZSB0aGlzLlNfUE9MRTpcbiAgICAgIGlmIChxID49IDApIHtcbiAgICAgICAgeCA9IChiID0gTWF0aC5zcXJ0KHEpKSAqIHNpbmxhbTtcbiAgICAgICAgeSA9IGNvc2xhbSAqICgodGhpcy5tb2RlID09PSB0aGlzLlNfUE9MRSkgPyBiIDogLWIpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHggPSB5ID0gMDtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHAueCA9IHRoaXMuYSAqIHggKyB0aGlzLngwO1xuICBwLnkgPSB0aGlzLmEgKiB5ICsgdGhpcy55MDtcbiAgcmV0dXJuIHA7XG59O1xuXG4vKiBJbnZlcnNlIGVxdWF0aW9uc1xuICAtLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnRzLmludmVyc2UgPSBmdW5jdGlvbihwKSB7XG4gIHAueCAtPSB0aGlzLngwO1xuICBwLnkgLT0gdGhpcy55MDtcbiAgdmFyIHggPSBwLnggLyB0aGlzLmE7XG4gIHZhciB5ID0gcC55IC8gdGhpcy5hO1xuICB2YXIgbGFtLCBwaGksIGNDZSwgc0NlLCBxLCByaG8sIGFiO1xuXG4gIGlmICh0aGlzLnNwaGVyZSkge1xuICAgIHZhciBjb3N6ID0gMCxcbiAgICAgIHJoLCBzaW56ID0gMDtcblxuICAgIHJoID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuICAgIHBoaSA9IHJoICogMC41O1xuICAgIGlmIChwaGkgPiAxKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcGhpID0gMiAqIE1hdGguYXNpbihwaGkpO1xuICAgIGlmICh0aGlzLm1vZGUgPT09IHRoaXMuT0JMSVEgfHwgdGhpcy5tb2RlID09PSB0aGlzLkVRVUlUKSB7XG4gICAgICBzaW56ID0gTWF0aC5zaW4ocGhpKTtcbiAgICAgIGNvc3ogPSBNYXRoLmNvcyhwaGkpO1xuICAgIH1cbiAgICBzd2l0Y2ggKHRoaXMubW9kZSkge1xuICAgIGNhc2UgdGhpcy5FUVVJVDpcbiAgICAgIHBoaSA9IChNYXRoLmFicyhyaCkgPD0gRVBTTE4pID8gMCA6IE1hdGguYXNpbih5ICogc2lueiAvIHJoKTtcbiAgICAgIHggKj0gc2luejtcbiAgICAgIHkgPSBjb3N6ICogcmg7XG4gICAgICBicmVhaztcbiAgICBjYXNlIHRoaXMuT0JMSVE6XG4gICAgICBwaGkgPSAoTWF0aC5hYnMocmgpIDw9IEVQU0xOKSA/IHRoaXMucGhpMCA6IE1hdGguYXNpbihjb3N6ICogdGhpcy5zaW5waDAgKyB5ICogc2lueiAqIHRoaXMuY29zcGgwIC8gcmgpO1xuICAgICAgeCAqPSBzaW56ICogdGhpcy5jb3NwaDA7XG4gICAgICB5ID0gKGNvc3ogLSBNYXRoLnNpbihwaGkpICogdGhpcy5zaW5waDApICogcmg7XG4gICAgICBicmVhaztcbiAgICBjYXNlIHRoaXMuTl9QT0xFOlxuICAgICAgeSA9IC15O1xuICAgICAgcGhpID0gSEFMRl9QSSAtIHBoaTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgdGhpcy5TX1BPTEU6XG4gICAgICBwaGkgLT0gSEFMRl9QSTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBsYW0gPSAoeSA9PT0gMCAmJiAodGhpcy5tb2RlID09PSB0aGlzLkVRVUlUIHx8IHRoaXMubW9kZSA9PT0gdGhpcy5PQkxJUSkpID8gMCA6IE1hdGguYXRhbjIoeCwgeSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgYWIgPSAwO1xuICAgIGlmICh0aGlzLm1vZGUgPT09IHRoaXMuT0JMSVEgfHwgdGhpcy5tb2RlID09PSB0aGlzLkVRVUlUKSB7XG4gICAgICB4IC89IHRoaXMuZGQ7XG4gICAgICB5ICo9IHRoaXMuZGQ7XG4gICAgICByaG8gPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG4gICAgICBpZiAocmhvIDwgRVBTTE4pIHtcbiAgICAgICAgcC54ID0gMDtcbiAgICAgICAgcC55ID0gdGhpcy5waGkwO1xuICAgICAgICByZXR1cm4gcDtcbiAgICAgIH1cbiAgICAgIHNDZSA9IDIgKiBNYXRoLmFzaW4oMC41ICogcmhvIC8gdGhpcy5ycSk7XG4gICAgICBjQ2UgPSBNYXRoLmNvcyhzQ2UpO1xuICAgICAgeCAqPSAoc0NlID0gTWF0aC5zaW4oc0NlKSk7XG4gICAgICBpZiAodGhpcy5tb2RlID09PSB0aGlzLk9CTElRKSB7XG4gICAgICAgIGFiID0gY0NlICogdGhpcy5zaW5iMSArIHkgKiBzQ2UgKiB0aGlzLmNvc2IxIC8gcmhvO1xuICAgICAgICBxID0gdGhpcy5xcCAqIGFiO1xuICAgICAgICB5ID0gcmhvICogdGhpcy5jb3NiMSAqIGNDZSAtIHkgKiB0aGlzLnNpbmIxICogc0NlO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGFiID0geSAqIHNDZSAvIHJobztcbiAgICAgICAgcSA9IHRoaXMucXAgKiBhYjtcbiAgICAgICAgeSA9IHJobyAqIGNDZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5tb2RlID09PSB0aGlzLk5fUE9MRSB8fCB0aGlzLm1vZGUgPT09IHRoaXMuU19QT0xFKSB7XG4gICAgICBpZiAodGhpcy5tb2RlID09PSB0aGlzLk5fUE9MRSkge1xuICAgICAgICB5ID0gLXk7XG4gICAgICB9XG4gICAgICBxID0gKHggKiB4ICsgeSAqIHkpO1xuICAgICAgaWYgKCFxKSB7XG4gICAgICAgIHAueCA9IDA7XG4gICAgICAgIHAueSA9IHRoaXMucGhpMDtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgICB9XG4gICAgICBhYiA9IDEgLSBxIC8gdGhpcy5xcDtcbiAgICAgIGlmICh0aGlzLm1vZGUgPT09IHRoaXMuU19QT0xFKSB7XG4gICAgICAgIGFiID0gLWFiO1xuICAgICAgfVxuICAgIH1cbiAgICBsYW0gPSBNYXRoLmF0YW4yKHgsIHkpO1xuICAgIHBoaSA9IHRoaXMuYXV0aGxhdChNYXRoLmFzaW4oYWIpLCB0aGlzLmFwYSk7XG4gIH1cblxuXG4gIHAueCA9IGFkanVzdF9sb24odGhpcy5sb25nMCArIGxhbSk7XG4gIHAueSA9IHBoaTtcbiAgcmV0dXJuIHA7XG59O1xuXG4vKiBkZXRlcm1pbmUgbGF0aXR1ZGUgZnJvbSBhdXRoYWxpYyBsYXRpdHVkZSAqL1xuZXhwb3J0cy5QMDAgPSAwLjMzMzMzMzMzMzMzMzMzMzMzMzMzO1xuZXhwb3J0cy5QMDEgPSAwLjE3MjIyMjIyMjIyMjIyMjIyMjIyO1xuZXhwb3J0cy5QMDIgPSAwLjEwMjU3OTM2NTA3OTM2NTA3OTM2O1xuZXhwb3J0cy5QMTAgPSAwLjA2Mzg4ODg4ODg4ODg4ODg4ODg4O1xuZXhwb3J0cy5QMTEgPSAwLjA2NjQwMjExNjQwMjExNjQwMjExO1xuZXhwb3J0cy5QMjAgPSAwLjAxNjQxNTAxMjk0MjE5MTU0NDQzO1xuXG5leHBvcnRzLmF1dGhzZXQgPSBmdW5jdGlvbihlcykge1xuICB2YXIgdDtcbiAgdmFyIEFQQSA9IFtdO1xuICBBUEFbMF0gPSBlcyAqIHRoaXMuUDAwO1xuICB0ID0gZXMgKiBlcztcbiAgQVBBWzBdICs9IHQgKiB0aGlzLlAwMTtcbiAgQVBBWzFdID0gdCAqIHRoaXMuUDEwO1xuICB0ICo9IGVzO1xuICBBUEFbMF0gKz0gdCAqIHRoaXMuUDAyO1xuICBBUEFbMV0gKz0gdCAqIHRoaXMuUDExO1xuICBBUEFbMl0gPSB0ICogdGhpcy5QMjA7XG4gIHJldHVybiBBUEE7XG59O1xuXG5leHBvcnRzLmF1dGhsYXQgPSBmdW5jdGlvbihiZXRhLCBBUEEpIHtcbiAgdmFyIHQgPSBiZXRhICsgYmV0YTtcbiAgcmV0dXJuIChiZXRhICsgQVBBWzBdICogTWF0aC5zaW4odCkgKyBBUEFbMV0gKiBNYXRoLnNpbih0ICsgdCkgKyBBUEFbMl0gKiBNYXRoLnNpbih0ICsgdCArIHQpKTtcbn07XG5leHBvcnRzLm5hbWVzID0gW1wiTGFtYmVydCBBemltdXRoYWwgRXF1YWwgQXJlYVwiLCBcIkxhbWJlcnRfQXppbXV0aGFsX0VxdWFsX0FyZWFcIiwgXCJsYWVhXCJdO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9sYWVhLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports,__webpack_require__){eval('var EPSLN = 1.0e-10;\nvar msfnz = __webpack_require__(8);\nvar tsfnz = __webpack_require__(22);\nvar HALF_PI = Math.PI/2;\nvar sign = __webpack_require__(17);\nvar adjust_lon = __webpack_require__(0);\nvar phi2z = __webpack_require__(21);\nexports.init = function() {\n\n  // array of:  r_maj,r_min,lat1,lat2,c_lon,c_lat,false_east,false_north\n  //double c_lat;                   /* center latitude                      */\n  //double c_lon;                   /* center longitude                     */\n  //double lat1;                    /* first standard parallel              */\n  //double lat2;                    /* second standard parallel             */\n  //double r_maj;                   /* major axis                           */\n  //double r_min;                   /* minor axis                           */\n  //double false_east;              /* x offset in meters                   */\n  //double false_north;             /* y offset in meters                   */\n\n  if (!this.lat2) {\n    this.lat2 = this.lat1;\n  } //if lat2 is not defined\n  if (!this.k0) {\n    this.k0 = 1;\n  }\n  this.x0 = this.x0 || 0;\n  this.y0 = this.y0 || 0;\n  // Standard Parallels cannot be equal and on opposite sides of the equator\n  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {\n    return;\n  }\n\n  var temp = this.b / this.a;\n  this.e = Math.sqrt(1 - temp * temp);\n\n  var sin1 = Math.sin(this.lat1);\n  var cos1 = Math.cos(this.lat1);\n  var ms1 = msfnz(this.e, sin1, cos1);\n  var ts1 = tsfnz(this.e, this.lat1, sin1);\n\n  var sin2 = Math.sin(this.lat2);\n  var cos2 = Math.cos(this.lat2);\n  var ms2 = msfnz(this.e, sin2, cos2);\n  var ts2 = tsfnz(this.e, this.lat2, sin2);\n\n  var ts0 = tsfnz(this.e, this.lat0, Math.sin(this.lat0));\n\n  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {\n    this.ns = Math.log(ms1 / ms2) / Math.log(ts1 / ts2);\n  }\n  else {\n    this.ns = sin1;\n  }\n  if (isNaN(this.ns)) {\n    this.ns = sin1;\n  }\n  this.f0 = ms1 / (this.ns * Math.pow(ts1, this.ns));\n  this.rh = this.a * this.f0 * Math.pow(ts0, this.ns);\n  if (!this.title) {\n    this.title = "Lambert Conformal Conic";\n  }\n};\n\n\n// Lambert Conformal conic forward equations--mapping lat,long to x,y\n// -----------------------------------------------------------------\nexports.forward = function(p) {\n\n  var lon = p.x;\n  var lat = p.y;\n\n  // singular cases :\n  if (Math.abs(2 * Math.abs(lat) - Math.PI) <= EPSLN) {\n    lat = sign(lat) * (HALF_PI - 2 * EPSLN);\n  }\n\n  var con = Math.abs(Math.abs(lat) - HALF_PI);\n  var ts, rh1;\n  if (con > EPSLN) {\n    ts = tsfnz(this.e, lat, Math.sin(lat));\n    rh1 = this.a * this.f0 * Math.pow(ts, this.ns);\n  }\n  else {\n    con = lat * this.ns;\n    if (con <= 0) {\n      return null;\n    }\n    rh1 = 0;\n  }\n  var theta = this.ns * adjust_lon(lon - this.long0);\n  p.x = this.k0 * (rh1 * Math.sin(theta)) + this.x0;\n  p.y = this.k0 * (this.rh - rh1 * Math.cos(theta)) + this.y0;\n\n  return p;\n};\n\n// Lambert Conformal Conic inverse equations--mapping x,y to lat/long\n// -----------------------------------------------------------------\nexports.inverse = function(p) {\n\n  var rh1, con, ts;\n  var lat, lon;\n  var x = (p.x - this.x0) / this.k0;\n  var y = (this.rh - (p.y - this.y0) / this.k0);\n  if (this.ns > 0) {\n    rh1 = Math.sqrt(x * x + y * y);\n    con = 1;\n  }\n  else {\n    rh1 = -Math.sqrt(x * x + y * y);\n    con = -1;\n  }\n  var theta = 0;\n  if (rh1 !== 0) {\n    theta = Math.atan2((con * x), (con * y));\n  }\n  if ((rh1 !== 0) || (this.ns > 0)) {\n    con = 1 / this.ns;\n    ts = Math.pow((rh1 / (this.a * this.f0)), con);\n    lat = phi2z(this.e, ts);\n    if (lat === -9999) {\n      return null;\n    }\n  }\n  else {\n    lat = -HALF_PI;\n  }\n  lon = adjust_lon(theta / this.ns + this.long0);\n\n  p.x = lon;\n  p.y = lat;\n  return p;\n};\n\nexports.names = ["Lambert Tangential Conformal Conic Projection", "Lambert_Conformal_Conic", "Lambert_Conformal_Conic_2SP", "lcc"];\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9sY2MuanM/NjdkOSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakIsc0JBQXNCO0FBQ3RCLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjE0OC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBFUFNMTiA9IDEuMGUtMTA7XG52YXIgbXNmbnogPSByZXF1aXJlKCcuLi9jb21tb24vbXNmbnonKTtcbnZhciB0c2ZueiA9IHJlcXVpcmUoJy4uL2NvbW1vbi90c2ZueicpO1xudmFyIEhBTEZfUEkgPSBNYXRoLlBJLzI7XG52YXIgc2lnbiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9zaWduJyk7XG52YXIgYWRqdXN0X2xvbiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9hZGp1c3RfbG9uJyk7XG52YXIgcGhpMnogPSByZXF1aXJlKCcuLi9jb21tb24vcGhpMnonKTtcbmV4cG9ydHMuaW5pdCA9IGZ1bmN0aW9uKCkge1xuXG4gIC8vIGFycmF5IG9mOiAgcl9tYWoscl9taW4sbGF0MSxsYXQyLGNfbG9uLGNfbGF0LGZhbHNlX2Vhc3QsZmFsc2Vfbm9ydGhcbiAgLy9kb3VibGUgY19sYXQ7ICAgICAgICAgICAgICAgICAgIC8qIGNlbnRlciBsYXRpdHVkZSAgICAgICAgICAgICAgICAgICAgICAqL1xuICAvL2RvdWJsZSBjX2xvbjsgICAgICAgICAgICAgICAgICAgLyogY2VudGVyIGxvbmdpdHVkZSAgICAgICAgICAgICAgICAgICAgICovXG4gIC8vZG91YmxlIGxhdDE7ICAgICAgICAgICAgICAgICAgICAvKiBmaXJzdCBzdGFuZGFyZCBwYXJhbGxlbCAgICAgICAgICAgICAgKi9cbiAgLy9kb3VibGUgbGF0MjsgICAgICAgICAgICAgICAgICAgIC8qIHNlY29uZCBzdGFuZGFyZCBwYXJhbGxlbCAgICAgICAgICAgICAqL1xuICAvL2RvdWJsZSByX21hajsgICAgICAgICAgICAgICAgICAgLyogbWFqb3IgYXhpcyAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gIC8vZG91YmxlIHJfbWluOyAgICAgICAgICAgICAgICAgICAvKiBtaW5vciBheGlzICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgLy9kb3VibGUgZmFsc2VfZWFzdDsgICAgICAgICAgICAgIC8qIHggb2Zmc2V0IGluIG1ldGVycyAgICAgICAgICAgICAgICAgICAqL1xuICAvL2RvdWJsZSBmYWxzZV9ub3J0aDsgICAgICAgICAgICAgLyogeSBvZmZzZXQgaW4gbWV0ZXJzICAgICAgICAgICAgICAgICAgICovXG5cbiAgaWYgKCF0aGlzLmxhdDIpIHtcbiAgICB0aGlzLmxhdDIgPSB0aGlzLmxhdDE7XG4gIH0gLy9pZiBsYXQyIGlzIG5vdCBkZWZpbmVkXG4gIGlmICghdGhpcy5rMCkge1xuICAgIHRoaXMuazAgPSAxO1xuICB9XG4gIHRoaXMueDAgPSB0aGlzLngwIHx8IDA7XG4gIHRoaXMueTAgPSB0aGlzLnkwIHx8IDA7XG4gIC8vIFN0YW5kYXJkIFBhcmFsbGVscyBjYW5ub3QgYmUgZXF1YWwgYW5kIG9uIG9wcG9zaXRlIHNpZGVzIG9mIHRoZSBlcXVhdG9yXG4gIGlmIChNYXRoLmFicyh0aGlzLmxhdDEgKyB0aGlzLmxhdDIpIDwgRVBTTE4pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgdGVtcCA9IHRoaXMuYiAvIHRoaXMuYTtcbiAgdGhpcy5lID0gTWF0aC5zcXJ0KDEgLSB0ZW1wICogdGVtcCk7XG5cbiAgdmFyIHNpbjEgPSBNYXRoLnNpbih0aGlzLmxhdDEpO1xuICB2YXIgY29zMSA9IE1hdGguY29zKHRoaXMubGF0MSk7XG4gIHZhciBtczEgPSBtc2Zueih0aGlzLmUsIHNpbjEsIGNvczEpO1xuICB2YXIgdHMxID0gdHNmbnoodGhpcy5lLCB0aGlzLmxhdDEsIHNpbjEpO1xuXG4gIHZhciBzaW4yID0gTWF0aC5zaW4odGhpcy5sYXQyKTtcbiAgdmFyIGNvczIgPSBNYXRoLmNvcyh0aGlzLmxhdDIpO1xuICB2YXIgbXMyID0gbXNmbnoodGhpcy5lLCBzaW4yLCBjb3MyKTtcbiAgdmFyIHRzMiA9IHRzZm56KHRoaXMuZSwgdGhpcy5sYXQyLCBzaW4yKTtcblxuICB2YXIgdHMwID0gdHNmbnoodGhpcy5lLCB0aGlzLmxhdDAsIE1hdGguc2luKHRoaXMubGF0MCkpO1xuXG4gIGlmIChNYXRoLmFicyh0aGlzLmxhdDEgLSB0aGlzLmxhdDIpID4gRVBTTE4pIHtcbiAgICB0aGlzLm5zID0gTWF0aC5sb2cobXMxIC8gbXMyKSAvIE1hdGgubG9nKHRzMSAvIHRzMik7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhpcy5ucyA9IHNpbjE7XG4gIH1cbiAgaWYgKGlzTmFOKHRoaXMubnMpKSB7XG4gICAgdGhpcy5ucyA9IHNpbjE7XG4gIH1cbiAgdGhpcy5mMCA9IG1zMSAvICh0aGlzLm5zICogTWF0aC5wb3codHMxLCB0aGlzLm5zKSk7XG4gIHRoaXMucmggPSB0aGlzLmEgKiB0aGlzLmYwICogTWF0aC5wb3codHMwLCB0aGlzLm5zKTtcbiAgaWYgKCF0aGlzLnRpdGxlKSB7XG4gICAgdGhpcy50aXRsZSA9IFwiTGFtYmVydCBDb25mb3JtYWwgQ29uaWNcIjtcbiAgfVxufTtcblxuXG4vLyBMYW1iZXJ0IENvbmZvcm1hbCBjb25pYyBmb3J3YXJkIGVxdWF0aW9ucy0tbWFwcGluZyBsYXQsbG9uZyB0byB4LHlcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5leHBvcnRzLmZvcndhcmQgPSBmdW5jdGlvbihwKSB7XG5cbiAgdmFyIGxvbiA9IHAueDtcbiAgdmFyIGxhdCA9IHAueTtcblxuICAvLyBzaW5ndWxhciBjYXNlcyA6XG4gIGlmIChNYXRoLmFicygyICogTWF0aC5hYnMobGF0KSAtIE1hdGguUEkpIDw9IEVQU0xOKSB7XG4gICAgbGF0ID0gc2lnbihsYXQpICogKEhBTEZfUEkgLSAyICogRVBTTE4pO1xuICB9XG5cbiAgdmFyIGNvbiA9IE1hdGguYWJzKE1hdGguYWJzKGxhdCkgLSBIQUxGX1BJKTtcbiAgdmFyIHRzLCByaDE7XG4gIGlmIChjb24gPiBFUFNMTikge1xuICAgIHRzID0gdHNmbnoodGhpcy5lLCBsYXQsIE1hdGguc2luKGxhdCkpO1xuICAgIHJoMSA9IHRoaXMuYSAqIHRoaXMuZjAgKiBNYXRoLnBvdyh0cywgdGhpcy5ucyk7XG4gIH1cbiAgZWxzZSB7XG4gICAgY29uID0gbGF0ICogdGhpcy5ucztcbiAgICBpZiAoY29uIDw9IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByaDEgPSAwO1xuICB9XG4gIHZhciB0aGV0YSA9IHRoaXMubnMgKiBhZGp1c3RfbG9uKGxvbiAtIHRoaXMubG9uZzApO1xuICBwLnggPSB0aGlzLmswICogKHJoMSAqIE1hdGguc2luKHRoZXRhKSkgKyB0aGlzLngwO1xuICBwLnkgPSB0aGlzLmswICogKHRoaXMucmggLSByaDEgKiBNYXRoLmNvcyh0aGV0YSkpICsgdGhpcy55MDtcblxuICByZXR1cm4gcDtcbn07XG5cbi8vIExhbWJlcnQgQ29uZm9ybWFsIENvbmljIGludmVyc2UgZXF1YXRpb25zLS1tYXBwaW5nIHgseSB0byBsYXQvbG9uZ1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmV4cG9ydHMuaW52ZXJzZSA9IGZ1bmN0aW9uKHApIHtcblxuICB2YXIgcmgxLCBjb24sIHRzO1xuICB2YXIgbGF0LCBsb247XG4gIHZhciB4ID0gKHAueCAtIHRoaXMueDApIC8gdGhpcy5rMDtcbiAgdmFyIHkgPSAodGhpcy5yaCAtIChwLnkgLSB0aGlzLnkwKSAvIHRoaXMuazApO1xuICBpZiAodGhpcy5ucyA+IDApIHtcbiAgICByaDEgPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG4gICAgY29uID0gMTtcbiAgfVxuICBlbHNlIHtcbiAgICByaDEgPSAtTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuICAgIGNvbiA9IC0xO1xuICB9XG4gIHZhciB0aGV0YSA9IDA7XG4gIGlmIChyaDEgIT09IDApIHtcbiAgICB0aGV0YSA9IE1hdGguYXRhbjIoKGNvbiAqIHgpLCAoY29uICogeSkpO1xuICB9XG4gIGlmICgocmgxICE9PSAwKSB8fCAodGhpcy5ucyA+IDApKSB7XG4gICAgY29uID0gMSAvIHRoaXMubnM7XG4gICAgdHMgPSBNYXRoLnBvdygocmgxIC8gKHRoaXMuYSAqIHRoaXMuZjApKSwgY29uKTtcbiAgICBsYXQgPSBwaGkyeih0aGlzLmUsIHRzKTtcbiAgICBpZiAobGF0ID09PSAtOTk5OSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIGxhdCA9IC1IQUxGX1BJO1xuICB9XG4gIGxvbiA9IGFkanVzdF9sb24odGhldGEgLyB0aGlzLm5zICsgdGhpcy5sb25nMCk7XG5cbiAgcC54ID0gbG9uO1xuICBwLnkgPSBsYXQ7XG4gIHJldHVybiBwO1xufTtcblxuZXhwb3J0cy5uYW1lcyA9IFtcIkxhbWJlcnQgVGFuZ2VudGlhbCBDb25mb3JtYWwgQ29uaWMgUHJvamVjdGlvblwiLCBcIkxhbWJlcnRfQ29uZm9ybWFsX0NvbmljXCIsIFwiTGFtYmVydF9Db25mb3JtYWxfQ29uaWNfMlNQXCIsIFwibGNjXCJdO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9sY2MuanNcbi8vIG1vZHVsZSBpZCA9IDE0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9')},function(module,exports){eval('exports.init = function() {\n  //no-op for longlat\n};\n\nfunction identity(pt) {\n  return pt;\n}\nexports.forward = identity;\nexports.inverse = identity;\nexports.names = ["longlat", "identity"];\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9sb25nbGF0LmpzP2FhMGMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxNDkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgLy9uby1vcCBmb3IgbG9uZ2xhdFxufTtcblxuZnVuY3Rpb24gaWRlbnRpdHkocHQpIHtcbiAgcmV0dXJuIHB0O1xufVxuZXhwb3J0cy5mb3J3YXJkID0gaWRlbnRpdHk7XG5leHBvcnRzLmludmVyc2UgPSBpZGVudGl0eTtcbmV4cG9ydHMubmFtZXMgPSBbXCJsb25nbGF0XCIsIFwiaWRlbnRpdHlcIl07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHJvajQvbGliL3Byb2plY3Rpb25zL2xvbmdsYXQuanNcbi8vIG1vZHVsZSBpZCA9IDE0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9')},function(module,exports,__webpack_require__){eval('var msfnz = __webpack_require__(8);\nvar HALF_PI = Math.PI/2;\nvar EPSLN = 1.0e-10;\nvar R2D = 57.29577951308232088;\nvar adjust_lon = __webpack_require__(0);\nvar FORTPI = Math.PI/4;\nvar tsfnz = __webpack_require__(22);\nvar phi2z = __webpack_require__(21);\nexports.init = function() {\n  var con = this.b / this.a;\n  this.es = 1 - con * con;\n  if(!(\'x0\' in this)){\n    this.x0 = 0;\n  }\n  if(!(\'y0\' in this)){\n    this.y0 = 0;\n  }\n  this.e = Math.sqrt(this.es);\n  if (this.lat_ts) {\n    if (this.sphere) {\n      this.k0 = Math.cos(this.lat_ts);\n    }\n    else {\n      this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));\n    }\n  }\n  else {\n    if (!this.k0) {\n      if (this.k) {\n        this.k0 = this.k;\n      }\n      else {\n        this.k0 = 1;\n      }\n    }\n  }\n};\n\n/* Mercator forward equations--mapping lat,long to x,y\n  --------------------------------------------------*/\n\nexports.forward = function(p) {\n  var lon = p.x;\n  var lat = p.y;\n  // convert to radians\n  if (lat * R2D > 90 && lat * R2D < -90 && lon * R2D > 180 && lon * R2D < -180) {\n    return null;\n  }\n\n  var x, y;\n  if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {\n    return null;\n  }\n  else {\n    if (this.sphere) {\n      x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);\n      y = this.y0 + this.a * this.k0 * Math.log(Math.tan(FORTPI + 0.5 * lat));\n    }\n    else {\n      var sinphi = Math.sin(lat);\n      var ts = tsfnz(this.e, lat, sinphi);\n      x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);\n      y = this.y0 - this.a * this.k0 * Math.log(ts);\n    }\n    p.x = x;\n    p.y = y;\n    return p;\n  }\n};\n\n\n/* Mercator inverse equations--mapping x,y to lat/long\n  --------------------------------------------------*/\nexports.inverse = function(p) {\n\n  var x = p.x - this.x0;\n  var y = p.y - this.y0;\n  var lon, lat;\n\n  if (this.sphere) {\n    lat = HALF_PI - 2 * Math.atan(Math.exp(-y / (this.a * this.k0)));\n  }\n  else {\n    var ts = Math.exp(-y / (this.a * this.k0));\n    lat = phi2z(this.e, ts);\n    if (lat === -9999) {\n      return null;\n    }\n  }\n  lon = adjust_lon(this.long0 + x / (this.a * this.k0));\n\n  p.x = lon;\n  p.y = lat;\n  return p;\n};\n\nexports.names = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"];\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9tZXJjLmpzPzQ3ZmUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMTUwLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIG1zZm56ID0gcmVxdWlyZSgnLi4vY29tbW9uL21zZm56Jyk7XG52YXIgSEFMRl9QSSA9IE1hdGguUEkvMjtcbnZhciBFUFNMTiA9IDEuMGUtMTA7XG52YXIgUjJEID0gNTcuMjk1Nzc5NTEzMDgyMzIwODg7XG52YXIgYWRqdXN0X2xvbiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9hZGp1c3RfbG9uJyk7XG52YXIgRk9SVFBJID0gTWF0aC5QSS80O1xudmFyIHRzZm56ID0gcmVxdWlyZSgnLi4vY29tbW9uL3RzZm56Jyk7XG52YXIgcGhpMnogPSByZXF1aXJlKCcuLi9jb21tb24vcGhpMnonKTtcbmV4cG9ydHMuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY29uID0gdGhpcy5iIC8gdGhpcy5hO1xuICB0aGlzLmVzID0gMSAtIGNvbiAqIGNvbjtcbiAgaWYoISgneDAnIGluIHRoaXMpKXtcbiAgICB0aGlzLngwID0gMDtcbiAgfVxuICBpZighKCd5MCcgaW4gdGhpcykpe1xuICAgIHRoaXMueTAgPSAwO1xuICB9XG4gIHRoaXMuZSA9IE1hdGguc3FydCh0aGlzLmVzKTtcbiAgaWYgKHRoaXMubGF0X3RzKSB7XG4gICAgaWYgKHRoaXMuc3BoZXJlKSB7XG4gICAgICB0aGlzLmswID0gTWF0aC5jb3ModGhpcy5sYXRfdHMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuazAgPSBtc2Zueih0aGlzLmUsIE1hdGguc2luKHRoaXMubGF0X3RzKSwgTWF0aC5jb3ModGhpcy5sYXRfdHMpKTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgaWYgKCF0aGlzLmswKSB7XG4gICAgICBpZiAodGhpcy5rKSB7XG4gICAgICAgIHRoaXMuazAgPSB0aGlzLms7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5rMCA9IDE7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKiBNZXJjYXRvciBmb3J3YXJkIGVxdWF0aW9ucy0tbWFwcGluZyBsYXQsbG9uZyB0byB4LHlcbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5leHBvcnRzLmZvcndhcmQgPSBmdW5jdGlvbihwKSB7XG4gIHZhciBsb24gPSBwLng7XG4gIHZhciBsYXQgPSBwLnk7XG4gIC8vIGNvbnZlcnQgdG8gcmFkaWFuc1xuICBpZiAobGF0ICogUjJEID4gOTAgJiYgbGF0ICogUjJEIDwgLTkwICYmIGxvbiAqIFIyRCA+IDE4MCAmJiBsb24gKiBSMkQgPCAtMTgwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgeCwgeTtcbiAgaWYgKE1hdGguYWJzKE1hdGguYWJzKGxhdCkgLSBIQUxGX1BJKSA8PSBFUFNMTikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGVsc2Uge1xuICAgIGlmICh0aGlzLnNwaGVyZSkge1xuICAgICAgeCA9IHRoaXMueDAgKyB0aGlzLmEgKiB0aGlzLmswICogYWRqdXN0X2xvbihsb24gLSB0aGlzLmxvbmcwKTtcbiAgICAgIHkgPSB0aGlzLnkwICsgdGhpcy5hICogdGhpcy5rMCAqIE1hdGgubG9nKE1hdGgudGFuKEZPUlRQSSArIDAuNSAqIGxhdCkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBzaW5waGkgPSBNYXRoLnNpbihsYXQpO1xuICAgICAgdmFyIHRzID0gdHNmbnoodGhpcy5lLCBsYXQsIHNpbnBoaSk7XG4gICAgICB4ID0gdGhpcy54MCArIHRoaXMuYSAqIHRoaXMuazAgKiBhZGp1c3RfbG9uKGxvbiAtIHRoaXMubG9uZzApO1xuICAgICAgeSA9IHRoaXMueTAgLSB0aGlzLmEgKiB0aGlzLmswICogTWF0aC5sb2codHMpO1xuICAgIH1cbiAgICBwLnggPSB4O1xuICAgIHAueSA9IHk7XG4gICAgcmV0dXJuIHA7XG4gIH1cbn07XG5cblxuLyogTWVyY2F0b3IgaW52ZXJzZSBlcXVhdGlvbnMtLW1hcHBpbmcgeCx5IHRvIGxhdC9sb25nXG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmV4cG9ydHMuaW52ZXJzZSA9IGZ1bmN0aW9uKHApIHtcblxuICB2YXIgeCA9IHAueCAtIHRoaXMueDA7XG4gIHZhciB5ID0gcC55IC0gdGhpcy55MDtcbiAgdmFyIGxvbiwgbGF0O1xuXG4gIGlmICh0aGlzLnNwaGVyZSkge1xuICAgIGxhdCA9IEhBTEZfUEkgLSAyICogTWF0aC5hdGFuKE1hdGguZXhwKC15IC8gKHRoaXMuYSAqIHRoaXMuazApKSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdmFyIHRzID0gTWF0aC5leHAoLXkgLyAodGhpcy5hICogdGhpcy5rMCkpO1xuICAgIGxhdCA9IHBoaTJ6KHRoaXMuZSwgdHMpO1xuICAgIGlmIChsYXQgPT09IC05OTk5KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgbG9uID0gYWRqdXN0X2xvbih0aGlzLmxvbmcwICsgeCAvICh0aGlzLmEgKiB0aGlzLmswKSk7XG5cbiAgcC54ID0gbG9uO1xuICBwLnkgPSBsYXQ7XG4gIHJldHVybiBwO1xufTtcblxuZXhwb3J0cy5uYW1lcyA9IFtcIk1lcmNhdG9yXCIsIFwiUG9wdWxhciBWaXN1YWxpc2F0aW9uIFBzZXVkbyBNZXJjYXRvclwiLCBcIk1lcmNhdG9yXzFTUFwiLCBcIk1lcmNhdG9yX0F1eGlsaWFyeV9TcGhlcmVcIiwgXCJtZXJjXCJdO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9tZXJjLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports,__webpack_require__){eval('var adjust_lon = __webpack_require__(0);\n/*\n  reference\n    "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,\n    The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.\n  */\n\n\n/* Initialize the Miller Cylindrical projection\n  -------------------------------------------*/\nexports.init = function() {\n  //no-op\n};\n\n\n/* Miller Cylindrical forward equations--mapping lat,long to x,y\n    ------------------------------------------------------------*/\nexports.forward = function(p) {\n  var lon = p.x;\n  var lat = p.y;\n  /* Forward equations\n      -----------------*/\n  var dlon = adjust_lon(lon - this.long0);\n  var x = this.x0 + this.a * dlon;\n  var y = this.y0 + this.a * Math.log(Math.tan((Math.PI / 4) + (lat / 2.5))) * 1.25;\n\n  p.x = x;\n  p.y = y;\n  return p;\n};\n\n/* Miller Cylindrical inverse equations--mapping x,y to lat/long\n    ------------------------------------------------------------*/\nexports.inverse = function(p) {\n  p.x -= this.x0;\n  p.y -= this.y0;\n\n  var lon = adjust_lon(this.long0 + p.x / this.a);\n  var lat = 2.5 * (Math.atan(Math.exp(0.8 * p.y / this.a)) - Math.PI / 4);\n\n  p.x = lon;\n  p.y = lat;\n  return p;\n};\nexports.names = ["Miller_Cylindrical", "mill"];\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9taWxsLmpzPzBjZGMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxNTEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYWRqdXN0X2xvbiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9hZGp1c3RfbG9uJyk7XG4vKlxuICByZWZlcmVuY2VcbiAgICBcIk5ldyBFcXVhbC1BcmVhIE1hcCBQcm9qZWN0aW9ucyBmb3IgTm9uY2lyY3VsYXIgUmVnaW9uc1wiLCBKb2huIFAuIFNueWRlcixcbiAgICBUaGUgQW1lcmljYW4gQ2FydG9ncmFwaGVyLCBWb2wgMTUsIE5vLiA0LCBPY3RvYmVyIDE5ODgsIHBwLiAzNDEtMzU1LlxuICAqL1xuXG5cbi8qIEluaXRpYWxpemUgdGhlIE1pbGxlciBDeWxpbmRyaWNhbCBwcm9qZWN0aW9uXG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZXhwb3J0cy5pbml0ID0gZnVuY3Rpb24oKSB7XG4gIC8vbm8tb3Bcbn07XG5cblxuLyogTWlsbGVyIEN5bGluZHJpY2FsIGZvcndhcmQgZXF1YXRpb25zLS1tYXBwaW5nIGxhdCxsb25nIHRvIHgseVxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnRzLmZvcndhcmQgPSBmdW5jdGlvbihwKSB7XG4gIHZhciBsb24gPSBwLng7XG4gIHZhciBsYXQgPSBwLnk7XG4gIC8qIEZvcndhcmQgZXF1YXRpb25zXG4gICAgICAtLS0tLS0tLS0tLS0tLS0tLSovXG4gIHZhciBkbG9uID0gYWRqdXN0X2xvbihsb24gLSB0aGlzLmxvbmcwKTtcbiAgdmFyIHggPSB0aGlzLngwICsgdGhpcy5hICogZGxvbjtcbiAgdmFyIHkgPSB0aGlzLnkwICsgdGhpcy5hICogTWF0aC5sb2coTWF0aC50YW4oKE1hdGguUEkgLyA0KSArIChsYXQgLyAyLjUpKSkgKiAxLjI1O1xuXG4gIHAueCA9IHg7XG4gIHAueSA9IHk7XG4gIHJldHVybiBwO1xufTtcblxuLyogTWlsbGVyIEN5bGluZHJpY2FsIGludmVyc2UgZXF1YXRpb25zLS1tYXBwaW5nIHgseSB0byBsYXQvbG9uZ1xuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnRzLmludmVyc2UgPSBmdW5jdGlvbihwKSB7XG4gIHAueCAtPSB0aGlzLngwO1xuICBwLnkgLT0gdGhpcy55MDtcblxuICB2YXIgbG9uID0gYWRqdXN0X2xvbih0aGlzLmxvbmcwICsgcC54IC8gdGhpcy5hKTtcbiAgdmFyIGxhdCA9IDIuNSAqIChNYXRoLmF0YW4oTWF0aC5leHAoMC44ICogcC55IC8gdGhpcy5hKSkgLSBNYXRoLlBJIC8gNCk7XG5cbiAgcC54ID0gbG9uO1xuICBwLnkgPSBsYXQ7XG4gIHJldHVybiBwO1xufTtcbmV4cG9ydHMubmFtZXMgPSBbXCJNaWxsZXJfQ3lsaW5kcmljYWxcIiwgXCJtaWxsXCJdO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9taWxsLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports,__webpack_require__){eval('var adjust_lon = __webpack_require__(0);\nvar EPSLN = 1.0e-10;\nexports.init = function() {};\n\n/* Mollweide forward equations--mapping lat,long to x,y\n    ----------------------------------------------------*/\nexports.forward = function(p) {\n\n  /* Forward equations\n      -----------------*/\n  var lon = p.x;\n  var lat = p.y;\n\n  var delta_lon = adjust_lon(lon - this.long0);\n  var theta = lat;\n  var con = Math.PI * Math.sin(lat);\n\n  /* Iterate using the Newton-Raphson method to find theta\n      -----------------------------------------------------*/\n  for (var i = 0; true; i++) {\n    var delta_theta = -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));\n    theta += delta_theta;\n    if (Math.abs(delta_theta) < EPSLN) {\n      break;\n    }\n  }\n  theta /= 2;\n\n  /* If the latitude is 90 deg, force the x coordinate to be "0 + false easting"\n       this is done here because of precision problems with "cos(theta)"\n       --------------------------------------------------------------------------*/\n  if (Math.PI / 2 - Math.abs(lat) < EPSLN) {\n    delta_lon = 0;\n  }\n  var x = 0.900316316158 * this.a * delta_lon * Math.cos(theta) + this.x0;\n  var y = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;\n\n  p.x = x;\n  p.y = y;\n  return p;\n};\n\nexports.inverse = function(p) {\n  var theta;\n  var arg;\n\n  /* Inverse equations\n      -----------------*/\n  p.x -= this.x0;\n  p.y -= this.y0;\n  arg = p.y / (1.4142135623731 * this.a);\n\n  /* Because of division by zero problems, \'arg\' can not be 1.  Therefore\n       a number very close to one is used instead.\n       -------------------------------------------------------------------*/\n  if (Math.abs(arg) > 0.999999999999) {\n    arg = 0.999999999999;\n  }\n  theta = Math.asin(arg);\n  var lon = adjust_lon(this.long0 + (p.x / (0.900316316158 * this.a * Math.cos(theta))));\n  if (lon < (-Math.PI)) {\n    lon = -Math.PI;\n  }\n  if (lon > Math.PI) {\n    lon = Math.PI;\n  }\n  arg = (2 * theta + Math.sin(2 * theta)) / Math.PI;\n  if (Math.abs(arg) > 1) {\n    arg = 1;\n  }\n  var lat = Math.asin(arg);\n\n  p.x = lon;\n  p.y = lat;\n  return p;\n};\nexports.names = ["Mollweide", "moll"];\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9tb2xsLmpzPzVhMzgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxNTIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYWRqdXN0X2xvbiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9hZGp1c3RfbG9uJyk7XG52YXIgRVBTTE4gPSAxLjBlLTEwO1xuZXhwb3J0cy5pbml0ID0gZnVuY3Rpb24oKSB7fTtcblxuLyogTW9sbHdlaWRlIGZvcndhcmQgZXF1YXRpb25zLS1tYXBwaW5nIGxhdCxsb25nIHRvIHgseVxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZXhwb3J0cy5mb3J3YXJkID0gZnVuY3Rpb24ocCkge1xuXG4gIC8qIEZvcndhcmQgZXF1YXRpb25zXG4gICAgICAtLS0tLS0tLS0tLS0tLS0tLSovXG4gIHZhciBsb24gPSBwLng7XG4gIHZhciBsYXQgPSBwLnk7XG5cbiAgdmFyIGRlbHRhX2xvbiA9IGFkanVzdF9sb24obG9uIC0gdGhpcy5sb25nMCk7XG4gIHZhciB0aGV0YSA9IGxhdDtcbiAgdmFyIGNvbiA9IE1hdGguUEkgKiBNYXRoLnNpbihsYXQpO1xuXG4gIC8qIEl0ZXJhdGUgdXNpbmcgdGhlIE5ld3Rvbi1SYXBoc29uIG1ldGhvZCB0byBmaW5kIHRoZXRhXG4gICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4gIGZvciAodmFyIGkgPSAwOyB0cnVlOyBpKyspIHtcbiAgICB2YXIgZGVsdGFfdGhldGEgPSAtKHRoZXRhICsgTWF0aC5zaW4odGhldGEpIC0gY29uKSAvICgxICsgTWF0aC5jb3ModGhldGEpKTtcbiAgICB0aGV0YSArPSBkZWx0YV90aGV0YTtcbiAgICBpZiAoTWF0aC5hYnMoZGVsdGFfdGhldGEpIDwgRVBTTE4pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICB0aGV0YSAvPSAyO1xuXG4gIC8qIElmIHRoZSBsYXRpdHVkZSBpcyA5MCBkZWcsIGZvcmNlIHRoZSB4IGNvb3JkaW5hdGUgdG8gYmUgXCIwICsgZmFsc2UgZWFzdGluZ1wiXG4gICAgICAgdGhpcyBpcyBkb25lIGhlcmUgYmVjYXVzZSBvZiBwcmVjaXNpb24gcHJvYmxlbXMgd2l0aCBcImNvcyh0aGV0YSlcIlxuICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgaWYgKE1hdGguUEkgLyAyIC0gTWF0aC5hYnMobGF0KSA8IEVQU0xOKSB7XG4gICAgZGVsdGFfbG9uID0gMDtcbiAgfVxuICB2YXIgeCA9IDAuOTAwMzE2MzE2MTU4ICogdGhpcy5hICogZGVsdGFfbG9uICogTWF0aC5jb3ModGhldGEpICsgdGhpcy54MDtcbiAgdmFyIHkgPSAxLjQxNDIxMzU2MjM3MzEgKiB0aGlzLmEgKiBNYXRoLnNpbih0aGV0YSkgKyB0aGlzLnkwO1xuXG4gIHAueCA9IHg7XG4gIHAueSA9IHk7XG4gIHJldHVybiBwO1xufTtcblxuZXhwb3J0cy5pbnZlcnNlID0gZnVuY3Rpb24ocCkge1xuICB2YXIgdGhldGE7XG4gIHZhciBhcmc7XG5cbiAgLyogSW52ZXJzZSBlcXVhdGlvbnNcbiAgICAgIC0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgcC54IC09IHRoaXMueDA7XG4gIHAueSAtPSB0aGlzLnkwO1xuICBhcmcgPSBwLnkgLyAoMS40MTQyMTM1NjIzNzMxICogdGhpcy5hKTtcblxuICAvKiBCZWNhdXNlIG9mIGRpdmlzaW9uIGJ5IHplcm8gcHJvYmxlbXMsICdhcmcnIGNhbiBub3QgYmUgMS4gIFRoZXJlZm9yZVxuICAgICAgIGEgbnVtYmVyIHZlcnkgY2xvc2UgdG8gb25lIGlzIHVzZWQgaW5zdGVhZC5cbiAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgaWYgKE1hdGguYWJzKGFyZykgPiAwLjk5OTk5OTk5OTk5OSkge1xuICAgIGFyZyA9IDAuOTk5OTk5OTk5OTk5O1xuICB9XG4gIHRoZXRhID0gTWF0aC5hc2luKGFyZyk7XG4gIHZhciBsb24gPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgKyAocC54IC8gKDAuOTAwMzE2MzE2MTU4ICogdGhpcy5hICogTWF0aC5jb3ModGhldGEpKSkpO1xuICBpZiAobG9uIDwgKC1NYXRoLlBJKSkge1xuICAgIGxvbiA9IC1NYXRoLlBJO1xuICB9XG4gIGlmIChsb24gPiBNYXRoLlBJKSB7XG4gICAgbG9uID0gTWF0aC5QSTtcbiAgfVxuICBhcmcgPSAoMiAqIHRoZXRhICsgTWF0aC5zaW4oMiAqIHRoZXRhKSkgLyBNYXRoLlBJO1xuICBpZiAoTWF0aC5hYnMoYXJnKSA+IDEpIHtcbiAgICBhcmcgPSAxO1xuICB9XG4gIHZhciBsYXQgPSBNYXRoLmFzaW4oYXJnKTtcblxuICBwLnggPSBsb247XG4gIHAueSA9IGxhdDtcbiAgcmV0dXJuIHA7XG59O1xuZXhwb3J0cy5uYW1lcyA9IFtcIk1vbGx3ZWlkZVwiLCBcIm1vbGxcIl07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHJvajQvbGliL3Byb2plY3Rpb25zL21vbGwuanNcbi8vIG1vZHVsZSBpZCA9IDE1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9')},function(module,exports){eval('var SEC_TO_RAD = 4.84813681109535993589914102357e-6;\n/*\n  reference\n    Department of Land and Survey Technical Circular 1973/32\n      http://www.linz.govt.nz/docs/miscellaneous/nz-map-definition.pdf\n    OSG Technical Report 4.1\n      http://www.linz.govt.nz/docs/miscellaneous/nzmg.pdf\n  */\n\n/**\n * iterations: Number of iterations to refine inverse transform.\n *     0 -> km accuracy\n *     1 -> m accuracy -- suitable for most mapping applications\n *     2 -> mm accuracy\n */\nexports.iterations = 1;\n\nexports.init = function() {\n  this.A = [];\n  this.A[1] = 0.6399175073;\n  this.A[2] = -0.1358797613;\n  this.A[3] = 0.063294409;\n  this.A[4] = -0.02526853;\n  this.A[5] = 0.0117879;\n  this.A[6] = -0.0055161;\n  this.A[7] = 0.0026906;\n  this.A[8] = -0.001333;\n  this.A[9] = 0.00067;\n  this.A[10] = -0.00034;\n\n  this.B_re = [];\n  this.B_im = [];\n  this.B_re[1] = 0.7557853228;\n  this.B_im[1] = 0;\n  this.B_re[2] = 0.249204646;\n  this.B_im[2] = 0.003371507;\n  this.B_re[3] = -0.001541739;\n  this.B_im[3] = 0.041058560;\n  this.B_re[4] = -0.10162907;\n  this.B_im[4] = 0.01727609;\n  this.B_re[5] = -0.26623489;\n  this.B_im[5] = -0.36249218;\n  this.B_re[6] = -0.6870983;\n  this.B_im[6] = -1.1651967;\n\n  this.C_re = [];\n  this.C_im = [];\n  this.C_re[1] = 1.3231270439;\n  this.C_im[1] = 0;\n  this.C_re[2] = -0.577245789;\n  this.C_im[2] = -0.007809598;\n  this.C_re[3] = 0.508307513;\n  this.C_im[3] = -0.112208952;\n  this.C_re[4] = -0.15094762;\n  this.C_im[4] = 0.18200602;\n  this.C_re[5] = 1.01418179;\n  this.C_im[5] = 1.64497696;\n  this.C_re[6] = 1.9660549;\n  this.C_im[6] = 2.5127645;\n\n  this.D = [];\n  this.D[1] = 1.5627014243;\n  this.D[2] = 0.5185406398;\n  this.D[3] = -0.03333098;\n  this.D[4] = -0.1052906;\n  this.D[5] = -0.0368594;\n  this.D[6] = 0.007317;\n  this.D[7] = 0.01220;\n  this.D[8] = 0.00394;\n  this.D[9] = -0.0013;\n};\n\n/**\n    New Zealand Map Grid Forward  - long/lat to x/y\n    long/lat in radians\n  */\nexports.forward = function(p) {\n  var n;\n  var lon = p.x;\n  var lat = p.y;\n\n  var delta_lat = lat - this.lat0;\n  var delta_lon = lon - this.long0;\n\n  // 1. Calculate d_phi and d_psi    ...                          // and d_lambda\n  // For this algorithm, delta_latitude is in seconds of arc x 10-5, so we need to scale to those units. Longitude is radians.\n  var d_phi = delta_lat / SEC_TO_RAD * 1E-5;\n  var d_lambda = delta_lon;\n  var d_phi_n = 1; // d_phi^0\n\n  var d_psi = 0;\n  for (n = 1; n <= 10; n++) {\n    d_phi_n = d_phi_n * d_phi;\n    d_psi = d_psi + this.A[n] * d_phi_n;\n  }\n\n  // 2. Calculate theta\n  var th_re = d_psi;\n  var th_im = d_lambda;\n\n  // 3. Calculate z\n  var th_n_re = 1;\n  var th_n_im = 0; // theta^0\n  var th_n_re1;\n  var th_n_im1;\n\n  var z_re = 0;\n  var z_im = 0;\n  for (n = 1; n <= 6; n++) {\n    th_n_re1 = th_n_re * th_re - th_n_im * th_im;\n    th_n_im1 = th_n_im * th_re + th_n_re * th_im;\n    th_n_re = th_n_re1;\n    th_n_im = th_n_im1;\n    z_re = z_re + this.B_re[n] * th_n_re - this.B_im[n] * th_n_im;\n    z_im = z_im + this.B_im[n] * th_n_re + this.B_re[n] * th_n_im;\n  }\n\n  // 4. Calculate easting and northing\n  p.x = (z_im * this.a) + this.x0;\n  p.y = (z_re * this.a) + this.y0;\n\n  return p;\n};\n\n\n/**\n    New Zealand Map Grid Inverse  -  x/y to long/lat\n  */\nexports.inverse = function(p) {\n  var n;\n  var x = p.x;\n  var y = p.y;\n\n  var delta_x = x - this.x0;\n  var delta_y = y - this.y0;\n\n  // 1. Calculate z\n  var z_re = delta_y / this.a;\n  var z_im = delta_x / this.a;\n\n  // 2a. Calculate theta - first approximation gives km accuracy\n  var z_n_re = 1;\n  var z_n_im = 0; // z^0\n  var z_n_re1;\n  var z_n_im1;\n\n  var th_re = 0;\n  var th_im = 0;\n  for (n = 1; n <= 6; n++) {\n    z_n_re1 = z_n_re * z_re - z_n_im * z_im;\n    z_n_im1 = z_n_im * z_re + z_n_re * z_im;\n    z_n_re = z_n_re1;\n    z_n_im = z_n_im1;\n    th_re = th_re + this.C_re[n] * z_n_re - this.C_im[n] * z_n_im;\n    th_im = th_im + this.C_im[n] * z_n_re + this.C_re[n] * z_n_im;\n  }\n\n  // 2b. Iterate to refine the accuracy of the calculation\n  //        0 iterations gives km accuracy\n  //        1 iteration gives m accuracy -- good enough for most mapping applications\n  //        2 iterations bives mm accuracy\n  for (var i = 0; i < this.iterations; i++) {\n    var th_n_re = th_re;\n    var th_n_im = th_im;\n    var th_n_re1;\n    var th_n_im1;\n\n    var num_re = z_re;\n    var num_im = z_im;\n    for (n = 2; n <= 6; n++) {\n      th_n_re1 = th_n_re * th_re - th_n_im * th_im;\n      th_n_im1 = th_n_im * th_re + th_n_re * th_im;\n      th_n_re = th_n_re1;\n      th_n_im = th_n_im1;\n      num_re = num_re + (n - 1) * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);\n      num_im = num_im + (n - 1) * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);\n    }\n\n    th_n_re = 1;\n    th_n_im = 0;\n    var den_re = this.B_re[1];\n    var den_im = this.B_im[1];\n    for (n = 2; n <= 6; n++) {\n      th_n_re1 = th_n_re * th_re - th_n_im * th_im;\n      th_n_im1 = th_n_im * th_re + th_n_re * th_im;\n      th_n_re = th_n_re1;\n      th_n_im = th_n_im1;\n      den_re = den_re + n * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);\n      den_im = den_im + n * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);\n    }\n\n    // Complex division\n    var den2 = den_re * den_re + den_im * den_im;\n    th_re = (num_re * den_re + num_im * den_im) / den2;\n    th_im = (num_im * den_re - num_re * den_im) / den2;\n  }\n\n  // 3. Calculate d_phi              ...                                    // and d_lambda\n  var d_psi = th_re;\n  var d_lambda = th_im;\n  var d_psi_n = 1; // d_psi^0\n\n  var d_phi = 0;\n  for (n = 1; n <= 9; n++) {\n    d_psi_n = d_psi_n * d_psi;\n    d_phi = d_phi + this.D[n] * d_psi_n;\n  }\n\n  // 4. Calculate latitude and longitude\n  // d_phi is calcuated in second of arc * 10^-5, so we need to scale back to radians. d_lambda is in radians.\n  var lat = this.lat0 + (d_phi * SEC_TO_RAD * 1E5);\n  var lon = this.long0 + d_lambda;\n\n  p.x = lon;\n  p.y = lat;\n\n  return p;\n};\nexports.names = ["New_Zealand_Map_Grid", "nzmg"];//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9uem1nLmpzPzNmNmIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixxQkFBcUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwiZmlsZSI6IjE1My5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBTRUNfVE9fUkFEID0gNC44NDgxMzY4MTEwOTUzNTk5MzU4OTkxNDEwMjM1N2UtNjtcbi8qXG4gIHJlZmVyZW5jZVxuICAgIERlcGFydG1lbnQgb2YgTGFuZCBhbmQgU3VydmV5IFRlY2huaWNhbCBDaXJjdWxhciAxOTczLzMyXG4gICAgICBodHRwOi8vd3d3LmxpbnouZ292dC5uei9kb2NzL21pc2NlbGxhbmVvdXMvbnotbWFwLWRlZmluaXRpb24ucGRmXG4gICAgT1NHIFRlY2huaWNhbCBSZXBvcnQgNC4xXG4gICAgICBodHRwOi8vd3d3LmxpbnouZ292dC5uei9kb2NzL21pc2NlbGxhbmVvdXMvbnptZy5wZGZcbiAgKi9cblxuLyoqXG4gKiBpdGVyYXRpb25zOiBOdW1iZXIgb2YgaXRlcmF0aW9ucyB0byByZWZpbmUgaW52ZXJzZSB0cmFuc2Zvcm0uXG4gKiAgICAgMCAtPiBrbSBhY2N1cmFjeVxuICogICAgIDEgLT4gbSBhY2N1cmFjeSAtLSBzdWl0YWJsZSBmb3IgbW9zdCBtYXBwaW5nIGFwcGxpY2F0aW9uc1xuICogICAgIDIgLT4gbW0gYWNjdXJhY3lcbiAqL1xuZXhwb3J0cy5pdGVyYXRpb25zID0gMTtcblxuZXhwb3J0cy5pbml0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuQSA9IFtdO1xuICB0aGlzLkFbMV0gPSAwLjYzOTkxNzUwNzM7XG4gIHRoaXMuQVsyXSA9IC0wLjEzNTg3OTc2MTM7XG4gIHRoaXMuQVszXSA9IDAuMDYzMjk0NDA5O1xuICB0aGlzLkFbNF0gPSAtMC4wMjUyNjg1MztcbiAgdGhpcy5BWzVdID0gMC4wMTE3ODc5O1xuICB0aGlzLkFbNl0gPSAtMC4wMDU1MTYxO1xuICB0aGlzLkFbN10gPSAwLjAwMjY5MDY7XG4gIHRoaXMuQVs4XSA9IC0wLjAwMTMzMztcbiAgdGhpcy5BWzldID0gMC4wMDA2NztcbiAgdGhpcy5BWzEwXSA9IC0wLjAwMDM0O1xuXG4gIHRoaXMuQl9yZSA9IFtdO1xuICB0aGlzLkJfaW0gPSBbXTtcbiAgdGhpcy5CX3JlWzFdID0gMC43NTU3ODUzMjI4O1xuICB0aGlzLkJfaW1bMV0gPSAwO1xuICB0aGlzLkJfcmVbMl0gPSAwLjI0OTIwNDY0NjtcbiAgdGhpcy5CX2ltWzJdID0gMC4wMDMzNzE1MDc7XG4gIHRoaXMuQl9yZVszXSA9IC0wLjAwMTU0MTczOTtcbiAgdGhpcy5CX2ltWzNdID0gMC4wNDEwNTg1NjA7XG4gIHRoaXMuQl9yZVs0XSA9IC0wLjEwMTYyOTA3O1xuICB0aGlzLkJfaW1bNF0gPSAwLjAxNzI3NjA5O1xuICB0aGlzLkJfcmVbNV0gPSAtMC4yNjYyMzQ4OTtcbiAgdGhpcy5CX2ltWzVdID0gLTAuMzYyNDkyMTg7XG4gIHRoaXMuQl9yZVs2XSA9IC0wLjY4NzA5ODM7XG4gIHRoaXMuQl9pbVs2XSA9IC0xLjE2NTE5Njc7XG5cbiAgdGhpcy5DX3JlID0gW107XG4gIHRoaXMuQ19pbSA9IFtdO1xuICB0aGlzLkNfcmVbMV0gPSAxLjMyMzEyNzA0Mzk7XG4gIHRoaXMuQ19pbVsxXSA9IDA7XG4gIHRoaXMuQ19yZVsyXSA9IC0wLjU3NzI0NTc4OTtcbiAgdGhpcy5DX2ltWzJdID0gLTAuMDA3ODA5NTk4O1xuICB0aGlzLkNfcmVbM10gPSAwLjUwODMwNzUxMztcbiAgdGhpcy5DX2ltWzNdID0gLTAuMTEyMjA4OTUyO1xuICB0aGlzLkNfcmVbNF0gPSAtMC4xNTA5NDc2MjtcbiAgdGhpcy5DX2ltWzRdID0gMC4xODIwMDYwMjtcbiAgdGhpcy5DX3JlWzVdID0gMS4wMTQxODE3OTtcbiAgdGhpcy5DX2ltWzVdID0gMS42NDQ5NzY5NjtcbiAgdGhpcy5DX3JlWzZdID0gMS45NjYwNTQ5O1xuICB0aGlzLkNfaW1bNl0gPSAyLjUxMjc2NDU7XG5cbiAgdGhpcy5EID0gW107XG4gIHRoaXMuRFsxXSA9IDEuNTYyNzAxNDI0MztcbiAgdGhpcy5EWzJdID0gMC41MTg1NDA2Mzk4O1xuICB0aGlzLkRbM10gPSAtMC4wMzMzMzA5ODtcbiAgdGhpcy5EWzRdID0gLTAuMTA1MjkwNjtcbiAgdGhpcy5EWzVdID0gLTAuMDM2ODU5NDtcbiAgdGhpcy5EWzZdID0gMC4wMDczMTc7XG4gIHRoaXMuRFs3XSA9IDAuMDEyMjA7XG4gIHRoaXMuRFs4XSA9IDAuMDAzOTQ7XG4gIHRoaXMuRFs5XSA9IC0wLjAwMTM7XG59O1xuXG4vKipcbiAgICBOZXcgWmVhbGFuZCBNYXAgR3JpZCBGb3J3YXJkICAtIGxvbmcvbGF0IHRvIHgveVxuICAgIGxvbmcvbGF0IGluIHJhZGlhbnNcbiAgKi9cbmV4cG9ydHMuZm9yd2FyZCA9IGZ1bmN0aW9uKHApIHtcbiAgdmFyIG47XG4gIHZhciBsb24gPSBwLng7XG4gIHZhciBsYXQgPSBwLnk7XG5cbiAgdmFyIGRlbHRhX2xhdCA9IGxhdCAtIHRoaXMubGF0MDtcbiAgdmFyIGRlbHRhX2xvbiA9IGxvbiAtIHRoaXMubG9uZzA7XG5cbiAgLy8gMS4gQ2FsY3VsYXRlIGRfcGhpIGFuZCBkX3BzaSAgICAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCBkX2xhbWJkYVxuICAvLyBGb3IgdGhpcyBhbGdvcml0aG0sIGRlbHRhX2xhdGl0dWRlIGlzIGluIHNlY29uZHMgb2YgYXJjIHggMTAtNSwgc28gd2UgbmVlZCB0byBzY2FsZSB0byB0aG9zZSB1bml0cy4gTG9uZ2l0dWRlIGlzIHJhZGlhbnMuXG4gIHZhciBkX3BoaSA9IGRlbHRhX2xhdCAvIFNFQ19UT19SQUQgKiAxRS01O1xuICB2YXIgZF9sYW1iZGEgPSBkZWx0YV9sb247XG4gIHZhciBkX3BoaV9uID0gMTsgLy8gZF9waGleMFxuXG4gIHZhciBkX3BzaSA9IDA7XG4gIGZvciAobiA9IDE7IG4gPD0gMTA7IG4rKykge1xuICAgIGRfcGhpX24gPSBkX3BoaV9uICogZF9waGk7XG4gICAgZF9wc2kgPSBkX3BzaSArIHRoaXMuQVtuXSAqIGRfcGhpX247XG4gIH1cblxuICAvLyAyLiBDYWxjdWxhdGUgdGhldGFcbiAgdmFyIHRoX3JlID0gZF9wc2k7XG4gIHZhciB0aF9pbSA9IGRfbGFtYmRhO1xuXG4gIC8vIDMuIENhbGN1bGF0ZSB6XG4gIHZhciB0aF9uX3JlID0gMTtcbiAgdmFyIHRoX25faW0gPSAwOyAvLyB0aGV0YV4wXG4gIHZhciB0aF9uX3JlMTtcbiAgdmFyIHRoX25faW0xO1xuXG4gIHZhciB6X3JlID0gMDtcbiAgdmFyIHpfaW0gPSAwO1xuICBmb3IgKG4gPSAxOyBuIDw9IDY7IG4rKykge1xuICAgIHRoX25fcmUxID0gdGhfbl9yZSAqIHRoX3JlIC0gdGhfbl9pbSAqIHRoX2ltO1xuICAgIHRoX25faW0xID0gdGhfbl9pbSAqIHRoX3JlICsgdGhfbl9yZSAqIHRoX2ltO1xuICAgIHRoX25fcmUgPSB0aF9uX3JlMTtcbiAgICB0aF9uX2ltID0gdGhfbl9pbTE7XG4gICAgel9yZSA9IHpfcmUgKyB0aGlzLkJfcmVbbl0gKiB0aF9uX3JlIC0gdGhpcy5CX2ltW25dICogdGhfbl9pbTtcbiAgICB6X2ltID0gel9pbSArIHRoaXMuQl9pbVtuXSAqIHRoX25fcmUgKyB0aGlzLkJfcmVbbl0gKiB0aF9uX2ltO1xuICB9XG5cbiAgLy8gNC4gQ2FsY3VsYXRlIGVhc3RpbmcgYW5kIG5vcnRoaW5nXG4gIHAueCA9ICh6X2ltICogdGhpcy5hKSArIHRoaXMueDA7XG4gIHAueSA9ICh6X3JlICogdGhpcy5hKSArIHRoaXMueTA7XG5cbiAgcmV0dXJuIHA7XG59O1xuXG5cbi8qKlxuICAgIE5ldyBaZWFsYW5kIE1hcCBHcmlkIEludmVyc2UgIC0gIHgveSB0byBsb25nL2xhdFxuICAqL1xuZXhwb3J0cy5pbnZlcnNlID0gZnVuY3Rpb24ocCkge1xuICB2YXIgbjtcbiAgdmFyIHggPSBwLng7XG4gIHZhciB5ID0gcC55O1xuXG4gIHZhciBkZWx0YV94ID0geCAtIHRoaXMueDA7XG4gIHZhciBkZWx0YV95ID0geSAtIHRoaXMueTA7XG5cbiAgLy8gMS4gQ2FsY3VsYXRlIHpcbiAgdmFyIHpfcmUgPSBkZWx0YV95IC8gdGhpcy5hO1xuICB2YXIgel9pbSA9IGRlbHRhX3ggLyB0aGlzLmE7XG5cbiAgLy8gMmEuIENhbGN1bGF0ZSB0aGV0YSAtIGZpcnN0IGFwcHJveGltYXRpb24gZ2l2ZXMga20gYWNjdXJhY3lcbiAgdmFyIHpfbl9yZSA9IDE7XG4gIHZhciB6X25faW0gPSAwOyAvLyB6XjBcbiAgdmFyIHpfbl9yZTE7XG4gIHZhciB6X25faW0xO1xuXG4gIHZhciB0aF9yZSA9IDA7XG4gIHZhciB0aF9pbSA9IDA7XG4gIGZvciAobiA9IDE7IG4gPD0gNjsgbisrKSB7XG4gICAgel9uX3JlMSA9IHpfbl9yZSAqIHpfcmUgLSB6X25faW0gKiB6X2ltO1xuICAgIHpfbl9pbTEgPSB6X25faW0gKiB6X3JlICsgel9uX3JlICogel9pbTtcbiAgICB6X25fcmUgPSB6X25fcmUxO1xuICAgIHpfbl9pbSA9IHpfbl9pbTE7XG4gICAgdGhfcmUgPSB0aF9yZSArIHRoaXMuQ19yZVtuXSAqIHpfbl9yZSAtIHRoaXMuQ19pbVtuXSAqIHpfbl9pbTtcbiAgICB0aF9pbSA9IHRoX2ltICsgdGhpcy5DX2ltW25dICogel9uX3JlICsgdGhpcy5DX3JlW25dICogel9uX2ltO1xuICB9XG5cbiAgLy8gMmIuIEl0ZXJhdGUgdG8gcmVmaW5lIHRoZSBhY2N1cmFjeSBvZiB0aGUgY2FsY3VsYXRpb25cbiAgLy8gICAgICAgIDAgaXRlcmF0aW9ucyBnaXZlcyBrbSBhY2N1cmFjeVxuICAvLyAgICAgICAgMSBpdGVyYXRpb24gZ2l2ZXMgbSBhY2N1cmFjeSAtLSBnb29kIGVub3VnaCBmb3IgbW9zdCBtYXBwaW5nIGFwcGxpY2F0aW9uc1xuICAvLyAgICAgICAgMiBpdGVyYXRpb25zIGJpdmVzIG1tIGFjY3VyYWN5XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pdGVyYXRpb25zOyBpKyspIHtcbiAgICB2YXIgdGhfbl9yZSA9IHRoX3JlO1xuICAgIHZhciB0aF9uX2ltID0gdGhfaW07XG4gICAgdmFyIHRoX25fcmUxO1xuICAgIHZhciB0aF9uX2ltMTtcblxuICAgIHZhciBudW1fcmUgPSB6X3JlO1xuICAgIHZhciBudW1faW0gPSB6X2ltO1xuICAgIGZvciAobiA9IDI7IG4gPD0gNjsgbisrKSB7XG4gICAgICB0aF9uX3JlMSA9IHRoX25fcmUgKiB0aF9yZSAtIHRoX25faW0gKiB0aF9pbTtcbiAgICAgIHRoX25faW0xID0gdGhfbl9pbSAqIHRoX3JlICsgdGhfbl9yZSAqIHRoX2ltO1xuICAgICAgdGhfbl9yZSA9IHRoX25fcmUxO1xuICAgICAgdGhfbl9pbSA9IHRoX25faW0xO1xuICAgICAgbnVtX3JlID0gbnVtX3JlICsgKG4gLSAxKSAqICh0aGlzLkJfcmVbbl0gKiB0aF9uX3JlIC0gdGhpcy5CX2ltW25dICogdGhfbl9pbSk7XG4gICAgICBudW1faW0gPSBudW1faW0gKyAobiAtIDEpICogKHRoaXMuQl9pbVtuXSAqIHRoX25fcmUgKyB0aGlzLkJfcmVbbl0gKiB0aF9uX2ltKTtcbiAgICB9XG5cbiAgICB0aF9uX3JlID0gMTtcbiAgICB0aF9uX2ltID0gMDtcbiAgICB2YXIgZGVuX3JlID0gdGhpcy5CX3JlWzFdO1xuICAgIHZhciBkZW5faW0gPSB0aGlzLkJfaW1bMV07XG4gICAgZm9yIChuID0gMjsgbiA8PSA2OyBuKyspIHtcbiAgICAgIHRoX25fcmUxID0gdGhfbl9yZSAqIHRoX3JlIC0gdGhfbl9pbSAqIHRoX2ltO1xuICAgICAgdGhfbl9pbTEgPSB0aF9uX2ltICogdGhfcmUgKyB0aF9uX3JlICogdGhfaW07XG4gICAgICB0aF9uX3JlID0gdGhfbl9yZTE7XG4gICAgICB0aF9uX2ltID0gdGhfbl9pbTE7XG4gICAgICBkZW5fcmUgPSBkZW5fcmUgKyBuICogKHRoaXMuQl9yZVtuXSAqIHRoX25fcmUgLSB0aGlzLkJfaW1bbl0gKiB0aF9uX2ltKTtcbiAgICAgIGRlbl9pbSA9IGRlbl9pbSArIG4gKiAodGhpcy5CX2ltW25dICogdGhfbl9yZSArIHRoaXMuQl9yZVtuXSAqIHRoX25faW0pO1xuICAgIH1cblxuICAgIC8vIENvbXBsZXggZGl2aXNpb25cbiAgICB2YXIgZGVuMiA9IGRlbl9yZSAqIGRlbl9yZSArIGRlbl9pbSAqIGRlbl9pbTtcbiAgICB0aF9yZSA9IChudW1fcmUgKiBkZW5fcmUgKyBudW1faW0gKiBkZW5faW0pIC8gZGVuMjtcbiAgICB0aF9pbSA9IChudW1faW0gKiBkZW5fcmUgLSBudW1fcmUgKiBkZW5faW0pIC8gZGVuMjtcbiAgfVxuXG4gIC8vIDMuIENhbGN1bGF0ZSBkX3BoaSAgICAgICAgICAgICAgLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIGRfbGFtYmRhXG4gIHZhciBkX3BzaSA9IHRoX3JlO1xuICB2YXIgZF9sYW1iZGEgPSB0aF9pbTtcbiAgdmFyIGRfcHNpX24gPSAxOyAvLyBkX3BzaV4wXG5cbiAgdmFyIGRfcGhpID0gMDtcbiAgZm9yIChuID0gMTsgbiA8PSA5OyBuKyspIHtcbiAgICBkX3BzaV9uID0gZF9wc2lfbiAqIGRfcHNpO1xuICAgIGRfcGhpID0gZF9waGkgKyB0aGlzLkRbbl0gKiBkX3BzaV9uO1xuICB9XG5cbiAgLy8gNC4gQ2FsY3VsYXRlIGxhdGl0dWRlIGFuZCBsb25naXR1ZGVcbiAgLy8gZF9waGkgaXMgY2FsY3VhdGVkIGluIHNlY29uZCBvZiBhcmMgKiAxMF4tNSwgc28gd2UgbmVlZCB0byBzY2FsZSBiYWNrIHRvIHJhZGlhbnMuIGRfbGFtYmRhIGlzIGluIHJhZGlhbnMuXG4gIHZhciBsYXQgPSB0aGlzLmxhdDAgKyAoZF9waGkgKiBTRUNfVE9fUkFEICogMUU1KTtcbiAgdmFyIGxvbiA9IHRoaXMubG9uZzAgKyBkX2xhbWJkYTtcblxuICBwLnggPSBsb247XG4gIHAueSA9IGxhdDtcblxuICByZXR1cm4gcDtcbn07XG5leHBvcnRzLm5hbWVzID0gW1wiTmV3X1plYWxhbmRfTWFwX0dyaWRcIiwgXCJuem1nXCJdO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcm9qNC9saWIvcHJvamVjdGlvbnMvbnptZy5qc1xuLy8gbW9kdWxlIGlkID0gMTUzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,exports,__webpack_require__){eval('var tsfnz = __webpack_require__(22);\nvar adjust_lon = __webpack_require__(0);\nvar phi2z = __webpack_require__(21);\nvar HALF_PI = Math.PI/2;\nvar FORTPI = Math.PI/4;\nvar EPSLN = 1.0e-10;\n\n/* Initialize the Oblique Mercator  projection\n    ------------------------------------------*/\nexports.init = function() {\n  this.no_off = this.no_off || false;\n  this.no_rot = this.no_rot || false;\n\n  if (isNaN(this.k0)) {\n    this.k0 = 1;\n  }\n  var sinlat = Math.sin(this.lat0);\n  var coslat = Math.cos(this.lat0);\n  var con = this.e * sinlat;\n\n  this.bl = Math.sqrt(1 + this.es / (1 - this.es) * Math.pow(coslat, 4));\n  this.al = this.a * this.bl * this.k0 * Math.sqrt(1 - this.es) / (1 - con * con);\n  var t0 = tsfnz(this.e, this.lat0, sinlat);\n  var dl = this.bl / coslat * Math.sqrt((1 - this.es) / (1 - con * con));\n  if (dl * dl < 1) {\n    dl = 1;\n  }\n  var fl;\n  var gl;\n  if (!isNaN(this.longc)) {\n    //Central point and azimuth method\n\n    if (this.lat0 >= 0) {\n      fl = dl + Math.sqrt(dl * dl - 1);\n    }\n    else {\n      fl = dl - Math.sqrt(dl * dl - 1);\n    }\n    this.el = fl * Math.pow(t0, this.bl);\n    gl = 0.5 * (fl - 1 / fl);\n    this.gamma0 = Math.asin(Math.sin(this.alpha) / dl);\n    this.long0 = this.longc - Math.asin(gl * Math.tan(this.gamma0)) / this.bl;\n\n  }\n  else {\n    //2 points method\n    var t1 = tsfnz(this.e, this.lat1, Math.sin(this.lat1));\n    var t2 = tsfnz(this.e, this.lat2, Math.sin(this.lat2));\n    if (this.lat0 >= 0) {\n      this.el = (dl + Math.sqrt(dl * dl - 1)) * Math.pow(t0, this.bl);\n    }\n    else {\n      this.el = (dl - Math.sqrt(dl * dl - 1)) * Math.pow(t0, this.bl);\n    }\n    var hl = Math.pow(t1, this.bl);\n    var ll = Math.pow(t2, this.bl);\n    fl = this.el / hl;\n    gl = 0.5 * (fl - 1 / fl);\n    var jl = (this.el * this.el - ll * hl) / (this.el * this.el + ll * hl);\n    var pl = (ll - hl) / (ll + hl);\n    var dlon12 = adjust_lon(this.long1 - this.long2);\n    this.long0 = 0.5 * (this.long1 + this.long2) - Math.atan(jl * Math.tan(0.5 * this.bl * (dlon12)) / pl) / this.bl;\n    this.long0 = adjust_lon(this.long0);\n    var dlon10 = adjust_lon(this.long1 - this.long0);\n    this.gamma0 = Math.atan(Math.sin(this.bl * (dlon10)) / gl);\n    this.alpha = Math.asin(dl * Math.sin(this.gamma0));\n  }\n\n  if (this.no_off) {\n    this.uc = 0;\n  }\n  else {\n    if (this.lat0 >= 0) {\n      this.uc = this.al / this.bl * Math.atan2(Math.sqrt(dl * dl - 1), Math.cos(this.alpha));\n    }\n    else {\n      this.uc = -1 * this.al / this.bl * Math.atan2(Math.sqrt(dl * dl - 1), Math.cos(this.alpha));\n    }\n  }\n\n};\n\n\n/* Oblique Mercator forward equations--mapping lat,long to x,y\n    ----------------------------------------------------------*/\nexports.forward = function(p) {\n  var lon = p.x;\n  var lat = p.y;\n  var dlon = adjust_lon(lon - this.long0);\n  var us, vs;\n  var con;\n  if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {\n    if (lat > 0) {\n      con = -1;\n    }\n    else {\n      con = 1;\n    }\n    vs = this.al / this.bl * Math.log(Math.tan(FORTPI + con * this.gamma0 * 0.5));\n    us = -1 * con * HALF_PI * this.al / this.bl;\n  }\n  else {\n    var t = tsfnz(this.e, lat, Math.sin(lat));\n    var ql = this.el / Math.pow(t, this.bl);\n    var sl = 0.5 * (ql - 1 / ql);\n    var tl = 0.5 * (ql + 1 / ql);\n    var vl = Math.sin(this.bl * (dlon));\n    var ul = (sl * Math.sin(this.gamma0) - vl * Math.cos(this.gamma0)) / tl;\n    if (Math.abs(Math.abs(ul) - 1) <= EPSLN) {\n      vs = Number.POSITIVE_INFINITY;\n    }\n    else {\n      vs = 0.5 * this.al * Math.log((1 - ul) / (1 + ul)) / this.bl;\n    }\n    if (Math.abs(Math.cos(this.bl * (dlon))) <= EPSLN) {\n      us = this.al * this.bl * (dlon);\n    }\n    else {\n      us = this.al * Math.atan2(sl * Math.cos(this.gamma0) + vl * Math.sin(this.gamma0), Math.cos(this.bl * dlon)) / this.bl;\n    }\n  }\n\n  if (this.no_rot) {\n    p.x = this.x0 + us;\n    p.y = this.y0 + vs;\n  }\n  else {\n\n    us -= this.uc;\n    p.x = this.x0 + vs * Math.cos(this.alpha) + us * Math.sin(this.alpha);\n    p.y = this.y0 + us * Math.cos(this.alpha) - vs * Math.sin(this.alpha);\n  }\n  return p;\n};\n\nexports.inverse = function(p) {\n  var us, vs;\n  if (this.no_rot) {\n    vs = p.y - this.y0;\n    us = p.x - this.x0;\n  }\n  else {\n    vs = (p.x - this.x0) * Math.cos(this.alpha) - (p.y - this.y0) * Math.sin(this.alpha);\n    us = (p.y - this.y0) * Math.cos(this.alpha) + (p.x - this.x0) * Math.sin(this.alpha);\n    us += this.uc;\n  }\n  var qp = Math.exp(-1 * this.bl * vs / this.al);\n  var sp = 0.5 * (qp - 1 / qp);\n  var tp = 0.5 * (qp + 1 / qp);\n  var vp = Math.sin(this.bl * us / this.al);\n  var up = (vp * Math.cos(this.gamma0) + sp * Math.sin(this.gamma0)) / tp;\n  var ts = Math.pow(this.el / Math.sqrt((1 + up) / (1 - up)), 1 / this.bl);\n  if (Math.abs(up - 1) < EPSLN) {\n    p.x = this.long0;\n    p.y = HALF_PI;\n  }\n  else if (Math.abs(up + 1) < EPSLN) {\n    p.x = this.long0;\n    p.y = -1 * HALF_PI;\n  }\n  else {\n    p.y = phi2z(this.e, ts);\n    p.x = adjust_lon(this.long0 - Math.atan2(sp * Math.cos(this.gamma0) - vp * Math.sin(this.gamma0), Math.cos(this.bl * us / this.al)) / this.bl);\n  }\n  return p;\n};\n\nexports.names = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "omerc"];//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9vbWVyYy5qcz8yZTgyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjE1NC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciB0c2ZueiA9IHJlcXVpcmUoJy4uL2NvbW1vbi90c2ZueicpO1xudmFyIGFkanVzdF9sb24gPSByZXF1aXJlKCcuLi9jb21tb24vYWRqdXN0X2xvbicpO1xudmFyIHBoaTJ6ID0gcmVxdWlyZSgnLi4vY29tbW9uL3BoaTJ6Jyk7XG52YXIgSEFMRl9QSSA9IE1hdGguUEkvMjtcbnZhciBGT1JUUEkgPSBNYXRoLlBJLzQ7XG52YXIgRVBTTE4gPSAxLjBlLTEwO1xuXG4vKiBJbml0aWFsaXplIHRoZSBPYmxpcXVlIE1lcmNhdG9yICBwcm9qZWN0aW9uXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmV4cG9ydHMuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLm5vX29mZiA9IHRoaXMubm9fb2ZmIHx8IGZhbHNlO1xuICB0aGlzLm5vX3JvdCA9IHRoaXMubm9fcm90IHx8IGZhbHNlO1xuXG4gIGlmIChpc05hTih0aGlzLmswKSkge1xuICAgIHRoaXMuazAgPSAxO1xuICB9XG4gIHZhciBzaW5sYXQgPSBNYXRoLnNpbih0aGlzLmxhdDApO1xuICB2YXIgY29zbGF0ID0gTWF0aC5jb3ModGhpcy5sYXQwKTtcbiAgdmFyIGNvbiA9IHRoaXMuZSAqIHNpbmxhdDtcblxuICB0aGlzLmJsID0gTWF0aC5zcXJ0KDEgKyB0aGlzLmVzIC8gKDEgLSB0aGlzLmVzKSAqIE1hdGgucG93KGNvc2xhdCwgNCkpO1xuICB0aGlzLmFsID0gdGhpcy5hICogdGhpcy5ibCAqIHRoaXMuazAgKiBNYXRoLnNxcnQoMSAtIHRoaXMuZXMpIC8gKDEgLSBjb24gKiBjb24pO1xuICB2YXIgdDAgPSB0c2Zueih0aGlzLmUsIHRoaXMubGF0MCwgc2lubGF0KTtcbiAgdmFyIGRsID0gdGhpcy5ibCAvIGNvc2xhdCAqIE1hdGguc3FydCgoMSAtIHRoaXMuZXMpIC8gKDEgLSBjb24gKiBjb24pKTtcbiAgaWYgKGRsICogZGwgPCAxKSB7XG4gICAgZGwgPSAxO1xuICB9XG4gIHZhciBmbDtcbiAgdmFyIGdsO1xuICBpZiAoIWlzTmFOKHRoaXMubG9uZ2MpKSB7XG4gICAgLy9DZW50cmFsIHBvaW50IGFuZCBhemltdXRoIG1ldGhvZFxuXG4gICAgaWYgKHRoaXMubGF0MCA+PSAwKSB7XG4gICAgICBmbCA9IGRsICsgTWF0aC5zcXJ0KGRsICogZGwgLSAxKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBmbCA9IGRsIC0gTWF0aC5zcXJ0KGRsICogZGwgLSAxKTtcbiAgICB9XG4gICAgdGhpcy5lbCA9IGZsICogTWF0aC5wb3codDAsIHRoaXMuYmwpO1xuICAgIGdsID0gMC41ICogKGZsIC0gMSAvIGZsKTtcbiAgICB0aGlzLmdhbW1hMCA9IE1hdGguYXNpbihNYXRoLnNpbih0aGlzLmFscGhhKSAvIGRsKTtcbiAgICB0aGlzLmxvbmcwID0gdGhpcy5sb25nYyAtIE1hdGguYXNpbihnbCAqIE1hdGgudGFuKHRoaXMuZ2FtbWEwKSkgLyB0aGlzLmJsO1xuXG4gIH1cbiAgZWxzZSB7XG4gICAgLy8yIHBvaW50cyBtZXRob2RcbiAgICB2YXIgdDEgPSB0c2Zueih0aGlzLmUsIHRoaXMubGF0MSwgTWF0aC5zaW4odGhpcy5sYXQxKSk7XG4gICAgdmFyIHQyID0gdHNmbnoodGhpcy5lLCB0aGlzLmxhdDIsIE1hdGguc2luKHRoaXMubGF0MikpO1xuICAgIGlmICh0aGlzLmxhdDAgPj0gMCkge1xuICAgICAgdGhpcy5lbCA9IChkbCArIE1hdGguc3FydChkbCAqIGRsIC0gMSkpICogTWF0aC5wb3codDAsIHRoaXMuYmwpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuZWwgPSAoZGwgLSBNYXRoLnNxcnQoZGwgKiBkbCAtIDEpKSAqIE1hdGgucG93KHQwLCB0aGlzLmJsKTtcbiAgICB9XG4gICAgdmFyIGhsID0gTWF0aC5wb3codDEsIHRoaXMuYmwpO1xuICAgIHZhciBsbCA9IE1hdGgucG93KHQyLCB0aGlzLmJsKTtcbiAgICBmbCA9IHRoaXMuZWwgLyBobDtcbiAgICBnbCA9IDAuNSAqIChmbCAtIDEgLyBmbCk7XG4gICAgdmFyIGpsID0gKHRoaXMuZWwgKiB0aGlzLmVsIC0gbGwgKiBobCkgLyAodGhpcy5lbCAqIHRoaXMuZWwgKyBsbCAqIGhsKTtcbiAgICB2YXIgcGwgPSAobGwgLSBobCkgLyAobGwgKyBobCk7XG4gICAgdmFyIGRsb24xMiA9IGFkanVzdF9sb24odGhpcy5sb25nMSAtIHRoaXMubG9uZzIpO1xuICAgIHRoaXMubG9uZzAgPSAwLjUgKiAodGhpcy5sb25nMSArIHRoaXMubG9uZzIpIC0gTWF0aC5hdGFuKGpsICogTWF0aC50YW4oMC41ICogdGhpcy5ibCAqIChkbG9uMTIpKSAvIHBsKSAvIHRoaXMuYmw7XG4gICAgdGhpcy5sb25nMCA9IGFkanVzdF9sb24odGhpcy5sb25nMCk7XG4gICAgdmFyIGRsb24xMCA9IGFkanVzdF9sb24odGhpcy5sb25nMSAtIHRoaXMubG9uZzApO1xuICAgIHRoaXMuZ2FtbWEwID0gTWF0aC5hdGFuKE1hdGguc2luKHRoaXMuYmwgKiAoZGxvbjEwKSkgLyBnbCk7XG4gICAgdGhpcy5hbHBoYSA9IE1hdGguYXNpbihkbCAqIE1hdGguc2luKHRoaXMuZ2FtbWEwKSk7XG4gIH1cblxuICBpZiAodGhpcy5ub19vZmYpIHtcbiAgICB0aGlzLnVjID0gMDtcbiAgfVxuICBlbHNlIHtcbiAgICBpZiAodGhpcy5sYXQwID49IDApIHtcbiAgICAgIHRoaXMudWMgPSB0aGlzLmFsIC8gdGhpcy5ibCAqIE1hdGguYXRhbjIoTWF0aC5zcXJ0KGRsICogZGwgLSAxKSwgTWF0aC5jb3ModGhpcy5hbHBoYSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMudWMgPSAtMSAqIHRoaXMuYWwgLyB0aGlzLmJsICogTWF0aC5hdGFuMihNYXRoLnNxcnQoZGwgKiBkbCAtIDEpLCBNYXRoLmNvcyh0aGlzLmFscGhhKSk7XG4gICAgfVxuICB9XG5cbn07XG5cblxuLyogT2JsaXF1ZSBNZXJjYXRvciBmb3J3YXJkIGVxdWF0aW9ucy0tbWFwcGluZyBsYXQsbG9uZyB0byB4LHlcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmV4cG9ydHMuZm9yd2FyZCA9IGZ1bmN0aW9uKHApIHtcbiAgdmFyIGxvbiA9IHAueDtcbiAgdmFyIGxhdCA9IHAueTtcbiAgdmFyIGRsb24gPSBhZGp1c3RfbG9uKGxvbiAtIHRoaXMubG9uZzApO1xuICB2YXIgdXMsIHZzO1xuICB2YXIgY29uO1xuICBpZiAoTWF0aC5hYnMoTWF0aC5hYnMobGF0KSAtIEhBTEZfUEkpIDw9IEVQU0xOKSB7XG4gICAgaWYgKGxhdCA+IDApIHtcbiAgICAgIGNvbiA9IC0xO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNvbiA9IDE7XG4gICAgfVxuICAgIHZzID0gdGhpcy5hbCAvIHRoaXMuYmwgKiBNYXRoLmxvZyhNYXRoLnRhbihGT1JUUEkgKyBjb24gKiB0aGlzLmdhbW1hMCAqIDAuNSkpO1xuICAgIHVzID0gLTEgKiBjb24gKiBIQUxGX1BJICogdGhpcy5hbCAvIHRoaXMuYmw7XG4gIH1cbiAgZWxzZSB7XG4gICAgdmFyIHQgPSB0c2Zueih0aGlzLmUsIGxhdCwgTWF0aC5zaW4obGF0KSk7XG4gICAgdmFyIHFsID0gdGhpcy5lbCAvIE1hdGgucG93KHQsIHRoaXMuYmwpO1xuICAgIHZhciBzbCA9IDAuNSAqIChxbCAtIDEgLyBxbCk7XG4gICAgdmFyIHRsID0gMC41ICogKHFsICsgMSAvIHFsKTtcbiAgICB2YXIgdmwgPSBNYXRoLnNpbih0aGlzLmJsICogKGRsb24pKTtcbiAgICB2YXIgdWwgPSAoc2wgKiBNYXRoLnNpbih0aGlzLmdhbW1hMCkgLSB2bCAqIE1hdGguY29zKHRoaXMuZ2FtbWEwKSkgLyB0bDtcbiAgICBpZiAoTWF0aC5hYnMoTWF0aC5hYnModWwpIC0gMSkgPD0gRVBTTE4pIHtcbiAgICAgIHZzID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZzID0gMC41ICogdGhpcy5hbCAqIE1hdGgubG9nKCgxIC0gdWwpIC8gKDEgKyB1bCkpIC8gdGhpcy5ibDtcbiAgICB9XG4gICAgaWYgKE1hdGguYWJzKE1hdGguY29zKHRoaXMuYmwgKiAoZGxvbikpKSA8PSBFUFNMTikge1xuICAgICAgdXMgPSB0aGlzLmFsICogdGhpcy5ibCAqIChkbG9uKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB1cyA9IHRoaXMuYWwgKiBNYXRoLmF0YW4yKHNsICogTWF0aC5jb3ModGhpcy5nYW1tYTApICsgdmwgKiBNYXRoLnNpbih0aGlzLmdhbW1hMCksIE1hdGguY29zKHRoaXMuYmwgKiBkbG9uKSkgLyB0aGlzLmJsO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLm5vX3JvdCkge1xuICAgIHAueCA9IHRoaXMueDAgKyB1cztcbiAgICBwLnkgPSB0aGlzLnkwICsgdnM7XG4gIH1cbiAgZWxzZSB7XG5cbiAgICB1cyAtPSB0aGlzLnVjO1xuICAgIHAueCA9IHRoaXMueDAgKyB2cyAqIE1hdGguY29zKHRoaXMuYWxwaGEpICsgdXMgKiBNYXRoLnNpbih0aGlzLmFscGhhKTtcbiAgICBwLnkgPSB0aGlzLnkwICsgdXMgKiBNYXRoLmNvcyh0aGlzLmFscGhhKSAtIHZzICogTWF0aC5zaW4odGhpcy5hbHBoYSk7XG4gIH1cbiAgcmV0dXJuIHA7XG59O1xuXG5leHBvcnRzLmludmVyc2UgPSBmdW5jdGlvbihwKSB7XG4gIHZhciB1cywgdnM7XG4gIGlmICh0aGlzLm5vX3JvdCkge1xuICAgIHZzID0gcC55IC0gdGhpcy55MDtcbiAgICB1cyA9IHAueCAtIHRoaXMueDA7XG4gIH1cbiAgZWxzZSB7XG4gICAgdnMgPSAocC54IC0gdGhpcy54MCkgKiBNYXRoLmNvcyh0aGlzLmFscGhhKSAtIChwLnkgLSB0aGlzLnkwKSAqIE1hdGguc2luKHRoaXMuYWxwaGEpO1xuICAgIHVzID0gKHAueSAtIHRoaXMueTApICogTWF0aC5jb3ModGhpcy5hbHBoYSkgKyAocC54IC0gdGhpcy54MCkgKiBNYXRoLnNpbih0aGlzLmFscGhhKTtcbiAgICB1cyArPSB0aGlzLnVjO1xuICB9XG4gIHZhciBxcCA9IE1hdGguZXhwKC0xICogdGhpcy5ibCAqIHZzIC8gdGhpcy5hbCk7XG4gIHZhciBzcCA9IDAuNSAqIChxcCAtIDEgLyBxcCk7XG4gIHZhciB0cCA9IDAuNSAqIChxcCArIDEgLyBxcCk7XG4gIHZhciB2cCA9IE1hdGguc2luKHRoaXMuYmwgKiB1cyAvIHRoaXMuYWwpO1xuICB2YXIgdXAgPSAodnAgKiBNYXRoLmNvcyh0aGlzLmdhbW1hMCkgKyBzcCAqIE1hdGguc2luKHRoaXMuZ2FtbWEwKSkgLyB0cDtcbiAgdmFyIHRzID0gTWF0aC5wb3codGhpcy5lbCAvIE1hdGguc3FydCgoMSArIHVwKSAvICgxIC0gdXApKSwgMSAvIHRoaXMuYmwpO1xuICBpZiAoTWF0aC5hYnModXAgLSAxKSA8IEVQU0xOKSB7XG4gICAgcC54ID0gdGhpcy5sb25nMDtcbiAgICBwLnkgPSBIQUxGX1BJO1xuICB9XG4gIGVsc2UgaWYgKE1hdGguYWJzKHVwICsgMSkgPCBFUFNMTikge1xuICAgIHAueCA9IHRoaXMubG9uZzA7XG4gICAgcC55ID0gLTEgKiBIQUxGX1BJO1xuICB9XG4gIGVsc2Uge1xuICAgIHAueSA9IHBoaTJ6KHRoaXMuZSwgdHMpO1xuICAgIHAueCA9IGFkanVzdF9sb24odGhpcy5sb25nMCAtIE1hdGguYXRhbjIoc3AgKiBNYXRoLmNvcyh0aGlzLmdhbW1hMCkgLSB2cCAqIE1hdGguc2luKHRoaXMuZ2FtbWEwKSwgTWF0aC5jb3ModGhpcy5ibCAqIHVzIC8gdGhpcy5hbCkpIC8gdGhpcy5ibCk7XG4gIH1cbiAgcmV0dXJuIHA7XG59O1xuXG5leHBvcnRzLm5hbWVzID0gW1wiSG90aW5lX09ibGlxdWVfTWVyY2F0b3JcIiwgXCJIb3RpbmUgT2JsaXF1ZSBNZXJjYXRvclwiLCBcIkhvdGluZV9PYmxpcXVlX01lcmNhdG9yX0F6aW11dGhfTmF0dXJhbF9PcmlnaW5cIiwgXCJIb3RpbmVfT2JsaXF1ZV9NZXJjYXRvcl9BemltdXRoX0NlbnRlclwiLCBcIm9tZXJjXCJdO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcm9qNC9saWIvcHJvamVjdGlvbnMvb21lcmMuanNcbi8vIG1vZHVsZSBpZCA9IDE1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9')},function(module,exports,__webpack_require__){eval('var e0fn = __webpack_require__(12);\nvar e1fn = __webpack_require__(13);\nvar e2fn = __webpack_require__(14);\nvar e3fn = __webpack_require__(15);\nvar adjust_lon = __webpack_require__(0);\nvar adjust_lat = __webpack_require__(11);\nvar mlfn = __webpack_require__(16);\nvar EPSLN = 1.0e-10;\nvar gN = __webpack_require__(33);\nvar MAX_ITER = 20;\nexports.init = function() {\n  /* Place parameters in static storage for common use\n      -------------------------------------------------*/\n  this.temp = this.b / this.a;\n  this.es = 1 - Math.pow(this.temp, 2); // devait etre dans tmerc.js mais n y est pas donc je commente sinon retour de valeurs nulles\n  this.e = Math.sqrt(this.es);\n  this.e0 = e0fn(this.es);\n  this.e1 = e1fn(this.es);\n  this.e2 = e2fn(this.es);\n  this.e3 = e3fn(this.es);\n  this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0); //si que des zeros le calcul ne se fait pas\n};\n\n\n/* Polyconic forward equations--mapping lat,long to x,y\n    ---------------------------------------------------*/\nexports.forward = function(p) {\n  var lon = p.x;\n  var lat = p.y;\n  var x, y, el;\n  var dlon = adjust_lon(lon - this.long0);\n  el = dlon * Math.sin(lat);\n  if (this.sphere) {\n    if (Math.abs(lat) <= EPSLN) {\n      x = this.a * dlon;\n      y = -1 * this.a * this.lat0;\n    }\n    else {\n      x = this.a * Math.sin(el) / Math.tan(lat);\n      y = this.a * (adjust_lat(lat - this.lat0) + (1 - Math.cos(el)) / Math.tan(lat));\n    }\n  }\n  else {\n    if (Math.abs(lat) <= EPSLN) {\n      x = this.a * dlon;\n      y = -1 * this.ml0;\n    }\n    else {\n      var nl = gN(this.a, this.e, Math.sin(lat)) / Math.tan(lat);\n      x = nl * Math.sin(el);\n      y = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, lat) - this.ml0 + nl * (1 - Math.cos(el));\n    }\n\n  }\n  p.x = x + this.x0;\n  p.y = y + this.y0;\n  return p;\n};\n\n\n/* Inverse equations\n  -----------------*/\nexports.inverse = function(p) {\n  var lon, lat, x, y, i;\n  var al, bl;\n  var phi, dphi;\n  x = p.x - this.x0;\n  y = p.y - this.y0;\n\n  if (this.sphere) {\n    if (Math.abs(y + this.a * this.lat0) <= EPSLN) {\n      lon = adjust_lon(x / this.a + this.long0);\n      lat = 0;\n    }\n    else {\n      al = this.lat0 + y / this.a;\n      bl = x * x / this.a / this.a + al * al;\n      phi = al;\n      var tanphi;\n      for (i = MAX_ITER; i; --i) {\n        tanphi = Math.tan(phi);\n        dphi = -1 * (al * (phi * tanphi + 1) - phi - 0.5 * (phi * phi + bl) * tanphi) / ((phi - al) / tanphi - 1);\n        phi += dphi;\n        if (Math.abs(dphi) <= EPSLN) {\n          lat = phi;\n          break;\n        }\n      }\n      lon = adjust_lon(this.long0 + (Math.asin(x * Math.tan(phi) / this.a)) / Math.sin(lat));\n    }\n  }\n  else {\n    if (Math.abs(y + this.ml0) <= EPSLN) {\n      lat = 0;\n      lon = adjust_lon(this.long0 + x / this.a);\n    }\n    else {\n\n      al = (this.ml0 + y) / this.a;\n      bl = x * x / this.a / this.a + al * al;\n      phi = al;\n      var cl, mln, mlnp, ma;\n      var con;\n      for (i = MAX_ITER; i; --i) {\n        con = this.e * Math.sin(phi);\n        cl = Math.sqrt(1 - con * con) * Math.tan(phi);\n        mln = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);\n        mlnp = this.e0 - 2 * this.e1 * Math.cos(2 * phi) + 4 * this.e2 * Math.cos(4 * phi) - 6 * this.e3 * Math.cos(6 * phi);\n        ma = mln / this.a;\n        dphi = (al * (cl * ma + 1) - ma - 0.5 * cl * (ma * ma + bl)) / (this.es * Math.sin(2 * phi) * (ma * ma + bl - 2 * al * ma) / (4 * cl) + (al - ma) * (cl * mlnp - 2 / Math.sin(2 * phi)) - mlnp);\n        phi -= dphi;\n        if (Math.abs(dphi) <= EPSLN) {\n          lat = phi;\n          break;\n        }\n      }\n\n      //lat=phi4z(this.e,this.e0,this.e1,this.e2,this.e3,al,bl,0,0);\n      cl = Math.sqrt(1 - this.es * Math.pow(Math.sin(lat), 2)) * Math.tan(lat);\n      lon = adjust_lon(this.long0 + Math.asin(x * cl / this.a) / Math.sin(lat));\n    }\n  }\n\n  p.x = lon;\n  p.y = lat;\n  return p;\n};\nexports.names = ["Polyconic", "poly"];//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9wb2x5LmpzPzJkYWMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFO0FBQzFFOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLEdBQUc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLEdBQUc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxNTUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZTBmbiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9lMGZuJyk7XG52YXIgZTFmbiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9lMWZuJyk7XG52YXIgZTJmbiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9lMmZuJyk7XG52YXIgZTNmbiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9lM2ZuJyk7XG52YXIgYWRqdXN0X2xvbiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9hZGp1c3RfbG9uJyk7XG52YXIgYWRqdXN0X2xhdCA9IHJlcXVpcmUoJy4uL2NvbW1vbi9hZGp1c3RfbGF0Jyk7XG52YXIgbWxmbiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9tbGZuJyk7XG52YXIgRVBTTE4gPSAxLjBlLTEwO1xudmFyIGdOID0gcmVxdWlyZSgnLi4vY29tbW9uL2dOJyk7XG52YXIgTUFYX0lURVIgPSAyMDtcbmV4cG9ydHMuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAvKiBQbGFjZSBwYXJhbWV0ZXJzIGluIHN0YXRpYyBzdG9yYWdlIGZvciBjb21tb24gdXNlXG4gICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgdGhpcy50ZW1wID0gdGhpcy5iIC8gdGhpcy5hO1xuICB0aGlzLmVzID0gMSAtIE1hdGgucG93KHRoaXMudGVtcCwgMik7IC8vIGRldmFpdCBldHJlIGRhbnMgdG1lcmMuanMgbWFpcyBuIHkgZXN0IHBhcyBkb25jIGplIGNvbW1lbnRlIHNpbm9uIHJldG91ciBkZSB2YWxldXJzIG51bGxlc1xuICB0aGlzLmUgPSBNYXRoLnNxcnQodGhpcy5lcyk7XG4gIHRoaXMuZTAgPSBlMGZuKHRoaXMuZXMpO1xuICB0aGlzLmUxID0gZTFmbih0aGlzLmVzKTtcbiAgdGhpcy5lMiA9IGUyZm4odGhpcy5lcyk7XG4gIHRoaXMuZTMgPSBlM2ZuKHRoaXMuZXMpO1xuICB0aGlzLm1sMCA9IHRoaXMuYSAqIG1sZm4odGhpcy5lMCwgdGhpcy5lMSwgdGhpcy5lMiwgdGhpcy5lMywgdGhpcy5sYXQwKTsgLy9zaSBxdWUgZGVzIHplcm9zIGxlIGNhbGN1bCBuZSBzZSBmYWl0IHBhc1xufTtcblxuXG4vKiBQb2x5Y29uaWMgZm9yd2FyZCBlcXVhdGlvbnMtLW1hcHBpbmcgbGF0LGxvbmcgdG8geCx5XG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmV4cG9ydHMuZm9yd2FyZCA9IGZ1bmN0aW9uKHApIHtcbiAgdmFyIGxvbiA9IHAueDtcbiAgdmFyIGxhdCA9IHAueTtcbiAgdmFyIHgsIHksIGVsO1xuICB2YXIgZGxvbiA9IGFkanVzdF9sb24obG9uIC0gdGhpcy5sb25nMCk7XG4gIGVsID0gZGxvbiAqIE1hdGguc2luKGxhdCk7XG4gIGlmICh0aGlzLnNwaGVyZSkge1xuICAgIGlmIChNYXRoLmFicyhsYXQpIDw9IEVQU0xOKSB7XG4gICAgICB4ID0gdGhpcy5hICogZGxvbjtcbiAgICAgIHkgPSAtMSAqIHRoaXMuYSAqIHRoaXMubGF0MDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB4ID0gdGhpcy5hICogTWF0aC5zaW4oZWwpIC8gTWF0aC50YW4obGF0KTtcbiAgICAgIHkgPSB0aGlzLmEgKiAoYWRqdXN0X2xhdChsYXQgLSB0aGlzLmxhdDApICsgKDEgLSBNYXRoLmNvcyhlbCkpIC8gTWF0aC50YW4obGF0KSk7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIGlmIChNYXRoLmFicyhsYXQpIDw9IEVQU0xOKSB7XG4gICAgICB4ID0gdGhpcy5hICogZGxvbjtcbiAgICAgIHkgPSAtMSAqIHRoaXMubWwwO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBubCA9IGdOKHRoaXMuYSwgdGhpcy5lLCBNYXRoLnNpbihsYXQpKSAvIE1hdGgudGFuKGxhdCk7XG4gICAgICB4ID0gbmwgKiBNYXRoLnNpbihlbCk7XG4gICAgICB5ID0gdGhpcy5hICogbWxmbih0aGlzLmUwLCB0aGlzLmUxLCB0aGlzLmUyLCB0aGlzLmUzLCBsYXQpIC0gdGhpcy5tbDAgKyBubCAqICgxIC0gTWF0aC5jb3MoZWwpKTtcbiAgICB9XG5cbiAgfVxuICBwLnggPSB4ICsgdGhpcy54MDtcbiAgcC55ID0geSArIHRoaXMueTA7XG4gIHJldHVybiBwO1xufTtcblxuXG4vKiBJbnZlcnNlIGVxdWF0aW9uc1xuICAtLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnRzLmludmVyc2UgPSBmdW5jdGlvbihwKSB7XG4gIHZhciBsb24sIGxhdCwgeCwgeSwgaTtcbiAgdmFyIGFsLCBibDtcbiAgdmFyIHBoaSwgZHBoaTtcbiAgeCA9IHAueCAtIHRoaXMueDA7XG4gIHkgPSBwLnkgLSB0aGlzLnkwO1xuXG4gIGlmICh0aGlzLnNwaGVyZSkge1xuICAgIGlmIChNYXRoLmFicyh5ICsgdGhpcy5hICogdGhpcy5sYXQwKSA8PSBFUFNMTikge1xuICAgICAgbG9uID0gYWRqdXN0X2xvbih4IC8gdGhpcy5hICsgdGhpcy5sb25nMCk7XG4gICAgICBsYXQgPSAwO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGFsID0gdGhpcy5sYXQwICsgeSAvIHRoaXMuYTtcbiAgICAgIGJsID0geCAqIHggLyB0aGlzLmEgLyB0aGlzLmEgKyBhbCAqIGFsO1xuICAgICAgcGhpID0gYWw7XG4gICAgICB2YXIgdGFucGhpO1xuICAgICAgZm9yIChpID0gTUFYX0lURVI7IGk7IC0taSkge1xuICAgICAgICB0YW5waGkgPSBNYXRoLnRhbihwaGkpO1xuICAgICAgICBkcGhpID0gLTEgKiAoYWwgKiAocGhpICogdGFucGhpICsgMSkgLSBwaGkgLSAwLjUgKiAocGhpICogcGhpICsgYmwpICogdGFucGhpKSAvICgocGhpIC0gYWwpIC8gdGFucGhpIC0gMSk7XG4gICAgICAgIHBoaSArPSBkcGhpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoZHBoaSkgPD0gRVBTTE4pIHtcbiAgICAgICAgICBsYXQgPSBwaGk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxvbiA9IGFkanVzdF9sb24odGhpcy5sb25nMCArIChNYXRoLmFzaW4oeCAqIE1hdGgudGFuKHBoaSkgLyB0aGlzLmEpKSAvIE1hdGguc2luKGxhdCkpO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICBpZiAoTWF0aC5hYnMoeSArIHRoaXMubWwwKSA8PSBFUFNMTikge1xuICAgICAgbGF0ID0gMDtcbiAgICAgIGxvbiA9IGFkanVzdF9sb24odGhpcy5sb25nMCArIHggLyB0aGlzLmEpO1xuICAgIH1cbiAgICBlbHNlIHtcblxuICAgICAgYWwgPSAodGhpcy5tbDAgKyB5KSAvIHRoaXMuYTtcbiAgICAgIGJsID0geCAqIHggLyB0aGlzLmEgLyB0aGlzLmEgKyBhbCAqIGFsO1xuICAgICAgcGhpID0gYWw7XG4gICAgICB2YXIgY2wsIG1sbiwgbWxucCwgbWE7XG4gICAgICB2YXIgY29uO1xuICAgICAgZm9yIChpID0gTUFYX0lURVI7IGk7IC0taSkge1xuICAgICAgICBjb24gPSB0aGlzLmUgKiBNYXRoLnNpbihwaGkpO1xuICAgICAgICBjbCA9IE1hdGguc3FydCgxIC0gY29uICogY29uKSAqIE1hdGgudGFuKHBoaSk7XG4gICAgICAgIG1sbiA9IHRoaXMuYSAqIG1sZm4odGhpcy5lMCwgdGhpcy5lMSwgdGhpcy5lMiwgdGhpcy5lMywgcGhpKTtcbiAgICAgICAgbWxucCA9IHRoaXMuZTAgLSAyICogdGhpcy5lMSAqIE1hdGguY29zKDIgKiBwaGkpICsgNCAqIHRoaXMuZTIgKiBNYXRoLmNvcyg0ICogcGhpKSAtIDYgKiB0aGlzLmUzICogTWF0aC5jb3MoNiAqIHBoaSk7XG4gICAgICAgIG1hID0gbWxuIC8gdGhpcy5hO1xuICAgICAgICBkcGhpID0gKGFsICogKGNsICogbWEgKyAxKSAtIG1hIC0gMC41ICogY2wgKiAobWEgKiBtYSArIGJsKSkgLyAodGhpcy5lcyAqIE1hdGguc2luKDIgKiBwaGkpICogKG1hICogbWEgKyBibCAtIDIgKiBhbCAqIG1hKSAvICg0ICogY2wpICsgKGFsIC0gbWEpICogKGNsICogbWxucCAtIDIgLyBNYXRoLnNpbigyICogcGhpKSkgLSBtbG5wKTtcbiAgICAgICAgcGhpIC09IGRwaGk7XG4gICAgICAgIGlmIChNYXRoLmFicyhkcGhpKSA8PSBFUFNMTikge1xuICAgICAgICAgIGxhdCA9IHBoaTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvL2xhdD1waGk0eih0aGlzLmUsdGhpcy5lMCx0aGlzLmUxLHRoaXMuZTIsdGhpcy5lMyxhbCxibCwwLDApO1xuICAgICAgY2wgPSBNYXRoLnNxcnQoMSAtIHRoaXMuZXMgKiBNYXRoLnBvdyhNYXRoLnNpbihsYXQpLCAyKSkgKiBNYXRoLnRhbihsYXQpO1xuICAgICAgbG9uID0gYWRqdXN0X2xvbih0aGlzLmxvbmcwICsgTWF0aC5hc2luKHggKiBjbCAvIHRoaXMuYSkgLyBNYXRoLnNpbihsYXQpKTtcbiAgICB9XG4gIH1cblxuICBwLnggPSBsb247XG4gIHAueSA9IGxhdDtcbiAgcmV0dXJuIHA7XG59O1xuZXhwb3J0cy5uYW1lcyA9IFtcIlBvbHljb25pY1wiLCBcInBvbHlcIl07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9wb2x5LmpzXG4vLyBtb2R1bGUgaWQgPSAxNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports,__webpack_require__){eval('var adjust_lon = __webpack_require__(0);\nvar adjust_lat = __webpack_require__(11);\nvar pj_enfn = __webpack_require__(123);\nvar MAX_ITER = 20;\nvar pj_mlfn = __webpack_require__(60);\nvar pj_inv_mlfn = __webpack_require__(124);\nvar HALF_PI = Math.PI/2;\nvar EPSLN = 1.0e-10;\nvar asinz = __webpack_require__(7);\nexports.init = function() {\n  /* Place parameters in static storage for common use\n    -------------------------------------------------*/\n\n\n  if (!this.sphere) {\n    this.en = pj_enfn(this.es);\n  }\n  else {\n    this.n = 1;\n    this.m = 0;\n    this.es = 0;\n    this.C_y = Math.sqrt((this.m + 1) / this.n);\n    this.C_x = this.C_y / (this.m + 1);\n  }\n\n};\n\n/* Sinusoidal forward equations--mapping lat,long to x,y\n  -----------------------------------------------------*/\nexports.forward = function(p) {\n  var x, y;\n  var lon = p.x;\n  var lat = p.y;\n  /* Forward equations\n    -----------------*/\n  lon = adjust_lon(lon - this.long0);\n\n  if (this.sphere) {\n    if (!this.m) {\n      lat = this.n !== 1 ? Math.asin(this.n * Math.sin(lat)) : lat;\n    }\n    else {\n      var k = this.n * Math.sin(lat);\n      for (var i = MAX_ITER; i; --i) {\n        var V = (this.m * lat + Math.sin(lat) - k) / (this.m + Math.cos(lat));\n        lat -= V;\n        if (Math.abs(V) < EPSLN) {\n          break;\n        }\n      }\n    }\n    x = this.a * this.C_x * lon * (this.m + Math.cos(lat));\n    y = this.a * this.C_y * lat;\n\n  }\n  else {\n\n    var s = Math.sin(lat);\n    var c = Math.cos(lat);\n    y = this.a * pj_mlfn(lat, s, c, this.en);\n    x = this.a * lon * c / Math.sqrt(1 - this.es * s * s);\n  }\n\n  p.x = x;\n  p.y = y;\n  return p;\n};\n\nexports.inverse = function(p) {\n  var lat, temp, lon, s;\n\n  p.x -= this.x0;\n  lon = p.x / this.a;\n  p.y -= this.y0;\n  lat = p.y / this.a;\n\n  if (this.sphere) {\n    lat /= this.C_y;\n    lon = lon / (this.C_x * (this.m + Math.cos(lat)));\n    if (this.m) {\n      lat = asinz((this.m * lat + Math.sin(lat)) / this.n);\n    }\n    else if (this.n !== 1) {\n      lat = asinz(Math.sin(lat) / this.n);\n    }\n    lon = adjust_lon(lon + this.long0);\n    lat = adjust_lat(lat);\n  }\n  else {\n    lat = pj_inv_mlfn(p.y / this.a, this.es, this.en);\n    s = Math.abs(lat);\n    if (s < HALF_PI) {\n      s = Math.sin(lat);\n      temp = this.long0 + p.x * Math.sqrt(1 - this.es * s * s) / (this.a * Math.cos(lat));\n      //temp = this.long0 + p.x / (this.a * Math.cos(lat));\n      lon = adjust_lon(temp);\n    }\n    else if ((s - EPSLN) < HALF_PI) {\n      lon = this.long0;\n    }\n  }\n  p.x = lon;\n  p.y = lat;\n  return p;\n};\nexports.names = ["Sinusoidal", "sinu"];//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9zaW51LmpzPzA4YzEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLEdBQUc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxNTYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYWRqdXN0X2xvbiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9hZGp1c3RfbG9uJyk7XG52YXIgYWRqdXN0X2xhdCA9IHJlcXVpcmUoJy4uL2NvbW1vbi9hZGp1c3RfbGF0Jyk7XG52YXIgcGpfZW5mbiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9wal9lbmZuJyk7XG52YXIgTUFYX0lURVIgPSAyMDtcbnZhciBwal9tbGZuID0gcmVxdWlyZSgnLi4vY29tbW9uL3BqX21sZm4nKTtcbnZhciBwal9pbnZfbWxmbiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9wal9pbnZfbWxmbicpO1xudmFyIEhBTEZfUEkgPSBNYXRoLlBJLzI7XG52YXIgRVBTTE4gPSAxLjBlLTEwO1xudmFyIGFzaW56ID0gcmVxdWlyZSgnLi4vY29tbW9uL2FzaW56Jyk7XG5leHBvcnRzLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgLyogUGxhY2UgcGFyYW1ldGVycyBpbiBzdGF0aWMgc3RvcmFnZSBmb3IgY29tbW9uIHVzZVxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cbiAgaWYgKCF0aGlzLnNwaGVyZSkge1xuICAgIHRoaXMuZW4gPSBwal9lbmZuKHRoaXMuZXMpO1xuICB9XG4gIGVsc2Uge1xuICAgIHRoaXMubiA9IDE7XG4gICAgdGhpcy5tID0gMDtcbiAgICB0aGlzLmVzID0gMDtcbiAgICB0aGlzLkNfeSA9IE1hdGguc3FydCgodGhpcy5tICsgMSkgLyB0aGlzLm4pO1xuICAgIHRoaXMuQ194ID0gdGhpcy5DX3kgLyAodGhpcy5tICsgMSk7XG4gIH1cblxufTtcblxuLyogU2ludXNvaWRhbCBmb3J3YXJkIGVxdWF0aW9ucy0tbWFwcGluZyBsYXQsbG9uZyB0byB4LHlcbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZXhwb3J0cy5mb3J3YXJkID0gZnVuY3Rpb24ocCkge1xuICB2YXIgeCwgeTtcbiAgdmFyIGxvbiA9IHAueDtcbiAgdmFyIGxhdCA9IHAueTtcbiAgLyogRm9yd2FyZCBlcXVhdGlvbnNcbiAgICAtLS0tLS0tLS0tLS0tLS0tLSovXG4gIGxvbiA9IGFkanVzdF9sb24obG9uIC0gdGhpcy5sb25nMCk7XG5cbiAgaWYgKHRoaXMuc3BoZXJlKSB7XG4gICAgaWYgKCF0aGlzLm0pIHtcbiAgICAgIGxhdCA9IHRoaXMubiAhPT0gMSA/IE1hdGguYXNpbih0aGlzLm4gKiBNYXRoLnNpbihsYXQpKSA6IGxhdDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgayA9IHRoaXMubiAqIE1hdGguc2luKGxhdCk7XG4gICAgICBmb3IgKHZhciBpID0gTUFYX0lURVI7IGk7IC0taSkge1xuICAgICAgICB2YXIgViA9ICh0aGlzLm0gKiBsYXQgKyBNYXRoLnNpbihsYXQpIC0gaykgLyAodGhpcy5tICsgTWF0aC5jb3MobGF0KSk7XG4gICAgICAgIGxhdCAtPSBWO1xuICAgICAgICBpZiAoTWF0aC5hYnMoVikgPCBFUFNMTikge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHggPSB0aGlzLmEgKiB0aGlzLkNfeCAqIGxvbiAqICh0aGlzLm0gKyBNYXRoLmNvcyhsYXQpKTtcbiAgICB5ID0gdGhpcy5hICogdGhpcy5DX3kgKiBsYXQ7XG5cbiAgfVxuICBlbHNlIHtcblxuICAgIHZhciBzID0gTWF0aC5zaW4obGF0KTtcbiAgICB2YXIgYyA9IE1hdGguY29zKGxhdCk7XG4gICAgeSA9IHRoaXMuYSAqIHBqX21sZm4obGF0LCBzLCBjLCB0aGlzLmVuKTtcbiAgICB4ID0gdGhpcy5hICogbG9uICogYyAvIE1hdGguc3FydCgxIC0gdGhpcy5lcyAqIHMgKiBzKTtcbiAgfVxuXG4gIHAueCA9IHg7XG4gIHAueSA9IHk7XG4gIHJldHVybiBwO1xufTtcblxuZXhwb3J0cy5pbnZlcnNlID0gZnVuY3Rpb24ocCkge1xuICB2YXIgbGF0LCB0ZW1wLCBsb24sIHM7XG5cbiAgcC54IC09IHRoaXMueDA7XG4gIGxvbiA9IHAueCAvIHRoaXMuYTtcbiAgcC55IC09IHRoaXMueTA7XG4gIGxhdCA9IHAueSAvIHRoaXMuYTtcblxuICBpZiAodGhpcy5zcGhlcmUpIHtcbiAgICBsYXQgLz0gdGhpcy5DX3k7XG4gICAgbG9uID0gbG9uIC8gKHRoaXMuQ194ICogKHRoaXMubSArIE1hdGguY29zKGxhdCkpKTtcbiAgICBpZiAodGhpcy5tKSB7XG4gICAgICBsYXQgPSBhc2lueigodGhpcy5tICogbGF0ICsgTWF0aC5zaW4obGF0KSkgLyB0aGlzLm4pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLm4gIT09IDEpIHtcbiAgICAgIGxhdCA9IGFzaW56KE1hdGguc2luKGxhdCkgLyB0aGlzLm4pO1xuICAgIH1cbiAgICBsb24gPSBhZGp1c3RfbG9uKGxvbiArIHRoaXMubG9uZzApO1xuICAgIGxhdCA9IGFkanVzdF9sYXQobGF0KTtcbiAgfVxuICBlbHNlIHtcbiAgICBsYXQgPSBwal9pbnZfbWxmbihwLnkgLyB0aGlzLmEsIHRoaXMuZXMsIHRoaXMuZW4pO1xuICAgIHMgPSBNYXRoLmFicyhsYXQpO1xuICAgIGlmIChzIDwgSEFMRl9QSSkge1xuICAgICAgcyA9IE1hdGguc2luKGxhdCk7XG4gICAgICB0ZW1wID0gdGhpcy5sb25nMCArIHAueCAqIE1hdGguc3FydCgxIC0gdGhpcy5lcyAqIHMgKiBzKSAvICh0aGlzLmEgKiBNYXRoLmNvcyhsYXQpKTtcbiAgICAgIC8vdGVtcCA9IHRoaXMubG9uZzAgKyBwLnggLyAodGhpcy5hICogTWF0aC5jb3MobGF0KSk7XG4gICAgICBsb24gPSBhZGp1c3RfbG9uKHRlbXApO1xuICAgIH1cbiAgICBlbHNlIGlmICgocyAtIEVQU0xOKSA8IEhBTEZfUEkpIHtcbiAgICAgIGxvbiA9IHRoaXMubG9uZzA7XG4gICAgfVxuICB9XG4gIHAueCA9IGxvbjtcbiAgcC55ID0gbGF0O1xuICByZXR1cm4gcDtcbn07XG5leHBvcnRzLm5hbWVzID0gW1wiU2ludXNvaWRhbFwiLCBcInNpbnVcIl07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9zaW51LmpzXG4vLyBtb2R1bGUgaWQgPSAxNTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports){eval('/*\n  references:\n    Formules et constantes pour le Calcul pour la\n    projection cylindrique conforme  axe oblique et pour la transformation entre\n    des systmes de rfrence.\n    http://www.swisstopo.admin.ch/internet/swisstopo/fr/home/topics/survey/sys/refsys/switzerland.parsysrelated1.31216.downloadList.77004.DownloadFile.tmp/swissprojectionfr.pdf\n  */\nexports.init = function() {\n  var phy0 = this.lat0;\n  this.lambda0 = this.long0;\n  var sinPhy0 = Math.sin(phy0);\n  var semiMajorAxis = this.a;\n  var invF = this.rf;\n  var flattening = 1 / invF;\n  var e2 = 2 * flattening - Math.pow(flattening, 2);\n  var e = this.e = Math.sqrt(e2);\n  this.R = this.k0 * semiMajorAxis * Math.sqrt(1 - e2) / (1 - e2 * Math.pow(sinPhy0, 2));\n  this.alpha = Math.sqrt(1 + e2 / (1 - e2) * Math.pow(Math.cos(phy0), 4));\n  this.b0 = Math.asin(sinPhy0 / this.alpha);\n  var k1 = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2));\n  var k2 = Math.log(Math.tan(Math.PI / 4 + phy0 / 2));\n  var k3 = Math.log((1 + e * sinPhy0) / (1 - e * sinPhy0));\n  this.K = k1 - this.alpha * k2 + this.alpha * e / 2 * k3;\n};\n\n\nexports.forward = function(p) {\n  var Sa1 = Math.log(Math.tan(Math.PI / 4 - p.y / 2));\n  var Sa2 = this.e / 2 * Math.log((1 + this.e * Math.sin(p.y)) / (1 - this.e * Math.sin(p.y)));\n  var S = -this.alpha * (Sa1 + Sa2) + this.K;\n\n  // spheric latitude\n  var b = 2 * (Math.atan(Math.exp(S)) - Math.PI / 4);\n\n  // spheric longitude\n  var I = this.alpha * (p.x - this.lambda0);\n\n  // psoeudo equatorial rotation\n  var rotI = Math.atan(Math.sin(I) / (Math.sin(this.b0) * Math.tan(b) + Math.cos(this.b0) * Math.cos(I)));\n\n  var rotB = Math.asin(Math.cos(this.b0) * Math.sin(b) - Math.sin(this.b0) * Math.cos(b) * Math.cos(I));\n\n  p.y = this.R / 2 * Math.log((1 + Math.sin(rotB)) / (1 - Math.sin(rotB))) + this.y0;\n  p.x = this.R * rotI + this.x0;\n  return p;\n};\n\nexports.inverse = function(p) {\n  var Y = p.x - this.x0;\n  var X = p.y - this.y0;\n\n  var rotI = Y / this.R;\n  var rotB = 2 * (Math.atan(Math.exp(X / this.R)) - Math.PI / 4);\n\n  var b = Math.asin(Math.cos(this.b0) * Math.sin(rotB) + Math.sin(this.b0) * Math.cos(rotB) * Math.cos(rotI));\n  var I = Math.atan(Math.sin(rotI) / (Math.cos(this.b0) * Math.cos(rotI) - Math.sin(this.b0) * Math.tan(rotB)));\n\n  var lambda = this.lambda0 + I / this.alpha;\n\n  var S = 0;\n  var phy = b;\n  var prevPhy = -1000;\n  var iteration = 0;\n  while (Math.abs(phy - prevPhy) > 0.0000001) {\n    if (++iteration > 20) {\n      //...reportError("omercFwdInfinity");\n      return;\n    }\n    //S = Math.log(Math.tan(Math.PI / 4 + phy / 2));\n    S = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + b / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(phy)) / 2));\n    prevPhy = phy;\n    phy = 2 * Math.atan(Math.exp(S)) - Math.PI / 2;\n  }\n\n  p.x = lambda;\n  p.y = phy;\n  return p;\n};\n\nexports.names = ["somerc"];\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9zb21lcmMuanM/ZWU0NyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIxNTcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICByZWZlcmVuY2VzOlxuICAgIEZvcm11bGVzIGV0IGNvbnN0YW50ZXMgcG91ciBsZSBDYWxjdWwgcG91ciBsYVxuICAgIHByb2plY3Rpb24gY3lsaW5kcmlxdWUgY29uZm9ybWUgw6AgYXhlIG9ibGlxdWUgZXQgcG91ciBsYSB0cmFuc2Zvcm1hdGlvbiBlbnRyZVxuICAgIGRlcyBzeXN0w6htZXMgZGUgcsOpZsOpcmVuY2UuXG4gICAgaHR0cDovL3d3dy5zd2lzc3RvcG8uYWRtaW4uY2gvaW50ZXJuZXQvc3dpc3N0b3BvL2ZyL2hvbWUvdG9waWNzL3N1cnZleS9zeXMvcmVmc3lzL3N3aXR6ZXJsYW5kLnBhcnN5c3JlbGF0ZWQxLjMxMjE2LmRvd25sb2FkTGlzdC43NzAwNC5Eb3dubG9hZEZpbGUudG1wL3N3aXNzcHJvamVjdGlvbmZyLnBkZlxuICAqL1xuZXhwb3J0cy5pbml0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwaHkwID0gdGhpcy5sYXQwO1xuICB0aGlzLmxhbWJkYTAgPSB0aGlzLmxvbmcwO1xuICB2YXIgc2luUGh5MCA9IE1hdGguc2luKHBoeTApO1xuICB2YXIgc2VtaU1ham9yQXhpcyA9IHRoaXMuYTtcbiAgdmFyIGludkYgPSB0aGlzLnJmO1xuICB2YXIgZmxhdHRlbmluZyA9IDEgLyBpbnZGO1xuICB2YXIgZTIgPSAyICogZmxhdHRlbmluZyAtIE1hdGgucG93KGZsYXR0ZW5pbmcsIDIpO1xuICB2YXIgZSA9IHRoaXMuZSA9IE1hdGguc3FydChlMik7XG4gIHRoaXMuUiA9IHRoaXMuazAgKiBzZW1pTWFqb3JBeGlzICogTWF0aC5zcXJ0KDEgLSBlMikgLyAoMSAtIGUyICogTWF0aC5wb3coc2luUGh5MCwgMikpO1xuICB0aGlzLmFscGhhID0gTWF0aC5zcXJ0KDEgKyBlMiAvICgxIC0gZTIpICogTWF0aC5wb3coTWF0aC5jb3MocGh5MCksIDQpKTtcbiAgdGhpcy5iMCA9IE1hdGguYXNpbihzaW5QaHkwIC8gdGhpcy5hbHBoYSk7XG4gIHZhciBrMSA9IE1hdGgubG9nKE1hdGgudGFuKE1hdGguUEkgLyA0ICsgdGhpcy5iMCAvIDIpKTtcbiAgdmFyIGsyID0gTWF0aC5sb2coTWF0aC50YW4oTWF0aC5QSSAvIDQgKyBwaHkwIC8gMikpO1xuICB2YXIgazMgPSBNYXRoLmxvZygoMSArIGUgKiBzaW5QaHkwKSAvICgxIC0gZSAqIHNpblBoeTApKTtcbiAgdGhpcy5LID0gazEgLSB0aGlzLmFscGhhICogazIgKyB0aGlzLmFscGhhICogZSAvIDIgKiBrMztcbn07XG5cblxuZXhwb3J0cy5mb3J3YXJkID0gZnVuY3Rpb24ocCkge1xuICB2YXIgU2ExID0gTWF0aC5sb2coTWF0aC50YW4oTWF0aC5QSSAvIDQgLSBwLnkgLyAyKSk7XG4gIHZhciBTYTIgPSB0aGlzLmUgLyAyICogTWF0aC5sb2coKDEgKyB0aGlzLmUgKiBNYXRoLnNpbihwLnkpKSAvICgxIC0gdGhpcy5lICogTWF0aC5zaW4ocC55KSkpO1xuICB2YXIgUyA9IC10aGlzLmFscGhhICogKFNhMSArIFNhMikgKyB0aGlzLks7XG5cbiAgLy8gc3BoZXJpYyBsYXRpdHVkZVxuICB2YXIgYiA9IDIgKiAoTWF0aC5hdGFuKE1hdGguZXhwKFMpKSAtIE1hdGguUEkgLyA0KTtcblxuICAvLyBzcGhlcmljIGxvbmdpdHVkZVxuICB2YXIgSSA9IHRoaXMuYWxwaGEgKiAocC54IC0gdGhpcy5sYW1iZGEwKTtcblxuICAvLyBwc29ldWRvIGVxdWF0b3JpYWwgcm90YXRpb25cbiAgdmFyIHJvdEkgPSBNYXRoLmF0YW4oTWF0aC5zaW4oSSkgLyAoTWF0aC5zaW4odGhpcy5iMCkgKiBNYXRoLnRhbihiKSArIE1hdGguY29zKHRoaXMuYjApICogTWF0aC5jb3MoSSkpKTtcblxuICB2YXIgcm90QiA9IE1hdGguYXNpbihNYXRoLmNvcyh0aGlzLmIwKSAqIE1hdGguc2luKGIpIC0gTWF0aC5zaW4odGhpcy5iMCkgKiBNYXRoLmNvcyhiKSAqIE1hdGguY29zKEkpKTtcblxuICBwLnkgPSB0aGlzLlIgLyAyICogTWF0aC5sb2coKDEgKyBNYXRoLnNpbihyb3RCKSkgLyAoMSAtIE1hdGguc2luKHJvdEIpKSkgKyB0aGlzLnkwO1xuICBwLnggPSB0aGlzLlIgKiByb3RJICsgdGhpcy54MDtcbiAgcmV0dXJuIHA7XG59O1xuXG5leHBvcnRzLmludmVyc2UgPSBmdW5jdGlvbihwKSB7XG4gIHZhciBZID0gcC54IC0gdGhpcy54MDtcbiAgdmFyIFggPSBwLnkgLSB0aGlzLnkwO1xuXG4gIHZhciByb3RJID0gWSAvIHRoaXMuUjtcbiAgdmFyIHJvdEIgPSAyICogKE1hdGguYXRhbihNYXRoLmV4cChYIC8gdGhpcy5SKSkgLSBNYXRoLlBJIC8gNCk7XG5cbiAgdmFyIGIgPSBNYXRoLmFzaW4oTWF0aC5jb3ModGhpcy5iMCkgKiBNYXRoLnNpbihyb3RCKSArIE1hdGguc2luKHRoaXMuYjApICogTWF0aC5jb3Mocm90QikgKiBNYXRoLmNvcyhyb3RJKSk7XG4gIHZhciBJID0gTWF0aC5hdGFuKE1hdGguc2luKHJvdEkpIC8gKE1hdGguY29zKHRoaXMuYjApICogTWF0aC5jb3Mocm90SSkgLSBNYXRoLnNpbih0aGlzLmIwKSAqIE1hdGgudGFuKHJvdEIpKSk7XG5cbiAgdmFyIGxhbWJkYSA9IHRoaXMubGFtYmRhMCArIEkgLyB0aGlzLmFscGhhO1xuXG4gIHZhciBTID0gMDtcbiAgdmFyIHBoeSA9IGI7XG4gIHZhciBwcmV2UGh5ID0gLTEwMDA7XG4gIHZhciBpdGVyYXRpb24gPSAwO1xuICB3aGlsZSAoTWF0aC5hYnMocGh5IC0gcHJldlBoeSkgPiAwLjAwMDAwMDEpIHtcbiAgICBpZiAoKytpdGVyYXRpb24gPiAyMCkge1xuICAgICAgLy8uLi5yZXBvcnRFcnJvcihcIm9tZXJjRndkSW5maW5pdHlcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vUyA9IE1hdGgubG9nKE1hdGgudGFuKE1hdGguUEkgLyA0ICsgcGh5IC8gMikpO1xuICAgIFMgPSAxIC8gdGhpcy5hbHBoYSAqIChNYXRoLmxvZyhNYXRoLnRhbihNYXRoLlBJIC8gNCArIGIgLyAyKSkgLSB0aGlzLkspICsgdGhpcy5lICogTWF0aC5sb2coTWF0aC50YW4oTWF0aC5QSSAvIDQgKyBNYXRoLmFzaW4odGhpcy5lICogTWF0aC5zaW4ocGh5KSkgLyAyKSk7XG4gICAgcHJldlBoeSA9IHBoeTtcbiAgICBwaHkgPSAyICogTWF0aC5hdGFuKE1hdGguZXhwKFMpKSAtIE1hdGguUEkgLyAyO1xuICB9XG5cbiAgcC54ID0gbGFtYmRhO1xuICBwLnkgPSBwaHk7XG4gIHJldHVybiBwO1xufTtcblxuZXhwb3J0cy5uYW1lcyA9IFtcInNvbWVyY1wiXTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcm9qNC9saWIvcHJvamVjdGlvbnMvc29tZXJjLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports,__webpack_require__){eval("var HALF_PI = Math.PI/2;\nvar EPSLN = 1.0e-10;\nvar sign = __webpack_require__(17);\nvar msfnz = __webpack_require__(8);\nvar tsfnz = __webpack_require__(22);\nvar phi2z = __webpack_require__(21);\nvar adjust_lon = __webpack_require__(0);\nexports.ssfn_ = function(phit, sinphi, eccen) {\n  sinphi *= eccen;\n  return (Math.tan(0.5 * (HALF_PI + phit)) * Math.pow((1 - sinphi) / (1 + sinphi), 0.5 * eccen));\n};\n\nexports.init = function() {\n  this.coslat0 = Math.cos(this.lat0);\n  this.sinlat0 = Math.sin(this.lat0);\n  if (this.sphere) {\n    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {\n      this.k0 = 0.5 * (1 + sign(this.lat0) * Math.sin(this.lat_ts));\n    }\n  }\n  else {\n    if (Math.abs(this.coslat0) <= EPSLN) {\n      if (this.lat0 > 0) {\n        //North pole\n        //trace('stere:north pole');\n        this.con = 1;\n      }\n      else {\n        //South pole\n        //trace('stere:south pole');\n        this.con = -1;\n      }\n    }\n    this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e));\n    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {\n      this.k0 = 0.5 * this.cons * msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / tsfnz(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts));\n    }\n    this.ms1 = msfnz(this.e, this.sinlat0, this.coslat0);\n    this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - HALF_PI;\n    this.cosX0 = Math.cos(this.X0);\n    this.sinX0 = Math.sin(this.X0);\n  }\n};\n\n// Stereographic forward equations--mapping lat,long to x,y\nexports.forward = function(p) {\n  var lon = p.x;\n  var lat = p.y;\n  var sinlat = Math.sin(lat);\n  var coslat = Math.cos(lat);\n  var A, X, sinX, cosX, ts, rh;\n  var dlon = adjust_lon(lon - this.long0);\n\n  if (Math.abs(Math.abs(lon - this.long0) - Math.PI) <= EPSLN && Math.abs(lat + this.lat0) <= EPSLN) {\n    //case of the origine point\n    //trace('stere:this is the origin point');\n    p.x = NaN;\n    p.y = NaN;\n    return p;\n  }\n  if (this.sphere) {\n    //trace('stere:sphere case');\n    A = 2 * this.k0 / (1 + this.sinlat0 * sinlat + this.coslat0 * coslat * Math.cos(dlon));\n    p.x = this.a * A * coslat * Math.sin(dlon) + this.x0;\n    p.y = this.a * A * (this.coslat0 * sinlat - this.sinlat0 * coslat * Math.cos(dlon)) + this.y0;\n    return p;\n  }\n  else {\n    X = 2 * Math.atan(this.ssfn_(lat, sinlat, this.e)) - HALF_PI;\n    cosX = Math.cos(X);\n    sinX = Math.sin(X);\n    if (Math.abs(this.coslat0) <= EPSLN) {\n      ts = tsfnz(this.e, lat * this.con, this.con * sinlat);\n      rh = 2 * this.a * this.k0 * ts / this.cons;\n      p.x = this.x0 + rh * Math.sin(lon - this.long0);\n      p.y = this.y0 - this.con * rh * Math.cos(lon - this.long0);\n      //trace(p.toString());\n      return p;\n    }\n    else if (Math.abs(this.sinlat0) < EPSLN) {\n      //Eq\n      //trace('stere:equateur');\n      A = 2 * this.a * this.k0 / (1 + cosX * Math.cos(dlon));\n      p.y = A * sinX;\n    }\n    else {\n      //other case\n      //trace('stere:normal case');\n      A = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * sinX + this.cosX0 * cosX * Math.cos(dlon)));\n      p.y = A * (this.cosX0 * sinX - this.sinX0 * cosX * Math.cos(dlon)) + this.y0;\n    }\n    p.x = A * cosX * Math.sin(dlon) + this.x0;\n  }\n  //trace(p.toString());\n  return p;\n};\n\n\n//* Stereographic inverse equations--mapping x,y to lat/long\nexports.inverse = function(p) {\n  p.x -= this.x0;\n  p.y -= this.y0;\n  var lon, lat, ts, ce, Chi;\n  var rh = Math.sqrt(p.x * p.x + p.y * p.y);\n  if (this.sphere) {\n    var c = 2 * Math.atan(rh / (0.5 * this.a * this.k0));\n    lon = this.long0;\n    lat = this.lat0;\n    if (rh <= EPSLN) {\n      p.x = lon;\n      p.y = lat;\n      return p;\n    }\n    lat = Math.asin(Math.cos(c) * this.sinlat0 + p.y * Math.sin(c) * this.coslat0 / rh);\n    if (Math.abs(this.coslat0) < EPSLN) {\n      if (this.lat0 > 0) {\n        lon = adjust_lon(this.long0 + Math.atan2(p.x, - 1 * p.y));\n      }\n      else {\n        lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));\n      }\n    }\n    else {\n      lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(c), rh * this.coslat0 * Math.cos(c) - p.y * this.sinlat0 * Math.sin(c)));\n    }\n    p.x = lon;\n    p.y = lat;\n    return p;\n  }\n  else {\n    if (Math.abs(this.coslat0) <= EPSLN) {\n      if (rh <= EPSLN) {\n        lat = this.lat0;\n        lon = this.long0;\n        p.x = lon;\n        p.y = lat;\n        //trace(p.toString());\n        return p;\n      }\n      p.x *= this.con;\n      p.y *= this.con;\n      ts = rh * this.cons / (2 * this.a * this.k0);\n      lat = this.con * phi2z(this.e, ts);\n      lon = this.con * adjust_lon(this.con * this.long0 + Math.atan2(p.x, - 1 * p.y));\n    }\n    else {\n      ce = 2 * Math.atan(rh * this.cosX0 / (2 * this.a * this.k0 * this.ms1));\n      lon = this.long0;\n      if (rh <= EPSLN) {\n        Chi = this.X0;\n      }\n      else {\n        Chi = Math.asin(Math.cos(ce) * this.sinX0 + p.y * Math.sin(ce) * this.cosX0 / rh);\n        lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(ce), rh * this.cosX0 * Math.cos(ce) - p.y * this.sinX0 * Math.sin(ce)));\n      }\n      lat = -1 * phi2z(this.e, Math.tan(0.5 * (HALF_PI + Chi)));\n    }\n  }\n  p.x = lon;\n  p.y = lat;\n\n  //trace(p.toString());\n  return p;\n\n};\nexports.names = [\"stere\", \"Stereographic_South_Pole\", \"Polar Stereographic (variant B)\"];\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9zdGVyZS5qcz82ZGYyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EiLCJmaWxlIjoiMTU4LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIEhBTEZfUEkgPSBNYXRoLlBJLzI7XG52YXIgRVBTTE4gPSAxLjBlLTEwO1xudmFyIHNpZ24gPSByZXF1aXJlKCcuLi9jb21tb24vc2lnbicpO1xudmFyIG1zZm56ID0gcmVxdWlyZSgnLi4vY29tbW9uL21zZm56Jyk7XG52YXIgdHNmbnogPSByZXF1aXJlKCcuLi9jb21tb24vdHNmbnonKTtcbnZhciBwaGkyeiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9waGkyeicpO1xudmFyIGFkanVzdF9sb24gPSByZXF1aXJlKCcuLi9jb21tb24vYWRqdXN0X2xvbicpO1xuZXhwb3J0cy5zc2ZuXyA9IGZ1bmN0aW9uKHBoaXQsIHNpbnBoaSwgZWNjZW4pIHtcbiAgc2lucGhpICo9IGVjY2VuO1xuICByZXR1cm4gKE1hdGgudGFuKDAuNSAqIChIQUxGX1BJICsgcGhpdCkpICogTWF0aC5wb3coKDEgLSBzaW5waGkpIC8gKDEgKyBzaW5waGkpLCAwLjUgKiBlY2NlbikpO1xufTtcblxuZXhwb3J0cy5pbml0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuY29zbGF0MCA9IE1hdGguY29zKHRoaXMubGF0MCk7XG4gIHRoaXMuc2lubGF0MCA9IE1hdGguc2luKHRoaXMubGF0MCk7XG4gIGlmICh0aGlzLnNwaGVyZSkge1xuICAgIGlmICh0aGlzLmswID09PSAxICYmICFpc05hTih0aGlzLmxhdF90cykgJiYgTWF0aC5hYnModGhpcy5jb3NsYXQwKSA8PSBFUFNMTikge1xuICAgICAgdGhpcy5rMCA9IDAuNSAqICgxICsgc2lnbih0aGlzLmxhdDApICogTWF0aC5zaW4odGhpcy5sYXRfdHMpKTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgaWYgKE1hdGguYWJzKHRoaXMuY29zbGF0MCkgPD0gRVBTTE4pIHtcbiAgICAgIGlmICh0aGlzLmxhdDAgPiAwKSB7XG4gICAgICAgIC8vTm9ydGggcG9sZVxuICAgICAgICAvL3RyYWNlKCdzdGVyZTpub3J0aCBwb2xlJyk7XG4gICAgICAgIHRoaXMuY29uID0gMTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvL1NvdXRoIHBvbGVcbiAgICAgICAgLy90cmFjZSgnc3RlcmU6c291dGggcG9sZScpO1xuICAgICAgICB0aGlzLmNvbiA9IC0xO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNvbnMgPSBNYXRoLnNxcnQoTWF0aC5wb3coMSArIHRoaXMuZSwgMSArIHRoaXMuZSkgKiBNYXRoLnBvdygxIC0gdGhpcy5lLCAxIC0gdGhpcy5lKSk7XG4gICAgaWYgKHRoaXMuazAgPT09IDEgJiYgIWlzTmFOKHRoaXMubGF0X3RzKSAmJiBNYXRoLmFicyh0aGlzLmNvc2xhdDApIDw9IEVQU0xOKSB7XG4gICAgICB0aGlzLmswID0gMC41ICogdGhpcy5jb25zICogbXNmbnoodGhpcy5lLCBNYXRoLnNpbih0aGlzLmxhdF90cyksIE1hdGguY29zKHRoaXMubGF0X3RzKSkgLyB0c2Zueih0aGlzLmUsIHRoaXMuY29uICogdGhpcy5sYXRfdHMsIHRoaXMuY29uICogTWF0aC5zaW4odGhpcy5sYXRfdHMpKTtcbiAgICB9XG4gICAgdGhpcy5tczEgPSBtc2Zueih0aGlzLmUsIHRoaXMuc2lubGF0MCwgdGhpcy5jb3NsYXQwKTtcbiAgICB0aGlzLlgwID0gMiAqIE1hdGguYXRhbih0aGlzLnNzZm5fKHRoaXMubGF0MCwgdGhpcy5zaW5sYXQwLCB0aGlzLmUpKSAtIEhBTEZfUEk7XG4gICAgdGhpcy5jb3NYMCA9IE1hdGguY29zKHRoaXMuWDApO1xuICAgIHRoaXMuc2luWDAgPSBNYXRoLnNpbih0aGlzLlgwKTtcbiAgfVxufTtcblxuLy8gU3RlcmVvZ3JhcGhpYyBmb3J3YXJkIGVxdWF0aW9ucy0tbWFwcGluZyBsYXQsbG9uZyB0byB4LHlcbmV4cG9ydHMuZm9yd2FyZCA9IGZ1bmN0aW9uKHApIHtcbiAgdmFyIGxvbiA9IHAueDtcbiAgdmFyIGxhdCA9IHAueTtcbiAgdmFyIHNpbmxhdCA9IE1hdGguc2luKGxhdCk7XG4gIHZhciBjb3NsYXQgPSBNYXRoLmNvcyhsYXQpO1xuICB2YXIgQSwgWCwgc2luWCwgY29zWCwgdHMsIHJoO1xuICB2YXIgZGxvbiA9IGFkanVzdF9sb24obG9uIC0gdGhpcy5sb25nMCk7XG5cbiAgaWYgKE1hdGguYWJzKE1hdGguYWJzKGxvbiAtIHRoaXMubG9uZzApIC0gTWF0aC5QSSkgPD0gRVBTTE4gJiYgTWF0aC5hYnMobGF0ICsgdGhpcy5sYXQwKSA8PSBFUFNMTikge1xuICAgIC8vY2FzZSBvZiB0aGUgb3JpZ2luZSBwb2ludFxuICAgIC8vdHJhY2UoJ3N0ZXJlOnRoaXMgaXMgdGhlIG9yaWdpbiBwb2ludCcpO1xuICAgIHAueCA9IE5hTjtcbiAgICBwLnkgPSBOYU47XG4gICAgcmV0dXJuIHA7XG4gIH1cbiAgaWYgKHRoaXMuc3BoZXJlKSB7XG4gICAgLy90cmFjZSgnc3RlcmU6c3BoZXJlIGNhc2UnKTtcbiAgICBBID0gMiAqIHRoaXMuazAgLyAoMSArIHRoaXMuc2lubGF0MCAqIHNpbmxhdCArIHRoaXMuY29zbGF0MCAqIGNvc2xhdCAqIE1hdGguY29zKGRsb24pKTtcbiAgICBwLnggPSB0aGlzLmEgKiBBICogY29zbGF0ICogTWF0aC5zaW4oZGxvbikgKyB0aGlzLngwO1xuICAgIHAueSA9IHRoaXMuYSAqIEEgKiAodGhpcy5jb3NsYXQwICogc2lubGF0IC0gdGhpcy5zaW5sYXQwICogY29zbGF0ICogTWF0aC5jb3MoZGxvbikpICsgdGhpcy55MDtcbiAgICByZXR1cm4gcDtcbiAgfVxuICBlbHNlIHtcbiAgICBYID0gMiAqIE1hdGguYXRhbih0aGlzLnNzZm5fKGxhdCwgc2lubGF0LCB0aGlzLmUpKSAtIEhBTEZfUEk7XG4gICAgY29zWCA9IE1hdGguY29zKFgpO1xuICAgIHNpblggPSBNYXRoLnNpbihYKTtcbiAgICBpZiAoTWF0aC5hYnModGhpcy5jb3NsYXQwKSA8PSBFUFNMTikge1xuICAgICAgdHMgPSB0c2Zueih0aGlzLmUsIGxhdCAqIHRoaXMuY29uLCB0aGlzLmNvbiAqIHNpbmxhdCk7XG4gICAgICByaCA9IDIgKiB0aGlzLmEgKiB0aGlzLmswICogdHMgLyB0aGlzLmNvbnM7XG4gICAgICBwLnggPSB0aGlzLngwICsgcmggKiBNYXRoLnNpbihsb24gLSB0aGlzLmxvbmcwKTtcbiAgICAgIHAueSA9IHRoaXMueTAgLSB0aGlzLmNvbiAqIHJoICogTWF0aC5jb3MobG9uIC0gdGhpcy5sb25nMCk7XG4gICAgICAvL3RyYWNlKHAudG9TdHJpbmcoKSk7XG4gICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgZWxzZSBpZiAoTWF0aC5hYnModGhpcy5zaW5sYXQwKSA8IEVQU0xOKSB7XG4gICAgICAvL0VxXG4gICAgICAvL3RyYWNlKCdzdGVyZTplcXVhdGV1cicpO1xuICAgICAgQSA9IDIgKiB0aGlzLmEgKiB0aGlzLmswIC8gKDEgKyBjb3NYICogTWF0aC5jb3MoZGxvbikpO1xuICAgICAgcC55ID0gQSAqIHNpblg7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy9vdGhlciBjYXNlXG4gICAgICAvL3RyYWNlKCdzdGVyZTpub3JtYWwgY2FzZScpO1xuICAgICAgQSA9IDIgKiB0aGlzLmEgKiB0aGlzLmswICogdGhpcy5tczEgLyAodGhpcy5jb3NYMCAqICgxICsgdGhpcy5zaW5YMCAqIHNpblggKyB0aGlzLmNvc1gwICogY29zWCAqIE1hdGguY29zKGRsb24pKSk7XG4gICAgICBwLnkgPSBBICogKHRoaXMuY29zWDAgKiBzaW5YIC0gdGhpcy5zaW5YMCAqIGNvc1ggKiBNYXRoLmNvcyhkbG9uKSkgKyB0aGlzLnkwO1xuICAgIH1cbiAgICBwLnggPSBBICogY29zWCAqIE1hdGguc2luKGRsb24pICsgdGhpcy54MDtcbiAgfVxuICAvL3RyYWNlKHAudG9TdHJpbmcoKSk7XG4gIHJldHVybiBwO1xufTtcblxuXG4vLyogU3RlcmVvZ3JhcGhpYyBpbnZlcnNlIGVxdWF0aW9ucy0tbWFwcGluZyB4LHkgdG8gbGF0L2xvbmdcbmV4cG9ydHMuaW52ZXJzZSA9IGZ1bmN0aW9uKHApIHtcbiAgcC54IC09IHRoaXMueDA7XG4gIHAueSAtPSB0aGlzLnkwO1xuICB2YXIgbG9uLCBsYXQsIHRzLCBjZSwgQ2hpO1xuICB2YXIgcmggPSBNYXRoLnNxcnQocC54ICogcC54ICsgcC55ICogcC55KTtcbiAgaWYgKHRoaXMuc3BoZXJlKSB7XG4gICAgdmFyIGMgPSAyICogTWF0aC5hdGFuKHJoIC8gKDAuNSAqIHRoaXMuYSAqIHRoaXMuazApKTtcbiAgICBsb24gPSB0aGlzLmxvbmcwO1xuICAgIGxhdCA9IHRoaXMubGF0MDtcbiAgICBpZiAocmggPD0gRVBTTE4pIHtcbiAgICAgIHAueCA9IGxvbjtcbiAgICAgIHAueSA9IGxhdDtcbiAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICBsYXQgPSBNYXRoLmFzaW4oTWF0aC5jb3MoYykgKiB0aGlzLnNpbmxhdDAgKyBwLnkgKiBNYXRoLnNpbihjKSAqIHRoaXMuY29zbGF0MCAvIHJoKTtcbiAgICBpZiAoTWF0aC5hYnModGhpcy5jb3NsYXQwKSA8IEVQU0xOKSB7XG4gICAgICBpZiAodGhpcy5sYXQwID4gMCkge1xuICAgICAgICBsb24gPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgKyBNYXRoLmF0YW4yKHAueCwgLSAxICogcC55KSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbG9uID0gYWRqdXN0X2xvbih0aGlzLmxvbmcwICsgTWF0aC5hdGFuMihwLngsIHAueSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGxvbiA9IGFkanVzdF9sb24odGhpcy5sb25nMCArIE1hdGguYXRhbjIocC54ICogTWF0aC5zaW4oYyksIHJoICogdGhpcy5jb3NsYXQwICogTWF0aC5jb3MoYykgLSBwLnkgKiB0aGlzLnNpbmxhdDAgKiBNYXRoLnNpbihjKSkpO1xuICAgIH1cbiAgICBwLnggPSBsb247XG4gICAgcC55ID0gbGF0O1xuICAgIHJldHVybiBwO1xuICB9XG4gIGVsc2Uge1xuICAgIGlmIChNYXRoLmFicyh0aGlzLmNvc2xhdDApIDw9IEVQU0xOKSB7XG4gICAgICBpZiAocmggPD0gRVBTTE4pIHtcbiAgICAgICAgbGF0ID0gdGhpcy5sYXQwO1xuICAgICAgICBsb24gPSB0aGlzLmxvbmcwO1xuICAgICAgICBwLnggPSBsb247XG4gICAgICAgIHAueSA9IGxhdDtcbiAgICAgICAgLy90cmFjZShwLnRvU3RyaW5nKCkpO1xuICAgICAgICByZXR1cm4gcDtcbiAgICAgIH1cbiAgICAgIHAueCAqPSB0aGlzLmNvbjtcbiAgICAgIHAueSAqPSB0aGlzLmNvbjtcbiAgICAgIHRzID0gcmggKiB0aGlzLmNvbnMgLyAoMiAqIHRoaXMuYSAqIHRoaXMuazApO1xuICAgICAgbGF0ID0gdGhpcy5jb24gKiBwaGkyeih0aGlzLmUsIHRzKTtcbiAgICAgIGxvbiA9IHRoaXMuY29uICogYWRqdXN0X2xvbih0aGlzLmNvbiAqIHRoaXMubG9uZzAgKyBNYXRoLmF0YW4yKHAueCwgLSAxICogcC55KSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY2UgPSAyICogTWF0aC5hdGFuKHJoICogdGhpcy5jb3NYMCAvICgyICogdGhpcy5hICogdGhpcy5rMCAqIHRoaXMubXMxKSk7XG4gICAgICBsb24gPSB0aGlzLmxvbmcwO1xuICAgICAgaWYgKHJoIDw9IEVQU0xOKSB7XG4gICAgICAgIENoaSA9IHRoaXMuWDA7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgQ2hpID0gTWF0aC5hc2luKE1hdGguY29zKGNlKSAqIHRoaXMuc2luWDAgKyBwLnkgKiBNYXRoLnNpbihjZSkgKiB0aGlzLmNvc1gwIC8gcmgpO1xuICAgICAgICBsb24gPSBhZGp1c3RfbG9uKHRoaXMubG9uZzAgKyBNYXRoLmF0YW4yKHAueCAqIE1hdGguc2luKGNlKSwgcmggKiB0aGlzLmNvc1gwICogTWF0aC5jb3MoY2UpIC0gcC55ICogdGhpcy5zaW5YMCAqIE1hdGguc2luKGNlKSkpO1xuICAgICAgfVxuICAgICAgbGF0ID0gLTEgKiBwaGkyeih0aGlzLmUsIE1hdGgudGFuKDAuNSAqIChIQUxGX1BJICsgQ2hpKSkpO1xuICAgIH1cbiAgfVxuICBwLnggPSBsb247XG4gIHAueSA9IGxhdDtcblxuICAvL3RyYWNlKHAudG9TdHJpbmcoKSk7XG4gIHJldHVybiBwO1xuXG59O1xuZXhwb3J0cy5uYW1lcyA9IFtcInN0ZXJlXCIsIFwiU3RlcmVvZ3JhcGhpY19Tb3V0aF9Qb2xlXCIsIFwiUG9sYXIgU3RlcmVvZ3JhcGhpYyAodmFyaWFudCBCKVwiXTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcm9qNC9saWIvcHJvamVjdGlvbnMvc3RlcmUuanNcbi8vIG1vZHVsZSBpZCA9IDE1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){eval('var gauss = __webpack_require__(144);\nvar adjust_lon = __webpack_require__(0);\nexports.init = function() {\n  gauss.init.apply(this);\n  if (!this.rc) {\n    return;\n  }\n  this.sinc0 = Math.sin(this.phic0);\n  this.cosc0 = Math.cos(this.phic0);\n  this.R2 = 2 * this.rc;\n  if (!this.title) {\n    this.title = "Oblique Stereographic Alternative";\n  }\n};\n\nexports.forward = function(p) {\n  var sinc, cosc, cosl, k;\n  p.x = adjust_lon(p.x - this.long0);\n  gauss.forward.apply(this, [p]);\n  sinc = Math.sin(p.y);\n  cosc = Math.cos(p.y);\n  cosl = Math.cos(p.x);\n  k = this.k0 * this.R2 / (1 + this.sinc0 * sinc + this.cosc0 * cosc * cosl);\n  p.x = k * cosc * Math.sin(p.x);\n  p.y = k * (this.cosc0 * sinc - this.sinc0 * cosc * cosl);\n  p.x = this.a * p.x + this.x0;\n  p.y = this.a * p.y + this.y0;\n  return p;\n};\n\nexports.inverse = function(p) {\n  var sinc, cosc, lon, lat, rho;\n  p.x = (p.x - this.x0) / this.a;\n  p.y = (p.y - this.y0) / this.a;\n\n  p.x /= this.k0;\n  p.y /= this.k0;\n  if ((rho = Math.sqrt(p.x * p.x + p.y * p.y))) {\n    var c = 2 * Math.atan2(rho, this.R2);\n    sinc = Math.sin(c);\n    cosc = Math.cos(c);\n    lat = Math.asin(cosc * this.sinc0 + p.y * sinc * this.cosc0 / rho);\n    lon = Math.atan2(p.x * sinc, rho * this.cosc0 * cosc - p.y * this.sinc0 * sinc);\n  }\n  else {\n    lat = this.phic0;\n    lon = 0;\n  }\n\n  p.x = lon;\n  p.y = lat;\n  gauss.inverse.apply(this, [p]);\n  p.x = adjust_lon(p.x + this.long0);\n  return p;\n};\n\nexports.names = ["Stereographic_North_Pole", "Oblique_Stereographic", "Polar_Stereographic", "sterea","Oblique Stereographic Alternative"];\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9wcm9qZWN0aW9ucy9zdGVyZWEuanM/ZjY0OCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjE1OS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBnYXVzcyA9IHJlcXVpcmUoJy4vZ2F1c3MnKTtcbnZhciBhZGp1c3RfbG9uID0gcmVxdWlyZSgnLi4vY29tbW9uL2FkanVzdF9sb24nKTtcbmV4cG9ydHMuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICBnYXVzcy5pbml0LmFwcGx5KHRoaXMpO1xuICBpZiAoIXRoaXMucmMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5zaW5jMCA9IE1hdGguc2luKHRoaXMucGhpYzApO1xuICB0aGlzLmNvc2MwID0gTWF0aC5jb3ModGhpcy5waGljMCk7XG4gIHRoaXMuUjIgPSAyICogdGhpcy5yYztcbiAgaWYgKCF0aGlzLnRpdGxlKSB7XG4gICAgdGhpcy50aXRsZSA9IFwiT2JsaXF1ZSBTdGVyZW9ncmFwaGljIEFsdGVybmF0aXZlXCI7XG4gIH1cbn07XG5cbmV4cG9ydHMuZm9yd2FyZCA9IGZ1bmN0aW9uKHApIHtcbiAgdmFyIHNpbmMsIGNvc2MsIGNvc2wsIGs7XG4gIHAueCA9IGFkanVzdF9sb24ocC54IC0gdGhpcy5sb25nMCk7XG4gIGdhdXNzLmZvcndhcmQuYXBwbHkodGhpcywgW3BdKTtcbiAgc2luYyA9IE1hdGguc2luKHAueSk7XG4gIGNvc2MgPSBNYXRoLmNvcyhwLnkpO1xuICBjb3NsID0gTWF0aC5jb3MocC54KTtcbiAgayA9IHRoaXMuazAgKiB0aGlzLlIyIC8gKDEgKyB0aGlzLnNpbmMwICogc2luYyArIHRoaXMuY29zYzAgKiBjb3NjICogY29zbCk7XG4gIHAueCA9IGsgKiBjb3NjICogTWF0aC5zaW4ocC54KTtcbiAgcC55ID0gayAqICh0aGlzLmNvc2MwICogc2luYyAtIHRoaXMuc2luYzAgKiBjb3NjICogY29zbCk7XG4gIHAueCA9IHRoaXMuYSAqIHAueCArIHRoaXMueDA7XG4gIHAueSA9IHRoaXMuYSAqIHAueSArIHRoaXMueTA7XG4gIHJldHVybiBwO1xufTtcblxuZXhwb3J0cy5pbnZlcnNlID0gZnVuY3Rpb24ocCkge1xuICB2YXIgc2luYywgY29zYywgbG9uLCBsYXQsIHJobztcbiAgcC54ID0gKHAueCAtIHRoaXMueDApIC8gdGhpcy5hO1xuICBwLnkgPSAocC55IC0gdGhpcy55MCkgLyB0aGlzLmE7XG5cbiAgcC54IC89IHRoaXMuazA7XG4gIHAueSAvPSB0aGlzLmswO1xuICBpZiAoKHJobyA9IE1hdGguc3FydChwLnggKiBwLnggKyBwLnkgKiBwLnkpKSkge1xuICAgIHZhciBjID0gMiAqIE1hdGguYXRhbjIocmhvLCB0aGlzLlIyKTtcbiAgICBzaW5jID0gTWF0aC5zaW4oYyk7XG4gICAgY29zYyA9IE1hdGguY29zKGMpO1xuICAgIGxhdCA9IE1hdGguYXNpbihjb3NjICogdGhpcy5zaW5jMCArIHAueSAqIHNpbmMgKiB0aGlzLmNvc2MwIC8gcmhvKTtcbiAgICBsb24gPSBNYXRoLmF0YW4yKHAueCAqIHNpbmMsIHJobyAqIHRoaXMuY29zYzAgKiBjb3NjIC0gcC55ICogdGhpcy5zaW5jMCAqIHNpbmMpO1xuICB9XG4gIGVsc2Uge1xuICAgIGxhdCA9IHRoaXMucGhpYzA7XG4gICAgbG9uID0gMDtcbiAgfVxuXG4gIHAueCA9IGxvbjtcbiAgcC55ID0gbGF0O1xuICBnYXVzcy5pbnZlcnNlLmFwcGx5KHRoaXMsIFtwXSk7XG4gIHAueCA9IGFkanVzdF9sb24ocC54ICsgdGhpcy5sb25nMCk7XG4gIHJldHVybiBwO1xufTtcblxuZXhwb3J0cy5uYW1lcyA9IFtcIlN0ZXJlb2dyYXBoaWNfTm9ydGhfUG9sZVwiLCBcIk9ibGlxdWVfU3RlcmVvZ3JhcGhpY1wiLCBcIlBvbGFyX1N0ZXJlb2dyYXBoaWNcIiwgXCJzdGVyZWFcIixcIk9ibGlxdWUgU3RlcmVvZ3JhcGhpYyBBbHRlcm5hdGl2ZVwiXTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcm9qNC9saWIvcHJvamVjdGlvbnMvc3RlcmVhLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports,__webpack_require__){eval('var D2R = 0.01745329251994329577;\nvar tmerc = __webpack_require__(65);\nexports.dependsOn = \'tmerc\';\nexports.init = function() {\n  if (!this.zone) {\n    return;\n  }\n  this.lat0 = 0;\n  this.long0 = ((6 * Math.abs(this.zone)) - 183) * D2R;\n  this.x0 = 500000;\n  this.y0 = this.utmSouth ? 10000000 : 0;\n  this.k0 = 0.9996;\n\n  tmerc.init.apply(this);\n  this.forward = tmerc.forward;\n  this.inverse = tmerc.inverse;\n};\nexports.names = ["Universal Transverse Mercator System", "utm"];\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9wcm9qZWN0aW9ucy91dG0uanM/ZGQzZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxNjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgRDJSID0gMC4wMTc0NTMyOTI1MTk5NDMyOTU3NztcbnZhciB0bWVyYyA9IHJlcXVpcmUoJy4vdG1lcmMnKTtcbmV4cG9ydHMuZGVwZW5kc09uID0gJ3RtZXJjJztcbmV4cG9ydHMuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuem9uZSkge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLmxhdDAgPSAwO1xuICB0aGlzLmxvbmcwID0gKCg2ICogTWF0aC5hYnModGhpcy56b25lKSkgLSAxODMpICogRDJSO1xuICB0aGlzLngwID0gNTAwMDAwO1xuICB0aGlzLnkwID0gdGhpcy51dG1Tb3V0aCA/IDEwMDAwMDAwIDogMDtcbiAgdGhpcy5rMCA9IDAuOTk5NjtcblxuICB0bWVyYy5pbml0LmFwcGx5KHRoaXMpO1xuICB0aGlzLmZvcndhcmQgPSB0bWVyYy5mb3J3YXJkO1xuICB0aGlzLmludmVyc2UgPSB0bWVyYy5pbnZlcnNlO1xufTtcbmV4cG9ydHMubmFtZXMgPSBbXCJVbml2ZXJzYWwgVHJhbnN2ZXJzZSBNZXJjYXRvciBTeXN0ZW1cIiwgXCJ1dG1cIl07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHJvajQvbGliL3Byb2plY3Rpb25zL3V0bS5qc1xuLy8gbW9kdWxlIGlkID0gMTYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=')},function(module,exports,__webpack_require__){eval('var adjust_lon = __webpack_require__(0);\nvar HALF_PI = Math.PI/2;\nvar EPSLN = 1.0e-10;\nvar asinz = __webpack_require__(7);\n/* Initialize the Van Der Grinten projection\n  ----------------------------------------*/\nexports.init = function() {\n  //this.R = 6370997; //Radius of earth\n  this.R = this.a;\n};\n\nexports.forward = function(p) {\n\n  var lon = p.x;\n  var lat = p.y;\n\n  /* Forward equations\n    -----------------*/\n  var dlon = adjust_lon(lon - this.long0);\n  var x, y;\n\n  if (Math.abs(lat) <= EPSLN) {\n    x = this.x0 + this.R * dlon;\n    y = this.y0;\n  }\n  var theta = asinz(2 * Math.abs(lat / Math.PI));\n  if ((Math.abs(dlon) <= EPSLN) || (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN)) {\n    x = this.x0;\n    if (lat >= 0) {\n      y = this.y0 + Math.PI * this.R * Math.tan(0.5 * theta);\n    }\n    else {\n      y = this.y0 + Math.PI * this.R * -Math.tan(0.5 * theta);\n    }\n    //  return(OK);\n  }\n  var al = 0.5 * Math.abs((Math.PI / dlon) - (dlon / Math.PI));\n  var asq = al * al;\n  var sinth = Math.sin(theta);\n  var costh = Math.cos(theta);\n\n  var g = costh / (sinth + costh - 1);\n  var gsq = g * g;\n  var m = g * (2 / sinth - 1);\n  var msq = m * m;\n  var con = Math.PI * this.R * (al * (g - msq) + Math.sqrt(asq * (g - msq) * (g - msq) - (msq + asq) * (gsq - msq))) / (msq + asq);\n  if (dlon < 0) {\n    con = -con;\n  }\n  x = this.x0 + con;\n  //con = Math.abs(con / (Math.PI * this.R));\n  var q = asq + g;\n  con = Math.PI * this.R * (m * q - al * Math.sqrt((msq + asq) * (asq + 1) - q * q)) / (msq + asq);\n  if (lat >= 0) {\n    //y = this.y0 + Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);\n    y = this.y0 + con;\n  }\n  else {\n    //y = this.y0 - Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);\n    y = this.y0 - con;\n  }\n  p.x = x;\n  p.y = y;\n  return p;\n};\n\n/* Van Der Grinten inverse equations--mapping x,y to lat/long\n  ---------------------------------------------------------*/\nexports.inverse = function(p) {\n  var lon, lat;\n  var xx, yy, xys, c1, c2, c3;\n  var a1;\n  var m1;\n  var con;\n  var th1;\n  var d;\n\n  /* inverse equations\n    -----------------*/\n  p.x -= this.x0;\n  p.y -= this.y0;\n  con = Math.PI * this.R;\n  xx = p.x / con;\n  yy = p.y / con;\n  xys = xx * xx + yy * yy;\n  c1 = -Math.abs(yy) * (1 + xys);\n  c2 = c1 - 2 * yy * yy + xx * xx;\n  c3 = -2 * c1 + 1 + 2 * yy * yy + xys * xys;\n  d = yy * yy / c3 + (2 * c2 * c2 * c2 / c3 / c3 / c3 - 9 * c1 * c2 / c3 / c3) / 27;\n  a1 = (c1 - c2 * c2 / 3 / c3) / c3;\n  m1 = 2 * Math.sqrt(-a1 / 3);\n  con = ((3 * d) / a1) / m1;\n  if (Math.abs(con) > 1) {\n    if (con >= 0) {\n      con = 1;\n    }\n    else {\n      con = -1;\n    }\n  }\n  th1 = Math.acos(con) / 3;\n  if (p.y >= 0) {\n    lat = (-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;\n  }\n  else {\n    lat = -(-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;\n  }\n\n  if (Math.abs(xx) < EPSLN) {\n    lon = this.long0;\n  }\n  else {\n    lon = adjust_lon(this.long0 + Math.PI * (xys - 1 + Math.sqrt(1 + 2 * (xx * xx - yy * yy) + xys * xys)) / 2 / xx);\n  }\n\n  p.x = lon;\n  p.y = lat;\n  return p;\n};\nexports.names = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"];//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L2xpYi9wcm9qZWN0aW9ucy92YW5kZy5qcz81MWQ1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjE2MS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBhZGp1c3RfbG9uID0gcmVxdWlyZSgnLi4vY29tbW9uL2FkanVzdF9sb24nKTtcbnZhciBIQUxGX1BJID0gTWF0aC5QSS8yO1xudmFyIEVQU0xOID0gMS4wZS0xMDtcbnZhciBhc2lueiA9IHJlcXVpcmUoJy4uL2NvbW1vbi9hc2lueicpO1xuLyogSW5pdGlhbGl6ZSB0aGUgVmFuIERlciBHcmludGVuIHByb2plY3Rpb25cbiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnRzLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgLy90aGlzLlIgPSA2MzcwOTk3OyAvL1JhZGl1cyBvZiBlYXJ0aFxuICB0aGlzLlIgPSB0aGlzLmE7XG59O1xuXG5leHBvcnRzLmZvcndhcmQgPSBmdW5jdGlvbihwKSB7XG5cbiAgdmFyIGxvbiA9IHAueDtcbiAgdmFyIGxhdCA9IHAueTtcblxuICAvKiBGb3J3YXJkIGVxdWF0aW9uc1xuICAgIC0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgdmFyIGRsb24gPSBhZGp1c3RfbG9uKGxvbiAtIHRoaXMubG9uZzApO1xuICB2YXIgeCwgeTtcblxuICBpZiAoTWF0aC5hYnMobGF0KSA8PSBFUFNMTikge1xuICAgIHggPSB0aGlzLngwICsgdGhpcy5SICogZGxvbjtcbiAgICB5ID0gdGhpcy55MDtcbiAgfVxuICB2YXIgdGhldGEgPSBhc2lueigyICogTWF0aC5hYnMobGF0IC8gTWF0aC5QSSkpO1xuICBpZiAoKE1hdGguYWJzKGRsb24pIDw9IEVQU0xOKSB8fCAoTWF0aC5hYnMoTWF0aC5hYnMobGF0KSAtIEhBTEZfUEkpIDw9IEVQU0xOKSkge1xuICAgIHggPSB0aGlzLngwO1xuICAgIGlmIChsYXQgPj0gMCkge1xuICAgICAgeSA9IHRoaXMueTAgKyBNYXRoLlBJICogdGhpcy5SICogTWF0aC50YW4oMC41ICogdGhldGEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHkgPSB0aGlzLnkwICsgTWF0aC5QSSAqIHRoaXMuUiAqIC1NYXRoLnRhbigwLjUgKiB0aGV0YSk7XG4gICAgfVxuICAgIC8vICByZXR1cm4oT0spO1xuICB9XG4gIHZhciBhbCA9IDAuNSAqIE1hdGguYWJzKChNYXRoLlBJIC8gZGxvbikgLSAoZGxvbiAvIE1hdGguUEkpKTtcbiAgdmFyIGFzcSA9IGFsICogYWw7XG4gIHZhciBzaW50aCA9IE1hdGguc2luKHRoZXRhKTtcbiAgdmFyIGNvc3RoID0gTWF0aC5jb3ModGhldGEpO1xuXG4gIHZhciBnID0gY29zdGggLyAoc2ludGggKyBjb3N0aCAtIDEpO1xuICB2YXIgZ3NxID0gZyAqIGc7XG4gIHZhciBtID0gZyAqICgyIC8gc2ludGggLSAxKTtcbiAgdmFyIG1zcSA9IG0gKiBtO1xuICB2YXIgY29uID0gTWF0aC5QSSAqIHRoaXMuUiAqIChhbCAqIChnIC0gbXNxKSArIE1hdGguc3FydChhc3EgKiAoZyAtIG1zcSkgKiAoZyAtIG1zcSkgLSAobXNxICsgYXNxKSAqIChnc3EgLSBtc3EpKSkgLyAobXNxICsgYXNxKTtcbiAgaWYgKGRsb24gPCAwKSB7XG4gICAgY29uID0gLWNvbjtcbiAgfVxuICB4ID0gdGhpcy54MCArIGNvbjtcbiAgLy9jb24gPSBNYXRoLmFicyhjb24gLyAoTWF0aC5QSSAqIHRoaXMuUikpO1xuICB2YXIgcSA9IGFzcSArIGc7XG4gIGNvbiA9IE1hdGguUEkgKiB0aGlzLlIgKiAobSAqIHEgLSBhbCAqIE1hdGguc3FydCgobXNxICsgYXNxKSAqIChhc3EgKyAxKSAtIHEgKiBxKSkgLyAobXNxICsgYXNxKTtcbiAgaWYgKGxhdCA+PSAwKSB7XG4gICAgLy95ID0gdGhpcy55MCArIE1hdGguUEkgKiB0aGlzLlIgKiBNYXRoLnNxcnQoMSAtIGNvbiAqIGNvbiAtIDIgKiBhbCAqIGNvbik7XG4gICAgeSA9IHRoaXMueTAgKyBjb247XG4gIH1cbiAgZWxzZSB7XG4gICAgLy95ID0gdGhpcy55MCAtIE1hdGguUEkgKiB0aGlzLlIgKiBNYXRoLnNxcnQoMSAtIGNvbiAqIGNvbiAtIDIgKiBhbCAqIGNvbik7XG4gICAgeSA9IHRoaXMueTAgLSBjb247XG4gIH1cbiAgcC54ID0geDtcbiAgcC55ID0geTtcbiAgcmV0dXJuIHA7XG59O1xuXG4vKiBWYW4gRGVyIEdyaW50ZW4gaW52ZXJzZSBlcXVhdGlvbnMtLW1hcHBpbmcgeCx5IHRvIGxhdC9sb25nXG4gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnRzLmludmVyc2UgPSBmdW5jdGlvbihwKSB7XG4gIHZhciBsb24sIGxhdDtcbiAgdmFyIHh4LCB5eSwgeHlzLCBjMSwgYzIsIGMzO1xuICB2YXIgYTE7XG4gIHZhciBtMTtcbiAgdmFyIGNvbjtcbiAgdmFyIHRoMTtcbiAgdmFyIGQ7XG5cbiAgLyogaW52ZXJzZSBlcXVhdGlvbnNcbiAgICAtLS0tLS0tLS0tLS0tLS0tLSovXG4gIHAueCAtPSB0aGlzLngwO1xuICBwLnkgLT0gdGhpcy55MDtcbiAgY29uID0gTWF0aC5QSSAqIHRoaXMuUjtcbiAgeHggPSBwLnggLyBjb247XG4gIHl5ID0gcC55IC8gY29uO1xuICB4eXMgPSB4eCAqIHh4ICsgeXkgKiB5eTtcbiAgYzEgPSAtTWF0aC5hYnMoeXkpICogKDEgKyB4eXMpO1xuICBjMiA9IGMxIC0gMiAqIHl5ICogeXkgKyB4eCAqIHh4O1xuICBjMyA9IC0yICogYzEgKyAxICsgMiAqIHl5ICogeXkgKyB4eXMgKiB4eXM7XG4gIGQgPSB5eSAqIHl5IC8gYzMgKyAoMiAqIGMyICogYzIgKiBjMiAvIGMzIC8gYzMgLyBjMyAtIDkgKiBjMSAqIGMyIC8gYzMgLyBjMykgLyAyNztcbiAgYTEgPSAoYzEgLSBjMiAqIGMyIC8gMyAvIGMzKSAvIGMzO1xuICBtMSA9IDIgKiBNYXRoLnNxcnQoLWExIC8gMyk7XG4gIGNvbiA9ICgoMyAqIGQpIC8gYTEpIC8gbTE7XG4gIGlmIChNYXRoLmFicyhjb24pID4gMSkge1xuICAgIGlmIChjb24gPj0gMCkge1xuICAgICAgY29uID0gMTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjb24gPSAtMTtcbiAgICB9XG4gIH1cbiAgdGgxID0gTWF0aC5hY29zKGNvbikgLyAzO1xuICBpZiAocC55ID49IDApIHtcbiAgICBsYXQgPSAoLW0xICogTWF0aC5jb3ModGgxICsgTWF0aC5QSSAvIDMpIC0gYzIgLyAzIC8gYzMpICogTWF0aC5QSTtcbiAgfVxuICBlbHNlIHtcbiAgICBsYXQgPSAtKC1tMSAqIE1hdGguY29zKHRoMSArIE1hdGguUEkgLyAzKSAtIGMyIC8gMyAvIGMzKSAqIE1hdGguUEk7XG4gIH1cblxuICBpZiAoTWF0aC5hYnMoeHgpIDwgRVBTTE4pIHtcbiAgICBsb24gPSB0aGlzLmxvbmcwO1xuICB9XG4gIGVsc2Uge1xuICAgIGxvbiA9IGFkanVzdF9sb24odGhpcy5sb25nMCArIE1hdGguUEkgKiAoeHlzIC0gMSArIE1hdGguc3FydCgxICsgMiAqICh4eCAqIHh4IC0geXkgKiB5eSkgKyB4eXMgKiB4eXMpKSAvIDIgLyB4eCk7XG4gIH1cblxuICBwLnggPSBsb247XG4gIHAueSA9IGxhdDtcbiAgcmV0dXJuIHA7XG59O1xuZXhwb3J0cy5uYW1lcyA9IFtcIlZhbl9kZXJfR3JpbnRlbl9JXCIsIFwiVmFuRGVyR3JpbnRlblwiLCBcInZhbmRnXCJdO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcm9qNC9saWIvcHJvamVjdGlvbnMvdmFuZGcuanNcbi8vIG1vZHVsZSBpZCA9IDE2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9')},function(module,exports){eval('module.exports = {\n\t"_args": [\n\t\t[\n\t\t\t{\n\t\t\t\t"raw": "proj4@^2.3.12",\n\t\t\t\t"scope": null,\n\t\t\t\t"escapedName": "proj4",\n\t\t\t\t"name": "proj4",\n\t\t\t\t"rawSpec": "^2.3.12",\n\t\t\t\t"spec": ">=2.3.12 <3.0.0",\n\t\t\t\t"type": "range"\n\t\t\t},\n\t\t\t"C:\\\\Users\\\\Miles.Petrov\\\\Repo\\\\geoApi"\n\t\t]\n\t],\n\t"_from": "proj4@>=2.3.12 <3.0.0",\n\t"_id": "proj4@2.3.15",\n\t"_inCache": true,\n\t"_location": "/proj4",\n\t"_nodeVersion": "6.1.0",\n\t"_npmOperationalInternal": {\n\t\t"host": "packages-12-west.internal.npmjs.com",\n\t\t"tmp": "tmp/proj4-2.3.15.tgz_1471808262546_0.6752060337457806"\n\t},\n\t"_npmUser": {\n\t\t"name": "ahocevar",\n\t\t"email": "andreas.hocevar@gmail.com"\n\t},\n\t"_npmVersion": "3.8.6",\n\t"_phantomChildren": {},\n\t"_requested": {\n\t\t"raw": "proj4@^2.3.12",\n\t\t"scope": null,\n\t\t"escapedName": "proj4",\n\t\t"name": "proj4",\n\t\t"rawSpec": "^2.3.12",\n\t\t"spec": ">=2.3.12 <3.0.0",\n\t\t"type": "range"\n\t},\n\t"_requiredBy": [\n\t\t"#DEV:/",\n\t\t"/shpjs"\n\t],\n\t"_resolved": "https://registry.npmjs.org/proj4/-/proj4-2.3.15.tgz",\n\t"_shasum": "5ad06e8bca30be0ffa389a49e4565f51f06d089e",\n\t"_shrinkwrap": null,\n\t"_spec": "proj4@^2.3.12",\n\t"_where": "C:\\\\Users\\\\Miles.Petrov\\\\Repo\\\\geoApi",\n\t"author": "",\n\t"bugs": {\n\t\t"url": "https://github.com/proj4js/proj4js/issues"\n\t},\n\t"contributors": [\n\t\t{\n\t\t\t"name": "Mike Adair",\n\t\t\t"email": "madair@dmsolutions.ca"\n\t\t},\n\t\t{\n\t\t\t"name": "Richard Greenwood",\n\t\t\t"email": "rich@greenwoodmap.com"\n\t\t},\n\t\t{\n\t\t\t"name": "Calvin Metcalf",\n\t\t\t"email": "calvin.metcalf@gmail.com"\n\t\t},\n\t\t{\n\t\t\t"name": "Richard Marsden",\n\t\t\t"url": "http://www.winwaed.com"\n\t\t},\n\t\t{\n\t\t\t"name": "T. Mittan"\n\t\t},\n\t\t{\n\t\t\t"name": "D. Steinwand"\n\t\t},\n\t\t{\n\t\t\t"name": "S. Nelson"\n\t\t}\n\t],\n\t"dependencies": {\n\t\t"mgrs": "~0.0.2"\n\t},\n\t"description": "Proj4js is a JavaScript library to transform point coordinates from one coordinate system to another, including datum transformations.",\n\t"devDependencies": {\n\t\t"browserify": "~12.0.1",\n\t\t"chai": "~1.8.1",\n\t\t"curl": "git://github.com/cujojs/curl.git",\n\t\t"grunt": "~0.4.2",\n\t\t"grunt-browserify": "~4.0.1",\n\t\t"grunt-cli": "~0.1.13",\n\t\t"grunt-contrib-connect": "~0.6.0",\n\t\t"grunt-contrib-jshint": "~0.8.0",\n\t\t"grunt-contrib-uglify": "~0.11.1",\n\t\t"grunt-mocha-phantomjs": "~0.4.0",\n\t\t"istanbul": "~0.2.4",\n\t\t"mocha": "~1.17.1",\n\t\t"tin": "~0.4.0"\n\t},\n\t"directories": {\n\t\t"test": "test",\n\t\t"doc": "docs"\n\t},\n\t"dist": {\n\t\t"shasum": "5ad06e8bca30be0ffa389a49e4565f51f06d089e",\n\t\t"tarball": "https://registry.npmjs.org/proj4/-/proj4-2.3.15.tgz"\n\t},\n\t"gitHead": "9fa5249c1f4183d5ddee3c4793dfd7b9f29f1886",\n\t"homepage": "https://github.com/proj4js/proj4js#readme",\n\t"jam": {\n\t\t"main": "dist/proj4.js",\n\t\t"include": [\n\t\t\t"dist/proj4.js",\n\t\t\t"README.md",\n\t\t\t"AUTHORS",\n\t\t\t"LICENSE.md"\n\t\t]\n\t},\n\t"license": "MIT",\n\t"main": "lib/index.js",\n\t"maintainers": [\n\t\t{\n\t\t\t"name": "cwmma",\n\t\t\t"email": "calvin.metcalf@gmail.com"\n\t\t},\n\t\t{\n\t\t\t"name": "ahocevar",\n\t\t\t"email": "andreas.hocevar@gmail.com"\n\t\t}\n\t],\n\t"name": "proj4",\n\t"optionalDependencies": {},\n\t"readme": "ERROR: No README data found!",\n\t"repository": {\n\t\t"type": "git",\n\t\t"url": "git://github.com/proj4js/proj4js.git"\n\t},\n\t"scripts": {\n\t\t"test": "./node_modules/istanbul/lib/cli.js test ./node_modules/mocha/bin/_mocha test/test.js"\n\t},\n\t"version": "2.3.15"\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Byb2o0L3BhY2thZ2UuanNvbj8xMGMwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSIsImZpbGUiOiIxNjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHtcblx0XCJfYXJnc1wiOiBbXG5cdFx0W1xuXHRcdFx0e1xuXHRcdFx0XHRcInJhd1wiOiBcInByb2o0QF4yLjMuMTJcIixcblx0XHRcdFx0XCJzY29wZVwiOiBudWxsLFxuXHRcdFx0XHRcImVzY2FwZWROYW1lXCI6IFwicHJvajRcIixcblx0XHRcdFx0XCJuYW1lXCI6IFwicHJvajRcIixcblx0XHRcdFx0XCJyYXdTcGVjXCI6IFwiXjIuMy4xMlwiLFxuXHRcdFx0XHRcInNwZWNcIjogXCI+PTIuMy4xMiA8My4wLjBcIixcblx0XHRcdFx0XCJ0eXBlXCI6IFwicmFuZ2VcIlxuXHRcdFx0fSxcblx0XHRcdFwiQzpcXFxcVXNlcnNcXFxcTWlsZXMuUGV0cm92XFxcXFJlcG9cXFxcZ2VvQXBpXCJcblx0XHRdXG5cdF0sXG5cdFwiX2Zyb21cIjogXCJwcm9qNEA+PTIuMy4xMiA8My4wLjBcIixcblx0XCJfaWRcIjogXCJwcm9qNEAyLjMuMTVcIixcblx0XCJfaW5DYWNoZVwiOiB0cnVlLFxuXHRcIl9sb2NhdGlvblwiOiBcIi9wcm9qNFwiLFxuXHRcIl9ub2RlVmVyc2lvblwiOiBcIjYuMS4wXCIsXG5cdFwiX25wbU9wZXJhdGlvbmFsSW50ZXJuYWxcIjoge1xuXHRcdFwiaG9zdFwiOiBcInBhY2thZ2VzLTEyLXdlc3QuaW50ZXJuYWwubnBtanMuY29tXCIsXG5cdFx0XCJ0bXBcIjogXCJ0bXAvcHJvajQtMi4zLjE1LnRnel8xNDcxODA4MjYyNTQ2XzAuNjc1MjA2MDMzNzQ1NzgwNlwiXG5cdH0sXG5cdFwiX25wbVVzZXJcIjoge1xuXHRcdFwibmFtZVwiOiBcImFob2NldmFyXCIsXG5cdFx0XCJlbWFpbFwiOiBcImFuZHJlYXMuaG9jZXZhckBnbWFpbC5jb21cIlxuXHR9LFxuXHRcIl9ucG1WZXJzaW9uXCI6IFwiMy44LjZcIixcblx0XCJfcGhhbnRvbUNoaWxkcmVuXCI6IHt9LFxuXHRcIl9yZXF1ZXN0ZWRcIjoge1xuXHRcdFwicmF3XCI6IFwicHJvajRAXjIuMy4xMlwiLFxuXHRcdFwic2NvcGVcIjogbnVsbCxcblx0XHRcImVzY2FwZWROYW1lXCI6IFwicHJvajRcIixcblx0XHRcIm5hbWVcIjogXCJwcm9qNFwiLFxuXHRcdFwicmF3U3BlY1wiOiBcIl4yLjMuMTJcIixcblx0XHRcInNwZWNcIjogXCI+PTIuMy4xMiA8My4wLjBcIixcblx0XHRcInR5cGVcIjogXCJyYW5nZVwiXG5cdH0sXG5cdFwiX3JlcXVpcmVkQnlcIjogW1xuXHRcdFwiI0RFVjovXCIsXG5cdFx0XCIvc2hwanNcIlxuXHRdLFxuXHRcIl9yZXNvbHZlZFwiOiBcImh0dHBzOi8vcmVnaXN0cnkubnBtanMub3JnL3Byb2o0Ly0vcHJvajQtMi4zLjE1LnRnelwiLFxuXHRcIl9zaGFzdW1cIjogXCI1YWQwNmU4YmNhMzBiZTBmZmEzODlhNDllNDU2NWY1MWYwNmQwODllXCIsXG5cdFwiX3Nocmlua3dyYXBcIjogbnVsbCxcblx0XCJfc3BlY1wiOiBcInByb2o0QF4yLjMuMTJcIixcblx0XCJfd2hlcmVcIjogXCJDOlxcXFxVc2Vyc1xcXFxNaWxlcy5QZXRyb3ZcXFxcUmVwb1xcXFxnZW9BcGlcIixcblx0XCJhdXRob3JcIjogXCJcIixcblx0XCJidWdzXCI6IHtcblx0XHRcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9wcm9qNGpzL3Byb2o0anMvaXNzdWVzXCJcblx0fSxcblx0XCJjb250cmlidXRvcnNcIjogW1xuXHRcdHtcblx0XHRcdFwibmFtZVwiOiBcIk1pa2UgQWRhaXJcIixcblx0XHRcdFwiZW1haWxcIjogXCJtYWRhaXJAZG1zb2x1dGlvbnMuY2FcIlxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0XCJuYW1lXCI6IFwiUmljaGFyZCBHcmVlbndvb2RcIixcblx0XHRcdFwiZW1haWxcIjogXCJyaWNoQGdyZWVud29vZG1hcC5jb21cIlxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0XCJuYW1lXCI6IFwiQ2FsdmluIE1ldGNhbGZcIixcblx0XHRcdFwiZW1haWxcIjogXCJjYWx2aW4ubWV0Y2FsZkBnbWFpbC5jb21cIlxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0XCJuYW1lXCI6IFwiUmljaGFyZCBNYXJzZGVuXCIsXG5cdFx0XHRcInVybFwiOiBcImh0dHA6Ly93d3cud2lud2FlZC5jb21cIlxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0XCJuYW1lXCI6IFwiVC4gTWl0dGFuXCJcblx0XHR9LFxuXHRcdHtcblx0XHRcdFwibmFtZVwiOiBcIkQuIFN0ZWlud2FuZFwiXG5cdFx0fSxcblx0XHR7XG5cdFx0XHRcIm5hbWVcIjogXCJTLiBOZWxzb25cIlxuXHRcdH1cblx0XSxcblx0XCJkZXBlbmRlbmNpZXNcIjoge1xuXHRcdFwibWdyc1wiOiBcIn4wLjAuMlwiXG5cdH0sXG5cdFwiZGVzY3JpcHRpb25cIjogXCJQcm9qNGpzIGlzIGEgSmF2YVNjcmlwdCBsaWJyYXJ5IHRvIHRyYW5zZm9ybSBwb2ludCBjb29yZGluYXRlcyBmcm9tIG9uZSBjb29yZGluYXRlIHN5c3RlbSB0byBhbm90aGVyLCBpbmNsdWRpbmcgZGF0dW0gdHJhbnNmb3JtYXRpb25zLlwiLFxuXHRcImRldkRlcGVuZGVuY2llc1wiOiB7XG5cdFx0XCJicm93c2VyaWZ5XCI6IFwifjEyLjAuMVwiLFxuXHRcdFwiY2hhaVwiOiBcIn4xLjguMVwiLFxuXHRcdFwiY3VybFwiOiBcImdpdDovL2dpdGh1Yi5jb20vY3Vqb2pzL2N1cmwuZ2l0XCIsXG5cdFx0XCJncnVudFwiOiBcIn4wLjQuMlwiLFxuXHRcdFwiZ3J1bnQtYnJvd3NlcmlmeVwiOiBcIn40LjAuMVwiLFxuXHRcdFwiZ3J1bnQtY2xpXCI6IFwifjAuMS4xM1wiLFxuXHRcdFwiZ3J1bnQtY29udHJpYi1jb25uZWN0XCI6IFwifjAuNi4wXCIsXG5cdFx0XCJncnVudC1jb250cmliLWpzaGludFwiOiBcIn4wLjguMFwiLFxuXHRcdFwiZ3J1bnQtY29udHJpYi11Z2xpZnlcIjogXCJ+MC4xMS4xXCIsXG5cdFx0XCJncnVudC1tb2NoYS1waGFudG9tanNcIjogXCJ+MC40LjBcIixcblx0XHRcImlzdGFuYnVsXCI6IFwifjAuMi40XCIsXG5cdFx0XCJtb2NoYVwiOiBcIn4xLjE3LjFcIixcblx0XHRcInRpblwiOiBcIn4wLjQuMFwiXG5cdH0sXG5cdFwiZGlyZWN0b3JpZXNcIjoge1xuXHRcdFwidGVzdFwiOiBcInRlc3RcIixcblx0XHRcImRvY1wiOiBcImRvY3NcIlxuXHR9LFxuXHRcImRpc3RcIjoge1xuXHRcdFwic2hhc3VtXCI6IFwiNWFkMDZlOGJjYTMwYmUwZmZhMzg5YTQ5ZTQ1NjVmNTFmMDZkMDg5ZVwiLFxuXHRcdFwidGFyYmFsbFwiOiBcImh0dHBzOi8vcmVnaXN0cnkubnBtanMub3JnL3Byb2o0Ly0vcHJvajQtMi4zLjE1LnRnelwiXG5cdH0sXG5cdFwiZ2l0SGVhZFwiOiBcIjlmYTUyNDljMWY0MTgzZDVkZGVlM2M0NzkzZGZkN2I5ZjI5ZjE4ODZcIixcblx0XCJob21lcGFnZVwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9wcm9qNGpzL3Byb2o0anMjcmVhZG1lXCIsXG5cdFwiamFtXCI6IHtcblx0XHRcIm1haW5cIjogXCJkaXN0L3Byb2o0LmpzXCIsXG5cdFx0XCJpbmNsdWRlXCI6IFtcblx0XHRcdFwiZGlzdC9wcm9qNC5qc1wiLFxuXHRcdFx0XCJSRUFETUUubWRcIixcblx0XHRcdFwiQVVUSE9SU1wiLFxuXHRcdFx0XCJMSUNFTlNFLm1kXCJcblx0XHRdXG5cdH0sXG5cdFwibGljZW5zZVwiOiBcIk1JVFwiLFxuXHRcIm1haW5cIjogXCJsaWIvaW5kZXguanNcIixcblx0XCJtYWludGFpbmVyc1wiOiBbXG5cdFx0e1xuXHRcdFx0XCJuYW1lXCI6IFwiY3dtbWFcIixcblx0XHRcdFwiZW1haWxcIjogXCJjYWx2aW4ubWV0Y2FsZkBnbWFpbC5jb21cIlxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0XCJuYW1lXCI6IFwiYWhvY2V2YXJcIixcblx0XHRcdFwiZW1haWxcIjogXCJhbmRyZWFzLmhvY2V2YXJAZ21haWwuY29tXCJcblx0XHR9XG5cdF0sXG5cdFwibmFtZVwiOiBcInByb2o0XCIsXG5cdFwib3B0aW9uYWxEZXBlbmRlbmNpZXNcIjoge30sXG5cdFwicmVhZG1lXCI6IFwiRVJST1I6IE5vIFJFQURNRSBkYXRhIGZvdW5kIVwiLFxuXHRcInJlcG9zaXRvcnlcIjoge1xuXHRcdFwidHlwZVwiOiBcImdpdFwiLFxuXHRcdFwidXJsXCI6IFwiZ2l0Oi8vZ2l0aHViLmNvbS9wcm9qNGpzL3Byb2o0anMuZ2l0XCJcblx0fSxcblx0XCJzY3JpcHRzXCI6IHtcblx0XHRcInRlc3RcIjogXCIuL25vZGVfbW9kdWxlcy9pc3RhbmJ1bC9saWIvY2xpLmpzIHRlc3QgLi9ub2RlX21vZHVsZXMvbW9jaGEvYmluL19tb2NoYSB0ZXN0L3Rlc3QuanNcIlxuXHR9LFxuXHRcInZlcnNpb25cIjogXCIyLjMuMTVcIlxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHJvajQvcGFja2FnZS5qc29uXG4vLyBtb2R1bGUgaWQgPSAxNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports){eval("module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 3);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function (h, s, v) {\n  var hi = Math.floor(h * 6);\n  var f = h * 6 - hi;\n  var p = v * (1 - s);\n  var q = v * (1 - f * s);\n  var t = v * (1 - (1 - f) * s);\n  var r = 255;\n  var g = 255;\n  var b = 255;\n\n  switch (hi) {\n    case 0:\n      r = v;g = t;b = p;break;\n    case 1:\n      r = q;g = v;b = p;break;\n    case 2:\n      r = p;g = v;b = t;break;\n    case 3:\n      r = p;g = q;b = v;break;\n    case 4:\n      r = t;g = p;b = v;break;\n    case 5:\n      r = v;g = p;b = q;break;\n  }\n  return [Math.floor(r * 255), Math.floor(g * 255), Math.floor(b * 255)];\n};\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar padHex = __webpack_require__(2);\n\nmodule.exports = function (rgb) {\n  var parts = rgb.map(function (val) {\n    return padHex(val.toString(16));\n  }).join('');\n\n  return '#' + parts;\n};\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar hexWidth = 2;\n\nmodule.exports = function (str) {\n  if (str.length > hexWidth) return str;\n  return new Array(hexWidth - str.length + 1).join('0') + str;\n};\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar hsvToRgb = __webpack_require__(0);\nvar rgbToHex = __webpack_require__(1);\nvar goldenRatio = 0.618033988749895;\n\nfunction getRgb() {\n  var inputs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var hue = inputs.hue,\n      saturation = inputs.saturation,\n      value = inputs.value;\n\n  if (!hue) hue = Math.random();\n  hue += goldenRatio;\n  hue %= 1;\n\n  if (typeof saturation !== 'number') saturation = 0.5;\n  if (typeof value !== 'number') value = 0.95;\n\n  return hsvToRgb(hue, saturation, value);\n}\n\nfunction getHex(opts, inputs) {\n  var rgb = getRgb(opts, inputs);\n  return rgbToHex(rgb);\n}\n\nmodule.exports = getHex;\n\n/***/ })\n/******/ ]);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Jjb2xvci9kaXN0L3Jjb2xvci5qcz9iMWVmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1EQUFtRCxjQUFjOztBQUVqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywwQkFBMEIsRUFBRTtBQUMvRCx5Q0FBeUMsZUFBZTtBQUN4RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBOEQsK0RBQStEOztBQUU3SDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxNQUFNLE1BQU07QUFDeEI7QUFDQSxZQUFZLE1BQU0sTUFBTTtBQUN4QjtBQUNBLFlBQVksTUFBTSxNQUFNO0FBQ3hCO0FBQ0EsWUFBWSxNQUFNLE1BQU07QUFDeEI7QUFDQSxZQUFZLE1BQU0sTUFBTTtBQUN4QjtBQUNBLFlBQVksTUFBTSxNQUFNO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1AiLCJmaWxlIjoiMTYzLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPVxuLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcblxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG5cblxuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbi8qKioqKiovIFx0Ly8gaWRlbnRpdHkgZnVuY3Rpb24gZm9yIGNhbGxpbmcgaGFybW9ueSBpbXBvcnRzIHdpdGggdGhlIGNvcnJlY3QgY29udGV4dFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmkgPSBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07XG5cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4vKioqKioqLyBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4vKioqKioqLyBcdFx0XHRcdGdldDogZ2V0dGVyXG4vKioqKioqLyBcdFx0XHR9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG5cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcblxuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDMpO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChoLCBzLCB2KSB7XG4gIHZhciBoaSA9IE1hdGguZmxvb3IoaCAqIDYpO1xuICB2YXIgZiA9IGggKiA2IC0gaGk7XG4gIHZhciBwID0gdiAqICgxIC0gcyk7XG4gIHZhciBxID0gdiAqICgxIC0gZiAqIHMpO1xuICB2YXIgdCA9IHYgKiAoMSAtICgxIC0gZikgKiBzKTtcbiAgdmFyIHIgPSAyNTU7XG4gIHZhciBnID0gMjU1O1xuICB2YXIgYiA9IDI1NTtcblxuICBzd2l0Y2ggKGhpKSB7XG4gICAgY2FzZSAwOlxuICAgICAgciA9IHY7ZyA9IHQ7YiA9IHA7YnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgciA9IHE7ZyA9IHY7YiA9IHA7YnJlYWs7XG4gICAgY2FzZSAyOlxuICAgICAgciA9IHA7ZyA9IHY7YiA9IHQ7YnJlYWs7XG4gICAgY2FzZSAzOlxuICAgICAgciA9IHA7ZyA9IHE7YiA9IHY7YnJlYWs7XG4gICAgY2FzZSA0OlxuICAgICAgciA9IHQ7ZyA9IHA7YiA9IHY7YnJlYWs7XG4gICAgY2FzZSA1OlxuICAgICAgciA9IHY7ZyA9IHA7YiA9IHE7YnJlYWs7XG4gIH1cbiAgcmV0dXJuIFtNYXRoLmZsb29yKHIgKiAyNTUpLCBNYXRoLmZsb29yKGcgKiAyNTUpLCBNYXRoLmZsb29yKGIgKiAyNTUpXTtcbn07XG5cbi8qKiovIH0pLFxuLyogMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgcGFkSGV4ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocmdiKSB7XG4gIHZhciBwYXJ0cyA9IHJnYi5tYXAoZnVuY3Rpb24gKHZhbCkge1xuICAgIHJldHVybiBwYWRIZXgodmFsLnRvU3RyaW5nKDE2KSk7XG4gIH0pLmpvaW4oJycpO1xuXG4gIHJldHVybiAnIycgKyBwYXJ0cztcbn07XG5cbi8qKiovIH0pLFxuLyogMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgaGV4V2lkdGggPSAyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgaWYgKHN0ci5sZW5ndGggPiBoZXhXaWR0aCkgcmV0dXJuIHN0cjtcbiAgcmV0dXJuIG5ldyBBcnJheShoZXhXaWR0aCAtIHN0ci5sZW5ndGggKyAxKS5qb2luKCcwJykgKyBzdHI7XG59O1xuXG4vKioqLyB9KSxcbi8qIDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGhzdlRvUmdiID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciByZ2JUb0hleCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG52YXIgZ29sZGVuUmF0aW8gPSAwLjYxODAzMzk4ODc0OTg5NTtcblxuZnVuY3Rpb24gZ2V0UmdiKCkge1xuICB2YXIgaW5wdXRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgdmFyIGh1ZSA9IGlucHV0cy5odWUsXG4gICAgICBzYXR1cmF0aW9uID0gaW5wdXRzLnNhdHVyYXRpb24sXG4gICAgICB2YWx1ZSA9IGlucHV0cy52YWx1ZTtcblxuICBpZiAoIWh1ZSkgaHVlID0gTWF0aC5yYW5kb20oKTtcbiAgaHVlICs9IGdvbGRlblJhdGlvO1xuICBodWUgJT0gMTtcblxuICBpZiAodHlwZW9mIHNhdHVyYXRpb24gIT09ICdudW1iZXInKSBzYXR1cmF0aW9uID0gMC41O1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykgdmFsdWUgPSAwLjk1O1xuXG4gIHJldHVybiBoc3ZUb1JnYihodWUsIHNhdHVyYXRpb24sIHZhbHVlKTtcbn1cblxuZnVuY3Rpb24gZ2V0SGV4KG9wdHMsIGlucHV0cykge1xuICB2YXIgcmdiID0gZ2V0UmdiKG9wdHMsIGlucHV0cyk7XG4gIHJldHVybiByZ2JUb0hleChyZ2IpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEhleDtcblxuLyoqKi8gfSlcbi8qKioqKiovIF0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yY29sb3IvZGlzdC9yY29sb3IuanNcbi8vIG1vZHVsZSBpZCA9IDE2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports){eval("module.exports = element;\nmodule.exports.pair = pair;\nmodule.exports.format = format;\nmodule.exports.formatPair = formatPair;\n\nfunction element(x, dims) {\n    return search(x, dims).val;\n}\n\nfunction formatPair(x) {\n    return format(x.lat, 'lat') + ' ' + format(x.lon, 'lon');\n}\n\n// Is 0 North or South?\nfunction format(x, dim) {\n    var dirs = {\n            lat: ['N', 'S'],\n            lon: ['E', 'W']\n        }[dim] || '',\n        dir = dirs[x >= 0 ? 0 : 1],\n        abs = Math.abs(x),\n        whole = Math.floor(abs),\n        fraction = abs - whole,\n        fractionMinutes = fraction * 60,\n        minutes = Math.floor(fractionMinutes),\n        seconds = Math.floor((fractionMinutes - minutes) * 60);\n\n    return whole + ' ' +\n        (minutes ? minutes + \"' \" : '') +\n        (seconds ? seconds + '\" ' : '') + dir;\n}\n\nfunction search(x, dims, r) {\n    if (!dims) dims = 'NSEW';\n    if (typeof x !== 'string') return { val: null, regex: r };\n    r = r || /[\\s\\,]*([\\-|\\|\\]?[0-9.]+)? *(?:([0-9.]+)['] *)?(?:([0-9.]+)(?:''|\"||) *)?([NSEW])?/gi;\n    var m = r.exec(x);\n    if (!m) return { val: null, regex: r };\n    else if (m[4] && dims.indexOf(m[4]) === -1) return { val: null, regex: r };\n    else return {\n        val: (((m[1]) ? parseFloat(m[1]) : 0) +\n            ((m[2] ? parseFloat(m[2]) / 60 : 0)) +\n            ((m[3] ? parseFloat(m[3]) / 3600 : 0))) *\n            ((m[4] && m[4] === 'S' || m[4] === 'W') ? -1 : 1),\n        regex: r,\n        raw: m[0],\n        dim: m[4]\n    };\n}\n\nfunction pair(x, dims) {\n    x = x.trim();\n    var one = search(x, dims);\n    if (one.val === null) return null;\n    var two = search(x, dims, one.regex);\n    if (two.val === null) return null;\n    // null if one/two are not contiguous.\n    if (one.raw + two.raw !== x) return null;\n    if (one.dim) return swapdim(one.val, two.val, one.dim);\n    else return [one.val, two.val];\n}\n\nfunction swapdim(a, b, dim) {\n    if (dim == 'N' || dim == 'S') return [a, b];\n    if (dim == 'W' || dim == 'E') return [b, a];\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3NleGFnZXNpbWFsL2luZGV4LmpzPzBhYjYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQix3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxNjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGVsZW1lbnQ7XG5tb2R1bGUuZXhwb3J0cy5wYWlyID0gcGFpcjtcbm1vZHVsZS5leHBvcnRzLmZvcm1hdCA9IGZvcm1hdDtcbm1vZHVsZS5leHBvcnRzLmZvcm1hdFBhaXIgPSBmb3JtYXRQYWlyO1xuXG5mdW5jdGlvbiBlbGVtZW50KHgsIGRpbXMpIHtcbiAgICByZXR1cm4gc2VhcmNoKHgsIGRpbXMpLnZhbDtcbn1cblxuZnVuY3Rpb24gZm9ybWF0UGFpcih4KSB7XG4gICAgcmV0dXJuIGZvcm1hdCh4LmxhdCwgJ2xhdCcpICsgJyAnICsgZm9ybWF0KHgubG9uLCAnbG9uJyk7XG59XG5cbi8vIElzIDAgTm9ydGggb3IgU291dGg/XG5mdW5jdGlvbiBmb3JtYXQoeCwgZGltKSB7XG4gICAgdmFyIGRpcnMgPSB7XG4gICAgICAgICAgICBsYXQ6IFsnTicsICdTJ10sXG4gICAgICAgICAgICBsb246IFsnRScsICdXJ11cbiAgICAgICAgfVtkaW1dIHx8ICcnLFxuICAgICAgICBkaXIgPSBkaXJzW3ggPj0gMCA/IDAgOiAxXSxcbiAgICAgICAgYWJzID0gTWF0aC5hYnMoeCksXG4gICAgICAgIHdob2xlID0gTWF0aC5mbG9vcihhYnMpLFxuICAgICAgICBmcmFjdGlvbiA9IGFicyAtIHdob2xlLFxuICAgICAgICBmcmFjdGlvbk1pbnV0ZXMgPSBmcmFjdGlvbiAqIDYwLFxuICAgICAgICBtaW51dGVzID0gTWF0aC5mbG9vcihmcmFjdGlvbk1pbnV0ZXMpLFxuICAgICAgICBzZWNvbmRzID0gTWF0aC5mbG9vcigoZnJhY3Rpb25NaW51dGVzIC0gbWludXRlcykgKiA2MCk7XG5cbiAgICByZXR1cm4gd2hvbGUgKyAnwrAgJyArXG4gICAgICAgIChtaW51dGVzID8gbWludXRlcyArIFwiJyBcIiA6ICcnKSArXG4gICAgICAgIChzZWNvbmRzID8gc2Vjb25kcyArICdcIiAnIDogJycpICsgZGlyO1xufVxuXG5mdW5jdGlvbiBzZWFyY2goeCwgZGltcywgcikge1xuICAgIGlmICghZGltcykgZGltcyA9ICdOU0VXJztcbiAgICBpZiAodHlwZW9mIHggIT09ICdzdHJpbmcnKSByZXR1cm4geyB2YWw6IG51bGwsIHJlZ2V4OiByIH07XG4gICAgciA9IHIgfHwgL1tcXHNcXCxdKihbXFwtfFxc4oCUfFxc4oCVXT9bMC05Ll0rKcKwPyAqKD86KFswLTkuXSspWyfigJnigLLigJhdICopPyg/OihbMC05Ll0rKSg/OicnfFwifOKAnXzigLMpICopPyhbTlNFV10pPy9naTtcbiAgICB2YXIgbSA9IHIuZXhlYyh4KTtcbiAgICBpZiAoIW0pIHJldHVybiB7IHZhbDogbnVsbCwgcmVnZXg6IHIgfTtcbiAgICBlbHNlIGlmIChtWzRdICYmIGRpbXMuaW5kZXhPZihtWzRdKSA9PT0gLTEpIHJldHVybiB7IHZhbDogbnVsbCwgcmVnZXg6IHIgfTtcbiAgICBlbHNlIHJldHVybiB7XG4gICAgICAgIHZhbDogKCgobVsxXSkgPyBwYXJzZUZsb2F0KG1bMV0pIDogMCkgK1xuICAgICAgICAgICAgKChtWzJdID8gcGFyc2VGbG9hdChtWzJdKSAvIDYwIDogMCkpICtcbiAgICAgICAgICAgICgobVszXSA/IHBhcnNlRmxvYXQobVszXSkgLyAzNjAwIDogMCkpKSAqXG4gICAgICAgICAgICAoKG1bNF0gJiYgbVs0XSA9PT0gJ1MnIHx8IG1bNF0gPT09ICdXJykgPyAtMSA6IDEpLFxuICAgICAgICByZWdleDogcixcbiAgICAgICAgcmF3OiBtWzBdLFxuICAgICAgICBkaW06IG1bNF1cbiAgICB9O1xufVxuXG5mdW5jdGlvbiBwYWlyKHgsIGRpbXMpIHtcbiAgICB4ID0geC50cmltKCk7XG4gICAgdmFyIG9uZSA9IHNlYXJjaCh4LCBkaW1zKTtcbiAgICBpZiAob25lLnZhbCA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gICAgdmFyIHR3byA9IHNlYXJjaCh4LCBkaW1zLCBvbmUucmVnZXgpO1xuICAgIGlmICh0d28udmFsID09PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgICAvLyBudWxsIGlmIG9uZS90d28gYXJlIG5vdCBjb250aWd1b3VzLlxuICAgIGlmIChvbmUucmF3ICsgdHdvLnJhdyAhPT0geCkgcmV0dXJuIG51bGw7XG4gICAgaWYgKG9uZS5kaW0pIHJldHVybiBzd2FwZGltKG9uZS52YWwsIHR3by52YWwsIG9uZS5kaW0pO1xuICAgIGVsc2UgcmV0dXJuIFtvbmUudmFsLCB0d28udmFsXTtcbn1cblxuZnVuY3Rpb24gc3dhcGRpbShhLCBiLCBkaW0pIHtcbiAgICBpZiAoZGltID09ICdOJyB8fCBkaW0gPT0gJ1MnKSByZXR1cm4gW2EsIGJdO1xuICAgIGlmIChkaW0gPT0gJ1cnIHx8IGRpbSA9PSAnRScpIHJldHVybiBbYiwgYV07XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2V4YWdlc2ltYWwvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE2NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){"use strict";eval("\r\nvar Promise = __webpack_require__(54);\r\nvar http = __webpack_require__(176);\r\nvar toArrayBuffer = __webpack_require__(69);\r\n\r\nmodule.exports = binaryAjax;\r\nvar i = -1;\r\n\r\nfunction binaryAjax(url) {\r\n  return new Promise(function(resolve, reject){\r\n    var type = url.slice(-3);\r\n    http.get(url, function (res) {\r\n      var len = 0;\r\n      var buffers = [];\r\n      if(res.statusCode > 399){\r\n        res.on('data', function (){});\r\n        if(type==='prj'){\r\n          return resolve(false);\r\n        }else{\r\n          return reject(new Error(res.statusCode));\r\n        }\r\n      }\r\n      res.on('data', function (d) {\r\n        len += d.length;\r\n        buffers.push(d);\r\n      });\r\n      res.on('error', function (e) {\r\n        reject(e);\r\n      });\r\n      res.on('end', function () {\r\n        var buffer = Buffer.concat(buffers, len);\r\n        if (type === 'prj') {\r\n          resolve(buffer.toString());\r\n        } else {\r\n          resolve(toArrayBuffer(buffer));\r\n        }\r\n      });\r\n    }).on('error', function (e) {\r\n        reject(e);\r\n      });\r\n  });\r\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3NocGpzL2xpYi9iaW5hcnlhamF4LmpzP2M0MjMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsT0FBTztBQUNQLEdBQUc7QUFDSCIsImZpbGUiOiIxNjUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcbnZhciBQcm9taXNlID0gcmVxdWlyZSgnbGllJyk7XHJcbnZhciBodHRwID0gcmVxdWlyZSgnaHR0cCcpO1xyXG52YXIgdG9BcnJheUJ1ZmZlciA9IHJlcXVpcmUoJy4vdG9BcnJheUJ1ZmZlcicpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBiaW5hcnlBamF4O1xyXG52YXIgaSA9IC0xO1xyXG5cclxuZnVuY3Rpb24gYmluYXJ5QWpheCh1cmwpIHtcclxuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcclxuICAgIHZhciB0eXBlID0gdXJsLnNsaWNlKC0zKTtcclxuICAgIGh0dHAuZ2V0KHVybCwgZnVuY3Rpb24gKHJlcykge1xyXG4gICAgICB2YXIgbGVuID0gMDtcclxuICAgICAgdmFyIGJ1ZmZlcnMgPSBbXTtcclxuICAgICAgaWYocmVzLnN0YXR1c0NvZGUgPiAzOTkpe1xyXG4gICAgICAgIHJlcy5vbignZGF0YScsIGZ1bmN0aW9uICgpe30pO1xyXG4gICAgICAgIGlmKHR5cGU9PT0ncHJqJyl7XHJcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZShmYWxzZSk7XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcihyZXMuc3RhdHVzQ29kZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXMub24oJ2RhdGEnLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIGxlbiArPSBkLmxlbmd0aDtcclxuICAgICAgICBidWZmZXJzLnB1c2goZCk7XHJcbiAgICAgIH0pO1xyXG4gICAgICByZXMub24oJ2Vycm9yJywgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICByZWplY3QoZSk7XHJcbiAgICAgIH0pO1xyXG4gICAgICByZXMub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYnVmZmVyID0gQnVmZmVyLmNvbmNhdChidWZmZXJzLCBsZW4pO1xyXG4gICAgICAgIGlmICh0eXBlID09PSAncHJqJykge1xyXG4gICAgICAgICAgcmVzb2x2ZShidWZmZXIudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJlc29sdmUodG9BcnJheUJ1ZmZlcihidWZmZXIpKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfSkub24oJ2Vycm9yJywgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICByZWplY3QoZSk7XHJcbiAgICAgIH0pO1xyXG4gIH0pO1xyXG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NocGpzL2xpYi9iaW5hcnlhamF4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){"use strict";eval("\r\nvar proj4 = __webpack_require__(63);\r\nvar unzip = __webpack_require__(168);\r\nvar binaryAjax = __webpack_require__(165);\r\nvar parseShp = __webpack_require__(167);\r\nvar toArrayBuffer = __webpack_require__(69);\r\nvar parseDbf = __webpack_require__(119);\r\nvar Promise = __webpack_require__(54);\r\nvar Cache = __webpack_require__(118);\r\nvar cache = new Cache({\r\n\tmax: 20\r\n});\r\nfunction shp(base, whiteList) {\r\n\tif (typeof base === 'string' && cache.has(base)) {\r\n\t\treturn Promise.resolve(cache.get(base));\r\n\t}\r\n\treturn shp.getShapefile(base, whiteList).then(function (resp) {\r\n\t\tif (typeof base === 'string') {\r\n\t\t\tcache.set(base, resp);\r\n\t\t}\r\n\t\treturn resp;\r\n\t});\r\n}\r\nshp.combine = function(arr) {\r\n\tvar out = {};\r\n\tout.type = 'FeatureCollection';\r\n\tout.features = [];\r\n\tvar i = 0;\r\n\tvar len = arr[0].length;\r\n\twhile (i < len) {\r\n\t\tout.features.push({\r\n\t\t\t'type': 'Feature',\r\n\t\t\t'geometry': arr[0][i],\r\n\t\t\t'properties': arr[1][i]\r\n\t\t});\r\n\t\ti++;\r\n\t}\r\n\treturn out;\r\n};\r\nshp.parseZip = function(buffer, whiteList) {\r\n\tvar key;\r\n\tvar zip = unzip(buffer);\r\n\tvar names = [];\r\n\twhiteList = whiteList || [];\r\n\tfor (key in zip) {\r\n\t\tif (key.indexOf('__MACOSX') !== -1) {\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tif (key.slice(-3).toLowerCase() === 'shp') {\r\n\t\t\tnames.push(key.slice(0, - 4));\r\n\t\t}\r\n\t\telse if (key.slice(-3).toLowerCase() === 'dbf') {\r\n\t\t\tzip[key.slice(0, -3) + key.slice(-3).toLowerCase()] = parseDbf(zip[key]);\r\n\t\t}\r\n\t\telse if (key.slice(-3).toLowerCase() === 'prj') {\r\n\t\t\tzip[key.slice(0, -3) + key.slice(-3).toLowerCase()] = proj4(zip[key]);\r\n\t\t}\r\n\t\telse if (key.slice(-4).toLowerCase() === 'json' || whiteList.indexOf(key.split('.').pop()) > -1) {\r\n\t\t\tnames.push(key.slice(0, -3) + key.slice(-3).toLowerCase());\r\n\t\t}\r\n\t}\r\n\tif (!names.length) {\r\n\t\tthrow new Error('no layers founds');\r\n\t}\r\n\tvar geojson = names.map(function(name) {\r\n\t\tvar parsed;\r\n\t\tif (name.slice(-4).toLowerCase() === 'json') {\r\n\t\t\tparsed = JSON.parse(zip[name]);\r\n\t\t\tparsed.fileName = name.slice(0, name.lastIndexOf('.'));\r\n\t\t}\r\n\t\telse if (whiteList.indexOf(name.slice(name.lastIndexOf('.') + 1)) > -1) {\r\n\t\t\tparsed = zip[name];\r\n\t\t\tparsed.fileName = name;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tparsed = shp.combine([parseShp(zip[name + '.shp'], zip[name + '.prj']), zip[name + '.dbf']]);\r\n\t\t\tparsed.fileName = name;\r\n\t\t}\r\n\t\treturn parsed;\r\n\t});\r\n\tif (geojson.length === 1) {\r\n\t\treturn geojson[0];\r\n\t}\r\n\telse {\r\n\t\treturn geojson;\r\n\t}\r\n};\r\n\r\nfunction getZip(base, whiteList) {\r\n\treturn binaryAjax(base).then(function(a) {\r\n\t\treturn shp.parseZip(a, whiteList);\r\n\t});\r\n}\r\nshp.getShapefile = function(base, whiteList) {\r\n\tif (typeof base === 'string') {\r\n\t\tif (base.slice(-4) === '.zip') {\r\n\t\t\treturn getZip(base, whiteList);\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn Promise.all([\r\n\t\t\t\tPromise.all([\r\n\t\t\t\t\tbinaryAjax(base + '.shp'),\r\n\t\t\t\t\tbinaryAjax(base + '.prj')\r\n\t\t\t\t]).then(function(args) {\r\n\t\t\t\t\treturn parseShp(args[0], args[1] ? proj4(args[1]) : false);\r\n\t\t\t\t}),\r\n\t\t\t\tbinaryAjax(base + '.dbf').then(parseDbf)\r\n\t\t\t]).then(shp.combine);\r\n\t\t}\r\n\t}\r\n\telse {\r\n\t\treturn new Promise(function(resolve) {\r\n\t\t\tresolve(shp.parseZip(base));\r\n\t\t});\r\n\t}\r\n};\r\nshp.parseShp = function (shp, prj) {\r\n\tif (Buffer.isBuffer(shp)) {\r\n\t\tshp = toArrayBuffer(shp);\r\n\t}\r\n\tif (Buffer.isBuffer(prj)) {\r\n\t\tprj = prj.toString();\r\n\t}\r\n\tif (typeof prj === 'string') {\r\n\t\tprj = proj4(prj);\r\n\t\treturn parseShp(shp, prj);\r\n\t} else {\r\n\t\treturn parseShp(shp);\r\n\t}\r\n};\r\nshp.parseDbf = function (dbf) {\r\n\tif (Buffer.isBuffer(dbf)) {\r\n\t\tdbf = toArrayBuffer(dbf);\r\n\t}\r\n\treturn parseDbf(dbf);\r\n};\r\nmodule.exports = shp;\r\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3NocGpzL2xpYi9pbmRleC5qcz80NDZhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTY2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG52YXIgcHJvajQgPSByZXF1aXJlKCdwcm9qNCcpO1xyXG52YXIgdW56aXAgPSByZXF1aXJlKCcuL3VuemlwJyk7XHJcbnZhciBiaW5hcnlBamF4ID0gcmVxdWlyZSgnLi9iaW5hcnlhamF4Jyk7XHJcbnZhciBwYXJzZVNocCA9IHJlcXVpcmUoJy4vcGFyc2VTaHAnKTtcclxudmFyIHRvQXJyYXlCdWZmZXIgPSByZXF1aXJlKCcuL3RvQXJyYXlCdWZmZXInKTtcclxudmFyIHBhcnNlRGJmID0gcmVxdWlyZSgncGFyc2VkYmYnKTtcclxudmFyIFByb21pc2UgPSByZXF1aXJlKCdsaWUnKTtcclxudmFyIENhY2hlID0gcmVxdWlyZSgnbHJ1LWNhY2hlJyk7XHJcbnZhciBjYWNoZSA9IG5ldyBDYWNoZSh7XHJcblx0bWF4OiAyMFxyXG59KTtcclxuZnVuY3Rpb24gc2hwKGJhc2UsIHdoaXRlTGlzdCkge1xyXG5cdGlmICh0eXBlb2YgYmFzZSA9PT0gJ3N0cmluZycgJiYgY2FjaGUuaGFzKGJhc2UpKSB7XHJcblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNhY2hlLmdldChiYXNlKSk7XHJcblx0fVxyXG5cdHJldHVybiBzaHAuZ2V0U2hhcGVmaWxlKGJhc2UsIHdoaXRlTGlzdCkudGhlbihmdW5jdGlvbiAocmVzcCkge1xyXG5cdFx0aWYgKHR5cGVvZiBiYXNlID09PSAnc3RyaW5nJykge1xyXG5cdFx0XHRjYWNoZS5zZXQoYmFzZSwgcmVzcCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmVzcDtcclxuXHR9KTtcclxufVxyXG5zaHAuY29tYmluZSA9IGZ1bmN0aW9uKGFycikge1xyXG5cdHZhciBvdXQgPSB7fTtcclxuXHRvdXQudHlwZSA9ICdGZWF0dXJlQ29sbGVjdGlvbic7XHJcblx0b3V0LmZlYXR1cmVzID0gW107XHJcblx0dmFyIGkgPSAwO1xyXG5cdHZhciBsZW4gPSBhcnJbMF0ubGVuZ3RoO1xyXG5cdHdoaWxlIChpIDwgbGVuKSB7XHJcblx0XHRvdXQuZmVhdHVyZXMucHVzaCh7XHJcblx0XHRcdCd0eXBlJzogJ0ZlYXR1cmUnLFxyXG5cdFx0XHQnZ2VvbWV0cnknOiBhcnJbMF1baV0sXHJcblx0XHRcdCdwcm9wZXJ0aWVzJzogYXJyWzFdW2ldXHJcblx0XHR9KTtcclxuXHRcdGkrKztcclxuXHR9XHJcblx0cmV0dXJuIG91dDtcclxufTtcclxuc2hwLnBhcnNlWmlwID0gZnVuY3Rpb24oYnVmZmVyLCB3aGl0ZUxpc3QpIHtcclxuXHR2YXIga2V5O1xyXG5cdHZhciB6aXAgPSB1bnppcChidWZmZXIpO1xyXG5cdHZhciBuYW1lcyA9IFtdO1xyXG5cdHdoaXRlTGlzdCA9IHdoaXRlTGlzdCB8fCBbXTtcclxuXHRmb3IgKGtleSBpbiB6aXApIHtcclxuXHRcdGlmIChrZXkuaW5kZXhPZignX19NQUNPU1gnKSAhPT0gLTEpIHtcclxuXHRcdFx0Y29udGludWU7XHJcblx0XHR9XHJcblx0XHRpZiAoa2V5LnNsaWNlKC0zKS50b0xvd2VyQ2FzZSgpID09PSAnc2hwJykge1xyXG5cdFx0XHRuYW1lcy5wdXNoKGtleS5zbGljZSgwLCAtIDQpKTtcclxuXHRcdH1cclxuXHRcdGVsc2UgaWYgKGtleS5zbGljZSgtMykudG9Mb3dlckNhc2UoKSA9PT0gJ2RiZicpIHtcclxuXHRcdFx0emlwW2tleS5zbGljZSgwLCAtMykgKyBrZXkuc2xpY2UoLTMpLnRvTG93ZXJDYXNlKCldID0gcGFyc2VEYmYoemlwW2tleV0pO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSBpZiAoa2V5LnNsaWNlKC0zKS50b0xvd2VyQ2FzZSgpID09PSAncHJqJykge1xyXG5cdFx0XHR6aXBba2V5LnNsaWNlKDAsIC0zKSArIGtleS5zbGljZSgtMykudG9Mb3dlckNhc2UoKV0gPSBwcm9qNCh6aXBba2V5XSk7XHJcblx0XHR9XHJcblx0XHRlbHNlIGlmIChrZXkuc2xpY2UoLTQpLnRvTG93ZXJDYXNlKCkgPT09ICdqc29uJyB8fCB3aGl0ZUxpc3QuaW5kZXhPZihrZXkuc3BsaXQoJy4nKS5wb3AoKSkgPiAtMSkge1xyXG5cdFx0XHRuYW1lcy5wdXNoKGtleS5zbGljZSgwLCAtMykgKyBrZXkuc2xpY2UoLTMpLnRvTG93ZXJDYXNlKCkpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAoIW5hbWVzLmxlbmd0aCkge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKCdubyBsYXllcnMgZm91bmRzJyk7XHJcblx0fVxyXG5cdHZhciBnZW9qc29uID0gbmFtZXMubWFwKGZ1bmN0aW9uKG5hbWUpIHtcclxuXHRcdHZhciBwYXJzZWQ7XHJcblx0XHRpZiAobmFtZS5zbGljZSgtNCkudG9Mb3dlckNhc2UoKSA9PT0gJ2pzb24nKSB7XHJcblx0XHRcdHBhcnNlZCA9IEpTT04ucGFyc2UoemlwW25hbWVdKTtcclxuXHRcdFx0cGFyc2VkLmZpbGVOYW1lID0gbmFtZS5zbGljZSgwLCBuYW1lLmxhc3RJbmRleE9mKCcuJykpO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSBpZiAod2hpdGVMaXN0LmluZGV4T2YobmFtZS5zbGljZShuYW1lLmxhc3RJbmRleE9mKCcuJykgKyAxKSkgPiAtMSkge1xyXG5cdFx0XHRwYXJzZWQgPSB6aXBbbmFtZV07XHJcblx0XHRcdHBhcnNlZC5maWxlTmFtZSA9IG5hbWU7XHJcblx0XHR9XHJcblx0XHRlbHNlIHtcclxuXHRcdFx0cGFyc2VkID0gc2hwLmNvbWJpbmUoW3BhcnNlU2hwKHppcFtuYW1lICsgJy5zaHAnXSwgemlwW25hbWUgKyAnLnByaiddKSwgemlwW25hbWUgKyAnLmRiZiddXSk7XHJcblx0XHRcdHBhcnNlZC5maWxlTmFtZSA9IG5hbWU7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcGFyc2VkO1xyXG5cdH0pO1xyXG5cdGlmIChnZW9qc29uLmxlbmd0aCA9PT0gMSkge1xyXG5cdFx0cmV0dXJuIGdlb2pzb25bMF07XHJcblx0fVxyXG5cdGVsc2Uge1xyXG5cdFx0cmV0dXJuIGdlb2pzb247XHJcblx0fVxyXG59O1xyXG5cclxuZnVuY3Rpb24gZ2V0WmlwKGJhc2UsIHdoaXRlTGlzdCkge1xyXG5cdHJldHVybiBiaW5hcnlBamF4KGJhc2UpLnRoZW4oZnVuY3Rpb24oYSkge1xyXG5cdFx0cmV0dXJuIHNocC5wYXJzZVppcChhLCB3aGl0ZUxpc3QpO1xyXG5cdH0pO1xyXG59XHJcbnNocC5nZXRTaGFwZWZpbGUgPSBmdW5jdGlvbihiYXNlLCB3aGl0ZUxpc3QpIHtcclxuXHRpZiAodHlwZW9mIGJhc2UgPT09ICdzdHJpbmcnKSB7XHJcblx0XHRpZiAoYmFzZS5zbGljZSgtNCkgPT09ICcuemlwJykge1xyXG5cdFx0XHRyZXR1cm4gZ2V0WmlwKGJhc2UsIHdoaXRlTGlzdCk7XHJcblx0XHR9XHJcblx0XHRlbHNlIHtcclxuXHRcdFx0cmV0dXJuIFByb21pc2UuYWxsKFtcclxuXHRcdFx0XHRQcm9taXNlLmFsbChbXHJcblx0XHRcdFx0XHRiaW5hcnlBamF4KGJhc2UgKyAnLnNocCcpLFxyXG5cdFx0XHRcdFx0YmluYXJ5QWpheChiYXNlICsgJy5wcmonKVxyXG5cdFx0XHRcdF0pLnRoZW4oZnVuY3Rpb24oYXJncykge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHBhcnNlU2hwKGFyZ3NbMF0sIGFyZ3NbMV0gPyBwcm9qNChhcmdzWzFdKSA6IGZhbHNlKTtcclxuXHRcdFx0XHR9KSxcclxuXHRcdFx0XHRiaW5hcnlBamF4KGJhc2UgKyAnLmRiZicpLnRoZW4ocGFyc2VEYmYpXHJcblx0XHRcdF0pLnRoZW4oc2hwLmNvbWJpbmUpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRlbHNlIHtcclxuXHRcdHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XHJcblx0XHRcdHJlc29sdmUoc2hwLnBhcnNlWmlwKGJhc2UpKTtcclxuXHRcdH0pO1xyXG5cdH1cclxufTtcclxuc2hwLnBhcnNlU2hwID0gZnVuY3Rpb24gKHNocCwgcHJqKSB7XHJcblx0aWYgKEJ1ZmZlci5pc0J1ZmZlcihzaHApKSB7XHJcblx0XHRzaHAgPSB0b0FycmF5QnVmZmVyKHNocCk7XHJcblx0fVxyXG5cdGlmIChCdWZmZXIuaXNCdWZmZXIocHJqKSkge1xyXG5cdFx0cHJqID0gcHJqLnRvU3RyaW5nKCk7XHJcblx0fVxyXG5cdGlmICh0eXBlb2YgcHJqID09PSAnc3RyaW5nJykge1xyXG5cdFx0cHJqID0gcHJvajQocHJqKTtcclxuXHRcdHJldHVybiBwYXJzZVNocChzaHAsIHByaik7XHJcblx0fSBlbHNlIHtcclxuXHRcdHJldHVybiBwYXJzZVNocChzaHApO1xyXG5cdH1cclxufTtcclxuc2hwLnBhcnNlRGJmID0gZnVuY3Rpb24gKGRiZikge1xyXG5cdGlmIChCdWZmZXIuaXNCdWZmZXIoZGJmKSkge1xyXG5cdFx0ZGJmID0gdG9BcnJheUJ1ZmZlcihkYmYpO1xyXG5cdH1cclxuXHRyZXR1cm4gcGFyc2VEYmYoZGJmKTtcclxufTtcclxubW9kdWxlLmV4cG9ydHMgPSBzaHA7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zaHBqcy9saWIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){"use strict";eval("\r\nfunction isClockWise(array){\r\n\tvar sum = 0;\r\n\tvar i = 1;\r\n\tvar len = array.length;\r\n\tvar prev,cur;\r\n\twhile(i<len){\r\n\t\tprev = cur||array[0];\r\n\t\tcur = array[i];\r\n\t\tsum += ((cur[0]-prev[0])*(cur[1]+prev[1]));\r\n\t\ti++;\r\n\t}\r\n\treturn sum > 0;\r\n}\r\nfunction polyReduce(a,b){\r\n\tif(isClockWise(b)||!a.length){\r\n\t\ta.push([b]);\r\n\t}else{\r\n\t\ta[a.length-1].push(b);\r\n\t}\r\n\treturn a;\r\n}\r\nParseShp.prototype.parsePoint = function (data){\r\n\treturn {\r\n\t\t'type': 'Point',\r\n\t\t'coordinates': this.parseCoord(data,0)\r\n\t};\r\n};\r\nParseShp.prototype.parseZPoint = function (data){\r\n\tvar pointXY = this.parsePoint(data);\r\n\tpointXY.coordinates.push(this.parseCoord(data,16));\r\n\treturn pointXY;\r\n};\r\nParseShp.prototype.parsePointArray = function (data,offset,num){\r\n\tvar out = [];\r\n\tvar done = 0;\r\n\twhile(done<num){\r\n\t\tout.push(this.parseCoord(data,offset));\r\n\t\toffset += 16;\r\n\t\tdone++;\r\n\t}\r\n\treturn out;\r\n};\r\nParseShp.prototype.parseZPointArray = function (data,zOffset,num,coordinates){\r\n\tvar i = 0;\r\n\twhile(i<num){\r\n\t\tcoordinates[i].push(data.getFloat64(zOffset,true));\r\n\t\ti++;\r\n\t\tzOffset += 8;\r\n\t}\r\n\treturn coordinates;\r\n};\r\nParseShp.prototype.parseArrayGroup = function (data,offset,partOffset,num,tot){\r\n\tvar out = [];\r\n\tvar done = 0;\r\n\tvar curNum,nextNum=0,pointNumber;\r\n\twhile(done<num){\r\n\t\tdone++;\r\n\t\tpartOffset += 4;\r\n\t\tcurNum = nextNum;\r\n\t\tif(done===num){\r\n\t\t\tnextNum = tot;\r\n\t\t}else{\r\n\t\t\tnextNum = data.getInt32(partOffset,true);\r\n\t\t}\r\n\t\tpointNumber = nextNum - curNum;\r\n\t\tif(!pointNumber){\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tout.push(this.parsePointArray(data,offset,pointNumber));\r\n\t\toffset += (pointNumber<<4);\r\n\t}\r\n\treturn out;\r\n};\r\nParseShp.prototype.parseZArrayGroup = function(data,zOffset,num,coordinates){\r\n\tvar i = 0;\r\n\twhile(i<num){\r\n\t\tcoordinates[i] = this.parseZPointArray(data,zOffset,coordinates[i].length,coordinates[i]);\r\n\t\tzOffset += (coordinates[i].length<<3);\r\n\t\ti++;\r\n\t}\r\n\treturn coordinates;\r\n};\r\nParseShp.prototype.parseMultiPoint = function (data){\r\n\tvar out = {};\r\n\tvar mins = this.parseCoord(data,0);\r\n\tvar maxs = this.parseCoord(data,16);\r\n\tout.bbox = [\r\n\t\tmins[0],\r\n\t\tmins[1],\r\n\t\tmaxs[0],\r\n\t\tmaxs[1]\r\n\t];\r\n\tvar num = data.getInt32(32,true);\r\n\tvar offset = 36;\r\n\tif(num===1){\r\n\t\tout.type = 'Point';\r\n\t\tout.coordinates = this.parseCoord(data,offset);\r\n\t}else{\r\n\t\tout.type = 'MultiPoint';\r\n\t\tout.coordinates = this.parsePointArray(data,offset,num);\r\n\t}\r\n\treturn out;\r\n};\r\nParseShp.prototype.parseZMultiPoint = function(data){\r\n\tvar geoJson = this.parseMultiPoint(data);\r\n\tvar num;\r\n\tif(geoJson.type === 'Point'){\r\n\t\tgeoJson.coordinates.push(data.getFloat64(72,true));\r\n\t\treturn geoJson;\r\n\t}else{\r\n\t\tnum = geoJson.coordinates.length;\r\n\t}\r\n\tvar zOffset = 56 + (num<<4);\r\n\tgeoJson.coordinates =  this.parseZPointArray(data,zOffset,num,geoJson.coordinates);\r\n\treturn geoJson;\r\n};\r\nParseShp.prototype.parsePolyline = function (data){\r\n\tvar out = {};\r\n\tvar mins = this.parseCoord(data,0);\r\n\tvar maxs = this.parseCoord(data,16);\r\n\tout.bbox = [\r\n\t\tmins[0],\r\n\t\tmins[1],\r\n\t\tmaxs[0],\r\n\t\tmaxs[1]\r\n\t];\r\n\tvar numParts = data.getInt32(32,true);\r\n\tvar num = data.getInt32(36,true);\r\n\tvar offset,partOffset;\r\n\tif(numParts === 1){\r\n\t\tout.type = 'LineString';\r\n\t\toffset = 44;\r\n\t\tout.coordinates = this.parsePointArray(data,offset,num);\r\n\t}else{\r\n\t\tout.type = 'MultiLineString';\r\n\t\toffset = 40 + (numParts<<2);\r\n\t\tpartOffset = 40;\r\n\t\tout.coordinates = this.parseArrayGroup(data,offset,partOffset,numParts,num);\r\n\t}\r\n\treturn out;\r\n};\r\nParseShp.prototype.parseZPolyline = function(data){\r\n\tvar geoJson = this.parsePolyline(data);\r\n\tvar num = geoJson.coordinates.length;\r\n\tvar zOffset = 60 + (num<<4);\r\n\tif(geoJson.type === 'LineString'){\r\n\t\tgeoJson.coordinates =  this.parseZPointArray(data,zOffset,num,geoJson.coordinates);\r\n\t\treturn geoJson;\r\n\t}else{\r\n\t\tgeoJson.coordinates =  this.parseZArrayGroup(data,zOffset,num,geoJson.coordinates);\r\n\t\treturn geoJson;\r\n\t}\r\n};\r\nParseShp.prototype.polyFuncs = function (out){\r\n\tif(out.type === 'LineString'){\r\n\t\tout.type = 'Polygon';\r\n\t\tout.coordinates = [out.coordinates];\r\n\t\treturn out;\r\n\t}else{\r\n\t\tout.coordinates = out.coordinates.reduce(polyReduce,[]);\r\n\t\tif(out.coordinates.length === 1){\r\n\t\t\tout.type = 'Polygon';\r\n\t\t\tout.coordinates = out.coordinates[0];\r\n\t\t\treturn out;\r\n\t\t}else{\r\n\t\t\tout.type = 'MultiPolygon';\r\n\t\t\treturn out;\r\n\t\t}\r\n\t}\r\n};\r\nParseShp.prototype.parsePolygon = function (data){\r\n\treturn this.polyFuncs(this.parsePolyline(data));\r\n};\r\nParseShp.prototype.parseZPolygon = function(data){\r\n\treturn this.polyFuncs(this.parseZPolyline(data));\r\n};\r\nvar shpFuncObj = {\r\n\t1:'parsePoint',\r\n\t3:'parsePolyline',\r\n\t5:'parsePolygon',\r\n\t8:'parseMultiPoint',\r\n\t11:'parseZPoint',\r\n\t13:'parseZPolyline',\r\n\t15:'parseZPolygon',\r\n\t18:'parseZMultiPoint'\r\n};\r\n\r\n\r\n\r\nfunction makeParseCoord(trans){\r\n\tif(trans){\r\n\t\treturn function(data,offset){\r\n\t\t\treturn trans.inverse([data.getFloat64(offset,true),data.getFloat64(offset+8,true)]);\r\n\t\t};\r\n\t}else{\r\n\t\treturn function(data,offset){\r\n\t\t\treturn [data.getFloat64(offset,true),data.getFloat64(offset+8,true)];\r\n\t\t};\r\n\t}\r\n}\r\nfunction ParseShp(buffer,trans){\r\n\tif(!(this instanceof ParseShp)){\r\n\t\treturn new ParseShp(buffer,trans);\r\n\t}\r\n\tthis.buffer = buffer;\r\n\tthis.shpFuncs(trans);\r\n\tthis.rows = this.getRows();\r\n}\r\nParseShp.prototype.shpFuncs = function (tran){\r\n\tvar num = this.getShpCode();\r\n\tif(num>20){\r\n\t\tnum -= 20;\r\n\t}\r\n\tif(!(num in shpFuncObj)){\r\n\t\tthrow new Error('I don\\'t know that shp type');\r\n\t}\r\n\tthis.parseFunc = this[shpFuncObj[num]];\r\n\tthis.parseCoord = makeParseCoord(tran);\r\n};\r\nParseShp.prototype.getShpCode = function(){\r\n\treturn this.parseHeader().shpCode;\r\n};\r\nParseShp.prototype.parseHeader = function (){\r\n\tvar view = new DataView(this.buffer,0,100) ;\r\n\treturn {\r\n\t\tlength : view.getInt32(6<<2,false),\r\n\t\tversion : view.getInt32(7<<2,true),\r\n\t\tshpCode : view.getInt32(8<<2,true),\r\n\t\tbbox : [\r\n\t\t\tview.getFloat64(9<<2,true),\r\n\t\t\tview.getFloat64(11<<2,true),\r\n\t\t\tview.getFloat64(13<<2,true),\r\n\t\t\tview.getFloat64(13<<2,true)\r\n\t\t]\r\n\t};\r\n};\r\nParseShp.prototype.getRows = function(){\r\n\tvar offset=100;\r\n\tvar len = this.buffer.byteLength;\r\n\tvar out = [];\r\n\tvar current;\r\n\twhile(offset<len){\r\n\t\tcurrent = this.getRow(offset);\r\n\t\toffset += 8;\r\n\t\toffset += current.len;\r\n\t\tif(current.type){\r\n\t\t\tout.push(this.parseFunc(current.data));\r\n\t\t}\r\n\t}\r\n\treturn out;\r\n};\r\nParseShp.prototype.getRow = function(offset){\r\n\tvar view = new DataView(this.buffer,offset,12);\r\n\tvar len = view.getInt32(4,false) << 1;\r\n\tvar data = new DataView(this.buffer,offset+12,len - 4);\r\n\t\r\n\treturn {\r\n\t\tid:view.getInt32(0,false),\r\n\t\tlen:len,\r\n\t\tdata:data,\r\n\t\ttype:view.getInt32(8,true)\r\n\t};\r\n};\r\nmodule.exports = function(buffer, trans){\r\n\treturn new ParseShp(buffer, trans).rows;\r\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3NocGpzL2xpYi9wYXJzZVNocC5qcz80Njk2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjE2Ny5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcclxuZnVuY3Rpb24gaXNDbG9ja1dpc2UoYXJyYXkpe1xyXG5cdHZhciBzdW0gPSAwO1xyXG5cdHZhciBpID0gMTtcclxuXHR2YXIgbGVuID0gYXJyYXkubGVuZ3RoO1xyXG5cdHZhciBwcmV2LGN1cjtcclxuXHR3aGlsZShpPGxlbil7XHJcblx0XHRwcmV2ID0gY3VyfHxhcnJheVswXTtcclxuXHRcdGN1ciA9IGFycmF5W2ldO1xyXG5cdFx0c3VtICs9ICgoY3VyWzBdLXByZXZbMF0pKihjdXJbMV0rcHJldlsxXSkpO1xyXG5cdFx0aSsrO1xyXG5cdH1cclxuXHRyZXR1cm4gc3VtID4gMDtcclxufVxyXG5mdW5jdGlvbiBwb2x5UmVkdWNlKGEsYil7XHJcblx0aWYoaXNDbG9ja1dpc2UoYil8fCFhLmxlbmd0aCl7XHJcblx0XHRhLnB1c2goW2JdKTtcclxuXHR9ZWxzZXtcclxuXHRcdGFbYS5sZW5ndGgtMV0ucHVzaChiKTtcclxuXHR9XHJcblx0cmV0dXJuIGE7XHJcbn1cclxuUGFyc2VTaHAucHJvdG90eXBlLnBhcnNlUG9pbnQgPSBmdW5jdGlvbiAoZGF0YSl7XHJcblx0cmV0dXJuIHtcclxuXHRcdCd0eXBlJzogJ1BvaW50JyxcclxuXHRcdCdjb29yZGluYXRlcyc6IHRoaXMucGFyc2VDb29yZChkYXRhLDApXHJcblx0fTtcclxufTtcclxuUGFyc2VTaHAucHJvdG90eXBlLnBhcnNlWlBvaW50ID0gZnVuY3Rpb24gKGRhdGEpe1xyXG5cdHZhciBwb2ludFhZID0gdGhpcy5wYXJzZVBvaW50KGRhdGEpO1xyXG5cdHBvaW50WFkuY29vcmRpbmF0ZXMucHVzaCh0aGlzLnBhcnNlQ29vcmQoZGF0YSwxNikpO1xyXG5cdHJldHVybiBwb2ludFhZO1xyXG59O1xyXG5QYXJzZVNocC5wcm90b3R5cGUucGFyc2VQb2ludEFycmF5ID0gZnVuY3Rpb24gKGRhdGEsb2Zmc2V0LG51bSl7XHJcblx0dmFyIG91dCA9IFtdO1xyXG5cdHZhciBkb25lID0gMDtcclxuXHR3aGlsZShkb25lPG51bSl7XHJcblx0XHRvdXQucHVzaCh0aGlzLnBhcnNlQ29vcmQoZGF0YSxvZmZzZXQpKTtcclxuXHRcdG9mZnNldCArPSAxNjtcclxuXHRcdGRvbmUrKztcclxuXHR9XHJcblx0cmV0dXJuIG91dDtcclxufTtcclxuUGFyc2VTaHAucHJvdG90eXBlLnBhcnNlWlBvaW50QXJyYXkgPSBmdW5jdGlvbiAoZGF0YSx6T2Zmc2V0LG51bSxjb29yZGluYXRlcyl7XHJcblx0dmFyIGkgPSAwO1xyXG5cdHdoaWxlKGk8bnVtKXtcclxuXHRcdGNvb3JkaW5hdGVzW2ldLnB1c2goZGF0YS5nZXRGbG9hdDY0KHpPZmZzZXQsdHJ1ZSkpO1xyXG5cdFx0aSsrO1xyXG5cdFx0ek9mZnNldCArPSA4O1xyXG5cdH1cclxuXHRyZXR1cm4gY29vcmRpbmF0ZXM7XHJcbn07XHJcblBhcnNlU2hwLnByb3RvdHlwZS5wYXJzZUFycmF5R3JvdXAgPSBmdW5jdGlvbiAoZGF0YSxvZmZzZXQscGFydE9mZnNldCxudW0sdG90KXtcclxuXHR2YXIgb3V0ID0gW107XHJcblx0dmFyIGRvbmUgPSAwO1xyXG5cdHZhciBjdXJOdW0sbmV4dE51bT0wLHBvaW50TnVtYmVyO1xyXG5cdHdoaWxlKGRvbmU8bnVtKXtcclxuXHRcdGRvbmUrKztcclxuXHRcdHBhcnRPZmZzZXQgKz0gNDtcclxuXHRcdGN1ck51bSA9IG5leHROdW07XHJcblx0XHRpZihkb25lPT09bnVtKXtcclxuXHRcdFx0bmV4dE51bSA9IHRvdDtcclxuXHRcdH1lbHNle1xyXG5cdFx0XHRuZXh0TnVtID0gZGF0YS5nZXRJbnQzMihwYXJ0T2Zmc2V0LHRydWUpO1xyXG5cdFx0fVxyXG5cdFx0cG9pbnROdW1iZXIgPSBuZXh0TnVtIC0gY3VyTnVtO1xyXG5cdFx0aWYoIXBvaW50TnVtYmVyKXtcclxuXHRcdFx0Y29udGludWU7XHJcblx0XHR9XHJcblx0XHRvdXQucHVzaCh0aGlzLnBhcnNlUG9pbnRBcnJheShkYXRhLG9mZnNldCxwb2ludE51bWJlcikpO1xyXG5cdFx0b2Zmc2V0ICs9IChwb2ludE51bWJlcjw8NCk7XHJcblx0fVxyXG5cdHJldHVybiBvdXQ7XHJcbn07XHJcblBhcnNlU2hwLnByb3RvdHlwZS5wYXJzZVpBcnJheUdyb3VwID0gZnVuY3Rpb24oZGF0YSx6T2Zmc2V0LG51bSxjb29yZGluYXRlcyl7XHJcblx0dmFyIGkgPSAwO1xyXG5cdHdoaWxlKGk8bnVtKXtcclxuXHRcdGNvb3JkaW5hdGVzW2ldID0gdGhpcy5wYXJzZVpQb2ludEFycmF5KGRhdGEsek9mZnNldCxjb29yZGluYXRlc1tpXS5sZW5ndGgsY29vcmRpbmF0ZXNbaV0pO1xyXG5cdFx0ek9mZnNldCArPSAoY29vcmRpbmF0ZXNbaV0ubGVuZ3RoPDwzKTtcclxuXHRcdGkrKztcclxuXHR9XHJcblx0cmV0dXJuIGNvb3JkaW5hdGVzO1xyXG59O1xyXG5QYXJzZVNocC5wcm90b3R5cGUucGFyc2VNdWx0aVBvaW50ID0gZnVuY3Rpb24gKGRhdGEpe1xyXG5cdHZhciBvdXQgPSB7fTtcclxuXHR2YXIgbWlucyA9IHRoaXMucGFyc2VDb29yZChkYXRhLDApO1xyXG5cdHZhciBtYXhzID0gdGhpcy5wYXJzZUNvb3JkKGRhdGEsMTYpO1xyXG5cdG91dC5iYm94ID0gW1xyXG5cdFx0bWluc1swXSxcclxuXHRcdG1pbnNbMV0sXHJcblx0XHRtYXhzWzBdLFxyXG5cdFx0bWF4c1sxXVxyXG5cdF07XHJcblx0dmFyIG51bSA9IGRhdGEuZ2V0SW50MzIoMzIsdHJ1ZSk7XHJcblx0dmFyIG9mZnNldCA9IDM2O1xyXG5cdGlmKG51bT09PTEpe1xyXG5cdFx0b3V0LnR5cGUgPSAnUG9pbnQnO1xyXG5cdFx0b3V0LmNvb3JkaW5hdGVzID0gdGhpcy5wYXJzZUNvb3JkKGRhdGEsb2Zmc2V0KTtcclxuXHR9ZWxzZXtcclxuXHRcdG91dC50eXBlID0gJ011bHRpUG9pbnQnO1xyXG5cdFx0b3V0LmNvb3JkaW5hdGVzID0gdGhpcy5wYXJzZVBvaW50QXJyYXkoZGF0YSxvZmZzZXQsbnVtKTtcclxuXHR9XHJcblx0cmV0dXJuIG91dDtcclxufTtcclxuUGFyc2VTaHAucHJvdG90eXBlLnBhcnNlWk11bHRpUG9pbnQgPSBmdW5jdGlvbihkYXRhKXtcclxuXHR2YXIgZ2VvSnNvbiA9IHRoaXMucGFyc2VNdWx0aVBvaW50KGRhdGEpO1xyXG5cdHZhciBudW07XHJcblx0aWYoZ2VvSnNvbi50eXBlID09PSAnUG9pbnQnKXtcclxuXHRcdGdlb0pzb24uY29vcmRpbmF0ZXMucHVzaChkYXRhLmdldEZsb2F0NjQoNzIsdHJ1ZSkpO1xyXG5cdFx0cmV0dXJuIGdlb0pzb247XHJcblx0fWVsc2V7XHJcblx0XHRudW0gPSBnZW9Kc29uLmNvb3JkaW5hdGVzLmxlbmd0aDtcclxuXHR9XHJcblx0dmFyIHpPZmZzZXQgPSA1NiArIChudW08PDQpO1xyXG5cdGdlb0pzb24uY29vcmRpbmF0ZXMgPSAgdGhpcy5wYXJzZVpQb2ludEFycmF5KGRhdGEsek9mZnNldCxudW0sZ2VvSnNvbi5jb29yZGluYXRlcyk7XHJcblx0cmV0dXJuIGdlb0pzb247XHJcbn07XHJcblBhcnNlU2hwLnByb3RvdHlwZS5wYXJzZVBvbHlsaW5lID0gZnVuY3Rpb24gKGRhdGEpe1xyXG5cdHZhciBvdXQgPSB7fTtcclxuXHR2YXIgbWlucyA9IHRoaXMucGFyc2VDb29yZChkYXRhLDApO1xyXG5cdHZhciBtYXhzID0gdGhpcy5wYXJzZUNvb3JkKGRhdGEsMTYpO1xyXG5cdG91dC5iYm94ID0gW1xyXG5cdFx0bWluc1swXSxcclxuXHRcdG1pbnNbMV0sXHJcblx0XHRtYXhzWzBdLFxyXG5cdFx0bWF4c1sxXVxyXG5cdF07XHJcblx0dmFyIG51bVBhcnRzID0gZGF0YS5nZXRJbnQzMigzMix0cnVlKTtcclxuXHR2YXIgbnVtID0gZGF0YS5nZXRJbnQzMigzNix0cnVlKTtcclxuXHR2YXIgb2Zmc2V0LHBhcnRPZmZzZXQ7XHJcblx0aWYobnVtUGFydHMgPT09IDEpe1xyXG5cdFx0b3V0LnR5cGUgPSAnTGluZVN0cmluZyc7XHJcblx0XHRvZmZzZXQgPSA0NDtcclxuXHRcdG91dC5jb29yZGluYXRlcyA9IHRoaXMucGFyc2VQb2ludEFycmF5KGRhdGEsb2Zmc2V0LG51bSk7XHJcblx0fWVsc2V7XHJcblx0XHRvdXQudHlwZSA9ICdNdWx0aUxpbmVTdHJpbmcnO1xyXG5cdFx0b2Zmc2V0ID0gNDAgKyAobnVtUGFydHM8PDIpO1xyXG5cdFx0cGFydE9mZnNldCA9IDQwO1xyXG5cdFx0b3V0LmNvb3JkaW5hdGVzID0gdGhpcy5wYXJzZUFycmF5R3JvdXAoZGF0YSxvZmZzZXQscGFydE9mZnNldCxudW1QYXJ0cyxudW0pO1xyXG5cdH1cclxuXHRyZXR1cm4gb3V0O1xyXG59O1xyXG5QYXJzZVNocC5wcm90b3R5cGUucGFyc2VaUG9seWxpbmUgPSBmdW5jdGlvbihkYXRhKXtcclxuXHR2YXIgZ2VvSnNvbiA9IHRoaXMucGFyc2VQb2x5bGluZShkYXRhKTtcclxuXHR2YXIgbnVtID0gZ2VvSnNvbi5jb29yZGluYXRlcy5sZW5ndGg7XHJcblx0dmFyIHpPZmZzZXQgPSA2MCArIChudW08PDQpO1xyXG5cdGlmKGdlb0pzb24udHlwZSA9PT0gJ0xpbmVTdHJpbmcnKXtcclxuXHRcdGdlb0pzb24uY29vcmRpbmF0ZXMgPSAgdGhpcy5wYXJzZVpQb2ludEFycmF5KGRhdGEsek9mZnNldCxudW0sZ2VvSnNvbi5jb29yZGluYXRlcyk7XHJcblx0XHRyZXR1cm4gZ2VvSnNvbjtcclxuXHR9ZWxzZXtcclxuXHRcdGdlb0pzb24uY29vcmRpbmF0ZXMgPSAgdGhpcy5wYXJzZVpBcnJheUdyb3VwKGRhdGEsek9mZnNldCxudW0sZ2VvSnNvbi5jb29yZGluYXRlcyk7XHJcblx0XHRyZXR1cm4gZ2VvSnNvbjtcclxuXHR9XHJcbn07XHJcblBhcnNlU2hwLnByb3RvdHlwZS5wb2x5RnVuY3MgPSBmdW5jdGlvbiAob3V0KXtcclxuXHRpZihvdXQudHlwZSA9PT0gJ0xpbmVTdHJpbmcnKXtcclxuXHRcdG91dC50eXBlID0gJ1BvbHlnb24nO1xyXG5cdFx0b3V0LmNvb3JkaW5hdGVzID0gW291dC5jb29yZGluYXRlc107XHJcblx0XHRyZXR1cm4gb3V0O1xyXG5cdH1lbHNle1xyXG5cdFx0b3V0LmNvb3JkaW5hdGVzID0gb3V0LmNvb3JkaW5hdGVzLnJlZHVjZShwb2x5UmVkdWNlLFtdKTtcclxuXHRcdGlmKG91dC5jb29yZGluYXRlcy5sZW5ndGggPT09IDEpe1xyXG5cdFx0XHRvdXQudHlwZSA9ICdQb2x5Z29uJztcclxuXHRcdFx0b3V0LmNvb3JkaW5hdGVzID0gb3V0LmNvb3JkaW5hdGVzWzBdO1xyXG5cdFx0XHRyZXR1cm4gb3V0O1xyXG5cdFx0fWVsc2V7XHJcblx0XHRcdG91dC50eXBlID0gJ011bHRpUG9seWdvbic7XHJcblx0XHRcdHJldHVybiBvdXQ7XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG5QYXJzZVNocC5wcm90b3R5cGUucGFyc2VQb2x5Z29uID0gZnVuY3Rpb24gKGRhdGEpe1xyXG5cdHJldHVybiB0aGlzLnBvbHlGdW5jcyh0aGlzLnBhcnNlUG9seWxpbmUoZGF0YSkpO1xyXG59O1xyXG5QYXJzZVNocC5wcm90b3R5cGUucGFyc2VaUG9seWdvbiA9IGZ1bmN0aW9uKGRhdGEpe1xyXG5cdHJldHVybiB0aGlzLnBvbHlGdW5jcyh0aGlzLnBhcnNlWlBvbHlsaW5lKGRhdGEpKTtcclxufTtcclxudmFyIHNocEZ1bmNPYmogPSB7XHJcblx0MToncGFyc2VQb2ludCcsXHJcblx0MzoncGFyc2VQb2x5bGluZScsXHJcblx0NToncGFyc2VQb2x5Z29uJyxcclxuXHQ4OidwYXJzZU11bHRpUG9pbnQnLFxyXG5cdDExOidwYXJzZVpQb2ludCcsXHJcblx0MTM6J3BhcnNlWlBvbHlsaW5lJyxcclxuXHQxNToncGFyc2VaUG9seWdvbicsXHJcblx0MTg6J3BhcnNlWk11bHRpUG9pbnQnXHJcbn07XHJcblxyXG5cclxuXHJcbmZ1bmN0aW9uIG1ha2VQYXJzZUNvb3JkKHRyYW5zKXtcclxuXHRpZih0cmFucyl7XHJcblx0XHRyZXR1cm4gZnVuY3Rpb24oZGF0YSxvZmZzZXQpe1xyXG5cdFx0XHRyZXR1cm4gdHJhbnMuaW52ZXJzZShbZGF0YS5nZXRGbG9hdDY0KG9mZnNldCx0cnVlKSxkYXRhLmdldEZsb2F0NjQob2Zmc2V0KzgsdHJ1ZSldKTtcclxuXHRcdH07XHJcblx0fWVsc2V7XHJcblx0XHRyZXR1cm4gZnVuY3Rpb24oZGF0YSxvZmZzZXQpe1xyXG5cdFx0XHRyZXR1cm4gW2RhdGEuZ2V0RmxvYXQ2NChvZmZzZXQsdHJ1ZSksZGF0YS5nZXRGbG9hdDY0KG9mZnNldCs4LHRydWUpXTtcclxuXHRcdH07XHJcblx0fVxyXG59XHJcbmZ1bmN0aW9uIFBhcnNlU2hwKGJ1ZmZlcix0cmFucyl7XHJcblx0aWYoISh0aGlzIGluc3RhbmNlb2YgUGFyc2VTaHApKXtcclxuXHRcdHJldHVybiBuZXcgUGFyc2VTaHAoYnVmZmVyLHRyYW5zKTtcclxuXHR9XHJcblx0dGhpcy5idWZmZXIgPSBidWZmZXI7XHJcblx0dGhpcy5zaHBGdW5jcyh0cmFucyk7XHJcblx0dGhpcy5yb3dzID0gdGhpcy5nZXRSb3dzKCk7XHJcbn1cclxuUGFyc2VTaHAucHJvdG90eXBlLnNocEZ1bmNzID0gZnVuY3Rpb24gKHRyYW4pe1xyXG5cdHZhciBudW0gPSB0aGlzLmdldFNocENvZGUoKTtcclxuXHRpZihudW0+MjApe1xyXG5cdFx0bnVtIC09IDIwO1xyXG5cdH1cclxuXHRpZighKG51bSBpbiBzaHBGdW5jT2JqKSl7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ0kgZG9uXFwndCBrbm93IHRoYXQgc2hwIHR5cGUnKTtcclxuXHR9XHJcblx0dGhpcy5wYXJzZUZ1bmMgPSB0aGlzW3NocEZ1bmNPYmpbbnVtXV07XHJcblx0dGhpcy5wYXJzZUNvb3JkID0gbWFrZVBhcnNlQ29vcmQodHJhbik7XHJcbn07XHJcblBhcnNlU2hwLnByb3RvdHlwZS5nZXRTaHBDb2RlID0gZnVuY3Rpb24oKXtcclxuXHRyZXR1cm4gdGhpcy5wYXJzZUhlYWRlcigpLnNocENvZGU7XHJcbn07XHJcblBhcnNlU2hwLnByb3RvdHlwZS5wYXJzZUhlYWRlciA9IGZ1bmN0aW9uICgpe1xyXG5cdHZhciB2aWV3ID0gbmV3IERhdGFWaWV3KHRoaXMuYnVmZmVyLDAsMTAwKSA7XHJcblx0cmV0dXJuIHtcclxuXHRcdGxlbmd0aCA6IHZpZXcuZ2V0SW50MzIoNjw8MixmYWxzZSksXHJcblx0XHR2ZXJzaW9uIDogdmlldy5nZXRJbnQzMig3PDwyLHRydWUpLFxyXG5cdFx0c2hwQ29kZSA6IHZpZXcuZ2V0SW50MzIoODw8Mix0cnVlKSxcclxuXHRcdGJib3ggOiBbXHJcblx0XHRcdHZpZXcuZ2V0RmxvYXQ2NCg5PDwyLHRydWUpLFxyXG5cdFx0XHR2aWV3LmdldEZsb2F0NjQoMTE8PDIsdHJ1ZSksXHJcblx0XHRcdHZpZXcuZ2V0RmxvYXQ2NCgxMzw8Mix0cnVlKSxcclxuXHRcdFx0dmlldy5nZXRGbG9hdDY0KDEzPDwyLHRydWUpXHJcblx0XHRdXHJcblx0fTtcclxufTtcclxuUGFyc2VTaHAucHJvdG90eXBlLmdldFJvd3MgPSBmdW5jdGlvbigpe1xyXG5cdHZhciBvZmZzZXQ9MTAwO1xyXG5cdHZhciBsZW4gPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xyXG5cdHZhciBvdXQgPSBbXTtcclxuXHR2YXIgY3VycmVudDtcclxuXHR3aGlsZShvZmZzZXQ8bGVuKXtcclxuXHRcdGN1cnJlbnQgPSB0aGlzLmdldFJvdyhvZmZzZXQpO1xyXG5cdFx0b2Zmc2V0ICs9IDg7XHJcblx0XHRvZmZzZXQgKz0gY3VycmVudC5sZW47XHJcblx0XHRpZihjdXJyZW50LnR5cGUpe1xyXG5cdFx0XHRvdXQucHVzaCh0aGlzLnBhcnNlRnVuYyhjdXJyZW50LmRhdGEpKTtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIG91dDtcclxufTtcclxuUGFyc2VTaHAucHJvdG90eXBlLmdldFJvdyA9IGZ1bmN0aW9uKG9mZnNldCl7XHJcblx0dmFyIHZpZXcgPSBuZXcgRGF0YVZpZXcodGhpcy5idWZmZXIsb2Zmc2V0LDEyKTtcclxuXHR2YXIgbGVuID0gdmlldy5nZXRJbnQzMig0LGZhbHNlKSA8PCAxO1xyXG5cdHZhciBkYXRhID0gbmV3IERhdGFWaWV3KHRoaXMuYnVmZmVyLG9mZnNldCsxMixsZW4gLSA0KTtcclxuXHRcclxuXHRyZXR1cm4ge1xyXG5cdFx0aWQ6dmlldy5nZXRJbnQzMigwLGZhbHNlKSxcclxuXHRcdGxlbjpsZW4sXHJcblx0XHRkYXRhOmRhdGEsXHJcblx0XHR0eXBlOnZpZXcuZ2V0SW50MzIoOCx0cnVlKVxyXG5cdH07XHJcbn07XHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYnVmZmVyLCB0cmFucyl7XHJcblx0cmV0dXJuIG5ldyBQYXJzZVNocChidWZmZXIsIHRyYW5zKS5yb3dzO1xyXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zaHBqcy9saWIvcGFyc2VTaHAuanNcbi8vIG1vZHVsZSBpZCA9IDE2N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports,__webpack_require__){"use strict";eval("\r\n\r\nvar JSZip = __webpack_require__(99);\r\nmodule.exports = function(buffer) {\r\n\tvar zip = new JSZip(buffer);\r\n\tvar files = zip.file(/.+/);\r\n\tvar out = {};\r\n\tfiles.forEach(function(a) {\r\n\t\tif (a.name.slice(-3).toLowerCase() === 'shp' || a.name.slice(-3).toLowerCase() === 'dbf') {\r\n\t\t\tout[a.name] = a.asText();\r\n\t\t\tout[a.name] = a.asArrayBuffer();\r\n\t\t}\r\n\t\telse {\r\n\t\t\tout[a.name] = a.asText();\r\n\t\t}\r\n\t});\r\n\treturn out;\r\n};\r\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3NocGpzL2xpYi91bnppcC5qcz8wNTcwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EiLCJmaWxlIjoiMTY4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIEpTWmlwID0gcmVxdWlyZSgnanN6aXAnKTtcclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihidWZmZXIpIHtcclxuXHR2YXIgemlwID0gbmV3IEpTWmlwKGJ1ZmZlcik7XHJcblx0dmFyIGZpbGVzID0gemlwLmZpbGUoLy4rLyk7XHJcblx0dmFyIG91dCA9IHt9O1xyXG5cdGZpbGVzLmZvckVhY2goZnVuY3Rpb24oYSkge1xyXG5cdFx0aWYgKGEubmFtZS5zbGljZSgtMykudG9Mb3dlckNhc2UoKSA9PT0gJ3NocCcgfHwgYS5uYW1lLnNsaWNlKC0zKS50b0xvd2VyQ2FzZSgpID09PSAnZGJmJykge1xyXG5cdFx0XHRvdXRbYS5uYW1lXSA9IGEuYXNUZXh0KCk7XHJcblx0XHRcdG91dFthLm5hbWVdID0gYS5hc0FycmF5QnVmZmVyKCk7XHJcblx0XHR9XHJcblx0XHRlbHNlIHtcclxuXHRcdFx0b3V0W2EubmFtZV0gPSBhLmFzVGV4dCgpO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG5cdHJldHVybiBvdXQ7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zaHBqcy9saWIvdW56aXAuanNcbi8vIG1vZHVsZSBpZCA9IDE2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9")},function(module,exports){eval('/*\n\nStackBlur - a fast almost Gaussian Blur For Canvas\n\nVersion: \t0.5\nAuthor:\t\tMario Klingemann\nContact: \tmario@quasimondo.com\nWebsite:\thttp://www.quasimondo.com/StackBlurForCanvas\nTwitter:\t@quasimondo\n\nIn case you find this class useful - especially in commercial projects -\nI am not totally unhappy for a small donation to my PayPal account\nmario@quasimondo.de\n\nOr support me on flattr: \nhttps://flattr.com/thing/72791/StackBlur-a-fast-almost-Gaussian-Blur-Effect-for-CanvasJavascript\n\nCopyright (c) 2010 Mario Klingemann\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the "Software"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n*/\n\nvar mul_table = [\n        512,512,456,512,328,456,335,512,405,328,271,456,388,335,292,512,\n        454,405,364,328,298,271,496,456,420,388,360,335,312,292,273,512,\n        482,454,428,405,383,364,345,328,312,298,284,271,259,496,475,456,\n        437,420,404,388,374,360,347,335,323,312,302,292,282,273,265,512,\n        497,482,468,454,441,428,417,405,394,383,373,364,354,345,337,328,\n        320,312,305,298,291,284,278,271,265,259,507,496,485,475,465,456,\n        446,437,428,420,412,404,396,388,381,374,367,360,354,347,341,335,\n        329,323,318,312,307,302,297,292,287,282,278,273,269,265,261,512,\n        505,497,489,482,475,468,461,454,447,441,435,428,422,417,411,405,\n        399,394,389,383,378,373,368,364,359,354,350,345,341,337,332,328,\n        324,320,316,312,309,305,301,298,294,291,287,284,281,278,274,271,\n        268,265,262,259,257,507,501,496,491,485,480,475,470,465,460,456,\n        451,446,442,437,433,428,424,420,416,412,408,404,400,396,392,388,\n        385,381,377,374,370,367,363,360,357,354,350,347,344,341,338,335,\n        332,329,326,323,320,318,315,312,310,307,304,302,299,297,294,292,\n        289,287,285,282,280,278,275,273,271,269,267,265,263,261,259];\n        \n   \nvar shg_table = [\n\t     9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, \n\t\t17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, \n\t\t19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20,\n\t\t20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21,\n\t\t21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,\n\t\t21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, \n\t\t22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,\n\t\t22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, \n\t\t23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,\n\t\t23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,\n\t\t23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, \n\t\t23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, \n\t\t24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n\t\t24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n\t\t24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n\t\t24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24 ];\n\nfunction blur( pixels, width, height, radius )\n{\n\tif ( isNaN(radius) || radius < 1 ) return;\n\tradius |= 0;\n\n\tvar x, y, i, p, yp, yi, yw, r_sum, g_sum, b_sum, a_sum, \n\tr_out_sum, g_out_sum, b_out_sum, a_out_sum,\n\tr_in_sum, g_in_sum, b_in_sum, a_in_sum, \n\tpr, pg, pb, pa, rbs;\n\t\t\t\n\tvar div = radius + radius + 1;\n\tvar w4 = width << 2;\n\tvar widthMinus1  = width - 1;\n\tvar heightMinus1 = height - 1;\n\tvar radiusPlus1  = radius + 1;\n\tvar sumFactor = radiusPlus1 * ( radiusPlus1 + 1 ) / 2;\n\t\n\tvar stackStart = new BlurStack();\n\tvar stack = stackStart;\n\tfor ( i = 1; i < div; i++ )\n\t{\n\t\tstack = stack.next = new BlurStack();\n\t\tif ( i == radiusPlus1 ) var stackEnd = stack;\n\t}\n\tstack.next = stackStart;\n\tvar stackIn = null;\n\tvar stackOut = null;\n\t\n\tyw = yi = 0;\n\t\n\tvar mul_sum = mul_table[radius];\n\tvar shg_sum = shg_table[radius];\n\t\n\tfor ( y = 0; y < height; y++ )\n\t{\n\t\tr_in_sum = g_in_sum = b_in_sum = a_in_sum = r_sum = g_sum = b_sum = a_sum = 0;\n\t\t\n\t\tr_out_sum = radiusPlus1 * ( pr = pixels[yi] );\n\t\tg_out_sum = radiusPlus1 * ( pg = pixels[yi+1] );\n\t\tb_out_sum = radiusPlus1 * ( pb = pixels[yi+2] );\n\t\ta_out_sum = radiusPlus1 * ( pa = pixels[yi+3] );\n\t\t\n\t\tr_sum += sumFactor * pr;\n\t\tg_sum += sumFactor * pg;\n\t\tb_sum += sumFactor * pb;\n\t\ta_sum += sumFactor * pa;\n\t\t\n\t\tstack = stackStart;\n\t\t\n\t\tfor( i = 0; i < radiusPlus1; i++ )\n\t\t{\n\t\t\tstack.r = pr;\n\t\t\tstack.g = pg;\n\t\t\tstack.b = pb;\n\t\t\tstack.a = pa;\n\t\t\tstack = stack.next;\n\t\t}\n\t\t\n\t\tfor( i = 1; i < radiusPlus1; i++ )\n\t\t{\n\t\t\tp = yi + (( widthMinus1 < i ? widthMinus1 : i ) << 2 );\n\t\t\tr_sum += ( stack.r = ( pr = pixels[p])) * ( rbs = radiusPlus1 - i );\n\t\t\tg_sum += ( stack.g = ( pg = pixels[p+1])) * rbs;\n\t\t\tb_sum += ( stack.b = ( pb = pixels[p+2])) * rbs;\n\t\t\ta_sum += ( stack.a = ( pa = pixels[p+3])) * rbs;\n\t\t\t\n\t\t\tr_in_sum += pr;\n\t\t\tg_in_sum += pg;\n\t\t\tb_in_sum += pb;\n\t\t\ta_in_sum += pa;\n\t\t\t\n\t\t\tstack = stack.next;\n\t\t}\n\t\t\n\t\t\n\t\tstackIn = stackStart;\n\t\tstackOut = stackEnd;\n\t\tfor ( x = 0; x < width; x++ )\n\t\t{\n\t\t\tpixels[yi+3] = pa = (a_sum * mul_sum) >> shg_sum;\n\t\t\tif ( pa != 0 )\n\t\t\t{\n\t\t\t\tpa = 255 / pa;\n\t\t\t\tpixels[yi]   = ((r_sum * mul_sum) >> shg_sum) * pa;\n\t\t\t\tpixels[yi+1] = ((g_sum * mul_sum) >> shg_sum) * pa;\n\t\t\t\tpixels[yi+2] = ((b_sum * mul_sum) >> shg_sum) * pa;\n\t\t\t} else {\n\t\t\t\tpixels[yi] = pixels[yi+1] = pixels[yi+2] = 0;\n\t\t\t}\n\t\t\t\n\t\t\tr_sum -= r_out_sum;\n\t\t\tg_sum -= g_out_sum;\n\t\t\tb_sum -= b_out_sum;\n\t\t\ta_sum -= a_out_sum;\n\t\t\t\n\t\t\tr_out_sum -= stackIn.r;\n\t\t\tg_out_sum -= stackIn.g;\n\t\t\tb_out_sum -= stackIn.b;\n\t\t\ta_out_sum -= stackIn.a;\n\t\t\t\n\t\t\tp =  ( yw + ( ( p = x + radius + 1 ) < widthMinus1 ? p : widthMinus1 ) ) << 2;\n\t\t\t\n\t\t\tr_in_sum += ( stackIn.r = pixels[p]);\n\t\t\tg_in_sum += ( stackIn.g = pixels[p+1]);\n\t\t\tb_in_sum += ( stackIn.b = pixels[p+2]);\n\t\t\ta_in_sum += ( stackIn.a = pixels[p+3]);\n\t\t\t\n\t\t\tr_sum += r_in_sum;\n\t\t\tg_sum += g_in_sum;\n\t\t\tb_sum += b_in_sum;\n\t\t\ta_sum += a_in_sum;\n\t\t\t\n\t\t\tstackIn = stackIn.next;\n\t\t\t\n\t\t\tr_out_sum += ( pr = stackOut.r );\n\t\t\tg_out_sum += ( pg = stackOut.g );\n\t\t\tb_out_sum += ( pb = stackOut.b );\n\t\t\ta_out_sum += ( pa = stackOut.a );\n\t\t\t\n\t\t\tr_in_sum -= pr;\n\t\t\tg_in_sum -= pg;\n\t\t\tb_in_sum -= pb;\n\t\t\ta_in_sum -= pa;\n\t\t\t\n\t\t\tstackOut = stackOut.next;\n\n\t\t\tyi += 4;\n\t\t}\n\t\tyw += width;\n\t}\n\n\t\n\tfor ( x = 0; x < width; x++ )\n\t{\n\t\tg_in_sum = b_in_sum = a_in_sum = r_in_sum = g_sum = b_sum = a_sum = r_sum = 0;\n\t\t\n\t\tyi = x << 2;\n\t\tr_out_sum = radiusPlus1 * ( pr = pixels[yi]);\n\t\tg_out_sum = radiusPlus1 * ( pg = pixels[yi+1]);\n\t\tb_out_sum = radiusPlus1 * ( pb = pixels[yi+2]);\n\t\ta_out_sum = radiusPlus1 * ( pa = pixels[yi+3]);\n\t\t\n\t\tr_sum += sumFactor * pr;\n\t\tg_sum += sumFactor * pg;\n\t\tb_sum += sumFactor * pb;\n\t\ta_sum += sumFactor * pa;\n\t\t\n\t\tstack = stackStart;\n\t\t\n\t\tfor( i = 0; i < radiusPlus1; i++ )\n\t\t{\n\t\t\tstack.r = pr;\n\t\t\tstack.g = pg;\n\t\t\tstack.b = pb;\n\t\t\tstack.a = pa;\n\t\t\tstack = stack.next;\n\t\t}\n\t\t\n\t\typ = width;\n\t\t\n\t\tfor( i = 1; i <= radius; i++ )\n\t\t{\n\t\t\tyi = ( yp + x ) << 2;\n\t\t\t\n\t\t\tr_sum += ( stack.r = ( pr = pixels[yi])) * ( rbs = radiusPlus1 - i );\n\t\t\tg_sum += ( stack.g = ( pg = pixels[yi+1])) * rbs;\n\t\t\tb_sum += ( stack.b = ( pb = pixels[yi+2])) * rbs;\n\t\t\ta_sum += ( stack.a = ( pa = pixels[yi+3])) * rbs;\n\t\t   \n\t\t\tr_in_sum += pr;\n\t\t\tg_in_sum += pg;\n\t\t\tb_in_sum += pb;\n\t\t\ta_in_sum += pa;\n\t\t\t\n\t\t\tstack = stack.next;\n\t\t\n\t\t\tif( i < heightMinus1 )\n\t\t\t{\n\t\t\t\typ += width;\n\t\t\t}\n\t\t}\n\t\t\n\t\tyi = x;\n\t\tstackIn = stackStart;\n\t\tstackOut = stackEnd;\n\t\tfor ( y = 0; y < height; y++ )\n\t\t{\n\t\t\tp = yi << 2;\n\t\t\tpixels[p+3] = pa = (a_sum * mul_sum) >> shg_sum;\n\t\t\tif ( pa > 0 )\n\t\t\t{\n\t\t\t\tpa = 255 / pa;\n\t\t\t\tpixels[p]   = ((r_sum * mul_sum) >> shg_sum ) * pa;\n\t\t\t\tpixels[p+1] = ((g_sum * mul_sum) >> shg_sum ) * pa;\n\t\t\t\tpixels[p+2] = ((b_sum * mul_sum) >> shg_sum ) * pa;\n\t\t\t} else {\n\t\t\t\tpixels[p] = pixels[p+1] = pixels[p+2] = 0;\n\t\t\t}\n\t\t\t\n\t\t\tr_sum -= r_out_sum;\n\t\t\tg_sum -= g_out_sum;\n\t\t\tb_sum -= b_out_sum;\n\t\t\ta_sum -= a_out_sum;\n\t\t   \n\t\t\tr_out_sum -= stackIn.r;\n\t\t\tg_out_sum -= stackIn.g;\n\t\t\tb_out_sum -= stackIn.b;\n\t\t\ta_out_sum -= stackIn.a;\n\t\t\t\n\t\t\tp = ( x + (( ( p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1 ) * width )) << 2;\n\t\t\t\n\t\t\tr_sum += ( r_in_sum += ( stackIn.r = pixels[p]));\n\t\t\tg_sum += ( g_in_sum += ( stackIn.g = pixels[p+1]));\n\t\t\tb_sum += ( b_in_sum += ( stackIn.b = pixels[p+2]));\n\t\t\ta_sum += ( a_in_sum += ( stackIn.a = pixels[p+3]));\n\t\t   \n\t\t\tstackIn = stackIn.next;\n\t\t\t\n\t\t\tr_out_sum += ( pr = stackOut.r );\n\t\t\tg_out_sum += ( pg = stackOut.g );\n\t\t\tb_out_sum += ( pb = stackOut.b );\n\t\t\ta_out_sum += ( pa = stackOut.a );\n\t\t\t\n\t\t\tr_in_sum -= pr;\n\t\t\tg_in_sum -= pg;\n\t\t\tb_in_sum -= pb;\n\t\t\ta_in_sum -= pa;\n\t\t\t\n\t\t\tstackOut = stackOut.next;\n\t\t\t\n\t\t\tyi += width;\n\t\t}\n\t}\n}\n\nfunction BlurStack()\n{\n\tthis.r = 0;\n\tthis.g = 0;\n\tthis.b = 0;\n\tthis.a = 0;\n\tthis.next = null;\n}\n\nmodule.exports = blur;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3N0YWNrYmx1ci9pbmRleC5qcz8wNzgyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxjQUFjLFdBQVc7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxhQUFhLFdBQVc7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGFBQWEsYUFBYTtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxZQUFZO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMTY5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcblxuU3RhY2tCbHVyIC0gYSBmYXN0IGFsbW9zdCBHYXVzc2lhbiBCbHVyIEZvciBDYW52YXNcblxuVmVyc2lvbjogXHQwLjVcbkF1dGhvcjpcdFx0TWFyaW8gS2xpbmdlbWFublxuQ29udGFjdDogXHRtYXJpb0BxdWFzaW1vbmRvLmNvbVxuV2Vic2l0ZTpcdGh0dHA6Ly93d3cucXVhc2ltb25kby5jb20vU3RhY2tCbHVyRm9yQ2FudmFzXG5Ud2l0dGVyOlx0QHF1YXNpbW9uZG9cblxuSW4gY2FzZSB5b3UgZmluZCB0aGlzIGNsYXNzIHVzZWZ1bCAtIGVzcGVjaWFsbHkgaW4gY29tbWVyY2lhbCBwcm9qZWN0cyAtXG5JIGFtIG5vdCB0b3RhbGx5IHVuaGFwcHkgZm9yIGEgc21hbGwgZG9uYXRpb24gdG8gbXkgUGF5UGFsIGFjY291bnRcbm1hcmlvQHF1YXNpbW9uZG8uZGVcblxuT3Igc3VwcG9ydCBtZSBvbiBmbGF0dHI6IFxuaHR0cHM6Ly9mbGF0dHIuY29tL3RoaW5nLzcyNzkxL1N0YWNrQmx1ci1hLWZhc3QtYWxtb3N0LUdhdXNzaWFuLUJsdXItRWZmZWN0LWZvci1DYW52YXNKYXZhc2NyaXB0XG5cbkNvcHlyaWdodCAoYykgMjAxMCBNYXJpbyBLbGluZ2VtYW5uXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG5vYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxuZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0XG5yZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSxcbmNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcblNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXG5jb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG5FWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcbk9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG5OT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXG5XSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbkZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1Jcbk9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiovXG5cbnZhciBtdWxfdGFibGUgPSBbXG4gICAgICAgIDUxMiw1MTIsNDU2LDUxMiwzMjgsNDU2LDMzNSw1MTIsNDA1LDMyOCwyNzEsNDU2LDM4OCwzMzUsMjkyLDUxMixcbiAgICAgICAgNDU0LDQwNSwzNjQsMzI4LDI5OCwyNzEsNDk2LDQ1Niw0MjAsMzg4LDM2MCwzMzUsMzEyLDI5MiwyNzMsNTEyLFxuICAgICAgICA0ODIsNDU0LDQyOCw0MDUsMzgzLDM2NCwzNDUsMzI4LDMxMiwyOTgsMjg0LDI3MSwyNTksNDk2LDQ3NSw0NTYsXG4gICAgICAgIDQzNyw0MjAsNDA0LDM4OCwzNzQsMzYwLDM0NywzMzUsMzIzLDMxMiwzMDIsMjkyLDI4MiwyNzMsMjY1LDUxMixcbiAgICAgICAgNDk3LDQ4Miw0NjgsNDU0LDQ0MSw0MjgsNDE3LDQwNSwzOTQsMzgzLDM3MywzNjQsMzU0LDM0NSwzMzcsMzI4LFxuICAgICAgICAzMjAsMzEyLDMwNSwyOTgsMjkxLDI4NCwyNzgsMjcxLDI2NSwyNTksNTA3LDQ5Niw0ODUsNDc1LDQ2NSw0NTYsXG4gICAgICAgIDQ0Niw0MzcsNDI4LDQyMCw0MTIsNDA0LDM5NiwzODgsMzgxLDM3NCwzNjcsMzYwLDM1NCwzNDcsMzQxLDMzNSxcbiAgICAgICAgMzI5LDMyMywzMTgsMzEyLDMwNywzMDIsMjk3LDI5MiwyODcsMjgyLDI3OCwyNzMsMjY5LDI2NSwyNjEsNTEyLFxuICAgICAgICA1MDUsNDk3LDQ4OSw0ODIsNDc1LDQ2OCw0NjEsNDU0LDQ0Nyw0NDEsNDM1LDQyOCw0MjIsNDE3LDQxMSw0MDUsXG4gICAgICAgIDM5OSwzOTQsMzg5LDM4MywzNzgsMzczLDM2OCwzNjQsMzU5LDM1NCwzNTAsMzQ1LDM0MSwzMzcsMzMyLDMyOCxcbiAgICAgICAgMzI0LDMyMCwzMTYsMzEyLDMwOSwzMDUsMzAxLDI5OCwyOTQsMjkxLDI4NywyODQsMjgxLDI3OCwyNzQsMjcxLFxuICAgICAgICAyNjgsMjY1LDI2MiwyNTksMjU3LDUwNyw1MDEsNDk2LDQ5MSw0ODUsNDgwLDQ3NSw0NzAsNDY1LDQ2MCw0NTYsXG4gICAgICAgIDQ1MSw0NDYsNDQyLDQzNyw0MzMsNDI4LDQyNCw0MjAsNDE2LDQxMiw0MDgsNDA0LDQwMCwzOTYsMzkyLDM4OCxcbiAgICAgICAgMzg1LDM4MSwzNzcsMzc0LDM3MCwzNjcsMzYzLDM2MCwzNTcsMzU0LDM1MCwzNDcsMzQ0LDM0MSwzMzgsMzM1LFxuICAgICAgICAzMzIsMzI5LDMyNiwzMjMsMzIwLDMxOCwzMTUsMzEyLDMxMCwzMDcsMzA0LDMwMiwyOTksMjk3LDI5NCwyOTIsXG4gICAgICAgIDI4OSwyODcsMjg1LDI4MiwyODAsMjc4LDI3NSwyNzMsMjcxLDI2OSwyNjcsMjY1LDI2MywyNjEsMjU5XTtcbiAgICAgICAgXG4gICBcbnZhciBzaGdfdGFibGUgPSBbXG5cdCAgICAgOSwgMTEsIDEyLCAxMywgMTMsIDE0LCAxNCwgMTUsIDE1LCAxNSwgMTUsIDE2LCAxNiwgMTYsIDE2LCAxNywgXG5cdFx0MTcsIDE3LCAxNywgMTcsIDE3LCAxNywgMTgsIDE4LCAxOCwgMTgsIDE4LCAxOCwgMTgsIDE4LCAxOCwgMTksIFxuXHRcdDE5LCAxOSwgMTksIDE5LCAxOSwgMTksIDE5LCAxOSwgMTksIDE5LCAxOSwgMTksIDE5LCAyMCwgMjAsIDIwLFxuXHRcdDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIxLFxuXHRcdDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLFxuXHRcdDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCBcblx0XHQyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMixcblx0XHQyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMywgXG5cdFx0MjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsXG5cdFx0MjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsXG5cdFx0MjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIFxuXHRcdDIzLCAyMywgMjMsIDIzLCAyMywgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCBcblx0XHQyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCxcblx0XHQyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCxcblx0XHQyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCxcblx0XHQyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0IF07XG5cbmZ1bmN0aW9uIGJsdXIoIHBpeGVscywgd2lkdGgsIGhlaWdodCwgcmFkaXVzIClcbntcblx0aWYgKCBpc05hTihyYWRpdXMpIHx8IHJhZGl1cyA8IDEgKSByZXR1cm47XG5cdHJhZGl1cyB8PSAwO1xuXG5cdHZhciB4LCB5LCBpLCBwLCB5cCwgeWksIHl3LCByX3N1bSwgZ19zdW0sIGJfc3VtLCBhX3N1bSwgXG5cdHJfb3V0X3N1bSwgZ19vdXRfc3VtLCBiX291dF9zdW0sIGFfb3V0X3N1bSxcblx0cl9pbl9zdW0sIGdfaW5fc3VtLCBiX2luX3N1bSwgYV9pbl9zdW0sIFxuXHRwciwgcGcsIHBiLCBwYSwgcmJzO1xuXHRcdFx0XG5cdHZhciBkaXYgPSByYWRpdXMgKyByYWRpdXMgKyAxO1xuXHR2YXIgdzQgPSB3aWR0aCA8PCAyO1xuXHR2YXIgd2lkdGhNaW51czEgID0gd2lkdGggLSAxO1xuXHR2YXIgaGVpZ2h0TWludXMxID0gaGVpZ2h0IC0gMTtcblx0dmFyIHJhZGl1c1BsdXMxICA9IHJhZGl1cyArIDE7XG5cdHZhciBzdW1GYWN0b3IgPSByYWRpdXNQbHVzMSAqICggcmFkaXVzUGx1czEgKyAxICkgLyAyO1xuXHRcblx0dmFyIHN0YWNrU3RhcnQgPSBuZXcgQmx1clN0YWNrKCk7XG5cdHZhciBzdGFjayA9IHN0YWNrU3RhcnQ7XG5cdGZvciAoIGkgPSAxOyBpIDwgZGl2OyBpKysgKVxuXHR7XG5cdFx0c3RhY2sgPSBzdGFjay5uZXh0ID0gbmV3IEJsdXJTdGFjaygpO1xuXHRcdGlmICggaSA9PSByYWRpdXNQbHVzMSApIHZhciBzdGFja0VuZCA9IHN0YWNrO1xuXHR9XG5cdHN0YWNrLm5leHQgPSBzdGFja1N0YXJ0O1xuXHR2YXIgc3RhY2tJbiA9IG51bGw7XG5cdHZhciBzdGFja091dCA9IG51bGw7XG5cdFxuXHR5dyA9IHlpID0gMDtcblx0XG5cdHZhciBtdWxfc3VtID0gbXVsX3RhYmxlW3JhZGl1c107XG5cdHZhciBzaGdfc3VtID0gc2hnX3RhYmxlW3JhZGl1c107XG5cdFxuXHRmb3IgKCB5ID0gMDsgeSA8IGhlaWdodDsgeSsrIClcblx0e1xuXHRcdHJfaW5fc3VtID0gZ19pbl9zdW0gPSBiX2luX3N1bSA9IGFfaW5fc3VtID0gcl9zdW0gPSBnX3N1bSA9IGJfc3VtID0gYV9zdW0gPSAwO1xuXHRcdFxuXHRcdHJfb3V0X3N1bSA9IHJhZGl1c1BsdXMxICogKCBwciA9IHBpeGVsc1t5aV0gKTtcblx0XHRnX291dF9zdW0gPSByYWRpdXNQbHVzMSAqICggcGcgPSBwaXhlbHNbeWkrMV0gKTtcblx0XHRiX291dF9zdW0gPSByYWRpdXNQbHVzMSAqICggcGIgPSBwaXhlbHNbeWkrMl0gKTtcblx0XHRhX291dF9zdW0gPSByYWRpdXNQbHVzMSAqICggcGEgPSBwaXhlbHNbeWkrM10gKTtcblx0XHRcblx0XHRyX3N1bSArPSBzdW1GYWN0b3IgKiBwcjtcblx0XHRnX3N1bSArPSBzdW1GYWN0b3IgKiBwZztcblx0XHRiX3N1bSArPSBzdW1GYWN0b3IgKiBwYjtcblx0XHRhX3N1bSArPSBzdW1GYWN0b3IgKiBwYTtcblx0XHRcblx0XHRzdGFjayA9IHN0YWNrU3RhcnQ7XG5cdFx0XG5cdFx0Zm9yKCBpID0gMDsgaSA8IHJhZGl1c1BsdXMxOyBpKysgKVxuXHRcdHtcblx0XHRcdHN0YWNrLnIgPSBwcjtcblx0XHRcdHN0YWNrLmcgPSBwZztcblx0XHRcdHN0YWNrLmIgPSBwYjtcblx0XHRcdHN0YWNrLmEgPSBwYTtcblx0XHRcdHN0YWNrID0gc3RhY2submV4dDtcblx0XHR9XG5cdFx0XG5cdFx0Zm9yKCBpID0gMTsgaSA8IHJhZGl1c1BsdXMxOyBpKysgKVxuXHRcdHtcblx0XHRcdHAgPSB5aSArICgoIHdpZHRoTWludXMxIDwgaSA/IHdpZHRoTWludXMxIDogaSApIDw8IDIgKTtcblx0XHRcdHJfc3VtICs9ICggc3RhY2suciA9ICggcHIgPSBwaXhlbHNbcF0pKSAqICggcmJzID0gcmFkaXVzUGx1czEgLSBpICk7XG5cdFx0XHRnX3N1bSArPSAoIHN0YWNrLmcgPSAoIHBnID0gcGl4ZWxzW3ArMV0pKSAqIHJicztcblx0XHRcdGJfc3VtICs9ICggc3RhY2suYiA9ICggcGIgPSBwaXhlbHNbcCsyXSkpICogcmJzO1xuXHRcdFx0YV9zdW0gKz0gKCBzdGFjay5hID0gKCBwYSA9IHBpeGVsc1twKzNdKSkgKiByYnM7XG5cdFx0XHRcblx0XHRcdHJfaW5fc3VtICs9IHByO1xuXHRcdFx0Z19pbl9zdW0gKz0gcGc7XG5cdFx0XHRiX2luX3N1bSArPSBwYjtcblx0XHRcdGFfaW5fc3VtICs9IHBhO1xuXHRcdFx0XG5cdFx0XHRzdGFjayA9IHN0YWNrLm5leHQ7XG5cdFx0fVxuXHRcdFxuXHRcdFxuXHRcdHN0YWNrSW4gPSBzdGFja1N0YXJ0O1xuXHRcdHN0YWNrT3V0ID0gc3RhY2tFbmQ7XG5cdFx0Zm9yICggeCA9IDA7IHggPCB3aWR0aDsgeCsrIClcblx0XHR7XG5cdFx0XHRwaXhlbHNbeWkrM10gPSBwYSA9IChhX3N1bSAqIG11bF9zdW0pID4+IHNoZ19zdW07XG5cdFx0XHRpZiAoIHBhICE9IDAgKVxuXHRcdFx0e1xuXHRcdFx0XHRwYSA9IDI1NSAvIHBhO1xuXHRcdFx0XHRwaXhlbHNbeWldICAgPSAoKHJfc3VtICogbXVsX3N1bSkgPj4gc2hnX3N1bSkgKiBwYTtcblx0XHRcdFx0cGl4ZWxzW3lpKzFdID0gKChnX3N1bSAqIG11bF9zdW0pID4+IHNoZ19zdW0pICogcGE7XG5cdFx0XHRcdHBpeGVsc1t5aSsyXSA9ICgoYl9zdW0gKiBtdWxfc3VtKSA+PiBzaGdfc3VtKSAqIHBhO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cGl4ZWxzW3lpXSA9IHBpeGVsc1t5aSsxXSA9IHBpeGVsc1t5aSsyXSA9IDA7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJfc3VtIC09IHJfb3V0X3N1bTtcblx0XHRcdGdfc3VtIC09IGdfb3V0X3N1bTtcblx0XHRcdGJfc3VtIC09IGJfb3V0X3N1bTtcblx0XHRcdGFfc3VtIC09IGFfb3V0X3N1bTtcblx0XHRcdFxuXHRcdFx0cl9vdXRfc3VtIC09IHN0YWNrSW4ucjtcblx0XHRcdGdfb3V0X3N1bSAtPSBzdGFja0luLmc7XG5cdFx0XHRiX291dF9zdW0gLT0gc3RhY2tJbi5iO1xuXHRcdFx0YV9vdXRfc3VtIC09IHN0YWNrSW4uYTtcblx0XHRcdFxuXHRcdFx0cCA9ICAoIHl3ICsgKCAoIHAgPSB4ICsgcmFkaXVzICsgMSApIDwgd2lkdGhNaW51czEgPyBwIDogd2lkdGhNaW51czEgKSApIDw8IDI7XG5cdFx0XHRcblx0XHRcdHJfaW5fc3VtICs9ICggc3RhY2tJbi5yID0gcGl4ZWxzW3BdKTtcblx0XHRcdGdfaW5fc3VtICs9ICggc3RhY2tJbi5nID0gcGl4ZWxzW3ArMV0pO1xuXHRcdFx0Yl9pbl9zdW0gKz0gKCBzdGFja0luLmIgPSBwaXhlbHNbcCsyXSk7XG5cdFx0XHRhX2luX3N1bSArPSAoIHN0YWNrSW4uYSA9IHBpeGVsc1twKzNdKTtcblx0XHRcdFxuXHRcdFx0cl9zdW0gKz0gcl9pbl9zdW07XG5cdFx0XHRnX3N1bSArPSBnX2luX3N1bTtcblx0XHRcdGJfc3VtICs9IGJfaW5fc3VtO1xuXHRcdFx0YV9zdW0gKz0gYV9pbl9zdW07XG5cdFx0XHRcblx0XHRcdHN0YWNrSW4gPSBzdGFja0luLm5leHQ7XG5cdFx0XHRcblx0XHRcdHJfb3V0X3N1bSArPSAoIHByID0gc3RhY2tPdXQuciApO1xuXHRcdFx0Z19vdXRfc3VtICs9ICggcGcgPSBzdGFja091dC5nICk7XG5cdFx0XHRiX291dF9zdW0gKz0gKCBwYiA9IHN0YWNrT3V0LmIgKTtcblx0XHRcdGFfb3V0X3N1bSArPSAoIHBhID0gc3RhY2tPdXQuYSApO1xuXHRcdFx0XG5cdFx0XHRyX2luX3N1bSAtPSBwcjtcblx0XHRcdGdfaW5fc3VtIC09IHBnO1xuXHRcdFx0Yl9pbl9zdW0gLT0gcGI7XG5cdFx0XHRhX2luX3N1bSAtPSBwYTtcblx0XHRcdFxuXHRcdFx0c3RhY2tPdXQgPSBzdGFja091dC5uZXh0O1xuXG5cdFx0XHR5aSArPSA0O1xuXHRcdH1cblx0XHR5dyArPSB3aWR0aDtcblx0fVxuXG5cdFxuXHRmb3IgKCB4ID0gMDsgeCA8IHdpZHRoOyB4KysgKVxuXHR7XG5cdFx0Z19pbl9zdW0gPSBiX2luX3N1bSA9IGFfaW5fc3VtID0gcl9pbl9zdW0gPSBnX3N1bSA9IGJfc3VtID0gYV9zdW0gPSByX3N1bSA9IDA7XG5cdFx0XG5cdFx0eWkgPSB4IDw8IDI7XG5cdFx0cl9vdXRfc3VtID0gcmFkaXVzUGx1czEgKiAoIHByID0gcGl4ZWxzW3lpXSk7XG5cdFx0Z19vdXRfc3VtID0gcmFkaXVzUGx1czEgKiAoIHBnID0gcGl4ZWxzW3lpKzFdKTtcblx0XHRiX291dF9zdW0gPSByYWRpdXNQbHVzMSAqICggcGIgPSBwaXhlbHNbeWkrMl0pO1xuXHRcdGFfb3V0X3N1bSA9IHJhZGl1c1BsdXMxICogKCBwYSA9IHBpeGVsc1t5aSszXSk7XG5cdFx0XG5cdFx0cl9zdW0gKz0gc3VtRmFjdG9yICogcHI7XG5cdFx0Z19zdW0gKz0gc3VtRmFjdG9yICogcGc7XG5cdFx0Yl9zdW0gKz0gc3VtRmFjdG9yICogcGI7XG5cdFx0YV9zdW0gKz0gc3VtRmFjdG9yICogcGE7XG5cdFx0XG5cdFx0c3RhY2sgPSBzdGFja1N0YXJ0O1xuXHRcdFxuXHRcdGZvciggaSA9IDA7IGkgPCByYWRpdXNQbHVzMTsgaSsrIClcblx0XHR7XG5cdFx0XHRzdGFjay5yID0gcHI7XG5cdFx0XHRzdGFjay5nID0gcGc7XG5cdFx0XHRzdGFjay5iID0gcGI7XG5cdFx0XHRzdGFjay5hID0gcGE7XG5cdFx0XHRzdGFjayA9IHN0YWNrLm5leHQ7XG5cdFx0fVxuXHRcdFxuXHRcdHlwID0gd2lkdGg7XG5cdFx0XG5cdFx0Zm9yKCBpID0gMTsgaSA8PSByYWRpdXM7IGkrKyApXG5cdFx0e1xuXHRcdFx0eWkgPSAoIHlwICsgeCApIDw8IDI7XG5cdFx0XHRcblx0XHRcdHJfc3VtICs9ICggc3RhY2suciA9ICggcHIgPSBwaXhlbHNbeWldKSkgKiAoIHJicyA9IHJhZGl1c1BsdXMxIC0gaSApO1xuXHRcdFx0Z19zdW0gKz0gKCBzdGFjay5nID0gKCBwZyA9IHBpeGVsc1t5aSsxXSkpICogcmJzO1xuXHRcdFx0Yl9zdW0gKz0gKCBzdGFjay5iID0gKCBwYiA9IHBpeGVsc1t5aSsyXSkpICogcmJzO1xuXHRcdFx0YV9zdW0gKz0gKCBzdGFjay5hID0gKCBwYSA9IHBpeGVsc1t5aSszXSkpICogcmJzO1xuXHRcdCAgIFxuXHRcdFx0cl9pbl9zdW0gKz0gcHI7XG5cdFx0XHRnX2luX3N1bSArPSBwZztcblx0XHRcdGJfaW5fc3VtICs9IHBiO1xuXHRcdFx0YV9pbl9zdW0gKz0gcGE7XG5cdFx0XHRcblx0XHRcdHN0YWNrID0gc3RhY2submV4dDtcblx0XHRcblx0XHRcdGlmKCBpIDwgaGVpZ2h0TWludXMxIClcblx0XHRcdHtcblx0XHRcdFx0eXAgKz0gd2lkdGg7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdHlpID0geDtcblx0XHRzdGFja0luID0gc3RhY2tTdGFydDtcblx0XHRzdGFja091dCA9IHN0YWNrRW5kO1xuXHRcdGZvciAoIHkgPSAwOyB5IDwgaGVpZ2h0OyB5KysgKVxuXHRcdHtcblx0XHRcdHAgPSB5aSA8PCAyO1xuXHRcdFx0cGl4ZWxzW3ArM10gPSBwYSA9IChhX3N1bSAqIG11bF9zdW0pID4+IHNoZ19zdW07XG5cdFx0XHRpZiAoIHBhID4gMCApXG5cdFx0XHR7XG5cdFx0XHRcdHBhID0gMjU1IC8gcGE7XG5cdFx0XHRcdHBpeGVsc1twXSAgID0gKChyX3N1bSAqIG11bF9zdW0pID4+IHNoZ19zdW0gKSAqIHBhO1xuXHRcdFx0XHRwaXhlbHNbcCsxXSA9ICgoZ19zdW0gKiBtdWxfc3VtKSA+PiBzaGdfc3VtICkgKiBwYTtcblx0XHRcdFx0cGl4ZWxzW3ArMl0gPSAoKGJfc3VtICogbXVsX3N1bSkgPj4gc2hnX3N1bSApICogcGE7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwaXhlbHNbcF0gPSBwaXhlbHNbcCsxXSA9IHBpeGVsc1twKzJdID0gMDtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cl9zdW0gLT0gcl9vdXRfc3VtO1xuXHRcdFx0Z19zdW0gLT0gZ19vdXRfc3VtO1xuXHRcdFx0Yl9zdW0gLT0gYl9vdXRfc3VtO1xuXHRcdFx0YV9zdW0gLT0gYV9vdXRfc3VtO1xuXHRcdCAgIFxuXHRcdFx0cl9vdXRfc3VtIC09IHN0YWNrSW4ucjtcblx0XHRcdGdfb3V0X3N1bSAtPSBzdGFja0luLmc7XG5cdFx0XHRiX291dF9zdW0gLT0gc3RhY2tJbi5iO1xuXHRcdFx0YV9vdXRfc3VtIC09IHN0YWNrSW4uYTtcblx0XHRcdFxuXHRcdFx0cCA9ICggeCArICgoICggcCA9IHkgKyByYWRpdXNQbHVzMSkgPCBoZWlnaHRNaW51czEgPyBwIDogaGVpZ2h0TWludXMxICkgKiB3aWR0aCApKSA8PCAyO1xuXHRcdFx0XG5cdFx0XHRyX3N1bSArPSAoIHJfaW5fc3VtICs9ICggc3RhY2tJbi5yID0gcGl4ZWxzW3BdKSk7XG5cdFx0XHRnX3N1bSArPSAoIGdfaW5fc3VtICs9ICggc3RhY2tJbi5nID0gcGl4ZWxzW3ArMV0pKTtcblx0XHRcdGJfc3VtICs9ICggYl9pbl9zdW0gKz0gKCBzdGFja0luLmIgPSBwaXhlbHNbcCsyXSkpO1xuXHRcdFx0YV9zdW0gKz0gKCBhX2luX3N1bSArPSAoIHN0YWNrSW4uYSA9IHBpeGVsc1twKzNdKSk7XG5cdFx0ICAgXG5cdFx0XHRzdGFja0luID0gc3RhY2tJbi5uZXh0O1xuXHRcdFx0XG5cdFx0XHRyX291dF9zdW0gKz0gKCBwciA9IHN0YWNrT3V0LnIgKTtcblx0XHRcdGdfb3V0X3N1bSArPSAoIHBnID0gc3RhY2tPdXQuZyApO1xuXHRcdFx0Yl9vdXRfc3VtICs9ICggcGIgPSBzdGFja091dC5iICk7XG5cdFx0XHRhX291dF9zdW0gKz0gKCBwYSA9IHN0YWNrT3V0LmEgKTtcblx0XHRcdFxuXHRcdFx0cl9pbl9zdW0gLT0gcHI7XG5cdFx0XHRnX2luX3N1bSAtPSBwZztcblx0XHRcdGJfaW5fc3VtIC09IHBiO1xuXHRcdFx0YV9pbl9zdW0gLT0gcGE7XG5cdFx0XHRcblx0XHRcdHN0YWNrT3V0ID0gc3RhY2tPdXQubmV4dDtcblx0XHRcdFxuXHRcdFx0eWkgKz0gd2lkdGg7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIEJsdXJTdGFjaygpXG57XG5cdHRoaXMuciA9IDA7XG5cdHRoaXMuZyA9IDA7XG5cdHRoaXMuYiA9IDA7XG5cdHRoaXMuYSA9IDA7XG5cdHRoaXMubmV4dCA9IG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmx1cjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc3RhY2tibHVyL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*!\n* svg.js - A lightweight library for manipulating and animating SVG.\n* @version 2.5.1\n* https://svgdotjs.github.io/\n*\n* @copyright Wout Fierens <wout@mick-wout.com>\n* @license MIT\n*\n* BUILT: Mon Mar 27 2017 13:30:36 GMT+0200 (Mitteleuropische Sommerzeit)\n*/;\n(function(root, factory) {\r\n  if (true) {\r\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = function(){\r\n      return factory(root, root.document)\r\n    }.call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\r\n  } else if (typeof exports === 'object') {\r\n    module.exports = root.document ? factory(root, root.document) : function(w){ return factory(w, w.document) }\r\n  } else {\r\n    root.SVG = factory(root, root.document)\r\n  }\r\n}(typeof window !== \"undefined\" ? window : this, function(window, document) {\r\n\r\n// The main wrapping element\r\nvar SVG = this.SVG = function(element) {\r\n  if (SVG.supported) {\r\n    element = new SVG.Doc(element)\r\n\r\n    if(!SVG.parser.draw)\r\n      SVG.prepare()\r\n\r\n    return element\r\n  }\r\n}\r\n\r\n// Default namespaces\r\nSVG.ns    = 'http://www.w3.org/2000/svg'\r\nSVG.xmlns = 'http://www.w3.org/2000/xmlns/'\r\nSVG.xlink = 'http://www.w3.org/1999/xlink'\r\nSVG.svgjs = 'http://svgjs.com/svgjs'\r\n\r\n// Svg support test\r\nSVG.supported = (function() {\r\n  return !! document.createElementNS &&\r\n         !! document.createElementNS(SVG.ns,'svg').createSVGRect\r\n})()\r\n\r\n// Don't bother to continue if SVG is not supported\r\nif (!SVG.supported) return false\r\n\r\n// Element id sequence\r\nSVG.did  = 1000\r\n\r\n// Get next named element id\r\nSVG.eid = function(name) {\r\n  return 'Svgjs' + capitalize(name) + (SVG.did++)\r\n}\r\n\r\n// Method for element creation\r\nSVG.create = function(name) {\r\n  // create element\r\n  var element = document.createElementNS(this.ns, name)\r\n\r\n  // apply unique id\r\n  element.setAttribute('id', this.eid(name))\r\n\r\n  return element\r\n}\r\n\r\n// Method for extending objects\r\nSVG.extend = function() {\r\n  var modules, methods, key, i\r\n\r\n  // Get list of modules\r\n  modules = [].slice.call(arguments)\r\n\r\n  // Get object with extensions\r\n  methods = modules.pop()\r\n\r\n  for (i = modules.length - 1; i >= 0; i--)\r\n    if (modules[i])\r\n      for (key in methods)\r\n        modules[i].prototype[key] = methods[key]\r\n\r\n  // Make sure SVG.Set inherits any newly added methods\r\n  if (SVG.Set && SVG.Set.inherit)\r\n    SVG.Set.inherit()\r\n}\r\n\r\n// Invent new element\r\nSVG.invent = function(config) {\r\n  // Create element initializer\r\n  var initializer = typeof config.create == 'function' ?\r\n    config.create :\r\n    function() {\r\n      this.constructor.call(this, SVG.create(config.create))\r\n    }\r\n\r\n  // Inherit prototype\r\n  if (config.inherit)\r\n    initializer.prototype = new config.inherit\r\n\r\n  // Extend with methods\r\n  if (config.extend)\r\n    SVG.extend(initializer, config.extend)\r\n\r\n  // Attach construct method to parent\r\n  if (config.construct)\r\n    SVG.extend(config.parent || SVG.Container, config.construct)\r\n\r\n  return initializer\r\n}\r\n\r\n// Adopt existing svg elements\r\nSVG.adopt = function(node) {\r\n  // check for presence of node\r\n  if (!node) return null\r\n\r\n  // make sure a node isn't already adopted\r\n  if (node.instance) return node.instance\r\n\r\n  // initialize variables\r\n  var element\r\n\r\n  // adopt with element-specific settings\r\n  if (node.nodeName == 'svg')\r\n    element = node.parentNode instanceof window.SVGElement ? new SVG.Nested : new SVG.Doc\r\n  else if (node.nodeName == 'linearGradient')\r\n    element = new SVG.Gradient('linear')\r\n  else if (node.nodeName == 'radialGradient')\r\n    element = new SVG.Gradient('radial')\r\n  else if (SVG[capitalize(node.nodeName)])\r\n    element = new SVG[capitalize(node.nodeName)]\r\n  else\r\n    element = new SVG.Element(node)\r\n\r\n  // ensure references\r\n  element.type  = node.nodeName\r\n  element.node  = node\r\n  node.instance = element\r\n\r\n  // SVG.Class specific preparations\r\n  if (element instanceof SVG.Doc)\r\n    element.namespace().defs()\r\n\r\n  // pull svgjs data from the dom (getAttributeNS doesn't work in html5)\r\n  element.setData(JSON.parse(node.getAttribute('svgjs:data')) || {})\r\n\r\n  return element\r\n}\r\n\r\n// Initialize parsing element\r\nSVG.prepare = function() {\r\n  // Select document body and create invisible svg element\r\n  var body = document.getElementsByTagName('body')[0]\r\n    , draw = (body ? new SVG.Doc(body) :  SVG.adopt(document.documentElement).nested()).size(2, 0)\r\n\r\n  // Create parser object\r\n  SVG.parser = {\r\n    body: body || document.documentElement\r\n  , draw: draw.style('opacity:0;position:absolute;left:-100%;top:-100%;overflow:hidden')\r\n  , poly: draw.polyline().node\r\n  , path: draw.path().node\r\n  , native: SVG.create('svg')\r\n  }\r\n}\r\n\r\nSVG.parser = {\r\n  native: SVG.create('svg')\r\n}\r\n\r\ndocument.addEventListener('DOMContentLoaded', function() {\r\n  if(!SVG.parser.draw)\r\n    SVG.prepare()\r\n}, false)\r\n\n// Storage for regular expressions\r\nSVG.regex = {\r\n  // Parse unit value\r\n  numberAndUnit:    /^([+-]?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?)([a-z%]*)$/i\r\n\r\n  // Parse hex value\r\n, hex:              /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i\r\n\r\n  // Parse rgb value\r\n, rgb:              /rgb\\((\\d+),(\\d+),(\\d+)\\)/\r\n\r\n  // Parse reference id\r\n, reference:        /#([a-z0-9\\-_]+)/i\r\n\r\n  // splits a transformation chain\r\n, transforms:       /\\)\\s*,?\\s*/\r\n\r\n  // Whitespace\r\n, whitespace:       /\\s/g\r\n\r\n  // Test hex value\r\n, isHex:            /^#[a-f0-9]{3,6}$/i\r\n\r\n  // Test rgb value\r\n, isRgb:            /^rgb\\(/\r\n\r\n  // Test css declaration\r\n, isCss:            /[^:]+:[^;]+;?/\r\n\r\n  // Test for blank string\r\n, isBlank:          /^(\\s+)?$/\r\n\r\n  // Test for numeric string\r\n, isNumber:         /^[+-]?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i\r\n\r\n  // Test for percent value\r\n, isPercent:        /^-?[\\d\\.]+%$/\r\n\r\n  // Test for image url\r\n, isImage:          /\\.(jpg|jpeg|png|gif|svg)(\\?[^=]+.*)?/i\r\n\r\n  // split at whitespace and comma\r\n, delimiter:        /[\\s,]+/\r\n\r\n  // The following regex are used to parse the d attribute of a path\r\n\r\n  // Matches all hyphens which are not after an exponent\r\n, hyphen:           /([^e])\\-/gi\r\n\r\n  // Replaces and tests for all path letters\r\n, pathLetters:      /[MLHVCSQTAZ]/gi\r\n\r\n  // yes we need this one, too\r\n, isPathLetter:     /[MLHVCSQTAZ]/i\r\n\r\n  // matches 0.154.23.45\r\n, numbersWithDots:  /((\\d?\\.\\d+(?:e[+-]?\\d+)?)((?:\\.\\d+(?:e[+-]?\\d+)?)+))+/gi\r\n\r\n  // matches .\r\n, dots:             /\\./g\r\n}\r\n\nSVG.utils = {\r\n  // Map function\r\n  map: function(array, block) {\r\n    var i\r\n      , il = array.length\r\n      , result = []\r\n\r\n    for (i = 0; i < il; i++)\r\n      result.push(block(array[i]))\r\n\r\n    return result\r\n  }\r\n\r\n  // Filter function\r\n, filter: function(array, block) {\r\n    var i\r\n      , il = array.length\r\n      , result = []\r\n\r\n    for (i = 0; i < il; i++)\r\n      if (block(array[i]))\r\n        result.push(array[i])\r\n\r\n    return result\r\n  }\r\n\r\n  // Degrees to radians\r\n, radians: function(d) {\r\n    return d % 360 * Math.PI / 180\r\n  }\r\n\r\n  // Radians to degrees\r\n, degrees: function(r) {\r\n    return r * 180 / Math.PI % 360\r\n  }\r\n\r\n, filterSVGElements: function(nodes) {\r\n    return this.filter( nodes, function(el) { return el instanceof window.SVGElement })\r\n  }\r\n\r\n}\n\r\nSVG.defaults = {\r\n  // Default attribute values\r\n  attrs: {\r\n    // fill and stroke\r\n    'fill-opacity':     1\r\n  , 'stroke-opacity':   1\r\n  , 'stroke-width':     0\r\n  , 'stroke-linejoin':  'miter'\r\n  , 'stroke-linecap':   'butt'\r\n  , fill:               '#000000'\r\n  , stroke:             '#000000'\r\n  , opacity:            1\r\n    // position\r\n  , x:                  0\r\n  , y:                  0\r\n  , cx:                 0\r\n  , cy:                 0\r\n    // size\r\n  , width:              0\r\n  , height:             0\r\n    // radius\r\n  , r:                  0\r\n  , rx:                 0\r\n  , ry:                 0\r\n    // gradient\r\n  , offset:             0\r\n  , 'stop-opacity':     1\r\n  , 'stop-color':       '#000000'\r\n    // text\r\n  , 'font-size':        16\r\n  , 'font-family':      'Helvetica, Arial, sans-serif'\r\n  , 'text-anchor':      'start'\r\n  }\r\n\r\n}\n// Module for color convertions\r\nSVG.Color = function(color) {\r\n  var match\r\n\r\n  // initialize defaults\r\n  this.r = 0\r\n  this.g = 0\r\n  this.b = 0\r\n\r\n  if(!color) return\r\n\r\n  // parse color\r\n  if (typeof color === 'string') {\r\n    if (SVG.regex.isRgb.test(color)) {\r\n      // get rgb values\r\n      match = SVG.regex.rgb.exec(color.replace(SVG.regex.whitespace,''))\r\n\r\n      // parse numeric values\r\n      this.r = parseInt(match[1])\r\n      this.g = parseInt(match[2])\r\n      this.b = parseInt(match[3])\r\n\r\n    } else if (SVG.regex.isHex.test(color)) {\r\n      // get hex values\r\n      match = SVG.regex.hex.exec(fullHex(color))\r\n\r\n      // parse numeric values\r\n      this.r = parseInt(match[1], 16)\r\n      this.g = parseInt(match[2], 16)\r\n      this.b = parseInt(match[3], 16)\r\n\r\n    }\r\n\r\n  } else if (typeof color === 'object') {\r\n    this.r = color.r\r\n    this.g = color.g\r\n    this.b = color.b\r\n\r\n  }\r\n\r\n}\r\n\r\nSVG.extend(SVG.Color, {\r\n  // Default to hex conversion\r\n  toString: function() {\r\n    return this.toHex()\r\n  }\r\n  // Build hex value\r\n, toHex: function() {\r\n    return '#'\r\n      + compToHex(this.r)\r\n      + compToHex(this.g)\r\n      + compToHex(this.b)\r\n  }\r\n  // Build rgb value\r\n, toRgb: function() {\r\n    return 'rgb(' + [this.r, this.g, this.b].join() + ')'\r\n  }\r\n  // Calculate true brightness\r\n, brightness: function() {\r\n    return (this.r / 255 * 0.30)\r\n         + (this.g / 255 * 0.59)\r\n         + (this.b / 255 * 0.11)\r\n  }\r\n  // Make color morphable\r\n, morph: function(color) {\r\n    this.destination = new SVG.Color(color)\r\n\r\n    return this\r\n  }\r\n  // Get morphed color at given position\r\n, at: function(pos) {\r\n    // make sure a destination is defined\r\n    if (!this.destination) return this\r\n\r\n    // normalise pos\r\n    pos = pos < 0 ? 0 : pos > 1 ? 1 : pos\r\n\r\n    // generate morphed color\r\n    return new SVG.Color({\r\n      r: ~~(this.r + (this.destination.r - this.r) * pos)\r\n    , g: ~~(this.g + (this.destination.g - this.g) * pos)\r\n    , b: ~~(this.b + (this.destination.b - this.b) * pos)\r\n    })\r\n  }\r\n\r\n})\r\n\r\n// Testers\r\n\r\n// Test if given value is a color string\r\nSVG.Color.test = function(color) {\r\n  color += ''\r\n  return SVG.regex.isHex.test(color)\r\n      || SVG.regex.isRgb.test(color)\r\n}\r\n\r\n// Test if given value is a rgb object\r\nSVG.Color.isRgb = function(color) {\r\n  return color && typeof color.r == 'number'\r\n               && typeof color.g == 'number'\r\n               && typeof color.b == 'number'\r\n}\r\n\r\n// Test if given value is a color\r\nSVG.Color.isColor = function(color) {\r\n  return SVG.Color.isRgb(color) || SVG.Color.test(color)\r\n}\n// Module for array conversion\r\nSVG.Array = function(array, fallback) {\r\n  array = (array || []).valueOf()\r\n\r\n  // if array is empty and fallback is provided, use fallback\r\n  if (array.length == 0 && fallback)\r\n    array = fallback.valueOf()\r\n\r\n  // parse array\r\n  this.value = this.parse(array)\r\n}\r\n\r\nSVG.extend(SVG.Array, {\r\n  // Make array morphable\r\n  morph: function(array) {\r\n    this.destination = this.parse(array)\r\n\r\n    // normalize length of arrays\r\n    if (this.value.length != this.destination.length) {\r\n      var lastValue       = this.value[this.value.length - 1]\r\n        , lastDestination = this.destination[this.destination.length - 1]\r\n\r\n      while(this.value.length > this.destination.length)\r\n        this.destination.push(lastDestination)\r\n      while(this.value.length < this.destination.length)\r\n        this.value.push(lastValue)\r\n    }\r\n\r\n    return this\r\n  }\r\n  // Clean up any duplicate points\r\n, settle: function() {\r\n    // find all unique values\r\n    for (var i = 0, il = this.value.length, seen = []; i < il; i++)\r\n      if (seen.indexOf(this.value[i]) == -1)\r\n        seen.push(this.value[i])\r\n\r\n    // set new value\r\n    return this.value = seen\r\n  }\r\n  // Get morphed array at given position\r\n, at: function(pos) {\r\n    // make sure a destination is defined\r\n    if (!this.destination) return this\r\n\r\n    // generate morphed array\r\n    for (var i = 0, il = this.value.length, array = []; i < il; i++)\r\n      array.push(this.value[i] + (this.destination[i] - this.value[i]) * pos)\r\n\r\n    return new SVG.Array(array)\r\n  }\r\n  // Convert array to string\r\n, toString: function() {\r\n    return this.value.join(' ')\r\n  }\r\n  // Real value\r\n, valueOf: function() {\r\n    return this.value\r\n  }\r\n  // Parse whitespace separated string\r\n, parse: function(array) {\r\n    array = array.valueOf()\r\n\r\n    // if already is an array, no need to parse it\r\n    if (Array.isArray(array)) return array\r\n\r\n    return this.split(array)\r\n  }\r\n  // Strip unnecessary whitespace\r\n, split: function(string) {\r\n    return string.trim().split(SVG.regex.delimiter).map(parseFloat)\r\n  }\r\n  // Reverse array\r\n, reverse: function() {\r\n    this.value.reverse()\r\n\r\n    return this\r\n  }\r\n, clone: function() {\r\n    var clone = new this.constructor()\r\n    clone.value = array_clone(this.value)\r\n    return clone\r\n  }\r\n})\n// Poly points array\r\nSVG.PointArray = function(array, fallback) {\r\n  SVG.Array.call(this, array, fallback || [[0,0]])\r\n}\r\n\r\n// Inherit from SVG.Array\r\nSVG.PointArray.prototype = new SVG.Array\r\nSVG.PointArray.prototype.constructor = SVG.PointArray\r\n\r\nSVG.extend(SVG.PointArray, {\r\n  // Convert array to string\r\n  toString: function() {\r\n    // convert to a poly point string\r\n    for (var i = 0, il = this.value.length, array = []; i < il; i++)\r\n      array.push(this.value[i].join(','))\r\n\r\n    return array.join(' ')\r\n  }\r\n  // Convert array to line object\r\n, toLine: function() {\r\n    return {\r\n      x1: this.value[0][0]\r\n    , y1: this.value[0][1]\r\n    , x2: this.value[1][0]\r\n    , y2: this.value[1][1]\r\n    }\r\n  }\r\n  // Get morphed array at given position\r\n, at: function(pos) {\r\n    // make sure a destination is defined\r\n    if (!this.destination) return this\r\n\r\n    // generate morphed point string\r\n    for (var i = 0, il = this.value.length, array = []; i < il; i++)\r\n      array.push([\r\n        this.value[i][0] + (this.destination[i][0] - this.value[i][0]) * pos\r\n      , this.value[i][1] + (this.destination[i][1] - this.value[i][1]) * pos\r\n      ])\r\n\r\n    return new SVG.PointArray(array)\r\n  }\r\n  // Parse point string and flat array\r\n, parse: function(array) {\r\n    var points = []\r\n\r\n    array = array.valueOf()\r\n\r\n    // if it is an array\r\n    if (Array.isArray(array)) {\r\n      // and it is not flat, there is no need to parse it\r\n      if(Array.isArray(array[0])) {\r\n        return array\r\n      }\r\n    } else { // Else, it is considered as a string\r\n      // parse points\r\n      array = array.trim().split(SVG.regex.delimiter).map(parseFloat)\r\n    }\r\n\r\n    // validate points - https://svgwg.org/svg2-draft/shapes.html#DataTypePoints\r\n    // Odd number of coordinates is an error. In such cases, drop the last odd coordinate.\r\n    if (array.length % 2 !== 0) array.pop()\r\n\r\n    // wrap points in two-tuples and parse points as floats\r\n    for(var i = 0, len = array.length; i < len; i = i + 2)\r\n      points.push([ array[i], array[i+1] ])\r\n\r\n    return points\r\n  }\r\n  // Move point string\r\n, move: function(x, y) {\r\n    var box = this.bbox()\r\n\r\n    // get relative offset\r\n    x -= box.x\r\n    y -= box.y\r\n\r\n    // move every point\r\n    if (!isNaN(x) && !isNaN(y))\r\n      for (var i = this.value.length - 1; i >= 0; i--)\r\n        this.value[i] = [this.value[i][0] + x, this.value[i][1] + y]\r\n\r\n    return this\r\n  }\r\n  // Resize poly string\r\n, size: function(width, height) {\r\n    var i, box = this.bbox()\r\n\r\n    // recalculate position of all points according to new size\r\n    for (i = this.value.length - 1; i >= 0; i--) {\r\n      if(box.width) this.value[i][0] = ((this.value[i][0] - box.x) * width)  / box.width  + box.x\r\n      if(box.height) this.value[i][1] = ((this.value[i][1] - box.y) * height) / box.height + box.y\r\n    }\r\n\r\n    return this\r\n  }\r\n  // Get bounding box of points\r\n, bbox: function() {\r\n    SVG.parser.poly.setAttribute('points', this.toString())\r\n\r\n    return SVG.parser.poly.getBBox()\r\n  }\r\n})\r\n\n// Path points array\r\nSVG.PathArray = function(array, fallback) {\r\n  SVG.Array.call(this, array, fallback || [['M', 0, 0]])\r\n}\r\n\r\n// Inherit from SVG.Array\r\nSVG.PathArray.prototype = new SVG.Array\r\nSVG.PathArray.prototype.constructor = SVG.PathArray\r\n\r\nSVG.extend(SVG.PathArray, {\r\n  // Convert array to string\r\n  toString: function() {\r\n    return arrayToString(this.value)\r\n  }\r\n  // Move path string\r\n, move: function(x, y) {\r\n    // get bounding box of current situation\r\n    var box = this.bbox()\r\n\r\n    // get relative offset\r\n    x -= box.x\r\n    y -= box.y\r\n\r\n    if (!isNaN(x) && !isNaN(y)) {\r\n      // move every point\r\n      for (var l, i = this.value.length - 1; i >= 0; i--) {\r\n        l = this.value[i][0]\r\n\r\n        if (l == 'M' || l == 'L' || l == 'T')  {\r\n          this.value[i][1] += x\r\n          this.value[i][2] += y\r\n\r\n        } else if (l == 'H')  {\r\n          this.value[i][1] += x\r\n\r\n        } else if (l == 'V')  {\r\n          this.value[i][1] += y\r\n\r\n        } else if (l == 'C' || l == 'S' || l == 'Q')  {\r\n          this.value[i][1] += x\r\n          this.value[i][2] += y\r\n          this.value[i][3] += x\r\n          this.value[i][4] += y\r\n\r\n          if (l == 'C')  {\r\n            this.value[i][5] += x\r\n            this.value[i][6] += y\r\n          }\r\n\r\n        } else if (l == 'A')  {\r\n          this.value[i][6] += x\r\n          this.value[i][7] += y\r\n        }\r\n\r\n      }\r\n    }\r\n\r\n    return this\r\n  }\r\n  // Resize path string\r\n, size: function(width, height) {\r\n    // get bounding box of current situation\r\n    var i, l, box = this.bbox()\r\n\r\n    // recalculate position of all points according to new size\r\n    for (i = this.value.length - 1; i >= 0; i--) {\r\n      l = this.value[i][0]\r\n\r\n      if (l == 'M' || l == 'L' || l == 'T')  {\r\n        this.value[i][1] = ((this.value[i][1] - box.x) * width)  / box.width  + box.x\r\n        this.value[i][2] = ((this.value[i][2] - box.y) * height) / box.height + box.y\r\n\r\n      } else if (l == 'H')  {\r\n        this.value[i][1] = ((this.value[i][1] - box.x) * width)  / box.width  + box.x\r\n\r\n      } else if (l == 'V')  {\r\n        this.value[i][1] = ((this.value[i][1] - box.y) * height) / box.height + box.y\r\n\r\n      } else if (l == 'C' || l == 'S' || l == 'Q')  {\r\n        this.value[i][1] = ((this.value[i][1] - box.x) * width)  / box.width  + box.x\r\n        this.value[i][2] = ((this.value[i][2] - box.y) * height) / box.height + box.y\r\n        this.value[i][3] = ((this.value[i][3] - box.x) * width)  / box.width  + box.x\r\n        this.value[i][4] = ((this.value[i][4] - box.y) * height) / box.height + box.y\r\n\r\n        if (l == 'C')  {\r\n          this.value[i][5] = ((this.value[i][5] - box.x) * width)  / box.width  + box.x\r\n          this.value[i][6] = ((this.value[i][6] - box.y) * height) / box.height + box.y\r\n        }\r\n\r\n      } else if (l == 'A')  {\r\n        // resize radii\r\n        this.value[i][1] = (this.value[i][1] * width)  / box.width\r\n        this.value[i][2] = (this.value[i][2] * height) / box.height\r\n\r\n        // move position values\r\n        this.value[i][6] = ((this.value[i][6] - box.x) * width)  / box.width  + box.x\r\n        this.value[i][7] = ((this.value[i][7] - box.y) * height) / box.height + box.y\r\n      }\r\n\r\n    }\r\n\r\n    return this\r\n  }\r\n  // Test if the passed path array use the same path data commands as this path array\r\n, equalCommands: function(pathArray) {\r\n    var i, il, equalCommands\r\n\r\n    pathArray = new SVG.PathArray(pathArray)\r\n\r\n    equalCommands = this.value.length === pathArray.value.length\r\n    for(i = 0, il = this.value.length; equalCommands && i < il; i++) {\r\n      equalCommands = this.value[i][0] === pathArray.value[i][0]\r\n    }\r\n\r\n    return equalCommands\r\n  }\r\n  // Make path array morphable\r\n, morph: function(pathArray) {\r\n    pathArray = new SVG.PathArray(pathArray)\r\n\r\n    if(this.equalCommands(pathArray)) {\r\n      this.destination = pathArray\r\n    } else {\r\n      this.destination = null\r\n    }\r\n\r\n    return this\r\n  }\r\n  // Get morphed path array at given position\r\n, at: function(pos) {\r\n    // make sure a destination is defined\r\n    if (!this.destination) return this\r\n\r\n    var sourceArray = this.value\r\n      , destinationArray = this.destination.value\r\n      , array = [], pathArray = new SVG.PathArray()\r\n      , i, il, j, jl\r\n\r\n    // Animate has specified in the SVG spec\r\n    // See: https://www.w3.org/TR/SVG11/paths.html#PathElement\r\n    for (i = 0, il = sourceArray.length; i < il; i++) {\r\n      array[i] = [sourceArray[i][0]]\r\n      for(j = 1, jl = sourceArray[i].length; j < jl; j++) {\r\n        array[i][j] = sourceArray[i][j] + (destinationArray[i][j] - sourceArray[i][j]) * pos\r\n      }\r\n      // For the two flags of the elliptical arc command, the SVG spec say:\r\n      // Flags and booleans are interpolated as fractions between zero and one, with any non-zero value considered to be a value of one/true\r\n      // Elliptical arc command as an array followed by corresponding indexes:\r\n      // ['A', rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]\r\n      //   0    1   2        3                 4             5      6  7\r\n      if(array[i][0] === 'A') {\r\n        array[i][4] = +(array[i][4] != 0)\r\n        array[i][5] = +(array[i][5] != 0)\r\n      }\r\n    }\r\n\r\n    // Directly modify the value of a path array, this is done this way for performance\r\n    pathArray.value = array\r\n    return pathArray\r\n  }\r\n  // Absolutize and parse path to array\r\n, parse: function(array) {\r\n    // if it's already a patharray, no need to parse it\r\n    if (array instanceof SVG.PathArray) return array.valueOf()\r\n\r\n    // prepare for parsing\r\n    var i, x0, y0, s, seg, arr\r\n      , x = 0\r\n      , y = 0\r\n      , paramCnt = { 'M':2, 'L':2, 'H':1, 'V':1, 'C':6, 'S':4, 'Q':4, 'T':2, 'A':7 }\r\n\r\n    if(typeof array == 'string'){\r\n\r\n      array = array\r\n        .replace(SVG.regex.numbersWithDots, pathRegReplace) // convert 45.123.123 to 45.123 .123\r\n        .replace(SVG.regex.pathLetters, ' $& ') // put some room between letters and numbers\r\n        .replace(SVG.regex.hyphen, '$1 -')      // add space before hyphen\r\n        .trim()                                 // trim\r\n        .split(SVG.regex.delimiter)   // split into array\r\n\r\n    }else{\r\n      array = array.reduce(function(prev, curr){\r\n        return [].concat.call(prev, curr)\r\n      }, [])\r\n    }\r\n\r\n    // array now is an array containing all parts of a path e.g. ['M', '0', '0', 'L', '30', '30' ...]\r\n\r\n    var arr = []\r\n\r\n    do{\r\n\r\n      // Test if we have a path letter\r\n      if(SVG.regex.isPathLetter.test(array[0])){\r\n        s = array[0]\r\n        array.shift()\r\n      // If last letter was a move command and we got no new, it defaults to [L]ine\r\n      }else if(s == 'M'){\r\n        s = 'L'\r\n      }else if(s == 'm'){\r\n        s = 'l'\r\n      }\r\n\r\n      // add path letter as first element\r\n      seg = [s.toUpperCase()]\r\n\r\n      // push all necessary parameters to segment\r\n      for(i = 0; i < paramCnt[seg[0]]; ++i){\r\n        seg.push(parseFloat(array.shift()))\r\n      }\r\n\r\n      // upper case\r\n      if(s == seg[0]){\r\n\r\n        if(s == 'M' || s == 'L' || s == 'C' || s == 'Q' || s == 'S' || s == 'T'){\r\n          x = seg[paramCnt[seg[0]]-1]\r\n          y = seg[paramCnt[seg[0]]]\r\n        }else if(s == 'V'){\r\n          y = seg[1]\r\n        }else if(s == 'H'){\r\n          x = seg[1]\r\n        }else if(s == 'A'){\r\n          x = seg[6]\r\n          y = seg[7]\r\n        }\r\n\r\n      // lower case\r\n      }else{\r\n\r\n        // convert relative to absolute values\r\n        if(s == 'm' || s == 'l' || s == 'c' || s == 's' || s == 'q' || s == 't'){\r\n\r\n          seg[1] += x\r\n          seg[2] += y\r\n\r\n          if(seg[3] != null){\r\n            seg[3] += x\r\n            seg[4] += y\r\n          }\r\n\r\n          if(seg[5] != null){\r\n            seg[5] += x\r\n            seg[6] += y\r\n          }\r\n\r\n          // move pointer\r\n          x = seg[paramCnt[seg[0]]-1]\r\n          y = seg[paramCnt[seg[0]]]\r\n\r\n        }else if(s == 'v'){\r\n          seg[1] += y\r\n          y = seg[1]\r\n        }else if(s == 'h'){\r\n          seg[1] += x\r\n          x = seg[1]\r\n        }else if(s == 'a'){\r\n          seg[6] += x\r\n          seg[7] += y\r\n          x = seg[6]\r\n          y = seg[7]\r\n        }\r\n\r\n      }\r\n\r\n      if(seg[0] == 'M'){\r\n        x0 = x\r\n        y0 = y\r\n      }\r\n\r\n      if(seg[0] == 'Z'){\r\n        x = x0\r\n        y = y0\r\n      }\r\n\r\n      arr.push(seg)\r\n\r\n    }while(array.length)\r\n\r\n    return arr\r\n\r\n  }\r\n  // Get bounding box of path\r\n, bbox: function() {\r\n    SVG.parser.path.setAttribute('d', this.toString())\r\n\r\n    return SVG.parser.path.getBBox()\r\n  }\r\n\r\n})\r\n\n// Module for unit convertions\r\nSVG.Number = SVG.invent({\r\n  // Initialize\r\n  create: function(value, unit) {\r\n    // initialize defaults\r\n    this.value = 0\r\n    this.unit  = unit || ''\r\n\r\n    // parse value\r\n    if (typeof value === 'number') {\r\n      // ensure a valid numeric value\r\n      this.value = isNaN(value) ? 0 : !isFinite(value) ? (value < 0 ? -3.4e+38 : +3.4e+38) : value\r\n\r\n    } else if (typeof value === 'string') {\r\n      unit = value.match(SVG.regex.numberAndUnit)\r\n\r\n      if (unit) {\r\n        // make value numeric\r\n        this.value = parseFloat(unit[1])\r\n\r\n        // normalize\r\n        if (unit[5] == '%')\r\n          this.value /= 100\r\n        else if (unit[5] == 's')\r\n          this.value *= 1000\r\n\r\n        // store unit\r\n        this.unit = unit[5]\r\n      }\r\n\r\n    } else {\r\n      if (value instanceof SVG.Number) {\r\n        this.value = value.valueOf()\r\n        this.unit  = value.unit\r\n      }\r\n    }\r\n\r\n  }\r\n  // Add methods\r\n, extend: {\r\n    // Stringalize\r\n    toString: function() {\r\n      return (\r\n        this.unit == '%' ?\r\n          ~~(this.value * 1e8) / 1e6:\r\n        this.unit == 's' ?\r\n          this.value / 1e3 :\r\n          this.value\r\n      ) + this.unit\r\n    }\r\n  , toJSON: function() {\r\n      return this.toString()\r\n    }\r\n  , // Convert to primitive\r\n    valueOf: function() {\r\n      return this.value\r\n    }\r\n    // Add number\r\n  , plus: function(number) {\r\n      number = new SVG.Number(number)\r\n      return new SVG.Number(this + number, this.unit || number.unit)\r\n    }\r\n    // Subtract number\r\n  , minus: function(number) {\r\n      number = new SVG.Number(number)\r\n      return new SVG.Number(this - number, this.unit || number.unit)\r\n    }\r\n    // Multiply number\r\n  , times: function(number) {\r\n      number = new SVG.Number(number)\r\n      return new SVG.Number(this * number, this.unit || number.unit)\r\n    }\r\n    // Divide number\r\n  , divide: function(number) {\r\n      number = new SVG.Number(number)\r\n      return new SVG.Number(this / number, this.unit || number.unit)\r\n    }\r\n    // Convert to different unit\r\n  , to: function(unit) {\r\n      var number = new SVG.Number(this)\r\n\r\n      if (typeof unit === 'string')\r\n        number.unit = unit\r\n\r\n      return number\r\n    }\r\n    // Make number morphable\r\n  , morph: function(number) {\r\n      this.destination = new SVG.Number(number)\r\n\r\n      if(number.relative) {\r\n        this.destination.value += this.value\r\n      }\r\n\r\n      return this\r\n    }\r\n    // Get morphed number at given position\r\n  , at: function(pos) {\r\n      // Make sure a destination is defined\r\n      if (!this.destination) return this\r\n\r\n      // Generate new morphed number\r\n      return new SVG.Number(this.destination)\r\n          .minus(this)\r\n          .times(pos)\r\n          .plus(this)\r\n    }\r\n\r\n  }\r\n})\r\n\n\r\nSVG.Element = SVG.invent({\r\n  // Initialize node\r\n  create: function(node) {\r\n    // make stroke value accessible dynamically\r\n    this._stroke = SVG.defaults.attrs.stroke\r\n    this._event = null\r\n\r\n    // initialize data object\r\n    this.dom = {}\r\n\r\n    // create circular reference\r\n    if (this.node = node) {\r\n      this.type = node.nodeName\r\n      this.node.instance = this\r\n\r\n      // store current attribute value\r\n      this._stroke = node.getAttribute('stroke') || this._stroke\r\n    }\r\n  }\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Move over x-axis\r\n    x: function(x) {\r\n      return this.attr('x', x)\r\n    }\r\n    // Move over y-axis\r\n  , y: function(y) {\r\n      return this.attr('y', y)\r\n    }\r\n    // Move by center over x-axis\r\n  , cx: function(x) {\r\n      return x == null ? this.x() + this.width() / 2 : this.x(x - this.width() / 2)\r\n    }\r\n    // Move by center over y-axis\r\n  , cy: function(y) {\r\n      return y == null ? this.y() + this.height() / 2 : this.y(y - this.height() / 2)\r\n    }\r\n    // Move element to given x and y values\r\n  , move: function(x, y) {\r\n      return this.x(x).y(y)\r\n    }\r\n    // Move element by its center\r\n  , center: function(x, y) {\r\n      return this.cx(x).cy(y)\r\n    }\r\n    // Set width of element\r\n  , width: function(width) {\r\n      return this.attr('width', width)\r\n    }\r\n    // Set height of element\r\n  , height: function(height) {\r\n      return this.attr('height', height)\r\n    }\r\n    // Set element size to given width and height\r\n  , size: function(width, height) {\r\n      var p = proportionalSize(this, width, height)\r\n\r\n      return this\r\n        .width(new SVG.Number(p.width))\r\n        .height(new SVG.Number(p.height))\r\n    }\r\n    // Clone element\r\n  , clone: function(parent, withData) {\r\n      // write dom data to the dom so the clone can pickup the data\r\n      this.writeDataToDom()\r\n\r\n      // clone element and assign new id\r\n      var clone = assignNewId(this.node.cloneNode(true))\r\n\r\n      // insert the clone in the given parent or after myself\r\n      if(parent) parent.add(clone)\r\n      else this.after(clone)\r\n\r\n      return clone\r\n    }\r\n    // Remove element\r\n  , remove: function() {\r\n      if (this.parent())\r\n        this.parent().removeElement(this)\r\n\r\n      return this\r\n    }\r\n    // Replace element\r\n  , replace: function(element) {\r\n      this.after(element).remove()\r\n\r\n      return element\r\n    }\r\n    // Add element to given container and return self\r\n  , addTo: function(parent) {\r\n      return parent.put(this)\r\n    }\r\n    // Add element to given container and return container\r\n  , putIn: function(parent) {\r\n      return parent.add(this)\r\n    }\r\n    // Get / set id\r\n  , id: function(id) {\r\n      return this.attr('id', id)\r\n    }\r\n    // Checks whether the given point inside the bounding box of the element\r\n  , inside: function(x, y) {\r\n      var box = this.bbox()\r\n\r\n      return x > box.x\r\n          && y > box.y\r\n          && x < box.x + box.width\r\n          && y < box.y + box.height\r\n    }\r\n    // Show element\r\n  , show: function() {\r\n      return this.style('display', '')\r\n    }\r\n    // Hide element\r\n  , hide: function() {\r\n      return this.style('display', 'none')\r\n    }\r\n    // Is element visible?\r\n  , visible: function() {\r\n      return this.style('display') != 'none'\r\n    }\r\n    // Return id on string conversion\r\n  , toString: function() {\r\n      return this.attr('id')\r\n    }\r\n    // Return array of classes on the node\r\n  , classes: function() {\r\n      var attr = this.attr('class')\r\n\r\n      return attr == null ? [] : attr.trim().split(SVG.regex.delimiter)\r\n    }\r\n    // Return true if class exists on the node, false otherwise\r\n  , hasClass: function(name) {\r\n      return this.classes().indexOf(name) != -1\r\n    }\r\n    // Add class to the node\r\n  , addClass: function(name) {\r\n      if (!this.hasClass(name)) {\r\n        var array = this.classes()\r\n        array.push(name)\r\n        this.attr('class', array.join(' '))\r\n      }\r\n\r\n      return this\r\n    }\r\n    // Remove class from the node\r\n  , removeClass: function(name) {\r\n      if (this.hasClass(name)) {\r\n        this.attr('class', this.classes().filter(function(c) {\r\n          return c != name\r\n        }).join(' '))\r\n      }\r\n\r\n      return this\r\n    }\r\n    // Toggle the presence of a class on the node\r\n  , toggleClass: function(name) {\r\n      return this.hasClass(name) ? this.removeClass(name) : this.addClass(name)\r\n    }\r\n    // Get referenced element form attribute value\r\n  , reference: function(attr) {\r\n      return SVG.get(this.attr(attr))\r\n    }\r\n    // Returns the parent element instance\r\n  , parent: function(type) {\r\n      var parent = this\r\n\r\n      // check for parent\r\n      if(!parent.node.parentNode) return null\r\n\r\n      // get parent element\r\n      parent = SVG.adopt(parent.node.parentNode)\r\n\r\n      if(!type) return parent\r\n\r\n      // loop trough ancestors if type is given\r\n      while(parent && parent.node instanceof window.SVGElement){\r\n        if(typeof type === 'string' ? parent.matches(type) : parent instanceof type) return parent\r\n        parent = SVG.adopt(parent.node.parentNode)\r\n      }\r\n    }\r\n    // Get parent document\r\n  , doc: function() {\r\n      return this instanceof SVG.Doc ? this : this.parent(SVG.Doc)\r\n    }\r\n    // return array of all ancestors of given type up to the root svg\r\n  , parents: function(type) {\r\n      var parents = [], parent = this\r\n\r\n      do{\r\n        parent = parent.parent(type)\r\n        if(!parent || !parent.node) break\r\n\r\n        parents.push(parent)\r\n      } while(parent.parent)\r\n\r\n      return parents\r\n    }\r\n    // matches the element vs a css selector\r\n  , matches: function(selector){\r\n      return matches(this.node, selector)\r\n    }\r\n    // Returns the svg node to call native svg methods on it\r\n  , native: function() {\r\n      return this.node\r\n    }\r\n    // Import raw svg\r\n  , svg: function(svg) {\r\n      // create temporary holder\r\n      var well = document.createElement('svg')\r\n\r\n      // act as a setter if svg is given\r\n      if (svg && this instanceof SVG.Parent) {\r\n        // dump raw svg\r\n        well.innerHTML = '<svg>' + svg.replace(/\\n/, '').replace(/<(\\w+)([^<]+?)\\/>/g, '<$1$2></$1>') + '</svg>'\r\n\r\n        // transplant nodes\r\n        for (var i = 0, il = well.firstChild.childNodes.length; i < il; i++)\r\n          this.node.appendChild(well.firstChild.firstChild)\r\n\r\n      // otherwise act as a getter\r\n      } else {\r\n        // create a wrapping svg element in case of partial content\r\n        well.appendChild(svg = document.createElement('svg'))\r\n\r\n        // write svgjs data to the dom\r\n        this.writeDataToDom()\r\n\r\n        // insert a copy of this node\r\n        svg.appendChild(this.node.cloneNode(true))\r\n\r\n        // return target element\r\n        return well.innerHTML.replace(/^<svg>/, '').replace(/<\\/svg>$/, '')\r\n      }\r\n\r\n      return this\r\n    }\r\n  // write svgjs data to the dom\r\n  , writeDataToDom: function() {\r\n\r\n      // dump variables recursively\r\n      if(this.each || this.lines){\r\n        var fn = this.each ? this : this.lines();\r\n        fn.each(function(){\r\n          this.writeDataToDom()\r\n        })\r\n      }\r\n\r\n      // remove previously set data\r\n      this.node.removeAttribute('svgjs:data')\r\n\r\n      if(Object.keys(this.dom).length)\r\n        this.node.setAttribute('svgjs:data', JSON.stringify(this.dom)) // see #428\r\n\r\n      return this\r\n    }\r\n  // set given data to the elements data property\r\n  , setData: function(o){\r\n      this.dom = o\r\n      return this\r\n    }\r\n  , is: function(obj){\r\n      return is(this, obj)\r\n    }\r\n  }\r\n})\r\n\nSVG.easing = {\r\n  '-': function(pos){return pos}\r\n, '<>':function(pos){return -Math.cos(pos * Math.PI) / 2 + 0.5}\r\n, '>': function(pos){return  Math.sin(pos * Math.PI / 2)}\r\n, '<': function(pos){return -Math.cos(pos * Math.PI / 2) + 1}\r\n}\r\n\r\nSVG.morph = function(pos){\r\n  return function(from, to) {\r\n    return new SVG.MorphObj(from, to).at(pos)\r\n  }\r\n}\r\n\r\nSVG.Situation = SVG.invent({\r\n\r\n  create: function(o){\r\n    this.init = false\r\n    this.reversed = false\r\n    this.reversing = false\r\n\r\n    this.duration = new SVG.Number(o.duration).valueOf()\r\n    this.delay = new SVG.Number(o.delay).valueOf()\r\n\r\n    this.start = +new Date() + this.delay\r\n    this.finish = this.start + this.duration\r\n    this.ease = o.ease\r\n\r\n    // this.loop is incremented from 0 to this.loops\r\n    // it is also incremented when in an infinite loop (when this.loops is true)\r\n    this.loop = 0\r\n    this.loops = false\r\n\r\n    this.animations = {\r\n      // functionToCall: [list of morphable objects]\r\n      // e.g. move: [SVG.Number, SVG.Number]\r\n    }\r\n\r\n    this.attrs = {\r\n      // holds all attributes which are not represented from a function svg.js provides\r\n      // e.g. someAttr: SVG.Number\r\n    }\r\n\r\n    this.styles = {\r\n      // holds all styles which should be animated\r\n      // e.g. fill-color: SVG.Color\r\n    }\r\n\r\n    this.transforms = [\r\n      // holds all transformations as transformation objects\r\n      // e.g. [SVG.Rotate, SVG.Translate, SVG.Matrix]\r\n    ]\r\n\r\n    this.once = {\r\n      // functions to fire at a specific position\r\n      // e.g. \"0.5\": function foo(){}\r\n    }\r\n\r\n  }\r\n\r\n})\r\n\r\n\r\nSVG.FX = SVG.invent({\r\n\r\n  create: function(element) {\r\n    this._target = element\r\n    this.situations = []\r\n    this.active = false\r\n    this.situation = null\r\n    this.paused = false\r\n    this.lastPos = 0\r\n    this.pos = 0\r\n    // The absolute position of an animation is its position in the context of its complete duration (including delay and loops)\r\n    // When performing a delay, absPos is below 0 and when performing a loop, its value is above 1\r\n    this.absPos = 0\r\n    this._speed = 1\r\n  }\r\n\r\n, extend: {\r\n\r\n    /**\r\n     * sets or returns the target of this animation\r\n     * @param o object || number In case of Object it holds all parameters. In case of number its the duration of the animation\r\n     * @param ease function || string Function which should be used for easing or easing keyword\r\n     * @param delay Number indicating the delay before the animation starts\r\n     * @return target || this\r\n     */\r\n    animate: function(o, ease, delay){\r\n\r\n      if(typeof o == 'object'){\r\n        ease = o.ease\r\n        delay = o.delay\r\n        o = o.duration\r\n      }\r\n\r\n      var situation = new SVG.Situation({\r\n        duration: o || 1000,\r\n        delay: delay || 0,\r\n        ease: SVG.easing[ease || '-'] || ease\r\n      })\r\n\r\n      this.queue(situation)\r\n\r\n      return this\r\n    }\r\n\r\n    /**\r\n     * sets a delay before the next element of the queue is called\r\n     * @param delay Duration of delay in milliseconds\r\n     * @return this.target()\r\n     */\r\n  , delay: function(delay){\r\n      // The delay is performed by an empty situation with its duration\r\n      // attribute set to the duration of the delay\r\n      var situation = new SVG.Situation({\r\n        duration: delay,\r\n        delay: 0,\r\n        ease: SVG.easing['-']\r\n      })\r\n\r\n      return this.queue(situation)\r\n    }\r\n\r\n    /**\r\n     * sets or returns the target of this animation\r\n     * @param null || target SVG.Element which should be set as new target\r\n     * @return target || this\r\n     */\r\n  , target: function(target){\r\n      if(target && target instanceof SVG.Element){\r\n        this._target = target\r\n        return this\r\n      }\r\n\r\n      return this._target\r\n    }\r\n\r\n    // returns the absolute position at a given time\r\n  , timeToAbsPos: function(timestamp){\r\n      return (timestamp - this.situation.start) / (this.situation.duration/this._speed)\r\n    }\r\n\r\n    // returns the timestamp from a given absolute positon\r\n  , absPosToTime: function(absPos){\r\n      return this.situation.duration/this._speed * absPos + this.situation.start\r\n    }\r\n\r\n    // starts the animationloop\r\n  , startAnimFrame: function(){\r\n      this.stopAnimFrame()\r\n      this.animationFrame = window.requestAnimationFrame(function(){ this.step() }.bind(this))\r\n    }\r\n\r\n    // cancels the animationframe\r\n  , stopAnimFrame: function(){\r\n      window.cancelAnimationFrame(this.animationFrame)\r\n    }\r\n\r\n    // kicks off the animation - only does something when the queue is currently not active and at least one situation is set\r\n  , start: function(){\r\n      // dont start if already started\r\n      if(!this.active && this.situation){\r\n        this.active = true\r\n        this.startCurrent()\r\n      }\r\n\r\n      return this\r\n    }\r\n\r\n    // start the current situation\r\n  , startCurrent: function(){\r\n      this.situation.start = +new Date + this.situation.delay/this._speed\r\n      this.situation.finish = this.situation.start + this.situation.duration/this._speed\r\n      return this.initAnimations().step()\r\n    }\r\n\r\n    /**\r\n     * adds a function / Situation to the animation queue\r\n     * @param fn function / situation to add\r\n     * @return this\r\n     */\r\n  , queue: function(fn){\r\n      if(typeof fn == 'function' || fn instanceof SVG.Situation)\r\n        this.situations.push(fn)\r\n\r\n      if(!this.situation) this.situation = this.situations.shift()\r\n\r\n      return this\r\n    }\r\n\r\n    /**\r\n     * pulls next element from the queue and execute it\r\n     * @return this\r\n     */\r\n  , dequeue: function(){\r\n      // stop current animation\r\n      this.stop()\r\n\r\n      // get next animation from queue\r\n      this.situation = this.situations.shift()\r\n\r\n      if(this.situation){\r\n        if(this.situation instanceof SVG.Situation) {\r\n          this.start()\r\n        } else {\r\n          // If it is not a SVG.Situation, then it is a function, we execute it\r\n          this.situation.call(this)\r\n        }\r\n      }\r\n\r\n      return this\r\n    }\r\n\r\n    // updates all animations to the current state of the element\r\n    // this is important when one property could be changed from another property\r\n  , initAnimations: function() {\r\n      var i, source\r\n      var s = this.situation\r\n\r\n      if(s.init) return this\r\n\r\n      for(i in s.animations){\r\n        source = this.target()[i]()\r\n\r\n        // The condition is because some methods return a normal number instead\r\n        // of a SVG.Number\r\n        if(s.animations[i] instanceof SVG.Number)\r\n          source = new SVG.Number(source)\r\n\r\n        s.animations[i] = source.morph(s.animations[i])\r\n      }\r\n\r\n      for(i in s.attrs){\r\n        s.attrs[i] = new SVG.MorphObj(this.target().attr(i), s.attrs[i])\r\n      }\r\n\r\n      for(i in s.styles){\r\n        s.styles[i] = new SVG.MorphObj(this.target().style(i), s.styles[i])\r\n      }\r\n\r\n      s.initialTransformation = this.target().matrixify()\r\n\r\n      s.init = true\r\n      return this\r\n    }\r\n  , clearQueue: function(){\r\n      this.situations = []\r\n      return this\r\n    }\r\n  , clearCurrent: function(){\r\n      this.situation = null\r\n      return this\r\n    }\r\n    /** stops the animation immediately\r\n     * @param jumpToEnd A Boolean indicating whether to complete the current animation immediately.\r\n     * @param clearQueue A Boolean indicating whether to remove queued animation as well.\r\n     * @return this\r\n     */\r\n  , stop: function(jumpToEnd, clearQueue){\r\n      var active = this.active\r\n      this.active = false\r\n\r\n      if(clearQueue){\r\n        this.clearQueue()\r\n      }\r\n\r\n      if(jumpToEnd && this.situation){\r\n        // initialize the situation if it was not\r\n        !active && this.startCurrent()\r\n        this.atEnd()\r\n      }\r\n\r\n      this.stopAnimFrame()\r\n\r\n      return this.clearCurrent()\r\n    }\r\n\r\n    /** resets the element to the state where the current element has started\r\n     * @return this\r\n     */\r\n  , reset: function(){\r\n      if(this.situation){\r\n        var temp = this.situation\r\n        this.stop()\r\n        this.situation = temp\r\n        this.atStart()\r\n      }\r\n      return this\r\n    }\r\n\r\n    // Stop the currently-running animation, remove all queued animations, and complete all animations for the element.\r\n  , finish: function(){\r\n\r\n      this.stop(true, false)\r\n\r\n      while(this.dequeue().situation && this.stop(true, false));\r\n\r\n      this.clearQueue().clearCurrent()\r\n\r\n      return this\r\n    }\r\n\r\n    // set the internal animation pointer at the start position, before any loops, and updates the visualisation\r\n  , atStart: function() {\r\n      return this.at(0, true)\r\n    }\r\n\r\n    // set the internal animation pointer at the end position, after all the loops, and updates the visualisation\r\n  , atEnd: function() {\r\n      if (this.situation.loops === true) {\r\n        // If in a infinite loop, we end the current iteration\r\n        this.situation.loops = this.situation.loop + 1\r\n      }\r\n\r\n      if(typeof this.situation.loops == 'number') {\r\n        // If performing a finite number of loops, we go after all the loops\r\n        return this.at(this.situation.loops, true)\r\n      } else {\r\n        // If no loops, we just go at the end\r\n        return this.at(1, true)\r\n      }\r\n    }\r\n\r\n    // set the internal animation pointer to the specified position and updates the visualisation\r\n    // if isAbsPos is true, pos is treated as an absolute position\r\n  , at: function(pos, isAbsPos){\r\n      var durDivSpd = this.situation.duration/this._speed\r\n\r\n      this.absPos = pos\r\n      // If pos is not an absolute position, we convert it into one\r\n      if (!isAbsPos) {\r\n        if (this.situation.reversed) this.absPos = 1 - this.absPos\r\n        this.absPos += this.situation.loop\r\n      }\r\n\r\n      this.situation.start = +new Date - this.absPos * durDivSpd\r\n      this.situation.finish = this.situation.start + durDivSpd\r\n\r\n      return this.step(true)\r\n    }\r\n\r\n    /**\r\n     * sets or returns the speed of the animations\r\n     * @param speed null || Number The new speed of the animations\r\n     * @return Number || this\r\n     */\r\n  , speed: function(speed){\r\n      if (speed === 0) return this.pause()\r\n\r\n      if (speed) {\r\n        this._speed = speed\r\n        // We use an absolute position here so that speed can affect the delay before the animation\r\n        return this.at(this.absPos, true)\r\n      } else return this._speed\r\n    }\r\n\r\n    // Make loopable\r\n  , loop: function(times, reverse) {\r\n      var c = this.last()\r\n\r\n      // store total loops\r\n      c.loops = (times != null) ? times : true\r\n      c.loop = 0\r\n\r\n      if(reverse) c.reversing = true\r\n      return this\r\n    }\r\n\r\n    // pauses the animation\r\n  , pause: function(){\r\n      this.paused = true\r\n      this.stopAnimFrame()\r\n\r\n      return this\r\n    }\r\n\r\n    // unpause the animation\r\n  , play: function(){\r\n      if(!this.paused) return this\r\n      this.paused = false\r\n      // We use an absolute position here so that the delay before the animation can be paused\r\n      return this.at(this.absPos, true)\r\n    }\r\n\r\n    /**\r\n     * toggle or set the direction of the animation\r\n     * true sets direction to backwards while false sets it to forwards\r\n     * @param reversed Boolean indicating whether to reverse the animation or not (default: toggle the reverse status)\r\n     * @return this\r\n     */\r\n  , reverse: function(reversed){\r\n      var c = this.last()\r\n\r\n      if(typeof reversed == 'undefined') c.reversed = !c.reversed\r\n      else c.reversed = reversed\r\n\r\n      return this\r\n    }\r\n\r\n\r\n    /**\r\n     * returns a float from 0-1 indicating the progress of the current animation\r\n     * @param eased Boolean indicating whether the returned position should be eased or not\r\n     * @return number\r\n     */\r\n  , progress: function(easeIt){\r\n      return easeIt ? this.situation.ease(this.pos) : this.pos\r\n    }\r\n\r\n    /**\r\n     * adds a callback function which is called when the current animation is finished\r\n     * @param fn Function which should be executed as callback\r\n     * @return number\r\n     */\r\n  , after: function(fn){\r\n      var c = this.last()\r\n        , wrapper = function wrapper(e){\r\n            if(e.detail.situation == c){\r\n              fn.call(this, c)\r\n              this.off('finished.fx', wrapper) // prevent memory leak\r\n            }\r\n          }\r\n\r\n      this.target().on('finished.fx', wrapper)\r\n\r\n      return this._callStart()\r\n    }\r\n\r\n    // adds a callback which is called whenever one animation step is performed\r\n  , during: function(fn){\r\n      var c = this.last()\r\n        , wrapper = function(e){\r\n            if(e.detail.situation == c){\r\n              fn.call(this, e.detail.pos, SVG.morph(e.detail.pos), e.detail.eased, c)\r\n            }\r\n          }\r\n\r\n      // see above\r\n      this.target().off('during.fx', wrapper).on('during.fx', wrapper)\r\n\r\n      this.after(function(){\r\n        this.off('during.fx', wrapper)\r\n      })\r\n\r\n      return this._callStart()\r\n    }\r\n\r\n    // calls after ALL animations in the queue are finished\r\n  , afterAll: function(fn){\r\n      var wrapper = function wrapper(e){\r\n            fn.call(this)\r\n            this.off('allfinished.fx', wrapper)\r\n          }\r\n\r\n      // see above\r\n      this.target().off('allfinished.fx', wrapper).on('allfinished.fx', wrapper)\r\n\r\n      return this._callStart()\r\n    }\r\n\r\n    // calls on every animation step for all animations\r\n  , duringAll: function(fn){\r\n      var wrapper = function(e){\r\n            fn.call(this, e.detail.pos, SVG.morph(e.detail.pos), e.detail.eased, e.detail.situation)\r\n          }\r\n\r\n      this.target().off('during.fx', wrapper).on('during.fx', wrapper)\r\n\r\n      this.afterAll(function(){\r\n        this.off('during.fx', wrapper)\r\n      })\r\n\r\n      return this._callStart()\r\n    }\r\n\r\n  , last: function(){\r\n      return this.situations.length ? this.situations[this.situations.length-1] : this.situation\r\n    }\r\n\r\n    // adds one property to the animations\r\n  , add: function(method, args, type){\r\n      this.last()[type || 'animations'][method] = args\r\n      return this._callStart()\r\n    }\r\n\r\n    /** perform one step of the animation\r\n     *  @param ignoreTime Boolean indicating whether to ignore time and use position directly or recalculate position based on time\r\n     *  @return this\r\n     */\r\n  , step: function(ignoreTime){\r\n\r\n      // convert current time to an absolute position\r\n      if(!ignoreTime) this.absPos = this.timeToAbsPos(+new Date)\r\n\r\n      // This part convert an absolute position to a position\r\n      if(this.situation.loops !== false) {\r\n        var absPos, absPosInt, lastLoop\r\n\r\n        // If the absolute position is below 0, we just treat it as if it was 0\r\n        absPos = Math.max(this.absPos, 0)\r\n        absPosInt = Math.floor(absPos)\r\n\r\n        if(this.situation.loops === true || absPosInt < this.situation.loops) {\r\n          this.pos = absPos - absPosInt\r\n          lastLoop = this.situation.loop\r\n          this.situation.loop = absPosInt\r\n        } else {\r\n          this.absPos = this.situation.loops\r\n          this.pos = 1\r\n          // The -1 here is because we don't want to toggle reversed when all the loops have been completed\r\n          lastLoop = this.situation.loop - 1\r\n          this.situation.loop = this.situation.loops\r\n        }\r\n\r\n        if(this.situation.reversing) {\r\n          // Toggle reversed if an odd number of loops as occured since the last call of step\r\n          this.situation.reversed = this.situation.reversed != Boolean((this.situation.loop - lastLoop) % 2)\r\n        }\r\n\r\n      } else {\r\n        // If there are no loop, the absolute position must not be above 1\r\n        this.absPos = Math.min(this.absPos, 1)\r\n        this.pos = this.absPos\r\n      }\r\n\r\n      // while the absolute position can be below 0, the position must not be below 0\r\n      if(this.pos < 0) this.pos = 0\r\n\r\n      if(this.situation.reversed) this.pos = 1 - this.pos\r\n\r\n\r\n      // apply easing\r\n      var eased = this.situation.ease(this.pos)\r\n\r\n      // call once-callbacks\r\n      for(var i in this.situation.once){\r\n        if(i > this.lastPos && i <= eased){\r\n          this.situation.once[i].call(this.target(), this.pos, eased)\r\n          delete this.situation.once[i]\r\n        }\r\n      }\r\n\r\n      // fire during callback with position, eased position and current situation as parameter\r\n      if(this.active) this.target().fire('during', {pos: this.pos, eased: eased, fx: this, situation: this.situation})\r\n\r\n      // the user may call stop or finish in the during callback\r\n      // so make sure that we still have a valid situation\r\n      if(!this.situation){\r\n        return this\r\n      }\r\n\r\n      // apply the actual animation to every property\r\n      this.eachAt()\r\n\r\n      // do final code when situation is finished\r\n      if((this.pos == 1 && !this.situation.reversed) || (this.situation.reversed && this.pos == 0)){\r\n\r\n        // stop animation callback\r\n        this.stopAnimFrame()\r\n\r\n        // fire finished callback with current situation as parameter\r\n        this.target().fire('finished', {fx:this, situation: this.situation})\r\n\r\n        if(!this.situations.length){\r\n          this.target().fire('allfinished')\r\n          this.target().off('.fx') // there shouldnt be any binding left, but to make sure...\r\n          this.active = false\r\n        }\r\n\r\n        // start next animation\r\n        if(this.active) this.dequeue()\r\n        else this.clearCurrent()\r\n\r\n      }else if(!this.paused && this.active){\r\n        // we continue animating when we are not at the end\r\n        this.startAnimFrame()\r\n      }\r\n\r\n      // save last eased position for once callback triggering\r\n      this.lastPos = eased\r\n      return this\r\n\r\n    }\r\n\r\n    // calculates the step for every property and calls block with it\r\n  , eachAt: function(){\r\n      var i, at, self = this, target = this.target(), s = this.situation\r\n\r\n      // apply animations which can be called trough a method\r\n      for(i in s.animations){\r\n\r\n        at = [].concat(s.animations[i]).map(function(el){\r\n          return typeof el !== 'string' && el.at ? el.at(s.ease(self.pos), self.pos) : el\r\n        })\r\n\r\n        target[i].apply(target, at)\r\n\r\n      }\r\n\r\n      // apply animation which has to be applied with attr()\r\n      for(i in s.attrs){\r\n\r\n        at = [i].concat(s.attrs[i]).map(function(el){\r\n          return typeof el !== 'string' && el.at ? el.at(s.ease(self.pos), self.pos) : el\r\n        })\r\n\r\n        target.attr.apply(target, at)\r\n\r\n      }\r\n\r\n      // apply animation which has to be applied with style()\r\n      for(i in s.styles){\r\n\r\n        at = [i].concat(s.styles[i]).map(function(el){\r\n          return typeof el !== 'string' && el.at ? el.at(s.ease(self.pos), self.pos) : el\r\n        })\r\n\r\n        target.style.apply(target, at)\r\n\r\n      }\r\n\r\n      // animate initialTransformation which has to be chained\r\n      if(s.transforms.length){\r\n\r\n        // get initial initialTransformation\r\n        at = s.initialTransformation\r\n        for(i = 0, len = s.transforms.length; i < len; i++){\r\n\r\n          // get next transformation in chain\r\n          var a = s.transforms[i]\r\n\r\n          // multiply matrix directly\r\n          if(a instanceof SVG.Matrix){\r\n\r\n            if(a.relative){\r\n              at = at.multiply(new SVG.Matrix().morph(a).at(s.ease(this.pos)))\r\n            }else{\r\n              at = at.morph(a).at(s.ease(this.pos))\r\n            }\r\n            continue\r\n          }\r\n\r\n          // when transformation is absolute we have to reset the needed transformation first\r\n          if(!a.relative)\r\n            a.undo(at.extract())\r\n\r\n          // and reapply it after\r\n          at = at.multiply(a.at(s.ease(this.pos)))\r\n\r\n        }\r\n\r\n        // set new matrix on element\r\n        target.matrix(at)\r\n      }\r\n\r\n      return this\r\n\r\n    }\r\n\r\n\r\n    // adds an once-callback which is called at a specific position and never again\r\n  , once: function(pos, fn, isEased){\r\n\r\n      if(!isEased)pos = this.situation.ease(pos)\r\n\r\n      this.situation.once[pos] = fn\r\n\r\n      return this\r\n    }\r\n\r\n  , _callStart: function() {\r\n      setTimeout(function(){this.start()}.bind(this), 0)\r\n      return this\r\n    }\r\n\r\n  }\r\n\r\n, parent: SVG.Element\r\n\r\n  // Add method to parent elements\r\n, construct: {\r\n    // Get fx module or create a new one, then animate with given duration and ease\r\n    animate: function(o, ease, delay) {\r\n      return (this.fx || (this.fx = new SVG.FX(this))).animate(o, ease, delay)\r\n    }\r\n  , delay: function(delay){\r\n      return (this.fx || (this.fx = new SVG.FX(this))).delay(delay)\r\n    }\r\n  , stop: function(jumpToEnd, clearQueue) {\r\n      if (this.fx)\r\n        this.fx.stop(jumpToEnd, clearQueue)\r\n\r\n      return this\r\n    }\r\n  , finish: function() {\r\n      if (this.fx)\r\n        this.fx.finish()\r\n\r\n      return this\r\n    }\r\n    // Pause current animation\r\n  , pause: function() {\r\n      if (this.fx)\r\n        this.fx.pause()\r\n\r\n      return this\r\n    }\r\n    // Play paused current animation\r\n  , play: function() {\r\n      if (this.fx)\r\n        this.fx.play()\r\n\r\n      return this\r\n    }\r\n    // Set/Get the speed of the animations\r\n  , speed: function(speed) {\r\n      if (this.fx)\r\n        if (speed == null)\r\n          return this.fx.speed()\r\n        else\r\n          this.fx.speed(speed)\r\n\r\n      return this\r\n    }\r\n  }\r\n\r\n})\r\n\r\n// MorphObj is used whenever no morphable object is given\r\nSVG.MorphObj = SVG.invent({\r\n\r\n  create: function(from, to){\r\n    // prepare color for morphing\r\n    if(SVG.Color.isColor(to)) return new SVG.Color(from).morph(to)\r\n    // prepare number for morphing\r\n    if(SVG.regex.numberAndUnit.test(to)) return new SVG.Number(from).morph(to)\r\n\r\n    // prepare for plain morphing\r\n    this.value = from\r\n    this.destination = to\r\n  }\r\n\r\n, extend: {\r\n    at: function(pos, real){\r\n      return real < 1 ? this.value : this.destination\r\n    },\r\n\r\n    valueOf: function(){\r\n      return this.value\r\n    }\r\n  }\r\n\r\n})\r\n\r\nSVG.extend(SVG.FX, {\r\n  // Add animatable attributes\r\n  attr: function(a, v, relative) {\r\n    // apply attributes individually\r\n    if (typeof a == 'object') {\r\n      for (var key in a)\r\n        this.attr(key, a[key])\r\n\r\n    } else {\r\n      this.add(a, v, 'attrs')\r\n    }\r\n\r\n    return this\r\n  }\r\n  // Add animatable styles\r\n, style: function(s, v) {\r\n    if (typeof s == 'object')\r\n      for (var key in s)\r\n        this.style(key, s[key])\r\n\r\n    else\r\n      this.add(s, v, 'styles')\r\n\r\n    return this\r\n  }\r\n  // Animatable x-axis\r\n, x: function(x, relative) {\r\n    if(this.target() instanceof SVG.G){\r\n      this.transform({x:x}, relative)\r\n      return this\r\n    }\r\n\r\n    var num = new SVG.Number(x)\r\n    num.relative = relative\r\n    return this.add('x', num)\r\n  }\r\n  // Animatable y-axis\r\n, y: function(y, relative) {\r\n    if(this.target() instanceof SVG.G){\r\n      this.transform({y:y}, relative)\r\n      return this\r\n    }\r\n\r\n    var num = new SVG.Number(y)\r\n    num.relative = relative\r\n    return this.add('y', num)\r\n  }\r\n  // Animatable center x-axis\r\n, cx: function(x) {\r\n    return this.add('cx', new SVG.Number(x))\r\n  }\r\n  // Animatable center y-axis\r\n, cy: function(y) {\r\n    return this.add('cy', new SVG.Number(y))\r\n  }\r\n  // Add animatable move\r\n, move: function(x, y) {\r\n    return this.x(x).y(y)\r\n  }\r\n  // Add animatable center\r\n, center: function(x, y) {\r\n    return this.cx(x).cy(y)\r\n  }\r\n  // Add animatable size\r\n, size: function(width, height) {\r\n    if (this.target() instanceof SVG.Text) {\r\n      // animate font size for Text elements\r\n      this.attr('font-size', width)\r\n\r\n    } else {\r\n      // animate bbox based size for all other elements\r\n      var box\r\n\r\n      if(!width || !height){\r\n        box = this.target().bbox()\r\n      }\r\n\r\n      if(!width){\r\n        width = box.width / box.height  * height\r\n      }\r\n\r\n      if(!height){\r\n        height = box.height / box.width  * width\r\n      }\r\n\r\n      this.add('width' , new SVG.Number(width))\r\n          .add('height', new SVG.Number(height))\r\n\r\n    }\r\n\r\n    return this\r\n  }\r\n  // Add animatable plot\r\n, plot: function() {\r\n    // We use arguments here since SVG.Line's plot method can be passed 4 parameters\r\n    return this.add('plot', arguments.length > 1 ? [].slice.call(arguments) : arguments[0])\r\n  }\r\n  // Add leading method\r\n, leading: function(value) {\r\n    return this.target().leading ?\r\n      this.add('leading', new SVG.Number(value)) :\r\n      this\r\n  }\r\n  // Add animatable viewbox\r\n, viewbox: function(x, y, width, height) {\r\n    if (this.target() instanceof SVG.Container) {\r\n      this.add('viewbox', new SVG.ViewBox(x, y, width, height))\r\n    }\r\n\r\n    return this\r\n  }\r\n, update: function(o) {\r\n    if (this.target() instanceof SVG.Stop) {\r\n      if (typeof o == 'number' || o instanceof SVG.Number) {\r\n        return this.update({\r\n          offset:  arguments[0]\r\n        , color:   arguments[1]\r\n        , opacity: arguments[2]\r\n        })\r\n      }\r\n\r\n      if (o.opacity != null) this.attr('stop-opacity', o.opacity)\r\n      if (o.color   != null) this.attr('stop-color', o.color)\r\n      if (o.offset  != null) this.attr('offset', o.offset)\r\n    }\r\n\r\n    return this\r\n  }\r\n})\r\n\nSVG.Box = SVG.invent({\r\n  create: function(x, y, width, height) {\r\n    if (typeof x == 'object' && !(x instanceof SVG.Element)) {\r\n      // chromes getBoundingClientRect has no x and y property\r\n      return SVG.Box.call(this, x.left != null ? x.left : x.x , x.top != null ? x.top : x.y, x.width, x.height)\r\n    } else if (arguments.length == 4) {\r\n      this.x = x\r\n      this.y = y\r\n      this.width = width\r\n      this.height = height\r\n\r\n    }\r\n\r\n    // add center, right, bottom...\r\n    fullBox(this)\r\n  }\r\n, extend: {\r\n    // Merge rect box with another, return a new instance\r\n    merge: function(box) {\r\n      var b = new this.constructor()\r\n\r\n      // merge boxes\r\n      b.x      = Math.min(this.x, box.x)\r\n      b.y      = Math.min(this.y, box.y)\r\n      b.width  = Math.max(this.x + this.width,  box.x + box.width)  - b.x\r\n      b.height = Math.max(this.y + this.height, box.y + box.height) - b.y\r\n\r\n      return fullBox(b)\r\n    }\r\n\r\n  , transform: function(m) {\r\n      var xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, p\r\n\r\n      var pts = [\r\n        new SVG.Point(this.x, this.y),\r\n        new SVG.Point(this.x2, this.y),\r\n        new SVG.Point(this.x, this.y2),\r\n        new SVG.Point(this.x2, this.y2)\r\n      ]\r\n\r\n      pts.forEach(function(p) {\r\n        p = p.transform(m)\r\n        xMin = Math.min(xMin,p.x)\r\n        xMax = Math.max(xMax,p.x)\r\n        yMin = Math.min(yMin,p.y)\r\n        yMax = Math.max(yMax,p.y)\r\n      })\r\n\r\n      bbox = new this.constructor()\r\n      bbox.x = xMin\r\n      bbox.width = xMax-xMin\r\n      bbox.y = yMin\r\n      bbox.height = yMax-yMin\r\n\r\n      fullBox(bbox)\r\n\r\n      return bbox\r\n    }\r\n  }\r\n})\r\n\r\nSVG.BBox = SVG.invent({\r\n  // Initialize\r\n  create: function(element) {\r\n    SVG.Box.apply(this, [].slice.call(arguments))\r\n\r\n    // get values if element is given\r\n    if (element instanceof SVG.Element) {\r\n      var box\r\n\r\n      // yes this is ugly, but Firefox can be a bitch when it comes to elements that are not yet rendered\r\n      try {\r\n\r\n        if (!document.documentElement.contains){\r\n          // This is IE - it does not support contains() for top-level SVGs\r\n          var topParent = element.node\r\n          while (topParent.parentNode){\r\n            topParent = topParent.parentNode\r\n          }\r\n          if (topParent != document) throw new Exception('Element not in the dom')\r\n        } else {\r\n          // the element is NOT in the dom, throw error\r\n          if(!document.documentElement.contains(element.node)) throw new Exception('Element not in the dom')\r\n        }\r\n\r\n        // find native bbox\r\n        box = element.node.getBBox()\r\n      } catch(e) {\r\n        if(element instanceof SVG.Shape){\r\n          var clone = element.clone(SVG.parser.draw).show()\r\n          box = clone.node.getBBox()\r\n          clone.remove()\r\n        }else{\r\n          box = {\r\n            x:      element.node.clientLeft\r\n          , y:      element.node.clientTop\r\n          , width:  element.node.clientWidth\r\n          , height: element.node.clientHeight\r\n          }\r\n        }\r\n      }\r\n\r\n      SVG.Box.call(this, box)\r\n    }\r\n\r\n  }\r\n\r\n  // Define ancestor\r\n, inherit: SVG.Box\r\n\r\n  // Define Parent\r\n, parent: SVG.Element\r\n\r\n  // Constructor\r\n, construct: {\r\n    // Get bounding box\r\n    bbox: function() {\r\n      return new SVG.BBox(this)\r\n    }\r\n  }\r\n\r\n})\r\n\r\nSVG.BBox.prototype.constructor = SVG.BBox\r\n\r\n\r\nSVG.extend(SVG.Element, {\r\n  tbox: function(){\r\n    console.warn('Use of TBox is deprecated and mapped to RBox. Use .rbox() instead.')\r\n    return this.rbox(this.doc())\r\n  }\r\n})\r\n\r\nSVG.RBox = SVG.invent({\r\n  // Initialize\r\n  create: function(element) {\r\n    SVG.Box.apply(this, [].slice.call(arguments))\r\n\r\n    if (element instanceof SVG.Element) {\r\n      SVG.Box.call(this, element.node.getBoundingClientRect())\r\n    }\r\n  }\r\n\r\n, inherit: SVG.Box\r\n\r\n  // define Parent\r\n, parent: SVG.Element\r\n\r\n, extend: {\r\n    addOffset: function() {\r\n      // offset by window scroll position, because getBoundingClientRect changes when window is scrolled\r\n      this.x += window.pageXOffset\r\n      this.y += window.pageYOffset\r\n      return this\r\n    }\r\n  }\r\n\r\n  // Constructor\r\n, construct: {\r\n    // Get rect box\r\n    rbox: function(el) {\r\n      if (el) return new SVG.RBox(this).transform(el.screenCTM().inverse())\r\n      return new SVG.RBox(this).addOffset()\r\n    }\r\n  }\r\n\r\n})\r\n\r\nSVG.RBox.prototype.constructor = SVG.RBox\r\n\nSVG.Matrix = SVG.invent({\r\n  // Initialize\r\n  create: function(source) {\r\n    var i, base = arrayToMatrix([1, 0, 0, 1, 0, 0])\r\n\r\n    // ensure source as object\r\n    source = source instanceof SVG.Element ?\r\n      source.matrixify() :\r\n    typeof source === 'string' ?\r\n      arrayToMatrix(source.split(SVG.regex.delimiter).map(parseFloat)) :\r\n    arguments.length == 6 ?\r\n      arrayToMatrix([].slice.call(arguments)) :\r\n    Array.isArray(source) ?\r\n      arrayToMatrix(source) :\r\n    typeof source === 'object' ?\r\n      source : base\r\n\r\n    // merge source\r\n    for (i = abcdef.length - 1; i >= 0; --i)\r\n      this[abcdef[i]] = source && typeof source[abcdef[i]] === 'number' ?\r\n        source[abcdef[i]] : base[abcdef[i]]\r\n  }\r\n\r\n  // Add methods\r\n, extend: {\r\n    // Extract individual transformations\r\n    extract: function() {\r\n      // find delta transform points\r\n      var px    = deltaTransformPoint(this, 0, 1)\r\n        , py    = deltaTransformPoint(this, 1, 0)\r\n        , skewX = 180 / Math.PI * Math.atan2(px.y, px.x) - 90\r\n\r\n      return {\r\n        // translation\r\n        x:        this.e\r\n      , y:        this.f\r\n      , transformedX:(this.e * Math.cos(skewX * Math.PI / 180) + this.f * Math.sin(skewX * Math.PI / 180)) / Math.sqrt(this.a * this.a + this.b * this.b)\r\n      , transformedY:(this.f * Math.cos(skewX * Math.PI / 180) + this.e * Math.sin(-skewX * Math.PI / 180)) / Math.sqrt(this.c * this.c + this.d * this.d)\r\n        // skew\r\n      , skewX:    -skewX\r\n      , skewY:    180 / Math.PI * Math.atan2(py.y, py.x)\r\n        // scale\r\n      , scaleX:   Math.sqrt(this.a * this.a + this.b * this.b)\r\n      , scaleY:   Math.sqrt(this.c * this.c + this.d * this.d)\r\n        // rotation\r\n      , rotation: skewX\r\n      , a: this.a\r\n      , b: this.b\r\n      , c: this.c\r\n      , d: this.d\r\n      , e: this.e\r\n      , f: this.f\r\n      , matrix: new SVG.Matrix(this)\r\n      }\r\n    }\r\n    // Clone matrix\r\n  , clone: function() {\r\n      return new SVG.Matrix(this)\r\n    }\r\n    // Morph one matrix into another\r\n  , morph: function(matrix) {\r\n      // store new destination\r\n      this.destination = new SVG.Matrix(matrix)\r\n\r\n      return this\r\n    }\r\n    // Get morphed matrix at a given position\r\n  , at: function(pos) {\r\n      // make sure a destination is defined\r\n      if (!this.destination) return this\r\n\r\n      // calculate morphed matrix at a given position\r\n      var matrix = new SVG.Matrix({\r\n        a: this.a + (this.destination.a - this.a) * pos\r\n      , b: this.b + (this.destination.b - this.b) * pos\r\n      , c: this.c + (this.destination.c - this.c) * pos\r\n      , d: this.d + (this.destination.d - this.d) * pos\r\n      , e: this.e + (this.destination.e - this.e) * pos\r\n      , f: this.f + (this.destination.f - this.f) * pos\r\n      })\r\n\r\n      return matrix\r\n    }\r\n    // Multiplies by given matrix\r\n  , multiply: function(matrix) {\r\n      return new SVG.Matrix(this.native().multiply(parseMatrix(matrix).native()))\r\n    }\r\n    // Inverses matrix\r\n  , inverse: function() {\r\n      return new SVG.Matrix(this.native().inverse())\r\n    }\r\n    // Translate matrix\r\n  , translate: function(x, y) {\r\n      return new SVG.Matrix(this.native().translate(x || 0, y || 0))\r\n    }\r\n    // Scale matrix\r\n  , scale: function(x, y, cx, cy) {\r\n      // support uniformal scale\r\n      if (arguments.length == 1) {\r\n        y = x\r\n      } else if (arguments.length == 3) {\r\n        cy = cx\r\n        cx = y\r\n        y = x\r\n      }\r\n\r\n      return this.around(cx, cy, new SVG.Matrix(x, 0, 0, y, 0, 0))\r\n    }\r\n    // Rotate matrix\r\n  , rotate: function(r, cx, cy) {\r\n      // convert degrees to radians\r\n      r = SVG.utils.radians(r)\r\n\r\n      return this.around(cx, cy, new SVG.Matrix(Math.cos(r), Math.sin(r), -Math.sin(r), Math.cos(r), 0, 0))\r\n    }\r\n    // Flip matrix on x or y, at a given offset\r\n  , flip: function(a, o) {\r\n      o = typeof a == 'number' ? a : o\r\n      return a == 'x' ?\r\n          this.scale(-1, 1, o, 0) :\r\n        a == 'y' ?\r\n          this.scale(1, -1, 0, o) :\r\n          this.scale(-1, -1, o, o)\r\n    }\r\n    // Skew\r\n  , skew: function(x, y, cx, cy) {\r\n      // support uniformal skew\r\n      if (arguments.length == 1) {\r\n        y = x\r\n      } else if (arguments.length == 3) {\r\n        cy = cx\r\n        cx = y\r\n        y = x\r\n      }\r\n\r\n      // convert degrees to radians\r\n      x = SVG.utils.radians(x)\r\n      y = SVG.utils.radians(y)\r\n\r\n      return this.around(cx, cy, new SVG.Matrix(1, Math.tan(y), Math.tan(x), 1, 0, 0))\r\n    }\r\n    // SkewX\r\n  , skewX: function(x, cx, cy) {\r\n      return this.skew(x, 0, cx, cy)\r\n    }\r\n    // SkewY\r\n  , skewY: function(y, cx, cy) {\r\n      return this.skew(0, y, cx, cy)\r\n    }\r\n    // Transform around a center point\r\n  , around: function(cx, cy, matrix) {\r\n      return this\r\n        .multiply(new SVG.Matrix(1, 0, 0, 1, cx || 0, cy || 0))\r\n        .multiply(matrix)\r\n        .multiply(new SVG.Matrix(1, 0, 0, 1, -cx || 0, -cy || 0))\r\n    }\r\n    // Convert to native SVGMatrix\r\n  , native: function() {\r\n      // create new matrix\r\n      var matrix = SVG.parser.native.createSVGMatrix()\r\n\r\n      // update with current values\r\n      for (var i = abcdef.length - 1; i >= 0; i--)\r\n        matrix[abcdef[i]] = this[abcdef[i]]\r\n\r\n      return matrix\r\n    }\r\n    // Convert matrix to string\r\n  , toString: function() {\r\n      return 'matrix(' + this.a + ',' + this.b + ',' + this.c + ',' + this.d + ',' + this.e + ',' + this.f + ')'\r\n    }\r\n  }\r\n\r\n  // Define parent\r\n, parent: SVG.Element\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Get current matrix\r\n    ctm: function() {\r\n      return new SVG.Matrix(this.node.getCTM())\r\n    },\r\n    // Get current screen matrix\r\n    screenCTM: function() {\r\n      /* https://bugzilla.mozilla.org/show_bug.cgi?id=1344537\r\n         This is needed because FF does not return the transformation matrix\r\n         for the inner coordinate system when getScreenCTM() is called on nested svgs.\r\n         However all other Browsers do that */\r\n      if(this instanceof SVG.Nested) {\r\n        var rect = this.rect(1,1)\r\n        var m = rect.node.getScreenCTM()\r\n        rect.remove()\r\n        return new SVG.Matrix(m)\r\n      }\r\n      return new SVG.Matrix(this.node.getScreenCTM())\r\n    }\r\n\r\n  }\r\n\r\n})\r\n\nSVG.Point = SVG.invent({\r\n  // Initialize\r\n  create: function(x,y) {\r\n    var i, source, base = {x:0, y:0}\r\n\r\n    // ensure source as object\r\n    source = Array.isArray(x) ?\r\n      {x:x[0], y:x[1]} :\r\n    typeof x === 'object' ?\r\n      {x:x.x, y:x.y} :\r\n    x != null ?\r\n      {x:x, y:(y != null ? y : x)} : base // If y has no value, then x is used has its value\r\n\r\n    // merge source\r\n    this.x = source.x\r\n    this.y = source.y\r\n  }\r\n\r\n  // Add methods\r\n, extend: {\r\n    // Clone point\r\n    clone: function() {\r\n      return new SVG.Point(this)\r\n    }\r\n    // Morph one point into another\r\n  , morph: function(x, y) {\r\n      // store new destination\r\n      this.destination = new SVG.Point(x, y)\r\n\r\n      return this\r\n    }\r\n    // Get morphed point at a given position\r\n  , at: function(pos) {\r\n      // make sure a destination is defined\r\n      if (!this.destination) return this\r\n\r\n      // calculate morphed matrix at a given position\r\n      var point = new SVG.Point({\r\n        x: this.x + (this.destination.x - this.x) * pos\r\n      , y: this.y + (this.destination.y - this.y) * pos\r\n      })\r\n\r\n      return point\r\n    }\r\n    // Convert to native SVGPoint\r\n  , native: function() {\r\n      // create new point\r\n      var point = SVG.parser.native.createSVGPoint()\r\n\r\n      // update with current values\r\n      point.x = this.x\r\n      point.y = this.y\r\n\r\n      return point\r\n    }\r\n    // transform point with matrix\r\n  , transform: function(matrix) {\r\n      return new SVG.Point(this.native().matrixTransform(matrix.native()))\r\n    }\r\n\r\n  }\r\n\r\n})\r\n\r\nSVG.extend(SVG.Element, {\r\n\r\n  // Get point\r\n  point: function(x, y) {\r\n    return new SVG.Point(x,y).transform(this.screenCTM().inverse());\r\n  }\r\n\r\n})\r\n\nSVG.extend(SVG.Element, {\r\n  // Set svg element attribute\r\n  attr: function(a, v, n) {\r\n    // act as full getter\r\n    if (a == null) {\r\n      // get an object of attributes\r\n      a = {}\r\n      v = this.node.attributes\r\n      for (n = v.length - 1; n >= 0; n--)\r\n        a[v[n].nodeName] = SVG.regex.isNumber.test(v[n].nodeValue) ? parseFloat(v[n].nodeValue) : v[n].nodeValue\r\n\r\n      return a\r\n\r\n    } else if (typeof a == 'object') {\r\n      // apply every attribute individually if an object is passed\r\n      for (v in a) this.attr(v, a[v])\r\n\r\n    } else if (v === null) {\r\n        // remove value\r\n        this.node.removeAttribute(a)\r\n\r\n    } else if (v == null) {\r\n      // act as a getter if the first and only argument is not an object\r\n      v = this.node.getAttribute(a)\r\n      return v == null ?\r\n        SVG.defaults.attrs[a] :\r\n      SVG.regex.isNumber.test(v) ?\r\n        parseFloat(v) : v\r\n\r\n    } else {\r\n      // BUG FIX: some browsers will render a stroke if a color is given even though stroke width is 0\r\n      if (a == 'stroke-width')\r\n        this.attr('stroke', parseFloat(v) > 0 ? this._stroke : null)\r\n      else if (a == 'stroke')\r\n        this._stroke = v\r\n\r\n      // convert image fill and stroke to patterns\r\n      if (a == 'fill' || a == 'stroke') {\r\n        if (SVG.regex.isImage.test(v))\r\n          v = this.doc().defs().image(v, 0, 0)\r\n\r\n        if (v instanceof SVG.Image)\r\n          v = this.doc().defs().pattern(0, 0, function() {\r\n            this.add(v)\r\n          })\r\n      }\r\n\r\n      // ensure correct numeric values (also accepts NaN and Infinity)\r\n      if (typeof v === 'number')\r\n        v = new SVG.Number(v)\r\n\r\n      // ensure full hex color\r\n      else if (SVG.Color.isColor(v))\r\n        v = new SVG.Color(v)\r\n\r\n      // parse array values\r\n      else if (Array.isArray(v))\r\n        v = new SVG.Array(v)\r\n\r\n      // if the passed attribute is leading...\r\n      if (a == 'leading') {\r\n        // ... call the leading method instead\r\n        if (this.leading)\r\n          this.leading(v)\r\n      } else {\r\n        // set given attribute on node\r\n        typeof n === 'string' ?\r\n          this.node.setAttributeNS(n, a, v.toString()) :\r\n          this.node.setAttribute(a, v.toString())\r\n      }\r\n\r\n      // rebuild if required\r\n      if (this.rebuild && (a == 'font-size' || a == 'x'))\r\n        this.rebuild(a, v)\r\n    }\r\n\r\n    return this\r\n  }\r\n})\nSVG.extend(SVG.Element, {\r\n  // Add transformations\r\n  transform: function(o, relative) {\r\n    // get target in case of the fx module, otherwise reference this\r\n    var target = this\r\n      , matrix\r\n\r\n    // act as a getter\r\n    if (typeof o !== 'object') {\r\n      // get current matrix\r\n      matrix = new SVG.Matrix(target).extract()\r\n\r\n      return typeof o === 'string' ? matrix[o] : matrix\r\n    }\r\n\r\n    // get current matrix\r\n    matrix = new SVG.Matrix(target)\r\n\r\n    // ensure relative flag\r\n    relative = !!relative || !!o.relative\r\n\r\n    // act on matrix\r\n    if (o.a != null) {\r\n      matrix = relative ?\r\n        // relative\r\n        matrix.multiply(new SVG.Matrix(o)) :\r\n        // absolute\r\n        new SVG.Matrix(o)\r\n\r\n    // act on rotation\r\n    } else if (o.rotation != null) {\r\n      // ensure centre point\r\n      ensureCentre(o, target)\r\n\r\n      // apply transformation\r\n      matrix = relative ?\r\n        // relative\r\n        matrix.rotate(o.rotation, o.cx, o.cy) :\r\n        // absolute\r\n        matrix.rotate(o.rotation - matrix.extract().rotation, o.cx, o.cy)\r\n\r\n    // act on scale\r\n    } else if (o.scale != null || o.scaleX != null || o.scaleY != null) {\r\n      // ensure centre point\r\n      ensureCentre(o, target)\r\n\r\n      // ensure scale values on both axes\r\n      o.scaleX = o.scale != null ? o.scale : o.scaleX != null ? o.scaleX : 1\r\n      o.scaleY = o.scale != null ? o.scale : o.scaleY != null ? o.scaleY : 1\r\n\r\n      if (!relative) {\r\n        // absolute; multiply inversed values\r\n        var e = matrix.extract()\r\n        o.scaleX = o.scaleX * 1 / e.scaleX\r\n        o.scaleY = o.scaleY * 1 / e.scaleY\r\n      }\r\n\r\n      matrix = matrix.scale(o.scaleX, o.scaleY, o.cx, o.cy)\r\n\r\n    // act on skew\r\n    } else if (o.skew != null || o.skewX != null || o.skewY != null) {\r\n      // ensure centre point\r\n      ensureCentre(o, target)\r\n\r\n      // ensure skew values on both axes\r\n      o.skewX = o.skew != null ? o.skew : o.skewX != null ? o.skewX : 0\r\n      o.skewY = o.skew != null ? o.skew : o.skewY != null ? o.skewY : 0\r\n\r\n      if (!relative) {\r\n        // absolute; reset skew values\r\n        var e = matrix.extract()\r\n        matrix = matrix.multiply(new SVG.Matrix().skew(e.skewX, e.skewY, o.cx, o.cy).inverse())\r\n      }\r\n\r\n      matrix = matrix.skew(o.skewX, o.skewY, o.cx, o.cy)\r\n\r\n    // act on flip\r\n    } else if (o.flip) {\r\n      matrix = matrix.flip(\r\n        o.flip\r\n      , o.offset == null ? target.bbox()['c' + o.flip] : o.offset\r\n      )\r\n\r\n    // act on translate\r\n    } else if (o.x != null || o.y != null) {\r\n      if (relative) {\r\n        // relative\r\n        matrix = matrix.translate(o.x, o.y)\r\n      } else {\r\n        // absolute\r\n        if (o.x != null) matrix.e = o.x\r\n        if (o.y != null) matrix.f = o.y\r\n      }\r\n    }\r\n\r\n    return this.attr('transform', matrix)\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.FX, {\r\n  transform: function(o, relative) {\r\n    // get target in case of the fx module, otherwise reference this\r\n    var target = this.target()\r\n      , matrix\r\n\r\n    // act as a getter\r\n    if (typeof o !== 'object') {\r\n      // get current matrix\r\n      matrix = new SVG.Matrix(target).extract()\r\n\r\n      return typeof o === 'string' ? matrix[o] : matrix\r\n    }\r\n\r\n    // ensure relative flag\r\n    relative = !!relative || !!o.relative\r\n\r\n    // act on matrix\r\n    if (o.a != null) {\r\n      matrix = new SVG.Matrix(o)\r\n\r\n    // act on rotation\r\n    } else if (o.rotation != null) {\r\n      // ensure centre point\r\n      ensureCentre(o, target)\r\n\r\n      // apply transformation\r\n      matrix = new SVG.Rotate(o.rotation, o.cx, o.cy)\r\n\r\n    // act on scale\r\n    } else if (o.scale != null || o.scaleX != null || o.scaleY != null) {\r\n      // ensure centre point\r\n      ensureCentre(o, target)\r\n\r\n      // ensure scale values on both axes\r\n      o.scaleX = o.scale != null ? o.scale : o.scaleX != null ? o.scaleX : 1\r\n      o.scaleY = o.scale != null ? o.scale : o.scaleY != null ? o.scaleY : 1\r\n\r\n      matrix = new SVG.Scale(o.scaleX, o.scaleY, o.cx, o.cy)\r\n\r\n    // act on skew\r\n    } else if (o.skewX != null || o.skewY != null) {\r\n      // ensure centre point\r\n      ensureCentre(o, target)\r\n\r\n      // ensure skew values on both axes\r\n      o.skewX = o.skewX != null ? o.skewX : 0\r\n      o.skewY = o.skewY != null ? o.skewY : 0\r\n\r\n      matrix = new SVG.Skew(o.skewX, o.skewY, o.cx, o.cy)\r\n\r\n    // act on flip\r\n    } else if (o.flip) {\r\n      matrix = new SVG.Matrix().flip(\r\n        o.flip\r\n      , o.offset == null ? target.bbox()['c' + o.flip] : o.offset\r\n      )\r\n\r\n    // act on translate\r\n    } else if (o.x != null || o.y != null) {\r\n      matrix = new SVG.Translate(o.x, o.y)\r\n    }\r\n\r\n    if(!matrix) return this\r\n\r\n    matrix.relative = relative\r\n\r\n    this.last().transforms.push(matrix)\r\n\r\n    return this._callStart()\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.Element, {\r\n  // Reset all transformations\r\n  untransform: function() {\r\n    return this.attr('transform', null)\r\n  },\r\n  // merge the whole transformation chain into one matrix and returns it\r\n  matrixify: function() {\r\n\r\n    var matrix = (this.attr('transform') || '')\r\n      // split transformations\r\n      .split(SVG.regex.transforms).slice(0,-1).map(function(str){\r\n        // generate key => value pairs\r\n        var kv = str.trim().split('(')\r\n        return [kv[0], kv[1].split(SVG.regex.delimiter).map(function(str){ return parseFloat(str) })]\r\n      })\r\n      // merge every transformation into one matrix\r\n      .reduce(function(matrix, transform){\r\n\r\n        if(transform[0] == 'matrix') return matrix.multiply(arrayToMatrix(transform[1]))\r\n        return matrix[transform[0]].apply(matrix, transform[1])\r\n\r\n      }, new SVG.Matrix())\r\n\r\n    return matrix\r\n  },\r\n  // add an element to another parent without changing the visual representation on the screen\r\n  toParent: function(parent) {\r\n    if(this == parent) return this\r\n    var ctm = this.screenCTM()\r\n    var pCtm = parent.screenCTM().inverse()\r\n\r\n    this.addTo(parent).untransform().transform(pCtm.multiply(ctm))\r\n\r\n    return this\r\n  },\r\n  // same as above with parent equals root-svg\r\n  toDoc: function() {\r\n    return this.toParent(this.doc())\r\n  }\r\n\r\n})\r\n\r\nSVG.Transformation = SVG.invent({\r\n\r\n  create: function(source, inversed){\r\n\r\n    if(arguments.length > 1 && typeof inversed != 'boolean'){\r\n      return this.constructor.call(this, [].slice.call(arguments))\r\n    }\r\n\r\n    if(Array.isArray(source)){\r\n      for(var i = 0, len = this.arguments.length; i < len; ++i){\r\n        this[this.arguments[i]] = source[i]\r\n      }\r\n    } else if(typeof source == 'object'){\r\n      for(var i = 0, len = this.arguments.length; i < len; ++i){\r\n        this[this.arguments[i]] = source[this.arguments[i]]\r\n      }\r\n    }\r\n\r\n    this.inversed = false\r\n\r\n    if(inversed === true){\r\n      this.inversed = true\r\n    }\r\n\r\n  }\r\n\r\n, extend: {\r\n\r\n    arguments: []\r\n  , method: ''\r\n\r\n  , at: function(pos){\r\n\r\n      var params = []\r\n\r\n      for(var i = 0, len = this.arguments.length; i < len; ++i){\r\n        params.push(this[this.arguments[i]])\r\n      }\r\n\r\n      var m = this._undo || new SVG.Matrix()\r\n\r\n      m = new SVG.Matrix().morph(SVG.Matrix.prototype[this.method].apply(m, params)).at(pos)\r\n\r\n      return this.inversed ? m.inverse() : m\r\n\r\n    }\r\n\r\n  , undo: function(o){\r\n      for(var i = 0, len = this.arguments.length; i < len; ++i){\r\n        o[this.arguments[i]] = typeof this[this.arguments[i]] == 'undefined' ? 0 : o[this.arguments[i]]\r\n      }\r\n\r\n      // The method SVG.Matrix.extract which was used before calling this\r\n      // method to obtain a value for the parameter o doesn't return a cx and\r\n      // a cy so we use the ones that were provided to this object at its creation\r\n      o.cx = this.cx\r\n      o.cy = this.cy\r\n\r\n      this._undo = new SVG[capitalize(this.method)](o, true).at(1)\r\n\r\n      return this\r\n    }\r\n\r\n  }\r\n\r\n})\r\n\r\nSVG.Translate = SVG.invent({\r\n\r\n  parent: SVG.Matrix\r\n, inherit: SVG.Transformation\r\n\r\n, create: function(source, inversed){\r\n    this.constructor.apply(this, [].slice.call(arguments))\r\n  }\r\n\r\n, extend: {\r\n    arguments: ['transformedX', 'transformedY']\r\n  , method: 'translate'\r\n  }\r\n\r\n})\r\n\r\nSVG.Rotate = SVG.invent({\r\n\r\n  parent: SVG.Matrix\r\n, inherit: SVG.Transformation\r\n\r\n, create: function(source, inversed){\r\n    this.constructor.apply(this, [].slice.call(arguments))\r\n  }\r\n\r\n, extend: {\r\n    arguments: ['rotation', 'cx', 'cy']\r\n  , method: 'rotate'\r\n  , at: function(pos){\r\n      var m = new SVG.Matrix().rotate(new SVG.Number().morph(this.rotation - (this._undo ? this._undo.rotation : 0)).at(pos), this.cx, this.cy)\r\n      return this.inversed ? m.inverse() : m\r\n    }\r\n  , undo: function(o){\r\n      this._undo = o\r\n      return this\r\n    }\r\n  }\r\n\r\n})\r\n\r\nSVG.Scale = SVG.invent({\r\n\r\n  parent: SVG.Matrix\r\n, inherit: SVG.Transformation\r\n\r\n, create: function(source, inversed){\r\n    this.constructor.apply(this, [].slice.call(arguments))\r\n  }\r\n\r\n, extend: {\r\n    arguments: ['scaleX', 'scaleY', 'cx', 'cy']\r\n  , method: 'scale'\r\n  }\r\n\r\n})\r\n\r\nSVG.Skew = SVG.invent({\r\n\r\n  parent: SVG.Matrix\r\n, inherit: SVG.Transformation\r\n\r\n, create: function(source, inversed){\r\n    this.constructor.apply(this, [].slice.call(arguments))\r\n  }\r\n\r\n, extend: {\r\n    arguments: ['skewX', 'skewY', 'cx', 'cy']\r\n  , method: 'skew'\r\n  }\r\n\r\n})\r\n\nSVG.extend(SVG.Element, {\r\n  // Dynamic style generator\r\n  style: function(s, v) {\r\n    if (arguments.length == 0) {\r\n      // get full style\r\n      return this.node.style.cssText || ''\r\n\r\n    } else if (arguments.length < 2) {\r\n      // apply every style individually if an object is passed\r\n      if (typeof s == 'object') {\r\n        for (v in s) this.style(v, s[v])\r\n\r\n      } else if (SVG.regex.isCss.test(s)) {\r\n        // parse css string\r\n        s = s.split(/\\s*;\\s*/)\r\n          // filter out suffix ; and stuff like ;;\r\n          .filter(function(e) { return !!e })\r\n          .map(function(e){ return e.split(/\\s*:\\s*/) })\r\n\r\n        // apply every definition individually\r\n        while (v = s.pop()) {\r\n          this.style(v[0], v[1])\r\n        }\r\n      } else {\r\n        // act as a getter if the first and only argument is not an object\r\n        return this.node.style[camelCase(s)]\r\n      }\r\n\r\n    } else {\r\n      this.node.style[camelCase(s)] = v === null || SVG.regex.isBlank.test(v) ? '' : v\r\n    }\r\n\r\n    return this\r\n  }\r\n})\nSVG.Parent = SVG.invent({\r\n  // Initialize node\r\n  create: function(element) {\r\n    this.constructor.call(this, element)\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Element\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Returns all child elements\r\n    children: function() {\r\n      return SVG.utils.map(SVG.utils.filterSVGElements(this.node.childNodes), function(node) {\r\n        return SVG.adopt(node)\r\n      })\r\n    }\r\n    // Add given element at a position\r\n  , add: function(element, i) {\r\n      if (i == null)\r\n        this.node.appendChild(element.node)\r\n      else if (element.node != this.node.childNodes[i])\r\n        this.node.insertBefore(element.node, this.node.childNodes[i])\r\n\r\n      return this\r\n    }\r\n    // Basically does the same as `add()` but returns the added element instead\r\n  , put: function(element, i) {\r\n      this.add(element, i)\r\n      return element\r\n    }\r\n    // Checks if the given element is a child\r\n  , has: function(element) {\r\n      return this.index(element) >= 0\r\n    }\r\n    // Gets index of given element\r\n  , index: function(element) {\r\n      return [].slice.call(this.node.childNodes).indexOf(element.node)\r\n    }\r\n    // Get a element at the given index\r\n  , get: function(i) {\r\n      return SVG.adopt(this.node.childNodes[i])\r\n    }\r\n    // Get first child\r\n  , first: function() {\r\n      return this.get(0)\r\n    }\r\n    // Get the last child\r\n  , last: function() {\r\n      return this.get(this.node.childNodes.length - 1)\r\n    }\r\n    // Iterates over all children and invokes a given block\r\n  , each: function(block, deep) {\r\n      var i, il\r\n        , children = this.children()\r\n\r\n      for (i = 0, il = children.length; i < il; i++) {\r\n        if (children[i] instanceof SVG.Element)\r\n          block.apply(children[i], [i, children])\r\n\r\n        if (deep && (children[i] instanceof SVG.Container))\r\n          children[i].each(block, deep)\r\n      }\r\n\r\n      return this\r\n    }\r\n    // Remove a given child\r\n  , removeElement: function(element) {\r\n      this.node.removeChild(element.node)\r\n\r\n      return this\r\n    }\r\n    // Remove all elements in this container\r\n  , clear: function() {\r\n      // remove children\r\n      while(this.node.hasChildNodes())\r\n        this.node.removeChild(this.node.lastChild)\r\n\r\n      // remove defs reference\r\n      delete this._defs\r\n\r\n      return this\r\n    }\r\n  , // Get defs\r\n    defs: function() {\r\n      return this.doc().defs()\r\n    }\r\n  }\r\n\r\n})\r\n\nSVG.extend(SVG.Parent, {\r\n\r\n  ungroup: function(parent, depth) {\r\n    if(depth === 0 || this instanceof SVG.Defs) return this\r\n\r\n    parent = parent || (this instanceof SVG.Doc ? this : this.parent(SVG.Parent))\r\n    depth = depth || Infinity\r\n\r\n    this.each(function(){\r\n      if(this instanceof SVG.Defs) return this\r\n      if(this instanceof SVG.Parent) return this.ungroup(parent, depth-1)\r\n      return this.toParent(parent)\r\n    })\r\n\r\n    this.node.firstChild || this.remove()\r\n\r\n    return this\r\n  },\r\n\r\n  flatten: function(parent, depth) {\r\n    return this.ungroup(parent, depth)\r\n  }\r\n\r\n})\nSVG.Container = SVG.invent({\r\n  // Initialize node\r\n  create: function(element) {\r\n    this.constructor.call(this, element)\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Parent\r\n\r\n})\n\r\nSVG.ViewBox = SVG.invent({\r\n\r\n  create: function(source) {\r\n    var i, base = [0, 0, 0, 0]\r\n\r\n    var x, y, width, height, box, view, we, he\r\n      , wm   = 1 // width multiplier\r\n      , hm   = 1 // height multiplier\r\n      , reg  = /[+-]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:e[+-]?\\d+)?/gi\r\n\r\n    if(source instanceof SVG.Element){\r\n\r\n      we = source\r\n      he = source\r\n      view = (source.attr('viewBox') || '').match(reg)\r\n      box = source.bbox\r\n\r\n      // get dimensions of current node\r\n      width  = new SVG.Number(source.width())\r\n      height = new SVG.Number(source.height())\r\n\r\n      // find nearest non-percentual dimensions\r\n      while (width.unit == '%') {\r\n        wm *= width.value\r\n        width = new SVG.Number(we instanceof SVG.Doc ? we.parent().offsetWidth : we.parent().width())\r\n        we = we.parent()\r\n      }\r\n      while (height.unit == '%') {\r\n        hm *= height.value\r\n        height = new SVG.Number(he instanceof SVG.Doc ? he.parent().offsetHeight : he.parent().height())\r\n        he = he.parent()\r\n      }\r\n\r\n      // ensure defaults\r\n      this.x      = 0\r\n      this.y      = 0\r\n      this.width  = width  * wm\r\n      this.height = height * hm\r\n      this.zoom   = 1\r\n\r\n      if (view) {\r\n        // get width and height from viewbox\r\n        x      = parseFloat(view[0])\r\n        y      = parseFloat(view[1])\r\n        width  = parseFloat(view[2])\r\n        height = parseFloat(view[3])\r\n\r\n        // calculate zoom accoring to viewbox\r\n        this.zoom = ((this.width / this.height) > (width / height)) ?\r\n          this.height / height :\r\n          this.width  / width\r\n\r\n        // calculate real pixel dimensions on parent SVG.Doc element\r\n        this.x      = x\r\n        this.y      = y\r\n        this.width  = width\r\n        this.height = height\r\n\r\n      }\r\n\r\n    }else{\r\n\r\n      // ensure source as object\r\n      source = typeof source === 'string' ?\r\n        source.match(reg).map(function(el){ return parseFloat(el) }) :\r\n      Array.isArray(source) ?\r\n        source :\r\n      typeof source == 'object' ?\r\n        [source.x, source.y, source.width, source.height] :\r\n      arguments.length == 4 ?\r\n        [].slice.call(arguments) :\r\n        base\r\n\r\n      this.x = source[0]\r\n      this.y = source[1]\r\n      this.width = source[2]\r\n      this.height = source[3]\r\n    }\r\n\r\n\r\n  }\r\n\r\n, extend: {\r\n\r\n    toString: function() {\r\n      return this.x + ' ' + this.y + ' ' + this.width + ' ' + this.height\r\n    }\r\n  , morph: function(x, y, width, height){\r\n      this.destination = new SVG.ViewBox(x, y, width, height)\r\n      return this\r\n    }\r\n\r\n  , at: function(pos) {\r\n\r\n      if(!this.destination) return this\r\n\r\n      return new SVG.ViewBox([\r\n          this.x + (this.destination.x - this.x) * pos\r\n        , this.y + (this.destination.y - this.y) * pos\r\n        , this.width + (this.destination.width - this.width) * pos\r\n        , this.height + (this.destination.height - this.height) * pos\r\n      ])\r\n\r\n    }\r\n\r\n  }\r\n\r\n  // Define parent\r\n, parent: SVG.Container\r\n\r\n  // Add parent method\r\n, construct: {\r\n\r\n    // get/set viewbox\r\n    viewbox: function(x, y, width, height) {\r\n      if (arguments.length == 0)\r\n        // act as a getter if there are no arguments\r\n        return new SVG.ViewBox(this)\r\n\r\n      // otherwise act as a setter\r\n      return this.attr('viewBox', new SVG.ViewBox(x, y, width, height))\r\n    }\r\n\r\n  }\r\n\r\n})\n// Add events to elements\r\n;[  'click'\r\n  , 'dblclick'\r\n  , 'mousedown'\r\n  , 'mouseup'\r\n  , 'mouseover'\r\n  , 'mouseout'\r\n  , 'mousemove'\r\n  // , 'mouseenter' -> not supported by IE\r\n  // , 'mouseleave' -> not supported by IE\r\n  , 'touchstart'\r\n  , 'touchmove'\r\n  , 'touchleave'\r\n  , 'touchend'\r\n  , 'touchcancel' ].forEach(function(event) {\r\n\r\n  // add event to SVG.Element\r\n  SVG.Element.prototype[event] = function(f) {\r\n    // bind event to element rather than element node\r\n    SVG.on(this.node, event, f)\r\n    return this\r\n  }\r\n})\r\n\r\n// Initialize listeners stack\r\nSVG.listeners = []\r\nSVG.handlerMap = []\r\nSVG.listenerId = 0\r\n\r\n// Add event binder in the SVG namespace\r\nSVG.on = function(node, event, listener, binding) {\r\n  // create listener, get object-index\r\n  var l     = listener.bind(binding || node.instance || node)\r\n    , index = (SVG.handlerMap.indexOf(node) + 1 || SVG.handlerMap.push(node)) - 1\r\n    , ev    = event.split('.')[0]\r\n    , ns    = event.split('.')[1] || '*'\r\n\r\n\r\n  // ensure valid object\r\n  SVG.listeners[index]         = SVG.listeners[index]         || {}\r\n  SVG.listeners[index][ev]     = SVG.listeners[index][ev]     || {}\r\n  SVG.listeners[index][ev][ns] = SVG.listeners[index][ev][ns] || {}\r\n\r\n  if(!listener._svgjsListenerId)\r\n    listener._svgjsListenerId = ++SVG.listenerId\r\n\r\n  // reference listener\r\n  SVG.listeners[index][ev][ns][listener._svgjsListenerId] = l\r\n\r\n  // add listener\r\n  node.addEventListener(ev, l, false)\r\n}\r\n\r\n// Add event unbinder in the SVG namespace\r\nSVG.off = function(node, event, listener) {\r\n  var index = SVG.handlerMap.indexOf(node)\r\n    , ev    = event && event.split('.')[0]\r\n    , ns    = event && event.split('.')[1]\r\n\r\n  if(index == -1) return\r\n\r\n  if (listener) {\r\n    if(typeof listener == 'function') listener = listener._svgjsListenerId\r\n    if(!listener) return\r\n\r\n    // remove listener reference\r\n    if (SVG.listeners[index][ev] && SVG.listeners[index][ev][ns || '*']) {\r\n      // remove listener\r\n      node.removeEventListener(ev, SVG.listeners[index][ev][ns || '*'][listener], false)\r\n\r\n      delete SVG.listeners[index][ev][ns || '*'][listener]\r\n    }\r\n\r\n  } else if (ns && ev) {\r\n    // remove all listeners for a namespaced event\r\n    if (SVG.listeners[index][ev] && SVG.listeners[index][ev][ns]) {\r\n      for (listener in SVG.listeners[index][ev][ns])\r\n        SVG.off(node, [ev, ns].join('.'), listener)\r\n\r\n      delete SVG.listeners[index][ev][ns]\r\n    }\r\n\r\n  } else if (ns){\r\n    // remove all listeners for a specific namespace\r\n    for(event in SVG.listeners[index]){\r\n        for(namespace in SVG.listeners[index][event]){\r\n            if(ns === namespace){\r\n                SVG.off(node, [event, ns].join('.'))\r\n            }\r\n        }\r\n    }\r\n\r\n  } else if (ev) {\r\n    // remove all listeners for the event\r\n    if (SVG.listeners[index][ev]) {\r\n      for (namespace in SVG.listeners[index][ev])\r\n        SVG.off(node, [ev, namespace].join('.'))\r\n\r\n      delete SVG.listeners[index][ev]\r\n    }\r\n\r\n  } else {\r\n    // remove all listeners on a given node\r\n    for (event in SVG.listeners[index])\r\n      SVG.off(node, event)\r\n\r\n    delete SVG.listeners[index]\r\n    delete SVG.handlerMap[index]\r\n\r\n  }\r\n}\r\n\r\n//\r\nSVG.extend(SVG.Element, {\r\n  // Bind given event to listener\r\n  on: function(event, listener, binding) {\r\n    SVG.on(this.node, event, listener, binding)\r\n\r\n    return this\r\n  }\r\n  // Unbind event from listener\r\n, off: function(event, listener) {\r\n    SVG.off(this.node, event, listener)\r\n\r\n    return this\r\n  }\r\n  // Fire given event\r\n, fire: function(event, data) {\r\n\r\n    // Dispatch event\r\n    if(event instanceof window.Event){\r\n        this.node.dispatchEvent(event)\r\n    }else{\r\n        this.node.dispatchEvent(event = new window.CustomEvent(event, {detail:data, cancelable: true}))\r\n    }\r\n\r\n    this._event = event\r\n    return this\r\n  }\r\n, event: function() {\r\n    return this._event\r\n  }\r\n})\n\r\nSVG.Defs = SVG.invent({\r\n  // Initialize node\r\n  create: 'defs'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n})\nSVG.G = SVG.invent({\r\n  // Initialize node\r\n  create: 'g'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Move over x-axis\r\n    x: function(x) {\r\n      return x == null ? this.transform('x') : this.transform({ x: x - this.x() }, true)\r\n    }\r\n    // Move over y-axis\r\n  , y: function(y) {\r\n      return y == null ? this.transform('y') : this.transform({ y: y - this.y() }, true)\r\n    }\r\n    // Move by center over x-axis\r\n  , cx: function(x) {\r\n      return x == null ? this.gbox().cx : this.x(x - this.gbox().width / 2)\r\n    }\r\n    // Move by center over y-axis\r\n  , cy: function(y) {\r\n      return y == null ? this.gbox().cy : this.y(y - this.gbox().height / 2)\r\n    }\r\n  , gbox: function() {\r\n\r\n      var bbox  = this.bbox()\r\n        , trans = this.transform()\r\n\r\n      bbox.x  += trans.x\r\n      bbox.x2 += trans.x\r\n      bbox.cx += trans.x\r\n\r\n      bbox.y  += trans.y\r\n      bbox.y2 += trans.y\r\n      bbox.cy += trans.y\r\n\r\n      return bbox\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create a group element\r\n    group: function() {\r\n      return this.put(new SVG.G)\r\n    }\r\n  }\r\n})\r\n\n// ### This module adds backward / forward functionality to elements.\r\n\r\n//\r\nSVG.extend(SVG.Element, {\r\n  // Get all siblings, including myself\r\n  siblings: function() {\r\n    return this.parent().children()\r\n  }\r\n  // Get the curent position siblings\r\n, position: function() {\r\n    return this.parent().index(this)\r\n  }\r\n  // Get the next element (will return null if there is none)\r\n, next: function() {\r\n    return this.siblings()[this.position() + 1]\r\n  }\r\n  // Get the next element (will return null if there is none)\r\n, previous: function() {\r\n    return this.siblings()[this.position() - 1]\r\n  }\r\n  // Send given element one step forward\r\n, forward: function() {\r\n    var i = this.position() + 1\r\n      , p = this.parent()\r\n\r\n    // move node one step forward\r\n    p.removeElement(this).add(this, i)\r\n\r\n    // make sure defs node is always at the top\r\n    if (p instanceof SVG.Doc)\r\n      p.node.appendChild(p.defs().node)\r\n\r\n    return this\r\n  }\r\n  // Send given element one step backward\r\n, backward: function() {\r\n    var i = this.position()\r\n\r\n    if (i > 0)\r\n      this.parent().removeElement(this).add(this, i - 1)\r\n\r\n    return this\r\n  }\r\n  // Send given element all the way to the front\r\n, front: function() {\r\n    var p = this.parent()\r\n\r\n    // Move node forward\r\n    p.node.appendChild(this.node)\r\n\r\n    // Make sure defs node is always at the top\r\n    if (p instanceof SVG.Doc)\r\n      p.node.appendChild(p.defs().node)\r\n\r\n    return this\r\n  }\r\n  // Send given element all the way to the back\r\n, back: function() {\r\n    if (this.position() > 0)\r\n      this.parent().removeElement(this).add(this, 0)\r\n\r\n    return this\r\n  }\r\n  // Inserts a given element before the targeted element\r\n, before: function(element) {\r\n    element.remove()\r\n\r\n    var i = this.position()\r\n\r\n    this.parent().add(element, i)\r\n\r\n    return this\r\n  }\r\n  // Insters a given element after the targeted element\r\n, after: function(element) {\r\n    element.remove()\r\n\r\n    var i = this.position()\r\n\r\n    this.parent().add(element, i + 1)\r\n\r\n    return this\r\n  }\r\n\r\n})\nSVG.Mask = SVG.invent({\r\n  // Initialize node\r\n  create: function() {\r\n    this.constructor.call(this, SVG.create('mask'))\r\n\r\n    // keep references to masked elements\r\n    this.targets = []\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Unmask all masked elements and remove itself\r\n    remove: function() {\r\n      // unmask all targets\r\n      for (var i = this.targets.length - 1; i >= 0; i--)\r\n        if (this.targets[i])\r\n          this.targets[i].unmask()\r\n      this.targets = []\r\n\r\n      // remove mask from parent\r\n      this.parent().removeElement(this)\r\n\r\n      return this\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create masking element\r\n    mask: function() {\r\n      return this.defs().put(new SVG.Mask)\r\n    }\r\n  }\r\n})\r\n\r\n\r\nSVG.extend(SVG.Element, {\r\n  // Distribute mask to svg element\r\n  maskWith: function(element) {\r\n    // use given mask or create a new one\r\n    this.masker = element instanceof SVG.Mask ? element : this.parent().mask().add(element)\r\n\r\n    // store reverence on self in mask\r\n    this.masker.targets.push(this)\r\n\r\n    // apply mask\r\n    return this.attr('mask', 'url(\"#' + this.masker.attr('id') + '\")')\r\n  }\r\n  // Unmask element\r\n, unmask: function() {\r\n    delete this.masker\r\n    return this.attr('mask', null)\r\n  }\r\n\r\n})\r\n\nSVG.ClipPath = SVG.invent({\r\n  // Initialize node\r\n  create: function() {\r\n    this.constructor.call(this, SVG.create('clipPath'))\r\n\r\n    // keep references to clipped elements\r\n    this.targets = []\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Unclip all clipped elements and remove itself\r\n    remove: function() {\r\n      // unclip all targets\r\n      for (var i = this.targets.length - 1; i >= 0; i--)\r\n        if (this.targets[i])\r\n          this.targets[i].unclip()\r\n      this.targets = []\r\n\r\n      // remove clipPath from parent\r\n      this.parent().removeElement(this)\r\n\r\n      return this\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create clipping element\r\n    clip: function() {\r\n      return this.defs().put(new SVG.ClipPath)\r\n    }\r\n  }\r\n})\r\n\r\n//\r\nSVG.extend(SVG.Element, {\r\n  // Distribute clipPath to svg element\r\n  clipWith: function(element) {\r\n    // use given clip or create a new one\r\n    this.clipper = element instanceof SVG.ClipPath ? element : this.parent().clip().add(element)\r\n\r\n    // store reverence on self in mask\r\n    this.clipper.targets.push(this)\r\n\r\n    // apply mask\r\n    return this.attr('clip-path', 'url(\"#' + this.clipper.attr('id') + '\")')\r\n  }\r\n  // Unclip element\r\n, unclip: function() {\r\n    delete this.clipper\r\n    return this.attr('clip-path', null)\r\n  }\r\n\r\n})\nSVG.Gradient = SVG.invent({\r\n  // Initialize node\r\n  create: function(type) {\r\n    this.constructor.call(this, SVG.create(type + 'Gradient'))\r\n\r\n    // store type\r\n    this.type = type\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Add a color stop\r\n    at: function(offset, color, opacity) {\r\n      return this.put(new SVG.Stop).update(offset, color, opacity)\r\n    }\r\n    // Update gradient\r\n  , update: function(block) {\r\n      // remove all stops\r\n      this.clear()\r\n\r\n      // invoke passed block\r\n      if (typeof block == 'function')\r\n        block.call(this, this)\r\n\r\n      return this\r\n    }\r\n    // Return the fill id\r\n  , fill: function() {\r\n      return 'url(#' + this.id() + ')'\r\n    }\r\n    // Alias string convertion to fill\r\n  , toString: function() {\r\n      return this.fill()\r\n    }\r\n    // custom attr to handle transform\r\n  , attr: function(a, b, c) {\r\n      if(a == 'transform') a = 'gradientTransform'\r\n      return SVG.Container.prototype.attr.call(this, a, b, c)\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create gradient element in defs\r\n    gradient: function(type, block) {\r\n      return this.defs().gradient(type, block)\r\n    }\r\n  }\r\n})\r\n\r\n// Add animatable methods to both gradient and fx module\r\nSVG.extend(SVG.Gradient, SVG.FX, {\r\n  // From position\r\n  from: function(x, y) {\r\n    return (this._target || this).type == 'radial' ?\r\n      this.attr({ fx: new SVG.Number(x), fy: new SVG.Number(y) }) :\r\n      this.attr({ x1: new SVG.Number(x), y1: new SVG.Number(y) })\r\n  }\r\n  // To position\r\n, to: function(x, y) {\r\n    return (this._target || this).type == 'radial' ?\r\n      this.attr({ cx: new SVG.Number(x), cy: new SVG.Number(y) }) :\r\n      this.attr({ x2: new SVG.Number(x), y2: new SVG.Number(y) })\r\n  }\r\n})\r\n\r\n// Base gradient generation\r\nSVG.extend(SVG.Defs, {\r\n  // define gradient\r\n  gradient: function(type, block) {\r\n    return this.put(new SVG.Gradient(type)).update(block)\r\n  }\r\n\r\n})\r\n\r\nSVG.Stop = SVG.invent({\r\n  // Initialize node\r\n  create: 'stop'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Element\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // add color stops\r\n    update: function(o) {\r\n      if (typeof o == 'number' || o instanceof SVG.Number) {\r\n        o = {\r\n          offset:  arguments[0]\r\n        , color:   arguments[1]\r\n        , opacity: arguments[2]\r\n        }\r\n      }\r\n\r\n      // set attributes\r\n      if (o.opacity != null) this.attr('stop-opacity', o.opacity)\r\n      if (o.color   != null) this.attr('stop-color', o.color)\r\n      if (o.offset  != null) this.attr('offset', new SVG.Number(o.offset))\r\n\r\n      return this\r\n    }\r\n  }\r\n\r\n})\r\n\nSVG.Pattern = SVG.invent({\r\n  // Initialize node\r\n  create: 'pattern'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Return the fill id\r\n    fill: function() {\r\n      return 'url(#' + this.id() + ')'\r\n    }\r\n    // Update pattern by rebuilding\r\n  , update: function(block) {\r\n      // remove content\r\n      this.clear()\r\n\r\n      // invoke passed block\r\n      if (typeof block == 'function')\r\n        block.call(this, this)\r\n\r\n      return this\r\n    }\r\n    // Alias string convertion to fill\r\n  , toString: function() {\r\n      return this.fill()\r\n    }\r\n    // custom attr to handle transform\r\n  , attr: function(a, b, c) {\r\n      if(a == 'transform') a = 'patternTransform'\r\n      return SVG.Container.prototype.attr.call(this, a, b, c)\r\n    }\r\n\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create pattern element in defs\r\n    pattern: function(width, height, block) {\r\n      return this.defs().pattern(width, height, block)\r\n    }\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.Defs, {\r\n  // Define gradient\r\n  pattern: function(width, height, block) {\r\n    return this.put(new SVG.Pattern).update(block).attr({\r\n      x:            0\r\n    , y:            0\r\n    , width:        width\r\n    , height:       height\r\n    , patternUnits: 'userSpaceOnUse'\r\n    })\r\n  }\r\n\r\n})\nSVG.Doc = SVG.invent({\r\n  // Initialize node\r\n  create: function(element) {\r\n    if (element) {\r\n      // ensure the presence of a dom element\r\n      element = typeof element == 'string' ?\r\n        document.getElementById(element) :\r\n        element\r\n\r\n      // If the target is an svg element, use that element as the main wrapper.\r\n      // This allows svg.js to work with svg documents as well.\r\n      if (element.nodeName == 'svg') {\r\n        this.constructor.call(this, element)\r\n      } else {\r\n        this.constructor.call(this, SVG.create('svg'))\r\n        element.appendChild(this.node)\r\n        this.size('100%', '100%')\r\n      }\r\n\r\n      // set svg element attributes and ensure defs node\r\n      this.namespace().defs()\r\n    }\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Add namespaces\r\n    namespace: function() {\r\n      return this\r\n        .attr({ xmlns: SVG.ns, version: '1.1' })\r\n        .attr('xmlns:xlink', SVG.xlink, SVG.xmlns)\r\n        .attr('xmlns:svgjs', SVG.svgjs, SVG.xmlns)\r\n    }\r\n    // Creates and returns defs element\r\n  , defs: function() {\r\n      if (!this._defs) {\r\n        var defs\r\n\r\n        // Find or create a defs element in this instance\r\n        if (defs = this.node.getElementsByTagName('defs')[0])\r\n          this._defs = SVG.adopt(defs)\r\n        else\r\n          this._defs = new SVG.Defs\r\n\r\n        // Make sure the defs node is at the end of the stack\r\n        this.node.appendChild(this._defs.node)\r\n      }\r\n\r\n      return this._defs\r\n    }\r\n    // custom parent method\r\n  , parent: function() {\r\n      return this.node.parentNode.nodeName == '#document' ? null : this.node.parentNode\r\n    }\r\n    // Fix for possible sub-pixel offset. See:\r\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=608812\r\n  , spof: function(spof) {\r\n      var pos = this.node.getScreenCTM()\r\n\r\n      if (pos)\r\n        this\r\n          .style('left', (-pos.e % 1) + 'px')\r\n          .style('top',  (-pos.f % 1) + 'px')\r\n\r\n      return this\r\n    }\r\n\r\n      // Removes the doc from the DOM\r\n  , remove: function() {\r\n      if(this.parent()) {\r\n        this.parent().removeChild(this.node);\r\n      }\r\n\r\n      return this;\r\n    }\r\n  }\r\n\r\n})\r\n\nSVG.Shape = SVG.invent({\r\n  // Initialize node\r\n  create: function(element) {\r\n    this.constructor.call(this, element)\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Element\r\n\r\n})\n\r\nSVG.Bare = SVG.invent({\r\n  // Initialize\r\n  create: function(element, inherit) {\r\n    // construct element\r\n    this.constructor.call(this, SVG.create(element))\r\n\r\n    // inherit custom methods\r\n    if (inherit)\r\n      for (var method in inherit.prototype)\r\n        if (typeof inherit.prototype[method] === 'function')\r\n          this[method] = inherit.prototype[method]\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Element\r\n\r\n  // Add methods\r\n, extend: {\r\n    // Insert some plain text\r\n    words: function(text) {\r\n      // remove contents\r\n      while (this.node.hasChildNodes())\r\n        this.node.removeChild(this.node.lastChild)\r\n\r\n      // create text node\r\n      this.node.appendChild(document.createTextNode(text))\r\n\r\n      return this\r\n    }\r\n  }\r\n})\r\n\r\n\r\nSVG.extend(SVG.Parent, {\r\n  // Create an element that is not described by SVG.js\r\n  element: function(element, inherit) {\r\n    return this.put(new SVG.Bare(element, inherit))\r\n  }\r\n})\r\n\nSVG.Symbol = SVG.invent({\r\n  // Initialize node\r\n  create: 'symbol'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n, construct: {\r\n    // create symbol\r\n    symbol: function() {\r\n      return this.put(new SVG.Symbol)\r\n    }\r\n  }\r\n})\r\n\nSVG.Use = SVG.invent({\r\n  // Initialize node\r\n  create: 'use'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Use element as a reference\r\n    element: function(element, file) {\r\n      // Set lined element\r\n      return this.attr('href', (file || '') + '#' + element, SVG.xlink)\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create a use element\r\n    use: function(element, file) {\r\n      return this.put(new SVG.Use).element(element, file)\r\n    }\r\n  }\r\n})\nSVG.Rect = SVG.invent({\r\n  // Initialize node\r\n  create: 'rect'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create a rect element\r\n    rect: function(width, height) {\r\n      return this.put(new SVG.Rect()).size(width, height)\r\n    }\r\n  }\r\n})\nSVG.Circle = SVG.invent({\r\n  // Initialize node\r\n  create: 'circle'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create circle element, based on ellipse\r\n    circle: function(size) {\r\n      return this.put(new SVG.Circle).rx(new SVG.Number(size).divide(2)).move(0, 0)\r\n    }\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.Circle, SVG.FX, {\r\n  // Radius x value\r\n  rx: function(rx) {\r\n    return this.attr('r', rx)\r\n  }\r\n  // Alias radius x value\r\n, ry: function(ry) {\r\n    return this.rx(ry)\r\n  }\r\n})\r\n\r\nSVG.Ellipse = SVG.invent({\r\n  // Initialize node\r\n  create: 'ellipse'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create an ellipse\r\n    ellipse: function(width, height) {\r\n      return this.put(new SVG.Ellipse).size(width, height).move(0, 0)\r\n    }\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.Ellipse, SVG.Rect, SVG.FX, {\r\n  // Radius x value\r\n  rx: function(rx) {\r\n    return this.attr('rx', rx)\r\n  }\r\n  // Radius y value\r\n, ry: function(ry) {\r\n    return this.attr('ry', ry)\r\n  }\r\n})\r\n\r\n// Add common method\r\nSVG.extend(SVG.Circle, SVG.Ellipse, {\r\n    // Move over x-axis\r\n    x: function(x) {\r\n      return x == null ? this.cx() - this.rx() : this.cx(x + this.rx())\r\n    }\r\n    // Move over y-axis\r\n  , y: function(y) {\r\n      return y == null ? this.cy() - this.ry() : this.cy(y + this.ry())\r\n    }\r\n    // Move by center over x-axis\r\n  , cx: function(x) {\r\n      return x == null ? this.attr('cx') : this.attr('cx', x)\r\n    }\r\n    // Move by center over y-axis\r\n  , cy: function(y) {\r\n      return y == null ? this.attr('cy') : this.attr('cy', y)\r\n    }\r\n    // Set width of element\r\n  , width: function(width) {\r\n      return width == null ? this.rx() * 2 : this.rx(new SVG.Number(width).divide(2))\r\n    }\r\n    // Set height of element\r\n  , height: function(height) {\r\n      return height == null ? this.ry() * 2 : this.ry(new SVG.Number(height).divide(2))\r\n    }\r\n    // Custom size function\r\n  , size: function(width, height) {\r\n      var p = proportionalSize(this, width, height)\r\n\r\n      return this\r\n        .rx(new SVG.Number(p.width).divide(2))\r\n        .ry(new SVG.Number(p.height).divide(2))\r\n    }\r\n})\nSVG.Line = SVG.invent({\r\n  // Initialize node\r\n  create: 'line'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Get array\r\n    array: function() {\r\n      return new SVG.PointArray([\r\n        [ this.attr('x1'), this.attr('y1') ]\r\n      , [ this.attr('x2'), this.attr('y2') ]\r\n      ])\r\n    }\r\n    // Overwrite native plot() method\r\n  , plot: function(x1, y1, x2, y2) {\r\n      if (x1 == null)\r\n        return this.array()\r\n      else if (typeof y1 !== 'undefined')\r\n        x1 = { x1: x1, y1: y1, x2: x2, y2: y2 }\r\n      else\r\n        x1 = new SVG.PointArray(x1).toLine()\r\n\r\n      return this.attr(x1)\r\n    }\r\n    // Move by left top corner\r\n  , move: function(x, y) {\r\n      return this.attr(this.array().move(x, y).toLine())\r\n    }\r\n    // Set element size to given width and height\r\n  , size: function(width, height) {\r\n      var p = proportionalSize(this, width, height)\r\n\r\n      return this.attr(this.array().size(p.width, p.height).toLine())\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create a line element\r\n    line: function(x1, y1, x2, y2) {\r\n      // make sure plot is called as a setter\r\n      // x1 is not necessarily a number, it can also be an array, a string and a SVG.PointArray\r\n      return SVG.Line.prototype.plot.apply(\r\n        this.put(new SVG.Line)\r\n      , x1 != null ? [x1, y1, x2, y2] : [0, 0, 0, 0]\r\n      )\r\n    }\r\n  }\r\n})\r\n\nSVG.Polyline = SVG.invent({\r\n  // Initialize node\r\n  create: 'polyline'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create a wrapped polyline element\r\n    polyline: function(p) {\r\n      // make sure plot is called as a setter\r\n      return this.put(new SVG.Polyline).plot(p || new SVG.PointArray)\r\n    }\r\n  }\r\n})\r\n\r\nSVG.Polygon = SVG.invent({\r\n  // Initialize node\r\n  create: 'polygon'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create a wrapped polygon element\r\n    polygon: function(p) {\r\n      // make sure plot is called as a setter\r\n      return this.put(new SVG.Polygon).plot(p || new SVG.PointArray)\r\n    }\r\n  }\r\n})\r\n\r\n// Add polygon-specific functions\r\nSVG.extend(SVG.Polyline, SVG.Polygon, {\r\n  // Get array\r\n  array: function() {\r\n    return this._array || (this._array = new SVG.PointArray(this.attr('points')))\r\n  }\r\n  // Plot new path\r\n, plot: function(p) {\r\n    return (p == null) ?\r\n      this.array() :\r\n      this.clear().attr('points', typeof p == 'string' ? p : (this._array = new SVG.PointArray(p)))\r\n  }\r\n  // Clear array cache\r\n, clear: function() {\r\n    delete this._array\r\n    return this\r\n  }\r\n  // Move by left top corner\r\n, move: function(x, y) {\r\n    return this.attr('points', this.array().move(x, y))\r\n  }\r\n  // Set element size to given width and height\r\n, size: function(width, height) {\r\n    var p = proportionalSize(this, width, height)\r\n\r\n    return this.attr('points', this.array().size(p.width, p.height))\r\n  }\r\n\r\n})\r\n\n// unify all point to point elements\r\nSVG.extend(SVG.Line, SVG.Polyline, SVG.Polygon, {\r\n  // Define morphable array\r\n  morphArray:  SVG.PointArray\r\n  // Move by left top corner over x-axis\r\n, x: function(x) {\r\n    return x == null ? this.bbox().x : this.move(x, this.bbox().y)\r\n  }\r\n  // Move by left top corner over y-axis\r\n, y: function(y) {\r\n    return y == null ? this.bbox().y : this.move(this.bbox().x, y)\r\n  }\r\n  // Set width of element\r\n, width: function(width) {\r\n    var b = this.bbox()\r\n\r\n    return width == null ? b.width : this.size(width, b.height)\r\n  }\r\n  // Set height of element\r\n, height: function(height) {\r\n    var b = this.bbox()\r\n\r\n    return height == null ? b.height : this.size(b.width, height)\r\n  }\r\n})\nSVG.Path = SVG.invent({\r\n  // Initialize node\r\n  create: 'path'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Define morphable array\r\n    morphArray:  SVG.PathArray\r\n    // Get array\r\n  , array: function() {\r\n      return this._array || (this._array = new SVG.PathArray(this.attr('d')))\r\n    }\r\n    // Plot new path\r\n  , plot: function(d) {\r\n      return (d == null) ?\r\n        this.array() :\r\n        this.clear().attr('d', typeof d == 'string' ? d : (this._array = new SVG.PathArray(d)))\r\n    }\r\n    // Clear array cache\r\n  , clear: function() {\r\n      delete this._array\r\n      return this\r\n    }\r\n    // Move by left top corner\r\n  , move: function(x, y) {\r\n      return this.attr('d', this.array().move(x, y))\r\n    }\r\n    // Move by left top corner over x-axis\r\n  , x: function(x) {\r\n      return x == null ? this.bbox().x : this.move(x, this.bbox().y)\r\n    }\r\n    // Move by left top corner over y-axis\r\n  , y: function(y) {\r\n      return y == null ? this.bbox().y : this.move(this.bbox().x, y)\r\n    }\r\n    // Set element size to given width and height\r\n  , size: function(width, height) {\r\n      var p = proportionalSize(this, width, height)\r\n\r\n      return this.attr('d', this.array().size(p.width, p.height))\r\n    }\r\n    // Set width of element\r\n  , width: function(width) {\r\n      return width == null ? this.bbox().width : this.size(width, this.bbox().height)\r\n    }\r\n    // Set height of element\r\n  , height: function(height) {\r\n      return height == null ? this.bbox().height : this.size(this.bbox().width, height)\r\n    }\r\n\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create a wrapped path element\r\n    path: function(d) {\r\n      // make sure plot is called as a setter\r\n      return this.put(new SVG.Path).plot(d || new SVG.PathArray)\r\n    }\r\n  }\r\n})\r\n\nSVG.Image = SVG.invent({\r\n  // Initialize node\r\n  create: 'image'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // (re)load image\r\n    load: function(url) {\r\n      if (!url) return this\r\n\r\n      var self = this\r\n        , img  = new window.Image()\r\n\r\n      // preload image\r\n      SVG.on(img, 'load', function() {\r\n        var p = self.parent(SVG.Pattern)\r\n\r\n        if(p === null) return\r\n\r\n        // ensure image size\r\n        if (self.width() == 0 && self.height() == 0)\r\n          self.size(img.width, img.height)\r\n\r\n        // ensure pattern size if not set\r\n        if (p && p.width() == 0 && p.height() == 0)\r\n          p.size(self.width(), self.height())\r\n\r\n        // callback\r\n        if (typeof self._loaded === 'function')\r\n          self._loaded.call(self, {\r\n            width:  img.width\r\n          , height: img.height\r\n          , ratio:  img.width / img.height\r\n          , url:    url\r\n          })\r\n      })\r\n\r\n      SVG.on(img, 'error', function(e){\r\n        if (typeof self._error === 'function'){\r\n            self._error.call(self, e)\r\n        }\r\n      })\r\n\r\n      return this.attr('href', (img.src = this.src = url), SVG.xlink)\r\n    }\r\n    // Add loaded callback\r\n  , loaded: function(loaded) {\r\n      this._loaded = loaded\r\n      return this\r\n    }\r\n\r\n  , error: function(error) {\r\n      this._error = error\r\n      return this\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // create image element, load image and set its size\r\n    image: function(source, width, height) {\r\n      return this.put(new SVG.Image).load(source).size(width || 0, height || width || 0)\r\n    }\r\n  }\r\n\r\n})\nSVG.Text = SVG.invent({\r\n  // Initialize node\r\n  create: function() {\r\n    this.constructor.call(this, SVG.create('text'))\r\n\r\n    this.dom.leading = new SVG.Number(1.3)    // store leading value for rebuilding\r\n    this._rebuild = true                      // enable automatic updating of dy values\r\n    this._build   = false                     // disable build mode for adding multiple lines\r\n\r\n    // set default font\r\n    this.attr('font-family', SVG.defaults.attrs['font-family'])\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Move over x-axis\r\n    x: function(x) {\r\n      // act as getter\r\n      if (x == null)\r\n        return this.attr('x')\r\n\r\n      return this.attr('x', x)\r\n    }\r\n    // Move over y-axis\r\n  , y: function(y) {\r\n      var oy = this.attr('y')\r\n        , o  = typeof oy === 'number' ? oy - this.bbox().y : 0\r\n\r\n      // act as getter\r\n      if (y == null)\r\n        return typeof oy === 'number' ? oy - o : oy\r\n\r\n      return this.attr('y', typeof y === 'number' ? y + o : y)\r\n    }\r\n    // Move center over x-axis\r\n  , cx: function(x) {\r\n      return x == null ? this.bbox().cx : this.x(x - this.bbox().width / 2)\r\n    }\r\n    // Move center over y-axis\r\n  , cy: function(y) {\r\n      return y == null ? this.bbox().cy : this.y(y - this.bbox().height / 2)\r\n    }\r\n    // Set the text content\r\n  , text: function(text) {\r\n      // act as getter\r\n      if (typeof text === 'undefined'){\r\n        var text = ''\r\n        var children = this.node.childNodes\r\n        for(var i = 0, len = children.length; i < len; ++i){\r\n\r\n          // add newline if its not the first child and newLined is set to true\r\n          if(i != 0 && children[i].nodeType != 3 && SVG.adopt(children[i]).dom.newLined == true){\r\n            text += '\\n'\r\n          }\r\n\r\n          // add content of this node\r\n          text += children[i].textContent\r\n        }\r\n\r\n        return text\r\n      }\r\n\r\n      // remove existing content\r\n      this.clear().build(true)\r\n\r\n      if (typeof text === 'function') {\r\n        // call block\r\n        text.call(this, this)\r\n\r\n      } else {\r\n        // store text and make sure text is not blank\r\n        text = text.split('\\n')\r\n\r\n        // build new lines\r\n        for (var i = 0, il = text.length; i < il; i++)\r\n          this.tspan(text[i]).newLine()\r\n      }\r\n\r\n      // disable build mode and rebuild lines\r\n      return this.build(false).rebuild()\r\n    }\r\n    // Set font size\r\n  , size: function(size) {\r\n      return this.attr('font-size', size).rebuild()\r\n    }\r\n    // Set / get leading\r\n  , leading: function(value) {\r\n      // act as getter\r\n      if (value == null)\r\n        return this.dom.leading\r\n\r\n      // act as setter\r\n      this.dom.leading = new SVG.Number(value)\r\n\r\n      return this.rebuild()\r\n    }\r\n    // Get all the first level lines\r\n  , lines: function() {\r\n      var node = (this.textPath && this.textPath() || this).node\r\n\r\n      // filter tspans and map them to SVG.js instances\r\n      var lines = SVG.utils.map(SVG.utils.filterSVGElements(node.childNodes), function(el){\r\n        return SVG.adopt(el)\r\n      })\r\n\r\n      // return an instance of SVG.set\r\n      return new SVG.Set(lines)\r\n    }\r\n    // Rebuild appearance type\r\n  , rebuild: function(rebuild) {\r\n      // store new rebuild flag if given\r\n      if (typeof rebuild == 'boolean')\r\n        this._rebuild = rebuild\r\n\r\n      // define position of all lines\r\n      if (this._rebuild) {\r\n        var self = this\r\n          , blankLineOffset = 0\r\n          , dy = this.dom.leading * new SVG.Number(this.attr('font-size'))\r\n\r\n        this.lines().each(function() {\r\n          if (this.dom.newLined) {\r\n            if (!self.textPath())\r\n              this.attr('x', self.attr('x'))\r\n            if(this.text() == '\\n') {\r\n              blankLineOffset += dy\r\n            }else{\r\n              this.attr('dy', dy + blankLineOffset)\r\n              blankLineOffset = 0\r\n            }\r\n          }\r\n        })\r\n\r\n        this.fire('rebuild')\r\n      }\r\n\r\n      return this\r\n    }\r\n    // Enable / disable build mode\r\n  , build: function(build) {\r\n      this._build = !!build\r\n      return this\r\n    }\r\n    // overwrite method from parent to set data properly\r\n  , setData: function(o){\r\n      this.dom = o\r\n      this.dom.leading = new SVG.Number(o.leading || 1.3)\r\n      return this\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create text element\r\n    text: function(text) {\r\n      return this.put(new SVG.Text).text(text)\r\n    }\r\n    // Create plain text element\r\n  , plain: function(text) {\r\n      return this.put(new SVG.Text).plain(text)\r\n    }\r\n  }\r\n\r\n})\r\n\r\nSVG.Tspan = SVG.invent({\r\n  // Initialize node\r\n  create: 'tspan'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Shape\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Set text content\r\n    text: function(text) {\r\n      if(text == null) return this.node.textContent + (this.dom.newLined ? '\\n' : '')\r\n\r\n      typeof text === 'function' ? text.call(this, this) : this.plain(text)\r\n\r\n      return this\r\n    }\r\n    // Shortcut dx\r\n  , dx: function(dx) {\r\n      return this.attr('dx', dx)\r\n    }\r\n    // Shortcut dy\r\n  , dy: function(dy) {\r\n      return this.attr('dy', dy)\r\n    }\r\n    // Create new line\r\n  , newLine: function() {\r\n      // fetch text parent\r\n      var t = this.parent(SVG.Text)\r\n\r\n      // mark new line\r\n      this.dom.newLined = true\r\n\r\n      // apply new hyn\r\n      return this.dy(t.dom.leading * t.attr('font-size')).attr('x', t.x())\r\n    }\r\n  }\r\n\r\n})\r\n\r\nSVG.extend(SVG.Text, SVG.Tspan, {\r\n  // Create plain text node\r\n  plain: function(text) {\r\n    // clear if build mode is disabled\r\n    if (this._build === false)\r\n      this.clear()\r\n\r\n    // create text node\r\n    this.node.appendChild(document.createTextNode(text))\r\n\r\n    return this\r\n  }\r\n  // Create a tspan\r\n, tspan: function(text) {\r\n    var node  = (this.textPath && this.textPath() || this).node\r\n      , tspan = new SVG.Tspan\r\n\r\n    // clear if build mode is disabled\r\n    if (this._build === false)\r\n      this.clear()\r\n\r\n    // add new tspan\r\n    node.appendChild(tspan.node)\r\n\r\n    return tspan.text(text)\r\n  }\r\n  // Clear all lines\r\n, clear: function() {\r\n    var node = (this.textPath && this.textPath() || this).node\r\n\r\n    // remove existing child nodes\r\n    while (node.hasChildNodes())\r\n      node.removeChild(node.lastChild)\r\n\r\n    return this\r\n  }\r\n  // Get length of text element\r\n, length: function() {\r\n    return this.node.getComputedTextLength()\r\n  }\r\n})\r\n\nSVG.TextPath = SVG.invent({\r\n  // Initialize node\r\n  create: 'textPath'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Parent\r\n\r\n  // Define parent class\r\n, parent: SVG.Text\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create path for text to run on\r\n    path: function(d) {\r\n      // create textPath element\r\n      var path  = new SVG.TextPath\r\n        , track = this.doc().defs().path(d)\r\n\r\n      // move lines to textpath\r\n      while (this.node.hasChildNodes())\r\n        path.node.appendChild(this.node.firstChild)\r\n\r\n      // add textPath element as child node\r\n      this.node.appendChild(path.node)\r\n\r\n      // link textPath to path and add content\r\n      path.attr('href', '#' + track, SVG.xlink)\r\n\r\n      return this\r\n    }\r\n    // return the array of the path track element\r\n  , array: function() {\r\n      var track = this.track()\r\n\r\n      return track ? track.array() : null\r\n    }\r\n    // Plot path if any\r\n  , plot: function(d) {\r\n      var track = this.track()\r\n        , pathArray = null\r\n\r\n      if (track) {\r\n        pathArray = track.plot(d)\r\n      }\r\n\r\n      return (d == null) ? pathArray : this\r\n    }\r\n    // Get the path track element\r\n  , track: function() {\r\n      var path = this.textPath()\r\n\r\n      if (path)\r\n        return path.reference('href')\r\n    }\r\n    // Get the textPath child\r\n  , textPath: function() {\r\n      if (this.node.firstChild && this.node.firstChild.nodeName == 'textPath')\r\n        return SVG.adopt(this.node.firstChild)\r\n    }\r\n  }\r\n})\r\n\nSVG.Nested = SVG.invent({\r\n  // Initialize node\r\n  create: function() {\r\n    this.constructor.call(this, SVG.create('svg'))\r\n\r\n    this.style('overflow', 'visible')\r\n  }\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create nested svg document\r\n    nested: function() {\r\n      return this.put(new SVG.Nested)\r\n    }\r\n  }\r\n})\nSVG.A = SVG.invent({\r\n  // Initialize node\r\n  create: 'a'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Link url\r\n    to: function(url) {\r\n      return this.attr('href', url, SVG.xlink)\r\n    }\r\n    // Link show attribute\r\n  , show: function(target) {\r\n      return this.attr('show', target, SVG.xlink)\r\n    }\r\n    // Link target attribute\r\n  , target: function(target) {\r\n      return this.attr('target', target)\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create a hyperlink element\r\n    link: function(url) {\r\n      return this.put(new SVG.A).to(url)\r\n    }\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.Element, {\r\n  // Create a hyperlink element\r\n  linkTo: function(url) {\r\n    var link = new SVG.A\r\n\r\n    if (typeof url == 'function')\r\n      url.call(link, link)\r\n    else\r\n      link.to(url)\r\n\r\n    return this.parent().put(link).put(this)\r\n  }\r\n\r\n})\nSVG.Marker = SVG.invent({\r\n  // Initialize node\r\n  create: 'marker'\r\n\r\n  // Inherit from\r\n, inherit: SVG.Container\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Set width of element\r\n    width: function(width) {\r\n      return this.attr('markerWidth', width)\r\n    }\r\n    // Set height of element\r\n  , height: function(height) {\r\n      return this.attr('markerHeight', height)\r\n    }\r\n    // Set marker refX and refY\r\n  , ref: function(x, y) {\r\n      return this.attr('refX', x).attr('refY', y)\r\n    }\r\n    // Update marker\r\n  , update: function(block) {\r\n      // remove all content\r\n      this.clear()\r\n\r\n      // invoke passed block\r\n      if (typeof block == 'function')\r\n        block.call(this, this)\r\n\r\n      return this\r\n    }\r\n    // Return the fill id\r\n  , toString: function() {\r\n      return 'url(#' + this.id() + ')'\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    marker: function(width, height, block) {\r\n      // Create marker element in defs\r\n      return this.defs().marker(width, height, block)\r\n    }\r\n  }\r\n\r\n})\r\n\r\nSVG.extend(SVG.Defs, {\r\n  // Create marker\r\n  marker: function(width, height, block) {\r\n    // Set default viewbox to match the width and height, set ref to cx and cy and set orient to auto\r\n    return this.put(new SVG.Marker)\r\n      .size(width, height)\r\n      .ref(width / 2, height / 2)\r\n      .viewbox(0, 0, width, height)\r\n      .attr('orient', 'auto')\r\n      .update(block)\r\n  }\r\n\r\n})\r\n\r\nSVG.extend(SVG.Line, SVG.Polyline, SVG.Polygon, SVG.Path, {\r\n  // Create and attach markers\r\n  marker: function(marker, width, height, block) {\r\n    var attr = ['marker']\r\n\r\n    // Build attribute name\r\n    if (marker != 'all') attr.push(marker)\r\n    attr = attr.join('-')\r\n\r\n    // Set marker attribute\r\n    marker = arguments[1] instanceof SVG.Marker ?\r\n      arguments[1] :\r\n      this.doc().marker(width, height, block)\r\n\r\n    return this.attr(attr, marker)\r\n  }\r\n\r\n})\n// Define list of available attributes for stroke and fill\r\nvar sugar = {\r\n  stroke: ['color', 'width', 'opacity', 'linecap', 'linejoin', 'miterlimit', 'dasharray', 'dashoffset']\r\n, fill:   ['color', 'opacity', 'rule']\r\n, prefix: function(t, a) {\r\n    return a == 'color' ? t : t + '-' + a\r\n  }\r\n}\r\n\r\n// Add sugar for fill and stroke\r\n;['fill', 'stroke'].forEach(function(m) {\r\n  var i, extension = {}\r\n\r\n  extension[m] = function(o) {\r\n    if (typeof o == 'undefined')\r\n      return this\r\n    if (typeof o == 'string' || SVG.Color.isRgb(o) || (o && typeof o.fill === 'function'))\r\n      this.attr(m, o)\r\n\r\n    else\r\n      // set all attributes from sugar.fill and sugar.stroke list\r\n      for (i = sugar[m].length - 1; i >= 0; i--)\r\n        if (o[sugar[m][i]] != null)\r\n          this.attr(sugar.prefix(m, sugar[m][i]), o[sugar[m][i]])\r\n\r\n    return this\r\n  }\r\n\r\n  SVG.extend(SVG.Element, SVG.FX, extension)\r\n\r\n})\r\n\r\nSVG.extend(SVG.Element, SVG.FX, {\r\n  // Map rotation to transform\r\n  rotate: function(d, cx, cy) {\r\n    return this.transform({ rotation: d, cx: cx, cy: cy })\r\n  }\r\n  // Map skew to transform\r\n, skew: function(x, y, cx, cy) {\r\n    return arguments.length == 1  || arguments.length == 3 ?\r\n      this.transform({ skew: x, cx: y, cy: cx }) :\r\n      this.transform({ skewX: x, skewY: y, cx: cx, cy: cy })\r\n  }\r\n  // Map scale to transform\r\n, scale: function(x, y, cx, cy) {\r\n    return arguments.length == 1  || arguments.length == 3 ?\r\n      this.transform({ scale: x, cx: y, cy: cx }) :\r\n      this.transform({ scaleX: x, scaleY: y, cx: cx, cy: cy })\r\n  }\r\n  // Map translate to transform\r\n, translate: function(x, y) {\r\n    return this.transform({ x: x, y: y })\r\n  }\r\n  // Map flip to transform\r\n, flip: function(a, o) {\r\n    o = typeof a == 'number' ? a : o\r\n    return this.transform({ flip: a || 'both', offset: o })\r\n  }\r\n  // Map matrix to transform\r\n, matrix: function(m) {\r\n    return this.attr('transform', new SVG.Matrix(arguments.length == 6 ? [].slice.call(arguments) : m))\r\n  }\r\n  // Opacity\r\n, opacity: function(value) {\r\n    return this.attr('opacity', value)\r\n  }\r\n  // Relative move over x axis\r\n, dx: function(x) {\r\n    return this.x(new SVG.Number(x).plus(this instanceof SVG.FX ? 0 : this.x()), true)\r\n  }\r\n  // Relative move over y axis\r\n, dy: function(y) {\r\n    return this.y(new SVG.Number(y).plus(this instanceof SVG.FX ? 0 : this.y()), true)\r\n  }\r\n  // Relative move over x and y axes\r\n, dmove: function(x, y) {\r\n    return this.dx(x).dy(y)\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.Rect, SVG.Ellipse, SVG.Circle, SVG.Gradient, SVG.FX, {\r\n  // Add x and y radius\r\n  radius: function(x, y) {\r\n    var type = (this._target || this).type;\r\n    return type == 'radial' || type == 'circle' ?\r\n      this.attr('r', new SVG.Number(x)) :\r\n      this.rx(x).ry(y == null ? x : y)\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.Path, {\r\n  // Get path length\r\n  length: function() {\r\n    return this.node.getTotalLength()\r\n  }\r\n  // Get point at length\r\n, pointAt: function(length) {\r\n    return this.node.getPointAtLength(length)\r\n  }\r\n})\r\n\r\nSVG.extend(SVG.Parent, SVG.Text, SVG.Tspan, SVG.FX, {\r\n  // Set font\r\n  font: function(a, v) {\r\n    if (typeof a == 'object') {\r\n      for (v in a) this.font(v, a[v])\r\n    }\r\n\r\n    return a == 'leading' ?\r\n        this.leading(v) :\r\n      a == 'anchor' ?\r\n        this.attr('text-anchor', v) :\r\n      a == 'size' || a == 'family' || a == 'weight' || a == 'stretch' || a == 'variant' || a == 'style' ?\r\n        this.attr('font-'+ a, v) :\r\n        this.attr(a, v)\r\n  }\r\n})\r\n\nSVG.Set = SVG.invent({\r\n  // Initialize\r\n  create: function(members) {\r\n    // Set initial state\r\n    Array.isArray(members) ? this.members = members : this.clear()\r\n  }\r\n\r\n  // Add class methods\r\n, extend: {\r\n    // Add element to set\r\n    add: function() {\r\n      var i, il, elements = [].slice.call(arguments)\r\n\r\n      for (i = 0, il = elements.length; i < il; i++)\r\n        this.members.push(elements[i])\r\n\r\n      return this\r\n    }\r\n    // Remove element from set\r\n  , remove: function(element) {\r\n      var i = this.index(element)\r\n\r\n      // remove given child\r\n      if (i > -1)\r\n        this.members.splice(i, 1)\r\n\r\n      return this\r\n    }\r\n    // Iterate over all members\r\n  , each: function(block) {\r\n      for (var i = 0, il = this.members.length; i < il; i++)\r\n        block.apply(this.members[i], [i, this.members])\r\n\r\n      return this\r\n    }\r\n    // Restore to defaults\r\n  , clear: function() {\r\n      // initialize store\r\n      this.members = []\r\n\r\n      return this\r\n    }\r\n    // Get the length of a set\r\n  , length: function() {\r\n      return this.members.length\r\n    }\r\n    // Checks if a given element is present in set\r\n  , has: function(element) {\r\n      return this.index(element) >= 0\r\n    }\r\n    // retuns index of given element in set\r\n  , index: function(element) {\r\n      return this.members.indexOf(element)\r\n    }\r\n    // Get member at given index\r\n  , get: function(i) {\r\n      return this.members[i]\r\n    }\r\n    // Get first member\r\n  , first: function() {\r\n      return this.get(0)\r\n    }\r\n    // Get last member\r\n  , last: function() {\r\n      return this.get(this.members.length - 1)\r\n    }\r\n    // Default value\r\n  , valueOf: function() {\r\n      return this.members\r\n    }\r\n    // Get the bounding box of all members included or empty box if set has no items\r\n  , bbox: function(){\r\n      // return an empty box of there are no members\r\n      if (this.members.length == 0)\r\n        return new SVG.RBox()\r\n\r\n      // get the first rbox and update the target bbox\r\n      var rbox = this.members[0].rbox(this.members[0].doc())\r\n\r\n      this.each(function() {\r\n        // user rbox for correct position and visual representation\r\n        rbox = rbox.merge(this.rbox(this.doc()))\r\n      })\r\n\r\n      return rbox\r\n    }\r\n  }\r\n\r\n  // Add parent method\r\n, construct: {\r\n    // Create a new set\r\n    set: function(members) {\r\n      return new SVG.Set(members)\r\n    }\r\n  }\r\n})\r\n\r\nSVG.FX.Set = SVG.invent({\r\n  // Initialize node\r\n  create: function(set) {\r\n    // store reference to set\r\n    this.set = set\r\n  }\r\n\r\n})\r\n\r\n// Alias methods\r\nSVG.Set.inherit = function() {\r\n  var m\r\n    , methods = []\r\n\r\n  // gather shape methods\r\n  for(var m in SVG.Shape.prototype)\r\n    if (typeof SVG.Shape.prototype[m] == 'function' && typeof SVG.Set.prototype[m] != 'function')\r\n      methods.push(m)\r\n\r\n  // apply shape aliasses\r\n  methods.forEach(function(method) {\r\n    SVG.Set.prototype[method] = function() {\r\n      for (var i = 0, il = this.members.length; i < il; i++)\r\n        if (this.members[i] && typeof this.members[i][method] == 'function')\r\n          this.members[i][method].apply(this.members[i], arguments)\r\n\r\n      return method == 'animate' ? (this.fx || (this.fx = new SVG.FX.Set(this))) : this\r\n    }\r\n  })\r\n\r\n  // clear methods for the next round\r\n  methods = []\r\n\r\n  // gather fx methods\r\n  for(var m in SVG.FX.prototype)\r\n    if (typeof SVG.FX.prototype[m] == 'function' && typeof SVG.FX.Set.prototype[m] != 'function')\r\n      methods.push(m)\r\n\r\n  // apply fx aliasses\r\n  methods.forEach(function(method) {\r\n    SVG.FX.Set.prototype[method] = function() {\r\n      for (var i = 0, il = this.set.members.length; i < il; i++)\r\n        this.set.members[i].fx[method].apply(this.set.members[i].fx, arguments)\r\n\r\n      return this\r\n    }\r\n  })\r\n}\r\n\r\n\r\n\n\r\nSVG.extend(SVG.Element, {\r\n  // Store data values on svg nodes\r\n  data: function(a, v, r) {\r\n    if (typeof a == 'object') {\r\n      for (v in a)\r\n        this.data(v, a[v])\r\n\r\n    } else if (arguments.length < 2) {\r\n      try {\r\n        return JSON.parse(this.attr('data-' + a))\r\n      } catch(e) {\r\n        return this.attr('data-' + a)\r\n      }\r\n\r\n    } else {\r\n      this.attr(\r\n        'data-' + a\r\n      , v === null ?\r\n          null :\r\n        r === true || typeof v === 'string' || typeof v === 'number' ?\r\n          v :\r\n          JSON.stringify(v)\r\n      )\r\n    }\r\n\r\n    return this\r\n  }\r\n})\nSVG.extend(SVG.Element, {\r\n  // Remember arbitrary data\r\n  remember: function(k, v) {\r\n    // remember every item in an object individually\r\n    if (typeof arguments[0] == 'object')\r\n      for (var v in k)\r\n        this.remember(v, k[v])\r\n\r\n    // retrieve memory\r\n    else if (arguments.length == 1)\r\n      return this.memory()[k]\r\n\r\n    // store memory\r\n    else\r\n      this.memory()[k] = v\r\n\r\n    return this\r\n  }\r\n\r\n  // Erase a given memory\r\n, forget: function() {\r\n    if (arguments.length == 0)\r\n      this._memory = {}\r\n    else\r\n      for (var i = arguments.length - 1; i >= 0; i--)\r\n        delete this.memory()[arguments[i]]\r\n\r\n    return this\r\n  }\r\n\r\n  // Initialize or return local memory object\r\n, memory: function() {\r\n    return this._memory || (this._memory = {})\r\n  }\r\n\r\n})\n// Method for getting an element by id\r\nSVG.get = function(id) {\r\n  var node = document.getElementById(idFromReference(id) || id)\r\n  return SVG.adopt(node)\r\n}\r\n\r\n// Select elements by query string\r\nSVG.select = function(query, parent) {\r\n  return new SVG.Set(\r\n    SVG.utils.map((parent || document).querySelectorAll(query), function(node) {\r\n      return SVG.adopt(node)\r\n    })\r\n  )\r\n}\r\n\r\nSVG.extend(SVG.Parent, {\r\n  // Scoped select method\r\n  select: function(query) {\r\n    return SVG.select(query, this.node)\r\n  }\r\n\r\n})\nfunction pathRegReplace(a, b, c, d) {\r\n  return c + d.replace(SVG.regex.dots, ' .')\r\n}\r\n\r\n// creates deep clone of array\r\nfunction array_clone(arr){\r\n  var clone = arr.slice(0)\r\n  for(var i = clone.length; i--;){\r\n    if(Array.isArray(clone[i])){\r\n      clone[i] = array_clone(clone[i])\r\n    }\r\n  }\r\n  return clone\r\n}\r\n\r\n// tests if a given element is instance of an object\r\nfunction is(el, obj){\r\n  return el instanceof obj\r\n}\r\n\r\n// tests if a given selector matches an element\r\nfunction matches(el, selector) {\r\n  return (el.matches || el.matchesSelector || el.msMatchesSelector || el.mozMatchesSelector || el.webkitMatchesSelector || el.oMatchesSelector).call(el, selector);\r\n}\r\n\r\n// Convert dash-separated-string to camelCase\r\nfunction camelCase(s) {\r\n  return s.toLowerCase().replace(/-(.)/g, function(m, g) {\r\n    return g.toUpperCase()\r\n  })\r\n}\r\n\r\n// Capitalize first letter of a string\r\nfunction capitalize(s) {\r\n  return s.charAt(0).toUpperCase() + s.slice(1)\r\n}\r\n\r\n// Ensure to six-based hex\r\nfunction fullHex(hex) {\r\n  return hex.length == 4 ?\r\n    [ '#',\r\n      hex.substring(1, 2), hex.substring(1, 2)\r\n    , hex.substring(2, 3), hex.substring(2, 3)\r\n    , hex.substring(3, 4), hex.substring(3, 4)\r\n    ].join('') : hex\r\n}\r\n\r\n// Component to hex value\r\nfunction compToHex(comp) {\r\n  var hex = comp.toString(16)\r\n  return hex.length == 1 ? '0' + hex : hex\r\n}\r\n\r\n// Calculate proportional width and height values when necessary\r\nfunction proportionalSize(element, width, height) {\r\n  if (width == null || height == null) {\r\n    var box = element.bbox()\r\n\r\n    if (width == null)\r\n      width = box.width / box.height * height\r\n    else if (height == null)\r\n      height = box.height / box.width * width\r\n  }\r\n\r\n  return {\r\n    width:  width\r\n  , height: height\r\n  }\r\n}\r\n\r\n// Delta transform point\r\nfunction deltaTransformPoint(matrix, x, y) {\r\n  return {\r\n    x: x * matrix.a + y * matrix.c + 0\r\n  , y: x * matrix.b + y * matrix.d + 0\r\n  }\r\n}\r\n\r\n// Map matrix array to object\r\nfunction arrayToMatrix(a) {\r\n  return { a: a[0], b: a[1], c: a[2], d: a[3], e: a[4], f: a[5] }\r\n}\r\n\r\n// Parse matrix if required\r\nfunction parseMatrix(matrix) {\r\n  if (!(matrix instanceof SVG.Matrix))\r\n    matrix = new SVG.Matrix(matrix)\r\n\r\n  return matrix\r\n}\r\n\r\n// Add centre point to transform object\r\nfunction ensureCentre(o, target) {\r\n  o.cx = o.cx == null ? target.bbox().cx : o.cx\r\n  o.cy = o.cy == null ? target.bbox().cy : o.cy\r\n}\r\n\r\n// PathArray Helpers\r\nfunction arrayToString(a) {\r\n  for (var i = 0, il = a.length, s = ''; i < il; i++) {\r\n    s += a[i][0]\r\n\r\n    if (a[i][1] != null) {\r\n      s += a[i][1]\r\n\r\n      if (a[i][2] != null) {\r\n        s += ' '\r\n        s += a[i][2]\r\n\r\n        if (a[i][3] != null) {\r\n          s += ' '\r\n          s += a[i][3]\r\n          s += ' '\r\n          s += a[i][4]\r\n\r\n          if (a[i][5] != null) {\r\n            s += ' '\r\n            s += a[i][5]\r\n            s += ' '\r\n            s += a[i][6]\r\n\r\n            if (a[i][7] != null) {\r\n              s += ' '\r\n              s += a[i][7]\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return s + ' '\r\n}\r\n\r\n// Deep new id assignment\r\nfunction assignNewId(node) {\r\n  // do the same for SVG child nodes as well\r\n  for (var i = node.childNodes.length - 1; i >= 0; i--)\r\n    if (node.childNodes[i] instanceof window.SVGElement)\r\n      assignNewId(node.childNodes[i])\r\n\r\n  return SVG.adopt(node).id(SVG.eid(node.nodeName))\r\n}\r\n\r\n// Add more bounding box properties\r\nfunction fullBox(b) {\r\n  if (b.x == null) {\r\n    b.x      = 0\r\n    b.y      = 0\r\n    b.width  = 0\r\n    b.height = 0\r\n  }\r\n\r\n  b.w  = b.width\r\n  b.h  = b.height\r\n  b.x2 = b.x + b.width\r\n  b.y2 = b.y + b.height\r\n  b.cx = b.x + b.width / 2\r\n  b.cy = b.y + b.height / 2\r\n\r\n  return b\r\n}\r\n\r\n// Get id from reference string\r\nfunction idFromReference(url) {\r\n  var m = url.toString().match(SVG.regex.reference)\r\n\r\n  if (m) return m[1]\r\n}\r\n\r\n// Create matrix array for looping\r\nvar abcdef = 'abcdef'.split('')\n// Add CustomEvent to IE9 and IE10\r\nif (typeof window.CustomEvent !== 'function') {\r\n  // Code from: https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent\r\n  var CustomEvent = function(event, options) {\r\n    options = options || { bubbles: false, cancelable: false, detail: undefined }\r\n    var e = document.createEvent('CustomEvent')\r\n    e.initCustomEvent(event, options.bubbles, options.cancelable, options.detail)\r\n    return e\r\n  }\r\n\r\n  CustomEvent.prototype = window.Event.prototype\r\n\r\n  window.CustomEvent = CustomEvent\r\n}\r\n\r\n// requestAnimationFrame / cancelAnimationFrame Polyfill with fallback based on Paul Irish\r\n(function(w) {\r\n  var lastTime = 0\r\n  var vendors = ['moz', 'webkit']\r\n\r\n  for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\r\n    w.requestAnimationFrame = w[vendors[x] + 'RequestAnimationFrame']\r\n    w.cancelAnimationFrame  = w[vendors[x] + 'CancelAnimationFrame'] ||\r\n                              w[vendors[x] + 'CancelRequestAnimationFrame']\r\n  }\r\n\r\n  w.requestAnimationFrame = w.requestAnimationFrame ||\r\n    function(callback) {\r\n      var currTime = new Date().getTime()\r\n      var timeToCall = Math.max(0, 16 - (currTime - lastTime))\r\n\r\n      var id = w.setTimeout(function() {\r\n        callback(currTime + timeToCall)\r\n      }, timeToCall)\r\n\r\n      lastTime = currTime + timeToCall\r\n      return id\r\n    }\r\n\r\n  w.cancelAnimationFrame = w.cancelAnimationFrame || w.clearTimeout;\r\n\r\n}(window))\r\n\r\nreturn SVG\r\n\r\n}));//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3N2Zy5qcy9kaXN0L3N2Zy5qcz84YTkxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQUE7QUFDTCxHQUFHO0FBQ0gsZ0ZBQWdGO0FBQ2hGLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOEJBQThCLFFBQVE7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtRUFBbUU7O0FBRW5FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msa0JBQWtCLFdBQVcsVUFBVTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRTs7QUFFM0Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQyxJQUFJOztBQUVwQztBQUNBOztBQUVBO0FBQ0EsOEJBQThCLEdBQUc7O0FBRWpDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxRQUFRO0FBQ3ZCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDLHlDQUF5QztBQUN0Rjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELFFBQVE7QUFDOUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVEQUF1RCxRQUFRO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxRQUFRO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVEQUF1RCxRQUFRO0FBQy9EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxPQUFPO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQyxTQUFTO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5Q0FBeUMsUUFBUTtBQUNqRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7O0FBRUEsU0FBUztBQUNUOztBQUVBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDs7QUFFQSxPQUFPO0FBQ1A7O0FBRUEsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHNDQUFzQyx5QkFBeUI7QUFDL0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QyxRQUFRO0FBQ2hEO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7O0FBRXBCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixzQkFBc0I7QUFDdEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0RBQStELFFBQVE7QUFDdkU7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0EscUJBQXFCO0FBQ3JCLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQzs7O0FBR0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxjQUFjO0FBQ2xGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0RBQW9ELGlFQUFpRTs7QUFFckg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHdDQUF3QyxtQ0FBbUM7O0FBRTNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNkMsU0FBUzs7QUFFdEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsYUFBYTtBQUN6QztBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLElBQUk7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixJQUFJO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCLFFBQVE7QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDLFFBQVE7QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQSxPQUFPLGVBQWU7QUFDdEI7QUFDQSxPQUFPLGFBQWE7QUFDcEI7QUFDQSxPQUFPLDJCQUEyQjs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDOztBQUVBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSx5QkFBeUI7QUFDbkcsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQsU0FBUztBQUMxRDtBQUNBO0FBQ0EsS0FBSztBQUNMLGlEQUFpRCxTQUFTO0FBQzFEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxpREFBaUQsU0FBUztBQUMxRDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsaURBQWlELFNBQVM7QUFDMUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQSx5QkFBeUI7QUFDekIsZ0NBQWdDO0FBQ2hDLCtCQUErQixhQUFhO0FBQzVDLDJCQUEyQiw0QkFBNEI7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSwyQ0FBMkMsd0JBQXdCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHVFQUF1RSw4QkFBOEI7QUFDckc7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Qsa0JBQWtCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxrQkFBa0I7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsK0NBQStDO0FBQ2hFLGlCQUFpQiwrQ0FBK0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsK0NBQStDO0FBQ2hFLGlCQUFpQiwrQ0FBK0M7QUFDaEU7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdDQUFnQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxTQUFTOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QyxRQUFRO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQyxRQUFRO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw4QkFBOEI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IseUJBQXlCO0FBQy9DLHNCQUFzQixxQ0FBcUM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMEJBQTBCO0FBQ2hELHNCQUFzQix1Q0FBdUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsK0JBQStCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDLFFBQVE7QUFDL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFFBQVE7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsUUFBUTtBQUNoRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsS0FBSztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsUUFBUTtBQUNoRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLHFEQUFxRDtBQUNyRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDIiwiZmlsZSI6IjE3MC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuKiBzdmcuanMgLSBBIGxpZ2h0d2VpZ2h0IGxpYnJhcnkgZm9yIG1hbmlwdWxhdGluZyBhbmQgYW5pbWF0aW5nIFNWRy5cbiogQHZlcnNpb24gMi41LjFcbiogaHR0cHM6Ly9zdmdkb3Rqcy5naXRodWIuaW8vXG4qXG4qIEBjb3B5cmlnaHQgV291dCBGaWVyZW5zIDx3b3V0QG1pY2std291dC5jb20+XG4qIEBsaWNlbnNlIE1JVFxuKlxuKiBCVUlMVDogTW9uIE1hciAyNyAyMDE3IDEzOjMwOjM2IEdNVCswMjAwIChNaXR0ZWxldXJvcMOkaXNjaGUgU29tbWVyemVpdClcbiovO1xuKGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcclxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICBkZWZpbmUoZnVuY3Rpb24oKXtcclxuICAgICAgcmV0dXJuIGZhY3Rvcnkocm9vdCwgcm9vdC5kb2N1bWVudClcclxuICAgIH0pXHJcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gcm9vdC5kb2N1bWVudCA/IGZhY3Rvcnkocm9vdCwgcm9vdC5kb2N1bWVudCkgOiBmdW5jdGlvbih3KXsgcmV0dXJuIGZhY3Rvcnkodywgdy5kb2N1bWVudCkgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICByb290LlNWRyA9IGZhY3Rvcnkocm9vdCwgcm9vdC5kb2N1bWVudClcclxuICB9XHJcbn0odHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHRoaXMsIGZ1bmN0aW9uKHdpbmRvdywgZG9jdW1lbnQpIHtcclxuXHJcbi8vIFRoZSBtYWluIHdyYXBwaW5nIGVsZW1lbnRcclxudmFyIFNWRyA9IHRoaXMuU1ZHID0gZnVuY3Rpb24oZWxlbWVudCkge1xyXG4gIGlmIChTVkcuc3VwcG9ydGVkKSB7XHJcbiAgICBlbGVtZW50ID0gbmV3IFNWRy5Eb2MoZWxlbWVudClcclxuXHJcbiAgICBpZighU1ZHLnBhcnNlci5kcmF3KVxyXG4gICAgICBTVkcucHJlcGFyZSgpXHJcblxyXG4gICAgcmV0dXJuIGVsZW1lbnRcclxuICB9XHJcbn1cclxuXHJcbi8vIERlZmF1bHQgbmFtZXNwYWNlc1xyXG5TVkcubnMgICAgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnXHJcblNWRy54bWxucyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3htbG5zLydcclxuU1ZHLnhsaW5rID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnXHJcblNWRy5zdmdqcyA9ICdodHRwOi8vc3ZnanMuY29tL3N2Z2pzJ1xyXG5cclxuLy8gU3ZnIHN1cHBvcnQgdGVzdFxyXG5TVkcuc3VwcG9ydGVkID0gKGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiAhISBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMgJiZcclxuICAgICAgICAgISEgZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWRy5ucywnc3ZnJykuY3JlYXRlU1ZHUmVjdFxyXG59KSgpXHJcblxyXG4vLyBEb24ndCBib3RoZXIgdG8gY29udGludWUgaWYgU1ZHIGlzIG5vdCBzdXBwb3J0ZWRcclxuaWYgKCFTVkcuc3VwcG9ydGVkKSByZXR1cm4gZmFsc2VcclxuXHJcbi8vIEVsZW1lbnQgaWQgc2VxdWVuY2VcclxuU1ZHLmRpZCAgPSAxMDAwXHJcblxyXG4vLyBHZXQgbmV4dCBuYW1lZCBlbGVtZW50IGlkXHJcblNWRy5laWQgPSBmdW5jdGlvbihuYW1lKSB7XHJcbiAgcmV0dXJuICdTdmdqcycgKyBjYXBpdGFsaXplKG5hbWUpICsgKFNWRy5kaWQrKylcclxufVxyXG5cclxuLy8gTWV0aG9kIGZvciBlbGVtZW50IGNyZWF0aW9uXHJcblNWRy5jcmVhdGUgPSBmdW5jdGlvbihuYW1lKSB7XHJcbiAgLy8gY3JlYXRlIGVsZW1lbnRcclxuICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyh0aGlzLm5zLCBuYW1lKVxyXG5cclxuICAvLyBhcHBseSB1bmlxdWUgaWRcclxuICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnaWQnLCB0aGlzLmVpZChuYW1lKSlcclxuXHJcbiAgcmV0dXJuIGVsZW1lbnRcclxufVxyXG5cclxuLy8gTWV0aG9kIGZvciBleHRlbmRpbmcgb2JqZWN0c1xyXG5TVkcuZXh0ZW5kID0gZnVuY3Rpb24oKSB7XHJcbiAgdmFyIG1vZHVsZXMsIG1ldGhvZHMsIGtleSwgaVxyXG5cclxuICAvLyBHZXQgbGlzdCBvZiBtb2R1bGVzXHJcbiAgbW9kdWxlcyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKVxyXG5cclxuICAvLyBHZXQgb2JqZWN0IHdpdGggZXh0ZW5zaW9uc1xyXG4gIG1ldGhvZHMgPSBtb2R1bGVzLnBvcCgpXHJcblxyXG4gIGZvciAoaSA9IG1vZHVsZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXHJcbiAgICBpZiAobW9kdWxlc1tpXSlcclxuICAgICAgZm9yIChrZXkgaW4gbWV0aG9kcylcclxuICAgICAgICBtb2R1bGVzW2ldLnByb3RvdHlwZVtrZXldID0gbWV0aG9kc1trZXldXHJcblxyXG4gIC8vIE1ha2Ugc3VyZSBTVkcuU2V0IGluaGVyaXRzIGFueSBuZXdseSBhZGRlZCBtZXRob2RzXHJcbiAgaWYgKFNWRy5TZXQgJiYgU1ZHLlNldC5pbmhlcml0KVxyXG4gICAgU1ZHLlNldC5pbmhlcml0KClcclxufVxyXG5cclxuLy8gSW52ZW50IG5ldyBlbGVtZW50XHJcblNWRy5pbnZlbnQgPSBmdW5jdGlvbihjb25maWcpIHtcclxuICAvLyBDcmVhdGUgZWxlbWVudCBpbml0aWFsaXplclxyXG4gIHZhciBpbml0aWFsaXplciA9IHR5cGVvZiBjb25maWcuY3JlYXRlID09ICdmdW5jdGlvbicgP1xyXG4gICAgY29uZmlnLmNyZWF0ZSA6XHJcbiAgICBmdW5jdGlvbigpIHtcclxuICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIFNWRy5jcmVhdGUoY29uZmlnLmNyZWF0ZSkpXHJcbiAgICB9XHJcblxyXG4gIC8vIEluaGVyaXQgcHJvdG90eXBlXHJcbiAgaWYgKGNvbmZpZy5pbmhlcml0KVxyXG4gICAgaW5pdGlhbGl6ZXIucHJvdG90eXBlID0gbmV3IGNvbmZpZy5pbmhlcml0XHJcblxyXG4gIC8vIEV4dGVuZCB3aXRoIG1ldGhvZHNcclxuICBpZiAoY29uZmlnLmV4dGVuZClcclxuICAgIFNWRy5leHRlbmQoaW5pdGlhbGl6ZXIsIGNvbmZpZy5leHRlbmQpXHJcblxyXG4gIC8vIEF0dGFjaCBjb25zdHJ1Y3QgbWV0aG9kIHRvIHBhcmVudFxyXG4gIGlmIChjb25maWcuY29uc3RydWN0KVxyXG4gICAgU1ZHLmV4dGVuZChjb25maWcucGFyZW50IHx8IFNWRy5Db250YWluZXIsIGNvbmZpZy5jb25zdHJ1Y3QpXHJcblxyXG4gIHJldHVybiBpbml0aWFsaXplclxyXG59XHJcblxyXG4vLyBBZG9wdCBleGlzdGluZyBzdmcgZWxlbWVudHNcclxuU1ZHLmFkb3B0ID0gZnVuY3Rpb24obm9kZSkge1xyXG4gIC8vIGNoZWNrIGZvciBwcmVzZW5jZSBvZiBub2RlXHJcbiAgaWYgKCFub2RlKSByZXR1cm4gbnVsbFxyXG5cclxuICAvLyBtYWtlIHN1cmUgYSBub2RlIGlzbid0IGFscmVhZHkgYWRvcHRlZFxyXG4gIGlmIChub2RlLmluc3RhbmNlKSByZXR1cm4gbm9kZS5pbnN0YW5jZVxyXG5cclxuICAvLyBpbml0aWFsaXplIHZhcmlhYmxlc1xyXG4gIHZhciBlbGVtZW50XHJcblxyXG4gIC8vIGFkb3B0IHdpdGggZWxlbWVudC1zcGVjaWZpYyBzZXR0aW5nc1xyXG4gIGlmIChub2RlLm5vZGVOYW1lID09ICdzdmcnKVxyXG4gICAgZWxlbWVudCA9IG5vZGUucGFyZW50Tm9kZSBpbnN0YW5jZW9mIHdpbmRvdy5TVkdFbGVtZW50ID8gbmV3IFNWRy5OZXN0ZWQgOiBuZXcgU1ZHLkRvY1xyXG4gIGVsc2UgaWYgKG5vZGUubm9kZU5hbWUgPT0gJ2xpbmVhckdyYWRpZW50JylcclxuICAgIGVsZW1lbnQgPSBuZXcgU1ZHLkdyYWRpZW50KCdsaW5lYXInKVxyXG4gIGVsc2UgaWYgKG5vZGUubm9kZU5hbWUgPT0gJ3JhZGlhbEdyYWRpZW50JylcclxuICAgIGVsZW1lbnQgPSBuZXcgU1ZHLkdyYWRpZW50KCdyYWRpYWwnKVxyXG4gIGVsc2UgaWYgKFNWR1tjYXBpdGFsaXplKG5vZGUubm9kZU5hbWUpXSlcclxuICAgIGVsZW1lbnQgPSBuZXcgU1ZHW2NhcGl0YWxpemUobm9kZS5ub2RlTmFtZSldXHJcbiAgZWxzZVxyXG4gICAgZWxlbWVudCA9IG5ldyBTVkcuRWxlbWVudChub2RlKVxyXG5cclxuICAvLyBlbnN1cmUgcmVmZXJlbmNlc1xyXG4gIGVsZW1lbnQudHlwZSAgPSBub2RlLm5vZGVOYW1lXHJcbiAgZWxlbWVudC5ub2RlICA9IG5vZGVcclxuICBub2RlLmluc3RhbmNlID0gZWxlbWVudFxyXG5cclxuICAvLyBTVkcuQ2xhc3Mgc3BlY2lmaWMgcHJlcGFyYXRpb25zXHJcbiAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBTVkcuRG9jKVxyXG4gICAgZWxlbWVudC5uYW1lc3BhY2UoKS5kZWZzKClcclxuXHJcbiAgLy8gcHVsbCBzdmdqcyBkYXRhIGZyb20gdGhlIGRvbSAoZ2V0QXR0cmlidXRlTlMgZG9lc24ndCB3b3JrIGluIGh0bWw1KVxyXG4gIGVsZW1lbnQuc2V0RGF0YShKU09OLnBhcnNlKG5vZGUuZ2V0QXR0cmlidXRlKCdzdmdqczpkYXRhJykpIHx8IHt9KVxyXG5cclxuICByZXR1cm4gZWxlbWVudFxyXG59XHJcblxyXG4vLyBJbml0aWFsaXplIHBhcnNpbmcgZWxlbWVudFxyXG5TVkcucHJlcGFyZSA9IGZ1bmN0aW9uKCkge1xyXG4gIC8vIFNlbGVjdCBkb2N1bWVudCBib2R5IGFuZCBjcmVhdGUgaW52aXNpYmxlIHN2ZyBlbGVtZW50XHJcbiAgdmFyIGJvZHkgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYm9keScpWzBdXHJcbiAgICAsIGRyYXcgPSAoYm9keSA/IG5ldyBTVkcuRG9jKGJvZHkpIDogIFNWRy5hZG9wdChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpLm5lc3RlZCgpKS5zaXplKDIsIDApXHJcblxyXG4gIC8vIENyZWF0ZSBwYXJzZXIgb2JqZWN0XHJcbiAgU1ZHLnBhcnNlciA9IHtcclxuICAgIGJvZHk6IGJvZHkgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XHJcbiAgLCBkcmF3OiBkcmF3LnN0eWxlKCdvcGFjaXR5OjA7cG9zaXRpb246YWJzb2x1dGU7bGVmdDotMTAwJTt0b3A6LTEwMCU7b3ZlcmZsb3c6aGlkZGVuJylcclxuICAsIHBvbHk6IGRyYXcucG9seWxpbmUoKS5ub2RlXHJcbiAgLCBwYXRoOiBkcmF3LnBhdGgoKS5ub2RlXHJcbiAgLCBuYXRpdmU6IFNWRy5jcmVhdGUoJ3N2ZycpXHJcbiAgfVxyXG59XHJcblxyXG5TVkcucGFyc2VyID0ge1xyXG4gIG5hdGl2ZTogU1ZHLmNyZWF0ZSgnc3ZnJylcclxufVxyXG5cclxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGZ1bmN0aW9uKCkge1xyXG4gIGlmKCFTVkcucGFyc2VyLmRyYXcpXHJcbiAgICBTVkcucHJlcGFyZSgpXHJcbn0sIGZhbHNlKVxyXG5cbi8vIFN0b3JhZ2UgZm9yIHJlZ3VsYXIgZXhwcmVzc2lvbnNcclxuU1ZHLnJlZ2V4ID0ge1xyXG4gIC8vIFBhcnNlIHVuaXQgdmFsdWVcclxuICBudW1iZXJBbmRVbml0OiAgICAvXihbKy1dPyhcXGQrKFxcLlxcZCopP3xcXC5cXGQrKShlWystXT9cXGQrKT8pKFthLXolXSopJC9pXHJcblxyXG4gIC8vIFBhcnNlIGhleCB2YWx1ZVxyXG4sIGhleDogICAgICAgICAgICAgIC9eIz8oW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkkL2lcclxuXHJcbiAgLy8gUGFyc2UgcmdiIHZhbHVlXHJcbiwgcmdiOiAgICAgICAgICAgICAgL3JnYlxcKChcXGQrKSwoXFxkKyksKFxcZCspXFwpL1xyXG5cclxuICAvLyBQYXJzZSByZWZlcmVuY2UgaWRcclxuLCByZWZlcmVuY2U6ICAgICAgICAvIyhbYS16MC05XFwtX10rKS9pXHJcblxyXG4gIC8vIHNwbGl0cyBhIHRyYW5zZm9ybWF0aW9uIGNoYWluXHJcbiwgdHJhbnNmb3JtczogICAgICAgL1xcKVxccyosP1xccyovXHJcblxyXG4gIC8vIFdoaXRlc3BhY2VcclxuLCB3aGl0ZXNwYWNlOiAgICAgICAvXFxzL2dcclxuXHJcbiAgLy8gVGVzdCBoZXggdmFsdWVcclxuLCBpc0hleDogICAgICAgICAgICAvXiNbYS1mMC05XXszLDZ9JC9pXHJcblxyXG4gIC8vIFRlc3QgcmdiIHZhbHVlXHJcbiwgaXNSZ2I6ICAgICAgICAgICAgL15yZ2JcXCgvXHJcblxyXG4gIC8vIFRlc3QgY3NzIGRlY2xhcmF0aW9uXHJcbiwgaXNDc3M6ICAgICAgICAgICAgL1teOl0rOlteO10rOz8vXHJcblxyXG4gIC8vIFRlc3QgZm9yIGJsYW5rIHN0cmluZ1xyXG4sIGlzQmxhbms6ICAgICAgICAgIC9eKFxccyspPyQvXHJcblxyXG4gIC8vIFRlc3QgZm9yIG51bWVyaWMgc3RyaW5nXHJcbiwgaXNOdW1iZXI6ICAgICAgICAgL15bKy1dPyhcXGQrKFxcLlxcZCopP3xcXC5cXGQrKShlWystXT9cXGQrKT8kL2lcclxuXHJcbiAgLy8gVGVzdCBmb3IgcGVyY2VudCB2YWx1ZVxyXG4sIGlzUGVyY2VudDogICAgICAgIC9eLT9bXFxkXFwuXSslJC9cclxuXHJcbiAgLy8gVGVzdCBmb3IgaW1hZ2UgdXJsXHJcbiwgaXNJbWFnZTogICAgICAgICAgL1xcLihqcGd8anBlZ3xwbmd8Z2lmfHN2ZykoXFw/W149XSsuKik/L2lcclxuXHJcbiAgLy8gc3BsaXQgYXQgd2hpdGVzcGFjZSBhbmQgY29tbWFcclxuLCBkZWxpbWl0ZXI6ICAgICAgICAvW1xccyxdKy9cclxuXHJcbiAgLy8gVGhlIGZvbGxvd2luZyByZWdleCBhcmUgdXNlZCB0byBwYXJzZSB0aGUgZCBhdHRyaWJ1dGUgb2YgYSBwYXRoXHJcblxyXG4gIC8vIE1hdGNoZXMgYWxsIGh5cGhlbnMgd2hpY2ggYXJlIG5vdCBhZnRlciBhbiBleHBvbmVudFxyXG4sIGh5cGhlbjogICAgICAgICAgIC8oW15lXSlcXC0vZ2lcclxuXHJcbiAgLy8gUmVwbGFjZXMgYW5kIHRlc3RzIGZvciBhbGwgcGF0aCBsZXR0ZXJzXHJcbiwgcGF0aExldHRlcnM6ICAgICAgL1tNTEhWQ1NRVEFaXS9naVxyXG5cclxuICAvLyB5ZXMgd2UgbmVlZCB0aGlzIG9uZSwgdG9vXHJcbiwgaXNQYXRoTGV0dGVyOiAgICAgL1tNTEhWQ1NRVEFaXS9pXHJcblxyXG4gIC8vIG1hdGNoZXMgMC4xNTQuMjMuNDVcclxuLCBudW1iZXJzV2l0aERvdHM6ICAvKChcXGQ/XFwuXFxkKyg/OmVbKy1dP1xcZCspPykoKD86XFwuXFxkKyg/OmVbKy1dP1xcZCspPykrKSkrL2dpXHJcblxyXG4gIC8vIG1hdGNoZXMgLlxyXG4sIGRvdHM6ICAgICAgICAgICAgIC9cXC4vZ1xyXG59XHJcblxuU1ZHLnV0aWxzID0ge1xyXG4gIC8vIE1hcCBmdW5jdGlvblxyXG4gIG1hcDogZnVuY3Rpb24oYXJyYXksIGJsb2NrKSB7XHJcbiAgICB2YXIgaVxyXG4gICAgICAsIGlsID0gYXJyYXkubGVuZ3RoXHJcbiAgICAgICwgcmVzdWx0ID0gW11cclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgaWw7IGkrKylcclxuICAgICAgcmVzdWx0LnB1c2goYmxvY2soYXJyYXlbaV0pKVxyXG5cclxuICAgIHJldHVybiByZXN1bHRcclxuICB9XHJcblxyXG4gIC8vIEZpbHRlciBmdW5jdGlvblxyXG4sIGZpbHRlcjogZnVuY3Rpb24oYXJyYXksIGJsb2NrKSB7XHJcbiAgICB2YXIgaVxyXG4gICAgICAsIGlsID0gYXJyYXkubGVuZ3RoXHJcbiAgICAgICwgcmVzdWx0ID0gW11cclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgaWw7IGkrKylcclxuICAgICAgaWYgKGJsb2NrKGFycmF5W2ldKSlcclxuICAgICAgICByZXN1bHQucHVzaChhcnJheVtpXSlcclxuXHJcbiAgICByZXR1cm4gcmVzdWx0XHJcbiAgfVxyXG5cclxuICAvLyBEZWdyZWVzIHRvIHJhZGlhbnNcclxuLCByYWRpYW5zOiBmdW5jdGlvbihkKSB7XHJcbiAgICByZXR1cm4gZCAlIDM2MCAqIE1hdGguUEkgLyAxODBcclxuICB9XHJcblxyXG4gIC8vIFJhZGlhbnMgdG8gZGVncmVlc1xyXG4sIGRlZ3JlZXM6IGZ1bmN0aW9uKHIpIHtcclxuICAgIHJldHVybiByICogMTgwIC8gTWF0aC5QSSAlIDM2MFxyXG4gIH1cclxuXHJcbiwgZmlsdGVyU1ZHRWxlbWVudHM6IGZ1bmN0aW9uKG5vZGVzKSB7XHJcbiAgICByZXR1cm4gdGhpcy5maWx0ZXIoIG5vZGVzLCBmdW5jdGlvbihlbCkgeyByZXR1cm4gZWwgaW5zdGFuY2VvZiB3aW5kb3cuU1ZHRWxlbWVudCB9KVxyXG4gIH1cclxuXHJcbn1cblxyXG5TVkcuZGVmYXVsdHMgPSB7XHJcbiAgLy8gRGVmYXVsdCBhdHRyaWJ1dGUgdmFsdWVzXHJcbiAgYXR0cnM6IHtcclxuICAgIC8vIGZpbGwgYW5kIHN0cm9rZVxyXG4gICAgJ2ZpbGwtb3BhY2l0eSc6ICAgICAxXHJcbiAgLCAnc3Ryb2tlLW9wYWNpdHknOiAgIDFcclxuICAsICdzdHJva2Utd2lkdGgnOiAgICAgMFxyXG4gICwgJ3N0cm9rZS1saW5lam9pbic6ICAnbWl0ZXInXHJcbiAgLCAnc3Ryb2tlLWxpbmVjYXAnOiAgICdidXR0J1xyXG4gICwgZmlsbDogICAgICAgICAgICAgICAnIzAwMDAwMCdcclxuICAsIHN0cm9rZTogICAgICAgICAgICAgJyMwMDAwMDAnXHJcbiAgLCBvcGFjaXR5OiAgICAgICAgICAgIDFcclxuICAgIC8vIHBvc2l0aW9uXHJcbiAgLCB4OiAgICAgICAgICAgICAgICAgIDBcclxuICAsIHk6ICAgICAgICAgICAgICAgICAgMFxyXG4gICwgY3g6ICAgICAgICAgICAgICAgICAwXHJcbiAgLCBjeTogICAgICAgICAgICAgICAgIDBcclxuICAgIC8vIHNpemVcclxuICAsIHdpZHRoOiAgICAgICAgICAgICAgMFxyXG4gICwgaGVpZ2h0OiAgICAgICAgICAgICAwXHJcbiAgICAvLyByYWRpdXNcclxuICAsIHI6ICAgICAgICAgICAgICAgICAgMFxyXG4gICwgcng6ICAgICAgICAgICAgICAgICAwXHJcbiAgLCByeTogICAgICAgICAgICAgICAgIDBcclxuICAgIC8vIGdyYWRpZW50XHJcbiAgLCBvZmZzZXQ6ICAgICAgICAgICAgIDBcclxuICAsICdzdG9wLW9wYWNpdHknOiAgICAgMVxyXG4gICwgJ3N0b3AtY29sb3InOiAgICAgICAnIzAwMDAwMCdcclxuICAgIC8vIHRleHRcclxuICAsICdmb250LXNpemUnOiAgICAgICAgMTZcclxuICAsICdmb250LWZhbWlseSc6ICAgICAgJ0hlbHZldGljYSwgQXJpYWwsIHNhbnMtc2VyaWYnXHJcbiAgLCAndGV4dC1hbmNob3InOiAgICAgICdzdGFydCdcclxuICB9XHJcblxyXG59XG4vLyBNb2R1bGUgZm9yIGNvbG9yIGNvbnZlcnRpb25zXHJcblNWRy5Db2xvciA9IGZ1bmN0aW9uKGNvbG9yKSB7XHJcbiAgdmFyIG1hdGNoXHJcblxyXG4gIC8vIGluaXRpYWxpemUgZGVmYXVsdHNcclxuICB0aGlzLnIgPSAwXHJcbiAgdGhpcy5nID0gMFxyXG4gIHRoaXMuYiA9IDBcclxuXHJcbiAgaWYoIWNvbG9yKSByZXR1cm5cclxuXHJcbiAgLy8gcGFyc2UgY29sb3JcclxuICBpZiAodHlwZW9mIGNvbG9yID09PSAnc3RyaW5nJykge1xyXG4gICAgaWYgKFNWRy5yZWdleC5pc1JnYi50ZXN0KGNvbG9yKSkge1xyXG4gICAgICAvLyBnZXQgcmdiIHZhbHVlc1xyXG4gICAgICBtYXRjaCA9IFNWRy5yZWdleC5yZ2IuZXhlYyhjb2xvci5yZXBsYWNlKFNWRy5yZWdleC53aGl0ZXNwYWNlLCcnKSlcclxuXHJcbiAgICAgIC8vIHBhcnNlIG51bWVyaWMgdmFsdWVzXHJcbiAgICAgIHRoaXMuciA9IHBhcnNlSW50KG1hdGNoWzFdKVxyXG4gICAgICB0aGlzLmcgPSBwYXJzZUludChtYXRjaFsyXSlcclxuICAgICAgdGhpcy5iID0gcGFyc2VJbnQobWF0Y2hbM10pXHJcblxyXG4gICAgfSBlbHNlIGlmIChTVkcucmVnZXguaXNIZXgudGVzdChjb2xvcikpIHtcclxuICAgICAgLy8gZ2V0IGhleCB2YWx1ZXNcclxuICAgICAgbWF0Y2ggPSBTVkcucmVnZXguaGV4LmV4ZWMoZnVsbEhleChjb2xvcikpXHJcblxyXG4gICAgICAvLyBwYXJzZSBudW1lcmljIHZhbHVlc1xyXG4gICAgICB0aGlzLnIgPSBwYXJzZUludChtYXRjaFsxXSwgMTYpXHJcbiAgICAgIHRoaXMuZyA9IHBhcnNlSW50KG1hdGNoWzJdLCAxNilcclxuICAgICAgdGhpcy5iID0gcGFyc2VJbnQobWF0Y2hbM10sIDE2KVxyXG5cclxuICAgIH1cclxuXHJcbiAgfSBlbHNlIGlmICh0eXBlb2YgY29sb3IgPT09ICdvYmplY3QnKSB7XHJcbiAgICB0aGlzLnIgPSBjb2xvci5yXHJcbiAgICB0aGlzLmcgPSBjb2xvci5nXHJcbiAgICB0aGlzLmIgPSBjb2xvci5iXHJcblxyXG4gIH1cclxuXHJcbn1cclxuXHJcblNWRy5leHRlbmQoU1ZHLkNvbG9yLCB7XHJcbiAgLy8gRGVmYXVsdCB0byBoZXggY29udmVyc2lvblxyXG4gIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLnRvSGV4KClcclxuICB9XHJcbiAgLy8gQnVpbGQgaGV4IHZhbHVlXHJcbiwgdG9IZXg6IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuICcjJ1xyXG4gICAgICArIGNvbXBUb0hleCh0aGlzLnIpXHJcbiAgICAgICsgY29tcFRvSGV4KHRoaXMuZylcclxuICAgICAgKyBjb21wVG9IZXgodGhpcy5iKVxyXG4gIH1cclxuICAvLyBCdWlsZCByZ2IgdmFsdWVcclxuLCB0b1JnYjogZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gJ3JnYignICsgW3RoaXMuciwgdGhpcy5nLCB0aGlzLmJdLmpvaW4oKSArICcpJ1xyXG4gIH1cclxuICAvLyBDYWxjdWxhdGUgdHJ1ZSBicmlnaHRuZXNzXHJcbiwgYnJpZ2h0bmVzczogZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gKHRoaXMuciAvIDI1NSAqIDAuMzApXHJcbiAgICAgICAgICsgKHRoaXMuZyAvIDI1NSAqIDAuNTkpXHJcbiAgICAgICAgICsgKHRoaXMuYiAvIDI1NSAqIDAuMTEpXHJcbiAgfVxyXG4gIC8vIE1ha2UgY29sb3IgbW9ycGhhYmxlXHJcbiwgbW9ycGg6IGZ1bmN0aW9uKGNvbG9yKSB7XHJcbiAgICB0aGlzLmRlc3RpbmF0aW9uID0gbmV3IFNWRy5Db2xvcihjb2xvcilcclxuXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuICAvLyBHZXQgbW9ycGhlZCBjb2xvciBhdCBnaXZlbiBwb3NpdGlvblxyXG4sIGF0OiBmdW5jdGlvbihwb3MpIHtcclxuICAgIC8vIG1ha2Ugc3VyZSBhIGRlc3RpbmF0aW9uIGlzIGRlZmluZWRcclxuICAgIGlmICghdGhpcy5kZXN0aW5hdGlvbikgcmV0dXJuIHRoaXNcclxuXHJcbiAgICAvLyBub3JtYWxpc2UgcG9zXHJcbiAgICBwb3MgPSBwb3MgPCAwID8gMCA6IHBvcyA+IDEgPyAxIDogcG9zXHJcblxyXG4gICAgLy8gZ2VuZXJhdGUgbW9ycGhlZCBjb2xvclxyXG4gICAgcmV0dXJuIG5ldyBTVkcuQ29sb3Ioe1xyXG4gICAgICByOiB+fih0aGlzLnIgKyAodGhpcy5kZXN0aW5hdGlvbi5yIC0gdGhpcy5yKSAqIHBvcylcclxuICAgICwgZzogfn4odGhpcy5nICsgKHRoaXMuZGVzdGluYXRpb24uZyAtIHRoaXMuZykgKiBwb3MpXHJcbiAgICAsIGI6IH5+KHRoaXMuYiArICh0aGlzLmRlc3RpbmF0aW9uLmIgLSB0aGlzLmIpICogcG9zKVxyXG4gICAgfSlcclxuICB9XHJcblxyXG59KVxyXG5cclxuLy8gVGVzdGVyc1xyXG5cclxuLy8gVGVzdCBpZiBnaXZlbiB2YWx1ZSBpcyBhIGNvbG9yIHN0cmluZ1xyXG5TVkcuQ29sb3IudGVzdCA9IGZ1bmN0aW9uKGNvbG9yKSB7XHJcbiAgY29sb3IgKz0gJydcclxuICByZXR1cm4gU1ZHLnJlZ2V4LmlzSGV4LnRlc3QoY29sb3IpXHJcbiAgICAgIHx8IFNWRy5yZWdleC5pc1JnYi50ZXN0KGNvbG9yKVxyXG59XHJcblxyXG4vLyBUZXN0IGlmIGdpdmVuIHZhbHVlIGlzIGEgcmdiIG9iamVjdFxyXG5TVkcuQ29sb3IuaXNSZ2IgPSBmdW5jdGlvbihjb2xvcikge1xyXG4gIHJldHVybiBjb2xvciAmJiB0eXBlb2YgY29sb3IuciA9PSAnbnVtYmVyJ1xyXG4gICAgICAgICAgICAgICAmJiB0eXBlb2YgY29sb3IuZyA9PSAnbnVtYmVyJ1xyXG4gICAgICAgICAgICAgICAmJiB0eXBlb2YgY29sb3IuYiA9PSAnbnVtYmVyJ1xyXG59XHJcblxyXG4vLyBUZXN0IGlmIGdpdmVuIHZhbHVlIGlzIGEgY29sb3JcclxuU1ZHLkNvbG9yLmlzQ29sb3IgPSBmdW5jdGlvbihjb2xvcikge1xyXG4gIHJldHVybiBTVkcuQ29sb3IuaXNSZ2IoY29sb3IpIHx8IFNWRy5Db2xvci50ZXN0KGNvbG9yKVxyXG59XG4vLyBNb2R1bGUgZm9yIGFycmF5IGNvbnZlcnNpb25cclxuU1ZHLkFycmF5ID0gZnVuY3Rpb24oYXJyYXksIGZhbGxiYWNrKSB7XHJcbiAgYXJyYXkgPSAoYXJyYXkgfHwgW10pLnZhbHVlT2YoKVxyXG5cclxuICAvLyBpZiBhcnJheSBpcyBlbXB0eSBhbmQgZmFsbGJhY2sgaXMgcHJvdmlkZWQsIHVzZSBmYWxsYmFja1xyXG4gIGlmIChhcnJheS5sZW5ndGggPT0gMCAmJiBmYWxsYmFjaylcclxuICAgIGFycmF5ID0gZmFsbGJhY2sudmFsdWVPZigpXHJcblxyXG4gIC8vIHBhcnNlIGFycmF5XHJcbiAgdGhpcy52YWx1ZSA9IHRoaXMucGFyc2UoYXJyYXkpXHJcbn1cclxuXHJcblNWRy5leHRlbmQoU1ZHLkFycmF5LCB7XHJcbiAgLy8gTWFrZSBhcnJheSBtb3JwaGFibGVcclxuICBtb3JwaDogZnVuY3Rpb24oYXJyYXkpIHtcclxuICAgIHRoaXMuZGVzdGluYXRpb24gPSB0aGlzLnBhcnNlKGFycmF5KVxyXG5cclxuICAgIC8vIG5vcm1hbGl6ZSBsZW5ndGggb2YgYXJyYXlzXHJcbiAgICBpZiAodGhpcy52YWx1ZS5sZW5ndGggIT0gdGhpcy5kZXN0aW5hdGlvbi5sZW5ndGgpIHtcclxuICAgICAgdmFyIGxhc3RWYWx1ZSAgICAgICA9IHRoaXMudmFsdWVbdGhpcy52YWx1ZS5sZW5ndGggLSAxXVxyXG4gICAgICAgICwgbGFzdERlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvblt0aGlzLmRlc3RpbmF0aW9uLmxlbmd0aCAtIDFdXHJcblxyXG4gICAgICB3aGlsZSh0aGlzLnZhbHVlLmxlbmd0aCA+IHRoaXMuZGVzdGluYXRpb24ubGVuZ3RoKVxyXG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ucHVzaChsYXN0RGVzdGluYXRpb24pXHJcbiAgICAgIHdoaWxlKHRoaXMudmFsdWUubGVuZ3RoIDwgdGhpcy5kZXN0aW5hdGlvbi5sZW5ndGgpXHJcbiAgICAgICAgdGhpcy52YWx1ZS5wdXNoKGxhc3RWYWx1ZSlcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuICAvLyBDbGVhbiB1cCBhbnkgZHVwbGljYXRlIHBvaW50c1xyXG4sIHNldHRsZTogZnVuY3Rpb24oKSB7XHJcbiAgICAvLyBmaW5kIGFsbCB1bmlxdWUgdmFsdWVzXHJcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSB0aGlzLnZhbHVlLmxlbmd0aCwgc2VlbiA9IFtdOyBpIDwgaWw7IGkrKylcclxuICAgICAgaWYgKHNlZW4uaW5kZXhPZih0aGlzLnZhbHVlW2ldKSA9PSAtMSlcclxuICAgICAgICBzZWVuLnB1c2godGhpcy52YWx1ZVtpXSlcclxuXHJcbiAgICAvLyBzZXQgbmV3IHZhbHVlXHJcbiAgICByZXR1cm4gdGhpcy52YWx1ZSA9IHNlZW5cclxuICB9XHJcbiAgLy8gR2V0IG1vcnBoZWQgYXJyYXkgYXQgZ2l2ZW4gcG9zaXRpb25cclxuLCBhdDogZnVuY3Rpb24ocG9zKSB7XHJcbiAgICAvLyBtYWtlIHN1cmUgYSBkZXN0aW5hdGlvbiBpcyBkZWZpbmVkXHJcbiAgICBpZiAoIXRoaXMuZGVzdGluYXRpb24pIHJldHVybiB0aGlzXHJcblxyXG4gICAgLy8gZ2VuZXJhdGUgbW9ycGhlZCBhcnJheVxyXG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gdGhpcy52YWx1ZS5sZW5ndGgsIGFycmF5ID0gW107IGkgPCBpbDsgaSsrKVxyXG4gICAgICBhcnJheS5wdXNoKHRoaXMudmFsdWVbaV0gKyAodGhpcy5kZXN0aW5hdGlvbltpXSAtIHRoaXMudmFsdWVbaV0pICogcG9zKVxyXG5cclxuICAgIHJldHVybiBuZXcgU1ZHLkFycmF5KGFycmF5KVxyXG4gIH1cclxuICAvLyBDb252ZXJ0IGFycmF5IHRvIHN0cmluZ1xyXG4sIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLnZhbHVlLmpvaW4oJyAnKVxyXG4gIH1cclxuICAvLyBSZWFsIHZhbHVlXHJcbiwgdmFsdWVPZjogZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy52YWx1ZVxyXG4gIH1cclxuICAvLyBQYXJzZSB3aGl0ZXNwYWNlIHNlcGFyYXRlZCBzdHJpbmdcclxuLCBwYXJzZTogZnVuY3Rpb24oYXJyYXkpIHtcclxuICAgIGFycmF5ID0gYXJyYXkudmFsdWVPZigpXHJcblxyXG4gICAgLy8gaWYgYWxyZWFkeSBpcyBhbiBhcnJheSwgbm8gbmVlZCB0byBwYXJzZSBpdFxyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyYXkpKSByZXR1cm4gYXJyYXlcclxuXHJcbiAgICByZXR1cm4gdGhpcy5zcGxpdChhcnJheSlcclxuICB9XHJcbiAgLy8gU3RyaXAgdW5uZWNlc3Nhcnkgd2hpdGVzcGFjZVxyXG4sIHNwbGl0OiBmdW5jdGlvbihzdHJpbmcpIHtcclxuICAgIHJldHVybiBzdHJpbmcudHJpbSgpLnNwbGl0KFNWRy5yZWdleC5kZWxpbWl0ZXIpLm1hcChwYXJzZUZsb2F0KVxyXG4gIH1cclxuICAvLyBSZXZlcnNlIGFycmF5XHJcbiwgcmV2ZXJzZTogZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLnZhbHVlLnJldmVyc2UoKVxyXG5cclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG4sIGNsb25lOiBmdW5jdGlvbigpIHtcclxuICAgIHZhciBjbG9uZSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKClcclxuICAgIGNsb25lLnZhbHVlID0gYXJyYXlfY2xvbmUodGhpcy52YWx1ZSlcclxuICAgIHJldHVybiBjbG9uZVxyXG4gIH1cclxufSlcbi8vIFBvbHkgcG9pbnRzIGFycmF5XHJcblNWRy5Qb2ludEFycmF5ID0gZnVuY3Rpb24oYXJyYXksIGZhbGxiYWNrKSB7XHJcbiAgU1ZHLkFycmF5LmNhbGwodGhpcywgYXJyYXksIGZhbGxiYWNrIHx8IFtbMCwwXV0pXHJcbn1cclxuXHJcbi8vIEluaGVyaXQgZnJvbSBTVkcuQXJyYXlcclxuU1ZHLlBvaW50QXJyYXkucHJvdG90eXBlID0gbmV3IFNWRy5BcnJheVxyXG5TVkcuUG9pbnRBcnJheS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTVkcuUG9pbnRBcnJheVxyXG5cclxuU1ZHLmV4dGVuZChTVkcuUG9pbnRBcnJheSwge1xyXG4gIC8vIENvbnZlcnQgYXJyYXkgdG8gc3RyaW5nXHJcbiAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xyXG4gICAgLy8gY29udmVydCB0byBhIHBvbHkgcG9pbnQgc3RyaW5nXHJcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSB0aGlzLnZhbHVlLmxlbmd0aCwgYXJyYXkgPSBbXTsgaSA8IGlsOyBpKyspXHJcbiAgICAgIGFycmF5LnB1c2godGhpcy52YWx1ZVtpXS5qb2luKCcsJykpXHJcblxyXG4gICAgcmV0dXJuIGFycmF5LmpvaW4oJyAnKVxyXG4gIH1cclxuICAvLyBDb252ZXJ0IGFycmF5IHRvIGxpbmUgb2JqZWN0XHJcbiwgdG9MaW5lOiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHgxOiB0aGlzLnZhbHVlWzBdWzBdXHJcbiAgICAsIHkxOiB0aGlzLnZhbHVlWzBdWzFdXHJcbiAgICAsIHgyOiB0aGlzLnZhbHVlWzFdWzBdXHJcbiAgICAsIHkyOiB0aGlzLnZhbHVlWzFdWzFdXHJcbiAgICB9XHJcbiAgfVxyXG4gIC8vIEdldCBtb3JwaGVkIGFycmF5IGF0IGdpdmVuIHBvc2l0aW9uXHJcbiwgYXQ6IGZ1bmN0aW9uKHBvcykge1xyXG4gICAgLy8gbWFrZSBzdXJlIGEgZGVzdGluYXRpb24gaXMgZGVmaW5lZFxyXG4gICAgaWYgKCF0aGlzLmRlc3RpbmF0aW9uKSByZXR1cm4gdGhpc1xyXG5cclxuICAgIC8vIGdlbmVyYXRlIG1vcnBoZWQgcG9pbnQgc3RyaW5nXHJcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSB0aGlzLnZhbHVlLmxlbmd0aCwgYXJyYXkgPSBbXTsgaSA8IGlsOyBpKyspXHJcbiAgICAgIGFycmF5LnB1c2goW1xyXG4gICAgICAgIHRoaXMudmFsdWVbaV1bMF0gKyAodGhpcy5kZXN0aW5hdGlvbltpXVswXSAtIHRoaXMudmFsdWVbaV1bMF0pICogcG9zXHJcbiAgICAgICwgdGhpcy52YWx1ZVtpXVsxXSArICh0aGlzLmRlc3RpbmF0aW9uW2ldWzFdIC0gdGhpcy52YWx1ZVtpXVsxXSkgKiBwb3NcclxuICAgICAgXSlcclxuXHJcbiAgICByZXR1cm4gbmV3IFNWRy5Qb2ludEFycmF5KGFycmF5KVxyXG4gIH1cclxuICAvLyBQYXJzZSBwb2ludCBzdHJpbmcgYW5kIGZsYXQgYXJyYXlcclxuLCBwYXJzZTogZnVuY3Rpb24oYXJyYXkpIHtcclxuICAgIHZhciBwb2ludHMgPSBbXVxyXG5cclxuICAgIGFycmF5ID0gYXJyYXkudmFsdWVPZigpXHJcblxyXG4gICAgLy8gaWYgaXQgaXMgYW4gYXJyYXlcclxuICAgIGlmIChBcnJheS5pc0FycmF5KGFycmF5KSkge1xyXG4gICAgICAvLyBhbmQgaXQgaXMgbm90IGZsYXQsIHRoZXJlIGlzIG5vIG5lZWQgdG8gcGFyc2UgaXRcclxuICAgICAgaWYoQXJyYXkuaXNBcnJheShhcnJheVswXSkpIHtcclxuICAgICAgICByZXR1cm4gYXJyYXlcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHsgLy8gRWxzZSwgaXQgaXMgY29uc2lkZXJlZCBhcyBhIHN0cmluZ1xyXG4gICAgICAvLyBwYXJzZSBwb2ludHNcclxuICAgICAgYXJyYXkgPSBhcnJheS50cmltKCkuc3BsaXQoU1ZHLnJlZ2V4LmRlbGltaXRlcikubWFwKHBhcnNlRmxvYXQpXHJcbiAgICB9XHJcblxyXG4gICAgLy8gdmFsaWRhdGUgcG9pbnRzIC0gaHR0cHM6Ly9zdmd3Zy5vcmcvc3ZnMi1kcmFmdC9zaGFwZXMuaHRtbCNEYXRhVHlwZVBvaW50c1xyXG4gICAgLy8gT2RkIG51bWJlciBvZiBjb29yZGluYXRlcyBpcyBhbiBlcnJvci4gSW4gc3VjaCBjYXNlcywgZHJvcCB0aGUgbGFzdCBvZGQgY29vcmRpbmF0ZS5cclxuICAgIGlmIChhcnJheS5sZW5ndGggJSAyICE9PSAwKSBhcnJheS5wb3AoKVxyXG5cclxuICAgIC8vIHdyYXAgcG9pbnRzIGluIHR3by10dXBsZXMgYW5kIHBhcnNlIHBvaW50cyBhcyBmbG9hdHNcclxuICAgIGZvcih2YXIgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSA9IGkgKyAyKVxyXG4gICAgICBwb2ludHMucHVzaChbIGFycmF5W2ldLCBhcnJheVtpKzFdIF0pXHJcblxyXG4gICAgcmV0dXJuIHBvaW50c1xyXG4gIH1cclxuICAvLyBNb3ZlIHBvaW50IHN0cmluZ1xyXG4sIG1vdmU6IGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgIHZhciBib3ggPSB0aGlzLmJib3goKVxyXG5cclxuICAgIC8vIGdldCByZWxhdGl2ZSBvZmZzZXRcclxuICAgIHggLT0gYm94LnhcclxuICAgIHkgLT0gYm94LnlcclxuXHJcbiAgICAvLyBtb3ZlIGV2ZXJ5IHBvaW50XHJcbiAgICBpZiAoIWlzTmFOKHgpICYmICFpc05hTih5KSlcclxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudmFsdWUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXHJcbiAgICAgICAgdGhpcy52YWx1ZVtpXSA9IFt0aGlzLnZhbHVlW2ldWzBdICsgeCwgdGhpcy52YWx1ZVtpXVsxXSArIHldXHJcblxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcbiAgLy8gUmVzaXplIHBvbHkgc3RyaW5nXHJcbiwgc2l6ZTogZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xyXG4gICAgdmFyIGksIGJveCA9IHRoaXMuYmJveCgpXHJcblxyXG4gICAgLy8gcmVjYWxjdWxhdGUgcG9zaXRpb24gb2YgYWxsIHBvaW50cyBhY2NvcmRpbmcgdG8gbmV3IHNpemVcclxuICAgIGZvciAoaSA9IHRoaXMudmFsdWUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgaWYoYm94LndpZHRoKSB0aGlzLnZhbHVlW2ldWzBdID0gKCh0aGlzLnZhbHVlW2ldWzBdIC0gYm94LngpICogd2lkdGgpICAvIGJveC53aWR0aCAgKyBib3gueFxyXG4gICAgICBpZihib3guaGVpZ2h0KSB0aGlzLnZhbHVlW2ldWzFdID0gKCh0aGlzLnZhbHVlW2ldWzFdIC0gYm94LnkpICogaGVpZ2h0KSAvIGJveC5oZWlnaHQgKyBib3gueVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG4gIC8vIEdldCBib3VuZGluZyBib3ggb2YgcG9pbnRzXHJcbiwgYmJveDogZnVuY3Rpb24oKSB7XHJcbiAgICBTVkcucGFyc2VyLnBvbHkuc2V0QXR0cmlidXRlKCdwb2ludHMnLCB0aGlzLnRvU3RyaW5nKCkpXHJcblxyXG4gICAgcmV0dXJuIFNWRy5wYXJzZXIucG9seS5nZXRCQm94KClcclxuICB9XHJcbn0pXHJcblxuLy8gUGF0aCBwb2ludHMgYXJyYXlcclxuU1ZHLlBhdGhBcnJheSA9IGZ1bmN0aW9uKGFycmF5LCBmYWxsYmFjaykge1xyXG4gIFNWRy5BcnJheS5jYWxsKHRoaXMsIGFycmF5LCBmYWxsYmFjayB8fCBbWydNJywgMCwgMF1dKVxyXG59XHJcblxyXG4vLyBJbmhlcml0IGZyb20gU1ZHLkFycmF5XHJcblNWRy5QYXRoQXJyYXkucHJvdG90eXBlID0gbmV3IFNWRy5BcnJheVxyXG5TVkcuUGF0aEFycmF5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNWRy5QYXRoQXJyYXlcclxuXHJcblNWRy5leHRlbmQoU1ZHLlBhdGhBcnJheSwge1xyXG4gIC8vIENvbnZlcnQgYXJyYXkgdG8gc3RyaW5nXHJcbiAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIGFycmF5VG9TdHJpbmcodGhpcy52YWx1ZSlcclxuICB9XHJcbiAgLy8gTW92ZSBwYXRoIHN0cmluZ1xyXG4sIG1vdmU6IGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgIC8vIGdldCBib3VuZGluZyBib3ggb2YgY3VycmVudCBzaXR1YXRpb25cclxuICAgIHZhciBib3ggPSB0aGlzLmJib3goKVxyXG5cclxuICAgIC8vIGdldCByZWxhdGl2ZSBvZmZzZXRcclxuICAgIHggLT0gYm94LnhcclxuICAgIHkgLT0gYm94LnlcclxuXHJcbiAgICBpZiAoIWlzTmFOKHgpICYmICFpc05hTih5KSkge1xyXG4gICAgICAvLyBtb3ZlIGV2ZXJ5IHBvaW50XHJcbiAgICAgIGZvciAodmFyIGwsIGkgPSB0aGlzLnZhbHVlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgbCA9IHRoaXMudmFsdWVbaV1bMF1cclxuXHJcbiAgICAgICAgaWYgKGwgPT0gJ00nIHx8IGwgPT0gJ0wnIHx8IGwgPT0gJ1QnKSAge1xyXG4gICAgICAgICAgdGhpcy52YWx1ZVtpXVsxXSArPSB4XHJcbiAgICAgICAgICB0aGlzLnZhbHVlW2ldWzJdICs9IHlcclxuXHJcbiAgICAgICAgfSBlbHNlIGlmIChsID09ICdIJykgIHtcclxuICAgICAgICAgIHRoaXMudmFsdWVbaV1bMV0gKz0geFxyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKGwgPT0gJ1YnKSAge1xyXG4gICAgICAgICAgdGhpcy52YWx1ZVtpXVsxXSArPSB5XHJcblxyXG4gICAgICAgIH0gZWxzZSBpZiAobCA9PSAnQycgfHwgbCA9PSAnUycgfHwgbCA9PSAnUScpICB7XHJcbiAgICAgICAgICB0aGlzLnZhbHVlW2ldWzFdICs9IHhcclxuICAgICAgICAgIHRoaXMudmFsdWVbaV1bMl0gKz0geVxyXG4gICAgICAgICAgdGhpcy52YWx1ZVtpXVszXSArPSB4XHJcbiAgICAgICAgICB0aGlzLnZhbHVlW2ldWzRdICs9IHlcclxuXHJcbiAgICAgICAgICBpZiAobCA9PSAnQycpICB7XHJcbiAgICAgICAgICAgIHRoaXMudmFsdWVbaV1bNV0gKz0geFxyXG4gICAgICAgICAgICB0aGlzLnZhbHVlW2ldWzZdICs9IHlcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSBlbHNlIGlmIChsID09ICdBJykgIHtcclxuICAgICAgICAgIHRoaXMudmFsdWVbaV1bNl0gKz0geFxyXG4gICAgICAgICAgdGhpcy52YWx1ZVtpXVs3XSArPSB5XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG4gIC8vIFJlc2l6ZSBwYXRoIHN0cmluZ1xyXG4sIHNpemU6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgIC8vIGdldCBib3VuZGluZyBib3ggb2YgY3VycmVudCBzaXR1YXRpb25cclxuICAgIHZhciBpLCBsLCBib3ggPSB0aGlzLmJib3goKVxyXG5cclxuICAgIC8vIHJlY2FsY3VsYXRlIHBvc2l0aW9uIG9mIGFsbCBwb2ludHMgYWNjb3JkaW5nIHRvIG5ldyBzaXplXHJcbiAgICBmb3IgKGkgPSB0aGlzLnZhbHVlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgIGwgPSB0aGlzLnZhbHVlW2ldWzBdXHJcblxyXG4gICAgICBpZiAobCA9PSAnTScgfHwgbCA9PSAnTCcgfHwgbCA9PSAnVCcpICB7XHJcbiAgICAgICAgdGhpcy52YWx1ZVtpXVsxXSA9ICgodGhpcy52YWx1ZVtpXVsxXSAtIGJveC54KSAqIHdpZHRoKSAgLyBib3gud2lkdGggICsgYm94LnhcclxuICAgICAgICB0aGlzLnZhbHVlW2ldWzJdID0gKCh0aGlzLnZhbHVlW2ldWzJdIC0gYm94LnkpICogaGVpZ2h0KSAvIGJveC5oZWlnaHQgKyBib3gueVxyXG5cclxuICAgICAgfSBlbHNlIGlmIChsID09ICdIJykgIHtcclxuICAgICAgICB0aGlzLnZhbHVlW2ldWzFdID0gKCh0aGlzLnZhbHVlW2ldWzFdIC0gYm94LngpICogd2lkdGgpICAvIGJveC53aWR0aCAgKyBib3gueFxyXG5cclxuICAgICAgfSBlbHNlIGlmIChsID09ICdWJykgIHtcclxuICAgICAgICB0aGlzLnZhbHVlW2ldWzFdID0gKCh0aGlzLnZhbHVlW2ldWzFdIC0gYm94LnkpICogaGVpZ2h0KSAvIGJveC5oZWlnaHQgKyBib3gueVxyXG5cclxuICAgICAgfSBlbHNlIGlmIChsID09ICdDJyB8fCBsID09ICdTJyB8fCBsID09ICdRJykgIHtcclxuICAgICAgICB0aGlzLnZhbHVlW2ldWzFdID0gKCh0aGlzLnZhbHVlW2ldWzFdIC0gYm94LngpICogd2lkdGgpICAvIGJveC53aWR0aCAgKyBib3gueFxyXG4gICAgICAgIHRoaXMudmFsdWVbaV1bMl0gPSAoKHRoaXMudmFsdWVbaV1bMl0gLSBib3gueSkgKiBoZWlnaHQpIC8gYm94LmhlaWdodCArIGJveC55XHJcbiAgICAgICAgdGhpcy52YWx1ZVtpXVszXSA9ICgodGhpcy52YWx1ZVtpXVszXSAtIGJveC54KSAqIHdpZHRoKSAgLyBib3gud2lkdGggICsgYm94LnhcclxuICAgICAgICB0aGlzLnZhbHVlW2ldWzRdID0gKCh0aGlzLnZhbHVlW2ldWzRdIC0gYm94LnkpICogaGVpZ2h0KSAvIGJveC5oZWlnaHQgKyBib3gueVxyXG5cclxuICAgICAgICBpZiAobCA9PSAnQycpICB7XHJcbiAgICAgICAgICB0aGlzLnZhbHVlW2ldWzVdID0gKCh0aGlzLnZhbHVlW2ldWzVdIC0gYm94LngpICogd2lkdGgpICAvIGJveC53aWR0aCAgKyBib3gueFxyXG4gICAgICAgICAgdGhpcy52YWx1ZVtpXVs2XSA9ICgodGhpcy52YWx1ZVtpXVs2XSAtIGJveC55KSAqIGhlaWdodCkgLyBib3guaGVpZ2h0ICsgYm94LnlcclxuICAgICAgICB9XHJcblxyXG4gICAgICB9IGVsc2UgaWYgKGwgPT0gJ0EnKSAge1xyXG4gICAgICAgIC8vIHJlc2l6ZSByYWRpaVxyXG4gICAgICAgIHRoaXMudmFsdWVbaV1bMV0gPSAodGhpcy52YWx1ZVtpXVsxXSAqIHdpZHRoKSAgLyBib3gud2lkdGhcclxuICAgICAgICB0aGlzLnZhbHVlW2ldWzJdID0gKHRoaXMudmFsdWVbaV1bMl0gKiBoZWlnaHQpIC8gYm94LmhlaWdodFxyXG5cclxuICAgICAgICAvLyBtb3ZlIHBvc2l0aW9uIHZhbHVlc1xyXG4gICAgICAgIHRoaXMudmFsdWVbaV1bNl0gPSAoKHRoaXMudmFsdWVbaV1bNl0gLSBib3gueCkgKiB3aWR0aCkgIC8gYm94LndpZHRoICArIGJveC54XHJcbiAgICAgICAgdGhpcy52YWx1ZVtpXVs3XSA9ICgodGhpcy52YWx1ZVtpXVs3XSAtIGJveC55KSAqIGhlaWdodCkgLyBib3guaGVpZ2h0ICsgYm94LnlcclxuICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuICAvLyBUZXN0IGlmIHRoZSBwYXNzZWQgcGF0aCBhcnJheSB1c2UgdGhlIHNhbWUgcGF0aCBkYXRhIGNvbW1hbmRzIGFzIHRoaXMgcGF0aCBhcnJheVxyXG4sIGVxdWFsQ29tbWFuZHM6IGZ1bmN0aW9uKHBhdGhBcnJheSkge1xyXG4gICAgdmFyIGksIGlsLCBlcXVhbENvbW1hbmRzXHJcblxyXG4gICAgcGF0aEFycmF5ID0gbmV3IFNWRy5QYXRoQXJyYXkocGF0aEFycmF5KVxyXG5cclxuICAgIGVxdWFsQ29tbWFuZHMgPSB0aGlzLnZhbHVlLmxlbmd0aCA9PT0gcGF0aEFycmF5LnZhbHVlLmxlbmd0aFxyXG4gICAgZm9yKGkgPSAwLCBpbCA9IHRoaXMudmFsdWUubGVuZ3RoOyBlcXVhbENvbW1hbmRzICYmIGkgPCBpbDsgaSsrKSB7XHJcbiAgICAgIGVxdWFsQ29tbWFuZHMgPSB0aGlzLnZhbHVlW2ldWzBdID09PSBwYXRoQXJyYXkudmFsdWVbaV1bMF1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZXF1YWxDb21tYW5kc1xyXG4gIH1cclxuICAvLyBNYWtlIHBhdGggYXJyYXkgbW9ycGhhYmxlXHJcbiwgbW9ycGg6IGZ1bmN0aW9uKHBhdGhBcnJheSkge1xyXG4gICAgcGF0aEFycmF5ID0gbmV3IFNWRy5QYXRoQXJyYXkocGF0aEFycmF5KVxyXG5cclxuICAgIGlmKHRoaXMuZXF1YWxDb21tYW5kcyhwYXRoQXJyYXkpKSB7XHJcbiAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBwYXRoQXJyYXlcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBudWxsXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcbiAgLy8gR2V0IG1vcnBoZWQgcGF0aCBhcnJheSBhdCBnaXZlbiBwb3NpdGlvblxyXG4sIGF0OiBmdW5jdGlvbihwb3MpIHtcclxuICAgIC8vIG1ha2Ugc3VyZSBhIGRlc3RpbmF0aW9uIGlzIGRlZmluZWRcclxuICAgIGlmICghdGhpcy5kZXN0aW5hdGlvbikgcmV0dXJuIHRoaXNcclxuXHJcbiAgICB2YXIgc291cmNlQXJyYXkgPSB0aGlzLnZhbHVlXHJcbiAgICAgICwgZGVzdGluYXRpb25BcnJheSA9IHRoaXMuZGVzdGluYXRpb24udmFsdWVcclxuICAgICAgLCBhcnJheSA9IFtdLCBwYXRoQXJyYXkgPSBuZXcgU1ZHLlBhdGhBcnJheSgpXHJcbiAgICAgICwgaSwgaWwsIGosIGpsXHJcblxyXG4gICAgLy8gQW5pbWF0ZSBoYXMgc3BlY2lmaWVkIGluIHRoZSBTVkcgc3BlY1xyXG4gICAgLy8gU2VlOiBodHRwczovL3d3dy53My5vcmcvVFIvU1ZHMTEvcGF0aHMuaHRtbCNQYXRoRWxlbWVudFxyXG4gICAgZm9yIChpID0gMCwgaWwgPSBzb3VyY2VBcnJheS5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XHJcbiAgICAgIGFycmF5W2ldID0gW3NvdXJjZUFycmF5W2ldWzBdXVxyXG4gICAgICBmb3IoaiA9IDEsIGpsID0gc291cmNlQXJyYXlbaV0ubGVuZ3RoOyBqIDwgamw7IGorKykge1xyXG4gICAgICAgIGFycmF5W2ldW2pdID0gc291cmNlQXJyYXlbaV1bal0gKyAoZGVzdGluYXRpb25BcnJheVtpXVtqXSAtIHNvdXJjZUFycmF5W2ldW2pdKSAqIHBvc1xyXG4gICAgICB9XHJcbiAgICAgIC8vIEZvciB0aGUgdHdvIGZsYWdzIG9mIHRoZSBlbGxpcHRpY2FsIGFyYyBjb21tYW5kLCB0aGUgU1ZHIHNwZWMgc2F5OlxyXG4gICAgICAvLyBGbGFncyBhbmQgYm9vbGVhbnMgYXJlIGludGVycG9sYXRlZCBhcyBmcmFjdGlvbnMgYmV0d2VlbiB6ZXJvIGFuZCBvbmUsIHdpdGggYW55IG5vbi16ZXJvIHZhbHVlIGNvbnNpZGVyZWQgdG8gYmUgYSB2YWx1ZSBvZiBvbmUvdHJ1ZVxyXG4gICAgICAvLyBFbGxpcHRpY2FsIGFyYyBjb21tYW5kIGFzIGFuIGFycmF5IGZvbGxvd2VkIGJ5IGNvcnJlc3BvbmRpbmcgaW5kZXhlczpcclxuICAgICAgLy8gWydBJywgcngsIHJ5LCB4LWF4aXMtcm90YXRpb24sIGxhcmdlLWFyYy1mbGFnLCBzd2VlcC1mbGFnLCB4LCB5XVxyXG4gICAgICAvLyAgIDAgICAgMSAgIDIgICAgICAgIDMgICAgICAgICAgICAgICAgIDQgICAgICAgICAgICAgNSAgICAgIDYgIDdcclxuICAgICAgaWYoYXJyYXlbaV1bMF0gPT09ICdBJykge1xyXG4gICAgICAgIGFycmF5W2ldWzRdID0gKyhhcnJheVtpXVs0XSAhPSAwKVxyXG4gICAgICAgIGFycmF5W2ldWzVdID0gKyhhcnJheVtpXVs1XSAhPSAwKVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRGlyZWN0bHkgbW9kaWZ5IHRoZSB2YWx1ZSBvZiBhIHBhdGggYXJyYXksIHRoaXMgaXMgZG9uZSB0aGlzIHdheSBmb3IgcGVyZm9ybWFuY2VcclxuICAgIHBhdGhBcnJheS52YWx1ZSA9IGFycmF5XHJcbiAgICByZXR1cm4gcGF0aEFycmF5XHJcbiAgfVxyXG4gIC8vIEFic29sdXRpemUgYW5kIHBhcnNlIHBhdGggdG8gYXJyYXlcclxuLCBwYXJzZTogZnVuY3Rpb24oYXJyYXkpIHtcclxuICAgIC8vIGlmIGl0J3MgYWxyZWFkeSBhIHBhdGhhcnJheSwgbm8gbmVlZCB0byBwYXJzZSBpdFxyXG4gICAgaWYgKGFycmF5IGluc3RhbmNlb2YgU1ZHLlBhdGhBcnJheSkgcmV0dXJuIGFycmF5LnZhbHVlT2YoKVxyXG5cclxuICAgIC8vIHByZXBhcmUgZm9yIHBhcnNpbmdcclxuICAgIHZhciBpLCB4MCwgeTAsIHMsIHNlZywgYXJyXHJcbiAgICAgICwgeCA9IDBcclxuICAgICAgLCB5ID0gMFxyXG4gICAgICAsIHBhcmFtQ250ID0geyAnTSc6MiwgJ0wnOjIsICdIJzoxLCAnVic6MSwgJ0MnOjYsICdTJzo0LCAnUSc6NCwgJ1QnOjIsICdBJzo3IH1cclxuXHJcbiAgICBpZih0eXBlb2YgYXJyYXkgPT0gJ3N0cmluZycpe1xyXG5cclxuICAgICAgYXJyYXkgPSBhcnJheVxyXG4gICAgICAgIC5yZXBsYWNlKFNWRy5yZWdleC5udW1iZXJzV2l0aERvdHMsIHBhdGhSZWdSZXBsYWNlKSAvLyBjb252ZXJ0IDQ1LjEyMy4xMjMgdG8gNDUuMTIzIC4xMjNcclxuICAgICAgICAucmVwbGFjZShTVkcucmVnZXgucGF0aExldHRlcnMsICcgJCYgJykgLy8gcHV0IHNvbWUgcm9vbSBiZXR3ZWVuIGxldHRlcnMgYW5kIG51bWJlcnNcclxuICAgICAgICAucmVwbGFjZShTVkcucmVnZXguaHlwaGVuLCAnJDEgLScpICAgICAgLy8gYWRkIHNwYWNlIGJlZm9yZSBoeXBoZW5cclxuICAgICAgICAudHJpbSgpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJpbVxyXG4gICAgICAgIC5zcGxpdChTVkcucmVnZXguZGVsaW1pdGVyKSAgIC8vIHNwbGl0IGludG8gYXJyYXlcclxuXHJcbiAgICB9ZWxzZXtcclxuICAgICAgYXJyYXkgPSBhcnJheS5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3Vycil7XHJcbiAgICAgICAgcmV0dXJuIFtdLmNvbmNhdC5jYWxsKHByZXYsIGN1cnIpXHJcbiAgICAgIH0sIFtdKVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGFycmF5IG5vdyBpcyBhbiBhcnJheSBjb250YWluaW5nIGFsbCBwYXJ0cyBvZiBhIHBhdGggZS5nLiBbJ00nLCAnMCcsICcwJywgJ0wnLCAnMzAnLCAnMzAnIC4uLl1cclxuXHJcbiAgICB2YXIgYXJyID0gW11cclxuXHJcbiAgICBkb3tcclxuXHJcbiAgICAgIC8vIFRlc3QgaWYgd2UgaGF2ZSBhIHBhdGggbGV0dGVyXHJcbiAgICAgIGlmKFNWRy5yZWdleC5pc1BhdGhMZXR0ZXIudGVzdChhcnJheVswXSkpe1xyXG4gICAgICAgIHMgPSBhcnJheVswXVxyXG4gICAgICAgIGFycmF5LnNoaWZ0KClcclxuICAgICAgLy8gSWYgbGFzdCBsZXR0ZXIgd2FzIGEgbW92ZSBjb21tYW5kIGFuZCB3ZSBnb3Qgbm8gbmV3LCBpdCBkZWZhdWx0cyB0byBbTF1pbmVcclxuICAgICAgfWVsc2UgaWYocyA9PSAnTScpe1xyXG4gICAgICAgIHMgPSAnTCdcclxuICAgICAgfWVsc2UgaWYocyA9PSAnbScpe1xyXG4gICAgICAgIHMgPSAnbCdcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gYWRkIHBhdGggbGV0dGVyIGFzIGZpcnN0IGVsZW1lbnRcclxuICAgICAgc2VnID0gW3MudG9VcHBlckNhc2UoKV1cclxuXHJcbiAgICAgIC8vIHB1c2ggYWxsIG5lY2Vzc2FyeSBwYXJhbWV0ZXJzIHRvIHNlZ21lbnRcclxuICAgICAgZm9yKGkgPSAwOyBpIDwgcGFyYW1DbnRbc2VnWzBdXTsgKytpKXtcclxuICAgICAgICBzZWcucHVzaChwYXJzZUZsb2F0KGFycmF5LnNoaWZ0KCkpKVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyB1cHBlciBjYXNlXHJcbiAgICAgIGlmKHMgPT0gc2VnWzBdKXtcclxuXHJcbiAgICAgICAgaWYocyA9PSAnTScgfHwgcyA9PSAnTCcgfHwgcyA9PSAnQycgfHwgcyA9PSAnUScgfHwgcyA9PSAnUycgfHwgcyA9PSAnVCcpe1xyXG4gICAgICAgICAgeCA9IHNlZ1twYXJhbUNudFtzZWdbMF1dLTFdXHJcbiAgICAgICAgICB5ID0gc2VnW3BhcmFtQ250W3NlZ1swXV1dXHJcbiAgICAgICAgfWVsc2UgaWYocyA9PSAnVicpe1xyXG4gICAgICAgICAgeSA9IHNlZ1sxXVxyXG4gICAgICAgIH1lbHNlIGlmKHMgPT0gJ0gnKXtcclxuICAgICAgICAgIHggPSBzZWdbMV1cclxuICAgICAgICB9ZWxzZSBpZihzID09ICdBJyl7XHJcbiAgICAgICAgICB4ID0gc2VnWzZdXHJcbiAgICAgICAgICB5ID0gc2VnWzddXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgLy8gbG93ZXIgY2FzZVxyXG4gICAgICB9ZWxzZXtcclxuXHJcbiAgICAgICAgLy8gY29udmVydCByZWxhdGl2ZSB0byBhYnNvbHV0ZSB2YWx1ZXNcclxuICAgICAgICBpZihzID09ICdtJyB8fCBzID09ICdsJyB8fCBzID09ICdjJyB8fCBzID09ICdzJyB8fCBzID09ICdxJyB8fCBzID09ICd0Jyl7XHJcblxyXG4gICAgICAgICAgc2VnWzFdICs9IHhcclxuICAgICAgICAgIHNlZ1syXSArPSB5XHJcblxyXG4gICAgICAgICAgaWYoc2VnWzNdICE9IG51bGwpe1xyXG4gICAgICAgICAgICBzZWdbM10gKz0geFxyXG4gICAgICAgICAgICBzZWdbNF0gKz0geVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmKHNlZ1s1XSAhPSBudWxsKXtcclxuICAgICAgICAgICAgc2VnWzVdICs9IHhcclxuICAgICAgICAgICAgc2VnWzZdICs9IHlcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBtb3ZlIHBvaW50ZXJcclxuICAgICAgICAgIHggPSBzZWdbcGFyYW1DbnRbc2VnWzBdXS0xXVxyXG4gICAgICAgICAgeSA9IHNlZ1twYXJhbUNudFtzZWdbMF1dXVxyXG5cclxuICAgICAgICB9ZWxzZSBpZihzID09ICd2Jyl7XHJcbiAgICAgICAgICBzZWdbMV0gKz0geVxyXG4gICAgICAgICAgeSA9IHNlZ1sxXVxyXG4gICAgICAgIH1lbHNlIGlmKHMgPT0gJ2gnKXtcclxuICAgICAgICAgIHNlZ1sxXSArPSB4XHJcbiAgICAgICAgICB4ID0gc2VnWzFdXHJcbiAgICAgICAgfWVsc2UgaWYocyA9PSAnYScpe1xyXG4gICAgICAgICAgc2VnWzZdICs9IHhcclxuICAgICAgICAgIHNlZ1s3XSArPSB5XHJcbiAgICAgICAgICB4ID0gc2VnWzZdXHJcbiAgICAgICAgICB5ID0gc2VnWzddXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYoc2VnWzBdID09ICdNJyl7XHJcbiAgICAgICAgeDAgPSB4XHJcbiAgICAgICAgeTAgPSB5XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmKHNlZ1swXSA9PSAnWicpe1xyXG4gICAgICAgIHggPSB4MFxyXG4gICAgICAgIHkgPSB5MFxyXG4gICAgICB9XHJcblxyXG4gICAgICBhcnIucHVzaChzZWcpXHJcblxyXG4gICAgfXdoaWxlKGFycmF5Lmxlbmd0aClcclxuXHJcbiAgICByZXR1cm4gYXJyXHJcblxyXG4gIH1cclxuICAvLyBHZXQgYm91bmRpbmcgYm94IG9mIHBhdGhcclxuLCBiYm94OiBmdW5jdGlvbigpIHtcclxuICAgIFNWRy5wYXJzZXIucGF0aC5zZXRBdHRyaWJ1dGUoJ2QnLCB0aGlzLnRvU3RyaW5nKCkpXHJcblxyXG4gICAgcmV0dXJuIFNWRy5wYXJzZXIucGF0aC5nZXRCQm94KClcclxuICB9XHJcblxyXG59KVxyXG5cbi8vIE1vZHVsZSBmb3IgdW5pdCBjb252ZXJ0aW9uc1xyXG5TVkcuTnVtYmVyID0gU1ZHLmludmVudCh7XHJcbiAgLy8gSW5pdGlhbGl6ZVxyXG4gIGNyZWF0ZTogZnVuY3Rpb24odmFsdWUsIHVuaXQpIHtcclxuICAgIC8vIGluaXRpYWxpemUgZGVmYXVsdHNcclxuICAgIHRoaXMudmFsdWUgPSAwXHJcbiAgICB0aGlzLnVuaXQgID0gdW5pdCB8fCAnJ1xyXG5cclxuICAgIC8vIHBhcnNlIHZhbHVlXHJcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xyXG4gICAgICAvLyBlbnN1cmUgYSB2YWxpZCBudW1lcmljIHZhbHVlXHJcbiAgICAgIHRoaXMudmFsdWUgPSBpc05hTih2YWx1ZSkgPyAwIDogIWlzRmluaXRlKHZhbHVlKSA/ICh2YWx1ZSA8IDAgPyAtMy40ZSszOCA6ICszLjRlKzM4KSA6IHZhbHVlXHJcblxyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIHVuaXQgPSB2YWx1ZS5tYXRjaChTVkcucmVnZXgubnVtYmVyQW5kVW5pdClcclxuXHJcbiAgICAgIGlmICh1bml0KSB7XHJcbiAgICAgICAgLy8gbWFrZSB2YWx1ZSBudW1lcmljXHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHBhcnNlRmxvYXQodW5pdFsxXSlcclxuXHJcbiAgICAgICAgLy8gbm9ybWFsaXplXHJcbiAgICAgICAgaWYgKHVuaXRbNV0gPT0gJyUnKVxyXG4gICAgICAgICAgdGhpcy52YWx1ZSAvPSAxMDBcclxuICAgICAgICBlbHNlIGlmICh1bml0WzVdID09ICdzJylcclxuICAgICAgICAgIHRoaXMudmFsdWUgKj0gMTAwMFxyXG5cclxuICAgICAgICAvLyBzdG9yZSB1bml0XHJcbiAgICAgICAgdGhpcy51bml0ID0gdW5pdFs1XVxyXG4gICAgICB9XHJcblxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU1ZHLk51bWJlcikge1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZS52YWx1ZU9mKClcclxuICAgICAgICB0aGlzLnVuaXQgID0gdmFsdWUudW5pdFxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gIH1cclxuICAvLyBBZGQgbWV0aG9kc1xyXG4sIGV4dGVuZDoge1xyXG4gICAgLy8gU3RyaW5nYWxpemVcclxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIChcclxuICAgICAgICB0aGlzLnVuaXQgPT0gJyUnID9cclxuICAgICAgICAgIH5+KHRoaXMudmFsdWUgKiAxZTgpIC8gMWU2OlxyXG4gICAgICAgIHRoaXMudW5pdCA9PSAncycgP1xyXG4gICAgICAgICAgdGhpcy52YWx1ZSAvIDFlMyA6XHJcbiAgICAgICAgICB0aGlzLnZhbHVlXHJcbiAgICAgICkgKyB0aGlzLnVuaXRcclxuICAgIH1cclxuICAsIHRvSlNPTjogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKClcclxuICAgIH1cclxuICAsIC8vIENvbnZlcnQgdG8gcHJpbWl0aXZlXHJcbiAgICB2YWx1ZU9mOiBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIHRoaXMudmFsdWVcclxuICAgIH1cclxuICAgIC8vIEFkZCBudW1iZXJcclxuICAsIHBsdXM6IGZ1bmN0aW9uKG51bWJlcikge1xyXG4gICAgICBudW1iZXIgPSBuZXcgU1ZHLk51bWJlcihudW1iZXIpXHJcbiAgICAgIHJldHVybiBuZXcgU1ZHLk51bWJlcih0aGlzICsgbnVtYmVyLCB0aGlzLnVuaXQgfHwgbnVtYmVyLnVuaXQpXHJcbiAgICB9XHJcbiAgICAvLyBTdWJ0cmFjdCBudW1iZXJcclxuICAsIG1pbnVzOiBmdW5jdGlvbihudW1iZXIpIHtcclxuICAgICAgbnVtYmVyID0gbmV3IFNWRy5OdW1iZXIobnVtYmVyKVxyXG4gICAgICByZXR1cm4gbmV3IFNWRy5OdW1iZXIodGhpcyAtIG51bWJlciwgdGhpcy51bml0IHx8IG51bWJlci51bml0KVxyXG4gICAgfVxyXG4gICAgLy8gTXVsdGlwbHkgbnVtYmVyXHJcbiAgLCB0aW1lczogZnVuY3Rpb24obnVtYmVyKSB7XHJcbiAgICAgIG51bWJlciA9IG5ldyBTVkcuTnVtYmVyKG51bWJlcilcclxuICAgICAgcmV0dXJuIG5ldyBTVkcuTnVtYmVyKHRoaXMgKiBudW1iZXIsIHRoaXMudW5pdCB8fCBudW1iZXIudW5pdClcclxuICAgIH1cclxuICAgIC8vIERpdmlkZSBudW1iZXJcclxuICAsIGRpdmlkZTogZnVuY3Rpb24obnVtYmVyKSB7XHJcbiAgICAgIG51bWJlciA9IG5ldyBTVkcuTnVtYmVyKG51bWJlcilcclxuICAgICAgcmV0dXJuIG5ldyBTVkcuTnVtYmVyKHRoaXMgLyBudW1iZXIsIHRoaXMudW5pdCB8fCBudW1iZXIudW5pdClcclxuICAgIH1cclxuICAgIC8vIENvbnZlcnQgdG8gZGlmZmVyZW50IHVuaXRcclxuICAsIHRvOiBmdW5jdGlvbih1bml0KSB7XHJcbiAgICAgIHZhciBudW1iZXIgPSBuZXcgU1ZHLk51bWJlcih0aGlzKVxyXG5cclxuICAgICAgaWYgKHR5cGVvZiB1bml0ID09PSAnc3RyaW5nJylcclxuICAgICAgICBudW1iZXIudW5pdCA9IHVuaXRcclxuXHJcbiAgICAgIHJldHVybiBudW1iZXJcclxuICAgIH1cclxuICAgIC8vIE1ha2UgbnVtYmVyIG1vcnBoYWJsZVxyXG4gICwgbW9ycGg6IGZ1bmN0aW9uKG51bWJlcikge1xyXG4gICAgICB0aGlzLmRlc3RpbmF0aW9uID0gbmV3IFNWRy5OdW1iZXIobnVtYmVyKVxyXG5cclxuICAgICAgaWYobnVtYmVyLnJlbGF0aXZlKSB7XHJcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi52YWx1ZSArPSB0aGlzLnZhbHVlXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcbiAgICAvLyBHZXQgbW9ycGhlZCBudW1iZXIgYXQgZ2l2ZW4gcG9zaXRpb25cclxuICAsIGF0OiBmdW5jdGlvbihwb3MpIHtcclxuICAgICAgLy8gTWFrZSBzdXJlIGEgZGVzdGluYXRpb24gaXMgZGVmaW5lZFxyXG4gICAgICBpZiAoIXRoaXMuZGVzdGluYXRpb24pIHJldHVybiB0aGlzXHJcblxyXG4gICAgICAvLyBHZW5lcmF0ZSBuZXcgbW9ycGhlZCBudW1iZXJcclxuICAgICAgcmV0dXJuIG5ldyBTVkcuTnVtYmVyKHRoaXMuZGVzdGluYXRpb24pXHJcbiAgICAgICAgICAubWludXModGhpcylcclxuICAgICAgICAgIC50aW1lcyhwb3MpXHJcbiAgICAgICAgICAucGx1cyh0aGlzKVxyXG4gICAgfVxyXG5cclxuICB9XHJcbn0pXHJcblxuXHJcblNWRy5FbGVtZW50ID0gU1ZHLmludmVudCh7XHJcbiAgLy8gSW5pdGlhbGl6ZSBub2RlXHJcbiAgY3JlYXRlOiBmdW5jdGlvbihub2RlKSB7XHJcbiAgICAvLyBtYWtlIHN0cm9rZSB2YWx1ZSBhY2Nlc3NpYmxlIGR5bmFtaWNhbGx5XHJcbiAgICB0aGlzLl9zdHJva2UgPSBTVkcuZGVmYXVsdHMuYXR0cnMuc3Ryb2tlXHJcbiAgICB0aGlzLl9ldmVudCA9IG51bGxcclxuXHJcbiAgICAvLyBpbml0aWFsaXplIGRhdGEgb2JqZWN0XHJcbiAgICB0aGlzLmRvbSA9IHt9XHJcblxyXG4gICAgLy8gY3JlYXRlIGNpcmN1bGFyIHJlZmVyZW5jZVxyXG4gICAgaWYgKHRoaXMubm9kZSA9IG5vZGUpIHtcclxuICAgICAgdGhpcy50eXBlID0gbm9kZS5ub2RlTmFtZVxyXG4gICAgICB0aGlzLm5vZGUuaW5zdGFuY2UgPSB0aGlzXHJcblxyXG4gICAgICAvLyBzdG9yZSBjdXJyZW50IGF0dHJpYnV0ZSB2YWx1ZVxyXG4gICAgICB0aGlzLl9zdHJva2UgPSBub2RlLmdldEF0dHJpYnV0ZSgnc3Ryb2tlJykgfHwgdGhpcy5fc3Ryb2tlXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBBZGQgY2xhc3MgbWV0aG9kc1xyXG4sIGV4dGVuZDoge1xyXG4gICAgLy8gTW92ZSBvdmVyIHgtYXhpc1xyXG4gICAgeDogZnVuY3Rpb24oeCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5hdHRyKCd4JywgeClcclxuICAgIH1cclxuICAgIC8vIE1vdmUgb3ZlciB5LWF4aXNcclxuICAsIHk6IGZ1bmN0aW9uKHkpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuYXR0cigneScsIHkpXHJcbiAgICB9XHJcbiAgICAvLyBNb3ZlIGJ5IGNlbnRlciBvdmVyIHgtYXhpc1xyXG4gICwgY3g6IGZ1bmN0aW9uKHgpIHtcclxuICAgICAgcmV0dXJuIHggPT0gbnVsbCA/IHRoaXMueCgpICsgdGhpcy53aWR0aCgpIC8gMiA6IHRoaXMueCh4IC0gdGhpcy53aWR0aCgpIC8gMilcclxuICAgIH1cclxuICAgIC8vIE1vdmUgYnkgY2VudGVyIG92ZXIgeS1heGlzXHJcbiAgLCBjeTogZnVuY3Rpb24oeSkge1xyXG4gICAgICByZXR1cm4geSA9PSBudWxsID8gdGhpcy55KCkgKyB0aGlzLmhlaWdodCgpIC8gMiA6IHRoaXMueSh5IC0gdGhpcy5oZWlnaHQoKSAvIDIpXHJcbiAgICB9XHJcbiAgICAvLyBNb3ZlIGVsZW1lbnQgdG8gZ2l2ZW4geCBhbmQgeSB2YWx1ZXNcclxuICAsIG1vdmU6IGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgICAgcmV0dXJuIHRoaXMueCh4KS55KHkpXHJcbiAgICB9XHJcbiAgICAvLyBNb3ZlIGVsZW1lbnQgYnkgaXRzIGNlbnRlclxyXG4gICwgY2VudGVyOiBmdW5jdGlvbih4LCB5KSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmN4KHgpLmN5KHkpXHJcbiAgICB9XHJcbiAgICAvLyBTZXQgd2lkdGggb2YgZWxlbWVudFxyXG4gICwgd2lkdGg6IGZ1bmN0aW9uKHdpZHRoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmF0dHIoJ3dpZHRoJywgd2lkdGgpXHJcbiAgICB9XHJcbiAgICAvLyBTZXQgaGVpZ2h0IG9mIGVsZW1lbnRcclxuICAsIGhlaWdodDogZnVuY3Rpb24oaGVpZ2h0KSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmF0dHIoJ2hlaWdodCcsIGhlaWdodClcclxuICAgIH1cclxuICAgIC8vIFNldCBlbGVtZW50IHNpemUgdG8gZ2l2ZW4gd2lkdGggYW5kIGhlaWdodFxyXG4gICwgc2l6ZTogZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xyXG4gICAgICB2YXIgcCA9IHByb3BvcnRpb25hbFNpemUodGhpcywgd2lkdGgsIGhlaWdodClcclxuXHJcbiAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgLndpZHRoKG5ldyBTVkcuTnVtYmVyKHAud2lkdGgpKVxyXG4gICAgICAgIC5oZWlnaHQobmV3IFNWRy5OdW1iZXIocC5oZWlnaHQpKVxyXG4gICAgfVxyXG4gICAgLy8gQ2xvbmUgZWxlbWVudFxyXG4gICwgY2xvbmU6IGZ1bmN0aW9uKHBhcmVudCwgd2l0aERhdGEpIHtcclxuICAgICAgLy8gd3JpdGUgZG9tIGRhdGEgdG8gdGhlIGRvbSBzbyB0aGUgY2xvbmUgY2FuIHBpY2t1cCB0aGUgZGF0YVxyXG4gICAgICB0aGlzLndyaXRlRGF0YVRvRG9tKClcclxuXHJcbiAgICAgIC8vIGNsb25lIGVsZW1lbnQgYW5kIGFzc2lnbiBuZXcgaWRcclxuICAgICAgdmFyIGNsb25lID0gYXNzaWduTmV3SWQodGhpcy5ub2RlLmNsb25lTm9kZSh0cnVlKSlcclxuXHJcbiAgICAgIC8vIGluc2VydCB0aGUgY2xvbmUgaW4gdGhlIGdpdmVuIHBhcmVudCBvciBhZnRlciBteXNlbGZcclxuICAgICAgaWYocGFyZW50KSBwYXJlbnQuYWRkKGNsb25lKVxyXG4gICAgICBlbHNlIHRoaXMuYWZ0ZXIoY2xvbmUpXHJcblxyXG4gICAgICByZXR1cm4gY2xvbmVcclxuICAgIH1cclxuICAgIC8vIFJlbW92ZSBlbGVtZW50XHJcbiAgLCByZW1vdmU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICBpZiAodGhpcy5wYXJlbnQoKSlcclxuICAgICAgICB0aGlzLnBhcmVudCgpLnJlbW92ZUVsZW1lbnQodGhpcylcclxuXHJcbiAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcbiAgICAvLyBSZXBsYWNlIGVsZW1lbnRcclxuICAsIHJlcGxhY2U6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuICAgICAgdGhpcy5hZnRlcihlbGVtZW50KS5yZW1vdmUoKVxyXG5cclxuICAgICAgcmV0dXJuIGVsZW1lbnRcclxuICAgIH1cclxuICAgIC8vIEFkZCBlbGVtZW50IHRvIGdpdmVuIGNvbnRhaW5lciBhbmQgcmV0dXJuIHNlbGZcclxuICAsIGFkZFRvOiBmdW5jdGlvbihwYXJlbnQpIHtcclxuICAgICAgcmV0dXJuIHBhcmVudC5wdXQodGhpcylcclxuICAgIH1cclxuICAgIC8vIEFkZCBlbGVtZW50IHRvIGdpdmVuIGNvbnRhaW5lciBhbmQgcmV0dXJuIGNvbnRhaW5lclxyXG4gICwgcHV0SW46IGZ1bmN0aW9uKHBhcmVudCkge1xyXG4gICAgICByZXR1cm4gcGFyZW50LmFkZCh0aGlzKVxyXG4gICAgfVxyXG4gICAgLy8gR2V0IC8gc2V0IGlkXHJcbiAgLCBpZDogZnVuY3Rpb24oaWQpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuYXR0cignaWQnLCBpZClcclxuICAgIH1cclxuICAgIC8vIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBwb2ludCBpbnNpZGUgdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgZWxlbWVudFxyXG4gICwgaW5zaWRlOiBmdW5jdGlvbih4LCB5KSB7XHJcbiAgICAgIHZhciBib3ggPSB0aGlzLmJib3goKVxyXG5cclxuICAgICAgcmV0dXJuIHggPiBib3gueFxyXG4gICAgICAgICAgJiYgeSA+IGJveC55XHJcbiAgICAgICAgICAmJiB4IDwgYm94LnggKyBib3gud2lkdGhcclxuICAgICAgICAgICYmIHkgPCBib3gueSArIGJveC5oZWlnaHRcclxuICAgIH1cclxuICAgIC8vIFNob3cgZWxlbWVudFxyXG4gICwgc2hvdzogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnN0eWxlKCdkaXNwbGF5JywgJycpXHJcbiAgICB9XHJcbiAgICAvLyBIaWRlIGVsZW1lbnRcclxuICAsIGhpZGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5zdHlsZSgnZGlzcGxheScsICdub25lJylcclxuICAgIH1cclxuICAgIC8vIElzIGVsZW1lbnQgdmlzaWJsZT9cclxuICAsIHZpc2libGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5zdHlsZSgnZGlzcGxheScpICE9ICdub25lJ1xyXG4gICAgfVxyXG4gICAgLy8gUmV0dXJuIGlkIG9uIHN0cmluZyBjb252ZXJzaW9uXHJcbiAgLCB0b1N0cmluZzogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmF0dHIoJ2lkJylcclxuICAgIH1cclxuICAgIC8vIFJldHVybiBhcnJheSBvZiBjbGFzc2VzIG9uIHRoZSBub2RlXHJcbiAgLCBjbGFzc2VzOiBmdW5jdGlvbigpIHtcclxuICAgICAgdmFyIGF0dHIgPSB0aGlzLmF0dHIoJ2NsYXNzJylcclxuXHJcbiAgICAgIHJldHVybiBhdHRyID09IG51bGwgPyBbXSA6IGF0dHIudHJpbSgpLnNwbGl0KFNWRy5yZWdleC5kZWxpbWl0ZXIpXHJcbiAgICB9XHJcbiAgICAvLyBSZXR1cm4gdHJ1ZSBpZiBjbGFzcyBleGlzdHMgb24gdGhlIG5vZGUsIGZhbHNlIG90aGVyd2lzZVxyXG4gICwgaGFzQ2xhc3M6IGZ1bmN0aW9uKG5hbWUpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuY2xhc3NlcygpLmluZGV4T2YobmFtZSkgIT0gLTFcclxuICAgIH1cclxuICAgIC8vIEFkZCBjbGFzcyB0byB0aGUgbm9kZVxyXG4gICwgYWRkQ2xhc3M6IGZ1bmN0aW9uKG5hbWUpIHtcclxuICAgICAgaWYgKCF0aGlzLmhhc0NsYXNzKG5hbWUpKSB7XHJcbiAgICAgICAgdmFyIGFycmF5ID0gdGhpcy5jbGFzc2VzKClcclxuICAgICAgICBhcnJheS5wdXNoKG5hbWUpXHJcbiAgICAgICAgdGhpcy5hdHRyKCdjbGFzcycsIGFycmF5LmpvaW4oJyAnKSlcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuICAgIC8vIFJlbW92ZSBjbGFzcyBmcm9tIHRoZSBub2RlXHJcbiAgLCByZW1vdmVDbGFzczogZnVuY3Rpb24obmFtZSkge1xyXG4gICAgICBpZiAodGhpcy5oYXNDbGFzcyhuYW1lKSkge1xyXG4gICAgICAgIHRoaXMuYXR0cignY2xhc3MnLCB0aGlzLmNsYXNzZXMoKS5maWx0ZXIoZnVuY3Rpb24oYykge1xyXG4gICAgICAgICAgcmV0dXJuIGMgIT0gbmFtZVxyXG4gICAgICAgIH0pLmpvaW4oJyAnKSlcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuICAgIC8vIFRvZ2dsZSB0aGUgcHJlc2VuY2Ugb2YgYSBjbGFzcyBvbiB0aGUgbm9kZVxyXG4gICwgdG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uKG5hbWUpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuaGFzQ2xhc3MobmFtZSkgPyB0aGlzLnJlbW92ZUNsYXNzKG5hbWUpIDogdGhpcy5hZGRDbGFzcyhuYW1lKVxyXG4gICAgfVxyXG4gICAgLy8gR2V0IHJlZmVyZW5jZWQgZWxlbWVudCBmb3JtIGF0dHJpYnV0ZSB2YWx1ZVxyXG4gICwgcmVmZXJlbmNlOiBmdW5jdGlvbihhdHRyKSB7XHJcbiAgICAgIHJldHVybiBTVkcuZ2V0KHRoaXMuYXR0cihhdHRyKSlcclxuICAgIH1cclxuICAgIC8vIFJldHVybnMgdGhlIHBhcmVudCBlbGVtZW50IGluc3RhbmNlXHJcbiAgLCBwYXJlbnQ6IGZ1bmN0aW9uKHR5cGUpIHtcclxuICAgICAgdmFyIHBhcmVudCA9IHRoaXNcclxuXHJcbiAgICAgIC8vIGNoZWNrIGZvciBwYXJlbnRcclxuICAgICAgaWYoIXBhcmVudC5ub2RlLnBhcmVudE5vZGUpIHJldHVybiBudWxsXHJcblxyXG4gICAgICAvLyBnZXQgcGFyZW50IGVsZW1lbnRcclxuICAgICAgcGFyZW50ID0gU1ZHLmFkb3B0KHBhcmVudC5ub2RlLnBhcmVudE5vZGUpXHJcblxyXG4gICAgICBpZighdHlwZSkgcmV0dXJuIHBhcmVudFxyXG5cclxuICAgICAgLy8gbG9vcCB0cm91Z2ggYW5jZXN0b3JzIGlmIHR5cGUgaXMgZ2l2ZW5cclxuICAgICAgd2hpbGUocGFyZW50ICYmIHBhcmVudC5ub2RlIGluc3RhbmNlb2Ygd2luZG93LlNWR0VsZW1lbnQpe1xyXG4gICAgICAgIGlmKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyA/IHBhcmVudC5tYXRjaGVzKHR5cGUpIDogcGFyZW50IGluc3RhbmNlb2YgdHlwZSkgcmV0dXJuIHBhcmVudFxyXG4gICAgICAgIHBhcmVudCA9IFNWRy5hZG9wdChwYXJlbnQubm9kZS5wYXJlbnROb2RlKVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBHZXQgcGFyZW50IGRvY3VtZW50XHJcbiAgLCBkb2M6IGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIFNWRy5Eb2MgPyB0aGlzIDogdGhpcy5wYXJlbnQoU1ZHLkRvYylcclxuICAgIH1cclxuICAgIC8vIHJldHVybiBhcnJheSBvZiBhbGwgYW5jZXN0b3JzIG9mIGdpdmVuIHR5cGUgdXAgdG8gdGhlIHJvb3Qgc3ZnXHJcbiAgLCBwYXJlbnRzOiBmdW5jdGlvbih0eXBlKSB7XHJcbiAgICAgIHZhciBwYXJlbnRzID0gW10sIHBhcmVudCA9IHRoaXNcclxuXHJcbiAgICAgIGRve1xyXG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQodHlwZSlcclxuICAgICAgICBpZighcGFyZW50IHx8ICFwYXJlbnQubm9kZSkgYnJlYWtcclxuXHJcbiAgICAgICAgcGFyZW50cy5wdXNoKHBhcmVudClcclxuICAgICAgfSB3aGlsZShwYXJlbnQucGFyZW50KVxyXG5cclxuICAgICAgcmV0dXJuIHBhcmVudHNcclxuICAgIH1cclxuICAgIC8vIG1hdGNoZXMgdGhlIGVsZW1lbnQgdnMgYSBjc3Mgc2VsZWN0b3JcclxuICAsIG1hdGNoZXM6IGZ1bmN0aW9uKHNlbGVjdG9yKXtcclxuICAgICAgcmV0dXJuIG1hdGNoZXModGhpcy5ub2RlLCBzZWxlY3RvcilcclxuICAgIH1cclxuICAgIC8vIFJldHVybnMgdGhlIHN2ZyBub2RlIHRvIGNhbGwgbmF0aXZlIHN2ZyBtZXRob2RzIG9uIGl0XHJcbiAgLCBuYXRpdmU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5ub2RlXHJcbiAgICB9XHJcbiAgICAvLyBJbXBvcnQgcmF3IHN2Z1xyXG4gICwgc3ZnOiBmdW5jdGlvbihzdmcpIHtcclxuICAgICAgLy8gY3JlYXRlIHRlbXBvcmFyeSBob2xkZXJcclxuICAgICAgdmFyIHdlbGwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdmcnKVxyXG5cclxuICAgICAgLy8gYWN0IGFzIGEgc2V0dGVyIGlmIHN2ZyBpcyBnaXZlblxyXG4gICAgICBpZiAoc3ZnICYmIHRoaXMgaW5zdGFuY2VvZiBTVkcuUGFyZW50KSB7XHJcbiAgICAgICAgLy8gZHVtcCByYXcgc3ZnXHJcbiAgICAgICAgd2VsbC5pbm5lckhUTUwgPSAnPHN2Zz4nICsgc3ZnLnJlcGxhY2UoL1xcbi8sICcnKS5yZXBsYWNlKC88KFxcdyspKFtePF0rPylcXC8+L2csICc8JDEkMj48LyQxPicpICsgJzwvc3ZnPidcclxuXHJcbiAgICAgICAgLy8gdHJhbnNwbGFudCBub2Rlc1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IHdlbGwuZmlyc3RDaGlsZC5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGlsOyBpKyspXHJcbiAgICAgICAgICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQod2VsbC5maXJzdENoaWxkLmZpcnN0Q2hpbGQpXHJcblxyXG4gICAgICAvLyBvdGhlcndpc2UgYWN0IGFzIGEgZ2V0dGVyXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gY3JlYXRlIGEgd3JhcHBpbmcgc3ZnIGVsZW1lbnQgaW4gY2FzZSBvZiBwYXJ0aWFsIGNvbnRlbnRcclxuICAgICAgICB3ZWxsLmFwcGVuZENoaWxkKHN2ZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N2ZycpKVxyXG5cclxuICAgICAgICAvLyB3cml0ZSBzdmdqcyBkYXRhIHRvIHRoZSBkb21cclxuICAgICAgICB0aGlzLndyaXRlRGF0YVRvRG9tKClcclxuXHJcbiAgICAgICAgLy8gaW5zZXJ0IGEgY29weSBvZiB0aGlzIG5vZGVcclxuICAgICAgICBzdmcuYXBwZW5kQ2hpbGQodGhpcy5ub2RlLmNsb25lTm9kZSh0cnVlKSlcclxuXHJcbiAgICAgICAgLy8gcmV0dXJuIHRhcmdldCBlbGVtZW50XHJcbiAgICAgICAgcmV0dXJuIHdlbGwuaW5uZXJIVE1MLnJlcGxhY2UoL148c3ZnPi8sICcnKS5yZXBsYWNlKC88XFwvc3ZnPiQvLCAnJylcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuICAvLyB3cml0ZSBzdmdqcyBkYXRhIHRvIHRoZSBkb21cclxuICAsIHdyaXRlRGF0YVRvRG9tOiBmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgIC8vIGR1bXAgdmFyaWFibGVzIHJlY3Vyc2l2ZWx5XHJcbiAgICAgIGlmKHRoaXMuZWFjaCB8fCB0aGlzLmxpbmVzKXtcclxuICAgICAgICB2YXIgZm4gPSB0aGlzLmVhY2ggPyB0aGlzIDogdGhpcy5saW5lcygpO1xyXG4gICAgICAgIGZuLmVhY2goZnVuY3Rpb24oKXtcclxuICAgICAgICAgIHRoaXMud3JpdGVEYXRhVG9Eb20oKVxyXG4gICAgICAgIH0pXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHJlbW92ZSBwcmV2aW91c2x5IHNldCBkYXRhXHJcbiAgICAgIHRoaXMubm9kZS5yZW1vdmVBdHRyaWJ1dGUoJ3N2Z2pzOmRhdGEnKVxyXG5cclxuICAgICAgaWYoT2JqZWN0LmtleXModGhpcy5kb20pLmxlbmd0aClcclxuICAgICAgICB0aGlzLm5vZGUuc2V0QXR0cmlidXRlKCdzdmdqczpkYXRhJywgSlNPTi5zdHJpbmdpZnkodGhpcy5kb20pKSAvLyBzZWUgIzQyOFxyXG5cclxuICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuICAvLyBzZXQgZ2l2ZW4gZGF0YSB0byB0aGUgZWxlbWVudHMgZGF0YSBwcm9wZXJ0eVxyXG4gICwgc2V0RGF0YTogZnVuY3Rpb24obyl7XHJcbiAgICAgIHRoaXMuZG9tID0gb1xyXG4gICAgICByZXR1cm4gdGhpc1xyXG4gICAgfVxyXG4gICwgaXM6IGZ1bmN0aW9uKG9iail7XHJcbiAgICAgIHJldHVybiBpcyh0aGlzLCBvYmopXHJcbiAgICB9XHJcbiAgfVxyXG59KVxyXG5cblNWRy5lYXNpbmcgPSB7XHJcbiAgJy0nOiBmdW5jdGlvbihwb3Mpe3JldHVybiBwb3N9XHJcbiwgJzw+JzpmdW5jdGlvbihwb3Mpe3JldHVybiAtTWF0aC5jb3MocG9zICogTWF0aC5QSSkgLyAyICsgMC41fVxyXG4sICc+JzogZnVuY3Rpb24ocG9zKXtyZXR1cm4gIE1hdGguc2luKHBvcyAqIE1hdGguUEkgLyAyKX1cclxuLCAnPCc6IGZ1bmN0aW9uKHBvcyl7cmV0dXJuIC1NYXRoLmNvcyhwb3MgKiBNYXRoLlBJIC8gMikgKyAxfVxyXG59XHJcblxyXG5TVkcubW9ycGggPSBmdW5jdGlvbihwb3Mpe1xyXG4gIHJldHVybiBmdW5jdGlvbihmcm9tLCB0bykge1xyXG4gICAgcmV0dXJuIG5ldyBTVkcuTW9ycGhPYmooZnJvbSwgdG8pLmF0KHBvcylcclxuICB9XHJcbn1cclxuXHJcblNWRy5TaXR1YXRpb24gPSBTVkcuaW52ZW50KHtcclxuXHJcbiAgY3JlYXRlOiBmdW5jdGlvbihvKXtcclxuICAgIHRoaXMuaW5pdCA9IGZhbHNlXHJcbiAgICB0aGlzLnJldmVyc2VkID0gZmFsc2VcclxuICAgIHRoaXMucmV2ZXJzaW5nID0gZmFsc2VcclxuXHJcbiAgICB0aGlzLmR1cmF0aW9uID0gbmV3IFNWRy5OdW1iZXIoby5kdXJhdGlvbikudmFsdWVPZigpXHJcbiAgICB0aGlzLmRlbGF5ID0gbmV3IFNWRy5OdW1iZXIoby5kZWxheSkudmFsdWVPZigpXHJcblxyXG4gICAgdGhpcy5zdGFydCA9ICtuZXcgRGF0ZSgpICsgdGhpcy5kZWxheVxyXG4gICAgdGhpcy5maW5pc2ggPSB0aGlzLnN0YXJ0ICsgdGhpcy5kdXJhdGlvblxyXG4gICAgdGhpcy5lYXNlID0gby5lYXNlXHJcblxyXG4gICAgLy8gdGhpcy5sb29wIGlzIGluY3JlbWVudGVkIGZyb20gMCB0byB0aGlzLmxvb3BzXHJcbiAgICAvLyBpdCBpcyBhbHNvIGluY3JlbWVudGVkIHdoZW4gaW4gYW4gaW5maW5pdGUgbG9vcCAod2hlbiB0aGlzLmxvb3BzIGlzIHRydWUpXHJcbiAgICB0aGlzLmxvb3AgPSAwXHJcbiAgICB0aGlzLmxvb3BzID0gZmFsc2VcclxuXHJcbiAgICB0aGlzLmFuaW1hdGlvbnMgPSB7XHJcbiAgICAgIC8vIGZ1bmN0aW9uVG9DYWxsOiBbbGlzdCBvZiBtb3JwaGFibGUgb2JqZWN0c11cclxuICAgICAgLy8gZS5nLiBtb3ZlOiBbU1ZHLk51bWJlciwgU1ZHLk51bWJlcl1cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmF0dHJzID0ge1xyXG4gICAgICAvLyBob2xkcyBhbGwgYXR0cmlidXRlcyB3aGljaCBhcmUgbm90IHJlcHJlc2VudGVkIGZyb20gYSBmdW5jdGlvbiBzdmcuanMgcHJvdmlkZXNcclxuICAgICAgLy8gZS5nLiBzb21lQXR0cjogU1ZHLk51bWJlclxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuc3R5bGVzID0ge1xyXG4gICAgICAvLyBob2xkcyBhbGwgc3R5bGVzIHdoaWNoIHNob3VsZCBiZSBhbmltYXRlZFxyXG4gICAgICAvLyBlLmcuIGZpbGwtY29sb3I6IFNWRy5Db2xvclxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMudHJhbnNmb3JtcyA9IFtcclxuICAgICAgLy8gaG9sZHMgYWxsIHRyYW5zZm9ybWF0aW9ucyBhcyB0cmFuc2Zvcm1hdGlvbiBvYmplY3RzXHJcbiAgICAgIC8vIGUuZy4gW1NWRy5Sb3RhdGUsIFNWRy5UcmFuc2xhdGUsIFNWRy5NYXRyaXhdXHJcbiAgICBdXHJcblxyXG4gICAgdGhpcy5vbmNlID0ge1xyXG4gICAgICAvLyBmdW5jdGlvbnMgdG8gZmlyZSBhdCBhIHNwZWNpZmljIHBvc2l0aW9uXHJcbiAgICAgIC8vIGUuZy4gXCIwLjVcIjogZnVuY3Rpb24gZm9vKCl7fVxyXG4gICAgfVxyXG5cclxuICB9XHJcblxyXG59KVxyXG5cclxuXHJcblNWRy5GWCA9IFNWRy5pbnZlbnQoe1xyXG5cclxuICBjcmVhdGU6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuICAgIHRoaXMuX3RhcmdldCA9IGVsZW1lbnRcclxuICAgIHRoaXMuc2l0dWF0aW9ucyA9IFtdXHJcbiAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlXHJcbiAgICB0aGlzLnNpdHVhdGlvbiA9IG51bGxcclxuICAgIHRoaXMucGF1c2VkID0gZmFsc2VcclxuICAgIHRoaXMubGFzdFBvcyA9IDBcclxuICAgIHRoaXMucG9zID0gMFxyXG4gICAgLy8gVGhlIGFic29sdXRlIHBvc2l0aW9uIG9mIGFuIGFuaW1hdGlvbiBpcyBpdHMgcG9zaXRpb24gaW4gdGhlIGNvbnRleHQgb2YgaXRzIGNvbXBsZXRlIGR1cmF0aW9uIChpbmNsdWRpbmcgZGVsYXkgYW5kIGxvb3BzKVxyXG4gICAgLy8gV2hlbiBwZXJmb3JtaW5nIGEgZGVsYXksIGFic1BvcyBpcyBiZWxvdyAwIGFuZCB3aGVuIHBlcmZvcm1pbmcgYSBsb29wLCBpdHMgdmFsdWUgaXMgYWJvdmUgMVxyXG4gICAgdGhpcy5hYnNQb3MgPSAwXHJcbiAgICB0aGlzLl9zcGVlZCA9IDFcclxuICB9XHJcblxyXG4sIGV4dGVuZDoge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogc2V0cyBvciByZXR1cm5zIHRoZSB0YXJnZXQgb2YgdGhpcyBhbmltYXRpb25cclxuICAgICAqIEBwYXJhbSBvIG9iamVjdCB8fCBudW1iZXIgSW4gY2FzZSBvZiBPYmplY3QgaXQgaG9sZHMgYWxsIHBhcmFtZXRlcnMuIEluIGNhc2Ugb2YgbnVtYmVyIGl0cyB0aGUgZHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvblxyXG4gICAgICogQHBhcmFtIGVhc2UgZnVuY3Rpb24gfHwgc3RyaW5nIEZ1bmN0aW9uIHdoaWNoIHNob3VsZCBiZSB1c2VkIGZvciBlYXNpbmcgb3IgZWFzaW5nIGtleXdvcmRcclxuICAgICAqIEBwYXJhbSBkZWxheSBOdW1iZXIgaW5kaWNhdGluZyB0aGUgZGVsYXkgYmVmb3JlIHRoZSBhbmltYXRpb24gc3RhcnRzXHJcbiAgICAgKiBAcmV0dXJuIHRhcmdldCB8fCB0aGlzXHJcbiAgICAgKi9cclxuICAgIGFuaW1hdGU6IGZ1bmN0aW9uKG8sIGVhc2UsIGRlbGF5KXtcclxuXHJcbiAgICAgIGlmKHR5cGVvZiBvID09ICdvYmplY3QnKXtcclxuICAgICAgICBlYXNlID0gby5lYXNlXHJcbiAgICAgICAgZGVsYXkgPSBvLmRlbGF5XHJcbiAgICAgICAgbyA9IG8uZHVyYXRpb25cclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHNpdHVhdGlvbiA9IG5ldyBTVkcuU2l0dWF0aW9uKHtcclxuICAgICAgICBkdXJhdGlvbjogbyB8fCAxMDAwLFxyXG4gICAgICAgIGRlbGF5OiBkZWxheSB8fCAwLFxyXG4gICAgICAgIGVhc2U6IFNWRy5lYXNpbmdbZWFzZSB8fCAnLSddIHx8IGVhc2VcclxuICAgICAgfSlcclxuXHJcbiAgICAgIHRoaXMucXVldWUoc2l0dWF0aW9uKVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIHNldHMgYSBkZWxheSBiZWZvcmUgdGhlIG5leHQgZWxlbWVudCBvZiB0aGUgcXVldWUgaXMgY2FsbGVkXHJcbiAgICAgKiBAcGFyYW0gZGVsYXkgRHVyYXRpb24gb2YgZGVsYXkgaW4gbWlsbGlzZWNvbmRzXHJcbiAgICAgKiBAcmV0dXJuIHRoaXMudGFyZ2V0KClcclxuICAgICAqL1xyXG4gICwgZGVsYXk6IGZ1bmN0aW9uKGRlbGF5KXtcclxuICAgICAgLy8gVGhlIGRlbGF5IGlzIHBlcmZvcm1lZCBieSBhbiBlbXB0eSBzaXR1YXRpb24gd2l0aCBpdHMgZHVyYXRpb25cclxuICAgICAgLy8gYXR0cmlidXRlIHNldCB0byB0aGUgZHVyYXRpb24gb2YgdGhlIGRlbGF5XHJcbiAgICAgIHZhciBzaXR1YXRpb24gPSBuZXcgU1ZHLlNpdHVhdGlvbih7XHJcbiAgICAgICAgZHVyYXRpb246IGRlbGF5LFxyXG4gICAgICAgIGRlbGF5OiAwLFxyXG4gICAgICAgIGVhc2U6IFNWRy5lYXNpbmdbJy0nXVxyXG4gICAgICB9KVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXMucXVldWUoc2l0dWF0aW9uKVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogc2V0cyBvciByZXR1cm5zIHRoZSB0YXJnZXQgb2YgdGhpcyBhbmltYXRpb25cclxuICAgICAqIEBwYXJhbSBudWxsIHx8IHRhcmdldCBTVkcuRWxlbWVudCB3aGljaCBzaG91bGQgYmUgc2V0IGFzIG5ldyB0YXJnZXRcclxuICAgICAqIEByZXR1cm4gdGFyZ2V0IHx8IHRoaXNcclxuICAgICAqL1xyXG4gICwgdGFyZ2V0OiBmdW5jdGlvbih0YXJnZXQpe1xyXG4gICAgICBpZih0YXJnZXQgJiYgdGFyZ2V0IGluc3RhbmNlb2YgU1ZHLkVsZW1lbnQpe1xyXG4gICAgICAgIHRoaXMuX3RhcmdldCA9IHRhcmdldFxyXG4gICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0aGlzLl90YXJnZXRcclxuICAgIH1cclxuXHJcbiAgICAvLyByZXR1cm5zIHRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBhdCBhIGdpdmVuIHRpbWVcclxuICAsIHRpbWVUb0Fic1BvczogZnVuY3Rpb24odGltZXN0YW1wKXtcclxuICAgICAgcmV0dXJuICh0aW1lc3RhbXAgLSB0aGlzLnNpdHVhdGlvbi5zdGFydCkgLyAodGhpcy5zaXR1YXRpb24uZHVyYXRpb24vdGhpcy5fc3BlZWQpXHJcbiAgICB9XHJcblxyXG4gICAgLy8gcmV0dXJucyB0aGUgdGltZXN0YW1wIGZyb20gYSBnaXZlbiBhYnNvbHV0ZSBwb3NpdG9uXHJcbiAgLCBhYnNQb3NUb1RpbWU6IGZ1bmN0aW9uKGFic1Bvcyl7XHJcbiAgICAgIHJldHVybiB0aGlzLnNpdHVhdGlvbi5kdXJhdGlvbi90aGlzLl9zcGVlZCAqIGFic1BvcyArIHRoaXMuc2l0dWF0aW9uLnN0YXJ0XHJcbiAgICB9XHJcblxyXG4gICAgLy8gc3RhcnRzIHRoZSBhbmltYXRpb25sb29wXHJcbiAgLCBzdGFydEFuaW1GcmFtZTogZnVuY3Rpb24oKXtcclxuICAgICAgdGhpcy5zdG9wQW5pbUZyYW1lKClcclxuICAgICAgdGhpcy5hbmltYXRpb25GcmFtZSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKXsgdGhpcy5zdGVwKCkgfS5iaW5kKHRoaXMpKVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGNhbmNlbHMgdGhlIGFuaW1hdGlvbmZyYW1lXHJcbiAgLCBzdG9wQW5pbUZyYW1lOiBmdW5jdGlvbigpe1xyXG4gICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5hbmltYXRpb25GcmFtZSlcclxuICAgIH1cclxuXHJcbiAgICAvLyBraWNrcyBvZmYgdGhlIGFuaW1hdGlvbiAtIG9ubHkgZG9lcyBzb21ldGhpbmcgd2hlbiB0aGUgcXVldWUgaXMgY3VycmVudGx5IG5vdCBhY3RpdmUgYW5kIGF0IGxlYXN0IG9uZSBzaXR1YXRpb24gaXMgc2V0XHJcbiAgLCBzdGFydDogZnVuY3Rpb24oKXtcclxuICAgICAgLy8gZG9udCBzdGFydCBpZiBhbHJlYWR5IHN0YXJ0ZWRcclxuICAgICAgaWYoIXRoaXMuYWN0aXZlICYmIHRoaXMuc2l0dWF0aW9uKXtcclxuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWVcclxuICAgICAgICB0aGlzLnN0YXJ0Q3VycmVudCgpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcblxyXG4gICAgLy8gc3RhcnQgdGhlIGN1cnJlbnQgc2l0dWF0aW9uXHJcbiAgLCBzdGFydEN1cnJlbnQ6IGZ1bmN0aW9uKCl7XHJcbiAgICAgIHRoaXMuc2l0dWF0aW9uLnN0YXJ0ID0gK25ldyBEYXRlICsgdGhpcy5zaXR1YXRpb24uZGVsYXkvdGhpcy5fc3BlZWRcclxuICAgICAgdGhpcy5zaXR1YXRpb24uZmluaXNoID0gdGhpcy5zaXR1YXRpb24uc3RhcnQgKyB0aGlzLnNpdHVhdGlvbi5kdXJhdGlvbi90aGlzLl9zcGVlZFxyXG4gICAgICByZXR1cm4gdGhpcy5pbml0QW5pbWF0aW9ucygpLnN0ZXAoKVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogYWRkcyBhIGZ1bmN0aW9uIC8gU2l0dWF0aW9uIHRvIHRoZSBhbmltYXRpb24gcXVldWVcclxuICAgICAqIEBwYXJhbSBmbiBmdW5jdGlvbiAvIHNpdHVhdGlvbiB0byBhZGRcclxuICAgICAqIEByZXR1cm4gdGhpc1xyXG4gICAgICovXHJcbiAgLCBxdWV1ZTogZnVuY3Rpb24oZm4pe1xyXG4gICAgICBpZih0eXBlb2YgZm4gPT0gJ2Z1bmN0aW9uJyB8fCBmbiBpbnN0YW5jZW9mIFNWRy5TaXR1YXRpb24pXHJcbiAgICAgICAgdGhpcy5zaXR1YXRpb25zLnB1c2goZm4pXHJcblxyXG4gICAgICBpZighdGhpcy5zaXR1YXRpb24pIHRoaXMuc2l0dWF0aW9uID0gdGhpcy5zaXR1YXRpb25zLnNoaWZ0KClcclxuXHJcbiAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBwdWxscyBuZXh0IGVsZW1lbnQgZnJvbSB0aGUgcXVldWUgYW5kIGV4ZWN1dGUgaXRcclxuICAgICAqIEByZXR1cm4gdGhpc1xyXG4gICAgICovXHJcbiAgLCBkZXF1ZXVlOiBmdW5jdGlvbigpe1xyXG4gICAgICAvLyBzdG9wIGN1cnJlbnQgYW5pbWF0aW9uXHJcbiAgICAgIHRoaXMuc3RvcCgpXHJcblxyXG4gICAgICAvLyBnZXQgbmV4dCBhbmltYXRpb24gZnJvbSBxdWV1ZVxyXG4gICAgICB0aGlzLnNpdHVhdGlvbiA9IHRoaXMuc2l0dWF0aW9ucy5zaGlmdCgpXHJcblxyXG4gICAgICBpZih0aGlzLnNpdHVhdGlvbil7XHJcbiAgICAgICAgaWYodGhpcy5zaXR1YXRpb24gaW5zdGFuY2VvZiBTVkcuU2l0dWF0aW9uKSB7XHJcbiAgICAgICAgICB0aGlzLnN0YXJ0KClcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gSWYgaXQgaXMgbm90IGEgU1ZHLlNpdHVhdGlvbiwgdGhlbiBpdCBpcyBhIGZ1bmN0aW9uLCB3ZSBleGVjdXRlIGl0XHJcbiAgICAgICAgICB0aGlzLnNpdHVhdGlvbi5jYWxsKHRoaXMpXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdGhpc1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHVwZGF0ZXMgYWxsIGFuaW1hdGlvbnMgdG8gdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGVsZW1lbnRcclxuICAgIC8vIHRoaXMgaXMgaW1wb3J0YW50IHdoZW4gb25lIHByb3BlcnR5IGNvdWxkIGJlIGNoYW5nZWQgZnJvbSBhbm90aGVyIHByb3BlcnR5XHJcbiAgLCBpbml0QW5pbWF0aW9uczogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciBpLCBzb3VyY2VcclxuICAgICAgdmFyIHMgPSB0aGlzLnNpdHVhdGlvblxyXG5cclxuICAgICAgaWYocy5pbml0KSByZXR1cm4gdGhpc1xyXG5cclxuICAgICAgZm9yKGkgaW4gcy5hbmltYXRpb25zKXtcclxuICAgICAgICBzb3VyY2UgPSB0aGlzLnRhcmdldCgpW2ldKClcclxuXHJcbiAgICAgICAgLy8gVGhlIGNvbmRpdGlvbiBpcyBiZWNhdXNlIHNvbWUgbWV0aG9kcyByZXR1cm4gYSBub3JtYWwgbnVtYmVyIGluc3RlYWRcclxuICAgICAgICAvLyBvZiBhIFNWRy5OdW1iZXJcclxuICAgICAgICBpZihzLmFuaW1hdGlvbnNbaV0gaW5zdGFuY2VvZiBTVkcuTnVtYmVyKVxyXG4gICAgICAgICAgc291cmNlID0gbmV3IFNWRy5OdW1iZXIoc291cmNlKVxyXG5cclxuICAgICAgICBzLmFuaW1hdGlvbnNbaV0gPSBzb3VyY2UubW9ycGgocy5hbmltYXRpb25zW2ldKVxyXG4gICAgICB9XHJcblxyXG4gICAgICBmb3IoaSBpbiBzLmF0dHJzKXtcclxuICAgICAgICBzLmF0dHJzW2ldID0gbmV3IFNWRy5Nb3JwaE9iaih0aGlzLnRhcmdldCgpLmF0dHIoaSksIHMuYXR0cnNbaV0pXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZvcihpIGluIHMuc3R5bGVzKXtcclxuICAgICAgICBzLnN0eWxlc1tpXSA9IG5ldyBTVkcuTW9ycGhPYmoodGhpcy50YXJnZXQoKS5zdHlsZShpKSwgcy5zdHlsZXNbaV0pXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHMuaW5pdGlhbFRyYW5zZm9ybWF0aW9uID0gdGhpcy50YXJnZXQoKS5tYXRyaXhpZnkoKVxyXG5cclxuICAgICAgcy5pbml0ID0gdHJ1ZVxyXG4gICAgICByZXR1cm4gdGhpc1xyXG4gICAgfVxyXG4gICwgY2xlYXJRdWV1ZTogZnVuY3Rpb24oKXtcclxuICAgICAgdGhpcy5zaXR1YXRpb25zID0gW11cclxuICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuICAsIGNsZWFyQ3VycmVudDogZnVuY3Rpb24oKXtcclxuICAgICAgdGhpcy5zaXR1YXRpb24gPSBudWxsXHJcbiAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcbiAgICAvKiogc3RvcHMgdGhlIGFuaW1hdGlvbiBpbW1lZGlhdGVseVxyXG4gICAgICogQHBhcmFtIGp1bXBUb0VuZCBBIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRvIGNvbXBsZXRlIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBpbW1lZGlhdGVseS5cclxuICAgICAqIEBwYXJhbSBjbGVhclF1ZXVlIEEgQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdG8gcmVtb3ZlIHF1ZXVlZCBhbmltYXRpb24gYXMgd2VsbC5cclxuICAgICAqIEByZXR1cm4gdGhpc1xyXG4gICAgICovXHJcbiAgLCBzdG9wOiBmdW5jdGlvbihqdW1wVG9FbmQsIGNsZWFyUXVldWUpe1xyXG4gICAgICB2YXIgYWN0aXZlID0gdGhpcy5hY3RpdmVcclxuICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZVxyXG5cclxuICAgICAgaWYoY2xlYXJRdWV1ZSl7XHJcbiAgICAgICAgdGhpcy5jbGVhclF1ZXVlKClcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYoanVtcFRvRW5kICYmIHRoaXMuc2l0dWF0aW9uKXtcclxuICAgICAgICAvLyBpbml0aWFsaXplIHRoZSBzaXR1YXRpb24gaWYgaXQgd2FzIG5vdFxyXG4gICAgICAgICFhY3RpdmUgJiYgdGhpcy5zdGFydEN1cnJlbnQoKVxyXG4gICAgICAgIHRoaXMuYXRFbmQoKVxyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLnN0b3BBbmltRnJhbWUoKVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXMuY2xlYXJDdXJyZW50KClcclxuICAgIH1cclxuXHJcbiAgICAvKiogcmVzZXRzIHRoZSBlbGVtZW50IHRvIHRoZSBzdGF0ZSB3aGVyZSB0aGUgY3VycmVudCBlbGVtZW50IGhhcyBzdGFydGVkXHJcbiAgICAgKiBAcmV0dXJuIHRoaXNcclxuICAgICAqL1xyXG4gICwgcmVzZXQ6IGZ1bmN0aW9uKCl7XHJcbiAgICAgIGlmKHRoaXMuc2l0dWF0aW9uKXtcclxuICAgICAgICB2YXIgdGVtcCA9IHRoaXMuc2l0dWF0aW9uXHJcbiAgICAgICAgdGhpcy5zdG9wKClcclxuICAgICAgICB0aGlzLnNpdHVhdGlvbiA9IHRlbXBcclxuICAgICAgICB0aGlzLmF0U3RhcnQoKVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcblxyXG4gICAgLy8gU3RvcCB0aGUgY3VycmVudGx5LXJ1bm5pbmcgYW5pbWF0aW9uLCByZW1vdmUgYWxsIHF1ZXVlZCBhbmltYXRpb25zLCBhbmQgY29tcGxldGUgYWxsIGFuaW1hdGlvbnMgZm9yIHRoZSBlbGVtZW50LlxyXG4gICwgZmluaXNoOiBmdW5jdGlvbigpe1xyXG5cclxuICAgICAgdGhpcy5zdG9wKHRydWUsIGZhbHNlKVxyXG5cclxuICAgICAgd2hpbGUodGhpcy5kZXF1ZXVlKCkuc2l0dWF0aW9uICYmIHRoaXMuc3RvcCh0cnVlLCBmYWxzZSkpO1xyXG5cclxuICAgICAgdGhpcy5jbGVhclF1ZXVlKCkuY2xlYXJDdXJyZW50KClcclxuXHJcbiAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcblxyXG4gICAgLy8gc2V0IHRoZSBpbnRlcm5hbCBhbmltYXRpb24gcG9pbnRlciBhdCB0aGUgc3RhcnQgcG9zaXRpb24sIGJlZm9yZSBhbnkgbG9vcHMsIGFuZCB1cGRhdGVzIHRoZSB2aXN1YWxpc2F0aW9uXHJcbiAgLCBhdFN0YXJ0OiBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuYXQoMCwgdHJ1ZSlcclxuICAgIH1cclxuXHJcbiAgICAvLyBzZXQgdGhlIGludGVybmFsIGFuaW1hdGlvbiBwb2ludGVyIGF0IHRoZSBlbmQgcG9zaXRpb24sIGFmdGVyIGFsbCB0aGUgbG9vcHMsIGFuZCB1cGRhdGVzIHRoZSB2aXN1YWxpc2F0aW9uXHJcbiAgLCBhdEVuZDogZnVuY3Rpb24oKSB7XHJcbiAgICAgIGlmICh0aGlzLnNpdHVhdGlvbi5sb29wcyA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIC8vIElmIGluIGEgaW5maW5pdGUgbG9vcCwgd2UgZW5kIHRoZSBjdXJyZW50IGl0ZXJhdGlvblxyXG4gICAgICAgIHRoaXMuc2l0dWF0aW9uLmxvb3BzID0gdGhpcy5zaXR1YXRpb24ubG9vcCArIDFcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYodHlwZW9mIHRoaXMuc2l0dWF0aW9uLmxvb3BzID09ICdudW1iZXInKSB7XHJcbiAgICAgICAgLy8gSWYgcGVyZm9ybWluZyBhIGZpbml0ZSBudW1iZXIgb2YgbG9vcHMsIHdlIGdvIGFmdGVyIGFsbCB0aGUgbG9vcHNcclxuICAgICAgICByZXR1cm4gdGhpcy5hdCh0aGlzLnNpdHVhdGlvbi5sb29wcywgdHJ1ZSlcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBJZiBubyBsb29wcywgd2UganVzdCBnbyBhdCB0aGUgZW5kXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXQoMSwgdHJ1ZSlcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIHNldCB0aGUgaW50ZXJuYWwgYW5pbWF0aW9uIHBvaW50ZXIgdG8gdGhlIHNwZWNpZmllZCBwb3NpdGlvbiBhbmQgdXBkYXRlcyB0aGUgdmlzdWFsaXNhdGlvblxyXG4gICAgLy8gaWYgaXNBYnNQb3MgaXMgdHJ1ZSwgcG9zIGlzIHRyZWF0ZWQgYXMgYW4gYWJzb2x1dGUgcG9zaXRpb25cclxuICAsIGF0OiBmdW5jdGlvbihwb3MsIGlzQWJzUG9zKXtcclxuICAgICAgdmFyIGR1ckRpdlNwZCA9IHRoaXMuc2l0dWF0aW9uLmR1cmF0aW9uL3RoaXMuX3NwZWVkXHJcblxyXG4gICAgICB0aGlzLmFic1BvcyA9IHBvc1xyXG4gICAgICAvLyBJZiBwb3MgaXMgbm90IGFuIGFic29sdXRlIHBvc2l0aW9uLCB3ZSBjb252ZXJ0IGl0IGludG8gb25lXHJcbiAgICAgIGlmICghaXNBYnNQb3MpIHtcclxuICAgICAgICBpZiAodGhpcy5zaXR1YXRpb24ucmV2ZXJzZWQpIHRoaXMuYWJzUG9zID0gMSAtIHRoaXMuYWJzUG9zXHJcbiAgICAgICAgdGhpcy5hYnNQb3MgKz0gdGhpcy5zaXR1YXRpb24ubG9vcFxyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLnNpdHVhdGlvbi5zdGFydCA9ICtuZXcgRGF0ZSAtIHRoaXMuYWJzUG9zICogZHVyRGl2U3BkXHJcbiAgICAgIHRoaXMuc2l0dWF0aW9uLmZpbmlzaCA9IHRoaXMuc2l0dWF0aW9uLnN0YXJ0ICsgZHVyRGl2U3BkXHJcblxyXG4gICAgICByZXR1cm4gdGhpcy5zdGVwKHRydWUpXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBzZXRzIG9yIHJldHVybnMgdGhlIHNwZWVkIG9mIHRoZSBhbmltYXRpb25zXHJcbiAgICAgKiBAcGFyYW0gc3BlZWQgbnVsbCB8fCBOdW1iZXIgVGhlIG5ldyBzcGVlZCBvZiB0aGUgYW5pbWF0aW9uc1xyXG4gICAgICogQHJldHVybiBOdW1iZXIgfHwgdGhpc1xyXG4gICAgICovXHJcbiAgLCBzcGVlZDogZnVuY3Rpb24oc3BlZWQpe1xyXG4gICAgICBpZiAoc3BlZWQgPT09IDApIHJldHVybiB0aGlzLnBhdXNlKClcclxuXHJcbiAgICAgIGlmIChzcGVlZCkge1xyXG4gICAgICAgIHRoaXMuX3NwZWVkID0gc3BlZWRcclxuICAgICAgICAvLyBXZSB1c2UgYW4gYWJzb2x1dGUgcG9zaXRpb24gaGVyZSBzbyB0aGF0IHNwZWVkIGNhbiBhZmZlY3QgdGhlIGRlbGF5IGJlZm9yZSB0aGUgYW5pbWF0aW9uXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXQodGhpcy5hYnNQb3MsIHRydWUpXHJcbiAgICAgIH0gZWxzZSByZXR1cm4gdGhpcy5fc3BlZWRcclxuICAgIH1cclxuXHJcbiAgICAvLyBNYWtlIGxvb3BhYmxlXHJcbiAgLCBsb29wOiBmdW5jdGlvbih0aW1lcywgcmV2ZXJzZSkge1xyXG4gICAgICB2YXIgYyA9IHRoaXMubGFzdCgpXHJcblxyXG4gICAgICAvLyBzdG9yZSB0b3RhbCBsb29wc1xyXG4gICAgICBjLmxvb3BzID0gKHRpbWVzICE9IG51bGwpID8gdGltZXMgOiB0cnVlXHJcbiAgICAgIGMubG9vcCA9IDBcclxuXHJcbiAgICAgIGlmKHJldmVyc2UpIGMucmV2ZXJzaW5nID0gdHJ1ZVxyXG4gICAgICByZXR1cm4gdGhpc1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHBhdXNlcyB0aGUgYW5pbWF0aW9uXHJcbiAgLCBwYXVzZTogZnVuY3Rpb24oKXtcclxuICAgICAgdGhpcy5wYXVzZWQgPSB0cnVlXHJcbiAgICAgIHRoaXMuc3RvcEFuaW1GcmFtZSgpXHJcblxyXG4gICAgICByZXR1cm4gdGhpc1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHVucGF1c2UgdGhlIGFuaW1hdGlvblxyXG4gICwgcGxheTogZnVuY3Rpb24oKXtcclxuICAgICAgaWYoIXRoaXMucGF1c2VkKSByZXR1cm4gdGhpc1xyXG4gICAgICB0aGlzLnBhdXNlZCA9IGZhbHNlXHJcbiAgICAgIC8vIFdlIHVzZSBhbiBhYnNvbHV0ZSBwb3NpdGlvbiBoZXJlIHNvIHRoYXQgdGhlIGRlbGF5IGJlZm9yZSB0aGUgYW5pbWF0aW9uIGNhbiBiZSBwYXVzZWRcclxuICAgICAgcmV0dXJuIHRoaXMuYXQodGhpcy5hYnNQb3MsIHRydWUpXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiB0b2dnbGUgb3Igc2V0IHRoZSBkaXJlY3Rpb24gb2YgdGhlIGFuaW1hdGlvblxyXG4gICAgICogdHJ1ZSBzZXRzIGRpcmVjdGlvbiB0byBiYWNrd2FyZHMgd2hpbGUgZmFsc2Ugc2V0cyBpdCB0byBmb3J3YXJkc1xyXG4gICAgICogQHBhcmFtIHJldmVyc2VkIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRvIHJldmVyc2UgdGhlIGFuaW1hdGlvbiBvciBub3QgKGRlZmF1bHQ6IHRvZ2dsZSB0aGUgcmV2ZXJzZSBzdGF0dXMpXHJcbiAgICAgKiBAcmV0dXJuIHRoaXNcclxuICAgICAqL1xyXG4gICwgcmV2ZXJzZTogZnVuY3Rpb24ocmV2ZXJzZWQpe1xyXG4gICAgICB2YXIgYyA9IHRoaXMubGFzdCgpXHJcblxyXG4gICAgICBpZih0eXBlb2YgcmV2ZXJzZWQgPT0gJ3VuZGVmaW5lZCcpIGMucmV2ZXJzZWQgPSAhYy5yZXZlcnNlZFxyXG4gICAgICBlbHNlIGMucmV2ZXJzZWQgPSByZXZlcnNlZFxyXG5cclxuICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiByZXR1cm5zIGEgZmxvYXQgZnJvbSAwLTEgaW5kaWNhdGluZyB0aGUgcHJvZ3Jlc3Mgb2YgdGhlIGN1cnJlbnQgYW5pbWF0aW9uXHJcbiAgICAgKiBAcGFyYW0gZWFzZWQgQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHJldHVybmVkIHBvc2l0aW9uIHNob3VsZCBiZSBlYXNlZCBvciBub3RcclxuICAgICAqIEByZXR1cm4gbnVtYmVyXHJcbiAgICAgKi9cclxuICAsIHByb2dyZXNzOiBmdW5jdGlvbihlYXNlSXQpe1xyXG4gICAgICByZXR1cm4gZWFzZUl0ID8gdGhpcy5zaXR1YXRpb24uZWFzZSh0aGlzLnBvcykgOiB0aGlzLnBvc1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogYWRkcyBhIGNhbGxiYWNrIGZ1bmN0aW9uIHdoaWNoIGlzIGNhbGxlZCB3aGVuIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBpcyBmaW5pc2hlZFxyXG4gICAgICogQHBhcmFtIGZuIEZ1bmN0aW9uIHdoaWNoIHNob3VsZCBiZSBleGVjdXRlZCBhcyBjYWxsYmFja1xyXG4gICAgICogQHJldHVybiBudW1iZXJcclxuICAgICAqL1xyXG4gICwgYWZ0ZXI6IGZ1bmN0aW9uKGZuKXtcclxuICAgICAgdmFyIGMgPSB0aGlzLmxhc3QoKVxyXG4gICAgICAgICwgd3JhcHBlciA9IGZ1bmN0aW9uIHdyYXBwZXIoZSl7XHJcbiAgICAgICAgICAgIGlmKGUuZGV0YWlsLnNpdHVhdGlvbiA9PSBjKXtcclxuICAgICAgICAgICAgICBmbi5jYWxsKHRoaXMsIGMpXHJcbiAgICAgICAgICAgICAgdGhpcy5vZmYoJ2ZpbmlzaGVkLmZ4Jywgd3JhcHBlcikgLy8gcHJldmVudCBtZW1vcnkgbGVha1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICB0aGlzLnRhcmdldCgpLm9uKCdmaW5pc2hlZC5meCcsIHdyYXBwZXIpXHJcblxyXG4gICAgICByZXR1cm4gdGhpcy5fY2FsbFN0YXJ0KClcclxuICAgIH1cclxuXHJcbiAgICAvLyBhZGRzIGEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW5ldmVyIG9uZSBhbmltYXRpb24gc3RlcCBpcyBwZXJmb3JtZWRcclxuICAsIGR1cmluZzogZnVuY3Rpb24oZm4pe1xyXG4gICAgICB2YXIgYyA9IHRoaXMubGFzdCgpXHJcbiAgICAgICAgLCB3cmFwcGVyID0gZnVuY3Rpb24oZSl7XHJcbiAgICAgICAgICAgIGlmKGUuZGV0YWlsLnNpdHVhdGlvbiA9PSBjKXtcclxuICAgICAgICAgICAgICBmbi5jYWxsKHRoaXMsIGUuZGV0YWlsLnBvcywgU1ZHLm1vcnBoKGUuZGV0YWlsLnBvcyksIGUuZGV0YWlsLmVhc2VkLCBjKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAvLyBzZWUgYWJvdmVcclxuICAgICAgdGhpcy50YXJnZXQoKS5vZmYoJ2R1cmluZy5meCcsIHdyYXBwZXIpLm9uKCdkdXJpbmcuZngnLCB3cmFwcGVyKVxyXG5cclxuICAgICAgdGhpcy5hZnRlcihmdW5jdGlvbigpe1xyXG4gICAgICAgIHRoaXMub2ZmKCdkdXJpbmcuZngnLCB3cmFwcGVyKVxyXG4gICAgICB9KVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXMuX2NhbGxTdGFydCgpXHJcbiAgICB9XHJcblxyXG4gICAgLy8gY2FsbHMgYWZ0ZXIgQUxMIGFuaW1hdGlvbnMgaW4gdGhlIHF1ZXVlIGFyZSBmaW5pc2hlZFxyXG4gICwgYWZ0ZXJBbGw6IGZ1bmN0aW9uKGZuKXtcclxuICAgICAgdmFyIHdyYXBwZXIgPSBmdW5jdGlvbiB3cmFwcGVyKGUpe1xyXG4gICAgICAgICAgICBmbi5jYWxsKHRoaXMpXHJcbiAgICAgICAgICAgIHRoaXMub2ZmKCdhbGxmaW5pc2hlZC5meCcsIHdyYXBwZXIpXHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAvLyBzZWUgYWJvdmVcclxuICAgICAgdGhpcy50YXJnZXQoKS5vZmYoJ2FsbGZpbmlzaGVkLmZ4Jywgd3JhcHBlcikub24oJ2FsbGZpbmlzaGVkLmZ4Jywgd3JhcHBlcilcclxuXHJcbiAgICAgIHJldHVybiB0aGlzLl9jYWxsU3RhcnQoKVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGNhbGxzIG9uIGV2ZXJ5IGFuaW1hdGlvbiBzdGVwIGZvciBhbGwgYW5pbWF0aW9uc1xyXG4gICwgZHVyaW5nQWxsOiBmdW5jdGlvbihmbil7XHJcbiAgICAgIHZhciB3cmFwcGVyID0gZnVuY3Rpb24oZSl7XHJcbiAgICAgICAgICAgIGZuLmNhbGwodGhpcywgZS5kZXRhaWwucG9zLCBTVkcubW9ycGgoZS5kZXRhaWwucG9zKSwgZS5kZXRhaWwuZWFzZWQsIGUuZGV0YWlsLnNpdHVhdGlvbilcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMudGFyZ2V0KCkub2ZmKCdkdXJpbmcuZngnLCB3cmFwcGVyKS5vbignZHVyaW5nLmZ4Jywgd3JhcHBlcilcclxuXHJcbiAgICAgIHRoaXMuYWZ0ZXJBbGwoZnVuY3Rpb24oKXtcclxuICAgICAgICB0aGlzLm9mZignZHVyaW5nLmZ4Jywgd3JhcHBlcilcclxuICAgICAgfSlcclxuXHJcbiAgICAgIHJldHVybiB0aGlzLl9jYWxsU3RhcnQoKVxyXG4gICAgfVxyXG5cclxuICAsIGxhc3Q6IGZ1bmN0aW9uKCl7XHJcbiAgICAgIHJldHVybiB0aGlzLnNpdHVhdGlvbnMubGVuZ3RoID8gdGhpcy5zaXR1YXRpb25zW3RoaXMuc2l0dWF0aW9ucy5sZW5ndGgtMV0gOiB0aGlzLnNpdHVhdGlvblxyXG4gICAgfVxyXG5cclxuICAgIC8vIGFkZHMgb25lIHByb3BlcnR5IHRvIHRoZSBhbmltYXRpb25zXHJcbiAgLCBhZGQ6IGZ1bmN0aW9uKG1ldGhvZCwgYXJncywgdHlwZSl7XHJcbiAgICAgIHRoaXMubGFzdCgpW3R5cGUgfHwgJ2FuaW1hdGlvbnMnXVttZXRob2RdID0gYXJnc1xyXG4gICAgICByZXR1cm4gdGhpcy5fY2FsbFN0YXJ0KClcclxuICAgIH1cclxuXHJcbiAgICAvKiogcGVyZm9ybSBvbmUgc3RlcCBvZiB0aGUgYW5pbWF0aW9uXHJcbiAgICAgKiAgQHBhcmFtIGlnbm9yZVRpbWUgQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdG8gaWdub3JlIHRpbWUgYW5kIHVzZSBwb3NpdGlvbiBkaXJlY3RseSBvciByZWNhbGN1bGF0ZSBwb3NpdGlvbiBiYXNlZCBvbiB0aW1lXHJcbiAgICAgKiAgQHJldHVybiB0aGlzXHJcbiAgICAgKi9cclxuICAsIHN0ZXA6IGZ1bmN0aW9uKGlnbm9yZVRpbWUpe1xyXG5cclxuICAgICAgLy8gY29udmVydCBjdXJyZW50IHRpbWUgdG8gYW4gYWJzb2x1dGUgcG9zaXRpb25cclxuICAgICAgaWYoIWlnbm9yZVRpbWUpIHRoaXMuYWJzUG9zID0gdGhpcy50aW1lVG9BYnNQb3MoK25ldyBEYXRlKVxyXG5cclxuICAgICAgLy8gVGhpcyBwYXJ0IGNvbnZlcnQgYW4gYWJzb2x1dGUgcG9zaXRpb24gdG8gYSBwb3NpdGlvblxyXG4gICAgICBpZih0aGlzLnNpdHVhdGlvbi5sb29wcyAhPT0gZmFsc2UpIHtcclxuICAgICAgICB2YXIgYWJzUG9zLCBhYnNQb3NJbnQsIGxhc3RMb29wXHJcblxyXG4gICAgICAgIC8vIElmIHRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBpcyBiZWxvdyAwLCB3ZSBqdXN0IHRyZWF0IGl0IGFzIGlmIGl0IHdhcyAwXHJcbiAgICAgICAgYWJzUG9zID0gTWF0aC5tYXgodGhpcy5hYnNQb3MsIDApXHJcbiAgICAgICAgYWJzUG9zSW50ID0gTWF0aC5mbG9vcihhYnNQb3MpXHJcblxyXG4gICAgICAgIGlmKHRoaXMuc2l0dWF0aW9uLmxvb3BzID09PSB0cnVlIHx8IGFic1Bvc0ludCA8IHRoaXMuc2l0dWF0aW9uLmxvb3BzKSB7XHJcbiAgICAgICAgICB0aGlzLnBvcyA9IGFic1BvcyAtIGFic1Bvc0ludFxyXG4gICAgICAgICAgbGFzdExvb3AgPSB0aGlzLnNpdHVhdGlvbi5sb29wXHJcbiAgICAgICAgICB0aGlzLnNpdHVhdGlvbi5sb29wID0gYWJzUG9zSW50XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRoaXMuYWJzUG9zID0gdGhpcy5zaXR1YXRpb24ubG9vcHNcclxuICAgICAgICAgIHRoaXMucG9zID0gMVxyXG4gICAgICAgICAgLy8gVGhlIC0xIGhlcmUgaXMgYmVjYXVzZSB3ZSBkb24ndCB3YW50IHRvIHRvZ2dsZSByZXZlcnNlZCB3aGVuIGFsbCB0aGUgbG9vcHMgaGF2ZSBiZWVuIGNvbXBsZXRlZFxyXG4gICAgICAgICAgbGFzdExvb3AgPSB0aGlzLnNpdHVhdGlvbi5sb29wIC0gMVxyXG4gICAgICAgICAgdGhpcy5zaXR1YXRpb24ubG9vcCA9IHRoaXMuc2l0dWF0aW9uLmxvb3BzXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZih0aGlzLnNpdHVhdGlvbi5yZXZlcnNpbmcpIHtcclxuICAgICAgICAgIC8vIFRvZ2dsZSByZXZlcnNlZCBpZiBhbiBvZGQgbnVtYmVyIG9mIGxvb3BzIGFzIG9jY3VyZWQgc2luY2UgdGhlIGxhc3QgY2FsbCBvZiBzdGVwXHJcbiAgICAgICAgICB0aGlzLnNpdHVhdGlvbi5yZXZlcnNlZCA9IHRoaXMuc2l0dWF0aW9uLnJldmVyc2VkICE9IEJvb2xlYW4oKHRoaXMuc2l0dWF0aW9uLmxvb3AgLSBsYXN0TG9vcCkgJSAyKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIGxvb3AsIHRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBtdXN0IG5vdCBiZSBhYm92ZSAxXHJcbiAgICAgICAgdGhpcy5hYnNQb3MgPSBNYXRoLm1pbih0aGlzLmFic1BvcywgMSlcclxuICAgICAgICB0aGlzLnBvcyA9IHRoaXMuYWJzUG9zXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHdoaWxlIHRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBjYW4gYmUgYmVsb3cgMCwgdGhlIHBvc2l0aW9uIG11c3Qgbm90IGJlIGJlbG93IDBcclxuICAgICAgaWYodGhpcy5wb3MgPCAwKSB0aGlzLnBvcyA9IDBcclxuXHJcbiAgICAgIGlmKHRoaXMuc2l0dWF0aW9uLnJldmVyc2VkKSB0aGlzLnBvcyA9IDEgLSB0aGlzLnBvc1xyXG5cclxuXHJcbiAgICAgIC8vIGFwcGx5IGVhc2luZ1xyXG4gICAgICB2YXIgZWFzZWQgPSB0aGlzLnNpdHVhdGlvbi5lYXNlKHRoaXMucG9zKVxyXG5cclxuICAgICAgLy8gY2FsbCBvbmNlLWNhbGxiYWNrc1xyXG4gICAgICBmb3IodmFyIGkgaW4gdGhpcy5zaXR1YXRpb24ub25jZSl7XHJcbiAgICAgICAgaWYoaSA+IHRoaXMubGFzdFBvcyAmJiBpIDw9IGVhc2VkKXtcclxuICAgICAgICAgIHRoaXMuc2l0dWF0aW9uLm9uY2VbaV0uY2FsbCh0aGlzLnRhcmdldCgpLCB0aGlzLnBvcywgZWFzZWQpXHJcbiAgICAgICAgICBkZWxldGUgdGhpcy5zaXR1YXRpb24ub25jZVtpXVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gZmlyZSBkdXJpbmcgY2FsbGJhY2sgd2l0aCBwb3NpdGlvbiwgZWFzZWQgcG9zaXRpb24gYW5kIGN1cnJlbnQgc2l0dWF0aW9uIGFzIHBhcmFtZXRlclxyXG4gICAgICBpZih0aGlzLmFjdGl2ZSkgdGhpcy50YXJnZXQoKS5maXJlKCdkdXJpbmcnLCB7cG9zOiB0aGlzLnBvcywgZWFzZWQ6IGVhc2VkLCBmeDogdGhpcywgc2l0dWF0aW9uOiB0aGlzLnNpdHVhdGlvbn0pXHJcblxyXG4gICAgICAvLyB0aGUgdXNlciBtYXkgY2FsbCBzdG9wIG9yIGZpbmlzaCBpbiB0aGUgZHVyaW5nIGNhbGxiYWNrXHJcbiAgICAgIC8vIHNvIG1ha2Ugc3VyZSB0aGF0IHdlIHN0aWxsIGhhdmUgYSB2YWxpZCBzaXR1YXRpb25cclxuICAgICAgaWYoIXRoaXMuc2l0dWF0aW9uKXtcclxuICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBhcHBseSB0aGUgYWN0dWFsIGFuaW1hdGlvbiB0byBldmVyeSBwcm9wZXJ0eVxyXG4gICAgICB0aGlzLmVhY2hBdCgpXHJcblxyXG4gICAgICAvLyBkbyBmaW5hbCBjb2RlIHdoZW4gc2l0dWF0aW9uIGlzIGZpbmlzaGVkXHJcbiAgICAgIGlmKCh0aGlzLnBvcyA9PSAxICYmICF0aGlzLnNpdHVhdGlvbi5yZXZlcnNlZCkgfHwgKHRoaXMuc2l0dWF0aW9uLnJldmVyc2VkICYmIHRoaXMucG9zID09IDApKXtcclxuXHJcbiAgICAgICAgLy8gc3RvcCBhbmltYXRpb24gY2FsbGJhY2tcclxuICAgICAgICB0aGlzLnN0b3BBbmltRnJhbWUoKVxyXG5cclxuICAgICAgICAvLyBmaXJlIGZpbmlzaGVkIGNhbGxiYWNrIHdpdGggY3VycmVudCBzaXR1YXRpb24gYXMgcGFyYW1ldGVyXHJcbiAgICAgICAgdGhpcy50YXJnZXQoKS5maXJlKCdmaW5pc2hlZCcsIHtmeDp0aGlzLCBzaXR1YXRpb246IHRoaXMuc2l0dWF0aW9ufSlcclxuXHJcbiAgICAgICAgaWYoIXRoaXMuc2l0dWF0aW9ucy5sZW5ndGgpe1xyXG4gICAgICAgICAgdGhpcy50YXJnZXQoKS5maXJlKCdhbGxmaW5pc2hlZCcpXHJcbiAgICAgICAgICB0aGlzLnRhcmdldCgpLm9mZignLmZ4JykgLy8gdGhlcmUgc2hvdWxkbnQgYmUgYW55IGJpbmRpbmcgbGVmdCwgYnV0IHRvIG1ha2Ugc3VyZS4uLlxyXG4gICAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gc3RhcnQgbmV4dCBhbmltYXRpb25cclxuICAgICAgICBpZih0aGlzLmFjdGl2ZSkgdGhpcy5kZXF1ZXVlKClcclxuICAgICAgICBlbHNlIHRoaXMuY2xlYXJDdXJyZW50KClcclxuXHJcbiAgICAgIH1lbHNlIGlmKCF0aGlzLnBhdXNlZCAmJiB0aGlzLmFjdGl2ZSl7XHJcbiAgICAgICAgLy8gd2UgY29udGludWUgYW5pbWF0aW5nIHdoZW4gd2UgYXJlIG5vdCBhdCB0aGUgZW5kXHJcbiAgICAgICAgdGhpcy5zdGFydEFuaW1GcmFtZSgpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHNhdmUgbGFzdCBlYXNlZCBwb3NpdGlvbiBmb3Igb25jZSBjYWxsYmFjayB0cmlnZ2VyaW5nXHJcbiAgICAgIHRoaXMubGFzdFBvcyA9IGVhc2VkXHJcbiAgICAgIHJldHVybiB0aGlzXHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8vIGNhbGN1bGF0ZXMgdGhlIHN0ZXAgZm9yIGV2ZXJ5IHByb3BlcnR5IGFuZCBjYWxscyBibG9jayB3aXRoIGl0XHJcbiAgLCBlYWNoQXQ6IGZ1bmN0aW9uKCl7XHJcbiAgICAgIHZhciBpLCBhdCwgc2VsZiA9IHRoaXMsIHRhcmdldCA9IHRoaXMudGFyZ2V0KCksIHMgPSB0aGlzLnNpdHVhdGlvblxyXG5cclxuICAgICAgLy8gYXBwbHkgYW5pbWF0aW9ucyB3aGljaCBjYW4gYmUgY2FsbGVkIHRyb3VnaCBhIG1ldGhvZFxyXG4gICAgICBmb3IoaSBpbiBzLmFuaW1hdGlvbnMpe1xyXG5cclxuICAgICAgICBhdCA9IFtdLmNvbmNhdChzLmFuaW1hdGlvbnNbaV0pLm1hcChmdW5jdGlvbihlbCl7XHJcbiAgICAgICAgICByZXR1cm4gdHlwZW9mIGVsICE9PSAnc3RyaW5nJyAmJiBlbC5hdCA/IGVsLmF0KHMuZWFzZShzZWxmLnBvcyksIHNlbGYucG9zKSA6IGVsXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgdGFyZ2V0W2ldLmFwcGx5KHRhcmdldCwgYXQpXHJcblxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBhcHBseSBhbmltYXRpb24gd2hpY2ggaGFzIHRvIGJlIGFwcGxpZWQgd2l0aCBhdHRyKClcclxuICAgICAgZm9yKGkgaW4gcy5hdHRycyl7XHJcblxyXG4gICAgICAgIGF0ID0gW2ldLmNvbmNhdChzLmF0dHJzW2ldKS5tYXAoZnVuY3Rpb24oZWwpe1xyXG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiBlbCAhPT0gJ3N0cmluZycgJiYgZWwuYXQgPyBlbC5hdChzLmVhc2Uoc2VsZi5wb3MpLCBzZWxmLnBvcykgOiBlbFxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIHRhcmdldC5hdHRyLmFwcGx5KHRhcmdldCwgYXQpXHJcblxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBhcHBseSBhbmltYXRpb24gd2hpY2ggaGFzIHRvIGJlIGFwcGxpZWQgd2l0aCBzdHlsZSgpXHJcbiAgICAgIGZvcihpIGluIHMuc3R5bGVzKXtcclxuXHJcbiAgICAgICAgYXQgPSBbaV0uY29uY2F0KHMuc3R5bGVzW2ldKS5tYXAoZnVuY3Rpb24oZWwpe1xyXG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiBlbCAhPT0gJ3N0cmluZycgJiYgZWwuYXQgPyBlbC5hdChzLmVhc2Uoc2VsZi5wb3MpLCBzZWxmLnBvcykgOiBlbFxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIHRhcmdldC5zdHlsZS5hcHBseSh0YXJnZXQsIGF0KVxyXG5cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gYW5pbWF0ZSBpbml0aWFsVHJhbnNmb3JtYXRpb24gd2hpY2ggaGFzIHRvIGJlIGNoYWluZWRcclxuICAgICAgaWYocy50cmFuc2Zvcm1zLmxlbmd0aCl7XHJcblxyXG4gICAgICAgIC8vIGdldCBpbml0aWFsIGluaXRpYWxUcmFuc2Zvcm1hdGlvblxyXG4gICAgICAgIGF0ID0gcy5pbml0aWFsVHJhbnNmb3JtYXRpb25cclxuICAgICAgICBmb3IoaSA9IDAsIGxlbiA9IHMudHJhbnNmb3Jtcy5sZW5ndGg7IGkgPCBsZW47IGkrKyl7XHJcblxyXG4gICAgICAgICAgLy8gZ2V0IG5leHQgdHJhbnNmb3JtYXRpb24gaW4gY2hhaW5cclxuICAgICAgICAgIHZhciBhID0gcy50cmFuc2Zvcm1zW2ldXHJcblxyXG4gICAgICAgICAgLy8gbXVsdGlwbHkgbWF0cml4IGRpcmVjdGx5XHJcbiAgICAgICAgICBpZihhIGluc3RhbmNlb2YgU1ZHLk1hdHJpeCl7XHJcblxyXG4gICAgICAgICAgICBpZihhLnJlbGF0aXZlKXtcclxuICAgICAgICAgICAgICBhdCA9IGF0Lm11bHRpcGx5KG5ldyBTVkcuTWF0cml4KCkubW9ycGgoYSkuYXQocy5lYXNlKHRoaXMucG9zKSkpXHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgIGF0ID0gYXQubW9ycGgoYSkuYXQocy5lYXNlKHRoaXMucG9zKSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb250aW51ZVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIHdoZW4gdHJhbnNmb3JtYXRpb24gaXMgYWJzb2x1dGUgd2UgaGF2ZSB0byByZXNldCB0aGUgbmVlZGVkIHRyYW5zZm9ybWF0aW9uIGZpcnN0XHJcbiAgICAgICAgICBpZighYS5yZWxhdGl2ZSlcclxuICAgICAgICAgICAgYS51bmRvKGF0LmV4dHJhY3QoKSlcclxuXHJcbiAgICAgICAgICAvLyBhbmQgcmVhcHBseSBpdCBhZnRlclxyXG4gICAgICAgICAgYXQgPSBhdC5tdWx0aXBseShhLmF0KHMuZWFzZSh0aGlzLnBvcykpKVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHNldCBuZXcgbWF0cml4IG9uIGVsZW1lbnRcclxuICAgICAgICB0YXJnZXQubWF0cml4KGF0KVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdGhpc1xyXG5cclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gYWRkcyBhbiBvbmNlLWNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhdCBhIHNwZWNpZmljIHBvc2l0aW9uIGFuZCBuZXZlciBhZ2FpblxyXG4gICwgb25jZTogZnVuY3Rpb24ocG9zLCBmbiwgaXNFYXNlZCl7XHJcblxyXG4gICAgICBpZighaXNFYXNlZClwb3MgPSB0aGlzLnNpdHVhdGlvbi5lYXNlKHBvcylcclxuXHJcbiAgICAgIHRoaXMuc2l0dWF0aW9uLm9uY2VbcG9zXSA9IGZuXHJcblxyXG4gICAgICByZXR1cm4gdGhpc1xyXG4gICAgfVxyXG5cclxuICAsIF9jYWxsU3RhcnQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dGhpcy5zdGFydCgpfS5iaW5kKHRoaXMpLCAwKVxyXG4gICAgICByZXR1cm4gdGhpc1xyXG4gICAgfVxyXG5cclxuICB9XHJcblxyXG4sIHBhcmVudDogU1ZHLkVsZW1lbnRcclxuXHJcbiAgLy8gQWRkIG1ldGhvZCB0byBwYXJlbnQgZWxlbWVudHNcclxuLCBjb25zdHJ1Y3Q6IHtcclxuICAgIC8vIEdldCBmeCBtb2R1bGUgb3IgY3JlYXRlIGEgbmV3IG9uZSwgdGhlbiBhbmltYXRlIHdpdGggZ2l2ZW4gZHVyYXRpb24gYW5kIGVhc2VcclxuICAgIGFuaW1hdGU6IGZ1bmN0aW9uKG8sIGVhc2UsIGRlbGF5KSB7XHJcbiAgICAgIHJldHVybiAodGhpcy5meCB8fCAodGhpcy5meCA9IG5ldyBTVkcuRlgodGhpcykpKS5hbmltYXRlKG8sIGVhc2UsIGRlbGF5KVxyXG4gICAgfVxyXG4gICwgZGVsYXk6IGZ1bmN0aW9uKGRlbGF5KXtcclxuICAgICAgcmV0dXJuICh0aGlzLmZ4IHx8ICh0aGlzLmZ4ID0gbmV3IFNWRy5GWCh0aGlzKSkpLmRlbGF5KGRlbGF5KVxyXG4gICAgfVxyXG4gICwgc3RvcDogZnVuY3Rpb24oanVtcFRvRW5kLCBjbGVhclF1ZXVlKSB7XHJcbiAgICAgIGlmICh0aGlzLmZ4KVxyXG4gICAgICAgIHRoaXMuZnguc3RvcChqdW1wVG9FbmQsIGNsZWFyUXVldWUpXHJcblxyXG4gICAgICByZXR1cm4gdGhpc1xyXG4gICAgfVxyXG4gICwgZmluaXNoOiBmdW5jdGlvbigpIHtcclxuICAgICAgaWYgKHRoaXMuZngpXHJcbiAgICAgICAgdGhpcy5meC5maW5pc2goKVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuICAgIC8vIFBhdXNlIGN1cnJlbnQgYW5pbWF0aW9uXHJcbiAgLCBwYXVzZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgIGlmICh0aGlzLmZ4KVxyXG4gICAgICAgIHRoaXMuZngucGF1c2UoKVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuICAgIC8vIFBsYXkgcGF1c2VkIGN1cnJlbnQgYW5pbWF0aW9uXHJcbiAgLCBwbGF5OiBmdW5jdGlvbigpIHtcclxuICAgICAgaWYgKHRoaXMuZngpXHJcbiAgICAgICAgdGhpcy5meC5wbGF5KClcclxuXHJcbiAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcbiAgICAvLyBTZXQvR2V0IHRoZSBzcGVlZCBvZiB0aGUgYW5pbWF0aW9uc1xyXG4gICwgc3BlZWQ6IGZ1bmN0aW9uKHNwZWVkKSB7XHJcbiAgICAgIGlmICh0aGlzLmZ4KVxyXG4gICAgICAgIGlmIChzcGVlZCA9PSBudWxsKVxyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuZnguc3BlZWQoKVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgIHRoaXMuZnguc3BlZWQoc3BlZWQpXHJcblxyXG4gICAgICByZXR1cm4gdGhpc1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbn0pXHJcblxyXG4vLyBNb3JwaE9iaiBpcyB1c2VkIHdoZW5ldmVyIG5vIG1vcnBoYWJsZSBvYmplY3QgaXMgZ2l2ZW5cclxuU1ZHLk1vcnBoT2JqID0gU1ZHLmludmVudCh7XHJcblxyXG4gIGNyZWF0ZTogZnVuY3Rpb24oZnJvbSwgdG8pe1xyXG4gICAgLy8gcHJlcGFyZSBjb2xvciBmb3IgbW9ycGhpbmdcclxuICAgIGlmKFNWRy5Db2xvci5pc0NvbG9yKHRvKSkgcmV0dXJuIG5ldyBTVkcuQ29sb3IoZnJvbSkubW9ycGgodG8pXHJcbiAgICAvLyBwcmVwYXJlIG51bWJlciBmb3IgbW9ycGhpbmdcclxuICAgIGlmKFNWRy5yZWdleC5udW1iZXJBbmRVbml0LnRlc3QodG8pKSByZXR1cm4gbmV3IFNWRy5OdW1iZXIoZnJvbSkubW9ycGgodG8pXHJcblxyXG4gICAgLy8gcHJlcGFyZSBmb3IgcGxhaW4gbW9ycGhpbmdcclxuICAgIHRoaXMudmFsdWUgPSBmcm9tXHJcbiAgICB0aGlzLmRlc3RpbmF0aW9uID0gdG9cclxuICB9XHJcblxyXG4sIGV4dGVuZDoge1xyXG4gICAgYXQ6IGZ1bmN0aW9uKHBvcywgcmVhbCl7XHJcbiAgICAgIHJldHVybiByZWFsIDwgMSA/IHRoaXMudmFsdWUgOiB0aGlzLmRlc3RpbmF0aW9uXHJcbiAgICB9LFxyXG5cclxuICAgIHZhbHVlT2Y6IGZ1bmN0aW9uKCl7XHJcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlXHJcbiAgICB9XHJcbiAgfVxyXG5cclxufSlcclxuXHJcblNWRy5leHRlbmQoU1ZHLkZYLCB7XHJcbiAgLy8gQWRkIGFuaW1hdGFibGUgYXR0cmlidXRlc1xyXG4gIGF0dHI6IGZ1bmN0aW9uKGEsIHYsIHJlbGF0aXZlKSB7XHJcbiAgICAvLyBhcHBseSBhdHRyaWJ1dGVzIGluZGl2aWR1YWxseVxyXG4gICAgaWYgKHR5cGVvZiBhID09ICdvYmplY3QnKSB7XHJcbiAgICAgIGZvciAodmFyIGtleSBpbiBhKVxyXG4gICAgICAgIHRoaXMuYXR0cihrZXksIGFba2V5XSlcclxuXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmFkZChhLCB2LCAnYXR0cnMnKVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG4gIC8vIEFkZCBhbmltYXRhYmxlIHN0eWxlc1xyXG4sIHN0eWxlOiBmdW5jdGlvbihzLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIHMgPT0gJ29iamVjdCcpXHJcbiAgICAgIGZvciAodmFyIGtleSBpbiBzKVxyXG4gICAgICAgIHRoaXMuc3R5bGUoa2V5LCBzW2tleV0pXHJcblxyXG4gICAgZWxzZVxyXG4gICAgICB0aGlzLmFkZChzLCB2LCAnc3R5bGVzJylcclxuXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuICAvLyBBbmltYXRhYmxlIHgtYXhpc1xyXG4sIHg6IGZ1bmN0aW9uKHgsIHJlbGF0aXZlKSB7XHJcbiAgICBpZih0aGlzLnRhcmdldCgpIGluc3RhbmNlb2YgU1ZHLkcpe1xyXG4gICAgICB0aGlzLnRyYW5zZm9ybSh7eDp4fSwgcmVsYXRpdmUpXHJcbiAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG51bSA9IG5ldyBTVkcuTnVtYmVyKHgpXHJcbiAgICBudW0ucmVsYXRpdmUgPSByZWxhdGl2ZVxyXG4gICAgcmV0dXJuIHRoaXMuYWRkKCd4JywgbnVtKVxyXG4gIH1cclxuICAvLyBBbmltYXRhYmxlIHktYXhpc1xyXG4sIHk6IGZ1bmN0aW9uKHksIHJlbGF0aXZlKSB7XHJcbiAgICBpZih0aGlzLnRhcmdldCgpIGluc3RhbmNlb2YgU1ZHLkcpe1xyXG4gICAgICB0aGlzLnRyYW5zZm9ybSh7eTp5fSwgcmVsYXRpdmUpXHJcbiAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG51bSA9IG5ldyBTVkcuTnVtYmVyKHkpXHJcbiAgICBudW0ucmVsYXRpdmUgPSByZWxhdGl2ZVxyXG4gICAgcmV0dXJuIHRoaXMuYWRkKCd5JywgbnVtKVxyXG4gIH1cclxuICAvLyBBbmltYXRhYmxlIGNlbnRlciB4LWF4aXNcclxuLCBjeDogZnVuY3Rpb24oeCkge1xyXG4gICAgcmV0dXJuIHRoaXMuYWRkKCdjeCcsIG5ldyBTVkcuTnVtYmVyKHgpKVxyXG4gIH1cclxuICAvLyBBbmltYXRhYmxlIGNlbnRlciB5LWF4aXNcclxuLCBjeTogZnVuY3Rpb24oeSkge1xyXG4gICAgcmV0dXJuIHRoaXMuYWRkKCdjeScsIG5ldyBTVkcuTnVtYmVyKHkpKVxyXG4gIH1cclxuICAvLyBBZGQgYW5pbWF0YWJsZSBtb3ZlXHJcbiwgbW92ZTogZnVuY3Rpb24oeCwgeSkge1xyXG4gICAgcmV0dXJuIHRoaXMueCh4KS55KHkpXHJcbiAgfVxyXG4gIC8vIEFkZCBhbmltYXRhYmxlIGNlbnRlclxyXG4sIGNlbnRlcjogZnVuY3Rpb24oeCwgeSkge1xyXG4gICAgcmV0dXJuIHRoaXMuY3goeCkuY3koeSlcclxuICB9XHJcbiAgLy8gQWRkIGFuaW1hdGFibGUgc2l6ZVxyXG4sIHNpemU6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgIGlmICh0aGlzLnRhcmdldCgpIGluc3RhbmNlb2YgU1ZHLlRleHQpIHtcclxuICAgICAgLy8gYW5pbWF0ZSBmb250IHNpemUgZm9yIFRleHQgZWxlbWVudHNcclxuICAgICAgdGhpcy5hdHRyKCdmb250LXNpemUnLCB3aWR0aClcclxuXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBhbmltYXRlIGJib3ggYmFzZWQgc2l6ZSBmb3IgYWxsIG90aGVyIGVsZW1lbnRzXHJcbiAgICAgIHZhciBib3hcclxuXHJcbiAgICAgIGlmKCF3aWR0aCB8fCAhaGVpZ2h0KXtcclxuICAgICAgICBib3ggPSB0aGlzLnRhcmdldCgpLmJib3goKVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZighd2lkdGgpe1xyXG4gICAgICAgIHdpZHRoID0gYm94LndpZHRoIC8gYm94LmhlaWdodCAgKiBoZWlnaHRcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYoIWhlaWdodCl7XHJcbiAgICAgICAgaGVpZ2h0ID0gYm94LmhlaWdodCAvIGJveC53aWR0aCAgKiB3aWR0aFxyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmFkZCgnd2lkdGgnICwgbmV3IFNWRy5OdW1iZXIod2lkdGgpKVxyXG4gICAgICAgICAgLmFkZCgnaGVpZ2h0JywgbmV3IFNWRy5OdW1iZXIoaGVpZ2h0KSlcclxuXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcbiAgLy8gQWRkIGFuaW1hdGFibGUgcGxvdFxyXG4sIHBsb3Q6IGZ1bmN0aW9uKCkge1xyXG4gICAgLy8gV2UgdXNlIGFyZ3VtZW50cyBoZXJlIHNpbmNlIFNWRy5MaW5lJ3MgcGxvdCBtZXRob2QgY2FuIGJlIHBhc3NlZCA0IHBhcmFtZXRlcnNcclxuICAgIHJldHVybiB0aGlzLmFkZCgncGxvdCcsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpIDogYXJndW1lbnRzWzBdKVxyXG4gIH1cclxuICAvLyBBZGQgbGVhZGluZyBtZXRob2RcclxuLCBsZWFkaW5nOiBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHRoaXMudGFyZ2V0KCkubGVhZGluZyA/XHJcbiAgICAgIHRoaXMuYWRkKCdsZWFkaW5nJywgbmV3IFNWRy5OdW1iZXIodmFsdWUpKSA6XHJcbiAgICAgIHRoaXNcclxuICB9XHJcbiAgLy8gQWRkIGFuaW1hdGFibGUgdmlld2JveFxyXG4sIHZpZXdib3g6IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgIGlmICh0aGlzLnRhcmdldCgpIGluc3RhbmNlb2YgU1ZHLkNvbnRhaW5lcikge1xyXG4gICAgICB0aGlzLmFkZCgndmlld2JveCcsIG5ldyBTVkcuVmlld0JveCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSlcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuLCB1cGRhdGU6IGZ1bmN0aW9uKG8pIHtcclxuICAgIGlmICh0aGlzLnRhcmdldCgpIGluc3RhbmNlb2YgU1ZHLlN0b3ApIHtcclxuICAgICAgaWYgKHR5cGVvZiBvID09ICdudW1iZXInIHx8IG8gaW5zdGFuY2VvZiBTVkcuTnVtYmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKHtcclxuICAgICAgICAgIG9mZnNldDogIGFyZ3VtZW50c1swXVxyXG4gICAgICAgICwgY29sb3I6ICAgYXJndW1lbnRzWzFdXHJcbiAgICAgICAgLCBvcGFjaXR5OiBhcmd1bWVudHNbMl1cclxuICAgICAgICB9KVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoby5vcGFjaXR5ICE9IG51bGwpIHRoaXMuYXR0cignc3RvcC1vcGFjaXR5Jywgby5vcGFjaXR5KVxyXG4gICAgICBpZiAoby5jb2xvciAgICE9IG51bGwpIHRoaXMuYXR0cignc3RvcC1jb2xvcicsIG8uY29sb3IpXHJcbiAgICAgIGlmIChvLm9mZnNldCAgIT0gbnVsbCkgdGhpcy5hdHRyKCdvZmZzZXQnLCBvLm9mZnNldClcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxufSlcclxuXG5TVkcuQm94ID0gU1ZHLmludmVudCh7XHJcbiAgY3JlYXRlOiBmdW5jdGlvbih4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICBpZiAodHlwZW9mIHggPT0gJ29iamVjdCcgJiYgISh4IGluc3RhbmNlb2YgU1ZHLkVsZW1lbnQpKSB7XHJcbiAgICAgIC8vIGNocm9tZXMgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGhhcyBubyB4IGFuZCB5IHByb3BlcnR5XHJcbiAgICAgIHJldHVybiBTVkcuQm94LmNhbGwodGhpcywgeC5sZWZ0ICE9IG51bGwgPyB4LmxlZnQgOiB4LnggLCB4LnRvcCAhPSBudWxsID8geC50b3AgOiB4LnksIHgud2lkdGgsIHguaGVpZ2h0KVxyXG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDQpIHtcclxuICAgICAgdGhpcy54ID0geFxyXG4gICAgICB0aGlzLnkgPSB5XHJcbiAgICAgIHRoaXMud2lkdGggPSB3aWR0aFxyXG4gICAgICB0aGlzLmhlaWdodCA9IGhlaWdodFxyXG5cclxuICAgIH1cclxuXHJcbiAgICAvLyBhZGQgY2VudGVyLCByaWdodCwgYm90dG9tLi4uXHJcbiAgICBmdWxsQm94KHRoaXMpXHJcbiAgfVxyXG4sIGV4dGVuZDoge1xyXG4gICAgLy8gTWVyZ2UgcmVjdCBib3ggd2l0aCBhbm90aGVyLCByZXR1cm4gYSBuZXcgaW5zdGFuY2VcclxuICAgIG1lcmdlOiBmdW5jdGlvbihib3gpIHtcclxuICAgICAgdmFyIGIgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpXHJcblxyXG4gICAgICAvLyBtZXJnZSBib3hlc1xyXG4gICAgICBiLnggICAgICA9IE1hdGgubWluKHRoaXMueCwgYm94LngpXHJcbiAgICAgIGIueSAgICAgID0gTWF0aC5taW4odGhpcy55LCBib3gueSlcclxuICAgICAgYi53aWR0aCAgPSBNYXRoLm1heCh0aGlzLnggKyB0aGlzLndpZHRoLCAgYm94LnggKyBib3gud2lkdGgpICAtIGIueFxyXG4gICAgICBiLmhlaWdodCA9IE1hdGgubWF4KHRoaXMueSArIHRoaXMuaGVpZ2h0LCBib3gueSArIGJveC5oZWlnaHQpIC0gYi55XHJcblxyXG4gICAgICByZXR1cm4gZnVsbEJveChiKVxyXG4gICAgfVxyXG5cclxuICAsIHRyYW5zZm9ybTogZnVuY3Rpb24obSkge1xyXG4gICAgICB2YXIgeE1pbiA9IEluZmluaXR5LCB4TWF4ID0gLUluZmluaXR5LCB5TWluID0gSW5maW5pdHksIHlNYXggPSAtSW5maW5pdHksIHBcclxuXHJcbiAgICAgIHZhciBwdHMgPSBbXHJcbiAgICAgICAgbmV3IFNWRy5Qb2ludCh0aGlzLngsIHRoaXMueSksXHJcbiAgICAgICAgbmV3IFNWRy5Qb2ludCh0aGlzLngyLCB0aGlzLnkpLFxyXG4gICAgICAgIG5ldyBTVkcuUG9pbnQodGhpcy54LCB0aGlzLnkyKSxcclxuICAgICAgICBuZXcgU1ZHLlBvaW50KHRoaXMueDIsIHRoaXMueTIpXHJcbiAgICAgIF1cclxuXHJcbiAgICAgIHB0cy5mb3JFYWNoKGZ1bmN0aW9uKHApIHtcclxuICAgICAgICBwID0gcC50cmFuc2Zvcm0obSlcclxuICAgICAgICB4TWluID0gTWF0aC5taW4oeE1pbixwLngpXHJcbiAgICAgICAgeE1heCA9IE1hdGgubWF4KHhNYXgscC54KVxyXG4gICAgICAgIHlNaW4gPSBNYXRoLm1pbih5TWluLHAueSlcclxuICAgICAgICB5TWF4ID0gTWF0aC5tYXgoeU1heCxwLnkpXHJcbiAgICAgIH0pXHJcblxyXG4gICAgICBiYm94ID0gbmV3IHRoaXMuY29uc3RydWN0b3IoKVxyXG4gICAgICBiYm94LnggPSB4TWluXHJcbiAgICAgIGJib3gud2lkdGggPSB4TWF4LXhNaW5cclxuICAgICAgYmJveC55ID0geU1pblxyXG4gICAgICBiYm94LmhlaWdodCA9IHlNYXgteU1pblxyXG5cclxuICAgICAgZnVsbEJveChiYm94KVxyXG5cclxuICAgICAgcmV0dXJuIGJib3hcclxuICAgIH1cclxuICB9XHJcbn0pXHJcblxyXG5TVkcuQkJveCA9IFNWRy5pbnZlbnQoe1xyXG4gIC8vIEluaXRpYWxpemVcclxuICBjcmVhdGU6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuICAgIFNWRy5Cb3guYXBwbHkodGhpcywgW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKVxyXG5cclxuICAgIC8vIGdldCB2YWx1ZXMgaWYgZWxlbWVudCBpcyBnaXZlblxyXG4gICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBTVkcuRWxlbWVudCkge1xyXG4gICAgICB2YXIgYm94XHJcblxyXG4gICAgICAvLyB5ZXMgdGhpcyBpcyB1Z2x5LCBidXQgRmlyZWZveCBjYW4gYmUgYSBiaXRjaCB3aGVuIGl0IGNvbWVzIHRvIGVsZW1lbnRzIHRoYXQgYXJlIG5vdCB5ZXQgcmVuZGVyZWRcclxuICAgICAgdHJ5IHtcclxuXHJcbiAgICAgICAgaWYgKCFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnMpe1xyXG4gICAgICAgICAgLy8gVGhpcyBpcyBJRSAtIGl0IGRvZXMgbm90IHN1cHBvcnQgY29udGFpbnMoKSBmb3IgdG9wLWxldmVsIFNWR3NcclxuICAgICAgICAgIHZhciB0b3BQYXJlbnQgPSBlbGVtZW50Lm5vZGVcclxuICAgICAgICAgIHdoaWxlICh0b3BQYXJlbnQucGFyZW50Tm9kZSl7XHJcbiAgICAgICAgICAgIHRvcFBhcmVudCA9IHRvcFBhcmVudC5wYXJlbnROb2RlXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAodG9wUGFyZW50ICE9IGRvY3VtZW50KSB0aHJvdyBuZXcgRXhjZXB0aW9uKCdFbGVtZW50IG5vdCBpbiB0aGUgZG9tJylcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gdGhlIGVsZW1lbnQgaXMgTk9UIGluIHRoZSBkb20sIHRocm93IGVycm9yXHJcbiAgICAgICAgICBpZighZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zKGVsZW1lbnQubm9kZSkpIHRocm93IG5ldyBFeGNlcHRpb24oJ0VsZW1lbnQgbm90IGluIHRoZSBkb20nKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gZmluZCBuYXRpdmUgYmJveFxyXG4gICAgICAgIGJveCA9IGVsZW1lbnQubm9kZS5nZXRCQm94KClcclxuICAgICAgfSBjYXRjaChlKSB7XHJcbiAgICAgICAgaWYoZWxlbWVudCBpbnN0YW5jZW9mIFNWRy5TaGFwZSl7XHJcbiAgICAgICAgICB2YXIgY2xvbmUgPSBlbGVtZW50LmNsb25lKFNWRy5wYXJzZXIuZHJhdykuc2hvdygpXHJcbiAgICAgICAgICBib3ggPSBjbG9uZS5ub2RlLmdldEJCb3goKVxyXG4gICAgICAgICAgY2xvbmUucmVtb3ZlKClcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgIGJveCA9IHtcclxuICAgICAgICAgICAgeDogICAgICBlbGVtZW50Lm5vZGUuY2xpZW50TGVmdFxyXG4gICAgICAgICAgLCB5OiAgICAgIGVsZW1lbnQubm9kZS5jbGllbnRUb3BcclxuICAgICAgICAgICwgd2lkdGg6ICBlbGVtZW50Lm5vZGUuY2xpZW50V2lkdGhcclxuICAgICAgICAgICwgaGVpZ2h0OiBlbGVtZW50Lm5vZGUuY2xpZW50SGVpZ2h0XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBTVkcuQm94LmNhbGwodGhpcywgYm94KVxyXG4gICAgfVxyXG5cclxuICB9XHJcblxyXG4gIC8vIERlZmluZSBhbmNlc3RvclxyXG4sIGluaGVyaXQ6IFNWRy5Cb3hcclxuXHJcbiAgLy8gRGVmaW5lIFBhcmVudFxyXG4sIHBhcmVudDogU1ZHLkVsZW1lbnRcclxuXHJcbiAgLy8gQ29uc3RydWN0b3JcclxuLCBjb25zdHJ1Y3Q6IHtcclxuICAgIC8vIEdldCBib3VuZGluZyBib3hcclxuICAgIGJib3g6IGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gbmV3IFNWRy5CQm94KHRoaXMpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxufSlcclxuXHJcblNWRy5CQm94LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNWRy5CQm94XHJcblxyXG5cclxuU1ZHLmV4dGVuZChTVkcuRWxlbWVudCwge1xyXG4gIHRib3g6IGZ1bmN0aW9uKCl7XHJcbiAgICBjb25zb2xlLndhcm4oJ1VzZSBvZiBUQm94IGlzIGRlcHJlY2F0ZWQgYW5kIG1hcHBlZCB0byBSQm94LiBVc2UgLnJib3goKSBpbnN0ZWFkLicpXHJcbiAgICByZXR1cm4gdGhpcy5yYm94KHRoaXMuZG9jKCkpXHJcbiAgfVxyXG59KVxyXG5cclxuU1ZHLlJCb3ggPSBTVkcuaW52ZW50KHtcclxuICAvLyBJbml0aWFsaXplXHJcbiAgY3JlYXRlOiBmdW5jdGlvbihlbGVtZW50KSB7XHJcbiAgICBTVkcuQm94LmFwcGx5KHRoaXMsIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSlcclxuXHJcbiAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIFNWRy5FbGVtZW50KSB7XHJcbiAgICAgIFNWRy5Cb3guY2FsbCh0aGlzLCBlbGVtZW50Lm5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuLCBpbmhlcml0OiBTVkcuQm94XHJcblxyXG4gIC8vIGRlZmluZSBQYXJlbnRcclxuLCBwYXJlbnQ6IFNWRy5FbGVtZW50XHJcblxyXG4sIGV4dGVuZDoge1xyXG4gICAgYWRkT2Zmc2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgLy8gb2Zmc2V0IGJ5IHdpbmRvdyBzY3JvbGwgcG9zaXRpb24sIGJlY2F1c2UgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGNoYW5nZXMgd2hlbiB3aW5kb3cgaXMgc2Nyb2xsZWRcclxuICAgICAgdGhpcy54ICs9IHdpbmRvdy5wYWdlWE9mZnNldFxyXG4gICAgICB0aGlzLnkgKz0gd2luZG93LnBhZ2VZT2Zmc2V0XHJcbiAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBDb25zdHJ1Y3RvclxyXG4sIGNvbnN0cnVjdDoge1xyXG4gICAgLy8gR2V0IHJlY3QgYm94XHJcbiAgICByYm94OiBmdW5jdGlvbihlbCkge1xyXG4gICAgICBpZiAoZWwpIHJldHVybiBuZXcgU1ZHLlJCb3godGhpcykudHJhbnNmb3JtKGVsLnNjcmVlbkNUTSgpLmludmVyc2UoKSlcclxuICAgICAgcmV0dXJuIG5ldyBTVkcuUkJveCh0aGlzKS5hZGRPZmZzZXQoKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbn0pXHJcblxyXG5TVkcuUkJveC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTVkcuUkJveFxyXG5cblNWRy5NYXRyaXggPSBTVkcuaW52ZW50KHtcclxuICAvLyBJbml0aWFsaXplXHJcbiAgY3JlYXRlOiBmdW5jdGlvbihzb3VyY2UpIHtcclxuICAgIHZhciBpLCBiYXNlID0gYXJyYXlUb01hdHJpeChbMSwgMCwgMCwgMSwgMCwgMF0pXHJcblxyXG4gICAgLy8gZW5zdXJlIHNvdXJjZSBhcyBvYmplY3RcclxuICAgIHNvdXJjZSA9IHNvdXJjZSBpbnN0YW5jZW9mIFNWRy5FbGVtZW50ID9cclxuICAgICAgc291cmNlLm1hdHJpeGlmeSgpIDpcclxuICAgIHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnID9cclxuICAgICAgYXJyYXlUb01hdHJpeChzb3VyY2Uuc3BsaXQoU1ZHLnJlZ2V4LmRlbGltaXRlcikubWFwKHBhcnNlRmxvYXQpKSA6XHJcbiAgICBhcmd1bWVudHMubGVuZ3RoID09IDYgP1xyXG4gICAgICBhcnJheVRvTWF0cml4KFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSkgOlxyXG4gICAgQXJyYXkuaXNBcnJheShzb3VyY2UpID9cclxuICAgICAgYXJyYXlUb01hdHJpeChzb3VyY2UpIDpcclxuICAgIHR5cGVvZiBzb3VyY2UgPT09ICdvYmplY3QnID9cclxuICAgICAgc291cmNlIDogYmFzZVxyXG5cclxuICAgIC8vIG1lcmdlIHNvdXJjZVxyXG4gICAgZm9yIChpID0gYWJjZGVmLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKVxyXG4gICAgICB0aGlzW2FiY2RlZltpXV0gPSBzb3VyY2UgJiYgdHlwZW9mIHNvdXJjZVthYmNkZWZbaV1dID09PSAnbnVtYmVyJyA/XHJcbiAgICAgICAgc291cmNlW2FiY2RlZltpXV0gOiBiYXNlW2FiY2RlZltpXV1cclxuICB9XHJcblxyXG4gIC8vIEFkZCBtZXRob2RzXHJcbiwgZXh0ZW5kOiB7XHJcbiAgICAvLyBFeHRyYWN0IGluZGl2aWR1YWwgdHJhbnNmb3JtYXRpb25zXHJcbiAgICBleHRyYWN0OiBmdW5jdGlvbigpIHtcclxuICAgICAgLy8gZmluZCBkZWx0YSB0cmFuc2Zvcm0gcG9pbnRzXHJcbiAgICAgIHZhciBweCAgICA9IGRlbHRhVHJhbnNmb3JtUG9pbnQodGhpcywgMCwgMSlcclxuICAgICAgICAsIHB5ICAgID0gZGVsdGFUcmFuc2Zvcm1Qb2ludCh0aGlzLCAxLCAwKVxyXG4gICAgICAgICwgc2tld1ggPSAxODAgLyBNYXRoLlBJICogTWF0aC5hdGFuMihweC55LCBweC54KSAtIDkwXHJcblxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIC8vIHRyYW5zbGF0aW9uXHJcbiAgICAgICAgeDogICAgICAgIHRoaXMuZVxyXG4gICAgICAsIHk6ICAgICAgICB0aGlzLmZcclxuICAgICAgLCB0cmFuc2Zvcm1lZFg6KHRoaXMuZSAqIE1hdGguY29zKHNrZXdYICogTWF0aC5QSSAvIDE4MCkgKyB0aGlzLmYgKiBNYXRoLnNpbihza2V3WCAqIE1hdGguUEkgLyAxODApKSAvIE1hdGguc3FydCh0aGlzLmEgKiB0aGlzLmEgKyB0aGlzLmIgKiB0aGlzLmIpXHJcbiAgICAgICwgdHJhbnNmb3JtZWRZOih0aGlzLmYgKiBNYXRoLmNvcyhza2V3WCAqIE1hdGguUEkgLyAxODApICsgdGhpcy5lICogTWF0aC5zaW4oLXNrZXdYICogTWF0aC5QSSAvIDE4MCkpIC8gTWF0aC5zcXJ0KHRoaXMuYyAqIHRoaXMuYyArIHRoaXMuZCAqIHRoaXMuZClcclxuICAgICAgICAvLyBza2V3XHJcbiAgICAgICwgc2tld1g6ICAgIC1za2V3WFxyXG4gICAgICAsIHNrZXdZOiAgICAxODAgLyBNYXRoLlBJICogTWF0aC5hdGFuMihweS55LCBweS54KVxyXG4gICAgICAgIC8vIHNjYWxlXHJcbiAgICAgICwgc2NhbGVYOiAgIE1hdGguc3FydCh0aGlzLmEgKiB0aGlzLmEgKyB0aGlzLmIgKiB0aGlzLmIpXHJcbiAgICAgICwgc2NhbGVZOiAgIE1hdGguc3FydCh0aGlzLmMgKiB0aGlzLmMgKyB0aGlzLmQgKiB0aGlzLmQpXHJcbiAgICAgICAgLy8gcm90YXRpb25cclxuICAgICAgLCByb3RhdGlvbjogc2tld1hcclxuICAgICAgLCBhOiB0aGlzLmFcclxuICAgICAgLCBiOiB0aGlzLmJcclxuICAgICAgLCBjOiB0aGlzLmNcclxuICAgICAgLCBkOiB0aGlzLmRcclxuICAgICAgLCBlOiB0aGlzLmVcclxuICAgICAgLCBmOiB0aGlzLmZcclxuICAgICAgLCBtYXRyaXg6IG5ldyBTVkcuTWF0cml4KHRoaXMpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIENsb25lIG1hdHJpeFxyXG4gICwgY2xvbmU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gbmV3IFNWRy5NYXRyaXgodGhpcylcclxuICAgIH1cclxuICAgIC8vIE1vcnBoIG9uZSBtYXRyaXggaW50byBhbm90aGVyXHJcbiAgLCBtb3JwaDogZnVuY3Rpb24obWF0cml4KSB7XHJcbiAgICAgIC8vIHN0b3JlIG5ldyBkZXN0aW5hdGlvblxyXG4gICAgICB0aGlzLmRlc3RpbmF0aW9uID0gbmV3IFNWRy5NYXRyaXgobWF0cml4KVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuICAgIC8vIEdldCBtb3JwaGVkIG1hdHJpeCBhdCBhIGdpdmVuIHBvc2l0aW9uXHJcbiAgLCBhdDogZnVuY3Rpb24ocG9zKSB7XHJcbiAgICAgIC8vIG1ha2Ugc3VyZSBhIGRlc3RpbmF0aW9uIGlzIGRlZmluZWRcclxuICAgICAgaWYgKCF0aGlzLmRlc3RpbmF0aW9uKSByZXR1cm4gdGhpc1xyXG5cclxuICAgICAgLy8gY2FsY3VsYXRlIG1vcnBoZWQgbWF0cml4IGF0IGEgZ2l2ZW4gcG9zaXRpb25cclxuICAgICAgdmFyIG1hdHJpeCA9IG5ldyBTVkcuTWF0cml4KHtcclxuICAgICAgICBhOiB0aGlzLmEgKyAodGhpcy5kZXN0aW5hdGlvbi5hIC0gdGhpcy5hKSAqIHBvc1xyXG4gICAgICAsIGI6IHRoaXMuYiArICh0aGlzLmRlc3RpbmF0aW9uLmIgLSB0aGlzLmIpICogcG9zXHJcbiAgICAgICwgYzogdGhpcy5jICsgKHRoaXMuZGVzdGluYXRpb24uYyAtIHRoaXMuYykgKiBwb3NcclxuICAgICAgLCBkOiB0aGlzLmQgKyAodGhpcy5kZXN0aW5hdGlvbi5kIC0gdGhpcy5kKSAqIHBvc1xyXG4gICAgICAsIGU6IHRoaXMuZSArICh0aGlzLmRlc3RpbmF0aW9uLmUgLSB0aGlzLmUpICogcG9zXHJcbiAgICAgICwgZjogdGhpcy5mICsgKHRoaXMuZGVzdGluYXRpb24uZiAtIHRoaXMuZikgKiBwb3NcclxuICAgICAgfSlcclxuXHJcbiAgICAgIHJldHVybiBtYXRyaXhcclxuICAgIH1cclxuICAgIC8vIE11bHRpcGxpZXMgYnkgZ2l2ZW4gbWF0cml4XHJcbiAgLCBtdWx0aXBseTogZnVuY3Rpb24obWF0cml4KSB7XHJcbiAgICAgIHJldHVybiBuZXcgU1ZHLk1hdHJpeCh0aGlzLm5hdGl2ZSgpLm11bHRpcGx5KHBhcnNlTWF0cml4KG1hdHJpeCkubmF0aXZlKCkpKVxyXG4gICAgfVxyXG4gICAgLy8gSW52ZXJzZXMgbWF0cml4XHJcbiAgLCBpbnZlcnNlOiBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIG5ldyBTVkcuTWF0cml4KHRoaXMubmF0aXZlKCkuaW52ZXJzZSgpKVxyXG4gICAgfVxyXG4gICAgLy8gVHJhbnNsYXRlIG1hdHJpeFxyXG4gICwgdHJhbnNsYXRlOiBmdW5jdGlvbih4LCB5KSB7XHJcbiAgICAgIHJldHVybiBuZXcgU1ZHLk1hdHJpeCh0aGlzLm5hdGl2ZSgpLnRyYW5zbGF0ZSh4IHx8IDAsIHkgfHwgMCkpXHJcbiAgICB9XHJcbiAgICAvLyBTY2FsZSBtYXRyaXhcclxuICAsIHNjYWxlOiBmdW5jdGlvbih4LCB5LCBjeCwgY3kpIHtcclxuICAgICAgLy8gc3VwcG9ydCB1bmlmb3JtYWwgc2NhbGVcclxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkge1xyXG4gICAgICAgIHkgPSB4XHJcbiAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAzKSB7XHJcbiAgICAgICAgY3kgPSBjeFxyXG4gICAgICAgIGN4ID0geVxyXG4gICAgICAgIHkgPSB4XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0aGlzLmFyb3VuZChjeCwgY3ksIG5ldyBTVkcuTWF0cml4KHgsIDAsIDAsIHksIDAsIDApKVxyXG4gICAgfVxyXG4gICAgLy8gUm90YXRlIG1hdHJpeFxyXG4gICwgcm90YXRlOiBmdW5jdGlvbihyLCBjeCwgY3kpIHtcclxuICAgICAgLy8gY29udmVydCBkZWdyZWVzIHRvIHJhZGlhbnNcclxuICAgICAgciA9IFNWRy51dGlscy5yYWRpYW5zKHIpXHJcblxyXG4gICAgICByZXR1cm4gdGhpcy5hcm91bmQoY3gsIGN5LCBuZXcgU1ZHLk1hdHJpeChNYXRoLmNvcyhyKSwgTWF0aC5zaW4ociksIC1NYXRoLnNpbihyKSwgTWF0aC5jb3MociksIDAsIDApKVxyXG4gICAgfVxyXG4gICAgLy8gRmxpcCBtYXRyaXggb24geCBvciB5LCBhdCBhIGdpdmVuIG9mZnNldFxyXG4gICwgZmxpcDogZnVuY3Rpb24oYSwgbykge1xyXG4gICAgICBvID0gdHlwZW9mIGEgPT0gJ251bWJlcicgPyBhIDogb1xyXG4gICAgICByZXR1cm4gYSA9PSAneCcgP1xyXG4gICAgICAgICAgdGhpcy5zY2FsZSgtMSwgMSwgbywgMCkgOlxyXG4gICAgICAgIGEgPT0gJ3knID9cclxuICAgICAgICAgIHRoaXMuc2NhbGUoMSwgLTEsIDAsIG8pIDpcclxuICAgICAgICAgIHRoaXMuc2NhbGUoLTEsIC0xLCBvLCBvKVxyXG4gICAgfVxyXG4gICAgLy8gU2tld1xyXG4gICwgc2tldzogZnVuY3Rpb24oeCwgeSwgY3gsIGN5KSB7XHJcbiAgICAgIC8vIHN1cHBvcnQgdW5pZm9ybWFsIHNrZXdcclxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkge1xyXG4gICAgICAgIHkgPSB4XHJcbiAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAzKSB7XHJcbiAgICAgICAgY3kgPSBjeFxyXG4gICAgICAgIGN4ID0geVxyXG4gICAgICAgIHkgPSB4XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGNvbnZlcnQgZGVncmVlcyB0byByYWRpYW5zXHJcbiAgICAgIHggPSBTVkcudXRpbHMucmFkaWFucyh4KVxyXG4gICAgICB5ID0gU1ZHLnV0aWxzLnJhZGlhbnMoeSlcclxuXHJcbiAgICAgIHJldHVybiB0aGlzLmFyb3VuZChjeCwgY3ksIG5ldyBTVkcuTWF0cml4KDEsIE1hdGgudGFuKHkpLCBNYXRoLnRhbih4KSwgMSwgMCwgMCkpXHJcbiAgICB9XHJcbiAgICAvLyBTa2V3WFxyXG4gICwgc2tld1g6IGZ1bmN0aW9uKHgsIGN4LCBjeSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5za2V3KHgsIDAsIGN4LCBjeSlcclxuICAgIH1cclxuICAgIC8vIFNrZXdZXHJcbiAgLCBza2V3WTogZnVuY3Rpb24oeSwgY3gsIGN5KSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnNrZXcoMCwgeSwgY3gsIGN5KVxyXG4gICAgfVxyXG4gICAgLy8gVHJhbnNmb3JtIGFyb3VuZCBhIGNlbnRlciBwb2ludFxyXG4gICwgYXJvdW5kOiBmdW5jdGlvbihjeCwgY3ksIG1hdHJpeCkge1xyXG4gICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgIC5tdWx0aXBseShuZXcgU1ZHLk1hdHJpeCgxLCAwLCAwLCAxLCBjeCB8fCAwLCBjeSB8fCAwKSlcclxuICAgICAgICAubXVsdGlwbHkobWF0cml4KVxyXG4gICAgICAgIC5tdWx0aXBseShuZXcgU1ZHLk1hdHJpeCgxLCAwLCAwLCAxLCAtY3ggfHwgMCwgLWN5IHx8IDApKVxyXG4gICAgfVxyXG4gICAgLy8gQ29udmVydCB0byBuYXRpdmUgU1ZHTWF0cml4XHJcbiAgLCBuYXRpdmU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAvLyBjcmVhdGUgbmV3IG1hdHJpeFxyXG4gICAgICB2YXIgbWF0cml4ID0gU1ZHLnBhcnNlci5uYXRpdmUuY3JlYXRlU1ZHTWF0cml4KClcclxuXHJcbiAgICAgIC8vIHVwZGF0ZSB3aXRoIGN1cnJlbnQgdmFsdWVzXHJcbiAgICAgIGZvciAodmFyIGkgPSBhYmNkZWYubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXHJcbiAgICAgICAgbWF0cml4W2FiY2RlZltpXV0gPSB0aGlzW2FiY2RlZltpXV1cclxuXHJcbiAgICAgIHJldHVybiBtYXRyaXhcclxuICAgIH1cclxuICAgIC8vIENvbnZlcnQgbWF0cml4IHRvIHN0cmluZ1xyXG4gICwgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gJ21hdHJpeCgnICsgdGhpcy5hICsgJywnICsgdGhpcy5iICsgJywnICsgdGhpcy5jICsgJywnICsgdGhpcy5kICsgJywnICsgdGhpcy5lICsgJywnICsgdGhpcy5mICsgJyknXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBEZWZpbmUgcGFyZW50XHJcbiwgcGFyZW50OiBTVkcuRWxlbWVudFxyXG5cclxuICAvLyBBZGQgcGFyZW50IG1ldGhvZFxyXG4sIGNvbnN0cnVjdDoge1xyXG4gICAgLy8gR2V0IGN1cnJlbnQgbWF0cml4XHJcbiAgICBjdG06IGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gbmV3IFNWRy5NYXRyaXgodGhpcy5ub2RlLmdldENUTSgpKVxyXG4gICAgfSxcclxuICAgIC8vIEdldCBjdXJyZW50IHNjcmVlbiBtYXRyaXhcclxuICAgIHNjcmVlbkNUTTogZnVuY3Rpb24oKSB7XHJcbiAgICAgIC8qIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEzNDQ1MzdcclxuICAgICAgICAgVGhpcyBpcyBuZWVkZWQgYmVjYXVzZSBGRiBkb2VzIG5vdCByZXR1cm4gdGhlIHRyYW5zZm9ybWF0aW9uIG1hdHJpeFxyXG4gICAgICAgICBmb3IgdGhlIGlubmVyIGNvb3JkaW5hdGUgc3lzdGVtIHdoZW4gZ2V0U2NyZWVuQ1RNKCkgaXMgY2FsbGVkIG9uIG5lc3RlZCBzdmdzLlxyXG4gICAgICAgICBIb3dldmVyIGFsbCBvdGhlciBCcm93c2VycyBkbyB0aGF0ICovXHJcbiAgICAgIGlmKHRoaXMgaW5zdGFuY2VvZiBTVkcuTmVzdGVkKSB7XHJcbiAgICAgICAgdmFyIHJlY3QgPSB0aGlzLnJlY3QoMSwxKVxyXG4gICAgICAgIHZhciBtID0gcmVjdC5ub2RlLmdldFNjcmVlbkNUTSgpXHJcbiAgICAgICAgcmVjdC5yZW1vdmUoKVxyXG4gICAgICAgIHJldHVybiBuZXcgU1ZHLk1hdHJpeChtKVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBuZXcgU1ZHLk1hdHJpeCh0aGlzLm5vZGUuZ2V0U2NyZWVuQ1RNKCkpXHJcbiAgICB9XHJcblxyXG4gIH1cclxuXHJcbn0pXHJcblxuU1ZHLlBvaW50ID0gU1ZHLmludmVudCh7XHJcbiAgLy8gSW5pdGlhbGl6ZVxyXG4gIGNyZWF0ZTogZnVuY3Rpb24oeCx5KSB7XHJcbiAgICB2YXIgaSwgc291cmNlLCBiYXNlID0ge3g6MCwgeTowfVxyXG5cclxuICAgIC8vIGVuc3VyZSBzb3VyY2UgYXMgb2JqZWN0XHJcbiAgICBzb3VyY2UgPSBBcnJheS5pc0FycmF5KHgpID9cclxuICAgICAge3g6eFswXSwgeTp4WzFdfSA6XHJcbiAgICB0eXBlb2YgeCA9PT0gJ29iamVjdCcgP1xyXG4gICAgICB7eDp4LngsIHk6eC55fSA6XHJcbiAgICB4ICE9IG51bGwgP1xyXG4gICAgICB7eDp4LCB5Oih5ICE9IG51bGwgPyB5IDogeCl9IDogYmFzZSAvLyBJZiB5IGhhcyBubyB2YWx1ZSwgdGhlbiB4IGlzIHVzZWQgaGFzIGl0cyB2YWx1ZVxyXG5cclxuICAgIC8vIG1lcmdlIHNvdXJjZVxyXG4gICAgdGhpcy54ID0gc291cmNlLnhcclxuICAgIHRoaXMueSA9IHNvdXJjZS55XHJcbiAgfVxyXG5cclxuICAvLyBBZGQgbWV0aG9kc1xyXG4sIGV4dGVuZDoge1xyXG4gICAgLy8gQ2xvbmUgcG9pbnRcclxuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIG5ldyBTVkcuUG9pbnQodGhpcylcclxuICAgIH1cclxuICAgIC8vIE1vcnBoIG9uZSBwb2ludCBpbnRvIGFub3RoZXJcclxuICAsIG1vcnBoOiBmdW5jdGlvbih4LCB5KSB7XHJcbiAgICAgIC8vIHN0b3JlIG5ldyBkZXN0aW5hdGlvblxyXG4gICAgICB0aGlzLmRlc3RpbmF0aW9uID0gbmV3IFNWRy5Qb2ludCh4LCB5KVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuICAgIC8vIEdldCBtb3JwaGVkIHBvaW50IGF0IGEgZ2l2ZW4gcG9zaXRpb25cclxuICAsIGF0OiBmdW5jdGlvbihwb3MpIHtcclxuICAgICAgLy8gbWFrZSBzdXJlIGEgZGVzdGluYXRpb24gaXMgZGVmaW5lZFxyXG4gICAgICBpZiAoIXRoaXMuZGVzdGluYXRpb24pIHJldHVybiB0aGlzXHJcblxyXG4gICAgICAvLyBjYWxjdWxhdGUgbW9ycGhlZCBtYXRyaXggYXQgYSBnaXZlbiBwb3NpdGlvblxyXG4gICAgICB2YXIgcG9pbnQgPSBuZXcgU1ZHLlBvaW50KHtcclxuICAgICAgICB4OiB0aGlzLnggKyAodGhpcy5kZXN0aW5hdGlvbi54IC0gdGhpcy54KSAqIHBvc1xyXG4gICAgICAsIHk6IHRoaXMueSArICh0aGlzLmRlc3RpbmF0aW9uLnkgLSB0aGlzLnkpICogcG9zXHJcbiAgICAgIH0pXHJcblxyXG4gICAgICByZXR1cm4gcG9pbnRcclxuICAgIH1cclxuICAgIC8vIENvbnZlcnQgdG8gbmF0aXZlIFNWR1BvaW50XHJcbiAgLCBuYXRpdmU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAvLyBjcmVhdGUgbmV3IHBvaW50XHJcbiAgICAgIHZhciBwb2ludCA9IFNWRy5wYXJzZXIubmF0aXZlLmNyZWF0ZVNWR1BvaW50KClcclxuXHJcbiAgICAgIC8vIHVwZGF0ZSB3aXRoIGN1cnJlbnQgdmFsdWVzXHJcbiAgICAgIHBvaW50LnggPSB0aGlzLnhcclxuICAgICAgcG9pbnQueSA9IHRoaXMueVxyXG5cclxuICAgICAgcmV0dXJuIHBvaW50XHJcbiAgICB9XHJcbiAgICAvLyB0cmFuc2Zvcm0gcG9pbnQgd2l0aCBtYXRyaXhcclxuICAsIHRyYW5zZm9ybTogZnVuY3Rpb24obWF0cml4KSB7XHJcbiAgICAgIHJldHVybiBuZXcgU1ZHLlBvaW50KHRoaXMubmF0aXZlKCkubWF0cml4VHJhbnNmb3JtKG1hdHJpeC5uYXRpdmUoKSkpXHJcbiAgICB9XHJcblxyXG4gIH1cclxuXHJcbn0pXHJcblxyXG5TVkcuZXh0ZW5kKFNWRy5FbGVtZW50LCB7XHJcblxyXG4gIC8vIEdldCBwb2ludFxyXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XHJcbiAgICByZXR1cm4gbmV3IFNWRy5Qb2ludCh4LHkpLnRyYW5zZm9ybSh0aGlzLnNjcmVlbkNUTSgpLmludmVyc2UoKSk7XHJcbiAgfVxyXG5cclxufSlcclxuXG5TVkcuZXh0ZW5kKFNWRy5FbGVtZW50LCB7XHJcbiAgLy8gU2V0IHN2ZyBlbGVtZW50IGF0dHJpYnV0ZVxyXG4gIGF0dHI6IGZ1bmN0aW9uKGEsIHYsIG4pIHtcclxuICAgIC8vIGFjdCBhcyBmdWxsIGdldHRlclxyXG4gICAgaWYgKGEgPT0gbnVsbCkge1xyXG4gICAgICAvLyBnZXQgYW4gb2JqZWN0IG9mIGF0dHJpYnV0ZXNcclxuICAgICAgYSA9IHt9XHJcbiAgICAgIHYgPSB0aGlzLm5vZGUuYXR0cmlidXRlc1xyXG4gICAgICBmb3IgKG4gPSB2Lmxlbmd0aCAtIDE7IG4gPj0gMDsgbi0tKVxyXG4gICAgICAgIGFbdltuXS5ub2RlTmFtZV0gPSBTVkcucmVnZXguaXNOdW1iZXIudGVzdCh2W25dLm5vZGVWYWx1ZSkgPyBwYXJzZUZsb2F0KHZbbl0ubm9kZVZhbHVlKSA6IHZbbl0ubm9kZVZhbHVlXHJcblxyXG4gICAgICByZXR1cm4gYVxyXG5cclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGEgPT0gJ29iamVjdCcpIHtcclxuICAgICAgLy8gYXBwbHkgZXZlcnkgYXR0cmlidXRlIGluZGl2aWR1YWxseSBpZiBhbiBvYmplY3QgaXMgcGFzc2VkXHJcbiAgICAgIGZvciAodiBpbiBhKSB0aGlzLmF0dHIodiwgYVt2XSlcclxuXHJcbiAgICB9IGVsc2UgaWYgKHYgPT09IG51bGwpIHtcclxuICAgICAgICAvLyByZW1vdmUgdmFsdWVcclxuICAgICAgICB0aGlzLm5vZGUucmVtb3ZlQXR0cmlidXRlKGEpXHJcblxyXG4gICAgfSBlbHNlIGlmICh2ID09IG51bGwpIHtcclxuICAgICAgLy8gYWN0IGFzIGEgZ2V0dGVyIGlmIHRoZSBmaXJzdCBhbmQgb25seSBhcmd1bWVudCBpcyBub3QgYW4gb2JqZWN0XHJcbiAgICAgIHYgPSB0aGlzLm5vZGUuZ2V0QXR0cmlidXRlKGEpXHJcbiAgICAgIHJldHVybiB2ID09IG51bGwgP1xyXG4gICAgICAgIFNWRy5kZWZhdWx0cy5hdHRyc1thXSA6XHJcbiAgICAgIFNWRy5yZWdleC5pc051bWJlci50ZXN0KHYpID9cclxuICAgICAgICBwYXJzZUZsb2F0KHYpIDogdlxyXG5cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIEJVRyBGSVg6IHNvbWUgYnJvd3NlcnMgd2lsbCByZW5kZXIgYSBzdHJva2UgaWYgYSBjb2xvciBpcyBnaXZlbiBldmVuIHRob3VnaCBzdHJva2Ugd2lkdGggaXMgMFxyXG4gICAgICBpZiAoYSA9PSAnc3Ryb2tlLXdpZHRoJylcclxuICAgICAgICB0aGlzLmF0dHIoJ3N0cm9rZScsIHBhcnNlRmxvYXQodikgPiAwID8gdGhpcy5fc3Ryb2tlIDogbnVsbClcclxuICAgICAgZWxzZSBpZiAoYSA9PSAnc3Ryb2tlJylcclxuICAgICAgICB0aGlzLl9zdHJva2UgPSB2XHJcblxyXG4gICAgICAvLyBjb252ZXJ0IGltYWdlIGZpbGwgYW5kIHN0cm9rZSB0byBwYXR0ZXJuc1xyXG4gICAgICBpZiAoYSA9PSAnZmlsbCcgfHwgYSA9PSAnc3Ryb2tlJykge1xyXG4gICAgICAgIGlmIChTVkcucmVnZXguaXNJbWFnZS50ZXN0KHYpKVxyXG4gICAgICAgICAgdiA9IHRoaXMuZG9jKCkuZGVmcygpLmltYWdlKHYsIDAsIDApXHJcblxyXG4gICAgICAgIGlmICh2IGluc3RhbmNlb2YgU1ZHLkltYWdlKVxyXG4gICAgICAgICAgdiA9IHRoaXMuZG9jKCkuZGVmcygpLnBhdHRlcm4oMCwgMCwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkKHYpXHJcbiAgICAgICAgICB9KVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBlbnN1cmUgY29ycmVjdCBudW1lcmljIHZhbHVlcyAoYWxzbyBhY2NlcHRzIE5hTiBhbmQgSW5maW5pdHkpXHJcbiAgICAgIGlmICh0eXBlb2YgdiA9PT0gJ251bWJlcicpXHJcbiAgICAgICAgdiA9IG5ldyBTVkcuTnVtYmVyKHYpXHJcblxyXG4gICAgICAvLyBlbnN1cmUgZnVsbCBoZXggY29sb3JcclxuICAgICAgZWxzZSBpZiAoU1ZHLkNvbG9yLmlzQ29sb3IodikpXHJcbiAgICAgICAgdiA9IG5ldyBTVkcuQ29sb3IodilcclxuXHJcbiAgICAgIC8vIHBhcnNlIGFycmF5IHZhbHVlc1xyXG4gICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHYpKVxyXG4gICAgICAgIHYgPSBuZXcgU1ZHLkFycmF5KHYpXHJcblxyXG4gICAgICAvLyBpZiB0aGUgcGFzc2VkIGF0dHJpYnV0ZSBpcyBsZWFkaW5nLi4uXHJcbiAgICAgIGlmIChhID09ICdsZWFkaW5nJykge1xyXG4gICAgICAgIC8vIC4uLiBjYWxsIHRoZSBsZWFkaW5nIG1ldGhvZCBpbnN0ZWFkXHJcbiAgICAgICAgaWYgKHRoaXMubGVhZGluZylcclxuICAgICAgICAgIHRoaXMubGVhZGluZyh2KVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIHNldCBnaXZlbiBhdHRyaWJ1dGUgb24gbm9kZVxyXG4gICAgICAgIHR5cGVvZiBuID09PSAnc3RyaW5nJyA/XHJcbiAgICAgICAgICB0aGlzLm5vZGUuc2V0QXR0cmlidXRlTlMobiwgYSwgdi50b1N0cmluZygpKSA6XHJcbiAgICAgICAgICB0aGlzLm5vZGUuc2V0QXR0cmlidXRlKGEsIHYudG9TdHJpbmcoKSlcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gcmVidWlsZCBpZiByZXF1aXJlZFxyXG4gICAgICBpZiAodGhpcy5yZWJ1aWxkICYmIChhID09ICdmb250LXNpemUnIHx8IGEgPT0gJ3gnKSlcclxuICAgICAgICB0aGlzLnJlYnVpbGQoYSwgdilcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxufSlcblNWRy5leHRlbmQoU1ZHLkVsZW1lbnQsIHtcclxuICAvLyBBZGQgdHJhbnNmb3JtYXRpb25zXHJcbiAgdHJhbnNmb3JtOiBmdW5jdGlvbihvLCByZWxhdGl2ZSkge1xyXG4gICAgLy8gZ2V0IHRhcmdldCBpbiBjYXNlIG9mIHRoZSBmeCBtb2R1bGUsIG90aGVyd2lzZSByZWZlcmVuY2UgdGhpc1xyXG4gICAgdmFyIHRhcmdldCA9IHRoaXNcclxuICAgICAgLCBtYXRyaXhcclxuXHJcbiAgICAvLyBhY3QgYXMgYSBnZXR0ZXJcclxuICAgIGlmICh0eXBlb2YgbyAhPT0gJ29iamVjdCcpIHtcclxuICAgICAgLy8gZ2V0IGN1cnJlbnQgbWF0cml4XHJcbiAgICAgIG1hdHJpeCA9IG5ldyBTVkcuTWF0cml4KHRhcmdldCkuZXh0cmFjdCgpXHJcblxyXG4gICAgICByZXR1cm4gdHlwZW9mIG8gPT09ICdzdHJpbmcnID8gbWF0cml4W29dIDogbWF0cml4XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZ2V0IGN1cnJlbnQgbWF0cml4XHJcbiAgICBtYXRyaXggPSBuZXcgU1ZHLk1hdHJpeCh0YXJnZXQpXHJcblxyXG4gICAgLy8gZW5zdXJlIHJlbGF0aXZlIGZsYWdcclxuICAgIHJlbGF0aXZlID0gISFyZWxhdGl2ZSB8fCAhIW8ucmVsYXRpdmVcclxuXHJcbiAgICAvLyBhY3Qgb24gbWF0cml4XHJcbiAgICBpZiAoby5hICE9IG51bGwpIHtcclxuICAgICAgbWF0cml4ID0gcmVsYXRpdmUgP1xyXG4gICAgICAgIC8vIHJlbGF0aXZlXHJcbiAgICAgICAgbWF0cml4Lm11bHRpcGx5KG5ldyBTVkcuTWF0cml4KG8pKSA6XHJcbiAgICAgICAgLy8gYWJzb2x1dGVcclxuICAgICAgICBuZXcgU1ZHLk1hdHJpeChvKVxyXG5cclxuICAgIC8vIGFjdCBvbiByb3RhdGlvblxyXG4gICAgfSBlbHNlIGlmIChvLnJvdGF0aW9uICE9IG51bGwpIHtcclxuICAgICAgLy8gZW5zdXJlIGNlbnRyZSBwb2ludFxyXG4gICAgICBlbnN1cmVDZW50cmUobywgdGFyZ2V0KVxyXG5cclxuICAgICAgLy8gYXBwbHkgdHJhbnNmb3JtYXRpb25cclxuICAgICAgbWF0cml4ID0gcmVsYXRpdmUgP1xyXG4gICAgICAgIC8vIHJlbGF0aXZlXHJcbiAgICAgICAgbWF0cml4LnJvdGF0ZShvLnJvdGF0aW9uLCBvLmN4LCBvLmN5KSA6XHJcbiAgICAgICAgLy8gYWJzb2x1dGVcclxuICAgICAgICBtYXRyaXgucm90YXRlKG8ucm90YXRpb24gLSBtYXRyaXguZXh0cmFjdCgpLnJvdGF0aW9uLCBvLmN4LCBvLmN5KVxyXG5cclxuICAgIC8vIGFjdCBvbiBzY2FsZVxyXG4gICAgfSBlbHNlIGlmIChvLnNjYWxlICE9IG51bGwgfHwgby5zY2FsZVggIT0gbnVsbCB8fCBvLnNjYWxlWSAhPSBudWxsKSB7XHJcbiAgICAgIC8vIGVuc3VyZSBjZW50cmUgcG9pbnRcclxuICAgICAgZW5zdXJlQ2VudHJlKG8sIHRhcmdldClcclxuXHJcbiAgICAgIC8vIGVuc3VyZSBzY2FsZSB2YWx1ZXMgb24gYm90aCBheGVzXHJcbiAgICAgIG8uc2NhbGVYID0gby5zY2FsZSAhPSBudWxsID8gby5zY2FsZSA6IG8uc2NhbGVYICE9IG51bGwgPyBvLnNjYWxlWCA6IDFcclxuICAgICAgby5zY2FsZVkgPSBvLnNjYWxlICE9IG51bGwgPyBvLnNjYWxlIDogby5zY2FsZVkgIT0gbnVsbCA/IG8uc2NhbGVZIDogMVxyXG5cclxuICAgICAgaWYgKCFyZWxhdGl2ZSkge1xyXG4gICAgICAgIC8vIGFic29sdXRlOyBtdWx0aXBseSBpbnZlcnNlZCB2YWx1ZXNcclxuICAgICAgICB2YXIgZSA9IG1hdHJpeC5leHRyYWN0KClcclxuICAgICAgICBvLnNjYWxlWCA9IG8uc2NhbGVYICogMSAvIGUuc2NhbGVYXHJcbiAgICAgICAgby5zY2FsZVkgPSBvLnNjYWxlWSAqIDEgLyBlLnNjYWxlWVxyXG4gICAgICB9XHJcblxyXG4gICAgICBtYXRyaXggPSBtYXRyaXguc2NhbGUoby5zY2FsZVgsIG8uc2NhbGVZLCBvLmN4LCBvLmN5KVxyXG5cclxuICAgIC8vIGFjdCBvbiBza2V3XHJcbiAgICB9IGVsc2UgaWYgKG8uc2tldyAhPSBudWxsIHx8IG8uc2tld1ggIT0gbnVsbCB8fCBvLnNrZXdZICE9IG51bGwpIHtcclxuICAgICAgLy8gZW5zdXJlIGNlbnRyZSBwb2ludFxyXG4gICAgICBlbnN1cmVDZW50cmUobywgdGFyZ2V0KVxyXG5cclxuICAgICAgLy8gZW5zdXJlIHNrZXcgdmFsdWVzIG9uIGJvdGggYXhlc1xyXG4gICAgICBvLnNrZXdYID0gby5za2V3ICE9IG51bGwgPyBvLnNrZXcgOiBvLnNrZXdYICE9IG51bGwgPyBvLnNrZXdYIDogMFxyXG4gICAgICBvLnNrZXdZID0gby5za2V3ICE9IG51bGwgPyBvLnNrZXcgOiBvLnNrZXdZICE9IG51bGwgPyBvLnNrZXdZIDogMFxyXG5cclxuICAgICAgaWYgKCFyZWxhdGl2ZSkge1xyXG4gICAgICAgIC8vIGFic29sdXRlOyByZXNldCBza2V3IHZhbHVlc1xyXG4gICAgICAgIHZhciBlID0gbWF0cml4LmV4dHJhY3QoKVxyXG4gICAgICAgIG1hdHJpeCA9IG1hdHJpeC5tdWx0aXBseShuZXcgU1ZHLk1hdHJpeCgpLnNrZXcoZS5za2V3WCwgZS5za2V3WSwgby5jeCwgby5jeSkuaW52ZXJzZSgpKVxyXG4gICAgICB9XHJcblxyXG4gICAgICBtYXRyaXggPSBtYXRyaXguc2tldyhvLnNrZXdYLCBvLnNrZXdZLCBvLmN4LCBvLmN5KVxyXG5cclxuICAgIC8vIGFjdCBvbiBmbGlwXHJcbiAgICB9IGVsc2UgaWYgKG8uZmxpcCkge1xyXG4gICAgICBtYXRyaXggPSBtYXRyaXguZmxpcChcclxuICAgICAgICBvLmZsaXBcclxuICAgICAgLCBvLm9mZnNldCA9PSBudWxsID8gdGFyZ2V0LmJib3goKVsnYycgKyBvLmZsaXBdIDogby5vZmZzZXRcclxuICAgICAgKVxyXG5cclxuICAgIC8vIGFjdCBvbiB0cmFuc2xhdGVcclxuICAgIH0gZWxzZSBpZiAoby54ICE9IG51bGwgfHwgby55ICE9IG51bGwpIHtcclxuICAgICAgaWYgKHJlbGF0aXZlKSB7XHJcbiAgICAgICAgLy8gcmVsYXRpdmVcclxuICAgICAgICBtYXRyaXggPSBtYXRyaXgudHJhbnNsYXRlKG8ueCwgby55KVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIGFic29sdXRlXHJcbiAgICAgICAgaWYgKG8ueCAhPSBudWxsKSBtYXRyaXguZSA9IG8ueFxyXG4gICAgICAgIGlmIChvLnkgIT0gbnVsbCkgbWF0cml4LmYgPSBvLnlcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLmF0dHIoJ3RyYW5zZm9ybScsIG1hdHJpeClcclxuICB9XHJcbn0pXHJcblxyXG5TVkcuZXh0ZW5kKFNWRy5GWCwge1xyXG4gIHRyYW5zZm9ybTogZnVuY3Rpb24obywgcmVsYXRpdmUpIHtcclxuICAgIC8vIGdldCB0YXJnZXQgaW4gY2FzZSBvZiB0aGUgZnggbW9kdWxlLCBvdGhlcndpc2UgcmVmZXJlbmNlIHRoaXNcclxuICAgIHZhciB0YXJnZXQgPSB0aGlzLnRhcmdldCgpXHJcbiAgICAgICwgbWF0cml4XHJcblxyXG4gICAgLy8gYWN0IGFzIGEgZ2V0dGVyXHJcbiAgICBpZiAodHlwZW9mIG8gIT09ICdvYmplY3QnKSB7XHJcbiAgICAgIC8vIGdldCBjdXJyZW50IG1hdHJpeFxyXG4gICAgICBtYXRyaXggPSBuZXcgU1ZHLk1hdHJpeCh0YXJnZXQpLmV4dHJhY3QoKVxyXG5cclxuICAgICAgcmV0dXJuIHR5cGVvZiBvID09PSAnc3RyaW5nJyA/IG1hdHJpeFtvXSA6IG1hdHJpeFxyXG4gICAgfVxyXG5cclxuICAgIC8vIGVuc3VyZSByZWxhdGl2ZSBmbGFnXHJcbiAgICByZWxhdGl2ZSA9ICEhcmVsYXRpdmUgfHwgISFvLnJlbGF0aXZlXHJcblxyXG4gICAgLy8gYWN0IG9uIG1hdHJpeFxyXG4gICAgaWYgKG8uYSAhPSBudWxsKSB7XHJcbiAgICAgIG1hdHJpeCA9IG5ldyBTVkcuTWF0cml4KG8pXHJcblxyXG4gICAgLy8gYWN0IG9uIHJvdGF0aW9uXHJcbiAgICB9IGVsc2UgaWYgKG8ucm90YXRpb24gIT0gbnVsbCkge1xyXG4gICAgICAvLyBlbnN1cmUgY2VudHJlIHBvaW50XHJcbiAgICAgIGVuc3VyZUNlbnRyZShvLCB0YXJnZXQpXHJcblxyXG4gICAgICAvLyBhcHBseSB0cmFuc2Zvcm1hdGlvblxyXG4gICAgICBtYXRyaXggPSBuZXcgU1ZHLlJvdGF0ZShvLnJvdGF0aW9uLCBvLmN4LCBvLmN5KVxyXG5cclxuICAgIC8vIGFjdCBvbiBzY2FsZVxyXG4gICAgfSBlbHNlIGlmIChvLnNjYWxlICE9IG51bGwgfHwgby5zY2FsZVggIT0gbnVsbCB8fCBvLnNjYWxlWSAhPSBudWxsKSB7XHJcbiAgICAgIC8vIGVuc3VyZSBjZW50cmUgcG9pbnRcclxuICAgICAgZW5zdXJlQ2VudHJlKG8sIHRhcmdldClcclxuXHJcbiAgICAgIC8vIGVuc3VyZSBzY2FsZSB2YWx1ZXMgb24gYm90aCBheGVzXHJcbiAgICAgIG8uc2NhbGVYID0gby5zY2FsZSAhPSBudWxsID8gby5zY2FsZSA6IG8uc2NhbGVYICE9IG51bGwgPyBvLnNjYWxlWCA6IDFcclxuICAgICAgby5zY2FsZVkgPSBvLnNjYWxlICE9IG51bGwgPyBvLnNjYWxlIDogby5zY2FsZVkgIT0gbnVsbCA/IG8uc2NhbGVZIDogMVxyXG5cclxuICAgICAgbWF0cml4ID0gbmV3IFNWRy5TY2FsZShvLnNjYWxlWCwgby5zY2FsZVksIG8uY3gsIG8uY3kpXHJcblxyXG4gICAgLy8gYWN0IG9uIHNrZXdcclxuICAgIH0gZWxzZSBpZiAoby5za2V3WCAhPSBudWxsIHx8IG8uc2tld1kgIT0gbnVsbCkge1xyXG4gICAgICAvLyBlbnN1cmUgY2VudHJlIHBvaW50XHJcbiAgICAgIGVuc3VyZUNlbnRyZShvLCB0YXJnZXQpXHJcblxyXG4gICAgICAvLyBlbnN1cmUgc2tldyB2YWx1ZXMgb24gYm90aCBheGVzXHJcbiAgICAgIG8uc2tld1ggPSBvLnNrZXdYICE9IG51bGwgPyBvLnNrZXdYIDogMFxyXG4gICAgICBvLnNrZXdZID0gby5za2V3WSAhPSBudWxsID8gby5za2V3WSA6IDBcclxuXHJcbiAgICAgIG1hdHJpeCA9IG5ldyBTVkcuU2tldyhvLnNrZXdYLCBvLnNrZXdZLCBvLmN4LCBvLmN5KVxyXG5cclxuICAgIC8vIGFjdCBvbiBmbGlwXHJcbiAgICB9IGVsc2UgaWYgKG8uZmxpcCkge1xyXG4gICAgICBtYXRyaXggPSBuZXcgU1ZHLk1hdHJpeCgpLmZsaXAoXHJcbiAgICAgICAgby5mbGlwXHJcbiAgICAgICwgby5vZmZzZXQgPT0gbnVsbCA/IHRhcmdldC5iYm94KClbJ2MnICsgby5mbGlwXSA6IG8ub2Zmc2V0XHJcbiAgICAgIClcclxuXHJcbiAgICAvLyBhY3Qgb24gdHJhbnNsYXRlXHJcbiAgICB9IGVsc2UgaWYgKG8ueCAhPSBudWxsIHx8IG8ueSAhPSBudWxsKSB7XHJcbiAgICAgIG1hdHJpeCA9IG5ldyBTVkcuVHJhbnNsYXRlKG8ueCwgby55KVxyXG4gICAgfVxyXG5cclxuICAgIGlmKCFtYXRyaXgpIHJldHVybiB0aGlzXHJcblxyXG4gICAgbWF0cml4LnJlbGF0aXZlID0gcmVsYXRpdmVcclxuXHJcbiAgICB0aGlzLmxhc3QoKS50cmFuc2Zvcm1zLnB1c2gobWF0cml4KVxyXG5cclxuICAgIHJldHVybiB0aGlzLl9jYWxsU3RhcnQoKVxyXG4gIH1cclxufSlcclxuXHJcblNWRy5leHRlbmQoU1ZHLkVsZW1lbnQsIHtcclxuICAvLyBSZXNldCBhbGwgdHJhbnNmb3JtYXRpb25zXHJcbiAgdW50cmFuc2Zvcm06IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuYXR0cigndHJhbnNmb3JtJywgbnVsbClcclxuICB9LFxyXG4gIC8vIG1lcmdlIHRoZSB3aG9sZSB0cmFuc2Zvcm1hdGlvbiBjaGFpbiBpbnRvIG9uZSBtYXRyaXggYW5kIHJldHVybnMgaXRcclxuICBtYXRyaXhpZnk6IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIHZhciBtYXRyaXggPSAodGhpcy5hdHRyKCd0cmFuc2Zvcm0nKSB8fCAnJylcclxuICAgICAgLy8gc3BsaXQgdHJhbnNmb3JtYXRpb25zXHJcbiAgICAgIC5zcGxpdChTVkcucmVnZXgudHJhbnNmb3Jtcykuc2xpY2UoMCwtMSkubWFwKGZ1bmN0aW9uKHN0cil7XHJcbiAgICAgICAgLy8gZ2VuZXJhdGUga2V5ID0+IHZhbHVlIHBhaXJzXHJcbiAgICAgICAgdmFyIGt2ID0gc3RyLnRyaW0oKS5zcGxpdCgnKCcpXHJcbiAgICAgICAgcmV0dXJuIFtrdlswXSwga3ZbMV0uc3BsaXQoU1ZHLnJlZ2V4LmRlbGltaXRlcikubWFwKGZ1bmN0aW9uKHN0cil7IHJldHVybiBwYXJzZUZsb2F0KHN0cikgfSldXHJcbiAgICAgIH0pXHJcbiAgICAgIC8vIG1lcmdlIGV2ZXJ5IHRyYW5zZm9ybWF0aW9uIGludG8gb25lIG1hdHJpeFxyXG4gICAgICAucmVkdWNlKGZ1bmN0aW9uKG1hdHJpeCwgdHJhbnNmb3JtKXtcclxuXHJcbiAgICAgICAgaWYodHJhbnNmb3JtWzBdID09ICdtYXRyaXgnKSByZXR1cm4gbWF0cml4Lm11bHRpcGx5KGFycmF5VG9NYXRyaXgodHJhbnNmb3JtWzFdKSlcclxuICAgICAgICByZXR1cm4gbWF0cml4W3RyYW5zZm9ybVswXV0uYXBwbHkobWF0cml4LCB0cmFuc2Zvcm1bMV0pXHJcblxyXG4gICAgICB9LCBuZXcgU1ZHLk1hdHJpeCgpKVxyXG5cclxuICAgIHJldHVybiBtYXRyaXhcclxuICB9LFxyXG4gIC8vIGFkZCBhbiBlbGVtZW50IHRvIGFub3RoZXIgcGFyZW50IHdpdGhvdXQgY2hhbmdpbmcgdGhlIHZpc3VhbCByZXByZXNlbnRhdGlvbiBvbiB0aGUgc2NyZWVuXHJcbiAgdG9QYXJlbnQ6IGZ1bmN0aW9uKHBhcmVudCkge1xyXG4gICAgaWYodGhpcyA9PSBwYXJlbnQpIHJldHVybiB0aGlzXHJcbiAgICB2YXIgY3RtID0gdGhpcy5zY3JlZW5DVE0oKVxyXG4gICAgdmFyIHBDdG0gPSBwYXJlbnQuc2NyZWVuQ1RNKCkuaW52ZXJzZSgpXHJcblxyXG4gICAgdGhpcy5hZGRUbyhwYXJlbnQpLnVudHJhbnNmb3JtKCkudHJhbnNmb3JtKHBDdG0ubXVsdGlwbHkoY3RtKSlcclxuXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH0sXHJcbiAgLy8gc2FtZSBhcyBhYm92ZSB3aXRoIHBhcmVudCBlcXVhbHMgcm9vdC1zdmdcclxuICB0b0RvYzogZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy50b1BhcmVudCh0aGlzLmRvYygpKVxyXG4gIH1cclxuXHJcbn0pXHJcblxyXG5TVkcuVHJhbnNmb3JtYXRpb24gPSBTVkcuaW52ZW50KHtcclxuXHJcbiAgY3JlYXRlOiBmdW5jdGlvbihzb3VyY2UsIGludmVyc2VkKXtcclxuXHJcbiAgICBpZihhcmd1bWVudHMubGVuZ3RoID4gMSAmJiB0eXBlb2YgaW52ZXJzZWQgIT0gJ2Jvb2xlYW4nKXtcclxuICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpXHJcbiAgICB9XHJcblxyXG4gICAgaWYoQXJyYXkuaXNBcnJheShzb3VyY2UpKXtcclxuICAgICAgZm9yKHZhciBpID0gMCwgbGVuID0gdGhpcy5hcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpe1xyXG4gICAgICAgIHRoaXNbdGhpcy5hcmd1bWVudHNbaV1dID0gc291cmNlW2ldXHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZih0eXBlb2Ygc291cmNlID09ICdvYmplY3QnKXtcclxuICAgICAgZm9yKHZhciBpID0gMCwgbGVuID0gdGhpcy5hcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpe1xyXG4gICAgICAgIHRoaXNbdGhpcy5hcmd1bWVudHNbaV1dID0gc291cmNlW3RoaXMuYXJndW1lbnRzW2ldXVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5pbnZlcnNlZCA9IGZhbHNlXHJcblxyXG4gICAgaWYoaW52ZXJzZWQgPT09IHRydWUpe1xyXG4gICAgICB0aGlzLmludmVyc2VkID0gdHJ1ZVxyXG4gICAgfVxyXG5cclxuICB9XHJcblxyXG4sIGV4dGVuZDoge1xyXG5cclxuICAgIGFyZ3VtZW50czogW11cclxuICAsIG1ldGhvZDogJydcclxuXHJcbiAgLCBhdDogZnVuY3Rpb24ocG9zKXtcclxuXHJcbiAgICAgIHZhciBwYXJhbXMgPSBbXVxyXG5cclxuICAgICAgZm9yKHZhciBpID0gMCwgbGVuID0gdGhpcy5hcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpe1xyXG4gICAgICAgIHBhcmFtcy5wdXNoKHRoaXNbdGhpcy5hcmd1bWVudHNbaV1dKVxyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgbSA9IHRoaXMuX3VuZG8gfHwgbmV3IFNWRy5NYXRyaXgoKVxyXG5cclxuICAgICAgbSA9IG5ldyBTVkcuTWF0cml4KCkubW9ycGgoU1ZHLk1hdHJpeC5wcm90b3R5cGVbdGhpcy5tZXRob2RdLmFwcGx5KG0sIHBhcmFtcykpLmF0KHBvcylcclxuXHJcbiAgICAgIHJldHVybiB0aGlzLmludmVyc2VkID8gbS5pbnZlcnNlKCkgOiBtXHJcblxyXG4gICAgfVxyXG5cclxuICAsIHVuZG86IGZ1bmN0aW9uKG8pe1xyXG4gICAgICBmb3IodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW47ICsraSl7XHJcbiAgICAgICAgb1t0aGlzLmFyZ3VtZW50c1tpXV0gPSB0eXBlb2YgdGhpc1t0aGlzLmFyZ3VtZW50c1tpXV0gPT0gJ3VuZGVmaW5lZCcgPyAwIDogb1t0aGlzLmFyZ3VtZW50c1tpXV1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gVGhlIG1ldGhvZCBTVkcuTWF0cml4LmV4dHJhY3Qgd2hpY2ggd2FzIHVzZWQgYmVmb3JlIGNhbGxpbmcgdGhpc1xyXG4gICAgICAvLyBtZXRob2QgdG8gb2J0YWluIGEgdmFsdWUgZm9yIHRoZSBwYXJhbWV0ZXIgbyBkb2Vzbid0IHJldHVybiBhIGN4IGFuZFxyXG4gICAgICAvLyBhIGN5IHNvIHdlIHVzZSB0aGUgb25lcyB0aGF0IHdlcmUgcHJvdmlkZWQgdG8gdGhpcyBvYmplY3QgYXQgaXRzIGNyZWF0aW9uXHJcbiAgICAgIG8uY3ggPSB0aGlzLmN4XHJcbiAgICAgIG8uY3kgPSB0aGlzLmN5XHJcblxyXG4gICAgICB0aGlzLl91bmRvID0gbmV3IFNWR1tjYXBpdGFsaXplKHRoaXMubWV0aG9kKV0obywgdHJ1ZSkuYXQoMSlcclxuXHJcbiAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcblxyXG4gIH1cclxuXHJcbn0pXHJcblxyXG5TVkcuVHJhbnNsYXRlID0gU1ZHLmludmVudCh7XHJcblxyXG4gIHBhcmVudDogU1ZHLk1hdHJpeFxyXG4sIGluaGVyaXQ6IFNWRy5UcmFuc2Zvcm1hdGlvblxyXG5cclxuLCBjcmVhdGU6IGZ1bmN0aW9uKHNvdXJjZSwgaW52ZXJzZWQpe1xyXG4gICAgdGhpcy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpXHJcbiAgfVxyXG5cclxuLCBleHRlbmQ6IHtcclxuICAgIGFyZ3VtZW50czogWyd0cmFuc2Zvcm1lZFgnLCAndHJhbnNmb3JtZWRZJ11cclxuICAsIG1ldGhvZDogJ3RyYW5zbGF0ZSdcclxuICB9XHJcblxyXG59KVxyXG5cclxuU1ZHLlJvdGF0ZSA9IFNWRy5pbnZlbnQoe1xyXG5cclxuICBwYXJlbnQ6IFNWRy5NYXRyaXhcclxuLCBpbmhlcml0OiBTVkcuVHJhbnNmb3JtYXRpb25cclxuXHJcbiwgY3JlYXRlOiBmdW5jdGlvbihzb3VyY2UsIGludmVyc2VkKXtcclxuICAgIHRoaXMuY29uc3RydWN0b3IuYXBwbHkodGhpcywgW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKVxyXG4gIH1cclxuXHJcbiwgZXh0ZW5kOiB7XHJcbiAgICBhcmd1bWVudHM6IFsncm90YXRpb24nLCAnY3gnLCAnY3knXVxyXG4gICwgbWV0aG9kOiAncm90YXRlJ1xyXG4gICwgYXQ6IGZ1bmN0aW9uKHBvcyl7XHJcbiAgICAgIHZhciBtID0gbmV3IFNWRy5NYXRyaXgoKS5yb3RhdGUobmV3IFNWRy5OdW1iZXIoKS5tb3JwaCh0aGlzLnJvdGF0aW9uIC0gKHRoaXMuX3VuZG8gPyB0aGlzLl91bmRvLnJvdGF0aW9uIDogMCkpLmF0KHBvcyksIHRoaXMuY3gsIHRoaXMuY3kpXHJcbiAgICAgIHJldHVybiB0aGlzLmludmVyc2VkID8gbS5pbnZlcnNlKCkgOiBtXHJcbiAgICB9XHJcbiAgLCB1bmRvOiBmdW5jdGlvbihvKXtcclxuICAgICAgdGhpcy5fdW5kbyA9IG9cclxuICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuICB9XHJcblxyXG59KVxyXG5cclxuU1ZHLlNjYWxlID0gU1ZHLmludmVudCh7XHJcblxyXG4gIHBhcmVudDogU1ZHLk1hdHJpeFxyXG4sIGluaGVyaXQ6IFNWRy5UcmFuc2Zvcm1hdGlvblxyXG5cclxuLCBjcmVhdGU6IGZ1bmN0aW9uKHNvdXJjZSwgaW52ZXJzZWQpe1xyXG4gICAgdGhpcy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpXHJcbiAgfVxyXG5cclxuLCBleHRlbmQ6IHtcclxuICAgIGFyZ3VtZW50czogWydzY2FsZVgnLCAnc2NhbGVZJywgJ2N4JywgJ2N5J11cclxuICAsIG1ldGhvZDogJ3NjYWxlJ1xyXG4gIH1cclxuXHJcbn0pXHJcblxyXG5TVkcuU2tldyA9IFNWRy5pbnZlbnQoe1xyXG5cclxuICBwYXJlbnQ6IFNWRy5NYXRyaXhcclxuLCBpbmhlcml0OiBTVkcuVHJhbnNmb3JtYXRpb25cclxuXHJcbiwgY3JlYXRlOiBmdW5jdGlvbihzb3VyY2UsIGludmVyc2VkKXtcclxuICAgIHRoaXMuY29uc3RydWN0b3IuYXBwbHkodGhpcywgW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKVxyXG4gIH1cclxuXHJcbiwgZXh0ZW5kOiB7XHJcbiAgICBhcmd1bWVudHM6IFsnc2tld1gnLCAnc2tld1knLCAnY3gnLCAnY3knXVxyXG4gICwgbWV0aG9kOiAnc2tldydcclxuICB9XHJcblxyXG59KVxyXG5cblNWRy5leHRlbmQoU1ZHLkVsZW1lbnQsIHtcclxuICAvLyBEeW5hbWljIHN0eWxlIGdlbmVyYXRvclxyXG4gIHN0eWxlOiBmdW5jdGlvbihzLCB2KSB7XHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgIC8vIGdldCBmdWxsIHN0eWxlXHJcbiAgICAgIHJldHVybiB0aGlzLm5vZGUuc3R5bGUuY3NzVGV4dCB8fCAnJ1xyXG5cclxuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcclxuICAgICAgLy8gYXBwbHkgZXZlcnkgc3R5bGUgaW5kaXZpZHVhbGx5IGlmIGFuIG9iamVjdCBpcyBwYXNzZWRcclxuICAgICAgaWYgKHR5cGVvZiBzID09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgZm9yICh2IGluIHMpIHRoaXMuc3R5bGUodiwgc1t2XSlcclxuXHJcbiAgICAgIH0gZWxzZSBpZiAoU1ZHLnJlZ2V4LmlzQ3NzLnRlc3QocykpIHtcclxuICAgICAgICAvLyBwYXJzZSBjc3Mgc3RyaW5nXHJcbiAgICAgICAgcyA9IHMuc3BsaXQoL1xccyo7XFxzKi8pXHJcbiAgICAgICAgICAvLyBmaWx0ZXIgb3V0IHN1ZmZpeCA7IGFuZCBzdHVmZiBsaWtlIDs7XHJcbiAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGUpIHsgcmV0dXJuICEhZSB9KVxyXG4gICAgICAgICAgLm1hcChmdW5jdGlvbihlKXsgcmV0dXJuIGUuc3BsaXQoL1xccyo6XFxzKi8pIH0pXHJcblxyXG4gICAgICAgIC8vIGFwcGx5IGV2ZXJ5IGRlZmluaXRpb24gaW5kaXZpZHVhbGx5XHJcbiAgICAgICAgd2hpbGUgKHYgPSBzLnBvcCgpKSB7XHJcbiAgICAgICAgICB0aGlzLnN0eWxlKHZbMF0sIHZbMV0pXHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIGFjdCBhcyBhIGdldHRlciBpZiB0aGUgZmlyc3QgYW5kIG9ubHkgYXJndW1lbnQgaXMgbm90IGFuIG9iamVjdFxyXG4gICAgICAgIHJldHVybiB0aGlzLm5vZGUuc3R5bGVbY2FtZWxDYXNlKHMpXVxyXG4gICAgICB9XHJcblxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5ub2RlLnN0eWxlW2NhbWVsQ2FzZShzKV0gPSB2ID09PSBudWxsIHx8IFNWRy5yZWdleC5pc0JsYW5rLnRlc3QodikgPyAnJyA6IHZcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxufSlcblNWRy5QYXJlbnQgPSBTVkcuaW52ZW50KHtcclxuICAvLyBJbml0aWFsaXplIG5vZGVcclxuICBjcmVhdGU6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuICAgIHRoaXMuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBlbGVtZW50KVxyXG4gIH1cclxuXHJcbiAgLy8gSW5oZXJpdCBmcm9tXHJcbiwgaW5oZXJpdDogU1ZHLkVsZW1lbnRcclxuXHJcbiAgLy8gQWRkIGNsYXNzIG1ldGhvZHNcclxuLCBleHRlbmQ6IHtcclxuICAgIC8vIFJldHVybnMgYWxsIGNoaWxkIGVsZW1lbnRzXHJcbiAgICBjaGlsZHJlbjogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiBTVkcudXRpbHMubWFwKFNWRy51dGlscy5maWx0ZXJTVkdFbGVtZW50cyh0aGlzLm5vZGUuY2hpbGROb2RlcyksIGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgICByZXR1cm4gU1ZHLmFkb3B0KG5vZGUpXHJcbiAgICAgIH0pXHJcbiAgICB9XHJcbiAgICAvLyBBZGQgZ2l2ZW4gZWxlbWVudCBhdCBhIHBvc2l0aW9uXHJcbiAgLCBhZGQ6IGZ1bmN0aW9uKGVsZW1lbnQsIGkpIHtcclxuICAgICAgaWYgKGkgPT0gbnVsbClcclxuICAgICAgICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQoZWxlbWVudC5ub2RlKVxyXG4gICAgICBlbHNlIGlmIChlbGVtZW50Lm5vZGUgIT0gdGhpcy5ub2RlLmNoaWxkTm9kZXNbaV0pXHJcbiAgICAgICAgdGhpcy5ub2RlLmluc2VydEJlZm9yZShlbGVtZW50Lm5vZGUsIHRoaXMubm9kZS5jaGlsZE5vZGVzW2ldKVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuICAgIC8vIEJhc2ljYWxseSBkb2VzIHRoZSBzYW1lIGFzIGBhZGQoKWAgYnV0IHJldHVybnMgdGhlIGFkZGVkIGVsZW1lbnQgaW5zdGVhZFxyXG4gICwgcHV0OiBmdW5jdGlvbihlbGVtZW50LCBpKSB7XHJcbiAgICAgIHRoaXMuYWRkKGVsZW1lbnQsIGkpXHJcbiAgICAgIHJldHVybiBlbGVtZW50XHJcbiAgICB9XHJcbiAgICAvLyBDaGVja3MgaWYgdGhlIGdpdmVuIGVsZW1lbnQgaXMgYSBjaGlsZFxyXG4gICwgaGFzOiBmdW5jdGlvbihlbGVtZW50KSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmluZGV4KGVsZW1lbnQpID49IDBcclxuICAgIH1cclxuICAgIC8vIEdldHMgaW5kZXggb2YgZ2l2ZW4gZWxlbWVudFxyXG4gICwgaW5kZXg6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuICAgICAgcmV0dXJuIFtdLnNsaWNlLmNhbGwodGhpcy5ub2RlLmNoaWxkTm9kZXMpLmluZGV4T2YoZWxlbWVudC5ub2RlKVxyXG4gICAgfVxyXG4gICAgLy8gR2V0IGEgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXhcclxuICAsIGdldDogZnVuY3Rpb24oaSkge1xyXG4gICAgICByZXR1cm4gU1ZHLmFkb3B0KHRoaXMubm9kZS5jaGlsZE5vZGVzW2ldKVxyXG4gICAgfVxyXG4gICAgLy8gR2V0IGZpcnN0IGNoaWxkXHJcbiAgLCBmaXJzdDogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmdldCgwKVxyXG4gICAgfVxyXG4gICAgLy8gR2V0IHRoZSBsYXN0IGNoaWxkXHJcbiAgLCBsYXN0OiBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZ2V0KHRoaXMubm9kZS5jaGlsZE5vZGVzLmxlbmd0aCAtIDEpXHJcbiAgICB9XHJcbiAgICAvLyBJdGVyYXRlcyBvdmVyIGFsbCBjaGlsZHJlbiBhbmQgaW52b2tlcyBhIGdpdmVuIGJsb2NrXHJcbiAgLCBlYWNoOiBmdW5jdGlvbihibG9jaywgZGVlcCkge1xyXG4gICAgICB2YXIgaSwgaWxcclxuICAgICAgICAsIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbigpXHJcblxyXG4gICAgICBmb3IgKGkgPSAwLCBpbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcclxuICAgICAgICBpZiAoY2hpbGRyZW5baV0gaW5zdGFuY2VvZiBTVkcuRWxlbWVudClcclxuICAgICAgICAgIGJsb2NrLmFwcGx5KGNoaWxkcmVuW2ldLCBbaSwgY2hpbGRyZW5dKVxyXG5cclxuICAgICAgICBpZiAoZGVlcCAmJiAoY2hpbGRyZW5baV0gaW5zdGFuY2VvZiBTVkcuQ29udGFpbmVyKSlcclxuICAgICAgICAgIGNoaWxkcmVuW2ldLmVhY2goYmxvY2ssIGRlZXApXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcbiAgICAvLyBSZW1vdmUgYSBnaXZlbiBjaGlsZFxyXG4gICwgcmVtb3ZlRWxlbWVudDogZnVuY3Rpb24oZWxlbWVudCkge1xyXG4gICAgICB0aGlzLm5vZGUucmVtb3ZlQ2hpbGQoZWxlbWVudC5ub2RlKVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuICAgIC8vIFJlbW92ZSBhbGwgZWxlbWVudHMgaW4gdGhpcyBjb250YWluZXJcclxuICAsIGNsZWFyOiBmdW5jdGlvbigpIHtcclxuICAgICAgLy8gcmVtb3ZlIGNoaWxkcmVuXHJcbiAgICAgIHdoaWxlKHRoaXMubm9kZS5oYXNDaGlsZE5vZGVzKCkpXHJcbiAgICAgICAgdGhpcy5ub2RlLnJlbW92ZUNoaWxkKHRoaXMubm9kZS5sYXN0Q2hpbGQpXHJcblxyXG4gICAgICAvLyByZW1vdmUgZGVmcyByZWZlcmVuY2VcclxuICAgICAgZGVsZXRlIHRoaXMuX2RlZnNcclxuXHJcbiAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcbiAgLCAvLyBHZXQgZGVmc1xyXG4gICAgZGVmczogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmRvYygpLmRlZnMoKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbn0pXHJcblxuU1ZHLmV4dGVuZChTVkcuUGFyZW50LCB7XHJcblxyXG4gIHVuZ3JvdXA6IGZ1bmN0aW9uKHBhcmVudCwgZGVwdGgpIHtcclxuICAgIGlmKGRlcHRoID09PSAwIHx8IHRoaXMgaW5zdGFuY2VvZiBTVkcuRGVmcykgcmV0dXJuIHRoaXNcclxuXHJcbiAgICBwYXJlbnQgPSBwYXJlbnQgfHwgKHRoaXMgaW5zdGFuY2VvZiBTVkcuRG9jID8gdGhpcyA6IHRoaXMucGFyZW50KFNWRy5QYXJlbnQpKVxyXG4gICAgZGVwdGggPSBkZXB0aCB8fCBJbmZpbml0eVxyXG5cclxuICAgIHRoaXMuZWFjaChmdW5jdGlvbigpe1xyXG4gICAgICBpZih0aGlzIGluc3RhbmNlb2YgU1ZHLkRlZnMpIHJldHVybiB0aGlzXHJcbiAgICAgIGlmKHRoaXMgaW5zdGFuY2VvZiBTVkcuUGFyZW50KSByZXR1cm4gdGhpcy51bmdyb3VwKHBhcmVudCwgZGVwdGgtMSlcclxuICAgICAgcmV0dXJuIHRoaXMudG9QYXJlbnQocGFyZW50KVxyXG4gICAgfSlcclxuXHJcbiAgICB0aGlzLm5vZGUuZmlyc3RDaGlsZCB8fCB0aGlzLnJlbW92ZSgpXHJcblxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9LFxyXG5cclxuICBmbGF0dGVuOiBmdW5jdGlvbihwYXJlbnQsIGRlcHRoKSB7XHJcbiAgICByZXR1cm4gdGhpcy51bmdyb3VwKHBhcmVudCwgZGVwdGgpXHJcbiAgfVxyXG5cclxufSlcblNWRy5Db250YWluZXIgPSBTVkcuaW52ZW50KHtcclxuICAvLyBJbml0aWFsaXplIG5vZGVcclxuICBjcmVhdGU6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuICAgIHRoaXMuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBlbGVtZW50KVxyXG4gIH1cclxuXHJcbiAgLy8gSW5oZXJpdCBmcm9tXHJcbiwgaW5oZXJpdDogU1ZHLlBhcmVudFxyXG5cclxufSlcblxyXG5TVkcuVmlld0JveCA9IFNWRy5pbnZlbnQoe1xyXG5cclxuICBjcmVhdGU6IGZ1bmN0aW9uKHNvdXJjZSkge1xyXG4gICAgdmFyIGksIGJhc2UgPSBbMCwgMCwgMCwgMF1cclxuXHJcbiAgICB2YXIgeCwgeSwgd2lkdGgsIGhlaWdodCwgYm94LCB2aWV3LCB3ZSwgaGVcclxuICAgICAgLCB3bSAgID0gMSAvLyB3aWR0aCBtdWx0aXBsaWVyXHJcbiAgICAgICwgaG0gICA9IDEgLy8gaGVpZ2h0IG11bHRpcGxpZXJcclxuICAgICAgLCByZWcgID0gL1srLV0/KD86XFxkKyg/OlxcLlxcZCopP3xcXC5cXGQrKSg/OmVbKy1dP1xcZCspPy9naVxyXG5cclxuICAgIGlmKHNvdXJjZSBpbnN0YW5jZW9mIFNWRy5FbGVtZW50KXtcclxuXHJcbiAgICAgIHdlID0gc291cmNlXHJcbiAgICAgIGhlID0gc291cmNlXHJcbiAgICAgIHZpZXcgPSAoc291cmNlLmF0dHIoJ3ZpZXdCb3gnKSB8fCAnJykubWF0Y2gocmVnKVxyXG4gICAgICBib3ggPSBzb3VyY2UuYmJveFxyXG5cclxuICAgICAgLy8gZ2V0IGRpbWVuc2lvbnMgb2YgY3VycmVudCBub2RlXHJcbiAgICAgIHdpZHRoICA9IG5ldyBTVkcuTnVtYmVyKHNvdXJjZS53aWR0aCgpKVxyXG4gICAgICBoZWlnaHQgPSBuZXcgU1ZHLk51bWJlcihzb3VyY2UuaGVpZ2h0KCkpXHJcblxyXG4gICAgICAvLyBmaW5kIG5lYXJlc3Qgbm9uLXBlcmNlbnR1YWwgZGltZW5zaW9uc1xyXG4gICAgICB3aGlsZSAod2lkdGgudW5pdCA9PSAnJScpIHtcclxuICAgICAgICB3bSAqPSB3aWR0aC52YWx1ZVxyXG4gICAgICAgIHdpZHRoID0gbmV3IFNWRy5OdW1iZXIod2UgaW5zdGFuY2VvZiBTVkcuRG9jID8gd2UucGFyZW50KCkub2Zmc2V0V2lkdGggOiB3ZS5wYXJlbnQoKS53aWR0aCgpKVxyXG4gICAgICAgIHdlID0gd2UucGFyZW50KClcclxuICAgICAgfVxyXG4gICAgICB3aGlsZSAoaGVpZ2h0LnVuaXQgPT0gJyUnKSB7XHJcbiAgICAgICAgaG0gKj0gaGVpZ2h0LnZhbHVlXHJcbiAgICAgICAgaGVpZ2h0ID0gbmV3IFNWRy5OdW1iZXIoaGUgaW5zdGFuY2VvZiBTVkcuRG9jID8gaGUucGFyZW50KCkub2Zmc2V0SGVpZ2h0IDogaGUucGFyZW50KCkuaGVpZ2h0KCkpXHJcbiAgICAgICAgaGUgPSBoZS5wYXJlbnQoKVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBlbnN1cmUgZGVmYXVsdHNcclxuICAgICAgdGhpcy54ICAgICAgPSAwXHJcbiAgICAgIHRoaXMueSAgICAgID0gMFxyXG4gICAgICB0aGlzLndpZHRoICA9IHdpZHRoICAqIHdtXHJcbiAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0ICogaG1cclxuICAgICAgdGhpcy56b29tICAgPSAxXHJcblxyXG4gICAgICBpZiAodmlldykge1xyXG4gICAgICAgIC8vIGdldCB3aWR0aCBhbmQgaGVpZ2h0IGZyb20gdmlld2JveFxyXG4gICAgICAgIHggICAgICA9IHBhcnNlRmxvYXQodmlld1swXSlcclxuICAgICAgICB5ICAgICAgPSBwYXJzZUZsb2F0KHZpZXdbMV0pXHJcbiAgICAgICAgd2lkdGggID0gcGFyc2VGbG9hdCh2aWV3WzJdKVxyXG4gICAgICAgIGhlaWdodCA9IHBhcnNlRmxvYXQodmlld1szXSlcclxuXHJcbiAgICAgICAgLy8gY2FsY3VsYXRlIHpvb20gYWNjb3JpbmcgdG8gdmlld2JveFxyXG4gICAgICAgIHRoaXMuem9vbSA9ICgodGhpcy53aWR0aCAvIHRoaXMuaGVpZ2h0KSA+ICh3aWR0aCAvIGhlaWdodCkpID9cclxuICAgICAgICAgIHRoaXMuaGVpZ2h0IC8gaGVpZ2h0IDpcclxuICAgICAgICAgIHRoaXMud2lkdGggIC8gd2lkdGhcclxuXHJcbiAgICAgICAgLy8gY2FsY3VsYXRlIHJlYWwgcGl4ZWwgZGltZW5zaW9ucyBvbiBwYXJlbnQgU1ZHLkRvYyBlbGVtZW50XHJcbiAgICAgICAgdGhpcy54ICAgICAgPSB4XHJcbiAgICAgICAgdGhpcy55ICAgICAgPSB5XHJcbiAgICAgICAgdGhpcy53aWR0aCAgPSB3aWR0aFxyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0XHJcblxyXG4gICAgICB9XHJcblxyXG4gICAgfWVsc2V7XHJcblxyXG4gICAgICAvLyBlbnN1cmUgc291cmNlIGFzIG9iamVjdFxyXG4gICAgICBzb3VyY2UgPSB0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJyA/XHJcbiAgICAgICAgc291cmNlLm1hdGNoKHJlZykubWFwKGZ1bmN0aW9uKGVsKXsgcmV0dXJuIHBhcnNlRmxvYXQoZWwpIH0pIDpcclxuICAgICAgQXJyYXkuaXNBcnJheShzb3VyY2UpID9cclxuICAgICAgICBzb3VyY2UgOlxyXG4gICAgICB0eXBlb2Ygc291cmNlID09ICdvYmplY3QnID9cclxuICAgICAgICBbc291cmNlLngsIHNvdXJjZS55LCBzb3VyY2Uud2lkdGgsIHNvdXJjZS5oZWlnaHRdIDpcclxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA9PSA0ID9cclxuICAgICAgICBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykgOlxyXG4gICAgICAgIGJhc2VcclxuXHJcbiAgICAgIHRoaXMueCA9IHNvdXJjZVswXVxyXG4gICAgICB0aGlzLnkgPSBzb3VyY2VbMV1cclxuICAgICAgdGhpcy53aWR0aCA9IHNvdXJjZVsyXVxyXG4gICAgICB0aGlzLmhlaWdodCA9IHNvdXJjZVszXVxyXG4gICAgfVxyXG5cclxuXHJcbiAgfVxyXG5cclxuLCBleHRlbmQ6IHtcclxuXHJcbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnggKyAnICcgKyB0aGlzLnkgKyAnICcgKyB0aGlzLndpZHRoICsgJyAnICsgdGhpcy5oZWlnaHRcclxuICAgIH1cclxuICAsIG1vcnBoOiBmdW5jdGlvbih4LCB5LCB3aWR0aCwgaGVpZ2h0KXtcclxuICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IG5ldyBTVkcuVmlld0JveCh4LCB5LCB3aWR0aCwgaGVpZ2h0KVxyXG4gICAgICByZXR1cm4gdGhpc1xyXG4gICAgfVxyXG5cclxuICAsIGF0OiBmdW5jdGlvbihwb3MpIHtcclxuXHJcbiAgICAgIGlmKCF0aGlzLmRlc3RpbmF0aW9uKSByZXR1cm4gdGhpc1xyXG5cclxuICAgICAgcmV0dXJuIG5ldyBTVkcuVmlld0JveChbXHJcbiAgICAgICAgICB0aGlzLnggKyAodGhpcy5kZXN0aW5hdGlvbi54IC0gdGhpcy54KSAqIHBvc1xyXG4gICAgICAgICwgdGhpcy55ICsgKHRoaXMuZGVzdGluYXRpb24ueSAtIHRoaXMueSkgKiBwb3NcclxuICAgICAgICAsIHRoaXMud2lkdGggKyAodGhpcy5kZXN0aW5hdGlvbi53aWR0aCAtIHRoaXMud2lkdGgpICogcG9zXHJcbiAgICAgICAgLCB0aGlzLmhlaWdodCArICh0aGlzLmRlc3RpbmF0aW9uLmhlaWdodCAtIHRoaXMuaGVpZ2h0KSAqIHBvc1xyXG4gICAgICBdKVxyXG5cclxuICAgIH1cclxuXHJcbiAgfVxyXG5cclxuICAvLyBEZWZpbmUgcGFyZW50XHJcbiwgcGFyZW50OiBTVkcuQ29udGFpbmVyXHJcblxyXG4gIC8vIEFkZCBwYXJlbnQgbWV0aG9kXHJcbiwgY29uc3RydWN0OiB7XHJcblxyXG4gICAgLy8gZ2V0L3NldCB2aWV3Ym94XHJcbiAgICB2aWV3Ym94OiBmdW5jdGlvbih4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDApXHJcbiAgICAgICAgLy8gYWN0IGFzIGEgZ2V0dGVyIGlmIHRoZXJlIGFyZSBubyBhcmd1bWVudHNcclxuICAgICAgICByZXR1cm4gbmV3IFNWRy5WaWV3Qm94KHRoaXMpXHJcblxyXG4gICAgICAvLyBvdGhlcndpc2UgYWN0IGFzIGEgc2V0dGVyXHJcbiAgICAgIHJldHVybiB0aGlzLmF0dHIoJ3ZpZXdCb3gnLCBuZXcgU1ZHLlZpZXdCb3goeCwgeSwgd2lkdGgsIGhlaWdodCkpXHJcbiAgICB9XHJcblxyXG4gIH1cclxuXHJcbn0pXG4vLyBBZGQgZXZlbnRzIHRvIGVsZW1lbnRzXHJcbjtbICAnY2xpY2snXHJcbiAgLCAnZGJsY2xpY2snXHJcbiAgLCAnbW91c2Vkb3duJ1xyXG4gICwgJ21vdXNldXAnXHJcbiAgLCAnbW91c2VvdmVyJ1xyXG4gICwgJ21vdXNlb3V0J1xyXG4gICwgJ21vdXNlbW92ZSdcclxuICAvLyAsICdtb3VzZWVudGVyJyAtPiBub3Qgc3VwcG9ydGVkIGJ5IElFXHJcbiAgLy8gLCAnbW91c2VsZWF2ZScgLT4gbm90IHN1cHBvcnRlZCBieSBJRVxyXG4gICwgJ3RvdWNoc3RhcnQnXHJcbiAgLCAndG91Y2htb3ZlJ1xyXG4gICwgJ3RvdWNobGVhdmUnXHJcbiAgLCAndG91Y2hlbmQnXHJcbiAgLCAndG91Y2hjYW5jZWwnIF0uZm9yRWFjaChmdW5jdGlvbihldmVudCkge1xyXG5cclxuICAvLyBhZGQgZXZlbnQgdG8gU1ZHLkVsZW1lbnRcclxuICBTVkcuRWxlbWVudC5wcm90b3R5cGVbZXZlbnRdID0gZnVuY3Rpb24oZikge1xyXG4gICAgLy8gYmluZCBldmVudCB0byBlbGVtZW50IHJhdGhlciB0aGFuIGVsZW1lbnQgbm9kZVxyXG4gICAgU1ZHLm9uKHRoaXMubm9kZSwgZXZlbnQsIGYpXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxufSlcclxuXHJcbi8vIEluaXRpYWxpemUgbGlzdGVuZXJzIHN0YWNrXHJcblNWRy5saXN0ZW5lcnMgPSBbXVxyXG5TVkcuaGFuZGxlck1hcCA9IFtdXHJcblNWRy5saXN0ZW5lcklkID0gMFxyXG5cclxuLy8gQWRkIGV2ZW50IGJpbmRlciBpbiB0aGUgU1ZHIG5hbWVzcGFjZVxyXG5TVkcub24gPSBmdW5jdGlvbihub2RlLCBldmVudCwgbGlzdGVuZXIsIGJpbmRpbmcpIHtcclxuICAvLyBjcmVhdGUgbGlzdGVuZXIsIGdldCBvYmplY3QtaW5kZXhcclxuICB2YXIgbCAgICAgPSBsaXN0ZW5lci5iaW5kKGJpbmRpbmcgfHwgbm9kZS5pbnN0YW5jZSB8fCBub2RlKVxyXG4gICAgLCBpbmRleCA9IChTVkcuaGFuZGxlck1hcC5pbmRleE9mKG5vZGUpICsgMSB8fCBTVkcuaGFuZGxlck1hcC5wdXNoKG5vZGUpKSAtIDFcclxuICAgICwgZXYgICAgPSBldmVudC5zcGxpdCgnLicpWzBdXHJcbiAgICAsIG5zICAgID0gZXZlbnQuc3BsaXQoJy4nKVsxXSB8fCAnKidcclxuXHJcblxyXG4gIC8vIGVuc3VyZSB2YWxpZCBvYmplY3RcclxuICBTVkcubGlzdGVuZXJzW2luZGV4XSAgICAgICAgID0gU1ZHLmxpc3RlbmVyc1tpbmRleF0gICAgICAgICB8fCB7fVxyXG4gIFNWRy5saXN0ZW5lcnNbaW5kZXhdW2V2XSAgICAgPSBTVkcubGlzdGVuZXJzW2luZGV4XVtldl0gICAgIHx8IHt9XHJcbiAgU1ZHLmxpc3RlbmVyc1tpbmRleF1bZXZdW25zXSA9IFNWRy5saXN0ZW5lcnNbaW5kZXhdW2V2XVtuc10gfHwge31cclxuXHJcbiAgaWYoIWxpc3RlbmVyLl9zdmdqc0xpc3RlbmVySWQpXHJcbiAgICBsaXN0ZW5lci5fc3ZnanNMaXN0ZW5lcklkID0gKytTVkcubGlzdGVuZXJJZFxyXG5cclxuICAvLyByZWZlcmVuY2UgbGlzdGVuZXJcclxuICBTVkcubGlzdGVuZXJzW2luZGV4XVtldl1bbnNdW2xpc3RlbmVyLl9zdmdqc0xpc3RlbmVySWRdID0gbFxyXG5cclxuICAvLyBhZGQgbGlzdGVuZXJcclxuICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXYsIGwsIGZhbHNlKVxyXG59XHJcblxyXG4vLyBBZGQgZXZlbnQgdW5iaW5kZXIgaW4gdGhlIFNWRyBuYW1lc3BhY2VcclxuU1ZHLm9mZiA9IGZ1bmN0aW9uKG5vZGUsIGV2ZW50LCBsaXN0ZW5lcikge1xyXG4gIHZhciBpbmRleCA9IFNWRy5oYW5kbGVyTWFwLmluZGV4T2Yobm9kZSlcclxuICAgICwgZXYgICAgPSBldmVudCAmJiBldmVudC5zcGxpdCgnLicpWzBdXHJcbiAgICAsIG5zICAgID0gZXZlbnQgJiYgZXZlbnQuc3BsaXQoJy4nKVsxXVxyXG5cclxuICBpZihpbmRleCA9PSAtMSkgcmV0dXJuXHJcblxyXG4gIGlmIChsaXN0ZW5lcikge1xyXG4gICAgaWYodHlwZW9mIGxpc3RlbmVyID09ICdmdW5jdGlvbicpIGxpc3RlbmVyID0gbGlzdGVuZXIuX3N2Z2pzTGlzdGVuZXJJZFxyXG4gICAgaWYoIWxpc3RlbmVyKSByZXR1cm5cclxuXHJcbiAgICAvLyByZW1vdmUgbGlzdGVuZXIgcmVmZXJlbmNlXHJcbiAgICBpZiAoU1ZHLmxpc3RlbmVyc1tpbmRleF1bZXZdICYmIFNWRy5saXN0ZW5lcnNbaW5kZXhdW2V2XVtucyB8fCAnKiddKSB7XHJcbiAgICAgIC8vIHJlbW92ZSBsaXN0ZW5lclxyXG4gICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXYsIFNWRy5saXN0ZW5lcnNbaW5kZXhdW2V2XVtucyB8fCAnKiddW2xpc3RlbmVyXSwgZmFsc2UpXHJcblxyXG4gICAgICBkZWxldGUgU1ZHLmxpc3RlbmVyc1tpbmRleF1bZXZdW25zIHx8ICcqJ11bbGlzdGVuZXJdXHJcbiAgICB9XHJcblxyXG4gIH0gZWxzZSBpZiAobnMgJiYgZXYpIHtcclxuICAgIC8vIHJlbW92ZSBhbGwgbGlzdGVuZXJzIGZvciBhIG5hbWVzcGFjZWQgZXZlbnRcclxuICAgIGlmIChTVkcubGlzdGVuZXJzW2luZGV4XVtldl0gJiYgU1ZHLmxpc3RlbmVyc1tpbmRleF1bZXZdW25zXSkge1xyXG4gICAgICBmb3IgKGxpc3RlbmVyIGluIFNWRy5saXN0ZW5lcnNbaW5kZXhdW2V2XVtuc10pXHJcbiAgICAgICAgU1ZHLm9mZihub2RlLCBbZXYsIG5zXS5qb2luKCcuJyksIGxpc3RlbmVyKVxyXG5cclxuICAgICAgZGVsZXRlIFNWRy5saXN0ZW5lcnNbaW5kZXhdW2V2XVtuc11cclxuICAgIH1cclxuXHJcbiAgfSBlbHNlIGlmIChucyl7XHJcbiAgICAvLyByZW1vdmUgYWxsIGxpc3RlbmVycyBmb3IgYSBzcGVjaWZpYyBuYW1lc3BhY2VcclxuICAgIGZvcihldmVudCBpbiBTVkcubGlzdGVuZXJzW2luZGV4XSl7XHJcbiAgICAgICAgZm9yKG5hbWVzcGFjZSBpbiBTVkcubGlzdGVuZXJzW2luZGV4XVtldmVudF0pe1xyXG4gICAgICAgICAgICBpZihucyA9PT0gbmFtZXNwYWNlKXtcclxuICAgICAgICAgICAgICAgIFNWRy5vZmYobm9kZSwgW2V2ZW50LCBuc10uam9pbignLicpKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICB9IGVsc2UgaWYgKGV2KSB7XHJcbiAgICAvLyByZW1vdmUgYWxsIGxpc3RlbmVycyBmb3IgdGhlIGV2ZW50XHJcbiAgICBpZiAoU1ZHLmxpc3RlbmVyc1tpbmRleF1bZXZdKSB7XHJcbiAgICAgIGZvciAobmFtZXNwYWNlIGluIFNWRy5saXN0ZW5lcnNbaW5kZXhdW2V2XSlcclxuICAgICAgICBTVkcub2ZmKG5vZGUsIFtldiwgbmFtZXNwYWNlXS5qb2luKCcuJykpXHJcblxyXG4gICAgICBkZWxldGUgU1ZHLmxpc3RlbmVyc1tpbmRleF1bZXZdXHJcbiAgICB9XHJcblxyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyByZW1vdmUgYWxsIGxpc3RlbmVycyBvbiBhIGdpdmVuIG5vZGVcclxuICAgIGZvciAoZXZlbnQgaW4gU1ZHLmxpc3RlbmVyc1tpbmRleF0pXHJcbiAgICAgIFNWRy5vZmYobm9kZSwgZXZlbnQpXHJcblxyXG4gICAgZGVsZXRlIFNWRy5saXN0ZW5lcnNbaW5kZXhdXHJcbiAgICBkZWxldGUgU1ZHLmhhbmRsZXJNYXBbaW5kZXhdXHJcblxyXG4gIH1cclxufVxyXG5cclxuLy9cclxuU1ZHLmV4dGVuZChTVkcuRWxlbWVudCwge1xyXG4gIC8vIEJpbmQgZ2l2ZW4gZXZlbnQgdG8gbGlzdGVuZXJcclxuICBvbjogZnVuY3Rpb24oZXZlbnQsIGxpc3RlbmVyLCBiaW5kaW5nKSB7XHJcbiAgICBTVkcub24odGhpcy5ub2RlLCBldmVudCwgbGlzdGVuZXIsIGJpbmRpbmcpXHJcblxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcbiAgLy8gVW5iaW5kIGV2ZW50IGZyb20gbGlzdGVuZXJcclxuLCBvZmY6IGZ1bmN0aW9uKGV2ZW50LCBsaXN0ZW5lcikge1xyXG4gICAgU1ZHLm9mZih0aGlzLm5vZGUsIGV2ZW50LCBsaXN0ZW5lcilcclxuXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuICAvLyBGaXJlIGdpdmVuIGV2ZW50XHJcbiwgZmlyZTogZnVuY3Rpb24oZXZlbnQsIGRhdGEpIHtcclxuXHJcbiAgICAvLyBEaXNwYXRjaCBldmVudFxyXG4gICAgaWYoZXZlbnQgaW5zdGFuY2VvZiB3aW5kb3cuRXZlbnQpe1xyXG4gICAgICAgIHRoaXMubm9kZS5kaXNwYXRjaEV2ZW50KGV2ZW50KVxyXG4gICAgfWVsc2V7XHJcbiAgICAgICAgdGhpcy5ub2RlLmRpc3BhdGNoRXZlbnQoZXZlbnQgPSBuZXcgd2luZG93LkN1c3RvbUV2ZW50KGV2ZW50LCB7ZGV0YWlsOmRhdGEsIGNhbmNlbGFibGU6IHRydWV9KSlcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9ldmVudCA9IGV2ZW50XHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuLCBldmVudDogZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZXZlbnRcclxuICB9XHJcbn0pXG5cclxuU1ZHLkRlZnMgPSBTVkcuaW52ZW50KHtcclxuICAvLyBJbml0aWFsaXplIG5vZGVcclxuICBjcmVhdGU6ICdkZWZzJ1xyXG5cclxuICAvLyBJbmhlcml0IGZyb21cclxuLCBpbmhlcml0OiBTVkcuQ29udGFpbmVyXHJcblxyXG59KVxuU1ZHLkcgPSBTVkcuaW52ZW50KHtcclxuICAvLyBJbml0aWFsaXplIG5vZGVcclxuICBjcmVhdGU6ICdnJ1xyXG5cclxuICAvLyBJbmhlcml0IGZyb21cclxuLCBpbmhlcml0OiBTVkcuQ29udGFpbmVyXHJcblxyXG4gIC8vIEFkZCBjbGFzcyBtZXRob2RzXHJcbiwgZXh0ZW5kOiB7XHJcbiAgICAvLyBNb3ZlIG92ZXIgeC1heGlzXHJcbiAgICB4OiBmdW5jdGlvbih4KSB7XHJcbiAgICAgIHJldHVybiB4ID09IG51bGwgPyB0aGlzLnRyYW5zZm9ybSgneCcpIDogdGhpcy50cmFuc2Zvcm0oeyB4OiB4IC0gdGhpcy54KCkgfSwgdHJ1ZSlcclxuICAgIH1cclxuICAgIC8vIE1vdmUgb3ZlciB5LWF4aXNcclxuICAsIHk6IGZ1bmN0aW9uKHkpIHtcclxuICAgICAgcmV0dXJuIHkgPT0gbnVsbCA/IHRoaXMudHJhbnNmb3JtKCd5JykgOiB0aGlzLnRyYW5zZm9ybSh7IHk6IHkgLSB0aGlzLnkoKSB9LCB0cnVlKVxyXG4gICAgfVxyXG4gICAgLy8gTW92ZSBieSBjZW50ZXIgb3ZlciB4LWF4aXNcclxuICAsIGN4OiBmdW5jdGlvbih4KSB7XHJcbiAgICAgIHJldHVybiB4ID09IG51bGwgPyB0aGlzLmdib3goKS5jeCA6IHRoaXMueCh4IC0gdGhpcy5nYm94KCkud2lkdGggLyAyKVxyXG4gICAgfVxyXG4gICAgLy8gTW92ZSBieSBjZW50ZXIgb3ZlciB5LWF4aXNcclxuICAsIGN5OiBmdW5jdGlvbih5KSB7XHJcbiAgICAgIHJldHVybiB5ID09IG51bGwgPyB0aGlzLmdib3goKS5jeSA6IHRoaXMueSh5IC0gdGhpcy5nYm94KCkuaGVpZ2h0IC8gMilcclxuICAgIH1cclxuICAsIGdib3g6IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgdmFyIGJib3ggID0gdGhpcy5iYm94KClcclxuICAgICAgICAsIHRyYW5zID0gdGhpcy50cmFuc2Zvcm0oKVxyXG5cclxuICAgICAgYmJveC54ICArPSB0cmFucy54XHJcbiAgICAgIGJib3gueDIgKz0gdHJhbnMueFxyXG4gICAgICBiYm94LmN4ICs9IHRyYW5zLnhcclxuXHJcbiAgICAgIGJib3gueSAgKz0gdHJhbnMueVxyXG4gICAgICBiYm94LnkyICs9IHRyYW5zLnlcclxuICAgICAgYmJveC5jeSArPSB0cmFucy55XHJcblxyXG4gICAgICByZXR1cm4gYmJveFxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gQWRkIHBhcmVudCBtZXRob2RcclxuLCBjb25zdHJ1Y3Q6IHtcclxuICAgIC8vIENyZWF0ZSBhIGdyb3VwIGVsZW1lbnRcclxuICAgIGdyb3VwOiBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuRylcclxuICAgIH1cclxuICB9XHJcbn0pXHJcblxuLy8gIyMjIFRoaXMgbW9kdWxlIGFkZHMgYmFja3dhcmQgLyBmb3J3YXJkIGZ1bmN0aW9uYWxpdHkgdG8gZWxlbWVudHMuXHJcblxyXG4vL1xyXG5TVkcuZXh0ZW5kKFNWRy5FbGVtZW50LCB7XHJcbiAgLy8gR2V0IGFsbCBzaWJsaW5ncywgaW5jbHVkaW5nIG15c2VsZlxyXG4gIHNpYmxpbmdzOiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLnBhcmVudCgpLmNoaWxkcmVuKClcclxuICB9XHJcbiAgLy8gR2V0IHRoZSBjdXJlbnQgcG9zaXRpb24gc2libGluZ3NcclxuLCBwb3NpdGlvbjogZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5wYXJlbnQoKS5pbmRleCh0aGlzKVxyXG4gIH1cclxuICAvLyBHZXQgdGhlIG5leHQgZWxlbWVudCAod2lsbCByZXR1cm4gbnVsbCBpZiB0aGVyZSBpcyBub25lKVxyXG4sIG5leHQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc2libGluZ3MoKVt0aGlzLnBvc2l0aW9uKCkgKyAxXVxyXG4gIH1cclxuICAvLyBHZXQgdGhlIG5leHQgZWxlbWVudCAod2lsbCByZXR1cm4gbnVsbCBpZiB0aGVyZSBpcyBub25lKVxyXG4sIHByZXZpb3VzOiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLnNpYmxpbmdzKClbdGhpcy5wb3NpdGlvbigpIC0gMV1cclxuICB9XHJcbiAgLy8gU2VuZCBnaXZlbiBlbGVtZW50IG9uZSBzdGVwIGZvcndhcmRcclxuLCBmb3J3YXJkOiBmdW5jdGlvbigpIHtcclxuICAgIHZhciBpID0gdGhpcy5wb3NpdGlvbigpICsgMVxyXG4gICAgICAsIHAgPSB0aGlzLnBhcmVudCgpXHJcblxyXG4gICAgLy8gbW92ZSBub2RlIG9uZSBzdGVwIGZvcndhcmRcclxuICAgIHAucmVtb3ZlRWxlbWVudCh0aGlzKS5hZGQodGhpcywgaSlcclxuXHJcbiAgICAvLyBtYWtlIHN1cmUgZGVmcyBub2RlIGlzIGFsd2F5cyBhdCB0aGUgdG9wXHJcbiAgICBpZiAocCBpbnN0YW5jZW9mIFNWRy5Eb2MpXHJcbiAgICAgIHAubm9kZS5hcHBlbmRDaGlsZChwLmRlZnMoKS5ub2RlKVxyXG5cclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG4gIC8vIFNlbmQgZ2l2ZW4gZWxlbWVudCBvbmUgc3RlcCBiYWNrd2FyZFxyXG4sIGJhY2t3YXJkOiBmdW5jdGlvbigpIHtcclxuICAgIHZhciBpID0gdGhpcy5wb3NpdGlvbigpXHJcblxyXG4gICAgaWYgKGkgPiAwKVxyXG4gICAgICB0aGlzLnBhcmVudCgpLnJlbW92ZUVsZW1lbnQodGhpcykuYWRkKHRoaXMsIGkgLSAxKVxyXG5cclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG4gIC8vIFNlbmQgZ2l2ZW4gZWxlbWVudCBhbGwgdGhlIHdheSB0byB0aGUgZnJvbnRcclxuLCBmcm9udDogZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgcCA9IHRoaXMucGFyZW50KClcclxuXHJcbiAgICAvLyBNb3ZlIG5vZGUgZm9yd2FyZFxyXG4gICAgcC5ub2RlLmFwcGVuZENoaWxkKHRoaXMubm9kZSlcclxuXHJcbiAgICAvLyBNYWtlIHN1cmUgZGVmcyBub2RlIGlzIGFsd2F5cyBhdCB0aGUgdG9wXHJcbiAgICBpZiAocCBpbnN0YW5jZW9mIFNWRy5Eb2MpXHJcbiAgICAgIHAubm9kZS5hcHBlbmRDaGlsZChwLmRlZnMoKS5ub2RlKVxyXG5cclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG4gIC8vIFNlbmQgZ2l2ZW4gZWxlbWVudCBhbGwgdGhlIHdheSB0byB0aGUgYmFja1xyXG4sIGJhY2s6IGZ1bmN0aW9uKCkge1xyXG4gICAgaWYgKHRoaXMucG9zaXRpb24oKSA+IDApXHJcbiAgICAgIHRoaXMucGFyZW50KCkucmVtb3ZlRWxlbWVudCh0aGlzKS5hZGQodGhpcywgMClcclxuXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuICAvLyBJbnNlcnRzIGEgZ2l2ZW4gZWxlbWVudCBiZWZvcmUgdGhlIHRhcmdldGVkIGVsZW1lbnRcclxuLCBiZWZvcmU6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuICAgIGVsZW1lbnQucmVtb3ZlKClcclxuXHJcbiAgICB2YXIgaSA9IHRoaXMucG9zaXRpb24oKVxyXG5cclxuICAgIHRoaXMucGFyZW50KCkuYWRkKGVsZW1lbnQsIGkpXHJcblxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcbiAgLy8gSW5zdGVycyBhIGdpdmVuIGVsZW1lbnQgYWZ0ZXIgdGhlIHRhcmdldGVkIGVsZW1lbnRcclxuLCBhZnRlcjogZnVuY3Rpb24oZWxlbWVudCkge1xyXG4gICAgZWxlbWVudC5yZW1vdmUoKVxyXG5cclxuICAgIHZhciBpID0gdGhpcy5wb3NpdGlvbigpXHJcblxyXG4gICAgdGhpcy5wYXJlbnQoKS5hZGQoZWxlbWVudCwgaSArIDEpXHJcblxyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcblxyXG59KVxuU1ZHLk1hc2sgPSBTVkcuaW52ZW50KHtcclxuICAvLyBJbml0aWFsaXplIG5vZGVcclxuICBjcmVhdGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIFNWRy5jcmVhdGUoJ21hc2snKSlcclxuXHJcbiAgICAvLyBrZWVwIHJlZmVyZW5jZXMgdG8gbWFza2VkIGVsZW1lbnRzXHJcbiAgICB0aGlzLnRhcmdldHMgPSBbXVxyXG4gIH1cclxuXHJcbiAgLy8gSW5oZXJpdCBmcm9tXHJcbiwgaW5oZXJpdDogU1ZHLkNvbnRhaW5lclxyXG5cclxuICAvLyBBZGQgY2xhc3MgbWV0aG9kc1xyXG4sIGV4dGVuZDoge1xyXG4gICAgLy8gVW5tYXNrIGFsbCBtYXNrZWQgZWxlbWVudHMgYW5kIHJlbW92ZSBpdHNlbGZcclxuICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgIC8vIHVubWFzayBhbGwgdGFyZ2V0c1xyXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50YXJnZXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxyXG4gICAgICAgIGlmICh0aGlzLnRhcmdldHNbaV0pXHJcbiAgICAgICAgICB0aGlzLnRhcmdldHNbaV0udW5tYXNrKClcclxuICAgICAgdGhpcy50YXJnZXRzID0gW11cclxuXHJcbiAgICAgIC8vIHJlbW92ZSBtYXNrIGZyb20gcGFyZW50XHJcbiAgICAgIHRoaXMucGFyZW50KCkucmVtb3ZlRWxlbWVudCh0aGlzKVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEFkZCBwYXJlbnQgbWV0aG9kXHJcbiwgY29uc3RydWN0OiB7XHJcbiAgICAvLyBDcmVhdGUgbWFza2luZyBlbGVtZW50XHJcbiAgICBtYXNrOiBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZGVmcygpLnB1dChuZXcgU1ZHLk1hc2spXHJcbiAgICB9XHJcbiAgfVxyXG59KVxyXG5cclxuXHJcblNWRy5leHRlbmQoU1ZHLkVsZW1lbnQsIHtcclxuICAvLyBEaXN0cmlidXRlIG1hc2sgdG8gc3ZnIGVsZW1lbnRcclxuICBtYXNrV2l0aDogZnVuY3Rpb24oZWxlbWVudCkge1xyXG4gICAgLy8gdXNlIGdpdmVuIG1hc2sgb3IgY3JlYXRlIGEgbmV3IG9uZVxyXG4gICAgdGhpcy5tYXNrZXIgPSBlbGVtZW50IGluc3RhbmNlb2YgU1ZHLk1hc2sgPyBlbGVtZW50IDogdGhpcy5wYXJlbnQoKS5tYXNrKCkuYWRkKGVsZW1lbnQpXHJcblxyXG4gICAgLy8gc3RvcmUgcmV2ZXJlbmNlIG9uIHNlbGYgaW4gbWFza1xyXG4gICAgdGhpcy5tYXNrZXIudGFyZ2V0cy5wdXNoKHRoaXMpXHJcblxyXG4gICAgLy8gYXBwbHkgbWFza1xyXG4gICAgcmV0dXJuIHRoaXMuYXR0cignbWFzaycsICd1cmwoXCIjJyArIHRoaXMubWFza2VyLmF0dHIoJ2lkJykgKyAnXCIpJylcclxuICB9XHJcbiAgLy8gVW5tYXNrIGVsZW1lbnRcclxuLCB1bm1hc2s6IGZ1bmN0aW9uKCkge1xyXG4gICAgZGVsZXRlIHRoaXMubWFza2VyXHJcbiAgICByZXR1cm4gdGhpcy5hdHRyKCdtYXNrJywgbnVsbClcclxuICB9XHJcblxyXG59KVxyXG5cblNWRy5DbGlwUGF0aCA9IFNWRy5pbnZlbnQoe1xyXG4gIC8vIEluaXRpYWxpemUgbm9kZVxyXG4gIGNyZWF0ZTogZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgU1ZHLmNyZWF0ZSgnY2xpcFBhdGgnKSlcclxuXHJcbiAgICAvLyBrZWVwIHJlZmVyZW5jZXMgdG8gY2xpcHBlZCBlbGVtZW50c1xyXG4gICAgdGhpcy50YXJnZXRzID0gW11cclxuICB9XHJcblxyXG4gIC8vIEluaGVyaXQgZnJvbVxyXG4sIGluaGVyaXQ6IFNWRy5Db250YWluZXJcclxuXHJcbiAgLy8gQWRkIGNsYXNzIG1ldGhvZHNcclxuLCBleHRlbmQ6IHtcclxuICAgIC8vIFVuY2xpcCBhbGwgY2xpcHBlZCBlbGVtZW50cyBhbmQgcmVtb3ZlIGl0c2VsZlxyXG4gICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcclxuICAgICAgLy8gdW5jbGlwIGFsbCB0YXJnZXRzXHJcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRhcmdldHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXHJcbiAgICAgICAgaWYgKHRoaXMudGFyZ2V0c1tpXSlcclxuICAgICAgICAgIHRoaXMudGFyZ2V0c1tpXS51bmNsaXAoKVxyXG4gICAgICB0aGlzLnRhcmdldHMgPSBbXVxyXG5cclxuICAgICAgLy8gcmVtb3ZlIGNsaXBQYXRoIGZyb20gcGFyZW50XHJcbiAgICAgIHRoaXMucGFyZW50KCkucmVtb3ZlRWxlbWVudCh0aGlzKVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEFkZCBwYXJlbnQgbWV0aG9kXHJcbiwgY29uc3RydWN0OiB7XHJcbiAgICAvLyBDcmVhdGUgY2xpcHBpbmcgZWxlbWVudFxyXG4gICAgY2xpcDogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmRlZnMoKS5wdXQobmV3IFNWRy5DbGlwUGF0aClcclxuICAgIH1cclxuICB9XHJcbn0pXHJcblxyXG4vL1xyXG5TVkcuZXh0ZW5kKFNWRy5FbGVtZW50LCB7XHJcbiAgLy8gRGlzdHJpYnV0ZSBjbGlwUGF0aCB0byBzdmcgZWxlbWVudFxyXG4gIGNsaXBXaXRoOiBmdW5jdGlvbihlbGVtZW50KSB7XHJcbiAgICAvLyB1c2UgZ2l2ZW4gY2xpcCBvciBjcmVhdGUgYSBuZXcgb25lXHJcbiAgICB0aGlzLmNsaXBwZXIgPSBlbGVtZW50IGluc3RhbmNlb2YgU1ZHLkNsaXBQYXRoID8gZWxlbWVudCA6IHRoaXMucGFyZW50KCkuY2xpcCgpLmFkZChlbGVtZW50KVxyXG5cclxuICAgIC8vIHN0b3JlIHJldmVyZW5jZSBvbiBzZWxmIGluIG1hc2tcclxuICAgIHRoaXMuY2xpcHBlci50YXJnZXRzLnB1c2godGhpcylcclxuXHJcbiAgICAvLyBhcHBseSBtYXNrXHJcbiAgICByZXR1cm4gdGhpcy5hdHRyKCdjbGlwLXBhdGgnLCAndXJsKFwiIycgKyB0aGlzLmNsaXBwZXIuYXR0cignaWQnKSArICdcIiknKVxyXG4gIH1cclxuICAvLyBVbmNsaXAgZWxlbWVudFxyXG4sIHVuY2xpcDogZnVuY3Rpb24oKSB7XHJcbiAgICBkZWxldGUgdGhpcy5jbGlwcGVyXHJcbiAgICByZXR1cm4gdGhpcy5hdHRyKCdjbGlwLXBhdGgnLCBudWxsKVxyXG4gIH1cclxuXHJcbn0pXG5TVkcuR3JhZGllbnQgPSBTVkcuaW52ZW50KHtcclxuICAvLyBJbml0aWFsaXplIG5vZGVcclxuICBjcmVhdGU6IGZ1bmN0aW9uKHR5cGUpIHtcclxuICAgIHRoaXMuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBTVkcuY3JlYXRlKHR5cGUgKyAnR3JhZGllbnQnKSlcclxuXHJcbiAgICAvLyBzdG9yZSB0eXBlXHJcbiAgICB0aGlzLnR5cGUgPSB0eXBlXHJcbiAgfVxyXG5cclxuICAvLyBJbmhlcml0IGZyb21cclxuLCBpbmhlcml0OiBTVkcuQ29udGFpbmVyXHJcblxyXG4gIC8vIEFkZCBjbGFzcyBtZXRob2RzXHJcbiwgZXh0ZW5kOiB7XHJcbiAgICAvLyBBZGQgYSBjb2xvciBzdG9wXHJcbiAgICBhdDogZnVuY3Rpb24ob2Zmc2V0LCBjb2xvciwgb3BhY2l0eSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5TdG9wKS51cGRhdGUob2Zmc2V0LCBjb2xvciwgb3BhY2l0eSlcclxuICAgIH1cclxuICAgIC8vIFVwZGF0ZSBncmFkaWVudFxyXG4gICwgdXBkYXRlOiBmdW5jdGlvbihibG9jaykge1xyXG4gICAgICAvLyByZW1vdmUgYWxsIHN0b3BzXHJcbiAgICAgIHRoaXMuY2xlYXIoKVxyXG5cclxuICAgICAgLy8gaW52b2tlIHBhc3NlZCBibG9ja1xyXG4gICAgICBpZiAodHlwZW9mIGJsb2NrID09ICdmdW5jdGlvbicpXHJcbiAgICAgICAgYmxvY2suY2FsbCh0aGlzLCB0aGlzKVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuICAgIC8vIFJldHVybiB0aGUgZmlsbCBpZFxyXG4gICwgZmlsbDogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiAndXJsKCMnICsgdGhpcy5pZCgpICsgJyknXHJcbiAgICB9XHJcbiAgICAvLyBBbGlhcyBzdHJpbmcgY29udmVydGlvbiB0byBmaWxsXHJcbiAgLCB0b1N0cmluZzogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmZpbGwoKVxyXG4gICAgfVxyXG4gICAgLy8gY3VzdG9tIGF0dHIgdG8gaGFuZGxlIHRyYW5zZm9ybVxyXG4gICwgYXR0cjogZnVuY3Rpb24oYSwgYiwgYykge1xyXG4gICAgICBpZihhID09ICd0cmFuc2Zvcm0nKSBhID0gJ2dyYWRpZW50VHJhbnNmb3JtJ1xyXG4gICAgICByZXR1cm4gU1ZHLkNvbnRhaW5lci5wcm90b3R5cGUuYXR0ci5jYWxsKHRoaXMsIGEsIGIsIGMpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBBZGQgcGFyZW50IG1ldGhvZFxyXG4sIGNvbnN0cnVjdDoge1xyXG4gICAgLy8gQ3JlYXRlIGdyYWRpZW50IGVsZW1lbnQgaW4gZGVmc1xyXG4gICAgZ3JhZGllbnQ6IGZ1bmN0aW9uKHR5cGUsIGJsb2NrKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmRlZnMoKS5ncmFkaWVudCh0eXBlLCBibG9jaylcclxuICAgIH1cclxuICB9XHJcbn0pXHJcblxyXG4vLyBBZGQgYW5pbWF0YWJsZSBtZXRob2RzIHRvIGJvdGggZ3JhZGllbnQgYW5kIGZ4IG1vZHVsZVxyXG5TVkcuZXh0ZW5kKFNWRy5HcmFkaWVudCwgU1ZHLkZYLCB7XHJcbiAgLy8gRnJvbSBwb3NpdGlvblxyXG4gIGZyb206IGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgIHJldHVybiAodGhpcy5fdGFyZ2V0IHx8IHRoaXMpLnR5cGUgPT0gJ3JhZGlhbCcgP1xyXG4gICAgICB0aGlzLmF0dHIoeyBmeDogbmV3IFNWRy5OdW1iZXIoeCksIGZ5OiBuZXcgU1ZHLk51bWJlcih5KSB9KSA6XHJcbiAgICAgIHRoaXMuYXR0cih7IHgxOiBuZXcgU1ZHLk51bWJlcih4KSwgeTE6IG5ldyBTVkcuTnVtYmVyKHkpIH0pXHJcbiAgfVxyXG4gIC8vIFRvIHBvc2l0aW9uXHJcbiwgdG86IGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgIHJldHVybiAodGhpcy5fdGFyZ2V0IHx8IHRoaXMpLnR5cGUgPT0gJ3JhZGlhbCcgP1xyXG4gICAgICB0aGlzLmF0dHIoeyBjeDogbmV3IFNWRy5OdW1iZXIoeCksIGN5OiBuZXcgU1ZHLk51bWJlcih5KSB9KSA6XHJcbiAgICAgIHRoaXMuYXR0cih7IHgyOiBuZXcgU1ZHLk51bWJlcih4KSwgeTI6IG5ldyBTVkcuTnVtYmVyKHkpIH0pXHJcbiAgfVxyXG59KVxyXG5cclxuLy8gQmFzZSBncmFkaWVudCBnZW5lcmF0aW9uXHJcblNWRy5leHRlbmQoU1ZHLkRlZnMsIHtcclxuICAvLyBkZWZpbmUgZ3JhZGllbnRcclxuICBncmFkaWVudDogZnVuY3Rpb24odHlwZSwgYmxvY2spIHtcclxuICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLkdyYWRpZW50KHR5cGUpKS51cGRhdGUoYmxvY2spXHJcbiAgfVxyXG5cclxufSlcclxuXHJcblNWRy5TdG9wID0gU1ZHLmludmVudCh7XHJcbiAgLy8gSW5pdGlhbGl6ZSBub2RlXHJcbiAgY3JlYXRlOiAnc3RvcCdcclxuXHJcbiAgLy8gSW5oZXJpdCBmcm9tXHJcbiwgaW5oZXJpdDogU1ZHLkVsZW1lbnRcclxuXHJcbiAgLy8gQWRkIGNsYXNzIG1ldGhvZHNcclxuLCBleHRlbmQ6IHtcclxuICAgIC8vIGFkZCBjb2xvciBzdG9wc1xyXG4gICAgdXBkYXRlOiBmdW5jdGlvbihvKSB7XHJcbiAgICAgIGlmICh0eXBlb2YgbyA9PSAnbnVtYmVyJyB8fCBvIGluc3RhbmNlb2YgU1ZHLk51bWJlcikge1xyXG4gICAgICAgIG8gPSB7XHJcbiAgICAgICAgICBvZmZzZXQ6ICBhcmd1bWVudHNbMF1cclxuICAgICAgICAsIGNvbG9yOiAgIGFyZ3VtZW50c1sxXVxyXG4gICAgICAgICwgb3BhY2l0eTogYXJndW1lbnRzWzJdXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBzZXQgYXR0cmlidXRlc1xyXG4gICAgICBpZiAoby5vcGFjaXR5ICE9IG51bGwpIHRoaXMuYXR0cignc3RvcC1vcGFjaXR5Jywgby5vcGFjaXR5KVxyXG4gICAgICBpZiAoby5jb2xvciAgICE9IG51bGwpIHRoaXMuYXR0cignc3RvcC1jb2xvcicsIG8uY29sb3IpXHJcbiAgICAgIGlmIChvLm9mZnNldCAgIT0gbnVsbCkgdGhpcy5hdHRyKCdvZmZzZXQnLCBuZXcgU1ZHLk51bWJlcihvLm9mZnNldCkpXHJcblxyXG4gICAgICByZXR1cm4gdGhpc1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbn0pXHJcblxuU1ZHLlBhdHRlcm4gPSBTVkcuaW52ZW50KHtcclxuICAvLyBJbml0aWFsaXplIG5vZGVcclxuICBjcmVhdGU6ICdwYXR0ZXJuJ1xyXG5cclxuICAvLyBJbmhlcml0IGZyb21cclxuLCBpbmhlcml0OiBTVkcuQ29udGFpbmVyXHJcblxyXG4gIC8vIEFkZCBjbGFzcyBtZXRob2RzXHJcbiwgZXh0ZW5kOiB7XHJcbiAgICAvLyBSZXR1cm4gdGhlIGZpbGwgaWRcclxuICAgIGZpbGw6IGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gJ3VybCgjJyArIHRoaXMuaWQoKSArICcpJ1xyXG4gICAgfVxyXG4gICAgLy8gVXBkYXRlIHBhdHRlcm4gYnkgcmVidWlsZGluZ1xyXG4gICwgdXBkYXRlOiBmdW5jdGlvbihibG9jaykge1xyXG4gICAgICAvLyByZW1vdmUgY29udGVudFxyXG4gICAgICB0aGlzLmNsZWFyKClcclxuXHJcbiAgICAgIC8vIGludm9rZSBwYXNzZWQgYmxvY2tcclxuICAgICAgaWYgKHR5cGVvZiBibG9jayA9PSAnZnVuY3Rpb24nKVxyXG4gICAgICAgIGJsb2NrLmNhbGwodGhpcywgdGhpcylcclxuXHJcbiAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcbiAgICAvLyBBbGlhcyBzdHJpbmcgY29udmVydGlvbiB0byBmaWxsXHJcbiAgLCB0b1N0cmluZzogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmZpbGwoKVxyXG4gICAgfVxyXG4gICAgLy8gY3VzdG9tIGF0dHIgdG8gaGFuZGxlIHRyYW5zZm9ybVxyXG4gICwgYXR0cjogZnVuY3Rpb24oYSwgYiwgYykge1xyXG4gICAgICBpZihhID09ICd0cmFuc2Zvcm0nKSBhID0gJ3BhdHRlcm5UcmFuc2Zvcm0nXHJcbiAgICAgIHJldHVybiBTVkcuQ29udGFpbmVyLnByb3RvdHlwZS5hdHRyLmNhbGwodGhpcywgYSwgYiwgYylcclxuICAgIH1cclxuXHJcbiAgfVxyXG5cclxuICAvLyBBZGQgcGFyZW50IG1ldGhvZFxyXG4sIGNvbnN0cnVjdDoge1xyXG4gICAgLy8gQ3JlYXRlIHBhdHRlcm4gZWxlbWVudCBpbiBkZWZzXHJcbiAgICBwYXR0ZXJuOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCBibG9jaykge1xyXG4gICAgICByZXR1cm4gdGhpcy5kZWZzKCkucGF0dGVybih3aWR0aCwgaGVpZ2h0LCBibG9jaylcclxuICAgIH1cclxuICB9XHJcbn0pXHJcblxyXG5TVkcuZXh0ZW5kKFNWRy5EZWZzLCB7XHJcbiAgLy8gRGVmaW5lIGdyYWRpZW50XHJcbiAgcGF0dGVybjogZnVuY3Rpb24od2lkdGgsIGhlaWdodCwgYmxvY2spIHtcclxuICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLlBhdHRlcm4pLnVwZGF0ZShibG9jaykuYXR0cih7XHJcbiAgICAgIHg6ICAgICAgICAgICAgMFxyXG4gICAgLCB5OiAgICAgICAgICAgIDBcclxuICAgICwgd2lkdGg6ICAgICAgICB3aWR0aFxyXG4gICAgLCBoZWlnaHQ6ICAgICAgIGhlaWdodFxyXG4gICAgLCBwYXR0ZXJuVW5pdHM6ICd1c2VyU3BhY2VPblVzZSdcclxuICAgIH0pXHJcbiAgfVxyXG5cclxufSlcblNWRy5Eb2MgPSBTVkcuaW52ZW50KHtcclxuICAvLyBJbml0aWFsaXplIG5vZGVcclxuICBjcmVhdGU6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuICAgIGlmIChlbGVtZW50KSB7XHJcbiAgICAgIC8vIGVuc3VyZSB0aGUgcHJlc2VuY2Ugb2YgYSBkb20gZWxlbWVudFxyXG4gICAgICBlbGVtZW50ID0gdHlwZW9mIGVsZW1lbnQgPT0gJ3N0cmluZycgP1xyXG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1lbnQpIDpcclxuICAgICAgICBlbGVtZW50XHJcblxyXG4gICAgICAvLyBJZiB0aGUgdGFyZ2V0IGlzIGFuIHN2ZyBlbGVtZW50LCB1c2UgdGhhdCBlbGVtZW50IGFzIHRoZSBtYWluIHdyYXBwZXIuXHJcbiAgICAgIC8vIFRoaXMgYWxsb3dzIHN2Zy5qcyB0byB3b3JrIHdpdGggc3ZnIGRvY3VtZW50cyBhcyB3ZWxsLlxyXG4gICAgICBpZiAoZWxlbWVudC5ub2RlTmFtZSA9PSAnc3ZnJykge1xyXG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBlbGVtZW50KVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBTVkcuY3JlYXRlKCdzdmcnKSlcclxuICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKHRoaXMubm9kZSlcclxuICAgICAgICB0aGlzLnNpemUoJzEwMCUnLCAnMTAwJScpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHNldCBzdmcgZWxlbWVudCBhdHRyaWJ1dGVzIGFuZCBlbnN1cmUgZGVmcyBub2RlXHJcbiAgICAgIHRoaXMubmFtZXNwYWNlKCkuZGVmcygpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBJbmhlcml0IGZyb21cclxuLCBpbmhlcml0OiBTVkcuQ29udGFpbmVyXHJcblxyXG4gIC8vIEFkZCBjbGFzcyBtZXRob2RzXHJcbiwgZXh0ZW5kOiB7XHJcbiAgICAvLyBBZGQgbmFtZXNwYWNlc1xyXG4gICAgbmFtZXNwYWNlOiBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICAuYXR0cih7IHhtbG5zOiBTVkcubnMsIHZlcnNpb246ICcxLjEnIH0pXHJcbiAgICAgICAgLmF0dHIoJ3htbG5zOnhsaW5rJywgU1ZHLnhsaW5rLCBTVkcueG1sbnMpXHJcbiAgICAgICAgLmF0dHIoJ3htbG5zOnN2Z2pzJywgU1ZHLnN2Z2pzLCBTVkcueG1sbnMpXHJcbiAgICB9XHJcbiAgICAvLyBDcmVhdGVzIGFuZCByZXR1cm5zIGRlZnMgZWxlbWVudFxyXG4gICwgZGVmczogZnVuY3Rpb24oKSB7XHJcbiAgICAgIGlmICghdGhpcy5fZGVmcykge1xyXG4gICAgICAgIHZhciBkZWZzXHJcblxyXG4gICAgICAgIC8vIEZpbmQgb3IgY3JlYXRlIGEgZGVmcyBlbGVtZW50IGluIHRoaXMgaW5zdGFuY2VcclxuICAgICAgICBpZiAoZGVmcyA9IHRoaXMubm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnZGVmcycpWzBdKVxyXG4gICAgICAgICAgdGhpcy5fZGVmcyA9IFNWRy5hZG9wdChkZWZzKVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgIHRoaXMuX2RlZnMgPSBuZXcgU1ZHLkRlZnNcclxuXHJcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBkZWZzIG5vZGUgaXMgYXQgdGhlIGVuZCBvZiB0aGUgc3RhY2tcclxuICAgICAgICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQodGhpcy5fZGVmcy5ub2RlKVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdGhpcy5fZGVmc1xyXG4gICAgfVxyXG4gICAgLy8gY3VzdG9tIHBhcmVudCBtZXRob2RcclxuICAsIHBhcmVudDogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm5vZGUucGFyZW50Tm9kZS5ub2RlTmFtZSA9PSAnI2RvY3VtZW50JyA/IG51bGwgOiB0aGlzLm5vZGUucGFyZW50Tm9kZVxyXG4gICAgfVxyXG4gICAgLy8gRml4IGZvciBwb3NzaWJsZSBzdWItcGl4ZWwgb2Zmc2V0LiBTZWU6XHJcbiAgICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02MDg4MTJcclxuICAsIHNwb2Y6IGZ1bmN0aW9uKHNwb2YpIHtcclxuICAgICAgdmFyIHBvcyA9IHRoaXMubm9kZS5nZXRTY3JlZW5DVE0oKVxyXG5cclxuICAgICAgaWYgKHBvcylcclxuICAgICAgICB0aGlzXHJcbiAgICAgICAgICAuc3R5bGUoJ2xlZnQnLCAoLXBvcy5lICUgMSkgKyAncHgnKVxyXG4gICAgICAgICAgLnN0eWxlKCd0b3AnLCAgKC1wb3MuZiAlIDEpICsgJ3B4JylcclxuXHJcbiAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcblxyXG4gICAgICAvLyBSZW1vdmVzIHRoZSBkb2MgZnJvbSB0aGUgRE9NXHJcbiAgLCByZW1vdmU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICBpZih0aGlzLnBhcmVudCgpKSB7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQoKS5yZW1vdmVDaGlsZCh0aGlzLm5vZGUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICB9XHJcblxyXG59KVxyXG5cblNWRy5TaGFwZSA9IFNWRy5pbnZlbnQoe1xyXG4gIC8vIEluaXRpYWxpemUgbm9kZVxyXG4gIGNyZWF0ZTogZnVuY3Rpb24oZWxlbWVudCkge1xyXG4gICAgdGhpcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIGVsZW1lbnQpXHJcbiAgfVxyXG5cclxuICAvLyBJbmhlcml0IGZyb21cclxuLCBpbmhlcml0OiBTVkcuRWxlbWVudFxyXG5cclxufSlcblxyXG5TVkcuQmFyZSA9IFNWRy5pbnZlbnQoe1xyXG4gIC8vIEluaXRpYWxpemVcclxuICBjcmVhdGU6IGZ1bmN0aW9uKGVsZW1lbnQsIGluaGVyaXQpIHtcclxuICAgIC8vIGNvbnN0cnVjdCBlbGVtZW50XHJcbiAgICB0aGlzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgU1ZHLmNyZWF0ZShlbGVtZW50KSlcclxuXHJcbiAgICAvLyBpbmhlcml0IGN1c3RvbSBtZXRob2RzXHJcbiAgICBpZiAoaW5oZXJpdClcclxuICAgICAgZm9yICh2YXIgbWV0aG9kIGluIGluaGVyaXQucHJvdG90eXBlKVxyXG4gICAgICAgIGlmICh0eXBlb2YgaW5oZXJpdC5wcm90b3R5cGVbbWV0aG9kXSA9PT0gJ2Z1bmN0aW9uJylcclxuICAgICAgICAgIHRoaXNbbWV0aG9kXSA9IGluaGVyaXQucHJvdG90eXBlW21ldGhvZF1cclxuICB9XHJcblxyXG4gIC8vIEluaGVyaXQgZnJvbVxyXG4sIGluaGVyaXQ6IFNWRy5FbGVtZW50XHJcblxyXG4gIC8vIEFkZCBtZXRob2RzXHJcbiwgZXh0ZW5kOiB7XHJcbiAgICAvLyBJbnNlcnQgc29tZSBwbGFpbiB0ZXh0XHJcbiAgICB3b3JkczogZnVuY3Rpb24odGV4dCkge1xyXG4gICAgICAvLyByZW1vdmUgY29udGVudHNcclxuICAgICAgd2hpbGUgKHRoaXMubm9kZS5oYXNDaGlsZE5vZGVzKCkpXHJcbiAgICAgICAgdGhpcy5ub2RlLnJlbW92ZUNoaWxkKHRoaXMubm9kZS5sYXN0Q2hpbGQpXHJcblxyXG4gICAgICAvLyBjcmVhdGUgdGV4dCBub2RlXHJcbiAgICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KSlcclxuXHJcbiAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcbiAgfVxyXG59KVxyXG5cclxuXHJcblNWRy5leHRlbmQoU1ZHLlBhcmVudCwge1xyXG4gIC8vIENyZWF0ZSBhbiBlbGVtZW50IHRoYXQgaXMgbm90IGRlc2NyaWJlZCBieSBTVkcuanNcclxuICBlbGVtZW50OiBmdW5jdGlvbihlbGVtZW50LCBpbmhlcml0KSB7XHJcbiAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5CYXJlKGVsZW1lbnQsIGluaGVyaXQpKVxyXG4gIH1cclxufSlcclxuXG5TVkcuU3ltYm9sID0gU1ZHLmludmVudCh7XHJcbiAgLy8gSW5pdGlhbGl6ZSBub2RlXHJcbiAgY3JlYXRlOiAnc3ltYm9sJ1xyXG5cclxuICAvLyBJbmhlcml0IGZyb21cclxuLCBpbmhlcml0OiBTVkcuQ29udGFpbmVyXHJcblxyXG4sIGNvbnN0cnVjdDoge1xyXG4gICAgLy8gY3JlYXRlIHN5bWJvbFxyXG4gICAgc3ltYm9sOiBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuU3ltYm9sKVxyXG4gICAgfVxyXG4gIH1cclxufSlcclxuXG5TVkcuVXNlID0gU1ZHLmludmVudCh7XHJcbiAgLy8gSW5pdGlhbGl6ZSBub2RlXHJcbiAgY3JlYXRlOiAndXNlJ1xyXG5cclxuICAvLyBJbmhlcml0IGZyb21cclxuLCBpbmhlcml0OiBTVkcuU2hhcGVcclxuXHJcbiAgLy8gQWRkIGNsYXNzIG1ldGhvZHNcclxuLCBleHRlbmQ6IHtcclxuICAgIC8vIFVzZSBlbGVtZW50IGFzIGEgcmVmZXJlbmNlXHJcbiAgICBlbGVtZW50OiBmdW5jdGlvbihlbGVtZW50LCBmaWxlKSB7XHJcbiAgICAgIC8vIFNldCBsaW5lZCBlbGVtZW50XHJcbiAgICAgIHJldHVybiB0aGlzLmF0dHIoJ2hyZWYnLCAoZmlsZSB8fCAnJykgKyAnIycgKyBlbGVtZW50LCBTVkcueGxpbmspXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBBZGQgcGFyZW50IG1ldGhvZFxyXG4sIGNvbnN0cnVjdDoge1xyXG4gICAgLy8gQ3JlYXRlIGEgdXNlIGVsZW1lbnRcclxuICAgIHVzZTogZnVuY3Rpb24oZWxlbWVudCwgZmlsZSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5Vc2UpLmVsZW1lbnQoZWxlbWVudCwgZmlsZSlcclxuICAgIH1cclxuICB9XHJcbn0pXG5TVkcuUmVjdCA9IFNWRy5pbnZlbnQoe1xyXG4gIC8vIEluaXRpYWxpemUgbm9kZVxyXG4gIGNyZWF0ZTogJ3JlY3QnXHJcblxyXG4gIC8vIEluaGVyaXQgZnJvbVxyXG4sIGluaGVyaXQ6IFNWRy5TaGFwZVxyXG5cclxuICAvLyBBZGQgcGFyZW50IG1ldGhvZFxyXG4sIGNvbnN0cnVjdDoge1xyXG4gICAgLy8gQ3JlYXRlIGEgcmVjdCBlbGVtZW50XHJcbiAgICByZWN0OiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLlJlY3QoKSkuc2l6ZSh3aWR0aCwgaGVpZ2h0KVxyXG4gICAgfVxyXG4gIH1cclxufSlcblNWRy5DaXJjbGUgPSBTVkcuaW52ZW50KHtcclxuICAvLyBJbml0aWFsaXplIG5vZGVcclxuICBjcmVhdGU6ICdjaXJjbGUnXHJcblxyXG4gIC8vIEluaGVyaXQgZnJvbVxyXG4sIGluaGVyaXQ6IFNWRy5TaGFwZVxyXG5cclxuICAvLyBBZGQgcGFyZW50IG1ldGhvZFxyXG4sIGNvbnN0cnVjdDoge1xyXG4gICAgLy8gQ3JlYXRlIGNpcmNsZSBlbGVtZW50LCBiYXNlZCBvbiBlbGxpcHNlXHJcbiAgICBjaXJjbGU6IGZ1bmN0aW9uKHNpemUpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuQ2lyY2xlKS5yeChuZXcgU1ZHLk51bWJlcihzaXplKS5kaXZpZGUoMikpLm1vdmUoMCwgMClcclxuICAgIH1cclxuICB9XHJcbn0pXHJcblxyXG5TVkcuZXh0ZW5kKFNWRy5DaXJjbGUsIFNWRy5GWCwge1xyXG4gIC8vIFJhZGl1cyB4IHZhbHVlXHJcbiAgcng6IGZ1bmN0aW9uKHJ4KSB7XHJcbiAgICByZXR1cm4gdGhpcy5hdHRyKCdyJywgcngpXHJcbiAgfVxyXG4gIC8vIEFsaWFzIHJhZGl1cyB4IHZhbHVlXHJcbiwgcnk6IGZ1bmN0aW9uKHJ5KSB7XHJcbiAgICByZXR1cm4gdGhpcy5yeChyeSlcclxuICB9XHJcbn0pXHJcblxyXG5TVkcuRWxsaXBzZSA9IFNWRy5pbnZlbnQoe1xyXG4gIC8vIEluaXRpYWxpemUgbm9kZVxyXG4gIGNyZWF0ZTogJ2VsbGlwc2UnXHJcblxyXG4gIC8vIEluaGVyaXQgZnJvbVxyXG4sIGluaGVyaXQ6IFNWRy5TaGFwZVxyXG5cclxuICAvLyBBZGQgcGFyZW50IG1ldGhvZFxyXG4sIGNvbnN0cnVjdDoge1xyXG4gICAgLy8gQ3JlYXRlIGFuIGVsbGlwc2VcclxuICAgIGVsbGlwc2U6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuRWxsaXBzZSkuc2l6ZSh3aWR0aCwgaGVpZ2h0KS5tb3ZlKDAsIDApXHJcbiAgICB9XHJcbiAgfVxyXG59KVxyXG5cclxuU1ZHLmV4dGVuZChTVkcuRWxsaXBzZSwgU1ZHLlJlY3QsIFNWRy5GWCwge1xyXG4gIC8vIFJhZGl1cyB4IHZhbHVlXHJcbiAgcng6IGZ1bmN0aW9uKHJ4KSB7XHJcbiAgICByZXR1cm4gdGhpcy5hdHRyKCdyeCcsIHJ4KVxyXG4gIH1cclxuICAvLyBSYWRpdXMgeSB2YWx1ZVxyXG4sIHJ5OiBmdW5jdGlvbihyeSkge1xyXG4gICAgcmV0dXJuIHRoaXMuYXR0cigncnknLCByeSlcclxuICB9XHJcbn0pXHJcblxyXG4vLyBBZGQgY29tbW9uIG1ldGhvZFxyXG5TVkcuZXh0ZW5kKFNWRy5DaXJjbGUsIFNWRy5FbGxpcHNlLCB7XHJcbiAgICAvLyBNb3ZlIG92ZXIgeC1heGlzXHJcbiAgICB4OiBmdW5jdGlvbih4KSB7XHJcbiAgICAgIHJldHVybiB4ID09IG51bGwgPyB0aGlzLmN4KCkgLSB0aGlzLnJ4KCkgOiB0aGlzLmN4KHggKyB0aGlzLnJ4KCkpXHJcbiAgICB9XHJcbiAgICAvLyBNb3ZlIG92ZXIgeS1heGlzXHJcbiAgLCB5OiBmdW5jdGlvbih5KSB7XHJcbiAgICAgIHJldHVybiB5ID09IG51bGwgPyB0aGlzLmN5KCkgLSB0aGlzLnJ5KCkgOiB0aGlzLmN5KHkgKyB0aGlzLnJ5KCkpXHJcbiAgICB9XHJcbiAgICAvLyBNb3ZlIGJ5IGNlbnRlciBvdmVyIHgtYXhpc1xyXG4gICwgY3g6IGZ1bmN0aW9uKHgpIHtcclxuICAgICAgcmV0dXJuIHggPT0gbnVsbCA/IHRoaXMuYXR0cignY3gnKSA6IHRoaXMuYXR0cignY3gnLCB4KVxyXG4gICAgfVxyXG4gICAgLy8gTW92ZSBieSBjZW50ZXIgb3ZlciB5LWF4aXNcclxuICAsIGN5OiBmdW5jdGlvbih5KSB7XHJcbiAgICAgIHJldHVybiB5ID09IG51bGwgPyB0aGlzLmF0dHIoJ2N5JykgOiB0aGlzLmF0dHIoJ2N5JywgeSlcclxuICAgIH1cclxuICAgIC8vIFNldCB3aWR0aCBvZiBlbGVtZW50XHJcbiAgLCB3aWR0aDogZnVuY3Rpb24od2lkdGgpIHtcclxuICAgICAgcmV0dXJuIHdpZHRoID09IG51bGwgPyB0aGlzLnJ4KCkgKiAyIDogdGhpcy5yeChuZXcgU1ZHLk51bWJlcih3aWR0aCkuZGl2aWRlKDIpKVxyXG4gICAgfVxyXG4gICAgLy8gU2V0IGhlaWdodCBvZiBlbGVtZW50XHJcbiAgLCBoZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCkge1xyXG4gICAgICByZXR1cm4gaGVpZ2h0ID09IG51bGwgPyB0aGlzLnJ5KCkgKiAyIDogdGhpcy5yeShuZXcgU1ZHLk51bWJlcihoZWlnaHQpLmRpdmlkZSgyKSlcclxuICAgIH1cclxuICAgIC8vIEN1c3RvbSBzaXplIGZ1bmN0aW9uXHJcbiAgLCBzaXplOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgIHZhciBwID0gcHJvcG9ydGlvbmFsU2l6ZSh0aGlzLCB3aWR0aCwgaGVpZ2h0KVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICAucngobmV3IFNWRy5OdW1iZXIocC53aWR0aCkuZGl2aWRlKDIpKVxyXG4gICAgICAgIC5yeShuZXcgU1ZHLk51bWJlcihwLmhlaWdodCkuZGl2aWRlKDIpKVxyXG4gICAgfVxyXG59KVxuU1ZHLkxpbmUgPSBTVkcuaW52ZW50KHtcclxuICAvLyBJbml0aWFsaXplIG5vZGVcclxuICBjcmVhdGU6ICdsaW5lJ1xyXG5cclxuICAvLyBJbmhlcml0IGZyb21cclxuLCBpbmhlcml0OiBTVkcuU2hhcGVcclxuXHJcbiAgLy8gQWRkIGNsYXNzIG1ldGhvZHNcclxuLCBleHRlbmQ6IHtcclxuICAgIC8vIEdldCBhcnJheVxyXG4gICAgYXJyYXk6IGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gbmV3IFNWRy5Qb2ludEFycmF5KFtcclxuICAgICAgICBbIHRoaXMuYXR0cigneDEnKSwgdGhpcy5hdHRyKCd5MScpIF1cclxuICAgICAgLCBbIHRoaXMuYXR0cigneDInKSwgdGhpcy5hdHRyKCd5MicpIF1cclxuICAgICAgXSlcclxuICAgIH1cclxuICAgIC8vIE92ZXJ3cml0ZSBuYXRpdmUgcGxvdCgpIG1ldGhvZFxyXG4gICwgcGxvdDogZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIpIHtcclxuICAgICAgaWYgKHgxID09IG51bGwpXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJyYXkoKVxyXG4gICAgICBlbHNlIGlmICh0eXBlb2YgeTEgIT09ICd1bmRlZmluZWQnKVxyXG4gICAgICAgIHgxID0geyB4MTogeDEsIHkxOiB5MSwgeDI6IHgyLCB5MjogeTIgfVxyXG4gICAgICBlbHNlXHJcbiAgICAgICAgeDEgPSBuZXcgU1ZHLlBvaW50QXJyYXkoeDEpLnRvTGluZSgpXHJcblxyXG4gICAgICByZXR1cm4gdGhpcy5hdHRyKHgxKVxyXG4gICAgfVxyXG4gICAgLy8gTW92ZSBieSBsZWZ0IHRvcCBjb3JuZXJcclxuICAsIG1vdmU6IGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuYXR0cih0aGlzLmFycmF5KCkubW92ZSh4LCB5KS50b0xpbmUoKSlcclxuICAgIH1cclxuICAgIC8vIFNldCBlbGVtZW50IHNpemUgdG8gZ2l2ZW4gd2lkdGggYW5kIGhlaWdodFxyXG4gICwgc2l6ZTogZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xyXG4gICAgICB2YXIgcCA9IHByb3BvcnRpb25hbFNpemUodGhpcywgd2lkdGgsIGhlaWdodClcclxuXHJcbiAgICAgIHJldHVybiB0aGlzLmF0dHIodGhpcy5hcnJheSgpLnNpemUocC53aWR0aCwgcC5oZWlnaHQpLnRvTGluZSgpKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gQWRkIHBhcmVudCBtZXRob2RcclxuLCBjb25zdHJ1Y3Q6IHtcclxuICAgIC8vIENyZWF0ZSBhIGxpbmUgZWxlbWVudFxyXG4gICAgbGluZTogZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIpIHtcclxuICAgICAgLy8gbWFrZSBzdXJlIHBsb3QgaXMgY2FsbGVkIGFzIGEgc2V0dGVyXHJcbiAgICAgIC8vIHgxIGlzIG5vdCBuZWNlc3NhcmlseSBhIG51bWJlciwgaXQgY2FuIGFsc28gYmUgYW4gYXJyYXksIGEgc3RyaW5nIGFuZCBhIFNWRy5Qb2ludEFycmF5XHJcbiAgICAgIHJldHVybiBTVkcuTGluZS5wcm90b3R5cGUucGxvdC5hcHBseShcclxuICAgICAgICB0aGlzLnB1dChuZXcgU1ZHLkxpbmUpXHJcbiAgICAgICwgeDEgIT0gbnVsbCA/IFt4MSwgeTEsIHgyLCB5Ml0gOiBbMCwgMCwgMCwgMF1cclxuICAgICAgKVxyXG4gICAgfVxyXG4gIH1cclxufSlcclxuXG5TVkcuUG9seWxpbmUgPSBTVkcuaW52ZW50KHtcclxuICAvLyBJbml0aWFsaXplIG5vZGVcclxuICBjcmVhdGU6ICdwb2x5bGluZSdcclxuXHJcbiAgLy8gSW5oZXJpdCBmcm9tXHJcbiwgaW5oZXJpdDogU1ZHLlNoYXBlXHJcblxyXG4gIC8vIEFkZCBwYXJlbnQgbWV0aG9kXHJcbiwgY29uc3RydWN0OiB7XHJcbiAgICAvLyBDcmVhdGUgYSB3cmFwcGVkIHBvbHlsaW5lIGVsZW1lbnRcclxuICAgIHBvbHlsaW5lOiBmdW5jdGlvbihwKSB7XHJcbiAgICAgIC8vIG1ha2Ugc3VyZSBwbG90IGlzIGNhbGxlZCBhcyBhIHNldHRlclxyXG4gICAgICByZXR1cm4gdGhpcy5wdXQobmV3IFNWRy5Qb2x5bGluZSkucGxvdChwIHx8IG5ldyBTVkcuUG9pbnRBcnJheSlcclxuICAgIH1cclxuICB9XHJcbn0pXHJcblxyXG5TVkcuUG9seWdvbiA9IFNWRy5pbnZlbnQoe1xyXG4gIC8vIEluaXRpYWxpemUgbm9kZVxyXG4gIGNyZWF0ZTogJ3BvbHlnb24nXHJcblxyXG4gIC8vIEluaGVyaXQgZnJvbVxyXG4sIGluaGVyaXQ6IFNWRy5TaGFwZVxyXG5cclxuICAvLyBBZGQgcGFyZW50IG1ldGhvZFxyXG4sIGNvbnN0cnVjdDoge1xyXG4gICAgLy8gQ3JlYXRlIGEgd3JhcHBlZCBwb2x5Z29uIGVsZW1lbnRcclxuICAgIHBvbHlnb246IGZ1bmN0aW9uKHApIHtcclxuICAgICAgLy8gbWFrZSBzdXJlIHBsb3QgaXMgY2FsbGVkIGFzIGEgc2V0dGVyXHJcbiAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLlBvbHlnb24pLnBsb3QocCB8fCBuZXcgU1ZHLlBvaW50QXJyYXkpXHJcbiAgICB9XHJcbiAgfVxyXG59KVxyXG5cclxuLy8gQWRkIHBvbHlnb24tc3BlY2lmaWMgZnVuY3Rpb25zXHJcblNWRy5leHRlbmQoU1ZHLlBvbHlsaW5lLCBTVkcuUG9seWdvbiwge1xyXG4gIC8vIEdldCBhcnJheVxyXG4gIGFycmF5OiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLl9hcnJheSB8fCAodGhpcy5fYXJyYXkgPSBuZXcgU1ZHLlBvaW50QXJyYXkodGhpcy5hdHRyKCdwb2ludHMnKSkpXHJcbiAgfVxyXG4gIC8vIFBsb3QgbmV3IHBhdGhcclxuLCBwbG90OiBmdW5jdGlvbihwKSB7XHJcbiAgICByZXR1cm4gKHAgPT0gbnVsbCkgP1xyXG4gICAgICB0aGlzLmFycmF5KCkgOlxyXG4gICAgICB0aGlzLmNsZWFyKCkuYXR0cigncG9pbnRzJywgdHlwZW9mIHAgPT0gJ3N0cmluZycgPyBwIDogKHRoaXMuX2FycmF5ID0gbmV3IFNWRy5Qb2ludEFycmF5KHApKSlcclxuICB9XHJcbiAgLy8gQ2xlYXIgYXJyYXkgY2FjaGVcclxuLCBjbGVhcjogZnVuY3Rpb24oKSB7XHJcbiAgICBkZWxldGUgdGhpcy5fYXJyYXlcclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG4gIC8vIE1vdmUgYnkgbGVmdCB0b3AgY29ybmVyXHJcbiwgbW92ZTogZnVuY3Rpb24oeCwgeSkge1xyXG4gICAgcmV0dXJuIHRoaXMuYXR0cigncG9pbnRzJywgdGhpcy5hcnJheSgpLm1vdmUoeCwgeSkpXHJcbiAgfVxyXG4gIC8vIFNldCBlbGVtZW50IHNpemUgdG8gZ2l2ZW4gd2lkdGggYW5kIGhlaWdodFxyXG4sIHNpemU6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgIHZhciBwID0gcHJvcG9ydGlvbmFsU2l6ZSh0aGlzLCB3aWR0aCwgaGVpZ2h0KVxyXG5cclxuICAgIHJldHVybiB0aGlzLmF0dHIoJ3BvaW50cycsIHRoaXMuYXJyYXkoKS5zaXplKHAud2lkdGgsIHAuaGVpZ2h0KSlcclxuICB9XHJcblxyXG59KVxyXG5cbi8vIHVuaWZ5IGFsbCBwb2ludCB0byBwb2ludCBlbGVtZW50c1xyXG5TVkcuZXh0ZW5kKFNWRy5MaW5lLCBTVkcuUG9seWxpbmUsIFNWRy5Qb2x5Z29uLCB7XHJcbiAgLy8gRGVmaW5lIG1vcnBoYWJsZSBhcnJheVxyXG4gIG1vcnBoQXJyYXk6ICBTVkcuUG9pbnRBcnJheVxyXG4gIC8vIE1vdmUgYnkgbGVmdCB0b3AgY29ybmVyIG92ZXIgeC1heGlzXHJcbiwgeDogZnVuY3Rpb24oeCkge1xyXG4gICAgcmV0dXJuIHggPT0gbnVsbCA/IHRoaXMuYmJveCgpLnggOiB0aGlzLm1vdmUoeCwgdGhpcy5iYm94KCkueSlcclxuICB9XHJcbiAgLy8gTW92ZSBieSBsZWZ0IHRvcCBjb3JuZXIgb3ZlciB5LWF4aXNcclxuLCB5OiBmdW5jdGlvbih5KSB7XHJcbiAgICByZXR1cm4geSA9PSBudWxsID8gdGhpcy5iYm94KCkueSA6IHRoaXMubW92ZSh0aGlzLmJib3goKS54LCB5KVxyXG4gIH1cclxuICAvLyBTZXQgd2lkdGggb2YgZWxlbWVudFxyXG4sIHdpZHRoOiBmdW5jdGlvbih3aWR0aCkge1xyXG4gICAgdmFyIGIgPSB0aGlzLmJib3goKVxyXG5cclxuICAgIHJldHVybiB3aWR0aCA9PSBudWxsID8gYi53aWR0aCA6IHRoaXMuc2l6ZSh3aWR0aCwgYi5oZWlnaHQpXHJcbiAgfVxyXG4gIC8vIFNldCBoZWlnaHQgb2YgZWxlbWVudFxyXG4sIGhlaWdodDogZnVuY3Rpb24oaGVpZ2h0KSB7XHJcbiAgICB2YXIgYiA9IHRoaXMuYmJveCgpXHJcblxyXG4gICAgcmV0dXJuIGhlaWdodCA9PSBudWxsID8gYi5oZWlnaHQgOiB0aGlzLnNpemUoYi53aWR0aCwgaGVpZ2h0KVxyXG4gIH1cclxufSlcblNWRy5QYXRoID0gU1ZHLmludmVudCh7XHJcbiAgLy8gSW5pdGlhbGl6ZSBub2RlXHJcbiAgY3JlYXRlOiAncGF0aCdcclxuXHJcbiAgLy8gSW5oZXJpdCBmcm9tXHJcbiwgaW5oZXJpdDogU1ZHLlNoYXBlXHJcblxyXG4gIC8vIEFkZCBjbGFzcyBtZXRob2RzXHJcbiwgZXh0ZW5kOiB7XHJcbiAgICAvLyBEZWZpbmUgbW9ycGhhYmxlIGFycmF5XHJcbiAgICBtb3JwaEFycmF5OiAgU1ZHLlBhdGhBcnJheVxyXG4gICAgLy8gR2V0IGFycmF5XHJcbiAgLCBhcnJheTogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9hcnJheSB8fCAodGhpcy5fYXJyYXkgPSBuZXcgU1ZHLlBhdGhBcnJheSh0aGlzLmF0dHIoJ2QnKSkpXHJcbiAgICB9XHJcbiAgICAvLyBQbG90IG5ldyBwYXRoXHJcbiAgLCBwbG90OiBmdW5jdGlvbihkKSB7XHJcbiAgICAgIHJldHVybiAoZCA9PSBudWxsKSA/XHJcbiAgICAgICAgdGhpcy5hcnJheSgpIDpcclxuICAgICAgICB0aGlzLmNsZWFyKCkuYXR0cignZCcsIHR5cGVvZiBkID09ICdzdHJpbmcnID8gZCA6ICh0aGlzLl9hcnJheSA9IG5ldyBTVkcuUGF0aEFycmF5KGQpKSlcclxuICAgIH1cclxuICAgIC8vIENsZWFyIGFycmF5IGNhY2hlXHJcbiAgLCBjbGVhcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgIGRlbGV0ZSB0aGlzLl9hcnJheVxyXG4gICAgICByZXR1cm4gdGhpc1xyXG4gICAgfVxyXG4gICAgLy8gTW92ZSBieSBsZWZ0IHRvcCBjb3JuZXJcclxuICAsIG1vdmU6IGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuYXR0cignZCcsIHRoaXMuYXJyYXkoKS5tb3ZlKHgsIHkpKVxyXG4gICAgfVxyXG4gICAgLy8gTW92ZSBieSBsZWZ0IHRvcCBjb3JuZXIgb3ZlciB4LWF4aXNcclxuICAsIHg6IGZ1bmN0aW9uKHgpIHtcclxuICAgICAgcmV0dXJuIHggPT0gbnVsbCA/IHRoaXMuYmJveCgpLnggOiB0aGlzLm1vdmUoeCwgdGhpcy5iYm94KCkueSlcclxuICAgIH1cclxuICAgIC8vIE1vdmUgYnkgbGVmdCB0b3AgY29ybmVyIG92ZXIgeS1heGlzXHJcbiAgLCB5OiBmdW5jdGlvbih5KSB7XHJcbiAgICAgIHJldHVybiB5ID09IG51bGwgPyB0aGlzLmJib3goKS55IDogdGhpcy5tb3ZlKHRoaXMuYmJveCgpLngsIHkpXHJcbiAgICB9XHJcbiAgICAvLyBTZXQgZWxlbWVudCBzaXplIHRvIGdpdmVuIHdpZHRoIGFuZCBoZWlnaHRcclxuICAsIHNpemU6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgdmFyIHAgPSBwcm9wb3J0aW9uYWxTaXplKHRoaXMsIHdpZHRoLCBoZWlnaHQpXHJcblxyXG4gICAgICByZXR1cm4gdGhpcy5hdHRyKCdkJywgdGhpcy5hcnJheSgpLnNpemUocC53aWR0aCwgcC5oZWlnaHQpKVxyXG4gICAgfVxyXG4gICAgLy8gU2V0IHdpZHRoIG9mIGVsZW1lbnRcclxuICAsIHdpZHRoOiBmdW5jdGlvbih3aWR0aCkge1xyXG4gICAgICByZXR1cm4gd2lkdGggPT0gbnVsbCA/IHRoaXMuYmJveCgpLndpZHRoIDogdGhpcy5zaXplKHdpZHRoLCB0aGlzLmJib3goKS5oZWlnaHQpXHJcbiAgICB9XHJcbiAgICAvLyBTZXQgaGVpZ2h0IG9mIGVsZW1lbnRcclxuICAsIGhlaWdodDogZnVuY3Rpb24oaGVpZ2h0KSB7XHJcbiAgICAgIHJldHVybiBoZWlnaHQgPT0gbnVsbCA/IHRoaXMuYmJveCgpLmhlaWdodCA6IHRoaXMuc2l6ZSh0aGlzLmJib3goKS53aWR0aCwgaGVpZ2h0KVxyXG4gICAgfVxyXG5cclxuICB9XHJcblxyXG4gIC8vIEFkZCBwYXJlbnQgbWV0aG9kXHJcbiwgY29uc3RydWN0OiB7XHJcbiAgICAvLyBDcmVhdGUgYSB3cmFwcGVkIHBhdGggZWxlbWVudFxyXG4gICAgcGF0aDogZnVuY3Rpb24oZCkge1xyXG4gICAgICAvLyBtYWtlIHN1cmUgcGxvdCBpcyBjYWxsZWQgYXMgYSBzZXR0ZXJcclxuICAgICAgcmV0dXJuIHRoaXMucHV0KG5ldyBTVkcuUGF0aCkucGxvdChkIHx8IG5ldyBTVkcuUGF0aEFycmF5KVxyXG4gICAgfVxyXG4gIH1cclxufSlcclxuXG5TVkcuSW1hZ2UgPSBTVkcuaW52ZW50KHtcclxuICAvLyBJbml0aWFsaXplIG5vZGVcclxuICBjcmVhdGU6ICdpbWFnZSdcclxuXHJcbiAgLy8gSW5oZXJpdCBmcm9tXHJcbiwgaW5oZXJpdDogU1ZHLlNoYXBlXHJcblxyXG4gIC8vIEFkZCBjbGFzcyBtZXRob2RzXHJcbiwgZXh0ZW5kOiB7XHJcbiAgICAvLyAocmUpbG9hZCBpbWFnZVxyXG4gICAgbG9hZDogZnVuY3Rpb24odXJsKSB7XHJcbiAgICAgIGlmICghdXJsKSByZXR1cm4gdGhpc1xyXG5cclxuICAgICAgdmFyIHNlbGYgPSB0aGlzXHJcbiAgICAgICAgLCBpbWcgID0gbmV3IHdpbmRvdy5JbWFnZSgpXHJcblxyXG4gICAgICAvLyBwcmVsb2FkIGltYWdlXHJcbiAgICAgIFNWRy5vbihpbWcsICdsb2FkJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHAgPSBzZWxmLnBhcmVudChTVkcuUGF0dGVybilcclxuXHJcbiAgICAgICAgaWYocCA9PT0gbnVsbCkgcmV0dXJuXHJcblxyXG4gICAgICAgIC8vIGVuc3VyZSBpbWFnZSBzaXplXHJcbiAgICAgICAgaWYgKHNlbGYud2lkdGgoKSA9PSAwICYmIHNlbGYuaGVpZ2h0KCkgPT0gMClcclxuICAgICAgICAgIHNlbGYuc2l6ZShpbWcud2lkdGgsIGltZy5oZWlnaHQpXHJcblxyXG4gICAgICAgIC8vIGVuc3VyZSBwYXR0ZXJuIHNpemUgaWYgbm90IHNldFxyXG4gICAgICAgIGlmIChwICYmIHAud2lkdGgoKSA9PSAwICYmIHAuaGVpZ2h0KCkgPT0gMClcclxuICAgICAgICAgIHAuc2l6ZShzZWxmLndpZHRoKCksIHNlbGYuaGVpZ2h0KCkpXHJcblxyXG4gICAgICAgIC8vIGNhbGxiYWNrXHJcbiAgICAgICAgaWYgKHR5cGVvZiBzZWxmLl9sb2FkZWQgPT09ICdmdW5jdGlvbicpXHJcbiAgICAgICAgICBzZWxmLl9sb2FkZWQuY2FsbChzZWxmLCB7XHJcbiAgICAgICAgICAgIHdpZHRoOiAgaW1nLndpZHRoXHJcbiAgICAgICAgICAsIGhlaWdodDogaW1nLmhlaWdodFxyXG4gICAgICAgICAgLCByYXRpbzogIGltZy53aWR0aCAvIGltZy5oZWlnaHRcclxuICAgICAgICAgICwgdXJsOiAgICB1cmxcclxuICAgICAgICAgIH0pXHJcbiAgICAgIH0pXHJcblxyXG4gICAgICBTVkcub24oaW1nLCAnZXJyb3InLCBmdW5jdGlvbihlKXtcclxuICAgICAgICBpZiAodHlwZW9mIHNlbGYuX2Vycm9yID09PSAnZnVuY3Rpb24nKXtcclxuICAgICAgICAgICAgc2VsZi5fZXJyb3IuY2FsbChzZWxmLCBlKVxyXG4gICAgICAgIH1cclxuICAgICAgfSlcclxuXHJcbiAgICAgIHJldHVybiB0aGlzLmF0dHIoJ2hyZWYnLCAoaW1nLnNyYyA9IHRoaXMuc3JjID0gdXJsKSwgU1ZHLnhsaW5rKVxyXG4gICAgfVxyXG4gICAgLy8gQWRkIGxvYWRlZCBjYWxsYmFja1xyXG4gICwgbG9hZGVkOiBmdW5jdGlvbihsb2FkZWQpIHtcclxuICAgICAgdGhpcy5fbG9hZGVkID0gbG9hZGVkXHJcbiAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcblxyXG4gICwgZXJyb3I6IGZ1bmN0aW9uKGVycm9yKSB7XHJcbiAgICAgIHRoaXMuX2Vycm9yID0gZXJyb3JcclxuICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEFkZCBwYXJlbnQgbWV0aG9kXHJcbiwgY29uc3RydWN0OiB7XHJcbiAgICAvLyBjcmVhdGUgaW1hZ2UgZWxlbWVudCwgbG9hZCBpbWFnZSBhbmQgc2V0IGl0cyBzaXplXHJcbiAgICBpbWFnZTogZnVuY3Rpb24oc291cmNlLCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLkltYWdlKS5sb2FkKHNvdXJjZSkuc2l6ZSh3aWR0aCB8fCAwLCBoZWlnaHQgfHwgd2lkdGggfHwgMClcclxuICAgIH1cclxuICB9XHJcblxyXG59KVxuU1ZHLlRleHQgPSBTVkcuaW52ZW50KHtcclxuICAvLyBJbml0aWFsaXplIG5vZGVcclxuICBjcmVhdGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIFNWRy5jcmVhdGUoJ3RleHQnKSlcclxuXHJcbiAgICB0aGlzLmRvbS5sZWFkaW5nID0gbmV3IFNWRy5OdW1iZXIoMS4zKSAgICAvLyBzdG9yZSBsZWFkaW5nIHZhbHVlIGZvciByZWJ1aWxkaW5nXHJcbiAgICB0aGlzLl9yZWJ1aWxkID0gdHJ1ZSAgICAgICAgICAgICAgICAgICAgICAvLyBlbmFibGUgYXV0b21hdGljIHVwZGF0aW5nIG9mIGR5IHZhbHVlc1xyXG4gICAgdGhpcy5fYnVpbGQgICA9IGZhbHNlICAgICAgICAgICAgICAgICAgICAgLy8gZGlzYWJsZSBidWlsZCBtb2RlIGZvciBhZGRpbmcgbXVsdGlwbGUgbGluZXNcclxuXHJcbiAgICAvLyBzZXQgZGVmYXVsdCBmb250XHJcbiAgICB0aGlzLmF0dHIoJ2ZvbnQtZmFtaWx5JywgU1ZHLmRlZmF1bHRzLmF0dHJzWydmb250LWZhbWlseSddKVxyXG4gIH1cclxuXHJcbiAgLy8gSW5oZXJpdCBmcm9tXHJcbiwgaW5oZXJpdDogU1ZHLlNoYXBlXHJcblxyXG4gIC8vIEFkZCBjbGFzcyBtZXRob2RzXHJcbiwgZXh0ZW5kOiB7XHJcbiAgICAvLyBNb3ZlIG92ZXIgeC1heGlzXHJcbiAgICB4OiBmdW5jdGlvbih4KSB7XHJcbiAgICAgIC8vIGFjdCBhcyBnZXR0ZXJcclxuICAgICAgaWYgKHggPT0gbnVsbClcclxuICAgICAgICByZXR1cm4gdGhpcy5hdHRyKCd4JylcclxuXHJcbiAgICAgIHJldHVybiB0aGlzLmF0dHIoJ3gnLCB4KVxyXG4gICAgfVxyXG4gICAgLy8gTW92ZSBvdmVyIHktYXhpc1xyXG4gICwgeTogZnVuY3Rpb24oeSkge1xyXG4gICAgICB2YXIgb3kgPSB0aGlzLmF0dHIoJ3knKVxyXG4gICAgICAgICwgbyAgPSB0eXBlb2Ygb3kgPT09ICdudW1iZXInID8gb3kgLSB0aGlzLmJib3goKS55IDogMFxyXG5cclxuICAgICAgLy8gYWN0IGFzIGdldHRlclxyXG4gICAgICBpZiAoeSA9PSBudWxsKVxyXG4gICAgICAgIHJldHVybiB0eXBlb2Ygb3kgPT09ICdudW1iZXInID8gb3kgLSBvIDogb3lcclxuXHJcbiAgICAgIHJldHVybiB0aGlzLmF0dHIoJ3knLCB0eXBlb2YgeSA9PT0gJ251bWJlcicgPyB5ICsgbyA6IHkpXHJcbiAgICB9XHJcbiAgICAvLyBNb3ZlIGNlbnRlciBvdmVyIHgtYXhpc1xyXG4gICwgY3g6IGZ1bmN0aW9uKHgpIHtcclxuICAgICAgcmV0dXJuIHggPT0gbnVsbCA/IHRoaXMuYmJveCgpLmN4IDogdGhpcy54KHggLSB0aGlzLmJib3goKS53aWR0aCAvIDIpXHJcbiAgICB9XHJcbiAgICAvLyBNb3ZlIGNlbnRlciBvdmVyIHktYXhpc1xyXG4gICwgY3k6IGZ1bmN0aW9uKHkpIHtcclxuICAgICAgcmV0dXJuIHkgPT0gbnVsbCA/IHRoaXMuYmJveCgpLmN5IDogdGhpcy55KHkgLSB0aGlzLmJib3goKS5oZWlnaHQgLyAyKVxyXG4gICAgfVxyXG4gICAgLy8gU2V0IHRoZSB0ZXh0IGNvbnRlbnRcclxuICAsIHRleHQ6IGZ1bmN0aW9uKHRleHQpIHtcclxuICAgICAgLy8gYWN0IGFzIGdldHRlclxyXG4gICAgICBpZiAodHlwZW9mIHRleHQgPT09ICd1bmRlZmluZWQnKXtcclxuICAgICAgICB2YXIgdGV4dCA9ICcnXHJcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5ub2RlLmNoaWxkTm9kZXNcclxuICAgICAgICBmb3IodmFyIGkgPSAwLCBsZW4gPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47ICsraSl7XHJcblxyXG4gICAgICAgICAgLy8gYWRkIG5ld2xpbmUgaWYgaXRzIG5vdCB0aGUgZmlyc3QgY2hpbGQgYW5kIG5ld0xpbmVkIGlzIHNldCB0byB0cnVlXHJcbiAgICAgICAgICBpZihpICE9IDAgJiYgY2hpbGRyZW5baV0ubm9kZVR5cGUgIT0gMyAmJiBTVkcuYWRvcHQoY2hpbGRyZW5baV0pLmRvbS5uZXdMaW5lZCA9PSB0cnVlKXtcclxuICAgICAgICAgICAgdGV4dCArPSAnXFxuJ1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIGFkZCBjb250ZW50IG9mIHRoaXMgbm9kZVxyXG4gICAgICAgICAgdGV4dCArPSBjaGlsZHJlbltpXS50ZXh0Q29udGVudFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRleHRcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gcmVtb3ZlIGV4aXN0aW5nIGNvbnRlbnRcclxuICAgICAgdGhpcy5jbGVhcigpLmJ1aWxkKHRydWUpXHJcblxyXG4gICAgICBpZiAodHlwZW9mIHRleHQgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAvLyBjYWxsIGJsb2NrXHJcbiAgICAgICAgdGV4dC5jYWxsKHRoaXMsIHRoaXMpXHJcblxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIHN0b3JlIHRleHQgYW5kIG1ha2Ugc3VyZSB0ZXh0IGlzIG5vdCBibGFua1xyXG4gICAgICAgIHRleHQgPSB0ZXh0LnNwbGl0KCdcXG4nKVxyXG5cclxuICAgICAgICAvLyBidWlsZCBuZXcgbGluZXNcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWwgPSB0ZXh0Lmxlbmd0aDsgaSA8IGlsOyBpKyspXHJcbiAgICAgICAgICB0aGlzLnRzcGFuKHRleHRbaV0pLm5ld0xpbmUoKVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBkaXNhYmxlIGJ1aWxkIG1vZGUgYW5kIHJlYnVpbGQgbGluZXNcclxuICAgICAgcmV0dXJuIHRoaXMuYnVpbGQoZmFsc2UpLnJlYnVpbGQoKVxyXG4gICAgfVxyXG4gICAgLy8gU2V0IGZvbnQgc2l6ZVxyXG4gICwgc2l6ZTogZnVuY3Rpb24oc2l6ZSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5hdHRyKCdmb250LXNpemUnLCBzaXplKS5yZWJ1aWxkKClcclxuICAgIH1cclxuICAgIC8vIFNldCAvIGdldCBsZWFkaW5nXHJcbiAgLCBsZWFkaW5nOiBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICAvLyBhY3QgYXMgZ2V0dGVyXHJcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKVxyXG4gICAgICAgIHJldHVybiB0aGlzLmRvbS5sZWFkaW5nXHJcblxyXG4gICAgICAvLyBhY3QgYXMgc2V0dGVyXHJcbiAgICAgIHRoaXMuZG9tLmxlYWRpbmcgPSBuZXcgU1ZHLk51bWJlcih2YWx1ZSlcclxuXHJcbiAgICAgIHJldHVybiB0aGlzLnJlYnVpbGQoKVxyXG4gICAgfVxyXG4gICAgLy8gR2V0IGFsbCB0aGUgZmlyc3QgbGV2ZWwgbGluZXNcclxuICAsIGxpbmVzOiBmdW5jdGlvbigpIHtcclxuICAgICAgdmFyIG5vZGUgPSAodGhpcy50ZXh0UGF0aCAmJiB0aGlzLnRleHRQYXRoKCkgfHwgdGhpcykubm9kZVxyXG5cclxuICAgICAgLy8gZmlsdGVyIHRzcGFucyBhbmQgbWFwIHRoZW0gdG8gU1ZHLmpzIGluc3RhbmNlc1xyXG4gICAgICB2YXIgbGluZXMgPSBTVkcudXRpbHMubWFwKFNWRy51dGlscy5maWx0ZXJTVkdFbGVtZW50cyhub2RlLmNoaWxkTm9kZXMpLCBmdW5jdGlvbihlbCl7XHJcbiAgICAgICAgcmV0dXJuIFNWRy5hZG9wdChlbClcclxuICAgICAgfSlcclxuXHJcbiAgICAgIC8vIHJldHVybiBhbiBpbnN0YW5jZSBvZiBTVkcuc2V0XHJcbiAgICAgIHJldHVybiBuZXcgU1ZHLlNldChsaW5lcylcclxuICAgIH1cclxuICAgIC8vIFJlYnVpbGQgYXBwZWFyYW5jZSB0eXBlXHJcbiAgLCByZWJ1aWxkOiBmdW5jdGlvbihyZWJ1aWxkKSB7XHJcbiAgICAgIC8vIHN0b3JlIG5ldyByZWJ1aWxkIGZsYWcgaWYgZ2l2ZW5cclxuICAgICAgaWYgKHR5cGVvZiByZWJ1aWxkID09ICdib29sZWFuJylcclxuICAgICAgICB0aGlzLl9yZWJ1aWxkID0gcmVidWlsZFxyXG5cclxuICAgICAgLy8gZGVmaW5lIHBvc2l0aW9uIG9mIGFsbCBsaW5lc1xyXG4gICAgICBpZiAodGhpcy5fcmVidWlsZCkge1xyXG4gICAgICAgIHZhciBzZWxmID0gdGhpc1xyXG4gICAgICAgICAgLCBibGFua0xpbmVPZmZzZXQgPSAwXHJcbiAgICAgICAgICAsIGR5ID0gdGhpcy5kb20ubGVhZGluZyAqIG5ldyBTVkcuTnVtYmVyKHRoaXMuYXR0cignZm9udC1zaXplJykpXHJcblxyXG4gICAgICAgIHRoaXMubGluZXMoKS5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgaWYgKHRoaXMuZG9tLm5ld0xpbmVkKSB7XHJcbiAgICAgICAgICAgIGlmICghc2VsZi50ZXh0UGF0aCgpKVxyXG4gICAgICAgICAgICAgIHRoaXMuYXR0cigneCcsIHNlbGYuYXR0cigneCcpKVxyXG4gICAgICAgICAgICBpZih0aGlzLnRleHQoKSA9PSAnXFxuJykge1xyXG4gICAgICAgICAgICAgIGJsYW5rTGluZU9mZnNldCArPSBkeVxyXG4gICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICB0aGlzLmF0dHIoJ2R5JywgZHkgKyBibGFua0xpbmVPZmZzZXQpXHJcbiAgICAgICAgICAgICAgYmxhbmtMaW5lT2Zmc2V0ID0gMFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgdGhpcy5maXJlKCdyZWJ1aWxkJylcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuICAgIC8vIEVuYWJsZSAvIGRpc2FibGUgYnVpbGQgbW9kZVxyXG4gICwgYnVpbGQ6IGZ1bmN0aW9uKGJ1aWxkKSB7XHJcbiAgICAgIHRoaXMuX2J1aWxkID0gISFidWlsZFxyXG4gICAgICByZXR1cm4gdGhpc1xyXG4gICAgfVxyXG4gICAgLy8gb3ZlcndyaXRlIG1ldGhvZCBmcm9tIHBhcmVudCB0byBzZXQgZGF0YSBwcm9wZXJseVxyXG4gICwgc2V0RGF0YTogZnVuY3Rpb24obyl7XHJcbiAgICAgIHRoaXMuZG9tID0gb1xyXG4gICAgICB0aGlzLmRvbS5sZWFkaW5nID0gbmV3IFNWRy5OdW1iZXIoby5sZWFkaW5nIHx8IDEuMylcclxuICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEFkZCBwYXJlbnQgbWV0aG9kXHJcbiwgY29uc3RydWN0OiB7XHJcbiAgICAvLyBDcmVhdGUgdGV4dCBlbGVtZW50XHJcbiAgICB0ZXh0OiBmdW5jdGlvbih0ZXh0KSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLlRleHQpLnRleHQodGV4dClcclxuICAgIH1cclxuICAgIC8vIENyZWF0ZSBwbGFpbiB0ZXh0IGVsZW1lbnRcclxuICAsIHBsYWluOiBmdW5jdGlvbih0ZXh0KSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLlRleHQpLnBsYWluKHRleHQpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxufSlcclxuXHJcblNWRy5Uc3BhbiA9IFNWRy5pbnZlbnQoe1xyXG4gIC8vIEluaXRpYWxpemUgbm9kZVxyXG4gIGNyZWF0ZTogJ3RzcGFuJ1xyXG5cclxuICAvLyBJbmhlcml0IGZyb21cclxuLCBpbmhlcml0OiBTVkcuU2hhcGVcclxuXHJcbiAgLy8gQWRkIGNsYXNzIG1ldGhvZHNcclxuLCBleHRlbmQ6IHtcclxuICAgIC8vIFNldCB0ZXh0IGNvbnRlbnRcclxuICAgIHRleHQ6IGZ1bmN0aW9uKHRleHQpIHtcclxuICAgICAgaWYodGV4dCA9PSBudWxsKSByZXR1cm4gdGhpcy5ub2RlLnRleHRDb250ZW50ICsgKHRoaXMuZG9tLm5ld0xpbmVkID8gJ1xcbicgOiAnJylcclxuXHJcbiAgICAgIHR5cGVvZiB0ZXh0ID09PSAnZnVuY3Rpb24nID8gdGV4dC5jYWxsKHRoaXMsIHRoaXMpIDogdGhpcy5wbGFpbih0ZXh0KVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuICAgIC8vIFNob3J0Y3V0IGR4XHJcbiAgLCBkeDogZnVuY3Rpb24oZHgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuYXR0cignZHgnLCBkeClcclxuICAgIH1cclxuICAgIC8vIFNob3J0Y3V0IGR5XHJcbiAgLCBkeTogZnVuY3Rpb24oZHkpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuYXR0cignZHknLCBkeSlcclxuICAgIH1cclxuICAgIC8vIENyZWF0ZSBuZXcgbGluZVxyXG4gICwgbmV3TGluZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgIC8vIGZldGNoIHRleHQgcGFyZW50XHJcbiAgICAgIHZhciB0ID0gdGhpcy5wYXJlbnQoU1ZHLlRleHQpXHJcblxyXG4gICAgICAvLyBtYXJrIG5ldyBsaW5lXHJcbiAgICAgIHRoaXMuZG9tLm5ld0xpbmVkID0gdHJ1ZVxyXG5cclxuICAgICAgLy8gYXBwbHkgbmV3IGh5wqFuXHJcbiAgICAgIHJldHVybiB0aGlzLmR5KHQuZG9tLmxlYWRpbmcgKiB0LmF0dHIoJ2ZvbnQtc2l6ZScpKS5hdHRyKCd4JywgdC54KCkpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxufSlcclxuXHJcblNWRy5leHRlbmQoU1ZHLlRleHQsIFNWRy5Uc3Bhbiwge1xyXG4gIC8vIENyZWF0ZSBwbGFpbiB0ZXh0IG5vZGVcclxuICBwbGFpbjogZnVuY3Rpb24odGV4dCkge1xyXG4gICAgLy8gY2xlYXIgaWYgYnVpbGQgbW9kZSBpcyBkaXNhYmxlZFxyXG4gICAgaWYgKHRoaXMuX2J1aWxkID09PSBmYWxzZSlcclxuICAgICAgdGhpcy5jbGVhcigpXHJcblxyXG4gICAgLy8gY3JlYXRlIHRleHQgbm9kZVxyXG4gICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpKVxyXG5cclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG4gIC8vIENyZWF0ZSBhIHRzcGFuXHJcbiwgdHNwYW46IGZ1bmN0aW9uKHRleHQpIHtcclxuICAgIHZhciBub2RlICA9ICh0aGlzLnRleHRQYXRoICYmIHRoaXMudGV4dFBhdGgoKSB8fCB0aGlzKS5ub2RlXHJcbiAgICAgICwgdHNwYW4gPSBuZXcgU1ZHLlRzcGFuXHJcblxyXG4gICAgLy8gY2xlYXIgaWYgYnVpbGQgbW9kZSBpcyBkaXNhYmxlZFxyXG4gICAgaWYgKHRoaXMuX2J1aWxkID09PSBmYWxzZSlcclxuICAgICAgdGhpcy5jbGVhcigpXHJcblxyXG4gICAgLy8gYWRkIG5ldyB0c3BhblxyXG4gICAgbm9kZS5hcHBlbmRDaGlsZCh0c3Bhbi5ub2RlKVxyXG5cclxuICAgIHJldHVybiB0c3Bhbi50ZXh0KHRleHQpXHJcbiAgfVxyXG4gIC8vIENsZWFyIGFsbCBsaW5lc1xyXG4sIGNsZWFyOiBmdW5jdGlvbigpIHtcclxuICAgIHZhciBub2RlID0gKHRoaXMudGV4dFBhdGggJiYgdGhpcy50ZXh0UGF0aCgpIHx8IHRoaXMpLm5vZGVcclxuXHJcbiAgICAvLyByZW1vdmUgZXhpc3RpbmcgY2hpbGQgbm9kZXNcclxuICAgIHdoaWxlIChub2RlLmhhc0NoaWxkTm9kZXMoKSlcclxuICAgICAgbm9kZS5yZW1vdmVDaGlsZChub2RlLmxhc3RDaGlsZClcclxuXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuICAvLyBHZXQgbGVuZ3RoIG9mIHRleHQgZWxlbWVudFxyXG4sIGxlbmd0aDogZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5ub2RlLmdldENvbXB1dGVkVGV4dExlbmd0aCgpXHJcbiAgfVxyXG59KVxyXG5cblNWRy5UZXh0UGF0aCA9IFNWRy5pbnZlbnQoe1xyXG4gIC8vIEluaXRpYWxpemUgbm9kZVxyXG4gIGNyZWF0ZTogJ3RleHRQYXRoJ1xyXG5cclxuICAvLyBJbmhlcml0IGZyb21cclxuLCBpbmhlcml0OiBTVkcuUGFyZW50XHJcblxyXG4gIC8vIERlZmluZSBwYXJlbnQgY2xhc3NcclxuLCBwYXJlbnQ6IFNWRy5UZXh0XHJcblxyXG4gIC8vIEFkZCBwYXJlbnQgbWV0aG9kXHJcbiwgY29uc3RydWN0OiB7XHJcbiAgICAvLyBDcmVhdGUgcGF0aCBmb3IgdGV4dCB0byBydW4gb25cclxuICAgIHBhdGg6IGZ1bmN0aW9uKGQpIHtcclxuICAgICAgLy8gY3JlYXRlIHRleHRQYXRoIGVsZW1lbnRcclxuICAgICAgdmFyIHBhdGggID0gbmV3IFNWRy5UZXh0UGF0aFxyXG4gICAgICAgICwgdHJhY2sgPSB0aGlzLmRvYygpLmRlZnMoKS5wYXRoKGQpXHJcblxyXG4gICAgICAvLyBtb3ZlIGxpbmVzIHRvIHRleHRwYXRoXHJcbiAgICAgIHdoaWxlICh0aGlzLm5vZGUuaGFzQ2hpbGROb2RlcygpKVxyXG4gICAgICAgIHBhdGgubm9kZS5hcHBlbmRDaGlsZCh0aGlzLm5vZGUuZmlyc3RDaGlsZClcclxuXHJcbiAgICAgIC8vIGFkZCB0ZXh0UGF0aCBlbGVtZW50IGFzIGNoaWxkIG5vZGVcclxuICAgICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKHBhdGgubm9kZSlcclxuXHJcbiAgICAgIC8vIGxpbmsgdGV4dFBhdGggdG8gcGF0aCBhbmQgYWRkIGNvbnRlbnRcclxuICAgICAgcGF0aC5hdHRyKCdocmVmJywgJyMnICsgdHJhY2ssIFNWRy54bGluaylcclxuXHJcbiAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcbiAgICAvLyByZXR1cm4gdGhlIGFycmF5IG9mIHRoZSBwYXRoIHRyYWNrIGVsZW1lbnRcclxuICAsIGFycmF5OiBmdW5jdGlvbigpIHtcclxuICAgICAgdmFyIHRyYWNrID0gdGhpcy50cmFjaygpXHJcblxyXG4gICAgICByZXR1cm4gdHJhY2sgPyB0cmFjay5hcnJheSgpIDogbnVsbFxyXG4gICAgfVxyXG4gICAgLy8gUGxvdCBwYXRoIGlmIGFueVxyXG4gICwgcGxvdDogZnVuY3Rpb24oZCkge1xyXG4gICAgICB2YXIgdHJhY2sgPSB0aGlzLnRyYWNrKClcclxuICAgICAgICAsIHBhdGhBcnJheSA9IG51bGxcclxuXHJcbiAgICAgIGlmICh0cmFjaykge1xyXG4gICAgICAgIHBhdGhBcnJheSA9IHRyYWNrLnBsb3QoZClcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIChkID09IG51bGwpID8gcGF0aEFycmF5IDogdGhpc1xyXG4gICAgfVxyXG4gICAgLy8gR2V0IHRoZSBwYXRoIHRyYWNrIGVsZW1lbnRcclxuICAsIHRyYWNrOiBmdW5jdGlvbigpIHtcclxuICAgICAgdmFyIHBhdGggPSB0aGlzLnRleHRQYXRoKClcclxuXHJcbiAgICAgIGlmIChwYXRoKVxyXG4gICAgICAgIHJldHVybiBwYXRoLnJlZmVyZW5jZSgnaHJlZicpXHJcbiAgICB9XHJcbiAgICAvLyBHZXQgdGhlIHRleHRQYXRoIGNoaWxkXHJcbiAgLCB0ZXh0UGF0aDogZnVuY3Rpb24oKSB7XHJcbiAgICAgIGlmICh0aGlzLm5vZGUuZmlyc3RDaGlsZCAmJiB0aGlzLm5vZGUuZmlyc3RDaGlsZC5ub2RlTmFtZSA9PSAndGV4dFBhdGgnKVxyXG4gICAgICAgIHJldHVybiBTVkcuYWRvcHQodGhpcy5ub2RlLmZpcnN0Q2hpbGQpXHJcbiAgICB9XHJcbiAgfVxyXG59KVxyXG5cblNWRy5OZXN0ZWQgPSBTVkcuaW52ZW50KHtcclxuICAvLyBJbml0aWFsaXplIG5vZGVcclxuICBjcmVhdGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIFNWRy5jcmVhdGUoJ3N2ZycpKVxyXG5cclxuICAgIHRoaXMuc3R5bGUoJ292ZXJmbG93JywgJ3Zpc2libGUnKVxyXG4gIH1cclxuXHJcbiAgLy8gSW5oZXJpdCBmcm9tXHJcbiwgaW5oZXJpdDogU1ZHLkNvbnRhaW5lclxyXG5cclxuICAvLyBBZGQgcGFyZW50IG1ldGhvZFxyXG4sIGNvbnN0cnVjdDoge1xyXG4gICAgLy8gQ3JlYXRlIG5lc3RlZCBzdmcgZG9jdW1lbnRcclxuICAgIG5lc3RlZDogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLk5lc3RlZClcclxuICAgIH1cclxuICB9XHJcbn0pXG5TVkcuQSA9IFNWRy5pbnZlbnQoe1xyXG4gIC8vIEluaXRpYWxpemUgbm9kZVxyXG4gIGNyZWF0ZTogJ2EnXHJcblxyXG4gIC8vIEluaGVyaXQgZnJvbVxyXG4sIGluaGVyaXQ6IFNWRy5Db250YWluZXJcclxuXHJcbiAgLy8gQWRkIGNsYXNzIG1ldGhvZHNcclxuLCBleHRlbmQ6IHtcclxuICAgIC8vIExpbmsgdXJsXHJcbiAgICB0bzogZnVuY3Rpb24odXJsKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmF0dHIoJ2hyZWYnLCB1cmwsIFNWRy54bGluaylcclxuICAgIH1cclxuICAgIC8vIExpbmsgc2hvdyBhdHRyaWJ1dGVcclxuICAsIHNob3c6IGZ1bmN0aW9uKHRhcmdldCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5hdHRyKCdzaG93JywgdGFyZ2V0LCBTVkcueGxpbmspXHJcbiAgICB9XHJcbiAgICAvLyBMaW5rIHRhcmdldCBhdHRyaWJ1dGVcclxuICAsIHRhcmdldDogZnVuY3Rpb24odGFyZ2V0KSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmF0dHIoJ3RhcmdldCcsIHRhcmdldClcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEFkZCBwYXJlbnQgbWV0aG9kXHJcbiwgY29uc3RydWN0OiB7XHJcbiAgICAvLyBDcmVhdGUgYSBoeXBlcmxpbmsgZWxlbWVudFxyXG4gICAgbGluazogZnVuY3Rpb24odXJsKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLkEpLnRvKHVybClcclxuICAgIH1cclxuICB9XHJcbn0pXHJcblxyXG5TVkcuZXh0ZW5kKFNWRy5FbGVtZW50LCB7XHJcbiAgLy8gQ3JlYXRlIGEgaHlwZXJsaW5rIGVsZW1lbnRcclxuICBsaW5rVG86IGZ1bmN0aW9uKHVybCkge1xyXG4gICAgdmFyIGxpbmsgPSBuZXcgU1ZHLkFcclxuXHJcbiAgICBpZiAodHlwZW9mIHVybCA9PSAnZnVuY3Rpb24nKVxyXG4gICAgICB1cmwuY2FsbChsaW5rLCBsaW5rKVxyXG4gICAgZWxzZVxyXG4gICAgICBsaW5rLnRvKHVybClcclxuXHJcbiAgICByZXR1cm4gdGhpcy5wYXJlbnQoKS5wdXQobGluaykucHV0KHRoaXMpXHJcbiAgfVxyXG5cclxufSlcblNWRy5NYXJrZXIgPSBTVkcuaW52ZW50KHtcclxuICAvLyBJbml0aWFsaXplIG5vZGVcclxuICBjcmVhdGU6ICdtYXJrZXInXHJcblxyXG4gIC8vIEluaGVyaXQgZnJvbVxyXG4sIGluaGVyaXQ6IFNWRy5Db250YWluZXJcclxuXHJcbiAgLy8gQWRkIGNsYXNzIG1ldGhvZHNcclxuLCBleHRlbmQ6IHtcclxuICAgIC8vIFNldCB3aWR0aCBvZiBlbGVtZW50XHJcbiAgICB3aWR0aDogZnVuY3Rpb24od2lkdGgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuYXR0cignbWFya2VyV2lkdGgnLCB3aWR0aClcclxuICAgIH1cclxuICAgIC8vIFNldCBoZWlnaHQgb2YgZWxlbWVudFxyXG4gICwgaGVpZ2h0OiBmdW5jdGlvbihoZWlnaHQpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuYXR0cignbWFya2VySGVpZ2h0JywgaGVpZ2h0KVxyXG4gICAgfVxyXG4gICAgLy8gU2V0IG1hcmtlciByZWZYIGFuZCByZWZZXHJcbiAgLCByZWY6IGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuYXR0cigncmVmWCcsIHgpLmF0dHIoJ3JlZlknLCB5KVxyXG4gICAgfVxyXG4gICAgLy8gVXBkYXRlIG1hcmtlclxyXG4gICwgdXBkYXRlOiBmdW5jdGlvbihibG9jaykge1xyXG4gICAgICAvLyByZW1vdmUgYWxsIGNvbnRlbnRcclxuICAgICAgdGhpcy5jbGVhcigpXHJcblxyXG4gICAgICAvLyBpbnZva2UgcGFzc2VkIGJsb2NrXHJcbiAgICAgIGlmICh0eXBlb2YgYmxvY2sgPT0gJ2Z1bmN0aW9uJylcclxuICAgICAgICBibG9jay5jYWxsKHRoaXMsIHRoaXMpXHJcblxyXG4gICAgICByZXR1cm4gdGhpc1xyXG4gICAgfVxyXG4gICAgLy8gUmV0dXJuIHRoZSBmaWxsIGlkXHJcbiAgLCB0b1N0cmluZzogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiAndXJsKCMnICsgdGhpcy5pZCgpICsgJyknXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBBZGQgcGFyZW50IG1ldGhvZFxyXG4sIGNvbnN0cnVjdDoge1xyXG4gICAgbWFya2VyOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCBibG9jaykge1xyXG4gICAgICAvLyBDcmVhdGUgbWFya2VyIGVsZW1lbnQgaW4gZGVmc1xyXG4gICAgICByZXR1cm4gdGhpcy5kZWZzKCkubWFya2VyKHdpZHRoLCBoZWlnaHQsIGJsb2NrKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbn0pXHJcblxyXG5TVkcuZXh0ZW5kKFNWRy5EZWZzLCB7XHJcbiAgLy8gQ3JlYXRlIG1hcmtlclxyXG4gIG1hcmtlcjogZnVuY3Rpb24od2lkdGgsIGhlaWdodCwgYmxvY2spIHtcclxuICAgIC8vIFNldCBkZWZhdWx0IHZpZXdib3ggdG8gbWF0Y2ggdGhlIHdpZHRoIGFuZCBoZWlnaHQsIHNldCByZWYgdG8gY3ggYW5kIGN5IGFuZCBzZXQgb3JpZW50IHRvIGF1dG9cclxuICAgIHJldHVybiB0aGlzLnB1dChuZXcgU1ZHLk1hcmtlcilcclxuICAgICAgLnNpemUod2lkdGgsIGhlaWdodClcclxuICAgICAgLnJlZih3aWR0aCAvIDIsIGhlaWdodCAvIDIpXHJcbiAgICAgIC52aWV3Ym94KDAsIDAsIHdpZHRoLCBoZWlnaHQpXHJcbiAgICAgIC5hdHRyKCdvcmllbnQnLCAnYXV0bycpXHJcbiAgICAgIC51cGRhdGUoYmxvY2spXHJcbiAgfVxyXG5cclxufSlcclxuXHJcblNWRy5leHRlbmQoU1ZHLkxpbmUsIFNWRy5Qb2x5bGluZSwgU1ZHLlBvbHlnb24sIFNWRy5QYXRoLCB7XHJcbiAgLy8gQ3JlYXRlIGFuZCBhdHRhY2ggbWFya2Vyc1xyXG4gIG1hcmtlcjogZnVuY3Rpb24obWFya2VyLCB3aWR0aCwgaGVpZ2h0LCBibG9jaykge1xyXG4gICAgdmFyIGF0dHIgPSBbJ21hcmtlciddXHJcblxyXG4gICAgLy8gQnVpbGQgYXR0cmlidXRlIG5hbWVcclxuICAgIGlmIChtYXJrZXIgIT0gJ2FsbCcpIGF0dHIucHVzaChtYXJrZXIpXHJcbiAgICBhdHRyID0gYXR0ci5qb2luKCctJylcclxuXHJcbiAgICAvLyBTZXQgbWFya2VyIGF0dHJpYnV0ZVxyXG4gICAgbWFya2VyID0gYXJndW1lbnRzWzFdIGluc3RhbmNlb2YgU1ZHLk1hcmtlciA/XHJcbiAgICAgIGFyZ3VtZW50c1sxXSA6XHJcbiAgICAgIHRoaXMuZG9jKCkubWFya2VyKHdpZHRoLCBoZWlnaHQsIGJsb2NrKVxyXG5cclxuICAgIHJldHVybiB0aGlzLmF0dHIoYXR0ciwgbWFya2VyKVxyXG4gIH1cclxuXHJcbn0pXG4vLyBEZWZpbmUgbGlzdCBvZiBhdmFpbGFibGUgYXR0cmlidXRlcyBmb3Igc3Ryb2tlIGFuZCBmaWxsXHJcbnZhciBzdWdhciA9IHtcclxuICBzdHJva2U6IFsnY29sb3InLCAnd2lkdGgnLCAnb3BhY2l0eScsICdsaW5lY2FwJywgJ2xpbmVqb2luJywgJ21pdGVybGltaXQnLCAnZGFzaGFycmF5JywgJ2Rhc2hvZmZzZXQnXVxyXG4sIGZpbGw6ICAgWydjb2xvcicsICdvcGFjaXR5JywgJ3J1bGUnXVxyXG4sIHByZWZpeDogZnVuY3Rpb24odCwgYSkge1xyXG4gICAgcmV0dXJuIGEgPT0gJ2NvbG9yJyA/IHQgOiB0ICsgJy0nICsgYVxyXG4gIH1cclxufVxyXG5cclxuLy8gQWRkIHN1Z2FyIGZvciBmaWxsIGFuZCBzdHJva2VcclxuO1snZmlsbCcsICdzdHJva2UnXS5mb3JFYWNoKGZ1bmN0aW9uKG0pIHtcclxuICB2YXIgaSwgZXh0ZW5zaW9uID0ge31cclxuXHJcbiAgZXh0ZW5zaW9uW21dID0gZnVuY3Rpb24obykge1xyXG4gICAgaWYgKHR5cGVvZiBvID09ICd1bmRlZmluZWQnKVxyXG4gICAgICByZXR1cm4gdGhpc1xyXG4gICAgaWYgKHR5cGVvZiBvID09ICdzdHJpbmcnIHx8IFNWRy5Db2xvci5pc1JnYihvKSB8fCAobyAmJiB0eXBlb2Ygby5maWxsID09PSAnZnVuY3Rpb24nKSlcclxuICAgICAgdGhpcy5hdHRyKG0sIG8pXHJcblxyXG4gICAgZWxzZVxyXG4gICAgICAvLyBzZXQgYWxsIGF0dHJpYnV0ZXMgZnJvbSBzdWdhci5maWxsIGFuZCBzdWdhci5zdHJva2UgbGlzdFxyXG4gICAgICBmb3IgKGkgPSBzdWdhclttXS5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcclxuICAgICAgICBpZiAob1tzdWdhclttXVtpXV0gIT0gbnVsbClcclxuICAgICAgICAgIHRoaXMuYXR0cihzdWdhci5wcmVmaXgobSwgc3VnYXJbbV1baV0pLCBvW3N1Z2FyW21dW2ldXSlcclxuXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuXHJcbiAgU1ZHLmV4dGVuZChTVkcuRWxlbWVudCwgU1ZHLkZYLCBleHRlbnNpb24pXHJcblxyXG59KVxyXG5cclxuU1ZHLmV4dGVuZChTVkcuRWxlbWVudCwgU1ZHLkZYLCB7XHJcbiAgLy8gTWFwIHJvdGF0aW9uIHRvIHRyYW5zZm9ybVxyXG4gIHJvdGF0ZTogZnVuY3Rpb24oZCwgY3gsIGN5KSB7XHJcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0oeyByb3RhdGlvbjogZCwgY3g6IGN4LCBjeTogY3kgfSlcclxuICB9XHJcbiAgLy8gTWFwIHNrZXcgdG8gdHJhbnNmb3JtXHJcbiwgc2tldzogZnVuY3Rpb24oeCwgeSwgY3gsIGN5KSB7XHJcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PSAxICB8fCBhcmd1bWVudHMubGVuZ3RoID09IDMgP1xyXG4gICAgICB0aGlzLnRyYW5zZm9ybSh7IHNrZXc6IHgsIGN4OiB5LCBjeTogY3ggfSkgOlxyXG4gICAgICB0aGlzLnRyYW5zZm9ybSh7IHNrZXdYOiB4LCBza2V3WTogeSwgY3g6IGN4LCBjeTogY3kgfSlcclxuICB9XHJcbiAgLy8gTWFwIHNjYWxlIHRvIHRyYW5zZm9ybVxyXG4sIHNjYWxlOiBmdW5jdGlvbih4LCB5LCBjeCwgY3kpIHtcclxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09IDEgIHx8IGFyZ3VtZW50cy5sZW5ndGggPT0gMyA/XHJcbiAgICAgIHRoaXMudHJhbnNmb3JtKHsgc2NhbGU6IHgsIGN4OiB5LCBjeTogY3ggfSkgOlxyXG4gICAgICB0aGlzLnRyYW5zZm9ybSh7IHNjYWxlWDogeCwgc2NhbGVZOiB5LCBjeDogY3gsIGN5OiBjeSB9KVxyXG4gIH1cclxuICAvLyBNYXAgdHJhbnNsYXRlIHRvIHRyYW5zZm9ybVxyXG4sIHRyYW5zbGF0ZTogZnVuY3Rpb24oeCwgeSkge1xyXG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKHsgeDogeCwgeTogeSB9KVxyXG4gIH1cclxuICAvLyBNYXAgZmxpcCB0byB0cmFuc2Zvcm1cclxuLCBmbGlwOiBmdW5jdGlvbihhLCBvKSB7XHJcbiAgICBvID0gdHlwZW9mIGEgPT0gJ251bWJlcicgPyBhIDogb1xyXG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKHsgZmxpcDogYSB8fCAnYm90aCcsIG9mZnNldDogbyB9KVxyXG4gIH1cclxuICAvLyBNYXAgbWF0cml4IHRvIHRyYW5zZm9ybVxyXG4sIG1hdHJpeDogZnVuY3Rpb24obSkge1xyXG4gICAgcmV0dXJuIHRoaXMuYXR0cigndHJhbnNmb3JtJywgbmV3IFNWRy5NYXRyaXgoYXJndW1lbnRzLmxlbmd0aCA9PSA2ID8gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpIDogbSkpXHJcbiAgfVxyXG4gIC8vIE9wYWNpdHlcclxuLCBvcGFjaXR5OiBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHRoaXMuYXR0cignb3BhY2l0eScsIHZhbHVlKVxyXG4gIH1cclxuICAvLyBSZWxhdGl2ZSBtb3ZlIG92ZXIgeCBheGlzXHJcbiwgZHg6IGZ1bmN0aW9uKHgpIHtcclxuICAgIHJldHVybiB0aGlzLngobmV3IFNWRy5OdW1iZXIoeCkucGx1cyh0aGlzIGluc3RhbmNlb2YgU1ZHLkZYID8gMCA6IHRoaXMueCgpKSwgdHJ1ZSlcclxuICB9XHJcbiAgLy8gUmVsYXRpdmUgbW92ZSBvdmVyIHkgYXhpc1xyXG4sIGR5OiBmdW5jdGlvbih5KSB7XHJcbiAgICByZXR1cm4gdGhpcy55KG5ldyBTVkcuTnVtYmVyKHkpLnBsdXModGhpcyBpbnN0YW5jZW9mIFNWRy5GWCA/IDAgOiB0aGlzLnkoKSksIHRydWUpXHJcbiAgfVxyXG4gIC8vIFJlbGF0aXZlIG1vdmUgb3ZlciB4IGFuZCB5IGF4ZXNcclxuLCBkbW92ZTogZnVuY3Rpb24oeCwgeSkge1xyXG4gICAgcmV0dXJuIHRoaXMuZHgoeCkuZHkoeSlcclxuICB9XHJcbn0pXHJcblxyXG5TVkcuZXh0ZW5kKFNWRy5SZWN0LCBTVkcuRWxsaXBzZSwgU1ZHLkNpcmNsZSwgU1ZHLkdyYWRpZW50LCBTVkcuRlgsIHtcclxuICAvLyBBZGQgeCBhbmQgeSByYWRpdXNcclxuICByYWRpdXM6IGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgIHZhciB0eXBlID0gKHRoaXMuX3RhcmdldCB8fCB0aGlzKS50eXBlO1xyXG4gICAgcmV0dXJuIHR5cGUgPT0gJ3JhZGlhbCcgfHwgdHlwZSA9PSAnY2lyY2xlJyA/XHJcbiAgICAgIHRoaXMuYXR0cigncicsIG5ldyBTVkcuTnVtYmVyKHgpKSA6XHJcbiAgICAgIHRoaXMucngoeCkucnkoeSA9PSBudWxsID8geCA6IHkpXHJcbiAgfVxyXG59KVxyXG5cclxuU1ZHLmV4dGVuZChTVkcuUGF0aCwge1xyXG4gIC8vIEdldCBwYXRoIGxlbmd0aFxyXG4gIGxlbmd0aDogZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5ub2RlLmdldFRvdGFsTGVuZ3RoKClcclxuICB9XHJcbiAgLy8gR2V0IHBvaW50IGF0IGxlbmd0aFxyXG4sIHBvaW50QXQ6IGZ1bmN0aW9uKGxlbmd0aCkge1xyXG4gICAgcmV0dXJuIHRoaXMubm9kZS5nZXRQb2ludEF0TGVuZ3RoKGxlbmd0aClcclxuICB9XHJcbn0pXHJcblxyXG5TVkcuZXh0ZW5kKFNWRy5QYXJlbnQsIFNWRy5UZXh0LCBTVkcuVHNwYW4sIFNWRy5GWCwge1xyXG4gIC8vIFNldCBmb250XHJcbiAgZm9udDogZnVuY3Rpb24oYSwgdikge1xyXG4gICAgaWYgKHR5cGVvZiBhID09ICdvYmplY3QnKSB7XHJcbiAgICAgIGZvciAodiBpbiBhKSB0aGlzLmZvbnQodiwgYVt2XSlcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYSA9PSAnbGVhZGluZycgP1xyXG4gICAgICAgIHRoaXMubGVhZGluZyh2KSA6XHJcbiAgICAgIGEgPT0gJ2FuY2hvcicgP1xyXG4gICAgICAgIHRoaXMuYXR0cigndGV4dC1hbmNob3InLCB2KSA6XHJcbiAgICAgIGEgPT0gJ3NpemUnIHx8IGEgPT0gJ2ZhbWlseScgfHwgYSA9PSAnd2VpZ2h0JyB8fCBhID09ICdzdHJldGNoJyB8fCBhID09ICd2YXJpYW50JyB8fCBhID09ICdzdHlsZScgP1xyXG4gICAgICAgIHRoaXMuYXR0cignZm9udC0nKyBhLCB2KSA6XHJcbiAgICAgICAgdGhpcy5hdHRyKGEsIHYpXHJcbiAgfVxyXG59KVxyXG5cblNWRy5TZXQgPSBTVkcuaW52ZW50KHtcclxuICAvLyBJbml0aWFsaXplXHJcbiAgY3JlYXRlOiBmdW5jdGlvbihtZW1iZXJzKSB7XHJcbiAgICAvLyBTZXQgaW5pdGlhbCBzdGF0ZVxyXG4gICAgQXJyYXkuaXNBcnJheShtZW1iZXJzKSA/IHRoaXMubWVtYmVycyA9IG1lbWJlcnMgOiB0aGlzLmNsZWFyKClcclxuICB9XHJcblxyXG4gIC8vIEFkZCBjbGFzcyBtZXRob2RzXHJcbiwgZXh0ZW5kOiB7XHJcbiAgICAvLyBBZGQgZWxlbWVudCB0byBzZXRcclxuICAgIGFkZDogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciBpLCBpbCwgZWxlbWVudHMgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cylcclxuXHJcbiAgICAgIGZvciAoaSA9IDAsIGlsID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKylcclxuICAgICAgICB0aGlzLm1lbWJlcnMucHVzaChlbGVtZW50c1tpXSlcclxuXHJcbiAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcbiAgICAvLyBSZW1vdmUgZWxlbWVudCBmcm9tIHNldFxyXG4gICwgcmVtb3ZlOiBmdW5jdGlvbihlbGVtZW50KSB7XHJcbiAgICAgIHZhciBpID0gdGhpcy5pbmRleChlbGVtZW50KVxyXG5cclxuICAgICAgLy8gcmVtb3ZlIGdpdmVuIGNoaWxkXHJcbiAgICAgIGlmIChpID4gLTEpXHJcbiAgICAgICAgdGhpcy5tZW1iZXJzLnNwbGljZShpLCAxKVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH1cclxuICAgIC8vIEl0ZXJhdGUgb3ZlciBhbGwgbWVtYmVyc1xyXG4gICwgZWFjaDogZnVuY3Rpb24oYmxvY2spIHtcclxuICAgICAgZm9yICh2YXIgaSA9IDAsIGlsID0gdGhpcy5tZW1iZXJzLmxlbmd0aDsgaSA8IGlsOyBpKyspXHJcbiAgICAgICAgYmxvY2suYXBwbHkodGhpcy5tZW1iZXJzW2ldLCBbaSwgdGhpcy5tZW1iZXJzXSlcclxuXHJcbiAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcbiAgICAvLyBSZXN0b3JlIHRvIGRlZmF1bHRzXHJcbiAgLCBjbGVhcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgIC8vIGluaXRpYWxpemUgc3RvcmVcclxuICAgICAgdGhpcy5tZW1iZXJzID0gW11cclxuXHJcbiAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcbiAgICAvLyBHZXQgdGhlIGxlbmd0aCBvZiBhIHNldFxyXG4gICwgbGVuZ3RoOiBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubWVtYmVycy5sZW5ndGhcclxuICAgIH1cclxuICAgIC8vIENoZWNrcyBpZiBhIGdpdmVuIGVsZW1lbnQgaXMgcHJlc2VudCBpbiBzZXRcclxuICAsIGhhczogZnVuY3Rpb24oZWxlbWVudCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5pbmRleChlbGVtZW50KSA+PSAwXHJcbiAgICB9XHJcbiAgICAvLyByZXR1bnMgaW5kZXggb2YgZ2l2ZW4gZWxlbWVudCBpbiBzZXRcclxuICAsIGluZGV4OiBmdW5jdGlvbihlbGVtZW50KSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm1lbWJlcnMuaW5kZXhPZihlbGVtZW50KVxyXG4gICAgfVxyXG4gICAgLy8gR2V0IG1lbWJlciBhdCBnaXZlbiBpbmRleFxyXG4gICwgZ2V0OiBmdW5jdGlvbihpKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm1lbWJlcnNbaV1cclxuICAgIH1cclxuICAgIC8vIEdldCBmaXJzdCBtZW1iZXJcclxuICAsIGZpcnN0OiBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZ2V0KDApXHJcbiAgICB9XHJcbiAgICAvLyBHZXQgbGFzdCBtZW1iZXJcclxuICAsIGxhc3Q6IGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5nZXQodGhpcy5tZW1iZXJzLmxlbmd0aCAtIDEpXHJcbiAgICB9XHJcbiAgICAvLyBEZWZhdWx0IHZhbHVlXHJcbiAgLCB2YWx1ZU9mOiBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubWVtYmVyc1xyXG4gICAgfVxyXG4gICAgLy8gR2V0IHRoZSBib3VuZGluZyBib3ggb2YgYWxsIG1lbWJlcnMgaW5jbHVkZWQgb3IgZW1wdHkgYm94IGlmIHNldCBoYXMgbm8gaXRlbXNcclxuICAsIGJib3g6IGZ1bmN0aW9uKCl7XHJcbiAgICAgIC8vIHJldHVybiBhbiBlbXB0eSBib3ggb2YgdGhlcmUgYXJlIG5vIG1lbWJlcnNcclxuICAgICAgaWYgKHRoaXMubWVtYmVycy5sZW5ndGggPT0gMClcclxuICAgICAgICByZXR1cm4gbmV3IFNWRy5SQm94KClcclxuXHJcbiAgICAgIC8vIGdldCB0aGUgZmlyc3QgcmJveCBhbmQgdXBkYXRlIHRoZSB0YXJnZXQgYmJveFxyXG4gICAgICB2YXIgcmJveCA9IHRoaXMubWVtYmVyc1swXS5yYm94KHRoaXMubWVtYmVyc1swXS5kb2MoKSlcclxuXHJcbiAgICAgIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcclxuICAgICAgICAvLyB1c2VyIHJib3ggZm9yIGNvcnJlY3QgcG9zaXRpb24gYW5kIHZpc3VhbCByZXByZXNlbnRhdGlvblxyXG4gICAgICAgIHJib3ggPSByYm94Lm1lcmdlKHRoaXMucmJveCh0aGlzLmRvYygpKSlcclxuICAgICAgfSlcclxuXHJcbiAgICAgIHJldHVybiByYm94XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBBZGQgcGFyZW50IG1ldGhvZFxyXG4sIGNvbnN0cnVjdDoge1xyXG4gICAgLy8gQ3JlYXRlIGEgbmV3IHNldFxyXG4gICAgc2V0OiBmdW5jdGlvbihtZW1iZXJzKSB7XHJcbiAgICAgIHJldHVybiBuZXcgU1ZHLlNldChtZW1iZXJzKVxyXG4gICAgfVxyXG4gIH1cclxufSlcclxuXHJcblNWRy5GWC5TZXQgPSBTVkcuaW52ZW50KHtcclxuICAvLyBJbml0aWFsaXplIG5vZGVcclxuICBjcmVhdGU6IGZ1bmN0aW9uKHNldCkge1xyXG4gICAgLy8gc3RvcmUgcmVmZXJlbmNlIHRvIHNldFxyXG4gICAgdGhpcy5zZXQgPSBzZXRcclxuICB9XHJcblxyXG59KVxyXG5cclxuLy8gQWxpYXMgbWV0aG9kc1xyXG5TVkcuU2V0LmluaGVyaXQgPSBmdW5jdGlvbigpIHtcclxuICB2YXIgbVxyXG4gICAgLCBtZXRob2RzID0gW11cclxuXHJcbiAgLy8gZ2F0aGVyIHNoYXBlIG1ldGhvZHNcclxuICBmb3IodmFyIG0gaW4gU1ZHLlNoYXBlLnByb3RvdHlwZSlcclxuICAgIGlmICh0eXBlb2YgU1ZHLlNoYXBlLnByb3RvdHlwZVttXSA9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTVkcuU2V0LnByb3RvdHlwZVttXSAhPSAnZnVuY3Rpb24nKVxyXG4gICAgICBtZXRob2RzLnB1c2gobSlcclxuXHJcbiAgLy8gYXBwbHkgc2hhcGUgYWxpYXNzZXNcclxuICBtZXRob2RzLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XHJcbiAgICBTVkcuU2V0LnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IHRoaXMubWVtYmVycy5sZW5ndGg7IGkgPCBpbDsgaSsrKVxyXG4gICAgICAgIGlmICh0aGlzLm1lbWJlcnNbaV0gJiYgdHlwZW9mIHRoaXMubWVtYmVyc1tpXVttZXRob2RdID09ICdmdW5jdGlvbicpXHJcbiAgICAgICAgICB0aGlzLm1lbWJlcnNbaV1bbWV0aG9kXS5hcHBseSh0aGlzLm1lbWJlcnNbaV0sIGFyZ3VtZW50cylcclxuXHJcbiAgICAgIHJldHVybiBtZXRob2QgPT0gJ2FuaW1hdGUnID8gKHRoaXMuZnggfHwgKHRoaXMuZnggPSBuZXcgU1ZHLkZYLlNldCh0aGlzKSkpIDogdGhpc1xyXG4gICAgfVxyXG4gIH0pXHJcblxyXG4gIC8vIGNsZWFyIG1ldGhvZHMgZm9yIHRoZSBuZXh0IHJvdW5kXHJcbiAgbWV0aG9kcyA9IFtdXHJcblxyXG4gIC8vIGdhdGhlciBmeCBtZXRob2RzXHJcbiAgZm9yKHZhciBtIGluIFNWRy5GWC5wcm90b3R5cGUpXHJcbiAgICBpZiAodHlwZW9mIFNWRy5GWC5wcm90b3R5cGVbbV0gPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU1ZHLkZYLlNldC5wcm90b3R5cGVbbV0gIT0gJ2Z1bmN0aW9uJylcclxuICAgICAgbWV0aG9kcy5wdXNoKG0pXHJcblxyXG4gIC8vIGFwcGx5IGZ4IGFsaWFzc2VzXHJcbiAgbWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xyXG4gICAgU1ZHLkZYLlNldC5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICBmb3IgKHZhciBpID0gMCwgaWwgPSB0aGlzLnNldC5tZW1iZXJzLmxlbmd0aDsgaSA8IGlsOyBpKyspXHJcbiAgICAgICAgdGhpcy5zZXQubWVtYmVyc1tpXS5meFttZXRob2RdLmFwcGx5KHRoaXMuc2V0Lm1lbWJlcnNbaV0uZngsIGFyZ3VtZW50cylcclxuXHJcbiAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9XHJcbiAgfSlcclxufVxyXG5cclxuXHJcblxuXHJcblNWRy5leHRlbmQoU1ZHLkVsZW1lbnQsIHtcclxuICAvLyBTdG9yZSBkYXRhIHZhbHVlcyBvbiBzdmcgbm9kZXNcclxuICBkYXRhOiBmdW5jdGlvbihhLCB2LCByKSB7XHJcbiAgICBpZiAodHlwZW9mIGEgPT0gJ29iamVjdCcpIHtcclxuICAgICAgZm9yICh2IGluIGEpXHJcbiAgICAgICAgdGhpcy5kYXRhKHYsIGFbdl0pXHJcblxyXG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHRoaXMuYXR0cignZGF0YS0nICsgYSkpXHJcbiAgICAgIH0gY2F0Y2goZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmF0dHIoJ2RhdGEtJyArIGEpXHJcbiAgICAgIH1cclxuXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmF0dHIoXHJcbiAgICAgICAgJ2RhdGEtJyArIGFcclxuICAgICAgLCB2ID09PSBudWxsID9cclxuICAgICAgICAgIG51bGwgOlxyXG4gICAgICAgIHIgPT09IHRydWUgfHwgdHlwZW9mIHYgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2ID09PSAnbnVtYmVyJyA/XHJcbiAgICAgICAgICB2IDpcclxuICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHYpXHJcbiAgICAgIClcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxufSlcblNWRy5leHRlbmQoU1ZHLkVsZW1lbnQsIHtcclxuICAvLyBSZW1lbWJlciBhcmJpdHJhcnkgZGF0YVxyXG4gIHJlbWVtYmVyOiBmdW5jdGlvbihrLCB2KSB7XHJcbiAgICAvLyByZW1lbWJlciBldmVyeSBpdGVtIGluIGFuIG9iamVjdCBpbmRpdmlkdWFsbHlcclxuICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09ICdvYmplY3QnKVxyXG4gICAgICBmb3IgKHZhciB2IGluIGspXHJcbiAgICAgICAgdGhpcy5yZW1lbWJlcih2LCBrW3ZdKVxyXG5cclxuICAgIC8vIHJldHJpZXZlIG1lbW9yeVxyXG4gICAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKVxyXG4gICAgICByZXR1cm4gdGhpcy5tZW1vcnkoKVtrXVxyXG5cclxuICAgIC8vIHN0b3JlIG1lbW9yeVxyXG4gICAgZWxzZVxyXG4gICAgICB0aGlzLm1lbW9yeSgpW2tdID0gdlxyXG5cclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICAvLyBFcmFzZSBhIGdpdmVuIG1lbW9yeVxyXG4sIGZvcmdldDogZnVuY3Rpb24oKSB7XHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAwKVxyXG4gICAgICB0aGlzLl9tZW1vcnkgPSB7fVxyXG4gICAgZWxzZVxyXG4gICAgICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxyXG4gICAgICAgIGRlbGV0ZSB0aGlzLm1lbW9yeSgpW2FyZ3VtZW50c1tpXV1cclxuXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuXHJcbiAgLy8gSW5pdGlhbGl6ZSBvciByZXR1cm4gbG9jYWwgbWVtb3J5IG9iamVjdFxyXG4sIG1lbW9yeTogZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fbWVtb3J5IHx8ICh0aGlzLl9tZW1vcnkgPSB7fSlcclxuICB9XHJcblxyXG59KVxuLy8gTWV0aG9kIGZvciBnZXR0aW5nIGFuIGVsZW1lbnQgYnkgaWRcclxuU1ZHLmdldCA9IGZ1bmN0aW9uKGlkKSB7XHJcbiAgdmFyIG5vZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZEZyb21SZWZlcmVuY2UoaWQpIHx8IGlkKVxyXG4gIHJldHVybiBTVkcuYWRvcHQobm9kZSlcclxufVxyXG5cclxuLy8gU2VsZWN0IGVsZW1lbnRzIGJ5IHF1ZXJ5IHN0cmluZ1xyXG5TVkcuc2VsZWN0ID0gZnVuY3Rpb24ocXVlcnksIHBhcmVudCkge1xyXG4gIHJldHVybiBuZXcgU1ZHLlNldChcclxuICAgIFNWRy51dGlscy5tYXAoKHBhcmVudCB8fCBkb2N1bWVudCkucXVlcnlTZWxlY3RvckFsbChxdWVyeSksIGZ1bmN0aW9uKG5vZGUpIHtcclxuICAgICAgcmV0dXJuIFNWRy5hZG9wdChub2RlKVxyXG4gICAgfSlcclxuICApXHJcbn1cclxuXHJcblNWRy5leHRlbmQoU1ZHLlBhcmVudCwge1xyXG4gIC8vIFNjb3BlZCBzZWxlY3QgbWV0aG9kXHJcbiAgc2VsZWN0OiBmdW5jdGlvbihxdWVyeSkge1xyXG4gICAgcmV0dXJuIFNWRy5zZWxlY3QocXVlcnksIHRoaXMubm9kZSlcclxuICB9XHJcblxyXG59KVxuZnVuY3Rpb24gcGF0aFJlZ1JlcGxhY2UoYSwgYiwgYywgZCkge1xyXG4gIHJldHVybiBjICsgZC5yZXBsYWNlKFNWRy5yZWdleC5kb3RzLCAnIC4nKVxyXG59XHJcblxyXG4vLyBjcmVhdGVzIGRlZXAgY2xvbmUgb2YgYXJyYXlcclxuZnVuY3Rpb24gYXJyYXlfY2xvbmUoYXJyKXtcclxuICB2YXIgY2xvbmUgPSBhcnIuc2xpY2UoMClcclxuICBmb3IodmFyIGkgPSBjbG9uZS5sZW5ndGg7IGktLTspe1xyXG4gICAgaWYoQXJyYXkuaXNBcnJheShjbG9uZVtpXSkpe1xyXG4gICAgICBjbG9uZVtpXSA9IGFycmF5X2Nsb25lKGNsb25lW2ldKVxyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gY2xvbmVcclxufVxyXG5cclxuLy8gdGVzdHMgaWYgYSBnaXZlbiBlbGVtZW50IGlzIGluc3RhbmNlIG9mIGFuIG9iamVjdFxyXG5mdW5jdGlvbiBpcyhlbCwgb2JqKXtcclxuICByZXR1cm4gZWwgaW5zdGFuY2VvZiBvYmpcclxufVxyXG5cclxuLy8gdGVzdHMgaWYgYSBnaXZlbiBzZWxlY3RvciBtYXRjaGVzIGFuIGVsZW1lbnRcclxuZnVuY3Rpb24gbWF0Y2hlcyhlbCwgc2VsZWN0b3IpIHtcclxuICByZXR1cm4gKGVsLm1hdGNoZXMgfHwgZWwubWF0Y2hlc1NlbGVjdG9yIHx8IGVsLm1zTWF0Y2hlc1NlbGVjdG9yIHx8IGVsLm1vek1hdGNoZXNTZWxlY3RvciB8fCBlbC53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHwgZWwub01hdGNoZXNTZWxlY3RvcikuY2FsbChlbCwgc2VsZWN0b3IpO1xyXG59XHJcblxyXG4vLyBDb252ZXJ0IGRhc2gtc2VwYXJhdGVkLXN0cmluZyB0byBjYW1lbENhc2VcclxuZnVuY3Rpb24gY2FtZWxDYXNlKHMpIHtcclxuICByZXR1cm4gcy50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoLy0oLikvZywgZnVuY3Rpb24obSwgZykge1xyXG4gICAgcmV0dXJuIGcudG9VcHBlckNhc2UoKVxyXG4gIH0pXHJcbn1cclxuXHJcbi8vIENhcGl0YWxpemUgZmlyc3QgbGV0dGVyIG9mIGEgc3RyaW5nXHJcbmZ1bmN0aW9uIGNhcGl0YWxpemUocykge1xyXG4gIHJldHVybiBzLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcy5zbGljZSgxKVxyXG59XHJcblxyXG4vLyBFbnN1cmUgdG8gc2l4LWJhc2VkIGhleFxyXG5mdW5jdGlvbiBmdWxsSGV4KGhleCkge1xyXG4gIHJldHVybiBoZXgubGVuZ3RoID09IDQgP1xyXG4gICAgWyAnIycsXHJcbiAgICAgIGhleC5zdWJzdHJpbmcoMSwgMiksIGhleC5zdWJzdHJpbmcoMSwgMilcclxuICAgICwgaGV4LnN1YnN0cmluZygyLCAzKSwgaGV4LnN1YnN0cmluZygyLCAzKVxyXG4gICAgLCBoZXguc3Vic3RyaW5nKDMsIDQpLCBoZXguc3Vic3RyaW5nKDMsIDQpXHJcbiAgICBdLmpvaW4oJycpIDogaGV4XHJcbn1cclxuXHJcbi8vIENvbXBvbmVudCB0byBoZXggdmFsdWVcclxuZnVuY3Rpb24gY29tcFRvSGV4KGNvbXApIHtcclxuICB2YXIgaGV4ID0gY29tcC50b1N0cmluZygxNilcclxuICByZXR1cm4gaGV4Lmxlbmd0aCA9PSAxID8gJzAnICsgaGV4IDogaGV4XHJcbn1cclxuXHJcbi8vIENhbGN1bGF0ZSBwcm9wb3J0aW9uYWwgd2lkdGggYW5kIGhlaWdodCB2YWx1ZXMgd2hlbiBuZWNlc3NhcnlcclxuZnVuY3Rpb24gcHJvcG9ydGlvbmFsU2l6ZShlbGVtZW50LCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgaWYgKHdpZHRoID09IG51bGwgfHwgaGVpZ2h0ID09IG51bGwpIHtcclxuICAgIHZhciBib3ggPSBlbGVtZW50LmJib3goKVxyXG5cclxuICAgIGlmICh3aWR0aCA9PSBudWxsKVxyXG4gICAgICB3aWR0aCA9IGJveC53aWR0aCAvIGJveC5oZWlnaHQgKiBoZWlnaHRcclxuICAgIGVsc2UgaWYgKGhlaWdodCA9PSBudWxsKVxyXG4gICAgICBoZWlnaHQgPSBib3guaGVpZ2h0IC8gYm94LndpZHRoICogd2lkdGhcclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICB3aWR0aDogIHdpZHRoXHJcbiAgLCBoZWlnaHQ6IGhlaWdodFxyXG4gIH1cclxufVxyXG5cclxuLy8gRGVsdGEgdHJhbnNmb3JtIHBvaW50XHJcbmZ1bmN0aW9uIGRlbHRhVHJhbnNmb3JtUG9pbnQobWF0cml4LCB4LCB5KSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHg6IHggKiBtYXRyaXguYSArIHkgKiBtYXRyaXguYyArIDBcclxuICAsIHk6IHggKiBtYXRyaXguYiArIHkgKiBtYXRyaXguZCArIDBcclxuICB9XHJcbn1cclxuXHJcbi8vIE1hcCBtYXRyaXggYXJyYXkgdG8gb2JqZWN0XHJcbmZ1bmN0aW9uIGFycmF5VG9NYXRyaXgoYSkge1xyXG4gIHJldHVybiB7IGE6IGFbMF0sIGI6IGFbMV0sIGM6IGFbMl0sIGQ6IGFbM10sIGU6IGFbNF0sIGY6IGFbNV0gfVxyXG59XHJcblxyXG4vLyBQYXJzZSBtYXRyaXggaWYgcmVxdWlyZWRcclxuZnVuY3Rpb24gcGFyc2VNYXRyaXgobWF0cml4KSB7XHJcbiAgaWYgKCEobWF0cml4IGluc3RhbmNlb2YgU1ZHLk1hdHJpeCkpXHJcbiAgICBtYXRyaXggPSBuZXcgU1ZHLk1hdHJpeChtYXRyaXgpXHJcblxyXG4gIHJldHVybiBtYXRyaXhcclxufVxyXG5cclxuLy8gQWRkIGNlbnRyZSBwb2ludCB0byB0cmFuc2Zvcm0gb2JqZWN0XHJcbmZ1bmN0aW9uIGVuc3VyZUNlbnRyZShvLCB0YXJnZXQpIHtcclxuICBvLmN4ID0gby5jeCA9PSBudWxsID8gdGFyZ2V0LmJib3goKS5jeCA6IG8uY3hcclxuICBvLmN5ID0gby5jeSA9PSBudWxsID8gdGFyZ2V0LmJib3goKS5jeSA6IG8uY3lcclxufVxyXG5cclxuLy8gUGF0aEFycmF5IEhlbHBlcnNcclxuZnVuY3Rpb24gYXJyYXlUb1N0cmluZyhhKSB7XHJcbiAgZm9yICh2YXIgaSA9IDAsIGlsID0gYS5sZW5ndGgsIHMgPSAnJzsgaSA8IGlsOyBpKyspIHtcclxuICAgIHMgKz0gYVtpXVswXVxyXG5cclxuICAgIGlmIChhW2ldWzFdICE9IG51bGwpIHtcclxuICAgICAgcyArPSBhW2ldWzFdXHJcblxyXG4gICAgICBpZiAoYVtpXVsyXSAhPSBudWxsKSB7XHJcbiAgICAgICAgcyArPSAnICdcclxuICAgICAgICBzICs9IGFbaV1bMl1cclxuXHJcbiAgICAgICAgaWYgKGFbaV1bM10gIT0gbnVsbCkge1xyXG4gICAgICAgICAgcyArPSAnICdcclxuICAgICAgICAgIHMgKz0gYVtpXVszXVxyXG4gICAgICAgICAgcyArPSAnICdcclxuICAgICAgICAgIHMgKz0gYVtpXVs0XVxyXG5cclxuICAgICAgICAgIGlmIChhW2ldWzVdICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcyArPSAnICdcclxuICAgICAgICAgICAgcyArPSBhW2ldWzVdXHJcbiAgICAgICAgICAgIHMgKz0gJyAnXHJcbiAgICAgICAgICAgIHMgKz0gYVtpXVs2XVxyXG5cclxuICAgICAgICAgICAgaWYgKGFbaV1bN10gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgIHMgKz0gJyAnXHJcbiAgICAgICAgICAgICAgcyArPSBhW2ldWzddXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBzICsgJyAnXHJcbn1cclxuXHJcbi8vIERlZXAgbmV3IGlkIGFzc2lnbm1lbnRcclxuZnVuY3Rpb24gYXNzaWduTmV3SWQobm9kZSkge1xyXG4gIC8vIGRvIHRoZSBzYW1lIGZvciBTVkcgY2hpbGQgbm9kZXMgYXMgd2VsbFxyXG4gIGZvciAodmFyIGkgPSBub2RlLmNoaWxkTm9kZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXHJcbiAgICBpZiAobm9kZS5jaGlsZE5vZGVzW2ldIGluc3RhbmNlb2Ygd2luZG93LlNWR0VsZW1lbnQpXHJcbiAgICAgIGFzc2lnbk5ld0lkKG5vZGUuY2hpbGROb2Rlc1tpXSlcclxuXHJcbiAgcmV0dXJuIFNWRy5hZG9wdChub2RlKS5pZChTVkcuZWlkKG5vZGUubm9kZU5hbWUpKVxyXG59XHJcblxyXG4vLyBBZGQgbW9yZSBib3VuZGluZyBib3ggcHJvcGVydGllc1xyXG5mdW5jdGlvbiBmdWxsQm94KGIpIHtcclxuICBpZiAoYi54ID09IG51bGwpIHtcclxuICAgIGIueCAgICAgID0gMFxyXG4gICAgYi55ICAgICAgPSAwXHJcbiAgICBiLndpZHRoICA9IDBcclxuICAgIGIuaGVpZ2h0ID0gMFxyXG4gIH1cclxuXHJcbiAgYi53ICA9IGIud2lkdGhcclxuICBiLmggID0gYi5oZWlnaHRcclxuICBiLngyID0gYi54ICsgYi53aWR0aFxyXG4gIGIueTIgPSBiLnkgKyBiLmhlaWdodFxyXG4gIGIuY3ggPSBiLnggKyBiLndpZHRoIC8gMlxyXG4gIGIuY3kgPSBiLnkgKyBiLmhlaWdodCAvIDJcclxuXHJcbiAgcmV0dXJuIGJcclxufVxyXG5cclxuLy8gR2V0IGlkIGZyb20gcmVmZXJlbmNlIHN0cmluZ1xyXG5mdW5jdGlvbiBpZEZyb21SZWZlcmVuY2UodXJsKSB7XHJcbiAgdmFyIG0gPSB1cmwudG9TdHJpbmcoKS5tYXRjaChTVkcucmVnZXgucmVmZXJlbmNlKVxyXG5cclxuICBpZiAobSkgcmV0dXJuIG1bMV1cclxufVxyXG5cclxuLy8gQ3JlYXRlIG1hdHJpeCBhcnJheSBmb3IgbG9vcGluZ1xyXG52YXIgYWJjZGVmID0gJ2FiY2RlZicuc3BsaXQoJycpXG4vLyBBZGQgQ3VzdG9tRXZlbnQgdG8gSUU5IGFuZCBJRTEwXHJcbmlmICh0eXBlb2Ygd2luZG93LkN1c3RvbUV2ZW50ICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgLy8gQ29kZSBmcm9tOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3VzdG9tRXZlbnRcclxuICB2YXIgQ3VzdG9tRXZlbnQgPSBmdW5jdGlvbihldmVudCwgb3B0aW9ucykge1xyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgeyBidWJibGVzOiBmYWxzZSwgY2FuY2VsYWJsZTogZmFsc2UsIGRldGFpbDogdW5kZWZpbmVkIH1cclxuICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50JylcclxuICAgIGUuaW5pdEN1c3RvbUV2ZW50KGV2ZW50LCBvcHRpb25zLmJ1YmJsZXMsIG9wdGlvbnMuY2FuY2VsYWJsZSwgb3B0aW9ucy5kZXRhaWwpXHJcbiAgICByZXR1cm4gZVxyXG4gIH1cclxuXHJcbiAgQ3VzdG9tRXZlbnQucHJvdG90eXBlID0gd2luZG93LkV2ZW50LnByb3RvdHlwZVxyXG5cclxuICB3aW5kb3cuQ3VzdG9tRXZlbnQgPSBDdXN0b21FdmVudFxyXG59XHJcblxyXG4vLyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgLyBjYW5jZWxBbmltYXRpb25GcmFtZSBQb2x5ZmlsbCB3aXRoIGZhbGxiYWNrIGJhc2VkIG9uIFBhdWwgSXJpc2hcclxuKGZ1bmN0aW9uKHcpIHtcclxuICB2YXIgbGFzdFRpbWUgPSAwXHJcbiAgdmFyIHZlbmRvcnMgPSBbJ21veicsICd3ZWJraXQnXVxyXG5cclxuICBmb3IodmFyIHggPSAwOyB4IDwgdmVuZG9ycy5sZW5ndGggJiYgIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7ICsreCkge1xyXG4gICAgdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB3W3ZlbmRvcnNbeF0gKyAnUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ11cclxuICAgIHcuY2FuY2VsQW5pbWF0aW9uRnJhbWUgID0gd1t2ZW5kb3JzW3hdICsgJ0NhbmNlbEFuaW1hdGlvbkZyYW1lJ10gfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd1t2ZW5kb3JzW3hdICsgJ0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSddXHJcbiAgfVxyXG5cclxuICB3LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHcucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XHJcbiAgICBmdW5jdGlvbihjYWxsYmFjaykge1xyXG4gICAgICB2YXIgY3VyclRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKVxyXG4gICAgICB2YXIgdGltZVRvQ2FsbCA9IE1hdGgubWF4KDAsIDE2IC0gKGN1cnJUaW1lIC0gbGFzdFRpbWUpKVxyXG5cclxuICAgICAgdmFyIGlkID0gdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGNhbGxiYWNrKGN1cnJUaW1lICsgdGltZVRvQ2FsbClcclxuICAgICAgfSwgdGltZVRvQ2FsbClcclxuXHJcbiAgICAgIGxhc3RUaW1lID0gY3VyclRpbWUgKyB0aW1lVG9DYWxsXHJcbiAgICAgIHJldHVybiBpZFxyXG4gICAgfVxyXG5cclxuICB3LmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gdy5jYW5jZWxBbmltYXRpb25GcmFtZSB8fCB3LmNsZWFyVGltZW91dDtcclxuXHJcbn0od2luZG93KSlcclxuXHJcbnJldHVybiBTVkdcclxuXHJcbn0pKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc3ZnLmpzL2Rpc3Qvc3ZnLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports,__webpack_require__){eval('/* globals Terraformer */\n(function (root, factory) {\n\n  // Node.\n  if(typeof module === \'object\' && typeof module.exports === \'object\') {\n    exports = module.exports = factory(__webpack_require__(37));\n  }\n\n  // Browser Global.\n  if(typeof root.navigator === "object") {\n    if (!root.Terraformer){\n      throw new Error("Terraformer.ArcGIS requires the core Terraformer library. https://github.com/esri/Terraformer");\n    }\n    root.Terraformer.ArcGIS = factory(root.Terraformer);\n  }\n\n}(this, function(Terraformer) {\n  var exports = {};\n\n  // https://github.com/Esri/terraformer-arcgis-parser/issues/10\n  function decompressGeometry(str) {\n    var xDiffPrev = 0;\n    var yDiffPrev = 0;\n    var points = [];\n    var x, y;\n    var strings;\n    var coefficient;\n\n    // Split the string into an array on the + and - characters\n    strings = str.match(/((\\+|\\-)[^\\+\\-]+)/g);\n\n    // The first value is the coefficient in base 32\n    coefficient = parseInt(strings[0], 32);\n\n    for (var j = 1; j < strings.length; j += 2) {\n      // j is the offset for the x value\n      // Convert the value from base 32 and add the previous x value\n      x = (parseInt(strings[j], 32) + xDiffPrev);\n      xDiffPrev = x;\n\n      // j+1 is the offset for the y value\n      // Convert the value from base 32 and add the previous y value\n      y = (parseInt(strings[j + 1], 32) + yDiffPrev);\n      yDiffPrev = y;\n\n      points.push([x / coefficient, y / coefficient]);\n    }\n\n    return points;\n  }\n\n  // checks if the first and last points of a ring are equal and closes the ring\n  function closeRing(coordinates) {\n    if (!pointsEqual(coordinates[0], coordinates[coordinates.length - 1])) {\n      coordinates.push(coordinates[0]);\n    }\n    return coordinates;\n  }\n\n  // checks if 2 x,y points are equal\n  function pointsEqual(a, b) {\n    for (var i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  // shallow object clone for feature properties and attributes\n  // from http://jsperf.com/cloning-an-object/2\n  function clone(obj) {\n    var target = {};\n    for (var i in obj) {\n      if (obj.hasOwnProperty(i)) {\n        target[i] = obj[i];\n      }\n    }\n    return target;\n  }\n\n  // determine if polygon ring coordinates are clockwise. clockwise signifies outer ring, counter-clockwise an inner ring\n  // or hole. this logic was found at http://stackoverflow.com/questions/1165647/how-to-determine-if-a-list-of-polygon-\n  // points-are-in-clockwise-order\n  function ringIsClockwise(ringToTest) {\n    var total = 0,i = 0;\n    var rLength = ringToTest.length;\n    var pt1 = ringToTest[i];\n    var pt2;\n    for (i; i < rLength - 1; i++) {\n      pt2 = ringToTest[i + 1];\n      total += (pt2[0] - pt1[0]) * (pt2[1] + pt1[1]);\n      pt1 = pt2;\n    }\n    return (total >= 0);\n  }\n\n  // This function ensures that rings are oriented in the right directions\n  // outer rings are clockwise, holes are counterclockwise\n  function orientRings(poly){\n    var output = [];\n    var polygon = poly.slice(0);\n    var outerRing = closeRing(polygon.shift().slice(0));\n    if(outerRing.length >= 4){\n      if(!ringIsClockwise(outerRing)){\n        outerRing.reverse();\n      }\n\n      output.push(outerRing);\n\n      for (var i = 0; i < polygon.length; i++) {\n        var hole = closeRing(polygon[i].slice(0));\n        if(hole.length >= 4){\n          if(ringIsClockwise(hole)){\n            hole.reverse();\n          }\n          output.push(hole);\n        }\n      }\n    }\n\n    return output;\n  }\n\n  // This function flattens holes in multipolygons to one array of polygons\n  // [\n  //   [\n  //     [ array of outer coordinates ]\n  //     [ hole coordinates ]\n  //     [ hole coordinates ]\n  //   ],\n  //   [\n  //     [ array of outer coordinates ]\n  //     [ hole coordinates ]\n  //     [ hole coordinates ]\n  //   ],\n  // ]\n  // becomes\n  // [\n  //   [ array of outer coordinates ]\n  //   [ hole coordinates ]\n  //   [ hole coordinates ]\n  //   [ array of outer coordinates ]\n  //   [ hole coordinates ]\n  //   [ hole coordinates ]\n  // ]\n  function flattenMultiPolygonRings(rings){\n    var output = [];\n    for (var i = 0; i < rings.length; i++) {\n      var polygon = orientRings(rings[i]);\n      for (var x = polygon.length - 1; x >= 0; x--) {\n        var ring = polygon[x].slice(0);\n        output.push(ring);\n      }\n    }\n    return output;\n  }\n\n  function coordinatesContainCoordinates(outer, inner){\n    var intersects = Terraformer.Tools.arraysIntersectArrays(outer, inner);\n    var contains = Terraformer.Tools.coordinatesContainPoint(outer, inner[0]);\n    if(!intersects && contains){\n      return true;\n    }\n    return false;\n  }\n\n  // do any polygons in this array contain any other polygons in this array?\n  // used for checking for holes in arcgis rings\n  function convertRingsToGeoJSON(rings){\n    var outerRings = [];\n    var holes = [];\n    var x; // iterator\n    var outerRing; // current outer ring being evaluated\n    var hole; // current hole being evaluated\n\n    // for each ring\n    for (var r = 0; r < rings.length; r++) {\n      var ring = closeRing(rings[r].slice(0));\n      if(ring.length < 4){\n        continue;\n      }\n      // is this ring an outer ring? is it clockwise?\n      if(ringIsClockwise(ring)){\n        var polygon = [ ring ];\n        outerRings.push(polygon); // push to outer rings\n      } else {\n        holes.push(ring); // counterclockwise push to holes\n      }\n    }\n\n    var uncontainedHoles = [];\n\n    // while there are holes left...\n    while(holes.length){\n      // pop a hole off out stack\n      hole = holes.pop();\n\n      // loop over all outer rings and see if they contain our hole.\n      var contained = false;\n      for (x = outerRings.length - 1; x >= 0; x--) {\n        outerRing = outerRings[x][0];\n        if(coordinatesContainCoordinates(outerRing, hole)){\n          // the hole is contained push it into our polygon\n          outerRings[x].push(hole);\n          contained = true;\n          break;\n        }\n      }\n\n      // ring is not contained in any outer ring\n      // sometimes this happens https://github.com/Esri/esri-leaflet/issues/320\n      if(!contained){\n        uncontainedHoles.push(hole);\n      }\n    }\n\n    // if we couldn\'t match any holes using contains we can now try intersects...\n    while(uncontainedHoles.length){\n      // pop a hole off out stack\n      hole = uncontainedHoles.pop();\n\n      // loop over all outer rings and see if any intersect our hole.\n      var intersects = false;\n      for (x = outerRings.length - 1; x >= 0; x--) {\n        outerRing = outerRings[x][0];\n        if(Terraformer.Tools.arraysIntersectArrays(outerRing, hole)){\n          // the hole intersects the outer ring push it into our polygon\n          outerRings[x].push(hole);\n          intersects = true;\n          break;\n        }\n      }\n\n      // hole does not intersect ANY outer ring at this point\n      // make it an outer ring.\n      if(!intersects) {\n        outerRings.push([hole.reverse()]);\n      }\n    }\n\n    if(outerRings.length === 1){\n      return {\n        type: \'Polygon\',\n        coordinates: outerRings[0]\n      };\n    } else {\n      return {\n        type: \'MultiPolygon\',\n        coordinates: outerRings\n      };\n    }\n  }\n\n  // ArcGIS -> GeoJSON\n  function parse(arcgis, options){\n    var geojson = {};\n\n    options = options || {};\n    options.idAttribute = options.idAttribute || undefined;\n\n    if(typeof arcgis.x === \'number\' && typeof arcgis.y === \'number\'){\n      geojson.type = "Point";\n      geojson.coordinates = [arcgis.x, arcgis.y];\n      if (arcgis.z || arcgis.m){\n        geojson.coordinates.push(arcgis.z);\n      }\n      if (arcgis.m){\n        geojson.coordinates.push(arcgis.m);\n      }\n    }\n\n    if(arcgis.points){\n      geojson.type = "MultiPoint";\n      geojson.coordinates = arcgis.points.slice(0);\n    }\n\n    if(arcgis.paths) {\n      if(arcgis.paths.length === 1){\n        geojson.type = "LineString";\n        geojson.coordinates = arcgis.paths[0].slice(0);\n      } else {\n        geojson.type = "MultiLineString";\n        geojson.coordinates = arcgis.paths.slice(0);\n      }\n    }\n\n    if(arcgis.rings) {\n      geojson = convertRingsToGeoJSON(arcgis.rings.slice(0));\n    }\n\n    if(arcgis.compressedGeometry || arcgis.geometry || arcgis.attributes) {\n      geojson.type = "Feature";\n\n      if(arcgis.compressedGeometry){\n        arcgis.geometry = {\n          paths: [\n            decompressGeometry(arcgis.compressedGeometry)\n          ]\n        };\n      }\n\n      geojson.geometry = (arcgis.geometry) ? parse(arcgis.geometry) : null;\n      geojson.properties = (arcgis.attributes) ? clone(arcgis.attributes) : null;\n      if(arcgis.attributes) {\n        geojson.id =  arcgis.attributes[options.idAttribute] || arcgis.attributes.OBJECTID || arcgis.attributes.FID;\n      }\n    }\n\n    var inputSpatialReference = (arcgis.geometry) ? arcgis.geometry.spatialReference : arcgis.spatialReference;\n\n    //convert spatial ref if needed\n    if(inputSpatialReference && inputSpatialReference.wkid === 102100){\n      geojson = Terraformer.toGeographic(geojson);\n    }\n\n    return new Terraformer.Primitive(geojson);\n  }\n\n  // GeoJSON -> ArcGIS\n  function convert(geojson, options){\n    var spatialReference;\n\n    options = options || {};\n    var idAttribute = options.idAttribute || "OBJECTID";\n\n    if(options.sr){\n      spatialReference = { wkid: options.sr };\n    } else if (geojson && geojson.crs === Terraformer.MercatorCRS) {\n      spatialReference = { wkid: 102100 };\n    } else {\n      spatialReference = { wkid: 4326 };\n    }\n\n    var result = {};\n    var i;\n\n    switch(geojson.type){\n    case "Point":\n      result.x = geojson.coordinates[0];\n      result.y = geojson.coordinates[1];\n      if(geojson.coordinates[2]) {\n        result.z = geojson.coordinates[2];\n      }\n      if(geojson.coordinates[3]) {\n        result.m = geojson.coordinates[3];\n      }\n      result.spatialReference = spatialReference;\n      break;\n    case "MultiPoint":\n      result.points = geojson.coordinates.slice(0);\n      result.spatialReference = spatialReference;\n      break;\n    case "LineString":\n      result.paths = [geojson.coordinates.slice(0)];\n      result.spatialReference = spatialReference;\n      break;\n    case "MultiLineString":\n      result.paths = geojson.coordinates.slice(0);\n      result.spatialReference = spatialReference;\n      break;\n    case "Polygon":\n      result.rings = orientRings(geojson.coordinates.slice(0));\n      result.spatialReference = spatialReference;\n      break;\n    case "MultiPolygon":\n      result.rings = flattenMultiPolygonRings(geojson.coordinates.slice(0));\n      result.spatialReference = spatialReference;\n      break;\n    case "Feature":\n      if(geojson.geometry) {\n        result.geometry = convert(geojson.geometry, options);\n      }\n      result.attributes = (geojson.properties) ? clone(geojson.properties) : {};\n      if(geojson.id) {\n        result.attributes[idAttribute] = geojson.id;\n      }\n      break;\n    case "FeatureCollection":\n      result = [];\n      for (i = 0; i < geojson.features.length; i++){\n        result.push(convert(geojson.features[i], options));\n      }\n      break;\n    case "GeometryCollection":\n      result = [];\n      for (i = 0; i < geojson.geometries.length; i++){\n        result.push(convert(geojson.geometries[i], options));\n      }\n      break;\n    }\n\n    return result;\n  }\n\n  function parseCompressedGeometry(string){\n    return new Terraformer.LineString(decompressGeometry(string));\n  }\n\n  exports.parse   = parse;\n  exports.convert = convert;\n  exports.toGeoJSON = parse;\n  exports.fromGeoJSON = convert;\n  exports.parseCompressedGeometry = parseCompressedGeometry;\n\n  return exports;\n}));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3RlcnJhZm9ybWVyLWFyY2dpcy1wYXJzZXIvdGVycmFmb3JtZXItYXJjZ2lzLXBhcnNlci5qcz9hNTU5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHFCQUFxQixvQkFBb0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Ysa0JBQWtCO0FBQ2xCLGFBQWE7O0FBRWI7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLE9BQU87QUFDUCx5QkFBeUI7QUFDekI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDLFFBQVE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQyxRQUFRO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCLEtBQUs7QUFDTCwwQkFBMEI7QUFDMUIsS0FBSztBQUNMLDBCQUEwQjtBQUMxQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDZCQUE2QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLCtCQUErQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQyIsImZpbGUiOiIxNzEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBnbG9iYWxzIFRlcnJhZm9ybWVyICovXG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblxuICAvLyBOb2RlLlxuICBpZih0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKCd0ZXJyYWZvcm1lcicpKTtcbiAgfVxuXG4gIC8vIEJyb3dzZXIgR2xvYmFsLlxuICBpZih0eXBlb2Ygcm9vdC5uYXZpZ2F0b3IgPT09IFwib2JqZWN0XCIpIHtcbiAgICBpZiAoIXJvb3QuVGVycmFmb3JtZXIpe1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGVycmFmb3JtZXIuQXJjR0lTIHJlcXVpcmVzIHRoZSBjb3JlIFRlcnJhZm9ybWVyIGxpYnJhcnkuIGh0dHBzOi8vZ2l0aHViLmNvbS9lc3JpL1RlcnJhZm9ybWVyXCIpO1xuICAgIH1cbiAgICByb290LlRlcnJhZm9ybWVyLkFyY0dJUyA9IGZhY3Rvcnkocm9vdC5UZXJyYWZvcm1lcik7XG4gIH1cblxufSh0aGlzLCBmdW5jdGlvbihUZXJyYWZvcm1lcikge1xuICB2YXIgZXhwb3J0cyA9IHt9O1xuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9Fc3JpL3RlcnJhZm9ybWVyLWFyY2dpcy1wYXJzZXIvaXNzdWVzLzEwXG4gIGZ1bmN0aW9uIGRlY29tcHJlc3NHZW9tZXRyeShzdHIpIHtcbiAgICB2YXIgeERpZmZQcmV2ID0gMDtcbiAgICB2YXIgeURpZmZQcmV2ID0gMDtcbiAgICB2YXIgcG9pbnRzID0gW107XG4gICAgdmFyIHgsIHk7XG4gICAgdmFyIHN0cmluZ3M7XG4gICAgdmFyIGNvZWZmaWNpZW50O1xuXG4gICAgLy8gU3BsaXQgdGhlIHN0cmluZyBpbnRvIGFuIGFycmF5IG9uIHRoZSArIGFuZCAtIGNoYXJhY3RlcnNcbiAgICBzdHJpbmdzID0gc3RyLm1hdGNoKC8oKFxcK3xcXC0pW15cXCtcXC1dKykvZyk7XG5cbiAgICAvLyBUaGUgZmlyc3QgdmFsdWUgaXMgdGhlIGNvZWZmaWNpZW50IGluIGJhc2UgMzJcbiAgICBjb2VmZmljaWVudCA9IHBhcnNlSW50KHN0cmluZ3NbMF0sIDMyKTtcblxuICAgIGZvciAodmFyIGogPSAxOyBqIDwgc3RyaW5ncy5sZW5ndGg7IGogKz0gMikge1xuICAgICAgLy8gaiBpcyB0aGUgb2Zmc2V0IGZvciB0aGUgeCB2YWx1ZVxuICAgICAgLy8gQ29udmVydCB0aGUgdmFsdWUgZnJvbSBiYXNlIDMyIGFuZCBhZGQgdGhlIHByZXZpb3VzIHggdmFsdWVcbiAgICAgIHggPSAocGFyc2VJbnQoc3RyaW5nc1tqXSwgMzIpICsgeERpZmZQcmV2KTtcbiAgICAgIHhEaWZmUHJldiA9IHg7XG5cbiAgICAgIC8vIGorMSBpcyB0aGUgb2Zmc2V0IGZvciB0aGUgeSB2YWx1ZVxuICAgICAgLy8gQ29udmVydCB0aGUgdmFsdWUgZnJvbSBiYXNlIDMyIGFuZCBhZGQgdGhlIHByZXZpb3VzIHkgdmFsdWVcbiAgICAgIHkgPSAocGFyc2VJbnQoc3RyaW5nc1tqICsgMV0sIDMyKSArIHlEaWZmUHJldik7XG4gICAgICB5RGlmZlByZXYgPSB5O1xuXG4gICAgICBwb2ludHMucHVzaChbeCAvIGNvZWZmaWNpZW50LCB5IC8gY29lZmZpY2llbnRdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcG9pbnRzO1xuICB9XG5cbiAgLy8gY2hlY2tzIGlmIHRoZSBmaXJzdCBhbmQgbGFzdCBwb2ludHMgb2YgYSByaW5nIGFyZSBlcXVhbCBhbmQgY2xvc2VzIHRoZSByaW5nXG4gIGZ1bmN0aW9uIGNsb3NlUmluZyhjb29yZGluYXRlcykge1xuICAgIGlmICghcG9pbnRzRXF1YWwoY29vcmRpbmF0ZXNbMF0sIGNvb3JkaW5hdGVzW2Nvb3JkaW5hdGVzLmxlbmd0aCAtIDFdKSkge1xuICAgICAgY29vcmRpbmF0ZXMucHVzaChjb29yZGluYXRlc1swXSk7XG4gICAgfVxuICAgIHJldHVybiBjb29yZGluYXRlcztcbiAgfVxuXG4gIC8vIGNoZWNrcyBpZiAyIHgseSBwb2ludHMgYXJlIGVxdWFsXG4gIGZ1bmN0aW9uIHBvaW50c0VxdWFsKGEsIGIpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBzaGFsbG93IG9iamVjdCBjbG9uZSBmb3IgZmVhdHVyZSBwcm9wZXJ0aWVzIGFuZCBhdHRyaWJ1dGVzXG4gIC8vIGZyb20gaHR0cDovL2pzcGVyZi5jb20vY2xvbmluZy1hbi1vYmplY3QvMlxuICBmdW5jdGlvbiBjbG9uZShvYmopIHtcbiAgICB2YXIgdGFyZ2V0ID0ge307XG4gICAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgdGFyZ2V0W2ldID0gb2JqW2ldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgLy8gZGV0ZXJtaW5lIGlmIHBvbHlnb24gcmluZyBjb29yZGluYXRlcyBhcmUgY2xvY2t3aXNlLiBjbG9ja3dpc2Ugc2lnbmlmaWVzIG91dGVyIHJpbmcsIGNvdW50ZXItY2xvY2t3aXNlIGFuIGlubmVyIHJpbmdcbiAgLy8gb3IgaG9sZS4gdGhpcyBsb2dpYyB3YXMgZm91bmQgYXQgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMTY1NjQ3L2hvdy10by1kZXRlcm1pbmUtaWYtYS1saXN0LW9mLXBvbHlnb24tXG4gIC8vIHBvaW50cy1hcmUtaW4tY2xvY2t3aXNlLW9yZGVyXG4gIGZ1bmN0aW9uIHJpbmdJc0Nsb2Nrd2lzZShyaW5nVG9UZXN0KSB7XG4gICAgdmFyIHRvdGFsID0gMCxpID0gMDtcbiAgICB2YXIgckxlbmd0aCA9IHJpbmdUb1Rlc3QubGVuZ3RoO1xuICAgIHZhciBwdDEgPSByaW5nVG9UZXN0W2ldO1xuICAgIHZhciBwdDI7XG4gICAgZm9yIChpOyBpIDwgckxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgcHQyID0gcmluZ1RvVGVzdFtpICsgMV07XG4gICAgICB0b3RhbCArPSAocHQyWzBdIC0gcHQxWzBdKSAqIChwdDJbMV0gKyBwdDFbMV0pO1xuICAgICAgcHQxID0gcHQyO1xuICAgIH1cbiAgICByZXR1cm4gKHRvdGFsID49IDApO1xuICB9XG5cbiAgLy8gVGhpcyBmdW5jdGlvbiBlbnN1cmVzIHRoYXQgcmluZ3MgYXJlIG9yaWVudGVkIGluIHRoZSByaWdodCBkaXJlY3Rpb25zXG4gIC8vIG91dGVyIHJpbmdzIGFyZSBjbG9ja3dpc2UsIGhvbGVzIGFyZSBjb3VudGVyY2xvY2t3aXNlXG4gIGZ1bmN0aW9uIG9yaWVudFJpbmdzKHBvbHkpe1xuICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICB2YXIgcG9seWdvbiA9IHBvbHkuc2xpY2UoMCk7XG4gICAgdmFyIG91dGVyUmluZyA9IGNsb3NlUmluZyhwb2x5Z29uLnNoaWZ0KCkuc2xpY2UoMCkpO1xuICAgIGlmKG91dGVyUmluZy5sZW5ndGggPj0gNCl7XG4gICAgICBpZighcmluZ0lzQ2xvY2t3aXNlKG91dGVyUmluZykpe1xuICAgICAgICBvdXRlclJpbmcucmV2ZXJzZSgpO1xuICAgICAgfVxuXG4gICAgICBvdXRwdXQucHVzaChvdXRlclJpbmcpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvbHlnb24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGhvbGUgPSBjbG9zZVJpbmcocG9seWdvbltpXS5zbGljZSgwKSk7XG4gICAgICAgIGlmKGhvbGUubGVuZ3RoID49IDQpe1xuICAgICAgICAgIGlmKHJpbmdJc0Nsb2Nrd2lzZShob2xlKSl7XG4gICAgICAgICAgICBob2xlLnJldmVyc2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0cHV0LnB1c2goaG9sZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG5cbiAgLy8gVGhpcyBmdW5jdGlvbiBmbGF0dGVucyBob2xlcyBpbiBtdWx0aXBvbHlnb25zIHRvIG9uZSBhcnJheSBvZiBwb2x5Z29uc1xuICAvLyBbXG4gIC8vICAgW1xuICAvLyAgICAgWyBhcnJheSBvZiBvdXRlciBjb29yZGluYXRlcyBdXG4gIC8vICAgICBbIGhvbGUgY29vcmRpbmF0ZXMgXVxuICAvLyAgICAgWyBob2xlIGNvb3JkaW5hdGVzIF1cbiAgLy8gICBdLFxuICAvLyAgIFtcbiAgLy8gICAgIFsgYXJyYXkgb2Ygb3V0ZXIgY29vcmRpbmF0ZXMgXVxuICAvLyAgICAgWyBob2xlIGNvb3JkaW5hdGVzIF1cbiAgLy8gICAgIFsgaG9sZSBjb29yZGluYXRlcyBdXG4gIC8vICAgXSxcbiAgLy8gXVxuICAvLyBiZWNvbWVzXG4gIC8vIFtcbiAgLy8gICBbIGFycmF5IG9mIG91dGVyIGNvb3JkaW5hdGVzIF1cbiAgLy8gICBbIGhvbGUgY29vcmRpbmF0ZXMgXVxuICAvLyAgIFsgaG9sZSBjb29yZGluYXRlcyBdXG4gIC8vICAgWyBhcnJheSBvZiBvdXRlciBjb29yZGluYXRlcyBdXG4gIC8vICAgWyBob2xlIGNvb3JkaW5hdGVzIF1cbiAgLy8gICBbIGhvbGUgY29vcmRpbmF0ZXMgXVxuICAvLyBdXG4gIGZ1bmN0aW9uIGZsYXR0ZW5NdWx0aVBvbHlnb25SaW5ncyhyaW5ncyl7XG4gICAgdmFyIG91dHB1dCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwb2x5Z29uID0gb3JpZW50UmluZ3MocmluZ3NbaV0pO1xuICAgICAgZm9yICh2YXIgeCA9IHBvbHlnb24ubGVuZ3RoIC0gMTsgeCA+PSAwOyB4LS0pIHtcbiAgICAgICAgdmFyIHJpbmcgPSBwb2x5Z29uW3hdLnNsaWNlKDApO1xuICAgICAgICBvdXRwdXQucHVzaChyaW5nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvb3JkaW5hdGVzQ29udGFpbkNvb3JkaW5hdGVzKG91dGVyLCBpbm5lcil7XG4gICAgdmFyIGludGVyc2VjdHMgPSBUZXJyYWZvcm1lci5Ub29scy5hcnJheXNJbnRlcnNlY3RBcnJheXMob3V0ZXIsIGlubmVyKTtcbiAgICB2YXIgY29udGFpbnMgPSBUZXJyYWZvcm1lci5Ub29scy5jb29yZGluYXRlc0NvbnRhaW5Qb2ludChvdXRlciwgaW5uZXJbMF0pO1xuICAgIGlmKCFpbnRlcnNlY3RzICYmIGNvbnRhaW5zKXtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBkbyBhbnkgcG9seWdvbnMgaW4gdGhpcyBhcnJheSBjb250YWluIGFueSBvdGhlciBwb2x5Z29ucyBpbiB0aGlzIGFycmF5P1xuICAvLyB1c2VkIGZvciBjaGVja2luZyBmb3IgaG9sZXMgaW4gYXJjZ2lzIHJpbmdzXG4gIGZ1bmN0aW9uIGNvbnZlcnRSaW5nc1RvR2VvSlNPTihyaW5ncyl7XG4gICAgdmFyIG91dGVyUmluZ3MgPSBbXTtcbiAgICB2YXIgaG9sZXMgPSBbXTtcbiAgICB2YXIgeDsgLy8gaXRlcmF0b3JcbiAgICB2YXIgb3V0ZXJSaW5nOyAvLyBjdXJyZW50IG91dGVyIHJpbmcgYmVpbmcgZXZhbHVhdGVkXG4gICAgdmFyIGhvbGU7IC8vIGN1cnJlbnQgaG9sZSBiZWluZyBldmFsdWF0ZWRcblxuICAgIC8vIGZvciBlYWNoIHJpbmdcbiAgICBmb3IgKHZhciByID0gMDsgciA8IHJpbmdzLmxlbmd0aDsgcisrKSB7XG4gICAgICB2YXIgcmluZyA9IGNsb3NlUmluZyhyaW5nc1tyXS5zbGljZSgwKSk7XG4gICAgICBpZihyaW5nLmxlbmd0aCA8IDQpe1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIGlzIHRoaXMgcmluZyBhbiBvdXRlciByaW5nPyBpcyBpdCBjbG9ja3dpc2U/XG4gICAgICBpZihyaW5nSXNDbG9ja3dpc2UocmluZykpe1xuICAgICAgICB2YXIgcG9seWdvbiA9IFsgcmluZyBdO1xuICAgICAgICBvdXRlclJpbmdzLnB1c2gocG9seWdvbik7IC8vIHB1c2ggdG8gb3V0ZXIgcmluZ3NcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhvbGVzLnB1c2gocmluZyk7IC8vIGNvdW50ZXJjbG9ja3dpc2UgcHVzaCB0byBob2xlc1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB1bmNvbnRhaW5lZEhvbGVzID0gW107XG5cbiAgICAvLyB3aGlsZSB0aGVyZSBhcmUgaG9sZXMgbGVmdC4uLlxuICAgIHdoaWxlKGhvbGVzLmxlbmd0aCl7XG4gICAgICAvLyBwb3AgYSBob2xlIG9mZiBvdXQgc3RhY2tcbiAgICAgIGhvbGUgPSBob2xlcy5wb3AoKTtcblxuICAgICAgLy8gbG9vcCBvdmVyIGFsbCBvdXRlciByaW5ncyBhbmQgc2VlIGlmIHRoZXkgY29udGFpbiBvdXIgaG9sZS5cbiAgICAgIHZhciBjb250YWluZWQgPSBmYWxzZTtcbiAgICAgIGZvciAoeCA9IG91dGVyUmluZ3MubGVuZ3RoIC0gMTsgeCA+PSAwOyB4LS0pIHtcbiAgICAgICAgb3V0ZXJSaW5nID0gb3V0ZXJSaW5nc1t4XVswXTtcbiAgICAgICAgaWYoY29vcmRpbmF0ZXNDb250YWluQ29vcmRpbmF0ZXMob3V0ZXJSaW5nLCBob2xlKSl7XG4gICAgICAgICAgLy8gdGhlIGhvbGUgaXMgY29udGFpbmVkIHB1c2ggaXQgaW50byBvdXIgcG9seWdvblxuICAgICAgICAgIG91dGVyUmluZ3NbeF0ucHVzaChob2xlKTtcbiAgICAgICAgICBjb250YWluZWQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHJpbmcgaXMgbm90IGNvbnRhaW5lZCBpbiBhbnkgb3V0ZXIgcmluZ1xuICAgICAgLy8gc29tZXRpbWVzIHRoaXMgaGFwcGVucyBodHRwczovL2dpdGh1Yi5jb20vRXNyaS9lc3JpLWxlYWZsZXQvaXNzdWVzLzMyMFxuICAgICAgaWYoIWNvbnRhaW5lZCl7XG4gICAgICAgIHVuY29udGFpbmVkSG9sZXMucHVzaChob2xlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiB3ZSBjb3VsZG4ndCBtYXRjaCBhbnkgaG9sZXMgdXNpbmcgY29udGFpbnMgd2UgY2FuIG5vdyB0cnkgaW50ZXJzZWN0cy4uLlxuICAgIHdoaWxlKHVuY29udGFpbmVkSG9sZXMubGVuZ3RoKXtcbiAgICAgIC8vIHBvcCBhIGhvbGUgb2ZmIG91dCBzdGFja1xuICAgICAgaG9sZSA9IHVuY29udGFpbmVkSG9sZXMucG9wKCk7XG5cbiAgICAgIC8vIGxvb3Agb3ZlciBhbGwgb3V0ZXIgcmluZ3MgYW5kIHNlZSBpZiBhbnkgaW50ZXJzZWN0IG91ciBob2xlLlxuICAgICAgdmFyIGludGVyc2VjdHMgPSBmYWxzZTtcbiAgICAgIGZvciAoeCA9IG91dGVyUmluZ3MubGVuZ3RoIC0gMTsgeCA+PSAwOyB4LS0pIHtcbiAgICAgICAgb3V0ZXJSaW5nID0gb3V0ZXJSaW5nc1t4XVswXTtcbiAgICAgICAgaWYoVGVycmFmb3JtZXIuVG9vbHMuYXJyYXlzSW50ZXJzZWN0QXJyYXlzKG91dGVyUmluZywgaG9sZSkpe1xuICAgICAgICAgIC8vIHRoZSBob2xlIGludGVyc2VjdHMgdGhlIG91dGVyIHJpbmcgcHVzaCBpdCBpbnRvIG91ciBwb2x5Z29uXG4gICAgICAgICAgb3V0ZXJSaW5nc1t4XS5wdXNoKGhvbGUpO1xuICAgICAgICAgIGludGVyc2VjdHMgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGhvbGUgZG9lcyBub3QgaW50ZXJzZWN0IEFOWSBvdXRlciByaW5nIGF0IHRoaXMgcG9pbnRcbiAgICAgIC8vIG1ha2UgaXQgYW4gb3V0ZXIgcmluZy5cbiAgICAgIGlmKCFpbnRlcnNlY3RzKSB7XG4gICAgICAgIG91dGVyUmluZ3MucHVzaChbaG9sZS5yZXZlcnNlKCldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZihvdXRlclJpbmdzLmxlbmd0aCA9PT0gMSl7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnUG9seWdvbicsXG4gICAgICAgIGNvb3JkaW5hdGVzOiBvdXRlclJpbmdzWzBdXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnTXVsdGlQb2x5Z29uJyxcbiAgICAgICAgY29vcmRpbmF0ZXM6IG91dGVyUmluZ3NcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgLy8gQXJjR0lTIC0+IEdlb0pTT05cbiAgZnVuY3Rpb24gcGFyc2UoYXJjZ2lzLCBvcHRpb25zKXtcbiAgICB2YXIgZ2VvanNvbiA9IHt9O1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy5pZEF0dHJpYnV0ZSA9IG9wdGlvbnMuaWRBdHRyaWJ1dGUgfHwgdW5kZWZpbmVkO1xuXG4gICAgaWYodHlwZW9mIGFyY2dpcy54ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgYXJjZ2lzLnkgPT09ICdudW1iZXInKXtcbiAgICAgIGdlb2pzb24udHlwZSA9IFwiUG9pbnRcIjtcbiAgICAgIGdlb2pzb24uY29vcmRpbmF0ZXMgPSBbYXJjZ2lzLngsIGFyY2dpcy55XTtcbiAgICAgIGlmIChhcmNnaXMueiB8fCBhcmNnaXMubSl7XG4gICAgICAgIGdlb2pzb24uY29vcmRpbmF0ZXMucHVzaChhcmNnaXMueik7XG4gICAgICB9XG4gICAgICBpZiAoYXJjZ2lzLm0pe1xuICAgICAgICBnZW9qc29uLmNvb3JkaW5hdGVzLnB1c2goYXJjZ2lzLm0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmKGFyY2dpcy5wb2ludHMpe1xuICAgICAgZ2VvanNvbi50eXBlID0gXCJNdWx0aVBvaW50XCI7XG4gICAgICBnZW9qc29uLmNvb3JkaW5hdGVzID0gYXJjZ2lzLnBvaW50cy5zbGljZSgwKTtcbiAgICB9XG5cbiAgICBpZihhcmNnaXMucGF0aHMpIHtcbiAgICAgIGlmKGFyY2dpcy5wYXRocy5sZW5ndGggPT09IDEpe1xuICAgICAgICBnZW9qc29uLnR5cGUgPSBcIkxpbmVTdHJpbmdcIjtcbiAgICAgICAgZ2VvanNvbi5jb29yZGluYXRlcyA9IGFyY2dpcy5wYXRoc1swXS5zbGljZSgwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdlb2pzb24udHlwZSA9IFwiTXVsdGlMaW5lU3RyaW5nXCI7XG4gICAgICAgIGdlb2pzb24uY29vcmRpbmF0ZXMgPSBhcmNnaXMucGF0aHMuc2xpY2UoMCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYoYXJjZ2lzLnJpbmdzKSB7XG4gICAgICBnZW9qc29uID0gY29udmVydFJpbmdzVG9HZW9KU09OKGFyY2dpcy5yaW5ncy5zbGljZSgwKSk7XG4gICAgfVxuXG4gICAgaWYoYXJjZ2lzLmNvbXByZXNzZWRHZW9tZXRyeSB8fCBhcmNnaXMuZ2VvbWV0cnkgfHwgYXJjZ2lzLmF0dHJpYnV0ZXMpIHtcbiAgICAgIGdlb2pzb24udHlwZSA9IFwiRmVhdHVyZVwiO1xuXG4gICAgICBpZihhcmNnaXMuY29tcHJlc3NlZEdlb21ldHJ5KXtcbiAgICAgICAgYXJjZ2lzLmdlb21ldHJ5ID0ge1xuICAgICAgICAgIHBhdGhzOiBbXG4gICAgICAgICAgICBkZWNvbXByZXNzR2VvbWV0cnkoYXJjZ2lzLmNvbXByZXNzZWRHZW9tZXRyeSlcbiAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGdlb2pzb24uZ2VvbWV0cnkgPSAoYXJjZ2lzLmdlb21ldHJ5KSA/IHBhcnNlKGFyY2dpcy5nZW9tZXRyeSkgOiBudWxsO1xuICAgICAgZ2VvanNvbi5wcm9wZXJ0aWVzID0gKGFyY2dpcy5hdHRyaWJ1dGVzKSA/IGNsb25lKGFyY2dpcy5hdHRyaWJ1dGVzKSA6IG51bGw7XG4gICAgICBpZihhcmNnaXMuYXR0cmlidXRlcykge1xuICAgICAgICBnZW9qc29uLmlkID0gIGFyY2dpcy5hdHRyaWJ1dGVzW29wdGlvbnMuaWRBdHRyaWJ1dGVdIHx8IGFyY2dpcy5hdHRyaWJ1dGVzLk9CSkVDVElEIHx8IGFyY2dpcy5hdHRyaWJ1dGVzLkZJRDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaW5wdXRTcGF0aWFsUmVmZXJlbmNlID0gKGFyY2dpcy5nZW9tZXRyeSkgPyBhcmNnaXMuZ2VvbWV0cnkuc3BhdGlhbFJlZmVyZW5jZSA6IGFyY2dpcy5zcGF0aWFsUmVmZXJlbmNlO1xuXG4gICAgLy9jb252ZXJ0IHNwYXRpYWwgcmVmIGlmIG5lZWRlZFxuICAgIGlmKGlucHV0U3BhdGlhbFJlZmVyZW5jZSAmJiBpbnB1dFNwYXRpYWxSZWZlcmVuY2Uud2tpZCA9PT0gMTAyMTAwKXtcbiAgICAgIGdlb2pzb24gPSBUZXJyYWZvcm1lci50b0dlb2dyYXBoaWMoZ2VvanNvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBUZXJyYWZvcm1lci5QcmltaXRpdmUoZ2VvanNvbik7XG4gIH1cblxuICAvLyBHZW9KU09OIC0+IEFyY0dJU1xuICBmdW5jdGlvbiBjb252ZXJ0KGdlb2pzb24sIG9wdGlvbnMpe1xuICAgIHZhciBzcGF0aWFsUmVmZXJlbmNlO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIGlkQXR0cmlidXRlID0gb3B0aW9ucy5pZEF0dHJpYnV0ZSB8fCBcIk9CSkVDVElEXCI7XG5cbiAgICBpZihvcHRpb25zLnNyKXtcbiAgICAgIHNwYXRpYWxSZWZlcmVuY2UgPSB7IHdraWQ6IG9wdGlvbnMuc3IgfTtcbiAgICB9IGVsc2UgaWYgKGdlb2pzb24gJiYgZ2VvanNvbi5jcnMgPT09IFRlcnJhZm9ybWVyLk1lcmNhdG9yQ1JTKSB7XG4gICAgICBzcGF0aWFsUmVmZXJlbmNlID0geyB3a2lkOiAxMDIxMDAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3BhdGlhbFJlZmVyZW5jZSA9IHsgd2tpZDogNDMyNiB9O1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICB2YXIgaTtcblxuICAgIHN3aXRjaChnZW9qc29uLnR5cGUpe1xuICAgIGNhc2UgXCJQb2ludFwiOlxuICAgICAgcmVzdWx0LnggPSBnZW9qc29uLmNvb3JkaW5hdGVzWzBdO1xuICAgICAgcmVzdWx0LnkgPSBnZW9qc29uLmNvb3JkaW5hdGVzWzFdO1xuICAgICAgaWYoZ2VvanNvbi5jb29yZGluYXRlc1syXSkge1xuICAgICAgICByZXN1bHQueiA9IGdlb2pzb24uY29vcmRpbmF0ZXNbMl07XG4gICAgICB9XG4gICAgICBpZihnZW9qc29uLmNvb3JkaW5hdGVzWzNdKSB7XG4gICAgICAgIHJlc3VsdC5tID0gZ2VvanNvbi5jb29yZGluYXRlc1szXTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5zcGF0aWFsUmVmZXJlbmNlID0gc3BhdGlhbFJlZmVyZW5jZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJNdWx0aVBvaW50XCI6XG4gICAgICByZXN1bHQucG9pbnRzID0gZ2VvanNvbi5jb29yZGluYXRlcy5zbGljZSgwKTtcbiAgICAgIHJlc3VsdC5zcGF0aWFsUmVmZXJlbmNlID0gc3BhdGlhbFJlZmVyZW5jZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJMaW5lU3RyaW5nXCI6XG4gICAgICByZXN1bHQucGF0aHMgPSBbZ2VvanNvbi5jb29yZGluYXRlcy5zbGljZSgwKV07XG4gICAgICByZXN1bHQuc3BhdGlhbFJlZmVyZW5jZSA9IHNwYXRpYWxSZWZlcmVuY2U7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiTXVsdGlMaW5lU3RyaW5nXCI6XG4gICAgICByZXN1bHQucGF0aHMgPSBnZW9qc29uLmNvb3JkaW5hdGVzLnNsaWNlKDApO1xuICAgICAgcmVzdWx0LnNwYXRpYWxSZWZlcmVuY2UgPSBzcGF0aWFsUmVmZXJlbmNlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIlBvbHlnb25cIjpcbiAgICAgIHJlc3VsdC5yaW5ncyA9IG9yaWVudFJpbmdzKGdlb2pzb24uY29vcmRpbmF0ZXMuc2xpY2UoMCkpO1xuICAgICAgcmVzdWx0LnNwYXRpYWxSZWZlcmVuY2UgPSBzcGF0aWFsUmVmZXJlbmNlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIk11bHRpUG9seWdvblwiOlxuICAgICAgcmVzdWx0LnJpbmdzID0gZmxhdHRlbk11bHRpUG9seWdvblJpbmdzKGdlb2pzb24uY29vcmRpbmF0ZXMuc2xpY2UoMCkpO1xuICAgICAgcmVzdWx0LnNwYXRpYWxSZWZlcmVuY2UgPSBzcGF0aWFsUmVmZXJlbmNlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIkZlYXR1cmVcIjpcbiAgICAgIGlmKGdlb2pzb24uZ2VvbWV0cnkpIHtcbiAgICAgICAgcmVzdWx0Lmdlb21ldHJ5ID0gY29udmVydChnZW9qc29uLmdlb21ldHJ5LCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5hdHRyaWJ1dGVzID0gKGdlb2pzb24ucHJvcGVydGllcykgPyBjbG9uZShnZW9qc29uLnByb3BlcnRpZXMpIDoge307XG4gICAgICBpZihnZW9qc29uLmlkKSB7XG4gICAgICAgIHJlc3VsdC5hdHRyaWJ1dGVzW2lkQXR0cmlidXRlXSA9IGdlb2pzb24uaWQ7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiRmVhdHVyZUNvbGxlY3Rpb25cIjpcbiAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGdlb2pzb24uZmVhdHVyZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICByZXN1bHQucHVzaChjb252ZXJ0KGdlb2pzb24uZmVhdHVyZXNbaV0sIG9wdGlvbnMpKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJHZW9tZXRyeUNvbGxlY3Rpb25cIjpcbiAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGdlb2pzb24uZ2VvbWV0cmllcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHJlc3VsdC5wdXNoKGNvbnZlcnQoZ2VvanNvbi5nZW9tZXRyaWVzW2ldLCBvcHRpb25zKSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VDb21wcmVzc2VkR2VvbWV0cnkoc3RyaW5nKXtcbiAgICByZXR1cm4gbmV3IFRlcnJhZm9ybWVyLkxpbmVTdHJpbmcoZGVjb21wcmVzc0dlb21ldHJ5KHN0cmluZykpO1xuICB9XG5cbiAgZXhwb3J0cy5wYXJzZSAgID0gcGFyc2U7XG4gIGV4cG9ydHMuY29udmVydCA9IGNvbnZlcnQ7XG4gIGV4cG9ydHMudG9HZW9KU09OID0gcGFyc2U7XG4gIGV4cG9ydHMuZnJvbUdlb0pTT04gPSBjb252ZXJ0O1xuICBleHBvcnRzLnBhcnNlQ29tcHJlc3NlZEdlb21ldHJ5ID0gcGFyc2VDb21wcmVzc2VkR2VvbWV0cnk7XG5cbiAgcmV0dXJuIGV4cG9ydHM7XG59KSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdGVycmFmb3JtZXItYXJjZ2lzLXBhcnNlci90ZXJyYWZvcm1lci1hcmNnaXMtcGFyc2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports,__webpack_require__){"use strict";eval("var require;var require;\r\n\r\n(function (f) {\r\n    if (true) {\r\n        module.exports = f();\r\n    } else if (typeof define === \"function\" && define.amd) {\r\n        define([], f);\r\n    } else {\r\n        var g;if (typeof window !== \"undefined\") {\r\n            g = window;\r\n        } else if (typeof global !== \"undefined\") {\r\n            g = global;\r\n        } else if (typeof self !== \"undefined\") {\r\n            g = self;\r\n        } else {\r\n            g = this;\r\n        }g.terraformerProj4js = f();\r\n    }\r\n})(function () {\r\n    var define, module, exports;return (function e(t, n, r) {\r\n        function s(o, u) {\r\n            if (!n[o]) {\r\n                if (!t[o]) {\r\n                    var a = typeof require == \"function\" && require;if (!u && a) return require(o, !0);if (i) return i(o, !0);var f = new Error(\"Cannot find module '\" + o + \"'\");throw (f.code = \"MODULE_NOT_FOUND\", f);\r\n                }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {\r\n                    var n = t[o][1][e];return s(n ? n : e);\r\n                }, l, l.exports, e, t, n, r);\r\n            }return n[o].exports;\r\n        }var i = typeof require == \"function\" && require;for (var o = 0; o < r.length; o++) s(r[o]);return s;\r\n    })({ 1: [function (require, module, exports) {\r\n            'use strict';\r\n            function makeConverter(Terraformer, proj4) {\r\n\r\n                // returns true if the spatial reference string is ID based and not defined in proj4\r\n                // returns false if ID based and defined, or a different projection type (like WKT).\r\n                // for now, we consider any projection string that begins with 'EPSG:' to be ID based\r\n                function invalidProjID(sr) {\r\n                    return !proj4.defs(sr) && sr.indexOf('EPSG:') === 0;\r\n                }\r\n\r\n                return function (geojson, outputSpatialReference, inputSpatialReference) {\r\n                    var inSr = inputSpatialReference;\r\n                    var outSr = outputSpatialReference;\r\n                    var urnRegex = /urn:ogc:def:crs:EPSG::(\\d+)/;\r\n\r\n                    // no supplied input SR, but geojson has SR defined\r\n                    if (!inSr && geojson.crs && geojson.crs.type === 'name') {\r\n                        var matches = geojson.crs.properties.name.match(urnRegex);\r\n                        inSr = matches ? 'EPSG:' + matches[1] : geojson.crs.properties.name;\r\n                    }\r\n\r\n                    if (!inSr) {\r\n                        inSr = 'EPSG:4326';\r\n                    } else if (invalidProjID(inSr)) {\r\n                        throw new Error('Projection: ' + inSr + ' could not be found in proj4.defs');\r\n                    }\r\n\r\n                    if (!outSr) {\r\n                        outSr = 'EPSG:4326';\r\n                        if (outSr === inSr) {\r\n                            return;\r\n                        }\r\n                    } else if (invalidProjID(outSr)) {\r\n                        throw new Error('Projection: ' + outSr + ' could not be found in proj4.defs');\r\n                    }\r\n\r\n                    var projFunc = proj4(inSr, outSr).forward;\r\n                    return Terraformer.Tools.applyConverter(geojson, projFunc);\r\n                };\r\n            }\r\n\r\n            module.exports = makeConverter;\r\n        }, {}] }, {}, [1])(1);\r\n});//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3RlcnJhZm9ybWVyLXByb2o0anMvZGlzdC90ZXJyYWZvcm1lci1wcm9qNGpzLmpzP2IzNDciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IndCQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCxjQUFjO0FBQ2Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxDQUFDO0FBQ0QsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxtQ0FBNkIsdUJBQXVCLG9EQUFvRDtBQUM1SyxpQkFBaUIsZ0JBQWdCLFlBQVksR0FBRztBQUNoRCx1Q0FBdUM7QUFDdkMsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTLGdEQUFnRCxlQUFlLGNBQWMsY0FBYztBQUNwRyxLQUFLLEdBQUc7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLElBQUksR0FBRyxJQUFJO0FBQ3BCLENBQUMiLCJmaWxlIjoiMTcyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4oZnVuY3Rpb24gKGYpIHtcclxuICAgIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmKCk7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAgICAgZGVmaW5lKFtdLCBmKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFyIGc7aWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgICAgICAgZyA9IHdpbmRvdztcclxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgICAgICAgZyA9IGdsb2JhbDtcclxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgICAgIGcgPSBzZWxmO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGcgPSB0aGlzO1xyXG4gICAgICAgIH1nLnRlcnJhZm9ybWVyUHJvajRqcyA9IGYoKTtcclxuICAgIH1cclxufSkoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGRlZmluZSwgbW9kdWxlLCBleHBvcnRzO3JldHVybiAoZnVuY3Rpb24gZSh0LCBuLCByKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gcyhvLCB1KSB7XHJcbiAgICAgICAgICAgIGlmICghbltvXSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0W29dKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSB0eXBlb2YgcmVxdWlyZSA9PSBcImZ1bmN0aW9uXCIgJiYgcmVxdWlyZTtpZiAoIXUgJiYgYSkgcmV0dXJuIGEobywgITApO2lmIChpKSByZXR1cm4gaShvLCAhMCk7dmFyIGYgPSBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiICsgbyArIFwiJ1wiKTt0aHJvdyAoZi5jb2RlID0gXCJNT0RVTEVfTk9UX0ZPVU5EXCIsIGYpO1xyXG4gICAgICAgICAgICAgICAgfXZhciBsID0gbltvXSA9IHsgZXhwb3J0czoge30gfTt0W29dWzBdLmNhbGwobC5leHBvcnRzLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gdFtvXVsxXVtlXTtyZXR1cm4gcyhuID8gbiA6IGUpO1xyXG4gICAgICAgICAgICAgICAgfSwgbCwgbC5leHBvcnRzLCBlLCB0LCBuLCByKTtcclxuICAgICAgICAgICAgfXJldHVybiBuW29dLmV4cG9ydHM7XHJcbiAgICAgICAgfXZhciBpID0gdHlwZW9mIHJlcXVpcmUgPT0gXCJmdW5jdGlvblwiICYmIHJlcXVpcmU7Zm9yICh2YXIgbyA9IDA7IG8gPCByLmxlbmd0aDsgbysrKSBzKHJbb10pO3JldHVybiBzO1xyXG4gICAgfSkoeyAxOiBbZnVuY3Rpb24gKHJlcXVpcmUsIG1vZHVsZSwgZXhwb3J0cykge1xyXG4gICAgICAgICAgICAndXNlIHN0cmljdCc7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIG1ha2VDb252ZXJ0ZXIoVGVycmFmb3JtZXIsIHByb2o0KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gcmV0dXJucyB0cnVlIGlmIHRoZSBzcGF0aWFsIHJlZmVyZW5jZSBzdHJpbmcgaXMgSUQgYmFzZWQgYW5kIG5vdCBkZWZpbmVkIGluIHByb2o0XHJcbiAgICAgICAgICAgICAgICAvLyByZXR1cm5zIGZhbHNlIGlmIElEIGJhc2VkIGFuZCBkZWZpbmVkLCBvciBhIGRpZmZlcmVudCBwcm9qZWN0aW9uIHR5cGUgKGxpa2UgV0tUKS5cclxuICAgICAgICAgICAgICAgIC8vIGZvciBub3csIHdlIGNvbnNpZGVyIGFueSBwcm9qZWN0aW9uIHN0cmluZyB0aGF0IGJlZ2lucyB3aXRoICdFUFNHOicgdG8gYmUgSUQgYmFzZWRcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGludmFsaWRQcm9qSUQoc3IpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIXByb2o0LmRlZnMoc3IpICYmIHNyLmluZGV4T2YoJ0VQU0c6JykgPT09IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChnZW9qc29uLCBvdXRwdXRTcGF0aWFsUmVmZXJlbmNlLCBpbnB1dFNwYXRpYWxSZWZlcmVuY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5TciA9IGlucHV0U3BhdGlhbFJlZmVyZW5jZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb3V0U3IgPSBvdXRwdXRTcGF0aWFsUmVmZXJlbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB1cm5SZWdleCA9IC91cm46b2djOmRlZjpjcnM6RVBTRzo6KFxcZCspLztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbm8gc3VwcGxpZWQgaW5wdXQgU1IsIGJ1dCBnZW9qc29uIGhhcyBTUiBkZWZpbmVkXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpblNyICYmIGdlb2pzb24uY3JzICYmIGdlb2pzb24uY3JzLnR5cGUgPT09ICduYW1lJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IGdlb2pzb24uY3JzLnByb3BlcnRpZXMubmFtZS5tYXRjaCh1cm5SZWdleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluU3IgPSBtYXRjaGVzID8gJ0VQU0c6JyArIG1hdGNoZXNbMV0gOiBnZW9qc29uLmNycy5wcm9wZXJ0aWVzLm5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWluU3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5TciA9ICdFUFNHOjQzMjYnO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW52YWxpZFByb2pJRChpblNyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb2plY3Rpb246ICcgKyBpblNyICsgJyBjb3VsZCBub3QgYmUgZm91bmQgaW4gcHJvajQuZGVmcycpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvdXRTcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRTciA9ICdFUFNHOjQzMjYnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3V0U3IgPT09IGluU3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW52YWxpZFByb2pJRChvdXRTcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9qZWN0aW9uOiAnICsgb3V0U3IgKyAnIGNvdWxkIG5vdCBiZSBmb3VuZCBpbiBwcm9qNC5kZWZzJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvakZ1bmMgPSBwcm9qNChpblNyLCBvdXRTcikuZm9yd2FyZDtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVGVycmFmb3JtZXIuVG9vbHMuYXBwbHlDb252ZXJ0ZXIoZ2VvanNvbiwgcHJvakZ1bmMpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBtYWtlQ29udmVydGVyO1xyXG4gICAgICAgIH0sIHt9XSB9LCB7fSwgWzFdKSgxKTtcclxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3RlcnJhZm9ybWVyLXByb2o0anMvZGlzdC90ZXJyYWZvcm1lci1wcm9qNGpzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==")},function(module,exports){eval('module.exports = {\n\t"markerSymbol": {\n\t\t"width": 16.5,\n\t\t"height": 16.5,\n\t\t"type": "esriPMS",\n\t\t"contentType": "image/png",\n\t\t"imageData": "iVBORw0KGgoAAAANSUhEUgAAABYAAAAWCAYAAADEtGw7AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAARuSURBVDiNjZVrbFRVEMd/5967e9vddbduN4WWYgXKKyVQWgIhkQBVqJIYCQZJI00UH2DiNxUUQwQNSfH1RYwghphoCIGADQk1QKqAGCKhCKTKq6GWbYHSdvve9u7ee8cP210LAjrJ+XAmM78zOf8zcxT/bROBYuDRkX03cA1ofliSeoDfBFYAz2UZemFZXsBf6De9gkvbQCJx7k7/4LAjrUAtcBBI/B/wDGBL6Zhg0cZ5E8YvKswJ+zRl4LqIOOC6xBO2fbytJ7a1oS16sSveDGwG/ngYuEJXatOnT06f9ErJuEINUYgLrosK5CDiID2d4LogLrbtyDeX7rSu/631msBHwPE0SB9dqa5Uzf4V5SWrpuXna6AQAQREyFqzGWPWAuwzR0j7Fag5EV+oPOILHGjuni5wFugYDTaB7Z8vmTFj1bSC/DQMEbRIAZ6FK9BL5qGCYVSWD4m1I4N9mZhJj3j9OR5dP3azf/LIvbtp8AulY0LPbF86c6oCBQKAt7Ia8+VN6BNKQNPA8GJMKcNTsRKUwrl6LlN9aTgreLSt37o9ZHcDjWnwpi+eLp01NdcfSAd6lq7GU7ma5C+1WF9tQC+ajnS3M7TtNZTpw1tZDeLiXGnIXEvEq+sHW3pN4IABTDR1fdyiotxwRtFIAZ4lVSRP1pI4+CW4Ltb3NSnxhgaw9n4GCOazr2KfrsNtv5FSPt8fztLV+GFHHteA4vL8kN/vNYw02CirANcl+eO3GWWlL4b0xTL7RO0OEBdj/rKMz2doRmk42wcUa0BuYcjvBVA5EczXt6aCHRtzzQeoUG7qsLlLMeZWko7LeqMGsW28i1fie2cnWngsAIU+wwtENEBERO55z/zLcT+7T3uN5IkGdLX1xZMA0tOJ9fX72KfrULqOtXsL0tsFgH3maOoNj8QN73gPpRskftpH/JO1uLHbAETjdgLo1ICmhlu9gwMJ206fajfUg9LwLHvpn+KCYVQwoy/e5esAhX26LuMbTLr2hdhQHGjSgGbLcaInWroyykjXLZLH9uBZsBzv82+isv2Yq98lq3ojKjuAWfU2nsUrsQ7twu1oy4B/vj0YsxyJAi3pW6qaOSb01qnqJ8r09HwQwXiqCu/SF0EEsZOpyg0PKEXi0C6sw7vBcUBckrYjCw83nWvsGf4Y2JdukKvtg1ZFxGcG54wNhdIt7TRdwGmoR4b60QsmgpMkWb8X67sa7PMnMi0Nws5LndE913saga2MamkHuFjf3DF/dn4oUJzj86eTJN6He+08+pRypC+G9f221JwYNU+ORHs71v0avQxsANrh7unWJXBj/6Wb08LZHr00LxjU0nNDBOfyWewLJ2E4nqnSdlzZ+eed6NpTNy4LfEhqunEvGOAvoOFoc+fkuusdw3l+0ygMmKZXUxrDccRKQQcs2z7S2tO55vj1K3uaYo3A+tFQePDX5CH1NS03dTV+dl7Q91jANAWXaH/C+r2jPz6i/g8jK3kv4EHg0VYETOHuz/Qq0PKwpL8BL8EAdKaMj7AAAAAASUVORK5CYII="\n\t}\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZGVmYXVsdEhpbGlnaHRTeW1ib2xzLmpzb24/NzQ2NiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTczLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSB7XG5cdFwibWFya2VyU3ltYm9sXCI6IHtcblx0XHRcIndpZHRoXCI6IDE2LjUsXG5cdFx0XCJoZWlnaHRcIjogMTYuNSxcblx0XHRcInR5cGVcIjogXCJlc3JpUE1TXCIsXG5cdFx0XCJjb250ZW50VHlwZVwiOiBcImltYWdlL3BuZ1wiLFxuXHRcdFwiaW1hZ2VEYXRhXCI6IFwiaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUJZQUFBQVdDQVlBQUFERXRHdzdBQUFBQkhOQ1NWUUlDQWdJZkFoa2lBQUFBQWx3U0ZsekFBQU4xd0FBRGRjQlFpaWJlQUFBQUJsMFJWaDBVMjltZEhkaGNtVUFkM2QzTG1sdWEzTmpZWEJsTG05eVo1dnVQQm9BQUFSdVNVUkJWRGlOalpWcmJGUlZFTWQvNTk2N2U5dmRkYmR1TjRXV1lnWEtLeVZRV2dJaGtRQlZxSklZQ1FaSkkwMFVIMkRpTnhVVVF3UU5TZkgxUll3Z2hwaG9DSUdBRFFrMVFLcUFHQ0toQ0tUS3E2R1diWUhTZHZ2ZTl1N2VlOGNQMjEwTEFqckorWEFtTTc4ek9mOHpjeFQvYlJPQll1RFJrWDAzY0Exb2ZsaVNlb0RmQkZZQXoyVVplbUZaWHNCZjZEZTlna3ZiUUNKeDdrNy80TEFqclVBdGNCQkkvQi93REdCTDZaaGcwY1o1RThZdktzd0orelJsNExxSU9PQzZ4Qk8yZmJ5dEo3YTFvUzE2c1N2ZURHd0cvbmdZdUVKWGF0T25UMDZmOUVySnVFSU5VWWdMcm9zSzVDRGlJRDJkNExvZ0xyYnR5RGVYN3JTdS82MzFtc0JId1BFMFNCOWRxYTVVemY0VjVTV3JwdVhuYTZBUUFRUkV5RnF6R1dQV0F1d3pSMGo3RmFnNUVWK29QT0lMSEdqdW5pNXdGdWdZRFRhQjdaOHZtVEZqMWJTQy9EUU1FYlJJQVo2Rks5Qkw1cUdDWVZTV0Q0bTFJNE45bVpoSmozajlPUjVkUDNhemYvTEl2YnRwOEF1bFkwTFBiRjg2YzZvQ0JRS0F0N0lhOCtWTjZCTktRTlBBOEdKTUtjTlRzUktVd3JsNkxsTjlhVGdyZUxTdDM3bzlaSGNEaldud3BpK2VMcDAxTmRjZlNBZDZscTdHVTdtYTVDKzFXRjl0UUMrYWpuUzNNN1R0TlpUcHcxdFpEZUxpWEduSVhFdkVxK3NIVzNwTjRJQUJURFIxZmR5aW90eHdSdEZJQVo0bFZTUlAxcEk0K0NXNEx0YjNOU254aGdhdzluNEdDT2F6cjJLZnJzTnR2NUZTUHQ4Znp0TFYrR0ZISHRlQTR2TDhrTi92Tll3MDJDaXJBTmNsK2VPM0dXV2xMNGIweFRMN1JPME9FQmRqL3JLTXoyZG9SbWs0MndjVWEwQnVZY2p2QlZBNUVjelh0NmFDSFJ0enpRZW9VRzdxc0xsTE1lWldrbzdMZXFNR3NXMjhpMWZpZTJjblduZ3NBSVUrd3d0RU5FQkVSTzU1ei96TGNUKzdUM3VONUlrR2RMWDF4Wk1BMHRPSjlmWDcyS2ZyVUxxT3RYc0wwdHNGZ0gzbWFPb05qOFFONzNnUHBSc2tmdHBIL0pPMXVMSGJBRVRqZGdMbzFJQ21obHU5Z3dNSjIwNmZhamZVZzlMd0xIdnBuK0tDWVZRd295L2U1ZXNBaFgyNkx1TWJUTHIyaGRoUUhHalNnR2JMY2FJbldyb3l5a2pYTFpMSDl1QlpzQnp2ODIraXN2MllxOThscTNvaktqdUFXZlUybnNVcnNRN3R3dTFveTRCL3ZqMFlzeHlKQWkzcFc2cWFPU2IwMXFucUo4cjA5SHdRd1hpcUN1L1NGMEVFc1pPcHlnMFBLRVhpMEM2c3c3dkJjVUJja3JZakN3ODNuV3ZzR2Y0WTJKZHVrS3Z0ZzFaRnhHY0c1NHdOaGRJdDdUUmR3R21vUjRiNjBRc21ncE1rV2I4WDY3c2E3UE1uTWkwTndzNUxuZEU5MTNzYWdhMk1hbWtIdUZqZjNERi9kbjRvVUp6ajg2ZVRKTjZIZSswOCtwUnlwQytHOWYyMjFKd1lOVStPUkhzNzF2MGF2UXhzQU5yaDd1bldKWEJqLzZXYjA4TFpIcjAwTHhqVTBuTkRCT2Z5V2V3TEoyRTRucW5TZGx6WitlZWQ2TnBUTnk0TGZFaHF1bkV2R09Bdm9PRm9jK2ZrdXVzZHczbCsweWdNbUtaWFV4ckRjY1JLUVFjczJ6N1MydE81NXZqMUszdWFZbzNBK3RGUWVQRFg1Q0gxTlMwM2RUVitkbDdROTFqQU5BV1hhSC9DK3IyalB6NmkvZzhqSzNrdjRFSGcwVllFVE9IdXovUXEwUEt3cEw4Qkw4RUFkS2FNajdBQUFBQUFTVVZPUks1Q1lJST1cIlxuXHR9XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2RlZmF1bHRIaWxpZ2h0U3ltYm9scy5qc29uXG4vLyBtb2R1bGUgaWQgPSAxNzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports){eval('module.exports = [\n\t"4326",\n\t"4269",\n\t"4258",\n\t"31467",\n\t"31468",\n\t"31469",\n\t"2166",\n\t"2167",\n\t"2168",\n\t"2036",\n\t"2044",\n\t"2045",\n\t"2065",\n\t"2081",\n\t"2082",\n\t"2083",\n\t"2085",\n\t"2086",\n\t"2091",\n\t"2092",\n\t"2093",\n\t"2096",\n\t"2097",\n\t"2098",\n\t"2105",\n\t"2106",\n\t"2107",\n\t"2108",\n\t"2109",\n\t"2110",\n\t"2111",\n\t"2112",\n\t"2113",\n\t"2114",\n\t"2115",\n\t"2116",\n\t"2117",\n\t"2118",\n\t"2119",\n\t"2120",\n\t"2121",\n\t"2122",\n\t"2123",\n\t"2124",\n\t"2125",\n\t"2126",\n\t"2127",\n\t"2128",\n\t"2129",\n\t"2130",\n\t"2131",\n\t"2132",\n\t"2169",\n\t"2170",\n\t"2171",\n\t"2172",\n\t"2173",\n\t"2174",\n\t"2175",\n\t"2176",\n\t"2177",\n\t"2178",\n\t"2179",\n\t"2180",\n\t"2193",\n\t"2199",\n\t"2200",\n\t"2206",\n\t"2207",\n\t"2208",\n\t"2209",\n\t"2210",\n\t"2211",\n\t"2212",\n\t"2319",\n\t"2320",\n\t"2321",\n\t"2322",\n\t"2323",\n\t"2324",\n\t"2325",\n\t"2326",\n\t"2327",\n\t"2328",\n\t"2329",\n\t"2330",\n\t"2331",\n\t"2332",\n\t"2333",\n\t"2334",\n\t"2335",\n\t"2336",\n\t"2337",\n\t"2338",\n\t"2339",\n\t"2340",\n\t"2341",\n\t"2342",\n\t"2343",\n\t"2344",\n\t"2345",\n\t"2346",\n\t"2347",\n\t"2348",\n\t"2349",\n\t"2350",\n\t"2351",\n\t"2352",\n\t"2353",\n\t"2354",\n\t"2355",\n\t"2356",\n\t"2357",\n\t"2358",\n\t"2359",\n\t"2360",\n\t"2361",\n\t"2362",\n\t"2363",\n\t"2364",\n\t"2365",\n\t"2366",\n\t"2367",\n\t"2368",\n\t"2369",\n\t"2370",\n\t"2371",\n\t"2372",\n\t"2373",\n\t"2374",\n\t"2375",\n\t"2376",\n\t"2377",\n\t"2378",\n\t"2379",\n\t"2380",\n\t"2381",\n\t"2382",\n\t"2383",\n\t"2384",\n\t"2385",\n\t"2386",\n\t"2387",\n\t"2388",\n\t"2389",\n\t"2390",\n\t"2391",\n\t"2392",\n\t"2393",\n\t"2394",\n\t"2395",\n\t"2396",\n\t"2397",\n\t"2398",\n\t"2399",\n\t"2400",\n\t"2401",\n\t"2402",\n\t"2403",\n\t"2404",\n\t"2405",\n\t"2406",\n\t"2407",\n\t"2408",\n\t"2409",\n\t"2410",\n\t"2411",\n\t"2412",\n\t"2413",\n\t"2414",\n\t"2415",\n\t"2416",\n\t"2417",\n\t"2418",\n\t"2419",\n\t"2420",\n\t"2421",\n\t"2422",\n\t"2423",\n\t"2424",\n\t"2425",\n\t"2426",\n\t"2427",\n\t"2428",\n\t"2429",\n\t"2430",\n\t"2431",\n\t"2432",\n\t"2433",\n\t"2434",\n\t"2435",\n\t"2436",\n\t"2437",\n\t"2438",\n\t"2439",\n\t"2440",\n\t"2441",\n\t"2442",\n\t"2443",\n\t"2444",\n\t"2445",\n\t"2446",\n\t"2447",\n\t"2448",\n\t"2449",\n\t"2450",\n\t"2451",\n\t"2452",\n\t"2453",\n\t"2454",\n\t"2455",\n\t"2456",\n\t"2457",\n\t"2458",\n\t"2459",\n\t"2460",\n\t"2461",\n\t"2462",\n\t"2463",\n\t"2464",\n\t"2465",\n\t"2466",\n\t"2467",\n\t"2468",\n\t"2469",\n\t"2470",\n\t"2471",\n\t"2472",\n\t"2473",\n\t"2474",\n\t"2475",\n\t"2476",\n\t"2477",\n\t"2478",\n\t"2479",\n\t"2480",\n\t"2481",\n\t"2482",\n\t"2483",\n\t"2484",\n\t"2485",\n\t"2486",\n\t"2487",\n\t"2488",\n\t"2489",\n\t"2490",\n\t"2491",\n\t"2492",\n\t"2493",\n\t"2494",\n\t"2495",\n\t"2496",\n\t"2497",\n\t"2498",\n\t"2499",\n\t"2500",\n\t"2501",\n\t"2502",\n\t"2503",\n\t"2504",\n\t"2505",\n\t"2506",\n\t"2507",\n\t"2508",\n\t"2509",\n\t"2510",\n\t"2511",\n\t"2512",\n\t"2513",\n\t"2514",\n\t"2515",\n\t"2516",\n\t"2517",\n\t"2518",\n\t"2519",\n\t"2520",\n\t"2521",\n\t"2522",\n\t"2523",\n\t"2524",\n\t"2525",\n\t"2526",\n\t"2527",\n\t"2528",\n\t"2529",\n\t"2530",\n\t"2531",\n\t"2532",\n\t"2533",\n\t"2534",\n\t"2535",\n\t"2536",\n\t"2537",\n\t"2538",\n\t"2539",\n\t"2540",\n\t"2541",\n\t"2542",\n\t"2543",\n\t"2544",\n\t"2545",\n\t"2546",\n\t"2547",\n\t"2548",\n\t"2549",\n\t"2551",\n\t"2552",\n\t"2553",\n\t"2554",\n\t"2555",\n\t"2556",\n\t"2557",\n\t"2558",\n\t"2559",\n\t"2560",\n\t"2561",\n\t"2562",\n\t"2563",\n\t"2564",\n\t"2565",\n\t"2566",\n\t"2567",\n\t"2568",\n\t"2569",\n\t"2570",\n\t"2571",\n\t"2572",\n\t"2573",\n\t"2574",\n\t"2575",\n\t"2576",\n\t"2577",\n\t"2578",\n\t"2579",\n\t"2580",\n\t"2581",\n\t"2582",\n\t"2583",\n\t"2584",\n\t"2585",\n\t"2586",\n\t"2587",\n\t"2588",\n\t"2589",\n\t"2590",\n\t"2591",\n\t"2592",\n\t"2593",\n\t"2594",\n\t"2595",\n\t"2596",\n\t"2597",\n\t"2598",\n\t"2599",\n\t"2600",\n\t"2601",\n\t"2602",\n\t"2603",\n\t"2604",\n\t"2605",\n\t"2606",\n\t"2607",\n\t"2608",\n\t"2609",\n\t"2610",\n\t"2611",\n\t"2612",\n\t"2613",\n\t"2614",\n\t"2615",\n\t"2616",\n\t"2617",\n\t"2618",\n\t"2619",\n\t"2620",\n\t"2621",\n\t"2622",\n\t"2623",\n\t"2624",\n\t"2625",\n\t"2626",\n\t"2627",\n\t"2628",\n\t"2629",\n\t"2630",\n\t"2631",\n\t"2632",\n\t"2633",\n\t"2634",\n\t"2635",\n\t"2636",\n\t"2637",\n\t"2638",\n\t"2639",\n\t"2640",\n\t"2641",\n\t"2642",\n\t"2643",\n\t"2644",\n\t"2645",\n\t"2646",\n\t"2647",\n\t"2648",\n\t"2649",\n\t"2650",\n\t"2651",\n\t"2652",\n\t"2653",\n\t"2654",\n\t"2655",\n\t"2656",\n\t"2657",\n\t"2658",\n\t"2659",\n\t"2660",\n\t"2661",\n\t"2662",\n\t"2663",\n\t"2664",\n\t"2665",\n\t"2666",\n\t"2667",\n\t"2668",\n\t"2669",\n\t"2670",\n\t"2671",\n\t"2672",\n\t"2673",\n\t"2674",\n\t"2675",\n\t"2676",\n\t"2677",\n\t"2678",\n\t"2679",\n\t"2680",\n\t"2681",\n\t"2682",\n\t"2683",\n\t"2684",\n\t"2685",\n\t"2686",\n\t"2687",\n\t"2688",\n\t"2689",\n\t"2690",\n\t"2691",\n\t"2692",\n\t"2693",\n\t"2694",\n\t"2695",\n\t"2696",\n\t"2697",\n\t"2698",\n\t"2699",\n\t"2700",\n\t"2701",\n\t"2702",\n\t"2703",\n\t"2704",\n\t"2705",\n\t"2706",\n\t"2707",\n\t"2708",\n\t"2709",\n\t"2710",\n\t"2711",\n\t"2712",\n\t"2713",\n\t"2714",\n\t"2715",\n\t"2716",\n\t"2717",\n\t"2718",\n\t"2719",\n\t"2720",\n\t"2721",\n\t"2722",\n\t"2723",\n\t"2724",\n\t"2725",\n\t"2726",\n\t"2727",\n\t"2728",\n\t"2729",\n\t"2730",\n\t"2731",\n\t"2732",\n\t"2733",\n\t"2734",\n\t"2735",\n\t"2738",\n\t"2739",\n\t"2740",\n\t"2741",\n\t"2742",\n\t"2743",\n\t"2744",\n\t"2745",\n\t"2746",\n\t"2747",\n\t"2748",\n\t"2749",\n\t"2750",\n\t"2751",\n\t"2752",\n\t"2753",\n\t"2754",\n\t"2755",\n\t"2756",\n\t"2757",\n\t"2758",\n\t"2935",\n\t"2936",\n\t"2937",\n\t"2938",\n\t"2939",\n\t"2940",\n\t"2941",\n\t"2953",\n\t"2963",\n\t"3006",\n\t"3007",\n\t"3008",\n\t"3009",\n\t"3010",\n\t"3011",\n\t"3012",\n\t"3013",\n\t"3014",\n\t"3015",\n\t"3016",\n\t"3017",\n\t"3018",\n\t"3019",\n\t"3020",\n\t"3021",\n\t"3022",\n\t"3023",\n\t"3024",\n\t"3025",\n\t"3026",\n\t"3027",\n\t"3028",\n\t"3029",\n\t"3030",\n\t"3034",\n\t"3035",\n\t"3038",\n\t"3039",\n\t"3040",\n\t"3041",\n\t"3042",\n\t"3043",\n\t"3044",\n\t"3045",\n\t"3046",\n\t"3047",\n\t"3048",\n\t"3049",\n\t"3050",\n\t"3051",\n\t"3058",\n\t"3059",\n\t"3068",\n\t"3114",\n\t"3115",\n\t"3116",\n\t"3117",\n\t"3118",\n\t"3120",\n\t"3126",\n\t"3127",\n\t"3128",\n\t"3129",\n\t"3130",\n\t"3131",\n\t"3132",\n\t"3133",\n\t"3134",\n\t"3135",\n\t"3136",\n\t"3137",\n\t"3138",\n\t"3139",\n\t"3140",\n\t"3146",\n\t"3147",\n\t"3150",\n\t"3151",\n\t"3152",\n\t"3300",\n\t"3301",\n\t"3328",\n\t"3329",\n\t"3330",\n\t"3331",\n\t"3332",\n\t"3333",\n\t"3334",\n\t"3335",\n\t"3346",\n\t"3350",\n\t"3351",\n\t"3352",\n\t"3366",\n\t"3386",\n\t"3387",\n\t"3388",\n\t"3389",\n\t"3390",\n\t"3396",\n\t"3397",\n\t"3398",\n\t"3399",\n\t"3407",\n\t"3414",\n\t"3416",\n\t"3764",\n\t"3788",\n\t"3789",\n\t"3790",\n\t"3791",\n\t"3793",\n\t"3795",\n\t"3796",\n\t"3819",\n\t"3821",\n\t"3823",\n\t"3824",\n\t"3833",\n\t"3834",\n\t"3835",\n\t"3836",\n\t"3837",\n\t"3838",\n\t"3839",\n\t"3840",\n\t"3841",\n\t"3842",\n\t"3843",\n\t"3844",\n\t"3845",\n\t"3846",\n\t"3847",\n\t"3848",\n\t"3849",\n\t"3850",\n\t"3851",\n\t"3852",\n\t"3854",\n\t"3873",\n\t"3874",\n\t"3875",\n\t"3876",\n\t"3877",\n\t"3878",\n\t"3879",\n\t"3880",\n\t"3881",\n\t"3882",\n\t"3883",\n\t"3884",\n\t"3885",\n\t"3888",\n\t"3889",\n\t"3906",\n\t"3907",\n\t"3908",\n\t"3909",\n\t"3910",\n\t"3911",\n\t"4001",\n\t"4002",\n\t"4003",\n\t"4004",\n\t"4005",\n\t"4006",\n\t"4007",\n\t"4008",\n\t"4009",\n\t"4010",\n\t"4011",\n\t"4012",\n\t"4013",\n\t"4014",\n\t"4015",\n\t"4016",\n\t"4017",\n\t"4018",\n\t"4019",\n\t"4020",\n\t"4021",\n\t"4022",\n\t"4023",\n\t"4024",\n\t"4025",\n\t"4026",\n\t"4027",\n\t"4028",\n\t"4029",\n\t"4030",\n\t"4031",\n\t"4032",\n\t"4033",\n\t"4034",\n\t"4035",\n\t"4036",\n\t"4037",\n\t"4038",\n\t"4040",\n\t"4041",\n\t"4042",\n\t"4043",\n\t"4044",\n\t"4045",\n\t"4046",\n\t"4047",\n\t"4052",\n\t"4053",\n\t"4054",\n\t"4055",\n\t"4074",\n\t"4075",\n\t"4080",\n\t"4081",\n\t"4120",\n\t"4121",\n\t"4122",\n\t"4123",\n\t"4124",\n\t"4125",\n\t"4126",\n\t"4127",\n\t"4128",\n\t"4129",\n\t"4130",\n\t"4131",\n\t"4132",\n\t"4133",\n\t"4134",\n\t"4135",\n\t"4136",\n\t"4137",\n\t"4138",\n\t"4139",\n\t"4140",\n\t"4141",\n\t"4142",\n\t"4143",\n\t"4144",\n\t"4145",\n\t"4146",\n\t"4147",\n\t"4148",\n\t"4149",\n\t"4150",\n\t"4151",\n\t"4152",\n\t"4153",\n\t"4154",\n\t"4155",\n\t"4156",\n\t"4157",\n\t"4158",\n\t"4159",\n\t"4160",\n\t"4161",\n\t"4162",\n\t"4163",\n\t"4164",\n\t"4165",\n\t"4166",\n\t"4167",\n\t"4168",\n\t"4169",\n\t"4170",\n\t"4171",\n\t"4172",\n\t"4173",\n\t"4174",\n\t"4175",\n\t"4176",\n\t"4178",\n\t"4179",\n\t"4180",\n\t"4181",\n\t"4182",\n\t"4183",\n\t"4184",\n\t"4185",\n\t"4188",\n\t"4189",\n\t"4190",\n\t"4191",\n\t"4192",\n\t"4193",\n\t"4194",\n\t"4195",\n\t"4196",\n\t"4197",\n\t"4198",\n\t"4199",\n\t"4200",\n\t"4201",\n\t"4202",\n\t"4203",\n\t"4204",\n\t"4205",\n\t"4206",\n\t"4207",\n\t"4208",\n\t"4209",\n\t"4210",\n\t"4211",\n\t"4212",\n\t"4213",\n\t"4214",\n\t"4215",\n\t"4216",\n\t"4218",\n\t"4219",\n\t"4220",\n\t"4221",\n\t"4222",\n\t"4223",\n\t"4224",\n\t"4225",\n\t"4226",\n\t"4227",\n\t"4228",\n\t"4229",\n\t"4230",\n\t"4231",\n\t"4232",\n\t"4233",\n\t"4234",\n\t"4235",\n\t"4236",\n\t"4237",\n\t"4238",\n\t"4239",\n\t"4240",\n\t"4241",\n\t"4242",\n\t"4243",\n\t"4244",\n\t"4245",\n\t"4246",\n\t"4247",\n\t"4248",\n\t"4249",\n\t"4250",\n\t"4251",\n\t"4252",\n\t"4253",\n\t"4254",\n\t"4255",\n\t"4256",\n\t"4257",\n\t"4259",\n\t"4260",\n\t"4261",\n\t"4262",\n\t"4263",\n\t"4264",\n\t"4265",\n\t"4266",\n\t"4267",\n\t"4268",\n\t"4270",\n\t"4271",\n\t"4272",\n\t"4273",\n\t"4274",\n\t"4275",\n\t"4276",\n\t"4277",\n\t"4278",\n\t"4279",\n\t"4280",\n\t"4281",\n\t"4282",\n\t"4283",\n\t"4284",\n\t"4285",\n\t"4286",\n\t"4287",\n\t"4288",\n\t"4289",\n\t"4291",\n\t"4292",\n\t"4293",\n\t"4294",\n\t"4295",\n\t"4296",\n\t"4297",\n\t"4298",\n\t"4299",\n\t"4300",\n\t"4301",\n\t"4302",\n\t"4303",\n\t"4304",\n\t"4306",\n\t"4307",\n\t"4308",\n\t"4309",\n\t"4310",\n\t"4311",\n\t"4312",\n\t"4313",\n\t"4314",\n\t"4315",\n\t"4316",\n\t"4317",\n\t"4318",\n\t"4319",\n\t"4322",\n\t"4324",\n\t"4327",\n\t"4329",\n\t"4339",\n\t"4341",\n\t"4343",\n\t"4345",\n\t"4347",\n\t"4349",\n\t"4351",\n\t"4353",\n\t"4355",\n\t"4357",\n\t"4359",\n\t"4361",\n\t"4363",\n\t"4365",\n\t"4367",\n\t"4369",\n\t"4371",\n\t"4373",\n\t"4375",\n\t"4377",\n\t"4379",\n\t"4381",\n\t"4383",\n\t"4386",\n\t"4388",\n\t"4417",\n\t"4434",\n\t"4463",\n\t"4466",\n\t"4469",\n\t"4470",\n\t"4472",\n\t"4475",\n\t"4480",\n\t"4482",\n\t"4483",\n\t"4490",\n\t"4491",\n\t"4492",\n\t"4493",\n\t"4494",\n\t"4495",\n\t"4496",\n\t"4497",\n\t"4498",\n\t"4499",\n\t"4500",\n\t"4501",\n\t"4502",\n\t"4503",\n\t"4504",\n\t"4505",\n\t"4506",\n\t"4507",\n\t"4508",\n\t"4509",\n\t"4510",\n\t"4511",\n\t"4512",\n\t"4513",\n\t"4514",\n\t"4515",\n\t"4516",\n\t"4517",\n\t"4518",\n\t"4519",\n\t"4520",\n\t"4521",\n\t"4522",\n\t"4523",\n\t"4524",\n\t"4525",\n\t"4526",\n\t"4527",\n\t"4528",\n\t"4529",\n\t"4530",\n\t"4531",\n\t"4532",\n\t"4533",\n\t"4534",\n\t"4535",\n\t"4536",\n\t"4537",\n\t"4538",\n\t"4539",\n\t"4540",\n\t"4541",\n\t"4542",\n\t"4543",\n\t"4544",\n\t"4545",\n\t"4546",\n\t"4547",\n\t"4548",\n\t"4549",\n\t"4550",\n\t"4551",\n\t"4552",\n\t"4553",\n\t"4554",\n\t"4555",\n\t"4557",\n\t"4558",\n\t"4568",\n\t"4569",\n\t"4570",\n\t"4571",\n\t"4572",\n\t"4573",\n\t"4574",\n\t"4575",\n\t"4576",\n\t"4577",\n\t"4578",\n\t"4579",\n\t"4580",\n\t"4581",\n\t"4582",\n\t"4583",\n\t"4584",\n\t"4585",\n\t"4586",\n\t"4587",\n\t"4588",\n\t"4589",\n\t"4600",\n\t"4601",\n\t"4602",\n\t"4603",\n\t"4604",\n\t"4605",\n\t"4606",\n\t"4607",\n\t"4608",\n\t"4609",\n\t"4610",\n\t"4611",\n\t"4612",\n\t"4613",\n\t"4614",\n\t"4615",\n\t"4616",\n\t"4617",\n\t"4618",\n\t"4619",\n\t"4620",\n\t"4621",\n\t"4622",\n\t"4623",\n\t"4624",\n\t"4625",\n\t"4626",\n\t"4627",\n\t"4628",\n\t"4629",\n\t"4630",\n\t"4631",\n\t"4632",\n\t"4633",\n\t"4634",\n\t"4635",\n\t"4636",\n\t"4637",\n\t"4638",\n\t"4639",\n\t"4640",\n\t"4641",\n\t"4642",\n\t"4643",\n\t"4644",\n\t"4645",\n\t"4646",\n\t"4652",\n\t"4653",\n\t"4654",\n\t"4655",\n\t"4656",\n\t"4657",\n\t"4658",\n\t"4659",\n\t"4660",\n\t"4661",\n\t"4662",\n\t"4663",\n\t"4664",\n\t"4665",\n\t"4666",\n\t"4667",\n\t"4668",\n\t"4669",\n\t"4670",\n\t"4671",\n\t"4672",\n\t"4673",\n\t"4674",\n\t"4675",\n\t"4676",\n\t"4677",\n\t"4678",\n\t"4679",\n\t"4680",\n\t"4681",\n\t"4682",\n\t"4683",\n\t"4684",\n\t"4685",\n\t"4686",\n\t"4687",\n\t"4688",\n\t"4689",\n\t"4690",\n\t"4691",\n\t"4692",\n\t"4693",\n\t"4694",\n\t"4695",\n\t"4696",\n\t"4697",\n\t"4698",\n\t"4699",\n\t"4700",\n\t"4701",\n\t"4702",\n\t"4703",\n\t"4704",\n\t"4705",\n\t"4706",\n\t"4707",\n\t"4708",\n\t"4709",\n\t"4710",\n\t"4711",\n\t"4712",\n\t"4713",\n\t"4714",\n\t"4715",\n\t"4716",\n\t"4717",\n\t"4718",\n\t"4719",\n\t"4720",\n\t"4721",\n\t"4722",\n\t"4723",\n\t"4724",\n\t"4725",\n\t"4726",\n\t"4727",\n\t"4728",\n\t"4729",\n\t"4730",\n\t"4731",\n\t"4732",\n\t"4733",\n\t"4734",\n\t"4735",\n\t"4736",\n\t"4737",\n\t"4738",\n\t"4739",\n\t"4740",\n\t"4741",\n\t"4742",\n\t"4743",\n\t"4744",\n\t"4745",\n\t"4746",\n\t"4747",\n\t"4748",\n\t"4749",\n\t"4750",\n\t"4751",\n\t"4752",\n\t"4753",\n\t"4754",\n\t"4755",\n\t"4756",\n\t"4757",\n\t"4758",\n\t"4759",\n\t"4760",\n\t"4761",\n\t"4762",\n\t"4763",\n\t"4764",\n\t"4765",\n\t"4766",\n\t"4767",\n\t"4768",\n\t"4769",\n\t"4770",\n\t"4771",\n\t"4772",\n\t"4773",\n\t"4774",\n\t"4775",\n\t"4776",\n\t"4777",\n\t"4778",\n\t"4779",\n\t"4780",\n\t"4781",\n\t"4782",\n\t"4783",\n\t"4784",\n\t"4785",\n\t"4786",\n\t"4787",\n\t"4788",\n\t"4789",\n\t"4790",\n\t"4791",\n\t"4792",\n\t"4793",\n\t"4794",\n\t"4795",\n\t"4796",\n\t"4797",\n\t"4798",\n\t"4799",\n\t"4800",\n\t"4801",\n\t"4802",\n\t"4803",\n\t"4804",\n\t"4805",\n\t"4806",\n\t"4807",\n\t"4808",\n\t"4809",\n\t"4810",\n\t"4811",\n\t"4812",\n\t"4813",\n\t"4814",\n\t"4815",\n\t"4816",\n\t"4817",\n\t"4818",\n\t"4819",\n\t"4820",\n\t"4821",\n\t"4822",\n\t"4823",\n\t"4824",\n\t"4839",\n\t"4855",\n\t"4856",\n\t"4857",\n\t"4858",\n\t"4859",\n\t"4860",\n\t"4861",\n\t"4862",\n\t"4863",\n\t"4864",\n\t"4865",\n\t"4866",\n\t"4867",\n\t"4868",\n\t"4869",\n\t"4870",\n\t"4871",\n\t"4872",\n\t"4873",\n\t"4874",\n\t"4875",\n\t"4876",\n\t"4877",\n\t"4878",\n\t"4879",\n\t"4880",\n\t"4883",\n\t"4885",\n\t"4887",\n\t"4889",\n\t"4891",\n\t"4893",\n\t"4895",\n\t"4898",\n\t"4900",\n\t"4901",\n\t"4902",\n\t"4903",\n\t"4904",\n\t"4907",\n\t"4909",\n\t"4921",\n\t"4923",\n\t"4925",\n\t"4927",\n\t"4929",\n\t"4931",\n\t"4933",\n\t"4935",\n\t"4937",\n\t"4939",\n\t"4941",\n\t"4943",\n\t"4945",\n\t"4947",\n\t"4949",\n\t"4951",\n\t"4953",\n\t"4955",\n\t"4957",\n\t"4959",\n\t"4961",\n\t"4963",\n\t"4965",\n\t"4967",\n\t"4969",\n\t"4971",\n\t"4973",\n\t"4975",\n\t"4977",\n\t"4979",\n\t"4981",\n\t"4983",\n\t"4985",\n\t"4987",\n\t"4989",\n\t"4991",\n\t"4993",\n\t"4995",\n\t"4997",\n\t"4999",\n\t"5012",\n\t"5013",\n\t"5017",\n\t"5048",\n\t"5105",\n\t"5106",\n\t"5107",\n\t"5108",\n\t"5109",\n\t"5110",\n\t"5111",\n\t"5112",\n\t"5113",\n\t"5114",\n\t"5115",\n\t"5116",\n\t"5117",\n\t"5118",\n\t"5119",\n\t"5120",\n\t"5121",\n\t"5122",\n\t"5123",\n\t"5124",\n\t"5125",\n\t"5126",\n\t"5127",\n\t"5128",\n\t"5129",\n\t"5130",\n\t"5132",\n\t"5167",\n\t"5168",\n\t"5169",\n\t"5170",\n\t"5171",\n\t"5172",\n\t"5173",\n\t"5174",\n\t"5175",\n\t"5176",\n\t"5177",\n\t"5178",\n\t"5179",\n\t"5180",\n\t"5181",\n\t"5182",\n\t"5183",\n\t"5184",\n\t"5185",\n\t"5186",\n\t"5187",\n\t"5188",\n\t"5224",\n\t"5228",\n\t"5229",\n\t"5233",\n\t"5245",\n\t"5246",\n\t"5251",\n\t"5252",\n\t"5253",\n\t"5254",\n\t"5255",\n\t"5256",\n\t"5257",\n\t"5258",\n\t"5259",\n\t"5263",\n\t"5264",\n\t"5269",\n\t"5270",\n\t"5271",\n\t"5272",\n\t"5273",\n\t"5274",\n\t"5275",\n\t"5801",\n\t"5802",\n\t"5803",\n\t"5804",\n\t"5808",\n\t"5809",\n\t"5810",\n\t"5811",\n\t"5812",\n\t"5813",\n\t"5814",\n\t"5815",\n\t"5816",\n\t"20004",\n\t"20005",\n\t"20006",\n\t"20007",\n\t"20008",\n\t"20009",\n\t"20010",\n\t"20011",\n\t"20012",\n\t"20013",\n\t"20014",\n\t"20015",\n\t"20016",\n\t"20017",\n\t"20018",\n\t"20019",\n\t"20020",\n\t"20021",\n\t"20022",\n\t"20023",\n\t"20024",\n\t"20025",\n\t"20026",\n\t"20027",\n\t"20028",\n\t"20029",\n\t"20030",\n\t"20031",\n\t"20032",\n\t"20064",\n\t"20065",\n\t"20066",\n\t"20067",\n\t"20068",\n\t"20069",\n\t"20070",\n\t"20071",\n\t"20072",\n\t"20073",\n\t"20074",\n\t"20075",\n\t"20076",\n\t"20077",\n\t"20078",\n\t"20079",\n\t"20080",\n\t"20081",\n\t"20082",\n\t"20083",\n\t"20084",\n\t"20085",\n\t"20086",\n\t"20087",\n\t"20088",\n\t"20089",\n\t"20090",\n\t"20091",\n\t"20092",\n\t"21413",\n\t"21414",\n\t"21415",\n\t"21416",\n\t"21417",\n\t"21418",\n\t"21419",\n\t"21420",\n\t"21421",\n\t"21422",\n\t"21423",\n\t"21453",\n\t"21454",\n\t"21455",\n\t"21456",\n\t"21457",\n\t"21458",\n\t"21459",\n\t"21460",\n\t"21461",\n\t"21462",\n\t"21463",\n\t"21473",\n\t"21474",\n\t"21475",\n\t"21476",\n\t"21477",\n\t"21478",\n\t"21479",\n\t"21480",\n\t"21481",\n\t"21482",\n\t"21483",\n\t"21896",\n\t"21897",\n\t"21898",\n\t"21899",\n\t"22171",\n\t"22172",\n\t"22173",\n\t"22174",\n\t"22175",\n\t"22176",\n\t"22177",\n\t"22181",\n\t"22182",\n\t"22183",\n\t"22184",\n\t"22185",\n\t"22186",\n\t"22187",\n\t"22191",\n\t"22192",\n\t"22193",\n\t"22194",\n\t"22195",\n\t"22196",\n\t"22197",\n\t"25884",\n\t"27205",\n\t"27206",\n\t"27207",\n\t"27208",\n\t"27209",\n\t"27210",\n\t"27211",\n\t"27212",\n\t"27213",\n\t"27214",\n\t"27215",\n\t"27216",\n\t"27217",\n\t"27218",\n\t"27219",\n\t"27220",\n\t"27221",\n\t"27222",\n\t"27223",\n\t"27224",\n\t"27225",\n\t"27226",\n\t"27227",\n\t"27228",\n\t"27229",\n\t"27230",\n\t"27231",\n\t"27232",\n\t"27391",\n\t"27392",\n\t"27393",\n\t"27394",\n\t"27395",\n\t"27396",\n\t"27397",\n\t"27398",\n\t"27492",\n\t"28402",\n\t"28403",\n\t"28404",\n\t"28405",\n\t"28406",\n\t"28407",\n\t"28408",\n\t"28409",\n\t"28410",\n\t"28411",\n\t"28412",\n\t"28413",\n\t"28414",\n\t"28415",\n\t"28416",\n\t"28417",\n\t"28418",\n\t"28419",\n\t"28420",\n\t"28421",\n\t"28422",\n\t"28423",\n\t"28424",\n\t"28425",\n\t"28426",\n\t"28427",\n\t"28428",\n\t"28429",\n\t"28430",\n\t"28431",\n\t"28432",\n\t"28462",\n\t"28463",\n\t"28464",\n\t"28465",\n\t"28466",\n\t"28467",\n\t"28468",\n\t"28469",\n\t"28470",\n\t"28471",\n\t"28472",\n\t"28473",\n\t"28474",\n\t"28475",\n\t"28476",\n\t"28477",\n\t"28478",\n\t"28479",\n\t"28480",\n\t"28481",\n\t"28482",\n\t"28483",\n\t"28484",\n\t"28485",\n\t"28486",\n\t"28487",\n\t"28488",\n\t"28489",\n\t"28490",\n\t"28491",\n\t"28492",\n\t"29701",\n\t"29702",\n\t"30161",\n\t"30162",\n\t"30163",\n\t"30164",\n\t"30165",\n\t"30166",\n\t"30167",\n\t"30168",\n\t"30169",\n\t"30170",\n\t"30171",\n\t"30172",\n\t"30173",\n\t"30174",\n\t"30175",\n\t"30176",\n\t"30177",\n\t"30178",\n\t"30179",\n\t"30800",\n\t"31251",\n\t"31252",\n\t"31253",\n\t"31254",\n\t"31255",\n\t"31256",\n\t"31257",\n\t"31258",\n\t"31259",\n\t"31275",\n\t"31276",\n\t"31277",\n\t"31278",\n\t"31279",\n\t"31281",\n\t"31282",\n\t"31283",\n\t"31284",\n\t"31285",\n\t"31286",\n\t"31287",\n\t"31288",\n\t"31289",\n\t"31290",\n\t"31466",\n\t"31700"\n];//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGF5ZXIvcmV2ZXJzZWRBeGlzLmpzb24/ZWRhOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxNzQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFtcblx0XCI0MzI2XCIsXG5cdFwiNDI2OVwiLFxuXHRcIjQyNThcIixcblx0XCIzMTQ2N1wiLFxuXHRcIjMxNDY4XCIsXG5cdFwiMzE0NjlcIixcblx0XCIyMTY2XCIsXG5cdFwiMjE2N1wiLFxuXHRcIjIxNjhcIixcblx0XCIyMDM2XCIsXG5cdFwiMjA0NFwiLFxuXHRcIjIwNDVcIixcblx0XCIyMDY1XCIsXG5cdFwiMjA4MVwiLFxuXHRcIjIwODJcIixcblx0XCIyMDgzXCIsXG5cdFwiMjA4NVwiLFxuXHRcIjIwODZcIixcblx0XCIyMDkxXCIsXG5cdFwiMjA5MlwiLFxuXHRcIjIwOTNcIixcblx0XCIyMDk2XCIsXG5cdFwiMjA5N1wiLFxuXHRcIjIwOThcIixcblx0XCIyMTA1XCIsXG5cdFwiMjEwNlwiLFxuXHRcIjIxMDdcIixcblx0XCIyMTA4XCIsXG5cdFwiMjEwOVwiLFxuXHRcIjIxMTBcIixcblx0XCIyMTExXCIsXG5cdFwiMjExMlwiLFxuXHRcIjIxMTNcIixcblx0XCIyMTE0XCIsXG5cdFwiMjExNVwiLFxuXHRcIjIxMTZcIixcblx0XCIyMTE3XCIsXG5cdFwiMjExOFwiLFxuXHRcIjIxMTlcIixcblx0XCIyMTIwXCIsXG5cdFwiMjEyMVwiLFxuXHRcIjIxMjJcIixcblx0XCIyMTIzXCIsXG5cdFwiMjEyNFwiLFxuXHRcIjIxMjVcIixcblx0XCIyMTI2XCIsXG5cdFwiMjEyN1wiLFxuXHRcIjIxMjhcIixcblx0XCIyMTI5XCIsXG5cdFwiMjEzMFwiLFxuXHRcIjIxMzFcIixcblx0XCIyMTMyXCIsXG5cdFwiMjE2OVwiLFxuXHRcIjIxNzBcIixcblx0XCIyMTcxXCIsXG5cdFwiMjE3MlwiLFxuXHRcIjIxNzNcIixcblx0XCIyMTc0XCIsXG5cdFwiMjE3NVwiLFxuXHRcIjIxNzZcIixcblx0XCIyMTc3XCIsXG5cdFwiMjE3OFwiLFxuXHRcIjIxNzlcIixcblx0XCIyMTgwXCIsXG5cdFwiMjE5M1wiLFxuXHRcIjIxOTlcIixcblx0XCIyMjAwXCIsXG5cdFwiMjIwNlwiLFxuXHRcIjIyMDdcIixcblx0XCIyMjA4XCIsXG5cdFwiMjIwOVwiLFxuXHRcIjIyMTBcIixcblx0XCIyMjExXCIsXG5cdFwiMjIxMlwiLFxuXHRcIjIzMTlcIixcblx0XCIyMzIwXCIsXG5cdFwiMjMyMVwiLFxuXHRcIjIzMjJcIixcblx0XCIyMzIzXCIsXG5cdFwiMjMyNFwiLFxuXHRcIjIzMjVcIixcblx0XCIyMzI2XCIsXG5cdFwiMjMyN1wiLFxuXHRcIjIzMjhcIixcblx0XCIyMzI5XCIsXG5cdFwiMjMzMFwiLFxuXHRcIjIzMzFcIixcblx0XCIyMzMyXCIsXG5cdFwiMjMzM1wiLFxuXHRcIjIzMzRcIixcblx0XCIyMzM1XCIsXG5cdFwiMjMzNlwiLFxuXHRcIjIzMzdcIixcblx0XCIyMzM4XCIsXG5cdFwiMjMzOVwiLFxuXHRcIjIzNDBcIixcblx0XCIyMzQxXCIsXG5cdFwiMjM0MlwiLFxuXHRcIjIzNDNcIixcblx0XCIyMzQ0XCIsXG5cdFwiMjM0NVwiLFxuXHRcIjIzNDZcIixcblx0XCIyMzQ3XCIsXG5cdFwiMjM0OFwiLFxuXHRcIjIzNDlcIixcblx0XCIyMzUwXCIsXG5cdFwiMjM1MVwiLFxuXHRcIjIzNTJcIixcblx0XCIyMzUzXCIsXG5cdFwiMjM1NFwiLFxuXHRcIjIzNTVcIixcblx0XCIyMzU2XCIsXG5cdFwiMjM1N1wiLFxuXHRcIjIzNThcIixcblx0XCIyMzU5XCIsXG5cdFwiMjM2MFwiLFxuXHRcIjIzNjFcIixcblx0XCIyMzYyXCIsXG5cdFwiMjM2M1wiLFxuXHRcIjIzNjRcIixcblx0XCIyMzY1XCIsXG5cdFwiMjM2NlwiLFxuXHRcIjIzNjdcIixcblx0XCIyMzY4XCIsXG5cdFwiMjM2OVwiLFxuXHRcIjIzNzBcIixcblx0XCIyMzcxXCIsXG5cdFwiMjM3MlwiLFxuXHRcIjIzNzNcIixcblx0XCIyMzc0XCIsXG5cdFwiMjM3NVwiLFxuXHRcIjIzNzZcIixcblx0XCIyMzc3XCIsXG5cdFwiMjM3OFwiLFxuXHRcIjIzNzlcIixcblx0XCIyMzgwXCIsXG5cdFwiMjM4MVwiLFxuXHRcIjIzODJcIixcblx0XCIyMzgzXCIsXG5cdFwiMjM4NFwiLFxuXHRcIjIzODVcIixcblx0XCIyMzg2XCIsXG5cdFwiMjM4N1wiLFxuXHRcIjIzODhcIixcblx0XCIyMzg5XCIsXG5cdFwiMjM5MFwiLFxuXHRcIjIzOTFcIixcblx0XCIyMzkyXCIsXG5cdFwiMjM5M1wiLFxuXHRcIjIzOTRcIixcblx0XCIyMzk1XCIsXG5cdFwiMjM5NlwiLFxuXHRcIjIzOTdcIixcblx0XCIyMzk4XCIsXG5cdFwiMjM5OVwiLFxuXHRcIjI0MDBcIixcblx0XCIyNDAxXCIsXG5cdFwiMjQwMlwiLFxuXHRcIjI0MDNcIixcblx0XCIyNDA0XCIsXG5cdFwiMjQwNVwiLFxuXHRcIjI0MDZcIixcblx0XCIyNDA3XCIsXG5cdFwiMjQwOFwiLFxuXHRcIjI0MDlcIixcblx0XCIyNDEwXCIsXG5cdFwiMjQxMVwiLFxuXHRcIjI0MTJcIixcblx0XCIyNDEzXCIsXG5cdFwiMjQxNFwiLFxuXHRcIjI0MTVcIixcblx0XCIyNDE2XCIsXG5cdFwiMjQxN1wiLFxuXHRcIjI0MThcIixcblx0XCIyNDE5XCIsXG5cdFwiMjQyMFwiLFxuXHRcIjI0MjFcIixcblx0XCIyNDIyXCIsXG5cdFwiMjQyM1wiLFxuXHRcIjI0MjRcIixcblx0XCIyNDI1XCIsXG5cdFwiMjQyNlwiLFxuXHRcIjI0MjdcIixcblx0XCIyNDI4XCIsXG5cdFwiMjQyOVwiLFxuXHRcIjI0MzBcIixcblx0XCIyNDMxXCIsXG5cdFwiMjQzMlwiLFxuXHRcIjI0MzNcIixcblx0XCIyNDM0XCIsXG5cdFwiMjQzNVwiLFxuXHRcIjI0MzZcIixcblx0XCIyNDM3XCIsXG5cdFwiMjQzOFwiLFxuXHRcIjI0MzlcIixcblx0XCIyNDQwXCIsXG5cdFwiMjQ0MVwiLFxuXHRcIjI0NDJcIixcblx0XCIyNDQzXCIsXG5cdFwiMjQ0NFwiLFxuXHRcIjI0NDVcIixcblx0XCIyNDQ2XCIsXG5cdFwiMjQ0N1wiLFxuXHRcIjI0NDhcIixcblx0XCIyNDQ5XCIsXG5cdFwiMjQ1MFwiLFxuXHRcIjI0NTFcIixcblx0XCIyNDUyXCIsXG5cdFwiMjQ1M1wiLFxuXHRcIjI0NTRcIixcblx0XCIyNDU1XCIsXG5cdFwiMjQ1NlwiLFxuXHRcIjI0NTdcIixcblx0XCIyNDU4XCIsXG5cdFwiMjQ1OVwiLFxuXHRcIjI0NjBcIixcblx0XCIyNDYxXCIsXG5cdFwiMjQ2MlwiLFxuXHRcIjI0NjNcIixcblx0XCIyNDY0XCIsXG5cdFwiMjQ2NVwiLFxuXHRcIjI0NjZcIixcblx0XCIyNDY3XCIsXG5cdFwiMjQ2OFwiLFxuXHRcIjI0NjlcIixcblx0XCIyNDcwXCIsXG5cdFwiMjQ3MVwiLFxuXHRcIjI0NzJcIixcblx0XCIyNDczXCIsXG5cdFwiMjQ3NFwiLFxuXHRcIjI0NzVcIixcblx0XCIyNDc2XCIsXG5cdFwiMjQ3N1wiLFxuXHRcIjI0NzhcIixcblx0XCIyNDc5XCIsXG5cdFwiMjQ4MFwiLFxuXHRcIjI0ODFcIixcblx0XCIyNDgyXCIsXG5cdFwiMjQ4M1wiLFxuXHRcIjI0ODRcIixcblx0XCIyNDg1XCIsXG5cdFwiMjQ4NlwiLFxuXHRcIjI0ODdcIixcblx0XCIyNDg4XCIsXG5cdFwiMjQ4OVwiLFxuXHRcIjI0OTBcIixcblx0XCIyNDkxXCIsXG5cdFwiMjQ5MlwiLFxuXHRcIjI0OTNcIixcblx0XCIyNDk0XCIsXG5cdFwiMjQ5NVwiLFxuXHRcIjI0OTZcIixcblx0XCIyNDk3XCIsXG5cdFwiMjQ5OFwiLFxuXHRcIjI0OTlcIixcblx0XCIyNTAwXCIsXG5cdFwiMjUwMVwiLFxuXHRcIjI1MDJcIixcblx0XCIyNTAzXCIsXG5cdFwiMjUwNFwiLFxuXHRcIjI1MDVcIixcblx0XCIyNTA2XCIsXG5cdFwiMjUwN1wiLFxuXHRcIjI1MDhcIixcblx0XCIyNTA5XCIsXG5cdFwiMjUxMFwiLFxuXHRcIjI1MTFcIixcblx0XCIyNTEyXCIsXG5cdFwiMjUxM1wiLFxuXHRcIjI1MTRcIixcblx0XCIyNTE1XCIsXG5cdFwiMjUxNlwiLFxuXHRcIjI1MTdcIixcblx0XCIyNTE4XCIsXG5cdFwiMjUxOVwiLFxuXHRcIjI1MjBcIixcblx0XCIyNTIxXCIsXG5cdFwiMjUyMlwiLFxuXHRcIjI1MjNcIixcblx0XCIyNTI0XCIsXG5cdFwiMjUyNVwiLFxuXHRcIjI1MjZcIixcblx0XCIyNTI3XCIsXG5cdFwiMjUyOFwiLFxuXHRcIjI1MjlcIixcblx0XCIyNTMwXCIsXG5cdFwiMjUzMVwiLFxuXHRcIjI1MzJcIixcblx0XCIyNTMzXCIsXG5cdFwiMjUzNFwiLFxuXHRcIjI1MzVcIixcblx0XCIyNTM2XCIsXG5cdFwiMjUzN1wiLFxuXHRcIjI1MzhcIixcblx0XCIyNTM5XCIsXG5cdFwiMjU0MFwiLFxuXHRcIjI1NDFcIixcblx0XCIyNTQyXCIsXG5cdFwiMjU0M1wiLFxuXHRcIjI1NDRcIixcblx0XCIyNTQ1XCIsXG5cdFwiMjU0NlwiLFxuXHRcIjI1NDdcIixcblx0XCIyNTQ4XCIsXG5cdFwiMjU0OVwiLFxuXHRcIjI1NTFcIixcblx0XCIyNTUyXCIsXG5cdFwiMjU1M1wiLFxuXHRcIjI1NTRcIixcblx0XCIyNTU1XCIsXG5cdFwiMjU1NlwiLFxuXHRcIjI1NTdcIixcblx0XCIyNTU4XCIsXG5cdFwiMjU1OVwiLFxuXHRcIjI1NjBcIixcblx0XCIyNTYxXCIsXG5cdFwiMjU2MlwiLFxuXHRcIjI1NjNcIixcblx0XCIyNTY0XCIsXG5cdFwiMjU2NVwiLFxuXHRcIjI1NjZcIixcblx0XCIyNTY3XCIsXG5cdFwiMjU2OFwiLFxuXHRcIjI1NjlcIixcblx0XCIyNTcwXCIsXG5cdFwiMjU3MVwiLFxuXHRcIjI1NzJcIixcblx0XCIyNTczXCIsXG5cdFwiMjU3NFwiLFxuXHRcIjI1NzVcIixcblx0XCIyNTc2XCIsXG5cdFwiMjU3N1wiLFxuXHRcIjI1NzhcIixcblx0XCIyNTc5XCIsXG5cdFwiMjU4MFwiLFxuXHRcIjI1ODFcIixcblx0XCIyNTgyXCIsXG5cdFwiMjU4M1wiLFxuXHRcIjI1ODRcIixcblx0XCIyNTg1XCIsXG5cdFwiMjU4NlwiLFxuXHRcIjI1ODdcIixcblx0XCIyNTg4XCIsXG5cdFwiMjU4OVwiLFxuXHRcIjI1OTBcIixcblx0XCIyNTkxXCIsXG5cdFwiMjU5MlwiLFxuXHRcIjI1OTNcIixcblx0XCIyNTk0XCIsXG5cdFwiMjU5NVwiLFxuXHRcIjI1OTZcIixcblx0XCIyNTk3XCIsXG5cdFwiMjU5OFwiLFxuXHRcIjI1OTlcIixcblx0XCIyNjAwXCIsXG5cdFwiMjYwMVwiLFxuXHRcIjI2MDJcIixcblx0XCIyNjAzXCIsXG5cdFwiMjYwNFwiLFxuXHRcIjI2MDVcIixcblx0XCIyNjA2XCIsXG5cdFwiMjYwN1wiLFxuXHRcIjI2MDhcIixcblx0XCIyNjA5XCIsXG5cdFwiMjYxMFwiLFxuXHRcIjI2MTFcIixcblx0XCIyNjEyXCIsXG5cdFwiMjYxM1wiLFxuXHRcIjI2MTRcIixcblx0XCIyNjE1XCIsXG5cdFwiMjYxNlwiLFxuXHRcIjI2MTdcIixcblx0XCIyNjE4XCIsXG5cdFwiMjYxOVwiLFxuXHRcIjI2MjBcIixcblx0XCIyNjIxXCIsXG5cdFwiMjYyMlwiLFxuXHRcIjI2MjNcIixcblx0XCIyNjI0XCIsXG5cdFwiMjYyNVwiLFxuXHRcIjI2MjZcIixcblx0XCIyNjI3XCIsXG5cdFwiMjYyOFwiLFxuXHRcIjI2MjlcIixcblx0XCIyNjMwXCIsXG5cdFwiMjYzMVwiLFxuXHRcIjI2MzJcIixcblx0XCIyNjMzXCIsXG5cdFwiMjYzNFwiLFxuXHRcIjI2MzVcIixcblx0XCIyNjM2XCIsXG5cdFwiMjYzN1wiLFxuXHRcIjI2MzhcIixcblx0XCIyNjM5XCIsXG5cdFwiMjY0MFwiLFxuXHRcIjI2NDFcIixcblx0XCIyNjQyXCIsXG5cdFwiMjY0M1wiLFxuXHRcIjI2NDRcIixcblx0XCIyNjQ1XCIsXG5cdFwiMjY0NlwiLFxuXHRcIjI2NDdcIixcblx0XCIyNjQ4XCIsXG5cdFwiMjY0OVwiLFxuXHRcIjI2NTBcIixcblx0XCIyNjUxXCIsXG5cdFwiMjY1MlwiLFxuXHRcIjI2NTNcIixcblx0XCIyNjU0XCIsXG5cdFwiMjY1NVwiLFxuXHRcIjI2NTZcIixcblx0XCIyNjU3XCIsXG5cdFwiMjY1OFwiLFxuXHRcIjI2NTlcIixcblx0XCIyNjYwXCIsXG5cdFwiMjY2MVwiLFxuXHRcIjI2NjJcIixcblx0XCIyNjYzXCIsXG5cdFwiMjY2NFwiLFxuXHRcIjI2NjVcIixcblx0XCIyNjY2XCIsXG5cdFwiMjY2N1wiLFxuXHRcIjI2NjhcIixcblx0XCIyNjY5XCIsXG5cdFwiMjY3MFwiLFxuXHRcIjI2NzFcIixcblx0XCIyNjcyXCIsXG5cdFwiMjY3M1wiLFxuXHRcIjI2NzRcIixcblx0XCIyNjc1XCIsXG5cdFwiMjY3NlwiLFxuXHRcIjI2NzdcIixcblx0XCIyNjc4XCIsXG5cdFwiMjY3OVwiLFxuXHRcIjI2ODBcIixcblx0XCIyNjgxXCIsXG5cdFwiMjY4MlwiLFxuXHRcIjI2ODNcIixcblx0XCIyNjg0XCIsXG5cdFwiMjY4NVwiLFxuXHRcIjI2ODZcIixcblx0XCIyNjg3XCIsXG5cdFwiMjY4OFwiLFxuXHRcIjI2ODlcIixcblx0XCIyNjkwXCIsXG5cdFwiMjY5MVwiLFxuXHRcIjI2OTJcIixcblx0XCIyNjkzXCIsXG5cdFwiMjY5NFwiLFxuXHRcIjI2OTVcIixcblx0XCIyNjk2XCIsXG5cdFwiMjY5N1wiLFxuXHRcIjI2OThcIixcblx0XCIyNjk5XCIsXG5cdFwiMjcwMFwiLFxuXHRcIjI3MDFcIixcblx0XCIyNzAyXCIsXG5cdFwiMjcwM1wiLFxuXHRcIjI3MDRcIixcblx0XCIyNzA1XCIsXG5cdFwiMjcwNlwiLFxuXHRcIjI3MDdcIixcblx0XCIyNzA4XCIsXG5cdFwiMjcwOVwiLFxuXHRcIjI3MTBcIixcblx0XCIyNzExXCIsXG5cdFwiMjcxMlwiLFxuXHRcIjI3MTNcIixcblx0XCIyNzE0XCIsXG5cdFwiMjcxNVwiLFxuXHRcIjI3MTZcIixcblx0XCIyNzE3XCIsXG5cdFwiMjcxOFwiLFxuXHRcIjI3MTlcIixcblx0XCIyNzIwXCIsXG5cdFwiMjcyMVwiLFxuXHRcIjI3MjJcIixcblx0XCIyNzIzXCIsXG5cdFwiMjcyNFwiLFxuXHRcIjI3MjVcIixcblx0XCIyNzI2XCIsXG5cdFwiMjcyN1wiLFxuXHRcIjI3MjhcIixcblx0XCIyNzI5XCIsXG5cdFwiMjczMFwiLFxuXHRcIjI3MzFcIixcblx0XCIyNzMyXCIsXG5cdFwiMjczM1wiLFxuXHRcIjI3MzRcIixcblx0XCIyNzM1XCIsXG5cdFwiMjczOFwiLFxuXHRcIjI3MzlcIixcblx0XCIyNzQwXCIsXG5cdFwiMjc0MVwiLFxuXHRcIjI3NDJcIixcblx0XCIyNzQzXCIsXG5cdFwiMjc0NFwiLFxuXHRcIjI3NDVcIixcblx0XCIyNzQ2XCIsXG5cdFwiMjc0N1wiLFxuXHRcIjI3NDhcIixcblx0XCIyNzQ5XCIsXG5cdFwiMjc1MFwiLFxuXHRcIjI3NTFcIixcblx0XCIyNzUyXCIsXG5cdFwiMjc1M1wiLFxuXHRcIjI3NTRcIixcblx0XCIyNzU1XCIsXG5cdFwiMjc1NlwiLFxuXHRcIjI3NTdcIixcblx0XCIyNzU4XCIsXG5cdFwiMjkzNVwiLFxuXHRcIjI5MzZcIixcblx0XCIyOTM3XCIsXG5cdFwiMjkzOFwiLFxuXHRcIjI5MzlcIixcblx0XCIyOTQwXCIsXG5cdFwiMjk0MVwiLFxuXHRcIjI5NTNcIixcblx0XCIyOTYzXCIsXG5cdFwiMzAwNlwiLFxuXHRcIjMwMDdcIixcblx0XCIzMDA4XCIsXG5cdFwiMzAwOVwiLFxuXHRcIjMwMTBcIixcblx0XCIzMDExXCIsXG5cdFwiMzAxMlwiLFxuXHRcIjMwMTNcIixcblx0XCIzMDE0XCIsXG5cdFwiMzAxNVwiLFxuXHRcIjMwMTZcIixcblx0XCIzMDE3XCIsXG5cdFwiMzAxOFwiLFxuXHRcIjMwMTlcIixcblx0XCIzMDIwXCIsXG5cdFwiMzAyMVwiLFxuXHRcIjMwMjJcIixcblx0XCIzMDIzXCIsXG5cdFwiMzAyNFwiLFxuXHRcIjMwMjVcIixcblx0XCIzMDI2XCIsXG5cdFwiMzAyN1wiLFxuXHRcIjMwMjhcIixcblx0XCIzMDI5XCIsXG5cdFwiMzAzMFwiLFxuXHRcIjMwMzRcIixcblx0XCIzMDM1XCIsXG5cdFwiMzAzOFwiLFxuXHRcIjMwMzlcIixcblx0XCIzMDQwXCIsXG5cdFwiMzA0MVwiLFxuXHRcIjMwNDJcIixcblx0XCIzMDQzXCIsXG5cdFwiMzA0NFwiLFxuXHRcIjMwNDVcIixcblx0XCIzMDQ2XCIsXG5cdFwiMzA0N1wiLFxuXHRcIjMwNDhcIixcblx0XCIzMDQ5XCIsXG5cdFwiMzA1MFwiLFxuXHRcIjMwNTFcIixcblx0XCIzMDU4XCIsXG5cdFwiMzA1OVwiLFxuXHRcIjMwNjhcIixcblx0XCIzMTE0XCIsXG5cdFwiMzExNVwiLFxuXHRcIjMxMTZcIixcblx0XCIzMTE3XCIsXG5cdFwiMzExOFwiLFxuXHRcIjMxMjBcIixcblx0XCIzMTI2XCIsXG5cdFwiMzEyN1wiLFxuXHRcIjMxMjhcIixcblx0XCIzMTI5XCIsXG5cdFwiMzEzMFwiLFxuXHRcIjMxMzFcIixcblx0XCIzMTMyXCIsXG5cdFwiMzEzM1wiLFxuXHRcIjMxMzRcIixcblx0XCIzMTM1XCIsXG5cdFwiMzEzNlwiLFxuXHRcIjMxMzdcIixcblx0XCIzMTM4XCIsXG5cdFwiMzEzOVwiLFxuXHRcIjMxNDBcIixcblx0XCIzMTQ2XCIsXG5cdFwiMzE0N1wiLFxuXHRcIjMxNTBcIixcblx0XCIzMTUxXCIsXG5cdFwiMzE1MlwiLFxuXHRcIjMzMDBcIixcblx0XCIzMzAxXCIsXG5cdFwiMzMyOFwiLFxuXHRcIjMzMjlcIixcblx0XCIzMzMwXCIsXG5cdFwiMzMzMVwiLFxuXHRcIjMzMzJcIixcblx0XCIzMzMzXCIsXG5cdFwiMzMzNFwiLFxuXHRcIjMzMzVcIixcblx0XCIzMzQ2XCIsXG5cdFwiMzM1MFwiLFxuXHRcIjMzNTFcIixcblx0XCIzMzUyXCIsXG5cdFwiMzM2NlwiLFxuXHRcIjMzODZcIixcblx0XCIzMzg3XCIsXG5cdFwiMzM4OFwiLFxuXHRcIjMzODlcIixcblx0XCIzMzkwXCIsXG5cdFwiMzM5NlwiLFxuXHRcIjMzOTdcIixcblx0XCIzMzk4XCIsXG5cdFwiMzM5OVwiLFxuXHRcIjM0MDdcIixcblx0XCIzNDE0XCIsXG5cdFwiMzQxNlwiLFxuXHRcIjM3NjRcIixcblx0XCIzNzg4XCIsXG5cdFwiMzc4OVwiLFxuXHRcIjM3OTBcIixcblx0XCIzNzkxXCIsXG5cdFwiMzc5M1wiLFxuXHRcIjM3OTVcIixcblx0XCIzNzk2XCIsXG5cdFwiMzgxOVwiLFxuXHRcIjM4MjFcIixcblx0XCIzODIzXCIsXG5cdFwiMzgyNFwiLFxuXHRcIjM4MzNcIixcblx0XCIzODM0XCIsXG5cdFwiMzgzNVwiLFxuXHRcIjM4MzZcIixcblx0XCIzODM3XCIsXG5cdFwiMzgzOFwiLFxuXHRcIjM4MzlcIixcblx0XCIzODQwXCIsXG5cdFwiMzg0MVwiLFxuXHRcIjM4NDJcIixcblx0XCIzODQzXCIsXG5cdFwiMzg0NFwiLFxuXHRcIjM4NDVcIixcblx0XCIzODQ2XCIsXG5cdFwiMzg0N1wiLFxuXHRcIjM4NDhcIixcblx0XCIzODQ5XCIsXG5cdFwiMzg1MFwiLFxuXHRcIjM4NTFcIixcblx0XCIzODUyXCIsXG5cdFwiMzg1NFwiLFxuXHRcIjM4NzNcIixcblx0XCIzODc0XCIsXG5cdFwiMzg3NVwiLFxuXHRcIjM4NzZcIixcblx0XCIzODc3XCIsXG5cdFwiMzg3OFwiLFxuXHRcIjM4NzlcIixcblx0XCIzODgwXCIsXG5cdFwiMzg4MVwiLFxuXHRcIjM4ODJcIixcblx0XCIzODgzXCIsXG5cdFwiMzg4NFwiLFxuXHRcIjM4ODVcIixcblx0XCIzODg4XCIsXG5cdFwiMzg4OVwiLFxuXHRcIjM5MDZcIixcblx0XCIzOTA3XCIsXG5cdFwiMzkwOFwiLFxuXHRcIjM5MDlcIixcblx0XCIzOTEwXCIsXG5cdFwiMzkxMVwiLFxuXHRcIjQwMDFcIixcblx0XCI0MDAyXCIsXG5cdFwiNDAwM1wiLFxuXHRcIjQwMDRcIixcblx0XCI0MDA1XCIsXG5cdFwiNDAwNlwiLFxuXHRcIjQwMDdcIixcblx0XCI0MDA4XCIsXG5cdFwiNDAwOVwiLFxuXHRcIjQwMTBcIixcblx0XCI0MDExXCIsXG5cdFwiNDAxMlwiLFxuXHRcIjQwMTNcIixcblx0XCI0MDE0XCIsXG5cdFwiNDAxNVwiLFxuXHRcIjQwMTZcIixcblx0XCI0MDE3XCIsXG5cdFwiNDAxOFwiLFxuXHRcIjQwMTlcIixcblx0XCI0MDIwXCIsXG5cdFwiNDAyMVwiLFxuXHRcIjQwMjJcIixcblx0XCI0MDIzXCIsXG5cdFwiNDAyNFwiLFxuXHRcIjQwMjVcIixcblx0XCI0MDI2XCIsXG5cdFwiNDAyN1wiLFxuXHRcIjQwMjhcIixcblx0XCI0MDI5XCIsXG5cdFwiNDAzMFwiLFxuXHRcIjQwMzFcIixcblx0XCI0MDMyXCIsXG5cdFwiNDAzM1wiLFxuXHRcIjQwMzRcIixcblx0XCI0MDM1XCIsXG5cdFwiNDAzNlwiLFxuXHRcIjQwMzdcIixcblx0XCI0MDM4XCIsXG5cdFwiNDA0MFwiLFxuXHRcIjQwNDFcIixcblx0XCI0MDQyXCIsXG5cdFwiNDA0M1wiLFxuXHRcIjQwNDRcIixcblx0XCI0MDQ1XCIsXG5cdFwiNDA0NlwiLFxuXHRcIjQwNDdcIixcblx0XCI0MDUyXCIsXG5cdFwiNDA1M1wiLFxuXHRcIjQwNTRcIixcblx0XCI0MDU1XCIsXG5cdFwiNDA3NFwiLFxuXHRcIjQwNzVcIixcblx0XCI0MDgwXCIsXG5cdFwiNDA4MVwiLFxuXHRcIjQxMjBcIixcblx0XCI0MTIxXCIsXG5cdFwiNDEyMlwiLFxuXHRcIjQxMjNcIixcblx0XCI0MTI0XCIsXG5cdFwiNDEyNVwiLFxuXHRcIjQxMjZcIixcblx0XCI0MTI3XCIsXG5cdFwiNDEyOFwiLFxuXHRcIjQxMjlcIixcblx0XCI0MTMwXCIsXG5cdFwiNDEzMVwiLFxuXHRcIjQxMzJcIixcblx0XCI0MTMzXCIsXG5cdFwiNDEzNFwiLFxuXHRcIjQxMzVcIixcblx0XCI0MTM2XCIsXG5cdFwiNDEzN1wiLFxuXHRcIjQxMzhcIixcblx0XCI0MTM5XCIsXG5cdFwiNDE0MFwiLFxuXHRcIjQxNDFcIixcblx0XCI0MTQyXCIsXG5cdFwiNDE0M1wiLFxuXHRcIjQxNDRcIixcblx0XCI0MTQ1XCIsXG5cdFwiNDE0NlwiLFxuXHRcIjQxNDdcIixcblx0XCI0MTQ4XCIsXG5cdFwiNDE0OVwiLFxuXHRcIjQxNTBcIixcblx0XCI0MTUxXCIsXG5cdFwiNDE1MlwiLFxuXHRcIjQxNTNcIixcblx0XCI0MTU0XCIsXG5cdFwiNDE1NVwiLFxuXHRcIjQxNTZcIixcblx0XCI0MTU3XCIsXG5cdFwiNDE1OFwiLFxuXHRcIjQxNTlcIixcblx0XCI0MTYwXCIsXG5cdFwiNDE2MVwiLFxuXHRcIjQxNjJcIixcblx0XCI0MTYzXCIsXG5cdFwiNDE2NFwiLFxuXHRcIjQxNjVcIixcblx0XCI0MTY2XCIsXG5cdFwiNDE2N1wiLFxuXHRcIjQxNjhcIixcblx0XCI0MTY5XCIsXG5cdFwiNDE3MFwiLFxuXHRcIjQxNzFcIixcblx0XCI0MTcyXCIsXG5cdFwiNDE3M1wiLFxuXHRcIjQxNzRcIixcblx0XCI0MTc1XCIsXG5cdFwiNDE3NlwiLFxuXHRcIjQxNzhcIixcblx0XCI0MTc5XCIsXG5cdFwiNDE4MFwiLFxuXHRcIjQxODFcIixcblx0XCI0MTgyXCIsXG5cdFwiNDE4M1wiLFxuXHRcIjQxODRcIixcblx0XCI0MTg1XCIsXG5cdFwiNDE4OFwiLFxuXHRcIjQxODlcIixcblx0XCI0MTkwXCIsXG5cdFwiNDE5MVwiLFxuXHRcIjQxOTJcIixcblx0XCI0MTkzXCIsXG5cdFwiNDE5NFwiLFxuXHRcIjQxOTVcIixcblx0XCI0MTk2XCIsXG5cdFwiNDE5N1wiLFxuXHRcIjQxOThcIixcblx0XCI0MTk5XCIsXG5cdFwiNDIwMFwiLFxuXHRcIjQyMDFcIixcblx0XCI0MjAyXCIsXG5cdFwiNDIwM1wiLFxuXHRcIjQyMDRcIixcblx0XCI0MjA1XCIsXG5cdFwiNDIwNlwiLFxuXHRcIjQyMDdcIixcblx0XCI0MjA4XCIsXG5cdFwiNDIwOVwiLFxuXHRcIjQyMTBcIixcblx0XCI0MjExXCIsXG5cdFwiNDIxMlwiLFxuXHRcIjQyMTNcIixcblx0XCI0MjE0XCIsXG5cdFwiNDIxNVwiLFxuXHRcIjQyMTZcIixcblx0XCI0MjE4XCIsXG5cdFwiNDIxOVwiLFxuXHRcIjQyMjBcIixcblx0XCI0MjIxXCIsXG5cdFwiNDIyMlwiLFxuXHRcIjQyMjNcIixcblx0XCI0MjI0XCIsXG5cdFwiNDIyNVwiLFxuXHRcIjQyMjZcIixcblx0XCI0MjI3XCIsXG5cdFwiNDIyOFwiLFxuXHRcIjQyMjlcIixcblx0XCI0MjMwXCIsXG5cdFwiNDIzMVwiLFxuXHRcIjQyMzJcIixcblx0XCI0MjMzXCIsXG5cdFwiNDIzNFwiLFxuXHRcIjQyMzVcIixcblx0XCI0MjM2XCIsXG5cdFwiNDIzN1wiLFxuXHRcIjQyMzhcIixcblx0XCI0MjM5XCIsXG5cdFwiNDI0MFwiLFxuXHRcIjQyNDFcIixcblx0XCI0MjQyXCIsXG5cdFwiNDI0M1wiLFxuXHRcIjQyNDRcIixcblx0XCI0MjQ1XCIsXG5cdFwiNDI0NlwiLFxuXHRcIjQyNDdcIixcblx0XCI0MjQ4XCIsXG5cdFwiNDI0OVwiLFxuXHRcIjQyNTBcIixcblx0XCI0MjUxXCIsXG5cdFwiNDI1MlwiLFxuXHRcIjQyNTNcIixcblx0XCI0MjU0XCIsXG5cdFwiNDI1NVwiLFxuXHRcIjQyNTZcIixcblx0XCI0MjU3XCIsXG5cdFwiNDI1OVwiLFxuXHRcIjQyNjBcIixcblx0XCI0MjYxXCIsXG5cdFwiNDI2MlwiLFxuXHRcIjQyNjNcIixcblx0XCI0MjY0XCIsXG5cdFwiNDI2NVwiLFxuXHRcIjQyNjZcIixcblx0XCI0MjY3XCIsXG5cdFwiNDI2OFwiLFxuXHRcIjQyNzBcIixcblx0XCI0MjcxXCIsXG5cdFwiNDI3MlwiLFxuXHRcIjQyNzNcIixcblx0XCI0Mjc0XCIsXG5cdFwiNDI3NVwiLFxuXHRcIjQyNzZcIixcblx0XCI0Mjc3XCIsXG5cdFwiNDI3OFwiLFxuXHRcIjQyNzlcIixcblx0XCI0MjgwXCIsXG5cdFwiNDI4MVwiLFxuXHRcIjQyODJcIixcblx0XCI0MjgzXCIsXG5cdFwiNDI4NFwiLFxuXHRcIjQyODVcIixcblx0XCI0Mjg2XCIsXG5cdFwiNDI4N1wiLFxuXHRcIjQyODhcIixcblx0XCI0Mjg5XCIsXG5cdFwiNDI5MVwiLFxuXHRcIjQyOTJcIixcblx0XCI0MjkzXCIsXG5cdFwiNDI5NFwiLFxuXHRcIjQyOTVcIixcblx0XCI0Mjk2XCIsXG5cdFwiNDI5N1wiLFxuXHRcIjQyOThcIixcblx0XCI0Mjk5XCIsXG5cdFwiNDMwMFwiLFxuXHRcIjQzMDFcIixcblx0XCI0MzAyXCIsXG5cdFwiNDMwM1wiLFxuXHRcIjQzMDRcIixcblx0XCI0MzA2XCIsXG5cdFwiNDMwN1wiLFxuXHRcIjQzMDhcIixcblx0XCI0MzA5XCIsXG5cdFwiNDMxMFwiLFxuXHRcIjQzMTFcIixcblx0XCI0MzEyXCIsXG5cdFwiNDMxM1wiLFxuXHRcIjQzMTRcIixcblx0XCI0MzE1XCIsXG5cdFwiNDMxNlwiLFxuXHRcIjQzMTdcIixcblx0XCI0MzE4XCIsXG5cdFwiNDMxOVwiLFxuXHRcIjQzMjJcIixcblx0XCI0MzI0XCIsXG5cdFwiNDMyN1wiLFxuXHRcIjQzMjlcIixcblx0XCI0MzM5XCIsXG5cdFwiNDM0MVwiLFxuXHRcIjQzNDNcIixcblx0XCI0MzQ1XCIsXG5cdFwiNDM0N1wiLFxuXHRcIjQzNDlcIixcblx0XCI0MzUxXCIsXG5cdFwiNDM1M1wiLFxuXHRcIjQzNTVcIixcblx0XCI0MzU3XCIsXG5cdFwiNDM1OVwiLFxuXHRcIjQzNjFcIixcblx0XCI0MzYzXCIsXG5cdFwiNDM2NVwiLFxuXHRcIjQzNjdcIixcblx0XCI0MzY5XCIsXG5cdFwiNDM3MVwiLFxuXHRcIjQzNzNcIixcblx0XCI0Mzc1XCIsXG5cdFwiNDM3N1wiLFxuXHRcIjQzNzlcIixcblx0XCI0MzgxXCIsXG5cdFwiNDM4M1wiLFxuXHRcIjQzODZcIixcblx0XCI0Mzg4XCIsXG5cdFwiNDQxN1wiLFxuXHRcIjQ0MzRcIixcblx0XCI0NDYzXCIsXG5cdFwiNDQ2NlwiLFxuXHRcIjQ0NjlcIixcblx0XCI0NDcwXCIsXG5cdFwiNDQ3MlwiLFxuXHRcIjQ0NzVcIixcblx0XCI0NDgwXCIsXG5cdFwiNDQ4MlwiLFxuXHRcIjQ0ODNcIixcblx0XCI0NDkwXCIsXG5cdFwiNDQ5MVwiLFxuXHRcIjQ0OTJcIixcblx0XCI0NDkzXCIsXG5cdFwiNDQ5NFwiLFxuXHRcIjQ0OTVcIixcblx0XCI0NDk2XCIsXG5cdFwiNDQ5N1wiLFxuXHRcIjQ0OThcIixcblx0XCI0NDk5XCIsXG5cdFwiNDUwMFwiLFxuXHRcIjQ1MDFcIixcblx0XCI0NTAyXCIsXG5cdFwiNDUwM1wiLFxuXHRcIjQ1MDRcIixcblx0XCI0NTA1XCIsXG5cdFwiNDUwNlwiLFxuXHRcIjQ1MDdcIixcblx0XCI0NTA4XCIsXG5cdFwiNDUwOVwiLFxuXHRcIjQ1MTBcIixcblx0XCI0NTExXCIsXG5cdFwiNDUxMlwiLFxuXHRcIjQ1MTNcIixcblx0XCI0NTE0XCIsXG5cdFwiNDUxNVwiLFxuXHRcIjQ1MTZcIixcblx0XCI0NTE3XCIsXG5cdFwiNDUxOFwiLFxuXHRcIjQ1MTlcIixcblx0XCI0NTIwXCIsXG5cdFwiNDUyMVwiLFxuXHRcIjQ1MjJcIixcblx0XCI0NTIzXCIsXG5cdFwiNDUyNFwiLFxuXHRcIjQ1MjVcIixcblx0XCI0NTI2XCIsXG5cdFwiNDUyN1wiLFxuXHRcIjQ1MjhcIixcblx0XCI0NTI5XCIsXG5cdFwiNDUzMFwiLFxuXHRcIjQ1MzFcIixcblx0XCI0NTMyXCIsXG5cdFwiNDUzM1wiLFxuXHRcIjQ1MzRcIixcblx0XCI0NTM1XCIsXG5cdFwiNDUzNlwiLFxuXHRcIjQ1MzdcIixcblx0XCI0NTM4XCIsXG5cdFwiNDUzOVwiLFxuXHRcIjQ1NDBcIixcblx0XCI0NTQxXCIsXG5cdFwiNDU0MlwiLFxuXHRcIjQ1NDNcIixcblx0XCI0NTQ0XCIsXG5cdFwiNDU0NVwiLFxuXHRcIjQ1NDZcIixcblx0XCI0NTQ3XCIsXG5cdFwiNDU0OFwiLFxuXHRcIjQ1NDlcIixcblx0XCI0NTUwXCIsXG5cdFwiNDU1MVwiLFxuXHRcIjQ1NTJcIixcblx0XCI0NTUzXCIsXG5cdFwiNDU1NFwiLFxuXHRcIjQ1NTVcIixcblx0XCI0NTU3XCIsXG5cdFwiNDU1OFwiLFxuXHRcIjQ1NjhcIixcblx0XCI0NTY5XCIsXG5cdFwiNDU3MFwiLFxuXHRcIjQ1NzFcIixcblx0XCI0NTcyXCIsXG5cdFwiNDU3M1wiLFxuXHRcIjQ1NzRcIixcblx0XCI0NTc1XCIsXG5cdFwiNDU3NlwiLFxuXHRcIjQ1NzdcIixcblx0XCI0NTc4XCIsXG5cdFwiNDU3OVwiLFxuXHRcIjQ1ODBcIixcblx0XCI0NTgxXCIsXG5cdFwiNDU4MlwiLFxuXHRcIjQ1ODNcIixcblx0XCI0NTg0XCIsXG5cdFwiNDU4NVwiLFxuXHRcIjQ1ODZcIixcblx0XCI0NTg3XCIsXG5cdFwiNDU4OFwiLFxuXHRcIjQ1ODlcIixcblx0XCI0NjAwXCIsXG5cdFwiNDYwMVwiLFxuXHRcIjQ2MDJcIixcblx0XCI0NjAzXCIsXG5cdFwiNDYwNFwiLFxuXHRcIjQ2MDVcIixcblx0XCI0NjA2XCIsXG5cdFwiNDYwN1wiLFxuXHRcIjQ2MDhcIixcblx0XCI0NjA5XCIsXG5cdFwiNDYxMFwiLFxuXHRcIjQ2MTFcIixcblx0XCI0NjEyXCIsXG5cdFwiNDYxM1wiLFxuXHRcIjQ2MTRcIixcblx0XCI0NjE1XCIsXG5cdFwiNDYxNlwiLFxuXHRcIjQ2MTdcIixcblx0XCI0NjE4XCIsXG5cdFwiNDYxOVwiLFxuXHRcIjQ2MjBcIixcblx0XCI0NjIxXCIsXG5cdFwiNDYyMlwiLFxuXHRcIjQ2MjNcIixcblx0XCI0NjI0XCIsXG5cdFwiNDYyNVwiLFxuXHRcIjQ2MjZcIixcblx0XCI0NjI3XCIsXG5cdFwiNDYyOFwiLFxuXHRcIjQ2MjlcIixcblx0XCI0NjMwXCIsXG5cdFwiNDYzMVwiLFxuXHRcIjQ2MzJcIixcblx0XCI0NjMzXCIsXG5cdFwiNDYzNFwiLFxuXHRcIjQ2MzVcIixcblx0XCI0NjM2XCIsXG5cdFwiNDYzN1wiLFxuXHRcIjQ2MzhcIixcblx0XCI0NjM5XCIsXG5cdFwiNDY0MFwiLFxuXHRcIjQ2NDFcIixcblx0XCI0NjQyXCIsXG5cdFwiNDY0M1wiLFxuXHRcIjQ2NDRcIixcblx0XCI0NjQ1XCIsXG5cdFwiNDY0NlwiLFxuXHRcIjQ2NTJcIixcblx0XCI0NjUzXCIsXG5cdFwiNDY1NFwiLFxuXHRcIjQ2NTVcIixcblx0XCI0NjU2XCIsXG5cdFwiNDY1N1wiLFxuXHRcIjQ2NThcIixcblx0XCI0NjU5XCIsXG5cdFwiNDY2MFwiLFxuXHRcIjQ2NjFcIixcblx0XCI0NjYyXCIsXG5cdFwiNDY2M1wiLFxuXHRcIjQ2NjRcIixcblx0XCI0NjY1XCIsXG5cdFwiNDY2NlwiLFxuXHRcIjQ2NjdcIixcblx0XCI0NjY4XCIsXG5cdFwiNDY2OVwiLFxuXHRcIjQ2NzBcIixcblx0XCI0NjcxXCIsXG5cdFwiNDY3MlwiLFxuXHRcIjQ2NzNcIixcblx0XCI0Njc0XCIsXG5cdFwiNDY3NVwiLFxuXHRcIjQ2NzZcIixcblx0XCI0Njc3XCIsXG5cdFwiNDY3OFwiLFxuXHRcIjQ2NzlcIixcblx0XCI0NjgwXCIsXG5cdFwiNDY4MVwiLFxuXHRcIjQ2ODJcIixcblx0XCI0NjgzXCIsXG5cdFwiNDY4NFwiLFxuXHRcIjQ2ODVcIixcblx0XCI0Njg2XCIsXG5cdFwiNDY4N1wiLFxuXHRcIjQ2ODhcIixcblx0XCI0Njg5XCIsXG5cdFwiNDY5MFwiLFxuXHRcIjQ2OTFcIixcblx0XCI0NjkyXCIsXG5cdFwiNDY5M1wiLFxuXHRcIjQ2OTRcIixcblx0XCI0Njk1XCIsXG5cdFwiNDY5NlwiLFxuXHRcIjQ2OTdcIixcblx0XCI0Njk4XCIsXG5cdFwiNDY5OVwiLFxuXHRcIjQ3MDBcIixcblx0XCI0NzAxXCIsXG5cdFwiNDcwMlwiLFxuXHRcIjQ3MDNcIixcblx0XCI0NzA0XCIsXG5cdFwiNDcwNVwiLFxuXHRcIjQ3MDZcIixcblx0XCI0NzA3XCIsXG5cdFwiNDcwOFwiLFxuXHRcIjQ3MDlcIixcblx0XCI0NzEwXCIsXG5cdFwiNDcxMVwiLFxuXHRcIjQ3MTJcIixcblx0XCI0NzEzXCIsXG5cdFwiNDcxNFwiLFxuXHRcIjQ3MTVcIixcblx0XCI0NzE2XCIsXG5cdFwiNDcxN1wiLFxuXHRcIjQ3MThcIixcblx0XCI0NzE5XCIsXG5cdFwiNDcyMFwiLFxuXHRcIjQ3MjFcIixcblx0XCI0NzIyXCIsXG5cdFwiNDcyM1wiLFxuXHRcIjQ3MjRcIixcblx0XCI0NzI1XCIsXG5cdFwiNDcyNlwiLFxuXHRcIjQ3MjdcIixcblx0XCI0NzI4XCIsXG5cdFwiNDcyOVwiLFxuXHRcIjQ3MzBcIixcblx0XCI0NzMxXCIsXG5cdFwiNDczMlwiLFxuXHRcIjQ3MzNcIixcblx0XCI0NzM0XCIsXG5cdFwiNDczNVwiLFxuXHRcIjQ3MzZcIixcblx0XCI0NzM3XCIsXG5cdFwiNDczOFwiLFxuXHRcIjQ3MzlcIixcblx0XCI0NzQwXCIsXG5cdFwiNDc0MVwiLFxuXHRcIjQ3NDJcIixcblx0XCI0NzQzXCIsXG5cdFwiNDc0NFwiLFxuXHRcIjQ3NDVcIixcblx0XCI0NzQ2XCIsXG5cdFwiNDc0N1wiLFxuXHRcIjQ3NDhcIixcblx0XCI0NzQ5XCIsXG5cdFwiNDc1MFwiLFxuXHRcIjQ3NTFcIixcblx0XCI0NzUyXCIsXG5cdFwiNDc1M1wiLFxuXHRcIjQ3NTRcIixcblx0XCI0NzU1XCIsXG5cdFwiNDc1NlwiLFxuXHRcIjQ3NTdcIixcblx0XCI0NzU4XCIsXG5cdFwiNDc1OVwiLFxuXHRcIjQ3NjBcIixcblx0XCI0NzYxXCIsXG5cdFwiNDc2MlwiLFxuXHRcIjQ3NjNcIixcblx0XCI0NzY0XCIsXG5cdFwiNDc2NVwiLFxuXHRcIjQ3NjZcIixcblx0XCI0NzY3XCIsXG5cdFwiNDc2OFwiLFxuXHRcIjQ3NjlcIixcblx0XCI0NzcwXCIsXG5cdFwiNDc3MVwiLFxuXHRcIjQ3NzJcIixcblx0XCI0NzczXCIsXG5cdFwiNDc3NFwiLFxuXHRcIjQ3NzVcIixcblx0XCI0Nzc2XCIsXG5cdFwiNDc3N1wiLFxuXHRcIjQ3NzhcIixcblx0XCI0Nzc5XCIsXG5cdFwiNDc4MFwiLFxuXHRcIjQ3ODFcIixcblx0XCI0NzgyXCIsXG5cdFwiNDc4M1wiLFxuXHRcIjQ3ODRcIixcblx0XCI0Nzg1XCIsXG5cdFwiNDc4NlwiLFxuXHRcIjQ3ODdcIixcblx0XCI0Nzg4XCIsXG5cdFwiNDc4OVwiLFxuXHRcIjQ3OTBcIixcblx0XCI0NzkxXCIsXG5cdFwiNDc5MlwiLFxuXHRcIjQ3OTNcIixcblx0XCI0Nzk0XCIsXG5cdFwiNDc5NVwiLFxuXHRcIjQ3OTZcIixcblx0XCI0Nzk3XCIsXG5cdFwiNDc5OFwiLFxuXHRcIjQ3OTlcIixcblx0XCI0ODAwXCIsXG5cdFwiNDgwMVwiLFxuXHRcIjQ4MDJcIixcblx0XCI0ODAzXCIsXG5cdFwiNDgwNFwiLFxuXHRcIjQ4MDVcIixcblx0XCI0ODA2XCIsXG5cdFwiNDgwN1wiLFxuXHRcIjQ4MDhcIixcblx0XCI0ODA5XCIsXG5cdFwiNDgxMFwiLFxuXHRcIjQ4MTFcIixcblx0XCI0ODEyXCIsXG5cdFwiNDgxM1wiLFxuXHRcIjQ4MTRcIixcblx0XCI0ODE1XCIsXG5cdFwiNDgxNlwiLFxuXHRcIjQ4MTdcIixcblx0XCI0ODE4XCIsXG5cdFwiNDgxOVwiLFxuXHRcIjQ4MjBcIixcblx0XCI0ODIxXCIsXG5cdFwiNDgyMlwiLFxuXHRcIjQ4MjNcIixcblx0XCI0ODI0XCIsXG5cdFwiNDgzOVwiLFxuXHRcIjQ4NTVcIixcblx0XCI0ODU2XCIsXG5cdFwiNDg1N1wiLFxuXHRcIjQ4NThcIixcblx0XCI0ODU5XCIsXG5cdFwiNDg2MFwiLFxuXHRcIjQ4NjFcIixcblx0XCI0ODYyXCIsXG5cdFwiNDg2M1wiLFxuXHRcIjQ4NjRcIixcblx0XCI0ODY1XCIsXG5cdFwiNDg2NlwiLFxuXHRcIjQ4NjdcIixcblx0XCI0ODY4XCIsXG5cdFwiNDg2OVwiLFxuXHRcIjQ4NzBcIixcblx0XCI0ODcxXCIsXG5cdFwiNDg3MlwiLFxuXHRcIjQ4NzNcIixcblx0XCI0ODc0XCIsXG5cdFwiNDg3NVwiLFxuXHRcIjQ4NzZcIixcblx0XCI0ODc3XCIsXG5cdFwiNDg3OFwiLFxuXHRcIjQ4NzlcIixcblx0XCI0ODgwXCIsXG5cdFwiNDg4M1wiLFxuXHRcIjQ4ODVcIixcblx0XCI0ODg3XCIsXG5cdFwiNDg4OVwiLFxuXHRcIjQ4OTFcIixcblx0XCI0ODkzXCIsXG5cdFwiNDg5NVwiLFxuXHRcIjQ4OThcIixcblx0XCI0OTAwXCIsXG5cdFwiNDkwMVwiLFxuXHRcIjQ5MDJcIixcblx0XCI0OTAzXCIsXG5cdFwiNDkwNFwiLFxuXHRcIjQ5MDdcIixcblx0XCI0OTA5XCIsXG5cdFwiNDkyMVwiLFxuXHRcIjQ5MjNcIixcblx0XCI0OTI1XCIsXG5cdFwiNDkyN1wiLFxuXHRcIjQ5MjlcIixcblx0XCI0OTMxXCIsXG5cdFwiNDkzM1wiLFxuXHRcIjQ5MzVcIixcblx0XCI0OTM3XCIsXG5cdFwiNDkzOVwiLFxuXHRcIjQ5NDFcIixcblx0XCI0OTQzXCIsXG5cdFwiNDk0NVwiLFxuXHRcIjQ5NDdcIixcblx0XCI0OTQ5XCIsXG5cdFwiNDk1MVwiLFxuXHRcIjQ5NTNcIixcblx0XCI0OTU1XCIsXG5cdFwiNDk1N1wiLFxuXHRcIjQ5NTlcIixcblx0XCI0OTYxXCIsXG5cdFwiNDk2M1wiLFxuXHRcIjQ5NjVcIixcblx0XCI0OTY3XCIsXG5cdFwiNDk2OVwiLFxuXHRcIjQ5NzFcIixcblx0XCI0OTczXCIsXG5cdFwiNDk3NVwiLFxuXHRcIjQ5NzdcIixcblx0XCI0OTc5XCIsXG5cdFwiNDk4MVwiLFxuXHRcIjQ5ODNcIixcblx0XCI0OTg1XCIsXG5cdFwiNDk4N1wiLFxuXHRcIjQ5ODlcIixcblx0XCI0OTkxXCIsXG5cdFwiNDk5M1wiLFxuXHRcIjQ5OTVcIixcblx0XCI0OTk3XCIsXG5cdFwiNDk5OVwiLFxuXHRcIjUwMTJcIixcblx0XCI1MDEzXCIsXG5cdFwiNTAxN1wiLFxuXHRcIjUwNDhcIixcblx0XCI1MTA1XCIsXG5cdFwiNTEwNlwiLFxuXHRcIjUxMDdcIixcblx0XCI1MTA4XCIsXG5cdFwiNTEwOVwiLFxuXHRcIjUxMTBcIixcblx0XCI1MTExXCIsXG5cdFwiNTExMlwiLFxuXHRcIjUxMTNcIixcblx0XCI1MTE0XCIsXG5cdFwiNTExNVwiLFxuXHRcIjUxMTZcIixcblx0XCI1MTE3XCIsXG5cdFwiNTExOFwiLFxuXHRcIjUxMTlcIixcblx0XCI1MTIwXCIsXG5cdFwiNTEyMVwiLFxuXHRcIjUxMjJcIixcblx0XCI1MTIzXCIsXG5cdFwiNTEyNFwiLFxuXHRcIjUxMjVcIixcblx0XCI1MTI2XCIsXG5cdFwiNTEyN1wiLFxuXHRcIjUxMjhcIixcblx0XCI1MTI5XCIsXG5cdFwiNTEzMFwiLFxuXHRcIjUxMzJcIixcblx0XCI1MTY3XCIsXG5cdFwiNTE2OFwiLFxuXHRcIjUxNjlcIixcblx0XCI1MTcwXCIsXG5cdFwiNTE3MVwiLFxuXHRcIjUxNzJcIixcblx0XCI1MTczXCIsXG5cdFwiNTE3NFwiLFxuXHRcIjUxNzVcIixcblx0XCI1MTc2XCIsXG5cdFwiNTE3N1wiLFxuXHRcIjUxNzhcIixcblx0XCI1MTc5XCIsXG5cdFwiNTE4MFwiLFxuXHRcIjUxODFcIixcblx0XCI1MTgyXCIsXG5cdFwiNTE4M1wiLFxuXHRcIjUxODRcIixcblx0XCI1MTg1XCIsXG5cdFwiNTE4NlwiLFxuXHRcIjUxODdcIixcblx0XCI1MTg4XCIsXG5cdFwiNTIyNFwiLFxuXHRcIjUyMjhcIixcblx0XCI1MjI5XCIsXG5cdFwiNTIzM1wiLFxuXHRcIjUyNDVcIixcblx0XCI1MjQ2XCIsXG5cdFwiNTI1MVwiLFxuXHRcIjUyNTJcIixcblx0XCI1MjUzXCIsXG5cdFwiNTI1NFwiLFxuXHRcIjUyNTVcIixcblx0XCI1MjU2XCIsXG5cdFwiNTI1N1wiLFxuXHRcIjUyNThcIixcblx0XCI1MjU5XCIsXG5cdFwiNTI2M1wiLFxuXHRcIjUyNjRcIixcblx0XCI1MjY5XCIsXG5cdFwiNTI3MFwiLFxuXHRcIjUyNzFcIixcblx0XCI1MjcyXCIsXG5cdFwiNTI3M1wiLFxuXHRcIjUyNzRcIixcblx0XCI1Mjc1XCIsXG5cdFwiNTgwMVwiLFxuXHRcIjU4MDJcIixcblx0XCI1ODAzXCIsXG5cdFwiNTgwNFwiLFxuXHRcIjU4MDhcIixcblx0XCI1ODA5XCIsXG5cdFwiNTgxMFwiLFxuXHRcIjU4MTFcIixcblx0XCI1ODEyXCIsXG5cdFwiNTgxM1wiLFxuXHRcIjU4MTRcIixcblx0XCI1ODE1XCIsXG5cdFwiNTgxNlwiLFxuXHRcIjIwMDA0XCIsXG5cdFwiMjAwMDVcIixcblx0XCIyMDAwNlwiLFxuXHRcIjIwMDA3XCIsXG5cdFwiMjAwMDhcIixcblx0XCIyMDAwOVwiLFxuXHRcIjIwMDEwXCIsXG5cdFwiMjAwMTFcIixcblx0XCIyMDAxMlwiLFxuXHRcIjIwMDEzXCIsXG5cdFwiMjAwMTRcIixcblx0XCIyMDAxNVwiLFxuXHRcIjIwMDE2XCIsXG5cdFwiMjAwMTdcIixcblx0XCIyMDAxOFwiLFxuXHRcIjIwMDE5XCIsXG5cdFwiMjAwMjBcIixcblx0XCIyMDAyMVwiLFxuXHRcIjIwMDIyXCIsXG5cdFwiMjAwMjNcIixcblx0XCIyMDAyNFwiLFxuXHRcIjIwMDI1XCIsXG5cdFwiMjAwMjZcIixcblx0XCIyMDAyN1wiLFxuXHRcIjIwMDI4XCIsXG5cdFwiMjAwMjlcIixcblx0XCIyMDAzMFwiLFxuXHRcIjIwMDMxXCIsXG5cdFwiMjAwMzJcIixcblx0XCIyMDA2NFwiLFxuXHRcIjIwMDY1XCIsXG5cdFwiMjAwNjZcIixcblx0XCIyMDA2N1wiLFxuXHRcIjIwMDY4XCIsXG5cdFwiMjAwNjlcIixcblx0XCIyMDA3MFwiLFxuXHRcIjIwMDcxXCIsXG5cdFwiMjAwNzJcIixcblx0XCIyMDA3M1wiLFxuXHRcIjIwMDc0XCIsXG5cdFwiMjAwNzVcIixcblx0XCIyMDA3NlwiLFxuXHRcIjIwMDc3XCIsXG5cdFwiMjAwNzhcIixcblx0XCIyMDA3OVwiLFxuXHRcIjIwMDgwXCIsXG5cdFwiMjAwODFcIixcblx0XCIyMDA4MlwiLFxuXHRcIjIwMDgzXCIsXG5cdFwiMjAwODRcIixcblx0XCIyMDA4NVwiLFxuXHRcIjIwMDg2XCIsXG5cdFwiMjAwODdcIixcblx0XCIyMDA4OFwiLFxuXHRcIjIwMDg5XCIsXG5cdFwiMjAwOTBcIixcblx0XCIyMDA5MVwiLFxuXHRcIjIwMDkyXCIsXG5cdFwiMjE0MTNcIixcblx0XCIyMTQxNFwiLFxuXHRcIjIxNDE1XCIsXG5cdFwiMjE0MTZcIixcblx0XCIyMTQxN1wiLFxuXHRcIjIxNDE4XCIsXG5cdFwiMjE0MTlcIixcblx0XCIyMTQyMFwiLFxuXHRcIjIxNDIxXCIsXG5cdFwiMjE0MjJcIixcblx0XCIyMTQyM1wiLFxuXHRcIjIxNDUzXCIsXG5cdFwiMjE0NTRcIixcblx0XCIyMTQ1NVwiLFxuXHRcIjIxNDU2XCIsXG5cdFwiMjE0NTdcIixcblx0XCIyMTQ1OFwiLFxuXHRcIjIxNDU5XCIsXG5cdFwiMjE0NjBcIixcblx0XCIyMTQ2MVwiLFxuXHRcIjIxNDYyXCIsXG5cdFwiMjE0NjNcIixcblx0XCIyMTQ3M1wiLFxuXHRcIjIxNDc0XCIsXG5cdFwiMjE0NzVcIixcblx0XCIyMTQ3NlwiLFxuXHRcIjIxNDc3XCIsXG5cdFwiMjE0NzhcIixcblx0XCIyMTQ3OVwiLFxuXHRcIjIxNDgwXCIsXG5cdFwiMjE0ODFcIixcblx0XCIyMTQ4MlwiLFxuXHRcIjIxNDgzXCIsXG5cdFwiMjE4OTZcIixcblx0XCIyMTg5N1wiLFxuXHRcIjIxODk4XCIsXG5cdFwiMjE4OTlcIixcblx0XCIyMjE3MVwiLFxuXHRcIjIyMTcyXCIsXG5cdFwiMjIxNzNcIixcblx0XCIyMjE3NFwiLFxuXHRcIjIyMTc1XCIsXG5cdFwiMjIxNzZcIixcblx0XCIyMjE3N1wiLFxuXHRcIjIyMTgxXCIsXG5cdFwiMjIxODJcIixcblx0XCIyMjE4M1wiLFxuXHRcIjIyMTg0XCIsXG5cdFwiMjIxODVcIixcblx0XCIyMjE4NlwiLFxuXHRcIjIyMTg3XCIsXG5cdFwiMjIxOTFcIixcblx0XCIyMjE5MlwiLFxuXHRcIjIyMTkzXCIsXG5cdFwiMjIxOTRcIixcblx0XCIyMjE5NVwiLFxuXHRcIjIyMTk2XCIsXG5cdFwiMjIxOTdcIixcblx0XCIyNTg4NFwiLFxuXHRcIjI3MjA1XCIsXG5cdFwiMjcyMDZcIixcblx0XCIyNzIwN1wiLFxuXHRcIjI3MjA4XCIsXG5cdFwiMjcyMDlcIixcblx0XCIyNzIxMFwiLFxuXHRcIjI3MjExXCIsXG5cdFwiMjcyMTJcIixcblx0XCIyNzIxM1wiLFxuXHRcIjI3MjE0XCIsXG5cdFwiMjcyMTVcIixcblx0XCIyNzIxNlwiLFxuXHRcIjI3MjE3XCIsXG5cdFwiMjcyMThcIixcblx0XCIyNzIxOVwiLFxuXHRcIjI3MjIwXCIsXG5cdFwiMjcyMjFcIixcblx0XCIyNzIyMlwiLFxuXHRcIjI3MjIzXCIsXG5cdFwiMjcyMjRcIixcblx0XCIyNzIyNVwiLFxuXHRcIjI3MjI2XCIsXG5cdFwiMjcyMjdcIixcblx0XCIyNzIyOFwiLFxuXHRcIjI3MjI5XCIsXG5cdFwiMjcyMzBcIixcblx0XCIyNzIzMVwiLFxuXHRcIjI3MjMyXCIsXG5cdFwiMjczOTFcIixcblx0XCIyNzM5MlwiLFxuXHRcIjI3MzkzXCIsXG5cdFwiMjczOTRcIixcblx0XCIyNzM5NVwiLFxuXHRcIjI3Mzk2XCIsXG5cdFwiMjczOTdcIixcblx0XCIyNzM5OFwiLFxuXHRcIjI3NDkyXCIsXG5cdFwiMjg0MDJcIixcblx0XCIyODQwM1wiLFxuXHRcIjI4NDA0XCIsXG5cdFwiMjg0MDVcIixcblx0XCIyODQwNlwiLFxuXHRcIjI4NDA3XCIsXG5cdFwiMjg0MDhcIixcblx0XCIyODQwOVwiLFxuXHRcIjI4NDEwXCIsXG5cdFwiMjg0MTFcIixcblx0XCIyODQxMlwiLFxuXHRcIjI4NDEzXCIsXG5cdFwiMjg0MTRcIixcblx0XCIyODQxNVwiLFxuXHRcIjI4NDE2XCIsXG5cdFwiMjg0MTdcIixcblx0XCIyODQxOFwiLFxuXHRcIjI4NDE5XCIsXG5cdFwiMjg0MjBcIixcblx0XCIyODQyMVwiLFxuXHRcIjI4NDIyXCIsXG5cdFwiMjg0MjNcIixcblx0XCIyODQyNFwiLFxuXHRcIjI4NDI1XCIsXG5cdFwiMjg0MjZcIixcblx0XCIyODQyN1wiLFxuXHRcIjI4NDI4XCIsXG5cdFwiMjg0MjlcIixcblx0XCIyODQzMFwiLFxuXHRcIjI4NDMxXCIsXG5cdFwiMjg0MzJcIixcblx0XCIyODQ2MlwiLFxuXHRcIjI4NDYzXCIsXG5cdFwiMjg0NjRcIixcblx0XCIyODQ2NVwiLFxuXHRcIjI4NDY2XCIsXG5cdFwiMjg0NjdcIixcblx0XCIyODQ2OFwiLFxuXHRcIjI4NDY5XCIsXG5cdFwiMjg0NzBcIixcblx0XCIyODQ3MVwiLFxuXHRcIjI4NDcyXCIsXG5cdFwiMjg0NzNcIixcblx0XCIyODQ3NFwiLFxuXHRcIjI4NDc1XCIsXG5cdFwiMjg0NzZcIixcblx0XCIyODQ3N1wiLFxuXHRcIjI4NDc4XCIsXG5cdFwiMjg0NzlcIixcblx0XCIyODQ4MFwiLFxuXHRcIjI4NDgxXCIsXG5cdFwiMjg0ODJcIixcblx0XCIyODQ4M1wiLFxuXHRcIjI4NDg0XCIsXG5cdFwiMjg0ODVcIixcblx0XCIyODQ4NlwiLFxuXHRcIjI4NDg3XCIsXG5cdFwiMjg0ODhcIixcblx0XCIyODQ4OVwiLFxuXHRcIjI4NDkwXCIsXG5cdFwiMjg0OTFcIixcblx0XCIyODQ5MlwiLFxuXHRcIjI5NzAxXCIsXG5cdFwiMjk3MDJcIixcblx0XCIzMDE2MVwiLFxuXHRcIjMwMTYyXCIsXG5cdFwiMzAxNjNcIixcblx0XCIzMDE2NFwiLFxuXHRcIjMwMTY1XCIsXG5cdFwiMzAxNjZcIixcblx0XCIzMDE2N1wiLFxuXHRcIjMwMTY4XCIsXG5cdFwiMzAxNjlcIixcblx0XCIzMDE3MFwiLFxuXHRcIjMwMTcxXCIsXG5cdFwiMzAxNzJcIixcblx0XCIzMDE3M1wiLFxuXHRcIjMwMTc0XCIsXG5cdFwiMzAxNzVcIixcblx0XCIzMDE3NlwiLFxuXHRcIjMwMTc3XCIsXG5cdFwiMzAxNzhcIixcblx0XCIzMDE3OVwiLFxuXHRcIjMwODAwXCIsXG5cdFwiMzEyNTFcIixcblx0XCIzMTI1MlwiLFxuXHRcIjMxMjUzXCIsXG5cdFwiMzEyNTRcIixcblx0XCIzMTI1NVwiLFxuXHRcIjMxMjU2XCIsXG5cdFwiMzEyNTdcIixcblx0XCIzMTI1OFwiLFxuXHRcIjMxMjU5XCIsXG5cdFwiMzEyNzVcIixcblx0XCIzMTI3NlwiLFxuXHRcIjMxMjc3XCIsXG5cdFwiMzEyNzhcIixcblx0XCIzMTI3OVwiLFxuXHRcIjMxMjgxXCIsXG5cdFwiMzEyODJcIixcblx0XCIzMTI4M1wiLFxuXHRcIjMxMjg0XCIsXG5cdFwiMzEyODVcIixcblx0XCIzMTI4NlwiLFxuXHRcIjMxMjg3XCIsXG5cdFwiMzEyODhcIixcblx0XCIzMTI4OVwiLFxuXHRcIjMxMjkwXCIsXG5cdFwiMzE0NjZcIixcblx0XCIzMTcwMFwiXG5dO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2xheWVyL3JldmVyc2VkQXhpcy5qc29uXG4vLyBtb2R1bGUgaWQgPSAxNzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports){eval('module.exports = require("fs");//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJmc1wiPzJlMDkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiMTc1LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZnNcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJmc1wiXG4vLyBtb2R1bGUgaWQgPSAxNzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==')},function(module,exports){eval('module.exports = require("http");//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJodHRwXCI/OGU0NCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIxNzYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJodHRwXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiaHR0cFwiXG4vLyBtb2R1bGUgaWQgPSAxNzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==')}]);